
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:42.870] plan(): Setting new future strategy stack:
[10:21:42.870] List of future strategies:
[10:21:42.870] 1. sequential:
[10:21:42.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:42.870]    - tweaked: FALSE
[10:21:42.870]    - call: future::plan("sequential")
[10:21:42.884] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[10:21:42.979] plan(): Setting new future strategy stack:
[10:21:42.979] List of future strategies:
[10:21:42.979] 1. sequential:
[10:21:42.979]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:42.979]    - tweaked: FALSE
[10:21:42.979]    - call: plan(strategy)
[10:21:42.991] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:42.993] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:42.993] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:42.999] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:21:42.999] Searching for globals ... DONE
[10:21:42.999] Resolving globals: TRUE
[10:21:42.999] Resolving any globals that are futures ...
[10:21:42.999] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:21:42.999] Resolving any globals that are futures ... DONE
[10:21:43.000] 
[10:21:43.000] 
[10:21:43.000] getGlobalsAndPackages() ... DONE
[10:21:43.000] run() for ‘Future’ ...
[10:21:43.001] - state: ‘created’
[10:21:43.001] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.001] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.001] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.001]   - Field: ‘label’
[10:21:43.001]   - Field: ‘local’
[10:21:43.002]   - Field: ‘owner’
[10:21:43.002]   - Field: ‘envir’
[10:21:43.002]   - Field: ‘packages’
[10:21:43.002]   - Field: ‘gc’
[10:21:43.002]   - Field: ‘conditions’
[10:21:43.002]   - Field: ‘expr’
[10:21:43.002]   - Field: ‘uuid’
[10:21:43.002]   - Field: ‘seed’
[10:21:43.002]   - Field: ‘version’
[10:21:43.002]   - Field: ‘result’
[10:21:43.002]   - Field: ‘asynchronous’
[10:21:43.002]   - Field: ‘calls’
[10:21:43.003]   - Field: ‘globals’
[10:21:43.003]   - Field: ‘stdout’
[10:21:43.003]   - Field: ‘earlySignal’
[10:21:43.003]   - Field: ‘lazy’
[10:21:43.003]   - Field: ‘state’
[10:21:43.003] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.003] - Launch lazy future ...
[10:21:43.004] Packages needed by the future expression (n = 0): <none>
[10:21:43.004] Packages needed by future strategies (n = 0): <none>
[10:21:43.005] {
[10:21:43.005]     {
[10:21:43.005]         {
[10:21:43.005]             ...future.startTime <- base::Sys.time()
[10:21:43.005]             {
[10:21:43.005]                 {
[10:21:43.005]                   {
[10:21:43.005]                     base::local({
[10:21:43.005]                       has_future <- base::requireNamespace("future", 
[10:21:43.005]                         quietly = TRUE)
[10:21:43.005]                       if (has_future) {
[10:21:43.005]                         ns <- base::getNamespace("future")
[10:21:43.005]                         version <- ns[[".package"]][["version"]]
[10:21:43.005]                         if (is.null(version)) 
[10:21:43.005]                           version <- utils::packageVersion("future")
[10:21:43.005]                       }
[10:21:43.005]                       else {
[10:21:43.005]                         version <- NULL
[10:21:43.005]                       }
[10:21:43.005]                       if (!has_future || version < "1.8.0") {
[10:21:43.005]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.005]                           "", base::R.version$version.string), 
[10:21:43.005]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.005]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.005]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.005]                             "release", "version")], collapse = " "), 
[10:21:43.005]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.005]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.005]                           info)
[10:21:43.005]                         info <- base::paste(info, collapse = "; ")
[10:21:43.005]                         if (!has_future) {
[10:21:43.005]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.005]                             info)
[10:21:43.005]                         }
[10:21:43.005]                         else {
[10:21:43.005]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.005]                             info, version)
[10:21:43.005]                         }
[10:21:43.005]                         base::stop(msg)
[10:21:43.005]                       }
[10:21:43.005]                     })
[10:21:43.005]                   }
[10:21:43.005]                   ...future.strategy.old <- future::plan("list")
[10:21:43.005]                   options(future.plan = NULL)
[10:21:43.005]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.005]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.005]                 }
[10:21:43.005]                 ...future.workdir <- getwd()
[10:21:43.005]             }
[10:21:43.005]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.005]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.005]         }
[10:21:43.005]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.005]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.005]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.005]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.005]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.005]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.005]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.005]             base::names(...future.oldOptions))
[10:21:43.005]     }
[10:21:43.005]     if (FALSE) {
[10:21:43.005]     }
[10:21:43.005]     else {
[10:21:43.005]         if (TRUE) {
[10:21:43.005]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.005]                 open = "w")
[10:21:43.005]         }
[10:21:43.005]         else {
[10:21:43.005]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.005]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.005]         }
[10:21:43.005]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.005]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.005]             base::sink(type = "output", split = FALSE)
[10:21:43.005]             base::close(...future.stdout)
[10:21:43.005]         }, add = TRUE)
[10:21:43.005]     }
[10:21:43.005]     ...future.frame <- base::sys.nframe()
[10:21:43.005]     ...future.conditions <- base::list()
[10:21:43.005]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.005]     if (FALSE) {
[10:21:43.005]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.005]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.005]     }
[10:21:43.005]     ...future.result <- base::tryCatch({
[10:21:43.005]         base::withCallingHandlers({
[10:21:43.005]             ...future.value <- base::withVisible(base::local({
[10:21:43.005]                 b <- a
[10:21:43.005]                 a <- 2
[10:21:43.005]                 a * b
[10:21:43.005]             }))
[10:21:43.005]             future::FutureResult(value = ...future.value$value, 
[10:21:43.005]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.005]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.005]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.005]                     ...future.globalenv.names))
[10:21:43.005]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.005]         }, condition = base::local({
[10:21:43.005]             c <- base::c
[10:21:43.005]             inherits <- base::inherits
[10:21:43.005]             invokeRestart <- base::invokeRestart
[10:21:43.005]             length <- base::length
[10:21:43.005]             list <- base::list
[10:21:43.005]             seq.int <- base::seq.int
[10:21:43.005]             signalCondition <- base::signalCondition
[10:21:43.005]             sys.calls <- base::sys.calls
[10:21:43.005]             `[[` <- base::`[[`
[10:21:43.005]             `+` <- base::`+`
[10:21:43.005]             `<<-` <- base::`<<-`
[10:21:43.005]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.005]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.005]                   3L)]
[10:21:43.005]             }
[10:21:43.005]             function(cond) {
[10:21:43.005]                 is_error <- inherits(cond, "error")
[10:21:43.005]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.005]                   NULL)
[10:21:43.005]                 if (is_error) {
[10:21:43.005]                   sessionInformation <- function() {
[10:21:43.005]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.005]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.005]                       search = base::search(), system = base::Sys.info())
[10:21:43.005]                   }
[10:21:43.005]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.005]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.005]                     cond$call), session = sessionInformation(), 
[10:21:43.005]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.005]                   signalCondition(cond)
[10:21:43.005]                 }
[10:21:43.005]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.005]                 "immediateCondition"))) {
[10:21:43.005]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.005]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.005]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.005]                   if (TRUE && !signal) {
[10:21:43.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.005]                     {
[10:21:43.005]                       inherits <- base::inherits
[10:21:43.005]                       invokeRestart <- base::invokeRestart
[10:21:43.005]                       is.null <- base::is.null
[10:21:43.005]                       muffled <- FALSE
[10:21:43.005]                       if (inherits(cond, "message")) {
[10:21:43.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.005]                         if (muffled) 
[10:21:43.005]                           invokeRestart("muffleMessage")
[10:21:43.005]                       }
[10:21:43.005]                       else if (inherits(cond, "warning")) {
[10:21:43.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.005]                         if (muffled) 
[10:21:43.005]                           invokeRestart("muffleWarning")
[10:21:43.005]                       }
[10:21:43.005]                       else if (inherits(cond, "condition")) {
[10:21:43.005]                         if (!is.null(pattern)) {
[10:21:43.005]                           computeRestarts <- base::computeRestarts
[10:21:43.005]                           grepl <- base::grepl
[10:21:43.005]                           restarts <- computeRestarts(cond)
[10:21:43.005]                           for (restart in restarts) {
[10:21:43.005]                             name <- restart$name
[10:21:43.005]                             if (is.null(name)) 
[10:21:43.005]                               next
[10:21:43.005]                             if (!grepl(pattern, name)) 
[10:21:43.005]                               next
[10:21:43.005]                             invokeRestart(restart)
[10:21:43.005]                             muffled <- TRUE
[10:21:43.005]                             break
[10:21:43.005]                           }
[10:21:43.005]                         }
[10:21:43.005]                       }
[10:21:43.005]                       invisible(muffled)
[10:21:43.005]                     }
[10:21:43.005]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.005]                   }
[10:21:43.005]                 }
[10:21:43.005]                 else {
[10:21:43.005]                   if (TRUE) {
[10:21:43.005]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.005]                     {
[10:21:43.005]                       inherits <- base::inherits
[10:21:43.005]                       invokeRestart <- base::invokeRestart
[10:21:43.005]                       is.null <- base::is.null
[10:21:43.005]                       muffled <- FALSE
[10:21:43.005]                       if (inherits(cond, "message")) {
[10:21:43.005]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.005]                         if (muffled) 
[10:21:43.005]                           invokeRestart("muffleMessage")
[10:21:43.005]                       }
[10:21:43.005]                       else if (inherits(cond, "warning")) {
[10:21:43.005]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.005]                         if (muffled) 
[10:21:43.005]                           invokeRestart("muffleWarning")
[10:21:43.005]                       }
[10:21:43.005]                       else if (inherits(cond, "condition")) {
[10:21:43.005]                         if (!is.null(pattern)) {
[10:21:43.005]                           computeRestarts <- base::computeRestarts
[10:21:43.005]                           grepl <- base::grepl
[10:21:43.005]                           restarts <- computeRestarts(cond)
[10:21:43.005]                           for (restart in restarts) {
[10:21:43.005]                             name <- restart$name
[10:21:43.005]                             if (is.null(name)) 
[10:21:43.005]                               next
[10:21:43.005]                             if (!grepl(pattern, name)) 
[10:21:43.005]                               next
[10:21:43.005]                             invokeRestart(restart)
[10:21:43.005]                             muffled <- TRUE
[10:21:43.005]                             break
[10:21:43.005]                           }
[10:21:43.005]                         }
[10:21:43.005]                       }
[10:21:43.005]                       invisible(muffled)
[10:21:43.005]                     }
[10:21:43.005]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.005]                   }
[10:21:43.005]                 }
[10:21:43.005]             }
[10:21:43.005]         }))
[10:21:43.005]     }, error = function(ex) {
[10:21:43.005]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.005]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.005]                 ...future.rng), started = ...future.startTime, 
[10:21:43.005]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.005]             version = "1.8"), class = "FutureResult")
[10:21:43.005]     }, finally = {
[10:21:43.005]         if (!identical(...future.workdir, getwd())) 
[10:21:43.005]             setwd(...future.workdir)
[10:21:43.005]         {
[10:21:43.005]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.005]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.005]             }
[10:21:43.005]             base::options(...future.oldOptions)
[10:21:43.005]             if (.Platform$OS.type == "windows") {
[10:21:43.005]                 old_names <- names(...future.oldEnvVars)
[10:21:43.005]                 envs <- base::Sys.getenv()
[10:21:43.005]                 names <- names(envs)
[10:21:43.005]                 common <- intersect(names, old_names)
[10:21:43.005]                 added <- setdiff(names, old_names)
[10:21:43.005]                 removed <- setdiff(old_names, names)
[10:21:43.005]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.005]                   envs[common]]
[10:21:43.005]                 NAMES <- toupper(changed)
[10:21:43.005]                 args <- list()
[10:21:43.005]                 for (kk in seq_along(NAMES)) {
[10:21:43.005]                   name <- changed[[kk]]
[10:21:43.005]                   NAME <- NAMES[[kk]]
[10:21:43.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.005]                     next
[10:21:43.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.005]                 }
[10:21:43.005]                 NAMES <- toupper(added)
[10:21:43.005]                 for (kk in seq_along(NAMES)) {
[10:21:43.005]                   name <- added[[kk]]
[10:21:43.005]                   NAME <- NAMES[[kk]]
[10:21:43.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.005]                     next
[10:21:43.005]                   args[[name]] <- ""
[10:21:43.005]                 }
[10:21:43.005]                 NAMES <- toupper(removed)
[10:21:43.005]                 for (kk in seq_along(NAMES)) {
[10:21:43.005]                   name <- removed[[kk]]
[10:21:43.005]                   NAME <- NAMES[[kk]]
[10:21:43.005]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.005]                     next
[10:21:43.005]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.005]                 }
[10:21:43.005]                 if (length(args) > 0) 
[10:21:43.005]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.005]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.005]             }
[10:21:43.005]             else {
[10:21:43.005]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.005]             }
[10:21:43.005]             {
[10:21:43.005]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.005]                   0L) {
[10:21:43.005]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.005]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.005]                   base::options(opts)
[10:21:43.005]                 }
[10:21:43.005]                 {
[10:21:43.005]                   {
[10:21:43.005]                     NULL
[10:21:43.005]                     RNGkind("Mersenne-Twister")
[10:21:43.005]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.005]                       inherits = FALSE)
[10:21:43.005]                   }
[10:21:43.005]                   options(future.plan = NULL)
[10:21:43.005]                   if (is.na(NA_character_)) 
[10:21:43.005]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.005]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.005]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.005]                     .init = FALSE)
[10:21:43.005]                 }
[10:21:43.005]             }
[10:21:43.005]         }
[10:21:43.005]     })
[10:21:43.005]     if (TRUE) {
[10:21:43.005]         base::sink(type = "output", split = FALSE)
[10:21:43.005]         if (TRUE) {
[10:21:43.005]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.005]         }
[10:21:43.005]         else {
[10:21:43.005]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.005]         }
[10:21:43.005]         base::close(...future.stdout)
[10:21:43.005]         ...future.stdout <- NULL
[10:21:43.005]     }
[10:21:43.005]     ...future.result$conditions <- ...future.conditions
[10:21:43.005]     ...future.result$finished <- base::Sys.time()
[10:21:43.005]     ...future.result
[10:21:43.005] }
[10:21:43.006] plan(): Setting new future strategy stack:
[10:21:43.007] List of future strategies:
[10:21:43.007] 1. sequential:
[10:21:43.007]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.007]    - tweaked: FALSE
[10:21:43.007]    - call: NULL
[10:21:43.007] plan(): nbrOfWorkers() = 1
[10:21:43.008] plan(): Setting new future strategy stack:
[10:21:43.008] List of future strategies:
[10:21:43.008] 1. sequential:
[10:21:43.008]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.008]    - tweaked: FALSE
[10:21:43.008]    - call: plan(strategy)
[10:21:43.009] plan(): nbrOfWorkers() = 1
[10:21:43.009] SequentialFuture started (and completed)
[10:21:43.009] - Launch lazy future ... done
[10:21:43.009] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.010] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.010] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.012] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:21:43.012] Searching for globals ... DONE
[10:21:43.012] Resolving globals: TRUE
[10:21:43.012] Resolving any globals that are futures ...
[10:21:43.012] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:21:43.012] Resolving any globals that are futures ... DONE
[10:21:43.012] 
[10:21:43.012] 
[10:21:43.012] getGlobalsAndPackages() ... DONE
[10:21:43.013] run() for ‘Future’ ...
[10:21:43.013] - state: ‘created’
[10:21:43.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.015] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.015] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.015]   - Field: ‘label’
[10:21:43.015]   - Field: ‘local’
[10:21:43.016]   - Field: ‘owner’
[10:21:43.016]   - Field: ‘envir’
[10:21:43.016]   - Field: ‘packages’
[10:21:43.016]   - Field: ‘gc’
[10:21:43.016]   - Field: ‘conditions’
[10:21:43.016]   - Field: ‘expr’
[10:21:43.016]   - Field: ‘uuid’
[10:21:43.016]   - Field: ‘seed’
[10:21:43.016]   - Field: ‘version’
[10:21:43.016]   - Field: ‘result’
[10:21:43.016]   - Field: ‘asynchronous’
[10:21:43.016]   - Field: ‘calls’
[10:21:43.017]   - Field: ‘globals’
[10:21:43.017]   - Field: ‘stdout’
[10:21:43.017]   - Field: ‘earlySignal’
[10:21:43.017]   - Field: ‘lazy’
[10:21:43.017]   - Field: ‘state’
[10:21:43.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.017] - Launch lazy future ...
[10:21:43.017] Packages needed by the future expression (n = 0): <none>
[10:21:43.017] Packages needed by future strategies (n = 0): <none>
[10:21:43.018] {
[10:21:43.018]     {
[10:21:43.018]         {
[10:21:43.018]             ...future.startTime <- base::Sys.time()
[10:21:43.018]             {
[10:21:43.018]                 {
[10:21:43.018]                   {
[10:21:43.018]                     base::local({
[10:21:43.018]                       has_future <- base::requireNamespace("future", 
[10:21:43.018]                         quietly = TRUE)
[10:21:43.018]                       if (has_future) {
[10:21:43.018]                         ns <- base::getNamespace("future")
[10:21:43.018]                         version <- ns[[".package"]][["version"]]
[10:21:43.018]                         if (is.null(version)) 
[10:21:43.018]                           version <- utils::packageVersion("future")
[10:21:43.018]                       }
[10:21:43.018]                       else {
[10:21:43.018]                         version <- NULL
[10:21:43.018]                       }
[10:21:43.018]                       if (!has_future || version < "1.8.0") {
[10:21:43.018]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.018]                           "", base::R.version$version.string), 
[10:21:43.018]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.018]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.018]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.018]                             "release", "version")], collapse = " "), 
[10:21:43.018]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.018]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.018]                           info)
[10:21:43.018]                         info <- base::paste(info, collapse = "; ")
[10:21:43.018]                         if (!has_future) {
[10:21:43.018]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.018]                             info)
[10:21:43.018]                         }
[10:21:43.018]                         else {
[10:21:43.018]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.018]                             info, version)
[10:21:43.018]                         }
[10:21:43.018]                         base::stop(msg)
[10:21:43.018]                       }
[10:21:43.018]                     })
[10:21:43.018]                   }
[10:21:43.018]                   ...future.strategy.old <- future::plan("list")
[10:21:43.018]                   options(future.plan = NULL)
[10:21:43.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.018]                 }
[10:21:43.018]                 ...future.workdir <- getwd()
[10:21:43.018]             }
[10:21:43.018]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.018]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.018]         }
[10:21:43.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.018]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.018]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.018]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.018]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.018]             base::names(...future.oldOptions))
[10:21:43.018]     }
[10:21:43.018]     if (FALSE) {
[10:21:43.018]     }
[10:21:43.018]     else {
[10:21:43.018]         if (TRUE) {
[10:21:43.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.018]                 open = "w")
[10:21:43.018]         }
[10:21:43.018]         else {
[10:21:43.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.018]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.018]         }
[10:21:43.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.018]             base::sink(type = "output", split = FALSE)
[10:21:43.018]             base::close(...future.stdout)
[10:21:43.018]         }, add = TRUE)
[10:21:43.018]     }
[10:21:43.018]     ...future.frame <- base::sys.nframe()
[10:21:43.018]     ...future.conditions <- base::list()
[10:21:43.018]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.018]     if (FALSE) {
[10:21:43.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.018]     }
[10:21:43.018]     ...future.result <- base::tryCatch({
[10:21:43.018]         base::withCallingHandlers({
[10:21:43.018]             ...future.value <- base::withVisible(base::local({
[10:21:43.018]                 b <- a
[10:21:43.018]                 a <- 2
[10:21:43.018]                 a * b
[10:21:43.018]             }))
[10:21:43.018]             future::FutureResult(value = ...future.value$value, 
[10:21:43.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.018]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.018]                     ...future.globalenv.names))
[10:21:43.018]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.018]         }, condition = base::local({
[10:21:43.018]             c <- base::c
[10:21:43.018]             inherits <- base::inherits
[10:21:43.018]             invokeRestart <- base::invokeRestart
[10:21:43.018]             length <- base::length
[10:21:43.018]             list <- base::list
[10:21:43.018]             seq.int <- base::seq.int
[10:21:43.018]             signalCondition <- base::signalCondition
[10:21:43.018]             sys.calls <- base::sys.calls
[10:21:43.018]             `[[` <- base::`[[`
[10:21:43.018]             `+` <- base::`+`
[10:21:43.018]             `<<-` <- base::`<<-`
[10:21:43.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.018]                   3L)]
[10:21:43.018]             }
[10:21:43.018]             function(cond) {
[10:21:43.018]                 is_error <- inherits(cond, "error")
[10:21:43.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.018]                   NULL)
[10:21:43.018]                 if (is_error) {
[10:21:43.018]                   sessionInformation <- function() {
[10:21:43.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.018]                       search = base::search(), system = base::Sys.info())
[10:21:43.018]                   }
[10:21:43.018]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.018]                     cond$call), session = sessionInformation(), 
[10:21:43.018]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.018]                   signalCondition(cond)
[10:21:43.018]                 }
[10:21:43.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.018]                 "immediateCondition"))) {
[10:21:43.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.018]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.018]                   if (TRUE && !signal) {
[10:21:43.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.018]                     {
[10:21:43.018]                       inherits <- base::inherits
[10:21:43.018]                       invokeRestart <- base::invokeRestart
[10:21:43.018]                       is.null <- base::is.null
[10:21:43.018]                       muffled <- FALSE
[10:21:43.018]                       if (inherits(cond, "message")) {
[10:21:43.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.018]                         if (muffled) 
[10:21:43.018]                           invokeRestart("muffleMessage")
[10:21:43.018]                       }
[10:21:43.018]                       else if (inherits(cond, "warning")) {
[10:21:43.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.018]                         if (muffled) 
[10:21:43.018]                           invokeRestart("muffleWarning")
[10:21:43.018]                       }
[10:21:43.018]                       else if (inherits(cond, "condition")) {
[10:21:43.018]                         if (!is.null(pattern)) {
[10:21:43.018]                           computeRestarts <- base::computeRestarts
[10:21:43.018]                           grepl <- base::grepl
[10:21:43.018]                           restarts <- computeRestarts(cond)
[10:21:43.018]                           for (restart in restarts) {
[10:21:43.018]                             name <- restart$name
[10:21:43.018]                             if (is.null(name)) 
[10:21:43.018]                               next
[10:21:43.018]                             if (!grepl(pattern, name)) 
[10:21:43.018]                               next
[10:21:43.018]                             invokeRestart(restart)
[10:21:43.018]                             muffled <- TRUE
[10:21:43.018]                             break
[10:21:43.018]                           }
[10:21:43.018]                         }
[10:21:43.018]                       }
[10:21:43.018]                       invisible(muffled)
[10:21:43.018]                     }
[10:21:43.018]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.018]                   }
[10:21:43.018]                 }
[10:21:43.018]                 else {
[10:21:43.018]                   if (TRUE) {
[10:21:43.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.018]                     {
[10:21:43.018]                       inherits <- base::inherits
[10:21:43.018]                       invokeRestart <- base::invokeRestart
[10:21:43.018]                       is.null <- base::is.null
[10:21:43.018]                       muffled <- FALSE
[10:21:43.018]                       if (inherits(cond, "message")) {
[10:21:43.018]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.018]                         if (muffled) 
[10:21:43.018]                           invokeRestart("muffleMessage")
[10:21:43.018]                       }
[10:21:43.018]                       else if (inherits(cond, "warning")) {
[10:21:43.018]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.018]                         if (muffled) 
[10:21:43.018]                           invokeRestart("muffleWarning")
[10:21:43.018]                       }
[10:21:43.018]                       else if (inherits(cond, "condition")) {
[10:21:43.018]                         if (!is.null(pattern)) {
[10:21:43.018]                           computeRestarts <- base::computeRestarts
[10:21:43.018]                           grepl <- base::grepl
[10:21:43.018]                           restarts <- computeRestarts(cond)
[10:21:43.018]                           for (restart in restarts) {
[10:21:43.018]                             name <- restart$name
[10:21:43.018]                             if (is.null(name)) 
[10:21:43.018]                               next
[10:21:43.018]                             if (!grepl(pattern, name)) 
[10:21:43.018]                               next
[10:21:43.018]                             invokeRestart(restart)
[10:21:43.018]                             muffled <- TRUE
[10:21:43.018]                             break
[10:21:43.018]                           }
[10:21:43.018]                         }
[10:21:43.018]                       }
[10:21:43.018]                       invisible(muffled)
[10:21:43.018]                     }
[10:21:43.018]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.018]                   }
[10:21:43.018]                 }
[10:21:43.018]             }
[10:21:43.018]         }))
[10:21:43.018]     }, error = function(ex) {
[10:21:43.018]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.018]                 ...future.rng), started = ...future.startTime, 
[10:21:43.018]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.018]             version = "1.8"), class = "FutureResult")
[10:21:43.018]     }, finally = {
[10:21:43.018]         if (!identical(...future.workdir, getwd())) 
[10:21:43.018]             setwd(...future.workdir)
[10:21:43.018]         {
[10:21:43.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.018]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.018]             }
[10:21:43.018]             base::options(...future.oldOptions)
[10:21:43.018]             if (.Platform$OS.type == "windows") {
[10:21:43.018]                 old_names <- names(...future.oldEnvVars)
[10:21:43.018]                 envs <- base::Sys.getenv()
[10:21:43.018]                 names <- names(envs)
[10:21:43.018]                 common <- intersect(names, old_names)
[10:21:43.018]                 added <- setdiff(names, old_names)
[10:21:43.018]                 removed <- setdiff(old_names, names)
[10:21:43.018]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.018]                   envs[common]]
[10:21:43.018]                 NAMES <- toupper(changed)
[10:21:43.018]                 args <- list()
[10:21:43.018]                 for (kk in seq_along(NAMES)) {
[10:21:43.018]                   name <- changed[[kk]]
[10:21:43.018]                   NAME <- NAMES[[kk]]
[10:21:43.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.018]                     next
[10:21:43.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.018]                 }
[10:21:43.018]                 NAMES <- toupper(added)
[10:21:43.018]                 for (kk in seq_along(NAMES)) {
[10:21:43.018]                   name <- added[[kk]]
[10:21:43.018]                   NAME <- NAMES[[kk]]
[10:21:43.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.018]                     next
[10:21:43.018]                   args[[name]] <- ""
[10:21:43.018]                 }
[10:21:43.018]                 NAMES <- toupper(removed)
[10:21:43.018]                 for (kk in seq_along(NAMES)) {
[10:21:43.018]                   name <- removed[[kk]]
[10:21:43.018]                   NAME <- NAMES[[kk]]
[10:21:43.018]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.018]                     next
[10:21:43.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.018]                 }
[10:21:43.018]                 if (length(args) > 0) 
[10:21:43.018]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.018]             }
[10:21:43.018]             else {
[10:21:43.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.018]             }
[10:21:43.018]             {
[10:21:43.018]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.018]                   0L) {
[10:21:43.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.018]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.018]                   base::options(opts)
[10:21:43.018]                 }
[10:21:43.018]                 {
[10:21:43.018]                   {
[10:21:43.018]                     NULL
[10:21:43.018]                     RNGkind("Mersenne-Twister")
[10:21:43.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.018]                       inherits = FALSE)
[10:21:43.018]                   }
[10:21:43.018]                   options(future.plan = NULL)
[10:21:43.018]                   if (is.na(NA_character_)) 
[10:21:43.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.018]                     .init = FALSE)
[10:21:43.018]                 }
[10:21:43.018]             }
[10:21:43.018]         }
[10:21:43.018]     })
[10:21:43.018]     if (TRUE) {
[10:21:43.018]         base::sink(type = "output", split = FALSE)
[10:21:43.018]         if (TRUE) {
[10:21:43.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.018]         }
[10:21:43.018]         else {
[10:21:43.018]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.018]         }
[10:21:43.018]         base::close(...future.stdout)
[10:21:43.018]         ...future.stdout <- NULL
[10:21:43.018]     }
[10:21:43.018]     ...future.result$conditions <- ...future.conditions
[10:21:43.018]     ...future.result$finished <- base::Sys.time()
[10:21:43.018]     ...future.result
[10:21:43.018] }
[10:21:43.020] plan(): Setting new future strategy stack:
[10:21:43.020] List of future strategies:
[10:21:43.020] 1. sequential:
[10:21:43.020]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.020]    - tweaked: FALSE
[10:21:43.020]    - call: NULL
[10:21:43.020] plan(): nbrOfWorkers() = 1
[10:21:43.021] plan(): Setting new future strategy stack:
[10:21:43.021] List of future strategies:
[10:21:43.021] 1. sequential:
[10:21:43.021]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.021]    - tweaked: FALSE
[10:21:43.021]    - call: plan(strategy)
[10:21:43.021] plan(): nbrOfWorkers() = 1
[10:21:43.022] SequentialFuture started (and completed)
[10:21:43.022] signalConditions() ...
[10:21:43.022]  - include = ‘immediateCondition’
[10:21:43.022]  - exclude = 
[10:21:43.022]  - resignal = FALSE
[10:21:43.022]  - Number of conditions: 1
[10:21:43.022] signalConditions() ... done
[10:21:43.022] - Launch lazy future ... done
[10:21:43.022] run() for ‘SequentialFuture’ ... done
[10:21:43.022] signalConditions() ...
[10:21:43.022]  - include = ‘immediateCondition’
[10:21:43.023]  - exclude = 
[10:21:43.023]  - resignal = FALSE
[10:21:43.023]  - Number of conditions: 1
[10:21:43.023] signalConditions() ... done
[10:21:43.023] Future state: ‘finished’
[10:21:43.023] signalConditions() ...
[10:21:43.023]  - include = ‘condition’
[10:21:43.023]  - exclude = ‘immediateCondition’
[10:21:43.023]  - resignal = TRUE
[10:21:43.023]  - Number of conditions: 1
[10:21:43.023]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:43.024] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:43"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.038] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.038] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.039] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.039] Searching for globals ... DONE
[10:21:43.040] Resolving globals: TRUE
[10:21:43.040] Resolving any globals that are futures ...
[10:21:43.040] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.040] Resolving any globals that are futures ... DONE
[10:21:43.040] Resolving futures part of globals (recursively) ...
[10:21:43.041] resolve() on list ...
[10:21:43.041]  recursive: 99
[10:21:43.041]  length: 1
[10:21:43.041]  elements: ‘ii’
[10:21:43.041]  length: 0 (resolved future 1)
[10:21:43.041] resolve() on list ... DONE
[10:21:43.042] - globals: [1] ‘ii’
[10:21:43.043] Resolving futures part of globals (recursively) ... DONE
[10:21:43.044] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.044] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.044] - globals: [1] ‘ii’
[10:21:43.044] 
[10:21:43.044] getGlobalsAndPackages() ... DONE
[10:21:43.045] run() for ‘Future’ ...
[10:21:43.045] - state: ‘created’
[10:21:43.045] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.045] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.045] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.045]   - Field: ‘label’
[10:21:43.045]   - Field: ‘local’
[10:21:43.046]   - Field: ‘owner’
[10:21:43.046]   - Field: ‘envir’
[10:21:43.046]   - Field: ‘packages’
[10:21:43.046]   - Field: ‘gc’
[10:21:43.046]   - Field: ‘conditions’
[10:21:43.046]   - Field: ‘expr’
[10:21:43.046]   - Field: ‘uuid’
[10:21:43.046]   - Field: ‘seed’
[10:21:43.046]   - Field: ‘version’
[10:21:43.046]   - Field: ‘result’
[10:21:43.046]   - Field: ‘asynchronous’
[10:21:43.046]   - Field: ‘calls’
[10:21:43.047]   - Field: ‘globals’
[10:21:43.047]   - Field: ‘stdout’
[10:21:43.047]   - Field: ‘earlySignal’
[10:21:43.047]   - Field: ‘lazy’
[10:21:43.047]   - Field: ‘state’
[10:21:43.047] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.047] - Launch lazy future ...
[10:21:43.047] Packages needed by the future expression (n = 0): <none>
[10:21:43.047] Packages needed by future strategies (n = 0): <none>
[10:21:43.048] {
[10:21:43.048]     {
[10:21:43.048]         {
[10:21:43.048]             ...future.startTime <- base::Sys.time()
[10:21:43.048]             {
[10:21:43.048]                 {
[10:21:43.048]                   {
[10:21:43.048]                     base::local({
[10:21:43.048]                       has_future <- base::requireNamespace("future", 
[10:21:43.048]                         quietly = TRUE)
[10:21:43.048]                       if (has_future) {
[10:21:43.048]                         ns <- base::getNamespace("future")
[10:21:43.048]                         version <- ns[[".package"]][["version"]]
[10:21:43.048]                         if (is.null(version)) 
[10:21:43.048]                           version <- utils::packageVersion("future")
[10:21:43.048]                       }
[10:21:43.048]                       else {
[10:21:43.048]                         version <- NULL
[10:21:43.048]                       }
[10:21:43.048]                       if (!has_future || version < "1.8.0") {
[10:21:43.048]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.048]                           "", base::R.version$version.string), 
[10:21:43.048]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.048]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.048]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.048]                             "release", "version")], collapse = " "), 
[10:21:43.048]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.048]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.048]                           info)
[10:21:43.048]                         info <- base::paste(info, collapse = "; ")
[10:21:43.048]                         if (!has_future) {
[10:21:43.048]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.048]                             info)
[10:21:43.048]                         }
[10:21:43.048]                         else {
[10:21:43.048]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.048]                             info, version)
[10:21:43.048]                         }
[10:21:43.048]                         base::stop(msg)
[10:21:43.048]                       }
[10:21:43.048]                     })
[10:21:43.048]                   }
[10:21:43.048]                   ...future.strategy.old <- future::plan("list")
[10:21:43.048]                   options(future.plan = NULL)
[10:21:43.048]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.048]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.048]                 }
[10:21:43.048]                 ...future.workdir <- getwd()
[10:21:43.048]             }
[10:21:43.048]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.048]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.048]         }
[10:21:43.048]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.048]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.048]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.048]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.048]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.048]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.048]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.048]             base::names(...future.oldOptions))
[10:21:43.048]     }
[10:21:43.048]     if (FALSE) {
[10:21:43.048]     }
[10:21:43.048]     else {
[10:21:43.048]         if (TRUE) {
[10:21:43.048]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.048]                 open = "w")
[10:21:43.048]         }
[10:21:43.048]         else {
[10:21:43.048]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.048]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.048]         }
[10:21:43.048]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.048]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.048]             base::sink(type = "output", split = FALSE)
[10:21:43.048]             base::close(...future.stdout)
[10:21:43.048]         }, add = TRUE)
[10:21:43.048]     }
[10:21:43.048]     ...future.frame <- base::sys.nframe()
[10:21:43.048]     ...future.conditions <- base::list()
[10:21:43.048]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.048]     if (FALSE) {
[10:21:43.048]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.048]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.048]     }
[10:21:43.048]     ...future.result <- base::tryCatch({
[10:21:43.048]         base::withCallingHandlers({
[10:21:43.048]             ...future.value <- base::withVisible(base::local({
[10:21:43.048]                 b <- a * ii
[10:21:43.048]                 a <- 0
[10:21:43.048]                 b
[10:21:43.048]             }))
[10:21:43.048]             future::FutureResult(value = ...future.value$value, 
[10:21:43.048]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.048]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.048]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.048]                     ...future.globalenv.names))
[10:21:43.048]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.048]         }, condition = base::local({
[10:21:43.048]             c <- base::c
[10:21:43.048]             inherits <- base::inherits
[10:21:43.048]             invokeRestart <- base::invokeRestart
[10:21:43.048]             length <- base::length
[10:21:43.048]             list <- base::list
[10:21:43.048]             seq.int <- base::seq.int
[10:21:43.048]             signalCondition <- base::signalCondition
[10:21:43.048]             sys.calls <- base::sys.calls
[10:21:43.048]             `[[` <- base::`[[`
[10:21:43.048]             `+` <- base::`+`
[10:21:43.048]             `<<-` <- base::`<<-`
[10:21:43.048]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.048]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.048]                   3L)]
[10:21:43.048]             }
[10:21:43.048]             function(cond) {
[10:21:43.048]                 is_error <- inherits(cond, "error")
[10:21:43.048]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.048]                   NULL)
[10:21:43.048]                 if (is_error) {
[10:21:43.048]                   sessionInformation <- function() {
[10:21:43.048]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.048]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.048]                       search = base::search(), system = base::Sys.info())
[10:21:43.048]                   }
[10:21:43.048]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.048]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.048]                     cond$call), session = sessionInformation(), 
[10:21:43.048]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.048]                   signalCondition(cond)
[10:21:43.048]                 }
[10:21:43.048]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.048]                 "immediateCondition"))) {
[10:21:43.048]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.048]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.048]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.048]                   if (TRUE && !signal) {
[10:21:43.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.048]                     {
[10:21:43.048]                       inherits <- base::inherits
[10:21:43.048]                       invokeRestart <- base::invokeRestart
[10:21:43.048]                       is.null <- base::is.null
[10:21:43.048]                       muffled <- FALSE
[10:21:43.048]                       if (inherits(cond, "message")) {
[10:21:43.048]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.048]                         if (muffled) 
[10:21:43.048]                           invokeRestart("muffleMessage")
[10:21:43.048]                       }
[10:21:43.048]                       else if (inherits(cond, "warning")) {
[10:21:43.048]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.048]                         if (muffled) 
[10:21:43.048]                           invokeRestart("muffleWarning")
[10:21:43.048]                       }
[10:21:43.048]                       else if (inherits(cond, "condition")) {
[10:21:43.048]                         if (!is.null(pattern)) {
[10:21:43.048]                           computeRestarts <- base::computeRestarts
[10:21:43.048]                           grepl <- base::grepl
[10:21:43.048]                           restarts <- computeRestarts(cond)
[10:21:43.048]                           for (restart in restarts) {
[10:21:43.048]                             name <- restart$name
[10:21:43.048]                             if (is.null(name)) 
[10:21:43.048]                               next
[10:21:43.048]                             if (!grepl(pattern, name)) 
[10:21:43.048]                               next
[10:21:43.048]                             invokeRestart(restart)
[10:21:43.048]                             muffled <- TRUE
[10:21:43.048]                             break
[10:21:43.048]                           }
[10:21:43.048]                         }
[10:21:43.048]                       }
[10:21:43.048]                       invisible(muffled)
[10:21:43.048]                     }
[10:21:43.048]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.048]                   }
[10:21:43.048]                 }
[10:21:43.048]                 else {
[10:21:43.048]                   if (TRUE) {
[10:21:43.048]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.048]                     {
[10:21:43.048]                       inherits <- base::inherits
[10:21:43.048]                       invokeRestart <- base::invokeRestart
[10:21:43.048]                       is.null <- base::is.null
[10:21:43.048]                       muffled <- FALSE
[10:21:43.048]                       if (inherits(cond, "message")) {
[10:21:43.048]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.048]                         if (muffled) 
[10:21:43.048]                           invokeRestart("muffleMessage")
[10:21:43.048]                       }
[10:21:43.048]                       else if (inherits(cond, "warning")) {
[10:21:43.048]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.048]                         if (muffled) 
[10:21:43.048]                           invokeRestart("muffleWarning")
[10:21:43.048]                       }
[10:21:43.048]                       else if (inherits(cond, "condition")) {
[10:21:43.048]                         if (!is.null(pattern)) {
[10:21:43.048]                           computeRestarts <- base::computeRestarts
[10:21:43.048]                           grepl <- base::grepl
[10:21:43.048]                           restarts <- computeRestarts(cond)
[10:21:43.048]                           for (restart in restarts) {
[10:21:43.048]                             name <- restart$name
[10:21:43.048]                             if (is.null(name)) 
[10:21:43.048]                               next
[10:21:43.048]                             if (!grepl(pattern, name)) 
[10:21:43.048]                               next
[10:21:43.048]                             invokeRestart(restart)
[10:21:43.048]                             muffled <- TRUE
[10:21:43.048]                             break
[10:21:43.048]                           }
[10:21:43.048]                         }
[10:21:43.048]                       }
[10:21:43.048]                       invisible(muffled)
[10:21:43.048]                     }
[10:21:43.048]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.048]                   }
[10:21:43.048]                 }
[10:21:43.048]             }
[10:21:43.048]         }))
[10:21:43.048]     }, error = function(ex) {
[10:21:43.048]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.048]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.048]                 ...future.rng), started = ...future.startTime, 
[10:21:43.048]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.048]             version = "1.8"), class = "FutureResult")
[10:21:43.048]     }, finally = {
[10:21:43.048]         if (!identical(...future.workdir, getwd())) 
[10:21:43.048]             setwd(...future.workdir)
[10:21:43.048]         {
[10:21:43.048]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.048]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.048]             }
[10:21:43.048]             base::options(...future.oldOptions)
[10:21:43.048]             if (.Platform$OS.type == "windows") {
[10:21:43.048]                 old_names <- names(...future.oldEnvVars)
[10:21:43.048]                 envs <- base::Sys.getenv()
[10:21:43.048]                 names <- names(envs)
[10:21:43.048]                 common <- intersect(names, old_names)
[10:21:43.048]                 added <- setdiff(names, old_names)
[10:21:43.048]                 removed <- setdiff(old_names, names)
[10:21:43.048]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.048]                   envs[common]]
[10:21:43.048]                 NAMES <- toupper(changed)
[10:21:43.048]                 args <- list()
[10:21:43.048]                 for (kk in seq_along(NAMES)) {
[10:21:43.048]                   name <- changed[[kk]]
[10:21:43.048]                   NAME <- NAMES[[kk]]
[10:21:43.048]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.048]                     next
[10:21:43.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.048]                 }
[10:21:43.048]                 NAMES <- toupper(added)
[10:21:43.048]                 for (kk in seq_along(NAMES)) {
[10:21:43.048]                   name <- added[[kk]]
[10:21:43.048]                   NAME <- NAMES[[kk]]
[10:21:43.048]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.048]                     next
[10:21:43.048]                   args[[name]] <- ""
[10:21:43.048]                 }
[10:21:43.048]                 NAMES <- toupper(removed)
[10:21:43.048]                 for (kk in seq_along(NAMES)) {
[10:21:43.048]                   name <- removed[[kk]]
[10:21:43.048]                   NAME <- NAMES[[kk]]
[10:21:43.048]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.048]                     next
[10:21:43.048]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.048]                 }
[10:21:43.048]                 if (length(args) > 0) 
[10:21:43.048]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.048]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.048]             }
[10:21:43.048]             else {
[10:21:43.048]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.048]             }
[10:21:43.048]             {
[10:21:43.048]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.048]                   0L) {
[10:21:43.048]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.048]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.048]                   base::options(opts)
[10:21:43.048]                 }
[10:21:43.048]                 {
[10:21:43.048]                   {
[10:21:43.048]                     NULL
[10:21:43.048]                     RNGkind("Mersenne-Twister")
[10:21:43.048]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.048]                       inherits = FALSE)
[10:21:43.048]                   }
[10:21:43.048]                   options(future.plan = NULL)
[10:21:43.048]                   if (is.na(NA_character_)) 
[10:21:43.048]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.048]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.048]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.048]                     .init = FALSE)
[10:21:43.048]                 }
[10:21:43.048]             }
[10:21:43.048]         }
[10:21:43.048]     })
[10:21:43.048]     if (TRUE) {
[10:21:43.048]         base::sink(type = "output", split = FALSE)
[10:21:43.048]         if (TRUE) {
[10:21:43.048]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.048]         }
[10:21:43.048]         else {
[10:21:43.048]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.048]         }
[10:21:43.048]         base::close(...future.stdout)
[10:21:43.048]         ...future.stdout <- NULL
[10:21:43.048]     }
[10:21:43.048]     ...future.result$conditions <- ...future.conditions
[10:21:43.048]     ...future.result$finished <- base::Sys.time()
[10:21:43.048]     ...future.result
[10:21:43.048] }
[10:21:43.049] assign_globals() ...
[10:21:43.050] List of 1
[10:21:43.050]  $ ii: int 1
[10:21:43.050]  - attr(*, "where")=List of 1
[10:21:43.050]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.050]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.050]  - attr(*, "resolved")= logi TRUE
[10:21:43.050]  - attr(*, "total_size")= num 35
[10:21:43.050]  - attr(*, "already-done")= logi TRUE
[10:21:43.052] - copied ‘ii’ to environment
[10:21:43.052] assign_globals() ... done
[10:21:43.052] plan(): Setting new future strategy stack:
[10:21:43.052] List of future strategies:
[10:21:43.052] 1. sequential:
[10:21:43.052]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.052]    - tweaked: FALSE
[10:21:43.052]    - call: NULL
[10:21:43.053] plan(): nbrOfWorkers() = 1
[10:21:43.053] plan(): Setting new future strategy stack:
[10:21:43.054] List of future strategies:
[10:21:43.054] 1. sequential:
[10:21:43.054]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.054]    - tweaked: FALSE
[10:21:43.054]    - call: plan(strategy)
[10:21:43.054] plan(): nbrOfWorkers() = 1
[10:21:43.054] SequentialFuture started (and completed)
[10:21:43.054] - Launch lazy future ... done
[10:21:43.054] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.055] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.055] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.056] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.056] Searching for globals ... DONE
[10:21:43.056] Resolving globals: TRUE
[10:21:43.057] Resolving any globals that are futures ...
[10:21:43.057] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.057] Resolving any globals that are futures ... DONE
[10:21:43.057] Resolving futures part of globals (recursively) ...
[10:21:43.057] resolve() on list ...
[10:21:43.057]  recursive: 99
[10:21:43.057]  length: 1
[10:21:43.058]  elements: ‘ii’
[10:21:43.058]  length: 0 (resolved future 1)
[10:21:43.058] resolve() on list ... DONE
[10:21:43.058] - globals: [1] ‘ii’
[10:21:43.058] Resolving futures part of globals (recursively) ... DONE
[10:21:43.058] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.058] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.058] - globals: [1] ‘ii’
[10:21:43.059] 
[10:21:43.059] getGlobalsAndPackages() ... DONE
[10:21:43.059] run() for ‘Future’ ...
[10:21:43.059] - state: ‘created’
[10:21:43.059] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.059] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.059] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.059]   - Field: ‘label’
[10:21:43.060]   - Field: ‘local’
[10:21:43.060]   - Field: ‘owner’
[10:21:43.060]   - Field: ‘envir’
[10:21:43.060]   - Field: ‘packages’
[10:21:43.060]   - Field: ‘gc’
[10:21:43.060]   - Field: ‘conditions’
[10:21:43.060]   - Field: ‘expr’
[10:21:43.060]   - Field: ‘uuid’
[10:21:43.060]   - Field: ‘seed’
[10:21:43.060]   - Field: ‘version’
[10:21:43.060]   - Field: ‘result’
[10:21:43.061]   - Field: ‘asynchronous’
[10:21:43.061]   - Field: ‘calls’
[10:21:43.061]   - Field: ‘globals’
[10:21:43.061]   - Field: ‘stdout’
[10:21:43.061]   - Field: ‘earlySignal’
[10:21:43.061]   - Field: ‘lazy’
[10:21:43.061]   - Field: ‘state’
[10:21:43.061] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.061] - Launch lazy future ...
[10:21:43.061] Packages needed by the future expression (n = 0): <none>
[10:21:43.061] Packages needed by future strategies (n = 0): <none>
[10:21:43.062] {
[10:21:43.062]     {
[10:21:43.062]         {
[10:21:43.062]             ...future.startTime <- base::Sys.time()
[10:21:43.062]             {
[10:21:43.062]                 {
[10:21:43.062]                   {
[10:21:43.062]                     base::local({
[10:21:43.062]                       has_future <- base::requireNamespace("future", 
[10:21:43.062]                         quietly = TRUE)
[10:21:43.062]                       if (has_future) {
[10:21:43.062]                         ns <- base::getNamespace("future")
[10:21:43.062]                         version <- ns[[".package"]][["version"]]
[10:21:43.062]                         if (is.null(version)) 
[10:21:43.062]                           version <- utils::packageVersion("future")
[10:21:43.062]                       }
[10:21:43.062]                       else {
[10:21:43.062]                         version <- NULL
[10:21:43.062]                       }
[10:21:43.062]                       if (!has_future || version < "1.8.0") {
[10:21:43.062]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.062]                           "", base::R.version$version.string), 
[10:21:43.062]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.062]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.062]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.062]                             "release", "version")], collapse = " "), 
[10:21:43.062]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.062]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.062]                           info)
[10:21:43.062]                         info <- base::paste(info, collapse = "; ")
[10:21:43.062]                         if (!has_future) {
[10:21:43.062]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.062]                             info)
[10:21:43.062]                         }
[10:21:43.062]                         else {
[10:21:43.062]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.062]                             info, version)
[10:21:43.062]                         }
[10:21:43.062]                         base::stop(msg)
[10:21:43.062]                       }
[10:21:43.062]                     })
[10:21:43.062]                   }
[10:21:43.062]                   ...future.strategy.old <- future::plan("list")
[10:21:43.062]                   options(future.plan = NULL)
[10:21:43.062]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.062]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.062]                 }
[10:21:43.062]                 ...future.workdir <- getwd()
[10:21:43.062]             }
[10:21:43.062]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.062]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.062]         }
[10:21:43.062]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.062]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.062]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.062]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.062]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.062]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.062]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.062]             base::names(...future.oldOptions))
[10:21:43.062]     }
[10:21:43.062]     if (FALSE) {
[10:21:43.062]     }
[10:21:43.062]     else {
[10:21:43.062]         if (TRUE) {
[10:21:43.062]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.062]                 open = "w")
[10:21:43.062]         }
[10:21:43.062]         else {
[10:21:43.062]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.062]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.062]         }
[10:21:43.062]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.062]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.062]             base::sink(type = "output", split = FALSE)
[10:21:43.062]             base::close(...future.stdout)
[10:21:43.062]         }, add = TRUE)
[10:21:43.062]     }
[10:21:43.062]     ...future.frame <- base::sys.nframe()
[10:21:43.062]     ...future.conditions <- base::list()
[10:21:43.062]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.062]     if (FALSE) {
[10:21:43.062]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.062]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.062]     }
[10:21:43.062]     ...future.result <- base::tryCatch({
[10:21:43.062]         base::withCallingHandlers({
[10:21:43.062]             ...future.value <- base::withVisible(base::local({
[10:21:43.062]                 b <- a * ii
[10:21:43.062]                 a <- 0
[10:21:43.062]                 b
[10:21:43.062]             }))
[10:21:43.062]             future::FutureResult(value = ...future.value$value, 
[10:21:43.062]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.062]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.062]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.062]                     ...future.globalenv.names))
[10:21:43.062]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.062]         }, condition = base::local({
[10:21:43.062]             c <- base::c
[10:21:43.062]             inherits <- base::inherits
[10:21:43.062]             invokeRestart <- base::invokeRestart
[10:21:43.062]             length <- base::length
[10:21:43.062]             list <- base::list
[10:21:43.062]             seq.int <- base::seq.int
[10:21:43.062]             signalCondition <- base::signalCondition
[10:21:43.062]             sys.calls <- base::sys.calls
[10:21:43.062]             `[[` <- base::`[[`
[10:21:43.062]             `+` <- base::`+`
[10:21:43.062]             `<<-` <- base::`<<-`
[10:21:43.062]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.062]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.062]                   3L)]
[10:21:43.062]             }
[10:21:43.062]             function(cond) {
[10:21:43.062]                 is_error <- inherits(cond, "error")
[10:21:43.062]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.062]                   NULL)
[10:21:43.062]                 if (is_error) {
[10:21:43.062]                   sessionInformation <- function() {
[10:21:43.062]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.062]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.062]                       search = base::search(), system = base::Sys.info())
[10:21:43.062]                   }
[10:21:43.062]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.062]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.062]                     cond$call), session = sessionInformation(), 
[10:21:43.062]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.062]                   signalCondition(cond)
[10:21:43.062]                 }
[10:21:43.062]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.062]                 "immediateCondition"))) {
[10:21:43.062]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.062]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.062]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.062]                   if (TRUE && !signal) {
[10:21:43.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.062]                     {
[10:21:43.062]                       inherits <- base::inherits
[10:21:43.062]                       invokeRestart <- base::invokeRestart
[10:21:43.062]                       is.null <- base::is.null
[10:21:43.062]                       muffled <- FALSE
[10:21:43.062]                       if (inherits(cond, "message")) {
[10:21:43.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.062]                         if (muffled) 
[10:21:43.062]                           invokeRestart("muffleMessage")
[10:21:43.062]                       }
[10:21:43.062]                       else if (inherits(cond, "warning")) {
[10:21:43.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.062]                         if (muffled) 
[10:21:43.062]                           invokeRestart("muffleWarning")
[10:21:43.062]                       }
[10:21:43.062]                       else if (inherits(cond, "condition")) {
[10:21:43.062]                         if (!is.null(pattern)) {
[10:21:43.062]                           computeRestarts <- base::computeRestarts
[10:21:43.062]                           grepl <- base::grepl
[10:21:43.062]                           restarts <- computeRestarts(cond)
[10:21:43.062]                           for (restart in restarts) {
[10:21:43.062]                             name <- restart$name
[10:21:43.062]                             if (is.null(name)) 
[10:21:43.062]                               next
[10:21:43.062]                             if (!grepl(pattern, name)) 
[10:21:43.062]                               next
[10:21:43.062]                             invokeRestart(restart)
[10:21:43.062]                             muffled <- TRUE
[10:21:43.062]                             break
[10:21:43.062]                           }
[10:21:43.062]                         }
[10:21:43.062]                       }
[10:21:43.062]                       invisible(muffled)
[10:21:43.062]                     }
[10:21:43.062]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.062]                   }
[10:21:43.062]                 }
[10:21:43.062]                 else {
[10:21:43.062]                   if (TRUE) {
[10:21:43.062]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.062]                     {
[10:21:43.062]                       inherits <- base::inherits
[10:21:43.062]                       invokeRestart <- base::invokeRestart
[10:21:43.062]                       is.null <- base::is.null
[10:21:43.062]                       muffled <- FALSE
[10:21:43.062]                       if (inherits(cond, "message")) {
[10:21:43.062]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.062]                         if (muffled) 
[10:21:43.062]                           invokeRestart("muffleMessage")
[10:21:43.062]                       }
[10:21:43.062]                       else if (inherits(cond, "warning")) {
[10:21:43.062]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.062]                         if (muffled) 
[10:21:43.062]                           invokeRestart("muffleWarning")
[10:21:43.062]                       }
[10:21:43.062]                       else if (inherits(cond, "condition")) {
[10:21:43.062]                         if (!is.null(pattern)) {
[10:21:43.062]                           computeRestarts <- base::computeRestarts
[10:21:43.062]                           grepl <- base::grepl
[10:21:43.062]                           restarts <- computeRestarts(cond)
[10:21:43.062]                           for (restart in restarts) {
[10:21:43.062]                             name <- restart$name
[10:21:43.062]                             if (is.null(name)) 
[10:21:43.062]                               next
[10:21:43.062]                             if (!grepl(pattern, name)) 
[10:21:43.062]                               next
[10:21:43.062]                             invokeRestart(restart)
[10:21:43.062]                             muffled <- TRUE
[10:21:43.062]                             break
[10:21:43.062]                           }
[10:21:43.062]                         }
[10:21:43.062]                       }
[10:21:43.062]                       invisible(muffled)
[10:21:43.062]                     }
[10:21:43.062]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.062]                   }
[10:21:43.062]                 }
[10:21:43.062]             }
[10:21:43.062]         }))
[10:21:43.062]     }, error = function(ex) {
[10:21:43.062]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.062]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.062]                 ...future.rng), started = ...future.startTime, 
[10:21:43.062]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.062]             version = "1.8"), class = "FutureResult")
[10:21:43.062]     }, finally = {
[10:21:43.062]         if (!identical(...future.workdir, getwd())) 
[10:21:43.062]             setwd(...future.workdir)
[10:21:43.062]         {
[10:21:43.062]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.062]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.062]             }
[10:21:43.062]             base::options(...future.oldOptions)
[10:21:43.062]             if (.Platform$OS.type == "windows") {
[10:21:43.062]                 old_names <- names(...future.oldEnvVars)
[10:21:43.062]                 envs <- base::Sys.getenv()
[10:21:43.062]                 names <- names(envs)
[10:21:43.062]                 common <- intersect(names, old_names)
[10:21:43.062]                 added <- setdiff(names, old_names)
[10:21:43.062]                 removed <- setdiff(old_names, names)
[10:21:43.062]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.062]                   envs[common]]
[10:21:43.062]                 NAMES <- toupper(changed)
[10:21:43.062]                 args <- list()
[10:21:43.062]                 for (kk in seq_along(NAMES)) {
[10:21:43.062]                   name <- changed[[kk]]
[10:21:43.062]                   NAME <- NAMES[[kk]]
[10:21:43.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.062]                     next
[10:21:43.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.062]                 }
[10:21:43.062]                 NAMES <- toupper(added)
[10:21:43.062]                 for (kk in seq_along(NAMES)) {
[10:21:43.062]                   name <- added[[kk]]
[10:21:43.062]                   NAME <- NAMES[[kk]]
[10:21:43.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.062]                     next
[10:21:43.062]                   args[[name]] <- ""
[10:21:43.062]                 }
[10:21:43.062]                 NAMES <- toupper(removed)
[10:21:43.062]                 for (kk in seq_along(NAMES)) {
[10:21:43.062]                   name <- removed[[kk]]
[10:21:43.062]                   NAME <- NAMES[[kk]]
[10:21:43.062]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.062]                     next
[10:21:43.062]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.062]                 }
[10:21:43.062]                 if (length(args) > 0) 
[10:21:43.062]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.062]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.062]             }
[10:21:43.062]             else {
[10:21:43.062]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.062]             }
[10:21:43.062]             {
[10:21:43.062]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.062]                   0L) {
[10:21:43.062]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.062]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.062]                   base::options(opts)
[10:21:43.062]                 }
[10:21:43.062]                 {
[10:21:43.062]                   {
[10:21:43.062]                     NULL
[10:21:43.062]                     RNGkind("Mersenne-Twister")
[10:21:43.062]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.062]                       inherits = FALSE)
[10:21:43.062]                   }
[10:21:43.062]                   options(future.plan = NULL)
[10:21:43.062]                   if (is.na(NA_character_)) 
[10:21:43.062]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.062]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.062]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.062]                     .init = FALSE)
[10:21:43.062]                 }
[10:21:43.062]             }
[10:21:43.062]         }
[10:21:43.062]     })
[10:21:43.062]     if (TRUE) {
[10:21:43.062]         base::sink(type = "output", split = FALSE)
[10:21:43.062]         if (TRUE) {
[10:21:43.062]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.062]         }
[10:21:43.062]         else {
[10:21:43.062]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.062]         }
[10:21:43.062]         base::close(...future.stdout)
[10:21:43.062]         ...future.stdout <- NULL
[10:21:43.062]     }
[10:21:43.062]     ...future.result$conditions <- ...future.conditions
[10:21:43.062]     ...future.result$finished <- base::Sys.time()
[10:21:43.062]     ...future.result
[10:21:43.062] }
[10:21:43.063] assign_globals() ...
[10:21:43.064] List of 1
[10:21:43.064]  $ ii: int 2
[10:21:43.064]  - attr(*, "where")=List of 1
[10:21:43.064]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.064]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.064]  - attr(*, "resolved")= logi TRUE
[10:21:43.064]  - attr(*, "total_size")= num 35
[10:21:43.064]  - attr(*, "already-done")= logi TRUE
[10:21:43.066] - copied ‘ii’ to environment
[10:21:43.066] assign_globals() ... done
[10:21:43.066] plan(): Setting new future strategy stack:
[10:21:43.066] List of future strategies:
[10:21:43.066] 1. sequential:
[10:21:43.066]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.066]    - tweaked: FALSE
[10:21:43.066]    - call: NULL
[10:21:43.067] plan(): nbrOfWorkers() = 1
[10:21:43.067] plan(): Setting new future strategy stack:
[10:21:43.068] List of future strategies:
[10:21:43.068] 1. sequential:
[10:21:43.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.068]    - tweaked: FALSE
[10:21:43.068]    - call: plan(strategy)
[10:21:43.068] plan(): nbrOfWorkers() = 1
[10:21:43.068] SequentialFuture started (and completed)
[10:21:43.068] - Launch lazy future ... done
[10:21:43.068] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.069] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.069] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.072] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.072] Searching for globals ... DONE
[10:21:43.072] Resolving globals: TRUE
[10:21:43.072] Resolving any globals that are futures ...
[10:21:43.072] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.072] Resolving any globals that are futures ... DONE
[10:21:43.072] Resolving futures part of globals (recursively) ...
[10:21:43.073] resolve() on list ...
[10:21:43.073]  recursive: 99
[10:21:43.073]  length: 1
[10:21:43.073]  elements: ‘ii’
[10:21:43.073]  length: 0 (resolved future 1)
[10:21:43.073] resolve() on list ... DONE
[10:21:43.073] - globals: [1] ‘ii’
[10:21:43.073] Resolving futures part of globals (recursively) ... DONE
[10:21:43.073] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.074] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.074] - globals: [1] ‘ii’
[10:21:43.074] 
[10:21:43.074] getGlobalsAndPackages() ... DONE
[10:21:43.074] run() for ‘Future’ ...
[10:21:43.074] - state: ‘created’
[10:21:43.074] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.075] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.075] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.075]   - Field: ‘label’
[10:21:43.075]   - Field: ‘local’
[10:21:43.075]   - Field: ‘owner’
[10:21:43.075]   - Field: ‘envir’
[10:21:43.075]   - Field: ‘packages’
[10:21:43.075]   - Field: ‘gc’
[10:21:43.075]   - Field: ‘conditions’
[10:21:43.076]   - Field: ‘expr’
[10:21:43.076]   - Field: ‘uuid’
[10:21:43.076]   - Field: ‘seed’
[10:21:43.076]   - Field: ‘version’
[10:21:43.076]   - Field: ‘result’
[10:21:43.076]   - Field: ‘asynchronous’
[10:21:43.076]   - Field: ‘calls’
[10:21:43.076]   - Field: ‘globals’
[10:21:43.076]   - Field: ‘stdout’
[10:21:43.076]   - Field: ‘earlySignal’
[10:21:43.076]   - Field: ‘lazy’
[10:21:43.077]   - Field: ‘state’
[10:21:43.077] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.077] - Launch lazy future ...
[10:21:43.077] Packages needed by the future expression (n = 0): <none>
[10:21:43.077] Packages needed by future strategies (n = 0): <none>
[10:21:43.077] {
[10:21:43.077]     {
[10:21:43.077]         {
[10:21:43.077]             ...future.startTime <- base::Sys.time()
[10:21:43.077]             {
[10:21:43.077]                 {
[10:21:43.077]                   {
[10:21:43.077]                     base::local({
[10:21:43.077]                       has_future <- base::requireNamespace("future", 
[10:21:43.077]                         quietly = TRUE)
[10:21:43.077]                       if (has_future) {
[10:21:43.077]                         ns <- base::getNamespace("future")
[10:21:43.077]                         version <- ns[[".package"]][["version"]]
[10:21:43.077]                         if (is.null(version)) 
[10:21:43.077]                           version <- utils::packageVersion("future")
[10:21:43.077]                       }
[10:21:43.077]                       else {
[10:21:43.077]                         version <- NULL
[10:21:43.077]                       }
[10:21:43.077]                       if (!has_future || version < "1.8.0") {
[10:21:43.077]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.077]                           "", base::R.version$version.string), 
[10:21:43.077]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.077]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.077]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.077]                             "release", "version")], collapse = " "), 
[10:21:43.077]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.077]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.077]                           info)
[10:21:43.077]                         info <- base::paste(info, collapse = "; ")
[10:21:43.077]                         if (!has_future) {
[10:21:43.077]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.077]                             info)
[10:21:43.077]                         }
[10:21:43.077]                         else {
[10:21:43.077]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.077]                             info, version)
[10:21:43.077]                         }
[10:21:43.077]                         base::stop(msg)
[10:21:43.077]                       }
[10:21:43.077]                     })
[10:21:43.077]                   }
[10:21:43.077]                   ...future.strategy.old <- future::plan("list")
[10:21:43.077]                   options(future.plan = NULL)
[10:21:43.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.077]                 }
[10:21:43.077]                 ...future.workdir <- getwd()
[10:21:43.077]             }
[10:21:43.077]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.077]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.077]         }
[10:21:43.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.077]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.077]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.077]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.077]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.077]             base::names(...future.oldOptions))
[10:21:43.077]     }
[10:21:43.077]     if (FALSE) {
[10:21:43.077]     }
[10:21:43.077]     else {
[10:21:43.077]         if (TRUE) {
[10:21:43.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.077]                 open = "w")
[10:21:43.077]         }
[10:21:43.077]         else {
[10:21:43.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.077]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.077]         }
[10:21:43.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.077]             base::sink(type = "output", split = FALSE)
[10:21:43.077]             base::close(...future.stdout)
[10:21:43.077]         }, add = TRUE)
[10:21:43.077]     }
[10:21:43.077]     ...future.frame <- base::sys.nframe()
[10:21:43.077]     ...future.conditions <- base::list()
[10:21:43.077]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.077]     if (FALSE) {
[10:21:43.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.077]     }
[10:21:43.077]     ...future.result <- base::tryCatch({
[10:21:43.077]         base::withCallingHandlers({
[10:21:43.077]             ...future.value <- base::withVisible(base::local({
[10:21:43.077]                 b <- a * ii
[10:21:43.077]                 a <- 0
[10:21:43.077]                 b
[10:21:43.077]             }))
[10:21:43.077]             future::FutureResult(value = ...future.value$value, 
[10:21:43.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.077]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.077]                     ...future.globalenv.names))
[10:21:43.077]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.077]         }, condition = base::local({
[10:21:43.077]             c <- base::c
[10:21:43.077]             inherits <- base::inherits
[10:21:43.077]             invokeRestart <- base::invokeRestart
[10:21:43.077]             length <- base::length
[10:21:43.077]             list <- base::list
[10:21:43.077]             seq.int <- base::seq.int
[10:21:43.077]             signalCondition <- base::signalCondition
[10:21:43.077]             sys.calls <- base::sys.calls
[10:21:43.077]             `[[` <- base::`[[`
[10:21:43.077]             `+` <- base::`+`
[10:21:43.077]             `<<-` <- base::`<<-`
[10:21:43.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.077]                   3L)]
[10:21:43.077]             }
[10:21:43.077]             function(cond) {
[10:21:43.077]                 is_error <- inherits(cond, "error")
[10:21:43.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.077]                   NULL)
[10:21:43.077]                 if (is_error) {
[10:21:43.077]                   sessionInformation <- function() {
[10:21:43.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.077]                       search = base::search(), system = base::Sys.info())
[10:21:43.077]                   }
[10:21:43.077]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.077]                     cond$call), session = sessionInformation(), 
[10:21:43.077]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.077]                   signalCondition(cond)
[10:21:43.077]                 }
[10:21:43.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.077]                 "immediateCondition"))) {
[10:21:43.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.077]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.077]                   if (TRUE && !signal) {
[10:21:43.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.077]                     {
[10:21:43.077]                       inherits <- base::inherits
[10:21:43.077]                       invokeRestart <- base::invokeRestart
[10:21:43.077]                       is.null <- base::is.null
[10:21:43.077]                       muffled <- FALSE
[10:21:43.077]                       if (inherits(cond, "message")) {
[10:21:43.077]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.077]                         if (muffled) 
[10:21:43.077]                           invokeRestart("muffleMessage")
[10:21:43.077]                       }
[10:21:43.077]                       else if (inherits(cond, "warning")) {
[10:21:43.077]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.077]                         if (muffled) 
[10:21:43.077]                           invokeRestart("muffleWarning")
[10:21:43.077]                       }
[10:21:43.077]                       else if (inherits(cond, "condition")) {
[10:21:43.077]                         if (!is.null(pattern)) {
[10:21:43.077]                           computeRestarts <- base::computeRestarts
[10:21:43.077]                           grepl <- base::grepl
[10:21:43.077]                           restarts <- computeRestarts(cond)
[10:21:43.077]                           for (restart in restarts) {
[10:21:43.077]                             name <- restart$name
[10:21:43.077]                             if (is.null(name)) 
[10:21:43.077]                               next
[10:21:43.077]                             if (!grepl(pattern, name)) 
[10:21:43.077]                               next
[10:21:43.077]                             invokeRestart(restart)
[10:21:43.077]                             muffled <- TRUE
[10:21:43.077]                             break
[10:21:43.077]                           }
[10:21:43.077]                         }
[10:21:43.077]                       }
[10:21:43.077]                       invisible(muffled)
[10:21:43.077]                     }
[10:21:43.077]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.077]                   }
[10:21:43.077]                 }
[10:21:43.077]                 else {
[10:21:43.077]                   if (TRUE) {
[10:21:43.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.077]                     {
[10:21:43.077]                       inherits <- base::inherits
[10:21:43.077]                       invokeRestart <- base::invokeRestart
[10:21:43.077]                       is.null <- base::is.null
[10:21:43.077]                       muffled <- FALSE
[10:21:43.077]                       if (inherits(cond, "message")) {
[10:21:43.077]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.077]                         if (muffled) 
[10:21:43.077]                           invokeRestart("muffleMessage")
[10:21:43.077]                       }
[10:21:43.077]                       else if (inherits(cond, "warning")) {
[10:21:43.077]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.077]                         if (muffled) 
[10:21:43.077]                           invokeRestart("muffleWarning")
[10:21:43.077]                       }
[10:21:43.077]                       else if (inherits(cond, "condition")) {
[10:21:43.077]                         if (!is.null(pattern)) {
[10:21:43.077]                           computeRestarts <- base::computeRestarts
[10:21:43.077]                           grepl <- base::grepl
[10:21:43.077]                           restarts <- computeRestarts(cond)
[10:21:43.077]                           for (restart in restarts) {
[10:21:43.077]                             name <- restart$name
[10:21:43.077]                             if (is.null(name)) 
[10:21:43.077]                               next
[10:21:43.077]                             if (!grepl(pattern, name)) 
[10:21:43.077]                               next
[10:21:43.077]                             invokeRestart(restart)
[10:21:43.077]                             muffled <- TRUE
[10:21:43.077]                             break
[10:21:43.077]                           }
[10:21:43.077]                         }
[10:21:43.077]                       }
[10:21:43.077]                       invisible(muffled)
[10:21:43.077]                     }
[10:21:43.077]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.077]                   }
[10:21:43.077]                 }
[10:21:43.077]             }
[10:21:43.077]         }))
[10:21:43.077]     }, error = function(ex) {
[10:21:43.077]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.077]                 ...future.rng), started = ...future.startTime, 
[10:21:43.077]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.077]             version = "1.8"), class = "FutureResult")
[10:21:43.077]     }, finally = {
[10:21:43.077]         if (!identical(...future.workdir, getwd())) 
[10:21:43.077]             setwd(...future.workdir)
[10:21:43.077]         {
[10:21:43.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.077]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.077]             }
[10:21:43.077]             base::options(...future.oldOptions)
[10:21:43.077]             if (.Platform$OS.type == "windows") {
[10:21:43.077]                 old_names <- names(...future.oldEnvVars)
[10:21:43.077]                 envs <- base::Sys.getenv()
[10:21:43.077]                 names <- names(envs)
[10:21:43.077]                 common <- intersect(names, old_names)
[10:21:43.077]                 added <- setdiff(names, old_names)
[10:21:43.077]                 removed <- setdiff(old_names, names)
[10:21:43.077]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.077]                   envs[common]]
[10:21:43.077]                 NAMES <- toupper(changed)
[10:21:43.077]                 args <- list()
[10:21:43.077]                 for (kk in seq_along(NAMES)) {
[10:21:43.077]                   name <- changed[[kk]]
[10:21:43.077]                   NAME <- NAMES[[kk]]
[10:21:43.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.077]                     next
[10:21:43.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.077]                 }
[10:21:43.077]                 NAMES <- toupper(added)
[10:21:43.077]                 for (kk in seq_along(NAMES)) {
[10:21:43.077]                   name <- added[[kk]]
[10:21:43.077]                   NAME <- NAMES[[kk]]
[10:21:43.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.077]                     next
[10:21:43.077]                   args[[name]] <- ""
[10:21:43.077]                 }
[10:21:43.077]                 NAMES <- toupper(removed)
[10:21:43.077]                 for (kk in seq_along(NAMES)) {
[10:21:43.077]                   name <- removed[[kk]]
[10:21:43.077]                   NAME <- NAMES[[kk]]
[10:21:43.077]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.077]                     next
[10:21:43.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.077]                 }
[10:21:43.077]                 if (length(args) > 0) 
[10:21:43.077]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.077]             }
[10:21:43.077]             else {
[10:21:43.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.077]             }
[10:21:43.077]             {
[10:21:43.077]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.077]                   0L) {
[10:21:43.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.077]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.077]                   base::options(opts)
[10:21:43.077]                 }
[10:21:43.077]                 {
[10:21:43.077]                   {
[10:21:43.077]                     NULL
[10:21:43.077]                     RNGkind("Mersenne-Twister")
[10:21:43.077]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.077]                       inherits = FALSE)
[10:21:43.077]                   }
[10:21:43.077]                   options(future.plan = NULL)
[10:21:43.077]                   if (is.na(NA_character_)) 
[10:21:43.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.077]                     .init = FALSE)
[10:21:43.077]                 }
[10:21:43.077]             }
[10:21:43.077]         }
[10:21:43.077]     })
[10:21:43.077]     if (TRUE) {
[10:21:43.077]         base::sink(type = "output", split = FALSE)
[10:21:43.077]         if (TRUE) {
[10:21:43.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.077]         }
[10:21:43.077]         else {
[10:21:43.077]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.077]         }
[10:21:43.077]         base::close(...future.stdout)
[10:21:43.077]         ...future.stdout <- NULL
[10:21:43.077]     }
[10:21:43.077]     ...future.result$conditions <- ...future.conditions
[10:21:43.077]     ...future.result$finished <- base::Sys.time()
[10:21:43.077]     ...future.result
[10:21:43.077] }
[10:21:43.079] assign_globals() ...
[10:21:43.079] List of 1
[10:21:43.079]  $ ii: int 3
[10:21:43.079]  - attr(*, "where")=List of 1
[10:21:43.079]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.079]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.079]  - attr(*, "resolved")= logi TRUE
[10:21:43.079]  - attr(*, "total_size")= num 35
[10:21:43.079]  - attr(*, "already-done")= logi TRUE
[10:21:43.081] - copied ‘ii’ to environment
[10:21:43.081] assign_globals() ... done
[10:21:43.082] plan(): Setting new future strategy stack:
[10:21:43.082] List of future strategies:
[10:21:43.082] 1. sequential:
[10:21:43.082]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.082]    - tweaked: FALSE
[10:21:43.082]    - call: NULL
[10:21:43.082] plan(): nbrOfWorkers() = 1
[10:21:43.083] plan(): Setting new future strategy stack:
[10:21:43.083] List of future strategies:
[10:21:43.083] 1. sequential:
[10:21:43.083]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.083]    - tweaked: FALSE
[10:21:43.083]    - call: plan(strategy)
[10:21:43.083] plan(): nbrOfWorkers() = 1
[10:21:43.083] SequentialFuture started (and completed)
[10:21:43.084] - Launch lazy future ... done
[10:21:43.084] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.085] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.085] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.086] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.086] Searching for globals ... DONE
[10:21:43.086] Resolving globals: TRUE
[10:21:43.086] Resolving any globals that are futures ...
[10:21:43.086] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.086] Resolving any globals that are futures ... DONE
[10:21:43.087] Resolving futures part of globals (recursively) ...
[10:21:43.087] resolve() on list ...
[10:21:43.087]  recursive: 99
[10:21:43.087]  length: 1
[10:21:43.087]  elements: ‘ii’
[10:21:43.087]  length: 0 (resolved future 1)
[10:21:43.087] resolve() on list ... DONE
[10:21:43.087] - globals: [1] ‘ii’
[10:21:43.088] Resolving futures part of globals (recursively) ... DONE
[10:21:43.088] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.088] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.088] - globals: [1] ‘ii’
[10:21:43.088] 
[10:21:43.088] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.089] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.089] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.090] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.090] Searching for globals ... DONE
[10:21:43.090] Resolving globals: TRUE
[10:21:43.091] Resolving any globals that are futures ...
[10:21:43.091] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.091] Resolving any globals that are futures ... DONE
[10:21:43.091] Resolving futures part of globals (recursively) ...
[10:21:43.091] resolve() on list ...
[10:21:43.091]  recursive: 99
[10:21:43.091]  length: 1
[10:21:43.091]  elements: ‘ii’
[10:21:43.092]  length: 0 (resolved future 1)
[10:21:43.092] resolve() on list ... DONE
[10:21:43.092] - globals: [1] ‘ii’
[10:21:43.092] Resolving futures part of globals (recursively) ... DONE
[10:21:43.092] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.092] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.092] - globals: [1] ‘ii’
[10:21:43.092] 
[10:21:43.093] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.093] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.093] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.094] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.095] Searching for globals ... DONE
[10:21:43.095] Resolving globals: TRUE
[10:21:43.095] Resolving any globals that are futures ...
[10:21:43.095] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.095] Resolving any globals that are futures ... DONE
[10:21:43.096] Resolving futures part of globals (recursively) ...
[10:21:43.097] resolve() on list ...
[10:21:43.097]  recursive: 99
[10:21:43.097]  length: 1
[10:21:43.097]  elements: ‘ii’
[10:21:43.097]  length: 0 (resolved future 1)
[10:21:43.097] resolve() on list ... DONE
[10:21:43.097] - globals: [1] ‘ii’
[10:21:43.097] Resolving futures part of globals (recursively) ... DONE
[10:21:43.097] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.098] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.098] - globals: [1] ‘ii’
[10:21:43.098] 
[10:21:43.098] getGlobalsAndPackages() ... DONE
[10:21:43.098] run() for ‘Future’ ...
[10:21:43.098] - state: ‘created’
[10:21:43.098] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.099] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.099] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.099]   - Field: ‘label’
[10:21:43.099]   - Field: ‘local’
[10:21:43.099]   - Field: ‘owner’
[10:21:43.099]   - Field: ‘envir’
[10:21:43.099]   - Field: ‘packages’
[10:21:43.099]   - Field: ‘gc’
[10:21:43.099]   - Field: ‘conditions’
[10:21:43.100]   - Field: ‘expr’
[10:21:43.100]   - Field: ‘uuid’
[10:21:43.100]   - Field: ‘seed’
[10:21:43.100]   - Field: ‘version’
[10:21:43.100]   - Field: ‘result’
[10:21:43.100]   - Field: ‘asynchronous’
[10:21:43.100]   - Field: ‘calls’
[10:21:43.100]   - Field: ‘globals’
[10:21:43.100]   - Field: ‘stdout’
[10:21:43.100]   - Field: ‘earlySignal’
[10:21:43.100]   - Field: ‘lazy’
[10:21:43.100]   - Field: ‘state’
[10:21:43.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.101] - Launch lazy future ...
[10:21:43.101] Packages needed by the future expression (n = 0): <none>
[10:21:43.101] Packages needed by future strategies (n = 0): <none>
[10:21:43.101] {
[10:21:43.101]     {
[10:21:43.101]         {
[10:21:43.101]             ...future.startTime <- base::Sys.time()
[10:21:43.101]             {
[10:21:43.101]                 {
[10:21:43.101]                   {
[10:21:43.101]                     base::local({
[10:21:43.101]                       has_future <- base::requireNamespace("future", 
[10:21:43.101]                         quietly = TRUE)
[10:21:43.101]                       if (has_future) {
[10:21:43.101]                         ns <- base::getNamespace("future")
[10:21:43.101]                         version <- ns[[".package"]][["version"]]
[10:21:43.101]                         if (is.null(version)) 
[10:21:43.101]                           version <- utils::packageVersion("future")
[10:21:43.101]                       }
[10:21:43.101]                       else {
[10:21:43.101]                         version <- NULL
[10:21:43.101]                       }
[10:21:43.101]                       if (!has_future || version < "1.8.0") {
[10:21:43.101]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.101]                           "", base::R.version$version.string), 
[10:21:43.101]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.101]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.101]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.101]                             "release", "version")], collapse = " "), 
[10:21:43.101]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.101]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.101]                           info)
[10:21:43.101]                         info <- base::paste(info, collapse = "; ")
[10:21:43.101]                         if (!has_future) {
[10:21:43.101]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.101]                             info)
[10:21:43.101]                         }
[10:21:43.101]                         else {
[10:21:43.101]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.101]                             info, version)
[10:21:43.101]                         }
[10:21:43.101]                         base::stop(msg)
[10:21:43.101]                       }
[10:21:43.101]                     })
[10:21:43.101]                   }
[10:21:43.101]                   ...future.strategy.old <- future::plan("list")
[10:21:43.101]                   options(future.plan = NULL)
[10:21:43.101]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.101]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.101]                 }
[10:21:43.101]                 ...future.workdir <- getwd()
[10:21:43.101]             }
[10:21:43.101]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.101]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.101]         }
[10:21:43.101]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.101]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.101]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.101]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.101]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.101]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.101]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.101]             base::names(...future.oldOptions))
[10:21:43.101]     }
[10:21:43.101]     if (FALSE) {
[10:21:43.101]     }
[10:21:43.101]     else {
[10:21:43.101]         if (TRUE) {
[10:21:43.101]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.101]                 open = "w")
[10:21:43.101]         }
[10:21:43.101]         else {
[10:21:43.101]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.101]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.101]         }
[10:21:43.101]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.101]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.101]             base::sink(type = "output", split = FALSE)
[10:21:43.101]             base::close(...future.stdout)
[10:21:43.101]         }, add = TRUE)
[10:21:43.101]     }
[10:21:43.101]     ...future.frame <- base::sys.nframe()
[10:21:43.101]     ...future.conditions <- base::list()
[10:21:43.101]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.101]     if (FALSE) {
[10:21:43.101]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.101]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.101]     }
[10:21:43.101]     ...future.result <- base::tryCatch({
[10:21:43.101]         base::withCallingHandlers({
[10:21:43.101]             ...future.value <- base::withVisible(base::local({
[10:21:43.101]                 b <- a * ii
[10:21:43.101]                 a <- 0
[10:21:43.101]                 b
[10:21:43.101]             }))
[10:21:43.101]             future::FutureResult(value = ...future.value$value, 
[10:21:43.101]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.101]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.101]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.101]                     ...future.globalenv.names))
[10:21:43.101]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.101]         }, condition = base::local({
[10:21:43.101]             c <- base::c
[10:21:43.101]             inherits <- base::inherits
[10:21:43.101]             invokeRestart <- base::invokeRestart
[10:21:43.101]             length <- base::length
[10:21:43.101]             list <- base::list
[10:21:43.101]             seq.int <- base::seq.int
[10:21:43.101]             signalCondition <- base::signalCondition
[10:21:43.101]             sys.calls <- base::sys.calls
[10:21:43.101]             `[[` <- base::`[[`
[10:21:43.101]             `+` <- base::`+`
[10:21:43.101]             `<<-` <- base::`<<-`
[10:21:43.101]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.101]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.101]                   3L)]
[10:21:43.101]             }
[10:21:43.101]             function(cond) {
[10:21:43.101]                 is_error <- inherits(cond, "error")
[10:21:43.101]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.101]                   NULL)
[10:21:43.101]                 if (is_error) {
[10:21:43.101]                   sessionInformation <- function() {
[10:21:43.101]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.101]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.101]                       search = base::search(), system = base::Sys.info())
[10:21:43.101]                   }
[10:21:43.101]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.101]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.101]                     cond$call), session = sessionInformation(), 
[10:21:43.101]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.101]                   signalCondition(cond)
[10:21:43.101]                 }
[10:21:43.101]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.101]                 "immediateCondition"))) {
[10:21:43.101]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.101]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.101]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.101]                   if (TRUE && !signal) {
[10:21:43.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.101]                     {
[10:21:43.101]                       inherits <- base::inherits
[10:21:43.101]                       invokeRestart <- base::invokeRestart
[10:21:43.101]                       is.null <- base::is.null
[10:21:43.101]                       muffled <- FALSE
[10:21:43.101]                       if (inherits(cond, "message")) {
[10:21:43.101]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.101]                         if (muffled) 
[10:21:43.101]                           invokeRestart("muffleMessage")
[10:21:43.101]                       }
[10:21:43.101]                       else if (inherits(cond, "warning")) {
[10:21:43.101]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.101]                         if (muffled) 
[10:21:43.101]                           invokeRestart("muffleWarning")
[10:21:43.101]                       }
[10:21:43.101]                       else if (inherits(cond, "condition")) {
[10:21:43.101]                         if (!is.null(pattern)) {
[10:21:43.101]                           computeRestarts <- base::computeRestarts
[10:21:43.101]                           grepl <- base::grepl
[10:21:43.101]                           restarts <- computeRestarts(cond)
[10:21:43.101]                           for (restart in restarts) {
[10:21:43.101]                             name <- restart$name
[10:21:43.101]                             if (is.null(name)) 
[10:21:43.101]                               next
[10:21:43.101]                             if (!grepl(pattern, name)) 
[10:21:43.101]                               next
[10:21:43.101]                             invokeRestart(restart)
[10:21:43.101]                             muffled <- TRUE
[10:21:43.101]                             break
[10:21:43.101]                           }
[10:21:43.101]                         }
[10:21:43.101]                       }
[10:21:43.101]                       invisible(muffled)
[10:21:43.101]                     }
[10:21:43.101]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.101]                   }
[10:21:43.101]                 }
[10:21:43.101]                 else {
[10:21:43.101]                   if (TRUE) {
[10:21:43.101]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.101]                     {
[10:21:43.101]                       inherits <- base::inherits
[10:21:43.101]                       invokeRestart <- base::invokeRestart
[10:21:43.101]                       is.null <- base::is.null
[10:21:43.101]                       muffled <- FALSE
[10:21:43.101]                       if (inherits(cond, "message")) {
[10:21:43.101]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.101]                         if (muffled) 
[10:21:43.101]                           invokeRestart("muffleMessage")
[10:21:43.101]                       }
[10:21:43.101]                       else if (inherits(cond, "warning")) {
[10:21:43.101]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.101]                         if (muffled) 
[10:21:43.101]                           invokeRestart("muffleWarning")
[10:21:43.101]                       }
[10:21:43.101]                       else if (inherits(cond, "condition")) {
[10:21:43.101]                         if (!is.null(pattern)) {
[10:21:43.101]                           computeRestarts <- base::computeRestarts
[10:21:43.101]                           grepl <- base::grepl
[10:21:43.101]                           restarts <- computeRestarts(cond)
[10:21:43.101]                           for (restart in restarts) {
[10:21:43.101]                             name <- restart$name
[10:21:43.101]                             if (is.null(name)) 
[10:21:43.101]                               next
[10:21:43.101]                             if (!grepl(pattern, name)) 
[10:21:43.101]                               next
[10:21:43.101]                             invokeRestart(restart)
[10:21:43.101]                             muffled <- TRUE
[10:21:43.101]                             break
[10:21:43.101]                           }
[10:21:43.101]                         }
[10:21:43.101]                       }
[10:21:43.101]                       invisible(muffled)
[10:21:43.101]                     }
[10:21:43.101]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.101]                   }
[10:21:43.101]                 }
[10:21:43.101]             }
[10:21:43.101]         }))
[10:21:43.101]     }, error = function(ex) {
[10:21:43.101]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.101]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.101]                 ...future.rng), started = ...future.startTime, 
[10:21:43.101]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.101]             version = "1.8"), class = "FutureResult")
[10:21:43.101]     }, finally = {
[10:21:43.101]         if (!identical(...future.workdir, getwd())) 
[10:21:43.101]             setwd(...future.workdir)
[10:21:43.101]         {
[10:21:43.101]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.101]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.101]             }
[10:21:43.101]             base::options(...future.oldOptions)
[10:21:43.101]             if (.Platform$OS.type == "windows") {
[10:21:43.101]                 old_names <- names(...future.oldEnvVars)
[10:21:43.101]                 envs <- base::Sys.getenv()
[10:21:43.101]                 names <- names(envs)
[10:21:43.101]                 common <- intersect(names, old_names)
[10:21:43.101]                 added <- setdiff(names, old_names)
[10:21:43.101]                 removed <- setdiff(old_names, names)
[10:21:43.101]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.101]                   envs[common]]
[10:21:43.101]                 NAMES <- toupper(changed)
[10:21:43.101]                 args <- list()
[10:21:43.101]                 for (kk in seq_along(NAMES)) {
[10:21:43.101]                   name <- changed[[kk]]
[10:21:43.101]                   NAME <- NAMES[[kk]]
[10:21:43.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.101]                     next
[10:21:43.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.101]                 }
[10:21:43.101]                 NAMES <- toupper(added)
[10:21:43.101]                 for (kk in seq_along(NAMES)) {
[10:21:43.101]                   name <- added[[kk]]
[10:21:43.101]                   NAME <- NAMES[[kk]]
[10:21:43.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.101]                     next
[10:21:43.101]                   args[[name]] <- ""
[10:21:43.101]                 }
[10:21:43.101]                 NAMES <- toupper(removed)
[10:21:43.101]                 for (kk in seq_along(NAMES)) {
[10:21:43.101]                   name <- removed[[kk]]
[10:21:43.101]                   NAME <- NAMES[[kk]]
[10:21:43.101]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.101]                     next
[10:21:43.101]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.101]                 }
[10:21:43.101]                 if (length(args) > 0) 
[10:21:43.101]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.101]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.101]             }
[10:21:43.101]             else {
[10:21:43.101]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.101]             }
[10:21:43.101]             {
[10:21:43.101]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.101]                   0L) {
[10:21:43.101]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.101]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.101]                   base::options(opts)
[10:21:43.101]                 }
[10:21:43.101]                 {
[10:21:43.101]                   {
[10:21:43.101]                     NULL
[10:21:43.101]                     RNGkind("Mersenne-Twister")
[10:21:43.101]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.101]                       inherits = FALSE)
[10:21:43.101]                   }
[10:21:43.101]                   options(future.plan = NULL)
[10:21:43.101]                   if (is.na(NA_character_)) 
[10:21:43.101]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.101]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.101]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.101]                     .init = FALSE)
[10:21:43.101]                 }
[10:21:43.101]             }
[10:21:43.101]         }
[10:21:43.101]     })
[10:21:43.101]     if (TRUE) {
[10:21:43.101]         base::sink(type = "output", split = FALSE)
[10:21:43.101]         if (TRUE) {
[10:21:43.101]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.101]         }
[10:21:43.101]         else {
[10:21:43.101]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.101]         }
[10:21:43.101]         base::close(...future.stdout)
[10:21:43.101]         ...future.stdout <- NULL
[10:21:43.101]     }
[10:21:43.101]     ...future.result$conditions <- ...future.conditions
[10:21:43.101]     ...future.result$finished <- base::Sys.time()
[10:21:43.101]     ...future.result
[10:21:43.101] }
[10:21:43.103] assign_globals() ...
[10:21:43.103] List of 1
[10:21:43.103]  $ ii: int 1
[10:21:43.103]  - attr(*, "where")=List of 1
[10:21:43.103]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.103]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.103]  - attr(*, "resolved")= logi TRUE
[10:21:43.103]  - attr(*, "total_size")= num 35
[10:21:43.103]  - attr(*, "already-done")= logi TRUE
[10:21:43.105] - copied ‘ii’ to environment
[10:21:43.105] assign_globals() ... done
[10:21:43.106] plan(): Setting new future strategy stack:
[10:21:43.106] List of future strategies:
[10:21:43.106] 1. sequential:
[10:21:43.106]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.106]    - tweaked: FALSE
[10:21:43.106]    - call: NULL
[10:21:43.106] plan(): nbrOfWorkers() = 1
[10:21:43.107] plan(): Setting new future strategy stack:
[10:21:43.107] List of future strategies:
[10:21:43.107] 1. sequential:
[10:21:43.107]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.107]    - tweaked: FALSE
[10:21:43.107]    - call: plan(strategy)
[10:21:43.108] plan(): nbrOfWorkers() = 1
[10:21:43.108] SequentialFuture started (and completed)
[10:21:43.108] signalConditions() ...
[10:21:43.108]  - include = ‘immediateCondition’
[10:21:43.108]  - exclude = 
[10:21:43.108]  - resignal = FALSE
[10:21:43.108]  - Number of conditions: 1
[10:21:43.108] signalConditions() ... done
[10:21:43.108] - Launch lazy future ... done
[10:21:43.108] run() for ‘SequentialFuture’ ... done
[10:21:43.108] signalConditions() ...
[10:21:43.109]  - include = ‘immediateCondition’
[10:21:43.109]  - exclude = 
[10:21:43.109]  - resignal = FALSE
[10:21:43.109]  - Number of conditions: 1
[10:21:43.109] signalConditions() ... done
[10:21:43.109] Future state: ‘finished’
[10:21:43.109] signalConditions() ...
[10:21:43.109]  - include = ‘condition’
[10:21:43.109]  - exclude = ‘immediateCondition’
[10:21:43.109]  - resignal = TRUE
[10:21:43.109]  - Number of conditions: 1
[10:21:43.109]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:43.110] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:43"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.124] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.124] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.124] 
[10:21:43.124] Searching for globals ... DONE
[10:21:43.125] - globals: [0] <none>
[10:21:43.125] getGlobalsAndPackages() ... DONE
[10:21:43.125] run() for ‘Future’ ...
[10:21:43.125] - state: ‘created’
[10:21:43.125] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.125] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.125] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.125]   - Field: ‘label’
[10:21:43.126]   - Field: ‘local’
[10:21:43.126]   - Field: ‘owner’
[10:21:43.126]   - Field: ‘envir’
[10:21:43.126]   - Field: ‘packages’
[10:21:43.126]   - Field: ‘gc’
[10:21:43.126]   - Field: ‘conditions’
[10:21:43.126]   - Field: ‘expr’
[10:21:43.126]   - Field: ‘uuid’
[10:21:43.126]   - Field: ‘seed’
[10:21:43.126]   - Field: ‘version’
[10:21:43.126]   - Field: ‘result’
[10:21:43.126]   - Field: ‘asynchronous’
[10:21:43.127]   - Field: ‘calls’
[10:21:43.127]   - Field: ‘globals’
[10:21:43.127]   - Field: ‘stdout’
[10:21:43.127]   - Field: ‘earlySignal’
[10:21:43.127]   - Field: ‘lazy’
[10:21:43.127]   - Field: ‘state’
[10:21:43.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.127] - Launch lazy future ...
[10:21:43.127] Packages needed by the future expression (n = 0): <none>
[10:21:43.127] Packages needed by future strategies (n = 0): <none>
[10:21:43.128] {
[10:21:43.128]     {
[10:21:43.128]         {
[10:21:43.128]             ...future.startTime <- base::Sys.time()
[10:21:43.128]             {
[10:21:43.128]                 {
[10:21:43.128]                   {
[10:21:43.128]                     base::local({
[10:21:43.128]                       has_future <- base::requireNamespace("future", 
[10:21:43.128]                         quietly = TRUE)
[10:21:43.128]                       if (has_future) {
[10:21:43.128]                         ns <- base::getNamespace("future")
[10:21:43.128]                         version <- ns[[".package"]][["version"]]
[10:21:43.128]                         if (is.null(version)) 
[10:21:43.128]                           version <- utils::packageVersion("future")
[10:21:43.128]                       }
[10:21:43.128]                       else {
[10:21:43.128]                         version <- NULL
[10:21:43.128]                       }
[10:21:43.128]                       if (!has_future || version < "1.8.0") {
[10:21:43.128]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.128]                           "", base::R.version$version.string), 
[10:21:43.128]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.128]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.128]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.128]                             "release", "version")], collapse = " "), 
[10:21:43.128]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.128]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.128]                           info)
[10:21:43.128]                         info <- base::paste(info, collapse = "; ")
[10:21:43.128]                         if (!has_future) {
[10:21:43.128]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.128]                             info)
[10:21:43.128]                         }
[10:21:43.128]                         else {
[10:21:43.128]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.128]                             info, version)
[10:21:43.128]                         }
[10:21:43.128]                         base::stop(msg)
[10:21:43.128]                       }
[10:21:43.128]                     })
[10:21:43.128]                   }
[10:21:43.128]                   ...future.strategy.old <- future::plan("list")
[10:21:43.128]                   options(future.plan = NULL)
[10:21:43.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.128]                 }
[10:21:43.128]                 ...future.workdir <- getwd()
[10:21:43.128]             }
[10:21:43.128]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.128]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.128]         }
[10:21:43.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.128]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.128]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.128]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.128]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.128]             base::names(...future.oldOptions))
[10:21:43.128]     }
[10:21:43.128]     if (FALSE) {
[10:21:43.128]     }
[10:21:43.128]     else {
[10:21:43.128]         if (TRUE) {
[10:21:43.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.128]                 open = "w")
[10:21:43.128]         }
[10:21:43.128]         else {
[10:21:43.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.128]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.128]         }
[10:21:43.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.128]             base::sink(type = "output", split = FALSE)
[10:21:43.128]             base::close(...future.stdout)
[10:21:43.128]         }, add = TRUE)
[10:21:43.128]     }
[10:21:43.128]     ...future.frame <- base::sys.nframe()
[10:21:43.128]     ...future.conditions <- base::list()
[10:21:43.128]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.128]     if (FALSE) {
[10:21:43.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.128]     }
[10:21:43.128]     ...future.result <- base::tryCatch({
[10:21:43.128]         base::withCallingHandlers({
[10:21:43.128]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.128]             future::FutureResult(value = ...future.value$value, 
[10:21:43.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.128]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.128]                     ...future.globalenv.names))
[10:21:43.128]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.128]         }, condition = base::local({
[10:21:43.128]             c <- base::c
[10:21:43.128]             inherits <- base::inherits
[10:21:43.128]             invokeRestart <- base::invokeRestart
[10:21:43.128]             length <- base::length
[10:21:43.128]             list <- base::list
[10:21:43.128]             seq.int <- base::seq.int
[10:21:43.128]             signalCondition <- base::signalCondition
[10:21:43.128]             sys.calls <- base::sys.calls
[10:21:43.128]             `[[` <- base::`[[`
[10:21:43.128]             `+` <- base::`+`
[10:21:43.128]             `<<-` <- base::`<<-`
[10:21:43.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.128]                   3L)]
[10:21:43.128]             }
[10:21:43.128]             function(cond) {
[10:21:43.128]                 is_error <- inherits(cond, "error")
[10:21:43.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.128]                   NULL)
[10:21:43.128]                 if (is_error) {
[10:21:43.128]                   sessionInformation <- function() {
[10:21:43.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.128]                       search = base::search(), system = base::Sys.info())
[10:21:43.128]                   }
[10:21:43.128]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.128]                     cond$call), session = sessionInformation(), 
[10:21:43.128]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.128]                   signalCondition(cond)
[10:21:43.128]                 }
[10:21:43.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.128]                 "immediateCondition"))) {
[10:21:43.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.128]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.128]                   if (TRUE && !signal) {
[10:21:43.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.128]                     {
[10:21:43.128]                       inherits <- base::inherits
[10:21:43.128]                       invokeRestart <- base::invokeRestart
[10:21:43.128]                       is.null <- base::is.null
[10:21:43.128]                       muffled <- FALSE
[10:21:43.128]                       if (inherits(cond, "message")) {
[10:21:43.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.128]                         if (muffled) 
[10:21:43.128]                           invokeRestart("muffleMessage")
[10:21:43.128]                       }
[10:21:43.128]                       else if (inherits(cond, "warning")) {
[10:21:43.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.128]                         if (muffled) 
[10:21:43.128]                           invokeRestart("muffleWarning")
[10:21:43.128]                       }
[10:21:43.128]                       else if (inherits(cond, "condition")) {
[10:21:43.128]                         if (!is.null(pattern)) {
[10:21:43.128]                           computeRestarts <- base::computeRestarts
[10:21:43.128]                           grepl <- base::grepl
[10:21:43.128]                           restarts <- computeRestarts(cond)
[10:21:43.128]                           for (restart in restarts) {
[10:21:43.128]                             name <- restart$name
[10:21:43.128]                             if (is.null(name)) 
[10:21:43.128]                               next
[10:21:43.128]                             if (!grepl(pattern, name)) 
[10:21:43.128]                               next
[10:21:43.128]                             invokeRestart(restart)
[10:21:43.128]                             muffled <- TRUE
[10:21:43.128]                             break
[10:21:43.128]                           }
[10:21:43.128]                         }
[10:21:43.128]                       }
[10:21:43.128]                       invisible(muffled)
[10:21:43.128]                     }
[10:21:43.128]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.128]                   }
[10:21:43.128]                 }
[10:21:43.128]                 else {
[10:21:43.128]                   if (TRUE) {
[10:21:43.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.128]                     {
[10:21:43.128]                       inherits <- base::inherits
[10:21:43.128]                       invokeRestart <- base::invokeRestart
[10:21:43.128]                       is.null <- base::is.null
[10:21:43.128]                       muffled <- FALSE
[10:21:43.128]                       if (inherits(cond, "message")) {
[10:21:43.128]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.128]                         if (muffled) 
[10:21:43.128]                           invokeRestart("muffleMessage")
[10:21:43.128]                       }
[10:21:43.128]                       else if (inherits(cond, "warning")) {
[10:21:43.128]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.128]                         if (muffled) 
[10:21:43.128]                           invokeRestart("muffleWarning")
[10:21:43.128]                       }
[10:21:43.128]                       else if (inherits(cond, "condition")) {
[10:21:43.128]                         if (!is.null(pattern)) {
[10:21:43.128]                           computeRestarts <- base::computeRestarts
[10:21:43.128]                           grepl <- base::grepl
[10:21:43.128]                           restarts <- computeRestarts(cond)
[10:21:43.128]                           for (restart in restarts) {
[10:21:43.128]                             name <- restart$name
[10:21:43.128]                             if (is.null(name)) 
[10:21:43.128]                               next
[10:21:43.128]                             if (!grepl(pattern, name)) 
[10:21:43.128]                               next
[10:21:43.128]                             invokeRestart(restart)
[10:21:43.128]                             muffled <- TRUE
[10:21:43.128]                             break
[10:21:43.128]                           }
[10:21:43.128]                         }
[10:21:43.128]                       }
[10:21:43.128]                       invisible(muffled)
[10:21:43.128]                     }
[10:21:43.128]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.128]                   }
[10:21:43.128]                 }
[10:21:43.128]             }
[10:21:43.128]         }))
[10:21:43.128]     }, error = function(ex) {
[10:21:43.128]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.128]                 ...future.rng), started = ...future.startTime, 
[10:21:43.128]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.128]             version = "1.8"), class = "FutureResult")
[10:21:43.128]     }, finally = {
[10:21:43.128]         if (!identical(...future.workdir, getwd())) 
[10:21:43.128]             setwd(...future.workdir)
[10:21:43.128]         {
[10:21:43.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.128]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.128]             }
[10:21:43.128]             base::options(...future.oldOptions)
[10:21:43.128]             if (.Platform$OS.type == "windows") {
[10:21:43.128]                 old_names <- names(...future.oldEnvVars)
[10:21:43.128]                 envs <- base::Sys.getenv()
[10:21:43.128]                 names <- names(envs)
[10:21:43.128]                 common <- intersect(names, old_names)
[10:21:43.128]                 added <- setdiff(names, old_names)
[10:21:43.128]                 removed <- setdiff(old_names, names)
[10:21:43.128]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.128]                   envs[common]]
[10:21:43.128]                 NAMES <- toupper(changed)
[10:21:43.128]                 args <- list()
[10:21:43.128]                 for (kk in seq_along(NAMES)) {
[10:21:43.128]                   name <- changed[[kk]]
[10:21:43.128]                   NAME <- NAMES[[kk]]
[10:21:43.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.128]                     next
[10:21:43.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.128]                 }
[10:21:43.128]                 NAMES <- toupper(added)
[10:21:43.128]                 for (kk in seq_along(NAMES)) {
[10:21:43.128]                   name <- added[[kk]]
[10:21:43.128]                   NAME <- NAMES[[kk]]
[10:21:43.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.128]                     next
[10:21:43.128]                   args[[name]] <- ""
[10:21:43.128]                 }
[10:21:43.128]                 NAMES <- toupper(removed)
[10:21:43.128]                 for (kk in seq_along(NAMES)) {
[10:21:43.128]                   name <- removed[[kk]]
[10:21:43.128]                   NAME <- NAMES[[kk]]
[10:21:43.128]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.128]                     next
[10:21:43.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.128]                 }
[10:21:43.128]                 if (length(args) > 0) 
[10:21:43.128]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.128]             }
[10:21:43.128]             else {
[10:21:43.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.128]             }
[10:21:43.128]             {
[10:21:43.128]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.128]                   0L) {
[10:21:43.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.128]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.128]                   base::options(opts)
[10:21:43.128]                 }
[10:21:43.128]                 {
[10:21:43.128]                   {
[10:21:43.128]                     NULL
[10:21:43.128]                     RNGkind("Mersenne-Twister")
[10:21:43.128]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.128]                       inherits = FALSE)
[10:21:43.128]                   }
[10:21:43.128]                   options(future.plan = NULL)
[10:21:43.128]                   if (is.na(NA_character_)) 
[10:21:43.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.128]                     .init = FALSE)
[10:21:43.128]                 }
[10:21:43.128]             }
[10:21:43.128]         }
[10:21:43.128]     })
[10:21:43.128]     if (TRUE) {
[10:21:43.128]         base::sink(type = "output", split = FALSE)
[10:21:43.128]         if (TRUE) {
[10:21:43.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.128]         }
[10:21:43.128]         else {
[10:21:43.128]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.128]         }
[10:21:43.128]         base::close(...future.stdout)
[10:21:43.128]         ...future.stdout <- NULL
[10:21:43.128]     }
[10:21:43.128]     ...future.result$conditions <- ...future.conditions
[10:21:43.128]     ...future.result$finished <- base::Sys.time()
[10:21:43.128]     ...future.result
[10:21:43.128] }
[10:21:43.130] plan(): Setting new future strategy stack:
[10:21:43.130] List of future strategies:
[10:21:43.130] 1. sequential:
[10:21:43.130]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.130]    - tweaked: FALSE
[10:21:43.130]    - call: NULL
[10:21:43.130] plan(): nbrOfWorkers() = 1
[10:21:43.131] plan(): Setting new future strategy stack:
[10:21:43.131] List of future strategies:
[10:21:43.131] 1. sequential:
[10:21:43.131]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.131]    - tweaked: FALSE
[10:21:43.131]    - call: plan(strategy)
[10:21:43.131] plan(): nbrOfWorkers() = 1
[10:21:43.131] SequentialFuture started (and completed)
[10:21:43.132] - Launch lazy future ... done
[10:21:43.132] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.132] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.132] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.133] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.133] Searching for globals ... DONE
[10:21:43.133] Resolving globals: TRUE
[10:21:43.133] Resolving any globals that are futures ...
[10:21:43.133] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.133] Resolving any globals that are futures ... DONE
[10:21:43.134] Resolving futures part of globals (recursively) ...
[10:21:43.134] resolve() on list ...
[10:21:43.134]  recursive: 99
[10:21:43.134]  length: 1
[10:21:43.134]  elements: ‘a’
[10:21:43.134] resolved() for ‘SequentialFuture’ ...
[10:21:43.134] - state: ‘finished’
[10:21:43.135] - run: TRUE
[10:21:43.135] - result: ‘FutureResult’
[10:21:43.135] resolved() for ‘SequentialFuture’ ... done
[10:21:43.135] Future #1
[10:21:43.135] resolved() for ‘SequentialFuture’ ...
[10:21:43.135] - state: ‘finished’
[10:21:43.135] - run: TRUE
[10:21:43.135] - result: ‘FutureResult’
[10:21:43.135] resolved() for ‘SequentialFuture’ ... done
[10:21:43.136] A SequentialFuture was resolved
[10:21:43.136]  length: 0 (resolved future 1)
[10:21:43.136] resolve() on list ... DONE
[10:21:43.136] - globals: [1] ‘a’
[10:21:43.136] Resolving futures part of globals (recursively) ... DONE
[10:21:43.136] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[10:21:43.136] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[10:21:43.136] - globals: [1] ‘a’
[10:21:43.137] - packages: [1] ‘future’
[10:21:43.137] getGlobalsAndPackages() ... DONE
[10:21:43.137] run() for ‘Future’ ...
[10:21:43.137] - state: ‘created’
[10:21:43.137] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.137] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.138]   - Field: ‘label’
[10:21:43.138]   - Field: ‘local’
[10:21:43.138]   - Field: ‘owner’
[10:21:43.138]   - Field: ‘envir’
[10:21:43.138]   - Field: ‘packages’
[10:21:43.138]   - Field: ‘gc’
[10:21:43.138]   - Field: ‘conditions’
[10:21:43.138]   - Field: ‘expr’
[10:21:43.138]   - Field: ‘uuid’
[10:21:43.138]   - Field: ‘seed’
[10:21:43.138]   - Field: ‘version’
[10:21:43.139]   - Field: ‘result’
[10:21:43.139]   - Field: ‘asynchronous’
[10:21:43.139]   - Field: ‘calls’
[10:21:43.139]   - Field: ‘globals’
[10:21:43.139]   - Field: ‘stdout’
[10:21:43.139]   - Field: ‘earlySignal’
[10:21:43.139]   - Field: ‘lazy’
[10:21:43.139]   - Field: ‘state’
[10:21:43.139] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.139] - Launch lazy future ...
[10:21:43.139] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.140] Packages needed by future strategies (n = 0): <none>
[10:21:43.140] {
[10:21:43.140]     {
[10:21:43.140]         {
[10:21:43.140]             ...future.startTime <- base::Sys.time()
[10:21:43.140]             {
[10:21:43.140]                 {
[10:21:43.140]                   {
[10:21:43.140]                     {
[10:21:43.140]                       base::local({
[10:21:43.140]                         has_future <- base::requireNamespace("future", 
[10:21:43.140]                           quietly = TRUE)
[10:21:43.140]                         if (has_future) {
[10:21:43.140]                           ns <- base::getNamespace("future")
[10:21:43.140]                           version <- ns[[".package"]][["version"]]
[10:21:43.140]                           if (is.null(version)) 
[10:21:43.140]                             version <- utils::packageVersion("future")
[10:21:43.140]                         }
[10:21:43.140]                         else {
[10:21:43.140]                           version <- NULL
[10:21:43.140]                         }
[10:21:43.140]                         if (!has_future || version < "1.8.0") {
[10:21:43.140]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.140]                             "", base::R.version$version.string), 
[10:21:43.140]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.140]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.140]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.140]                               "release", "version")], collapse = " "), 
[10:21:43.140]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.140]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.140]                             info)
[10:21:43.140]                           info <- base::paste(info, collapse = "; ")
[10:21:43.140]                           if (!has_future) {
[10:21:43.140]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.140]                               info)
[10:21:43.140]                           }
[10:21:43.140]                           else {
[10:21:43.140]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.140]                               info, version)
[10:21:43.140]                           }
[10:21:43.140]                           base::stop(msg)
[10:21:43.140]                         }
[10:21:43.140]                       })
[10:21:43.140]                     }
[10:21:43.140]                     base::local({
[10:21:43.140]                       for (pkg in "future") {
[10:21:43.140]                         base::loadNamespace(pkg)
[10:21:43.140]                         base::library(pkg, character.only = TRUE)
[10:21:43.140]                       }
[10:21:43.140]                     })
[10:21:43.140]                   }
[10:21:43.140]                   ...future.strategy.old <- future::plan("list")
[10:21:43.140]                   options(future.plan = NULL)
[10:21:43.140]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.140]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.140]                 }
[10:21:43.140]                 ...future.workdir <- getwd()
[10:21:43.140]             }
[10:21:43.140]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.140]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.140]         }
[10:21:43.140]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.140]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.140]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.140]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.140]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.140]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.140]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.140]             base::names(...future.oldOptions))
[10:21:43.140]     }
[10:21:43.140]     if (FALSE) {
[10:21:43.140]     }
[10:21:43.140]     else {
[10:21:43.140]         if (TRUE) {
[10:21:43.140]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.140]                 open = "w")
[10:21:43.140]         }
[10:21:43.140]         else {
[10:21:43.140]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.140]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.140]         }
[10:21:43.140]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.140]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.140]             base::sink(type = "output", split = FALSE)
[10:21:43.140]             base::close(...future.stdout)
[10:21:43.140]         }, add = TRUE)
[10:21:43.140]     }
[10:21:43.140]     ...future.frame <- base::sys.nframe()
[10:21:43.140]     ...future.conditions <- base::list()
[10:21:43.140]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.140]     if (FALSE) {
[10:21:43.140]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.140]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.140]     }
[10:21:43.140]     ...future.result <- base::tryCatch({
[10:21:43.140]         base::withCallingHandlers({
[10:21:43.140]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.140]                 1))
[10:21:43.140]             future::FutureResult(value = ...future.value$value, 
[10:21:43.140]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.140]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.140]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.140]                     ...future.globalenv.names))
[10:21:43.140]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.140]         }, condition = base::local({
[10:21:43.140]             c <- base::c
[10:21:43.140]             inherits <- base::inherits
[10:21:43.140]             invokeRestart <- base::invokeRestart
[10:21:43.140]             length <- base::length
[10:21:43.140]             list <- base::list
[10:21:43.140]             seq.int <- base::seq.int
[10:21:43.140]             signalCondition <- base::signalCondition
[10:21:43.140]             sys.calls <- base::sys.calls
[10:21:43.140]             `[[` <- base::`[[`
[10:21:43.140]             `+` <- base::`+`
[10:21:43.140]             `<<-` <- base::`<<-`
[10:21:43.140]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.140]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.140]                   3L)]
[10:21:43.140]             }
[10:21:43.140]             function(cond) {
[10:21:43.140]                 is_error <- inherits(cond, "error")
[10:21:43.140]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.140]                   NULL)
[10:21:43.140]                 if (is_error) {
[10:21:43.140]                   sessionInformation <- function() {
[10:21:43.140]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.140]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.140]                       search = base::search(), system = base::Sys.info())
[10:21:43.140]                   }
[10:21:43.140]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.140]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.140]                     cond$call), session = sessionInformation(), 
[10:21:43.140]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.140]                   signalCondition(cond)
[10:21:43.140]                 }
[10:21:43.140]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.140]                 "immediateCondition"))) {
[10:21:43.140]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.140]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.140]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.140]                   if (TRUE && !signal) {
[10:21:43.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.140]                     {
[10:21:43.140]                       inherits <- base::inherits
[10:21:43.140]                       invokeRestart <- base::invokeRestart
[10:21:43.140]                       is.null <- base::is.null
[10:21:43.140]                       muffled <- FALSE
[10:21:43.140]                       if (inherits(cond, "message")) {
[10:21:43.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.140]                         if (muffled) 
[10:21:43.140]                           invokeRestart("muffleMessage")
[10:21:43.140]                       }
[10:21:43.140]                       else if (inherits(cond, "warning")) {
[10:21:43.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.140]                         if (muffled) 
[10:21:43.140]                           invokeRestart("muffleWarning")
[10:21:43.140]                       }
[10:21:43.140]                       else if (inherits(cond, "condition")) {
[10:21:43.140]                         if (!is.null(pattern)) {
[10:21:43.140]                           computeRestarts <- base::computeRestarts
[10:21:43.140]                           grepl <- base::grepl
[10:21:43.140]                           restarts <- computeRestarts(cond)
[10:21:43.140]                           for (restart in restarts) {
[10:21:43.140]                             name <- restart$name
[10:21:43.140]                             if (is.null(name)) 
[10:21:43.140]                               next
[10:21:43.140]                             if (!grepl(pattern, name)) 
[10:21:43.140]                               next
[10:21:43.140]                             invokeRestart(restart)
[10:21:43.140]                             muffled <- TRUE
[10:21:43.140]                             break
[10:21:43.140]                           }
[10:21:43.140]                         }
[10:21:43.140]                       }
[10:21:43.140]                       invisible(muffled)
[10:21:43.140]                     }
[10:21:43.140]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.140]                   }
[10:21:43.140]                 }
[10:21:43.140]                 else {
[10:21:43.140]                   if (TRUE) {
[10:21:43.140]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.140]                     {
[10:21:43.140]                       inherits <- base::inherits
[10:21:43.140]                       invokeRestart <- base::invokeRestart
[10:21:43.140]                       is.null <- base::is.null
[10:21:43.140]                       muffled <- FALSE
[10:21:43.140]                       if (inherits(cond, "message")) {
[10:21:43.140]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.140]                         if (muffled) 
[10:21:43.140]                           invokeRestart("muffleMessage")
[10:21:43.140]                       }
[10:21:43.140]                       else if (inherits(cond, "warning")) {
[10:21:43.140]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.140]                         if (muffled) 
[10:21:43.140]                           invokeRestart("muffleWarning")
[10:21:43.140]                       }
[10:21:43.140]                       else if (inherits(cond, "condition")) {
[10:21:43.140]                         if (!is.null(pattern)) {
[10:21:43.140]                           computeRestarts <- base::computeRestarts
[10:21:43.140]                           grepl <- base::grepl
[10:21:43.140]                           restarts <- computeRestarts(cond)
[10:21:43.140]                           for (restart in restarts) {
[10:21:43.140]                             name <- restart$name
[10:21:43.140]                             if (is.null(name)) 
[10:21:43.140]                               next
[10:21:43.140]                             if (!grepl(pattern, name)) 
[10:21:43.140]                               next
[10:21:43.140]                             invokeRestart(restart)
[10:21:43.140]                             muffled <- TRUE
[10:21:43.140]                             break
[10:21:43.140]                           }
[10:21:43.140]                         }
[10:21:43.140]                       }
[10:21:43.140]                       invisible(muffled)
[10:21:43.140]                     }
[10:21:43.140]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.140]                   }
[10:21:43.140]                 }
[10:21:43.140]             }
[10:21:43.140]         }))
[10:21:43.140]     }, error = function(ex) {
[10:21:43.140]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.140]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.140]                 ...future.rng), started = ...future.startTime, 
[10:21:43.140]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.140]             version = "1.8"), class = "FutureResult")
[10:21:43.140]     }, finally = {
[10:21:43.140]         if (!identical(...future.workdir, getwd())) 
[10:21:43.140]             setwd(...future.workdir)
[10:21:43.140]         {
[10:21:43.140]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.140]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.140]             }
[10:21:43.140]             base::options(...future.oldOptions)
[10:21:43.140]             if (.Platform$OS.type == "windows") {
[10:21:43.140]                 old_names <- names(...future.oldEnvVars)
[10:21:43.140]                 envs <- base::Sys.getenv()
[10:21:43.140]                 names <- names(envs)
[10:21:43.140]                 common <- intersect(names, old_names)
[10:21:43.140]                 added <- setdiff(names, old_names)
[10:21:43.140]                 removed <- setdiff(old_names, names)
[10:21:43.140]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.140]                   envs[common]]
[10:21:43.140]                 NAMES <- toupper(changed)
[10:21:43.140]                 args <- list()
[10:21:43.140]                 for (kk in seq_along(NAMES)) {
[10:21:43.140]                   name <- changed[[kk]]
[10:21:43.140]                   NAME <- NAMES[[kk]]
[10:21:43.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.140]                     next
[10:21:43.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.140]                 }
[10:21:43.140]                 NAMES <- toupper(added)
[10:21:43.140]                 for (kk in seq_along(NAMES)) {
[10:21:43.140]                   name <- added[[kk]]
[10:21:43.140]                   NAME <- NAMES[[kk]]
[10:21:43.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.140]                     next
[10:21:43.140]                   args[[name]] <- ""
[10:21:43.140]                 }
[10:21:43.140]                 NAMES <- toupper(removed)
[10:21:43.140]                 for (kk in seq_along(NAMES)) {
[10:21:43.140]                   name <- removed[[kk]]
[10:21:43.140]                   NAME <- NAMES[[kk]]
[10:21:43.140]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.140]                     next
[10:21:43.140]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.140]                 }
[10:21:43.140]                 if (length(args) > 0) 
[10:21:43.140]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.140]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.140]             }
[10:21:43.140]             else {
[10:21:43.140]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.140]             }
[10:21:43.140]             {
[10:21:43.140]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.140]                   0L) {
[10:21:43.140]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.140]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.140]                   base::options(opts)
[10:21:43.140]                 }
[10:21:43.140]                 {
[10:21:43.140]                   {
[10:21:43.140]                     NULL
[10:21:43.140]                     RNGkind("Mersenne-Twister")
[10:21:43.140]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.140]                       inherits = FALSE)
[10:21:43.140]                   }
[10:21:43.140]                   options(future.plan = NULL)
[10:21:43.140]                   if (is.na(NA_character_)) 
[10:21:43.140]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.140]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.140]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.140]                     .init = FALSE)
[10:21:43.140]                 }
[10:21:43.140]             }
[10:21:43.140]         }
[10:21:43.140]     })
[10:21:43.140]     if (TRUE) {
[10:21:43.140]         base::sink(type = "output", split = FALSE)
[10:21:43.140]         if (TRUE) {
[10:21:43.140]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.140]         }
[10:21:43.140]         else {
[10:21:43.140]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.140]         }
[10:21:43.140]         base::close(...future.stdout)
[10:21:43.140]         ...future.stdout <- NULL
[10:21:43.140]     }
[10:21:43.140]     ...future.result$conditions <- ...future.conditions
[10:21:43.140]     ...future.result$finished <- base::Sys.time()
[10:21:43.140]     ...future.result
[10:21:43.140] }
[10:21:43.142] assign_globals() ...
[10:21:43.142] List of 1
[10:21:43.142]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18cb73e38> 
[10:21:43.142]  - attr(*, "where")=List of 1
[10:21:43.142]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.142]  - attr(*, "resolved")= logi TRUE
[10:21:43.142]  - attr(*, "total_size")= num 3535
[10:21:43.142]  - attr(*, "already-done")= logi TRUE
[10:21:43.144] - copied ‘a’ to environment
[10:21:43.144] assign_globals() ... done
[10:21:43.145] plan(): Setting new future strategy stack:
[10:21:43.145] List of future strategies:
[10:21:43.145] 1. sequential:
[10:21:43.145]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.145]    - tweaked: FALSE
[10:21:43.145]    - call: NULL
[10:21:43.145] plan(): nbrOfWorkers() = 1
[10:21:43.146] plan(): Setting new future strategy stack:
[10:21:43.146] List of future strategies:
[10:21:43.146] 1. sequential:
[10:21:43.146]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.146]    - tweaked: FALSE
[10:21:43.146]    - call: plan(strategy)
[10:21:43.146] plan(): nbrOfWorkers() = 1
[10:21:43.147] SequentialFuture started (and completed)
[10:21:43.147] - Launch lazy future ... done
[10:21:43.147] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.147] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.147] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.150] 
[10:21:43.150] Searching for globals ... DONE
[10:21:43.150] - globals: [0] <none>
[10:21:43.150] getGlobalsAndPackages() ... DONE
[10:21:43.151] run() for ‘Future’ ...
[10:21:43.151] - state: ‘created’
[10:21:43.151] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.151] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.151] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.151]   - Field: ‘label’
[10:21:43.151]   - Field: ‘local’
[10:21:43.151]   - Field: ‘owner’
[10:21:43.152]   - Field: ‘envir’
[10:21:43.152]   - Field: ‘packages’
[10:21:43.152]   - Field: ‘gc’
[10:21:43.152]   - Field: ‘conditions’
[10:21:43.152]   - Field: ‘expr’
[10:21:43.152]   - Field: ‘uuid’
[10:21:43.152]   - Field: ‘seed’
[10:21:43.152]   - Field: ‘version’
[10:21:43.152]   - Field: ‘result’
[10:21:43.152]   - Field: ‘asynchronous’
[10:21:43.152]   - Field: ‘calls’
[10:21:43.152]   - Field: ‘globals’
[10:21:43.153]   - Field: ‘stdout’
[10:21:43.153]   - Field: ‘earlySignal’
[10:21:43.153]   - Field: ‘lazy’
[10:21:43.153]   - Field: ‘state’
[10:21:43.153] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.153] - Launch lazy future ...
[10:21:43.153] Packages needed by the future expression (n = 0): <none>
[10:21:43.153] Packages needed by future strategies (n = 0): <none>
[10:21:43.154] {
[10:21:43.154]     {
[10:21:43.154]         {
[10:21:43.154]             ...future.startTime <- base::Sys.time()
[10:21:43.154]             {
[10:21:43.154]                 {
[10:21:43.154]                   {
[10:21:43.154]                     base::local({
[10:21:43.154]                       has_future <- base::requireNamespace("future", 
[10:21:43.154]                         quietly = TRUE)
[10:21:43.154]                       if (has_future) {
[10:21:43.154]                         ns <- base::getNamespace("future")
[10:21:43.154]                         version <- ns[[".package"]][["version"]]
[10:21:43.154]                         if (is.null(version)) 
[10:21:43.154]                           version <- utils::packageVersion("future")
[10:21:43.154]                       }
[10:21:43.154]                       else {
[10:21:43.154]                         version <- NULL
[10:21:43.154]                       }
[10:21:43.154]                       if (!has_future || version < "1.8.0") {
[10:21:43.154]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.154]                           "", base::R.version$version.string), 
[10:21:43.154]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.154]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.154]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.154]                             "release", "version")], collapse = " "), 
[10:21:43.154]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.154]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.154]                           info)
[10:21:43.154]                         info <- base::paste(info, collapse = "; ")
[10:21:43.154]                         if (!has_future) {
[10:21:43.154]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.154]                             info)
[10:21:43.154]                         }
[10:21:43.154]                         else {
[10:21:43.154]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.154]                             info, version)
[10:21:43.154]                         }
[10:21:43.154]                         base::stop(msg)
[10:21:43.154]                       }
[10:21:43.154]                     })
[10:21:43.154]                   }
[10:21:43.154]                   ...future.strategy.old <- future::plan("list")
[10:21:43.154]                   options(future.plan = NULL)
[10:21:43.154]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.154]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.154]                 }
[10:21:43.154]                 ...future.workdir <- getwd()
[10:21:43.154]             }
[10:21:43.154]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.154]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.154]         }
[10:21:43.154]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.154]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.154]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.154]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.154]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.154]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.154]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.154]             base::names(...future.oldOptions))
[10:21:43.154]     }
[10:21:43.154]     if (FALSE) {
[10:21:43.154]     }
[10:21:43.154]     else {
[10:21:43.154]         if (TRUE) {
[10:21:43.154]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.154]                 open = "w")
[10:21:43.154]         }
[10:21:43.154]         else {
[10:21:43.154]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.154]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.154]         }
[10:21:43.154]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.154]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.154]             base::sink(type = "output", split = FALSE)
[10:21:43.154]             base::close(...future.stdout)
[10:21:43.154]         }, add = TRUE)
[10:21:43.154]     }
[10:21:43.154]     ...future.frame <- base::sys.nframe()
[10:21:43.154]     ...future.conditions <- base::list()
[10:21:43.154]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.154]     if (FALSE) {
[10:21:43.154]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.154]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.154]     }
[10:21:43.154]     ...future.result <- base::tryCatch({
[10:21:43.154]         base::withCallingHandlers({
[10:21:43.154]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.154]             future::FutureResult(value = ...future.value$value, 
[10:21:43.154]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.154]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.154]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.154]                     ...future.globalenv.names))
[10:21:43.154]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.154]         }, condition = base::local({
[10:21:43.154]             c <- base::c
[10:21:43.154]             inherits <- base::inherits
[10:21:43.154]             invokeRestart <- base::invokeRestart
[10:21:43.154]             length <- base::length
[10:21:43.154]             list <- base::list
[10:21:43.154]             seq.int <- base::seq.int
[10:21:43.154]             signalCondition <- base::signalCondition
[10:21:43.154]             sys.calls <- base::sys.calls
[10:21:43.154]             `[[` <- base::`[[`
[10:21:43.154]             `+` <- base::`+`
[10:21:43.154]             `<<-` <- base::`<<-`
[10:21:43.154]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.154]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.154]                   3L)]
[10:21:43.154]             }
[10:21:43.154]             function(cond) {
[10:21:43.154]                 is_error <- inherits(cond, "error")
[10:21:43.154]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.154]                   NULL)
[10:21:43.154]                 if (is_error) {
[10:21:43.154]                   sessionInformation <- function() {
[10:21:43.154]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.154]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.154]                       search = base::search(), system = base::Sys.info())
[10:21:43.154]                   }
[10:21:43.154]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.154]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.154]                     cond$call), session = sessionInformation(), 
[10:21:43.154]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.154]                   signalCondition(cond)
[10:21:43.154]                 }
[10:21:43.154]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.154]                 "immediateCondition"))) {
[10:21:43.154]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.154]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.154]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.154]                   if (TRUE && !signal) {
[10:21:43.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.154]                     {
[10:21:43.154]                       inherits <- base::inherits
[10:21:43.154]                       invokeRestart <- base::invokeRestart
[10:21:43.154]                       is.null <- base::is.null
[10:21:43.154]                       muffled <- FALSE
[10:21:43.154]                       if (inherits(cond, "message")) {
[10:21:43.154]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.154]                         if (muffled) 
[10:21:43.154]                           invokeRestart("muffleMessage")
[10:21:43.154]                       }
[10:21:43.154]                       else if (inherits(cond, "warning")) {
[10:21:43.154]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.154]                         if (muffled) 
[10:21:43.154]                           invokeRestart("muffleWarning")
[10:21:43.154]                       }
[10:21:43.154]                       else if (inherits(cond, "condition")) {
[10:21:43.154]                         if (!is.null(pattern)) {
[10:21:43.154]                           computeRestarts <- base::computeRestarts
[10:21:43.154]                           grepl <- base::grepl
[10:21:43.154]                           restarts <- computeRestarts(cond)
[10:21:43.154]                           for (restart in restarts) {
[10:21:43.154]                             name <- restart$name
[10:21:43.154]                             if (is.null(name)) 
[10:21:43.154]                               next
[10:21:43.154]                             if (!grepl(pattern, name)) 
[10:21:43.154]                               next
[10:21:43.154]                             invokeRestart(restart)
[10:21:43.154]                             muffled <- TRUE
[10:21:43.154]                             break
[10:21:43.154]                           }
[10:21:43.154]                         }
[10:21:43.154]                       }
[10:21:43.154]                       invisible(muffled)
[10:21:43.154]                     }
[10:21:43.154]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.154]                   }
[10:21:43.154]                 }
[10:21:43.154]                 else {
[10:21:43.154]                   if (TRUE) {
[10:21:43.154]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.154]                     {
[10:21:43.154]                       inherits <- base::inherits
[10:21:43.154]                       invokeRestart <- base::invokeRestart
[10:21:43.154]                       is.null <- base::is.null
[10:21:43.154]                       muffled <- FALSE
[10:21:43.154]                       if (inherits(cond, "message")) {
[10:21:43.154]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.154]                         if (muffled) 
[10:21:43.154]                           invokeRestart("muffleMessage")
[10:21:43.154]                       }
[10:21:43.154]                       else if (inherits(cond, "warning")) {
[10:21:43.154]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.154]                         if (muffled) 
[10:21:43.154]                           invokeRestart("muffleWarning")
[10:21:43.154]                       }
[10:21:43.154]                       else if (inherits(cond, "condition")) {
[10:21:43.154]                         if (!is.null(pattern)) {
[10:21:43.154]                           computeRestarts <- base::computeRestarts
[10:21:43.154]                           grepl <- base::grepl
[10:21:43.154]                           restarts <- computeRestarts(cond)
[10:21:43.154]                           for (restart in restarts) {
[10:21:43.154]                             name <- restart$name
[10:21:43.154]                             if (is.null(name)) 
[10:21:43.154]                               next
[10:21:43.154]                             if (!grepl(pattern, name)) 
[10:21:43.154]                               next
[10:21:43.154]                             invokeRestart(restart)
[10:21:43.154]                             muffled <- TRUE
[10:21:43.154]                             break
[10:21:43.154]                           }
[10:21:43.154]                         }
[10:21:43.154]                       }
[10:21:43.154]                       invisible(muffled)
[10:21:43.154]                     }
[10:21:43.154]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.154]                   }
[10:21:43.154]                 }
[10:21:43.154]             }
[10:21:43.154]         }))
[10:21:43.154]     }, error = function(ex) {
[10:21:43.154]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.154]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.154]                 ...future.rng), started = ...future.startTime, 
[10:21:43.154]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.154]             version = "1.8"), class = "FutureResult")
[10:21:43.154]     }, finally = {
[10:21:43.154]         if (!identical(...future.workdir, getwd())) 
[10:21:43.154]             setwd(...future.workdir)
[10:21:43.154]         {
[10:21:43.154]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.154]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.154]             }
[10:21:43.154]             base::options(...future.oldOptions)
[10:21:43.154]             if (.Platform$OS.type == "windows") {
[10:21:43.154]                 old_names <- names(...future.oldEnvVars)
[10:21:43.154]                 envs <- base::Sys.getenv()
[10:21:43.154]                 names <- names(envs)
[10:21:43.154]                 common <- intersect(names, old_names)
[10:21:43.154]                 added <- setdiff(names, old_names)
[10:21:43.154]                 removed <- setdiff(old_names, names)
[10:21:43.154]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.154]                   envs[common]]
[10:21:43.154]                 NAMES <- toupper(changed)
[10:21:43.154]                 args <- list()
[10:21:43.154]                 for (kk in seq_along(NAMES)) {
[10:21:43.154]                   name <- changed[[kk]]
[10:21:43.154]                   NAME <- NAMES[[kk]]
[10:21:43.154]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.154]                     next
[10:21:43.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.154]                 }
[10:21:43.154]                 NAMES <- toupper(added)
[10:21:43.154]                 for (kk in seq_along(NAMES)) {
[10:21:43.154]                   name <- added[[kk]]
[10:21:43.154]                   NAME <- NAMES[[kk]]
[10:21:43.154]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.154]                     next
[10:21:43.154]                   args[[name]] <- ""
[10:21:43.154]                 }
[10:21:43.154]                 NAMES <- toupper(removed)
[10:21:43.154]                 for (kk in seq_along(NAMES)) {
[10:21:43.154]                   name <- removed[[kk]]
[10:21:43.154]                   NAME <- NAMES[[kk]]
[10:21:43.154]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.154]                     next
[10:21:43.154]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.154]                 }
[10:21:43.154]                 if (length(args) > 0) 
[10:21:43.154]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.154]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.154]             }
[10:21:43.154]             else {
[10:21:43.154]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.154]             }
[10:21:43.154]             {
[10:21:43.154]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.154]                   0L) {
[10:21:43.154]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.154]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.154]                   base::options(opts)
[10:21:43.154]                 }
[10:21:43.154]                 {
[10:21:43.154]                   {
[10:21:43.154]                     NULL
[10:21:43.154]                     RNGkind("Mersenne-Twister")
[10:21:43.154]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.154]                       inherits = FALSE)
[10:21:43.154]                   }
[10:21:43.154]                   options(future.plan = NULL)
[10:21:43.154]                   if (is.na(NA_character_)) 
[10:21:43.154]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.154]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.154]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.154]                     .init = FALSE)
[10:21:43.154]                 }
[10:21:43.154]             }
[10:21:43.154]         }
[10:21:43.154]     })
[10:21:43.154]     if (TRUE) {
[10:21:43.154]         base::sink(type = "output", split = FALSE)
[10:21:43.154]         if (TRUE) {
[10:21:43.154]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.154]         }
[10:21:43.154]         else {
[10:21:43.154]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.154]         }
[10:21:43.154]         base::close(...future.stdout)
[10:21:43.154]         ...future.stdout <- NULL
[10:21:43.154]     }
[10:21:43.154]     ...future.result$conditions <- ...future.conditions
[10:21:43.154]     ...future.result$finished <- base::Sys.time()
[10:21:43.154]     ...future.result
[10:21:43.154] }
[10:21:43.156] plan(): Setting new future strategy stack:
[10:21:43.156] List of future strategies:
[10:21:43.156] 1. sequential:
[10:21:43.156]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.156]    - tweaked: FALSE
[10:21:43.156]    - call: NULL
[10:21:43.157] plan(): nbrOfWorkers() = 1
[10:21:43.158] plan(): Setting new future strategy stack:
[10:21:43.158] List of future strategies:
[10:21:43.158] 1. sequential:
[10:21:43.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.158]    - tweaked: FALSE
[10:21:43.158]    - call: plan(strategy)
[10:21:43.158] plan(): nbrOfWorkers() = 1
[10:21:43.159] SequentialFuture started (and completed)
[10:21:43.159] - Launch lazy future ... done
[10:21:43.159] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.159] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.159] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.160] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.160] Searching for globals ... DONE
[10:21:43.161] Resolving globals: TRUE
[10:21:43.161] Resolving any globals that are futures ...
[10:21:43.161] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.161] Resolving any globals that are futures ... DONE
[10:21:43.161] Resolving futures part of globals (recursively) ...
[10:21:43.161] resolve() on list ...
[10:21:43.162]  recursive: 99
[10:21:43.162]  length: 1
[10:21:43.162]  elements: ‘a’
[10:21:43.162] resolved() for ‘SequentialFuture’ ...
[10:21:43.162] - state: ‘finished’
[10:21:43.162] - run: TRUE
[10:21:43.162] - result: ‘FutureResult’
[10:21:43.162] resolved() for ‘SequentialFuture’ ... done
[10:21:43.162] Future #1
[10:21:43.162] resolved() for ‘SequentialFuture’ ...
[10:21:43.163] - state: ‘finished’
[10:21:43.163] - run: TRUE
[10:21:43.163] - result: ‘FutureResult’
[10:21:43.163] resolved() for ‘SequentialFuture’ ... done
[10:21:43.163] A SequentialFuture was resolved
[10:21:43.163]  length: 0 (resolved future 1)
[10:21:43.163] resolve() on list ... DONE
[10:21:43.163] - globals: [1] ‘a’
[10:21:43.163] Resolving futures part of globals (recursively) ... DONE
[10:21:43.163] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[10:21:43.164] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[10:21:43.164] - globals: [1] ‘a’
[10:21:43.164] - packages: [1] ‘future’
[10:21:43.164] getGlobalsAndPackages() ... DONE
[10:21:43.164] run() for ‘Future’ ...
[10:21:43.165] - state: ‘created’
[10:21:43.165] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.165] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.165] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.165]   - Field: ‘label’
[10:21:43.165]   - Field: ‘local’
[10:21:43.165]   - Field: ‘owner’
[10:21:43.165]   - Field: ‘envir’
[10:21:43.166]   - Field: ‘packages’
[10:21:43.166]   - Field: ‘gc’
[10:21:43.166]   - Field: ‘conditions’
[10:21:43.166]   - Field: ‘expr’
[10:21:43.166]   - Field: ‘uuid’
[10:21:43.166]   - Field: ‘seed’
[10:21:43.166]   - Field: ‘version’
[10:21:43.166]   - Field: ‘result’
[10:21:43.166]   - Field: ‘asynchronous’
[10:21:43.166]   - Field: ‘calls’
[10:21:43.166]   - Field: ‘globals’
[10:21:43.166]   - Field: ‘stdout’
[10:21:43.167]   - Field: ‘earlySignal’
[10:21:43.167]   - Field: ‘lazy’
[10:21:43.167]   - Field: ‘state’
[10:21:43.167] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.167] - Launch lazy future ...
[10:21:43.167] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.167] Packages needed by future strategies (n = 0): <none>
[10:21:43.168] {
[10:21:43.168]     {
[10:21:43.168]         {
[10:21:43.168]             ...future.startTime <- base::Sys.time()
[10:21:43.168]             {
[10:21:43.168]                 {
[10:21:43.168]                   {
[10:21:43.168]                     {
[10:21:43.168]                       base::local({
[10:21:43.168]                         has_future <- base::requireNamespace("future", 
[10:21:43.168]                           quietly = TRUE)
[10:21:43.168]                         if (has_future) {
[10:21:43.168]                           ns <- base::getNamespace("future")
[10:21:43.168]                           version <- ns[[".package"]][["version"]]
[10:21:43.168]                           if (is.null(version)) 
[10:21:43.168]                             version <- utils::packageVersion("future")
[10:21:43.168]                         }
[10:21:43.168]                         else {
[10:21:43.168]                           version <- NULL
[10:21:43.168]                         }
[10:21:43.168]                         if (!has_future || version < "1.8.0") {
[10:21:43.168]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.168]                             "", base::R.version$version.string), 
[10:21:43.168]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.168]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.168]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.168]                               "release", "version")], collapse = " "), 
[10:21:43.168]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.168]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.168]                             info)
[10:21:43.168]                           info <- base::paste(info, collapse = "; ")
[10:21:43.168]                           if (!has_future) {
[10:21:43.168]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.168]                               info)
[10:21:43.168]                           }
[10:21:43.168]                           else {
[10:21:43.168]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.168]                               info, version)
[10:21:43.168]                           }
[10:21:43.168]                           base::stop(msg)
[10:21:43.168]                         }
[10:21:43.168]                       })
[10:21:43.168]                     }
[10:21:43.168]                     base::local({
[10:21:43.168]                       for (pkg in "future") {
[10:21:43.168]                         base::loadNamespace(pkg)
[10:21:43.168]                         base::library(pkg, character.only = TRUE)
[10:21:43.168]                       }
[10:21:43.168]                     })
[10:21:43.168]                   }
[10:21:43.168]                   ...future.strategy.old <- future::plan("list")
[10:21:43.168]                   options(future.plan = NULL)
[10:21:43.168]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.168]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.168]                 }
[10:21:43.168]                 ...future.workdir <- getwd()
[10:21:43.168]             }
[10:21:43.168]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.168]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.168]         }
[10:21:43.168]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.168]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.168]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.168]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.168]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.168]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.168]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.168]             base::names(...future.oldOptions))
[10:21:43.168]     }
[10:21:43.168]     if (FALSE) {
[10:21:43.168]     }
[10:21:43.168]     else {
[10:21:43.168]         if (TRUE) {
[10:21:43.168]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.168]                 open = "w")
[10:21:43.168]         }
[10:21:43.168]         else {
[10:21:43.168]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.168]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.168]         }
[10:21:43.168]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.168]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.168]             base::sink(type = "output", split = FALSE)
[10:21:43.168]             base::close(...future.stdout)
[10:21:43.168]         }, add = TRUE)
[10:21:43.168]     }
[10:21:43.168]     ...future.frame <- base::sys.nframe()
[10:21:43.168]     ...future.conditions <- base::list()
[10:21:43.168]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.168]     if (FALSE) {
[10:21:43.168]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.168]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.168]     }
[10:21:43.168]     ...future.result <- base::tryCatch({
[10:21:43.168]         base::withCallingHandlers({
[10:21:43.168]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.168]                 1))
[10:21:43.168]             future::FutureResult(value = ...future.value$value, 
[10:21:43.168]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.168]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.168]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.168]                     ...future.globalenv.names))
[10:21:43.168]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.168]         }, condition = base::local({
[10:21:43.168]             c <- base::c
[10:21:43.168]             inherits <- base::inherits
[10:21:43.168]             invokeRestart <- base::invokeRestart
[10:21:43.168]             length <- base::length
[10:21:43.168]             list <- base::list
[10:21:43.168]             seq.int <- base::seq.int
[10:21:43.168]             signalCondition <- base::signalCondition
[10:21:43.168]             sys.calls <- base::sys.calls
[10:21:43.168]             `[[` <- base::`[[`
[10:21:43.168]             `+` <- base::`+`
[10:21:43.168]             `<<-` <- base::`<<-`
[10:21:43.168]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.168]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.168]                   3L)]
[10:21:43.168]             }
[10:21:43.168]             function(cond) {
[10:21:43.168]                 is_error <- inherits(cond, "error")
[10:21:43.168]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.168]                   NULL)
[10:21:43.168]                 if (is_error) {
[10:21:43.168]                   sessionInformation <- function() {
[10:21:43.168]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.168]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.168]                       search = base::search(), system = base::Sys.info())
[10:21:43.168]                   }
[10:21:43.168]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.168]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.168]                     cond$call), session = sessionInformation(), 
[10:21:43.168]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.168]                   signalCondition(cond)
[10:21:43.168]                 }
[10:21:43.168]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.168]                 "immediateCondition"))) {
[10:21:43.168]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.168]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.168]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.168]                   if (TRUE && !signal) {
[10:21:43.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.168]                     {
[10:21:43.168]                       inherits <- base::inherits
[10:21:43.168]                       invokeRestart <- base::invokeRestart
[10:21:43.168]                       is.null <- base::is.null
[10:21:43.168]                       muffled <- FALSE
[10:21:43.168]                       if (inherits(cond, "message")) {
[10:21:43.168]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.168]                         if (muffled) 
[10:21:43.168]                           invokeRestart("muffleMessage")
[10:21:43.168]                       }
[10:21:43.168]                       else if (inherits(cond, "warning")) {
[10:21:43.168]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.168]                         if (muffled) 
[10:21:43.168]                           invokeRestart("muffleWarning")
[10:21:43.168]                       }
[10:21:43.168]                       else if (inherits(cond, "condition")) {
[10:21:43.168]                         if (!is.null(pattern)) {
[10:21:43.168]                           computeRestarts <- base::computeRestarts
[10:21:43.168]                           grepl <- base::grepl
[10:21:43.168]                           restarts <- computeRestarts(cond)
[10:21:43.168]                           for (restart in restarts) {
[10:21:43.168]                             name <- restart$name
[10:21:43.168]                             if (is.null(name)) 
[10:21:43.168]                               next
[10:21:43.168]                             if (!grepl(pattern, name)) 
[10:21:43.168]                               next
[10:21:43.168]                             invokeRestart(restart)
[10:21:43.168]                             muffled <- TRUE
[10:21:43.168]                             break
[10:21:43.168]                           }
[10:21:43.168]                         }
[10:21:43.168]                       }
[10:21:43.168]                       invisible(muffled)
[10:21:43.168]                     }
[10:21:43.168]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.168]                   }
[10:21:43.168]                 }
[10:21:43.168]                 else {
[10:21:43.168]                   if (TRUE) {
[10:21:43.168]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.168]                     {
[10:21:43.168]                       inherits <- base::inherits
[10:21:43.168]                       invokeRestart <- base::invokeRestart
[10:21:43.168]                       is.null <- base::is.null
[10:21:43.168]                       muffled <- FALSE
[10:21:43.168]                       if (inherits(cond, "message")) {
[10:21:43.168]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.168]                         if (muffled) 
[10:21:43.168]                           invokeRestart("muffleMessage")
[10:21:43.168]                       }
[10:21:43.168]                       else if (inherits(cond, "warning")) {
[10:21:43.168]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.168]                         if (muffled) 
[10:21:43.168]                           invokeRestart("muffleWarning")
[10:21:43.168]                       }
[10:21:43.168]                       else if (inherits(cond, "condition")) {
[10:21:43.168]                         if (!is.null(pattern)) {
[10:21:43.168]                           computeRestarts <- base::computeRestarts
[10:21:43.168]                           grepl <- base::grepl
[10:21:43.168]                           restarts <- computeRestarts(cond)
[10:21:43.168]                           for (restart in restarts) {
[10:21:43.168]                             name <- restart$name
[10:21:43.168]                             if (is.null(name)) 
[10:21:43.168]                               next
[10:21:43.168]                             if (!grepl(pattern, name)) 
[10:21:43.168]                               next
[10:21:43.168]                             invokeRestart(restart)
[10:21:43.168]                             muffled <- TRUE
[10:21:43.168]                             break
[10:21:43.168]                           }
[10:21:43.168]                         }
[10:21:43.168]                       }
[10:21:43.168]                       invisible(muffled)
[10:21:43.168]                     }
[10:21:43.168]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.168]                   }
[10:21:43.168]                 }
[10:21:43.168]             }
[10:21:43.168]         }))
[10:21:43.168]     }, error = function(ex) {
[10:21:43.168]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.168]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.168]                 ...future.rng), started = ...future.startTime, 
[10:21:43.168]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.168]             version = "1.8"), class = "FutureResult")
[10:21:43.168]     }, finally = {
[10:21:43.168]         if (!identical(...future.workdir, getwd())) 
[10:21:43.168]             setwd(...future.workdir)
[10:21:43.168]         {
[10:21:43.168]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.168]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.168]             }
[10:21:43.168]             base::options(...future.oldOptions)
[10:21:43.168]             if (.Platform$OS.type == "windows") {
[10:21:43.168]                 old_names <- names(...future.oldEnvVars)
[10:21:43.168]                 envs <- base::Sys.getenv()
[10:21:43.168]                 names <- names(envs)
[10:21:43.168]                 common <- intersect(names, old_names)
[10:21:43.168]                 added <- setdiff(names, old_names)
[10:21:43.168]                 removed <- setdiff(old_names, names)
[10:21:43.168]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.168]                   envs[common]]
[10:21:43.168]                 NAMES <- toupper(changed)
[10:21:43.168]                 args <- list()
[10:21:43.168]                 for (kk in seq_along(NAMES)) {
[10:21:43.168]                   name <- changed[[kk]]
[10:21:43.168]                   NAME <- NAMES[[kk]]
[10:21:43.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.168]                     next
[10:21:43.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.168]                 }
[10:21:43.168]                 NAMES <- toupper(added)
[10:21:43.168]                 for (kk in seq_along(NAMES)) {
[10:21:43.168]                   name <- added[[kk]]
[10:21:43.168]                   NAME <- NAMES[[kk]]
[10:21:43.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.168]                     next
[10:21:43.168]                   args[[name]] <- ""
[10:21:43.168]                 }
[10:21:43.168]                 NAMES <- toupper(removed)
[10:21:43.168]                 for (kk in seq_along(NAMES)) {
[10:21:43.168]                   name <- removed[[kk]]
[10:21:43.168]                   NAME <- NAMES[[kk]]
[10:21:43.168]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.168]                     next
[10:21:43.168]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.168]                 }
[10:21:43.168]                 if (length(args) > 0) 
[10:21:43.168]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.168]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.168]             }
[10:21:43.168]             else {
[10:21:43.168]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.168]             }
[10:21:43.168]             {
[10:21:43.168]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.168]                   0L) {
[10:21:43.168]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.168]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.168]                   base::options(opts)
[10:21:43.168]                 }
[10:21:43.168]                 {
[10:21:43.168]                   {
[10:21:43.168]                     NULL
[10:21:43.168]                     RNGkind("Mersenne-Twister")
[10:21:43.168]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.168]                       inherits = FALSE)
[10:21:43.168]                   }
[10:21:43.168]                   options(future.plan = NULL)
[10:21:43.168]                   if (is.na(NA_character_)) 
[10:21:43.168]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.168]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.168]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.168]                     .init = FALSE)
[10:21:43.168]                 }
[10:21:43.168]             }
[10:21:43.168]         }
[10:21:43.168]     })
[10:21:43.168]     if (TRUE) {
[10:21:43.168]         base::sink(type = "output", split = FALSE)
[10:21:43.168]         if (TRUE) {
[10:21:43.168]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.168]         }
[10:21:43.168]         else {
[10:21:43.168]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.168]         }
[10:21:43.168]         base::close(...future.stdout)
[10:21:43.168]         ...future.stdout <- NULL
[10:21:43.168]     }
[10:21:43.168]     ...future.result$conditions <- ...future.conditions
[10:21:43.168]     ...future.result$finished <- base::Sys.time()
[10:21:43.168]     ...future.result
[10:21:43.168] }
[10:21:43.169] assign_globals() ...
[10:21:43.170] List of 1
[10:21:43.170]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18da5c6a0> 
[10:21:43.170]  - attr(*, "where")=List of 1
[10:21:43.170]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.170]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.170]  - attr(*, "resolved")= logi TRUE
[10:21:43.170]  - attr(*, "total_size")= num 3535
[10:21:43.170]  - attr(*, "already-done")= logi TRUE
[10:21:43.172] - copied ‘a’ to environment
[10:21:43.172] assign_globals() ... done
[10:21:43.173] plan(): Setting new future strategy stack:
[10:21:43.173] List of future strategies:
[10:21:43.173] 1. sequential:
[10:21:43.173]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.173]    - tweaked: FALSE
[10:21:43.173]    - call: NULL
[10:21:43.173] plan(): nbrOfWorkers() = 1
[10:21:43.174] plan(): Setting new future strategy stack:
[10:21:43.174] List of future strategies:
[10:21:43.174] 1. sequential:
[10:21:43.174]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.174]    - tweaked: FALSE
[10:21:43.174]    - call: plan(strategy)
[10:21:43.174] plan(): nbrOfWorkers() = 1
[10:21:43.175] SequentialFuture started (and completed)
[10:21:43.175] - Launch lazy future ... done
[10:21:43.175] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.175] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.175] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.176] 
[10:21:43.176] Searching for globals ... DONE
[10:21:43.176] - globals: [0] <none>
[10:21:43.176] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.176] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.177] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.178] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.178] Searching for globals ... DONE
[10:21:43.178] Resolving globals: TRUE
[10:21:43.178] Resolving any globals that are futures ...
[10:21:43.178] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.178] Resolving any globals that are futures ... DONE
[10:21:43.178] Resolving futures part of globals (recursively) ...
[10:21:43.180] resolve() on list ...
[10:21:43.180]  recursive: 99
[10:21:43.181]  length: 1
[10:21:43.181]  elements: ‘a’
[10:21:43.181] run() for ‘Future’ ...
[10:21:43.181] - state: ‘created’
[10:21:43.181] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.181] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.181] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.181]   - Field: ‘label’
[10:21:43.182]   - Field: ‘local’
[10:21:43.182]   - Field: ‘owner’
[10:21:43.182]   - Field: ‘envir’
[10:21:43.182]   - Field: ‘packages’
[10:21:43.182]   - Field: ‘gc’
[10:21:43.182]   - Field: ‘conditions’
[10:21:43.182]   - Field: ‘expr’
[10:21:43.182]   - Field: ‘uuid’
[10:21:43.182]   - Field: ‘seed’
[10:21:43.182]   - Field: ‘version’
[10:21:43.182]   - Field: ‘result’
[10:21:43.183]   - Field: ‘asynchronous’
[10:21:43.183]   - Field: ‘calls’
[10:21:43.183]   - Field: ‘globals’
[10:21:43.183]   - Field: ‘stdout’
[10:21:43.183]   - Field: ‘earlySignal’
[10:21:43.183]   - Field: ‘lazy’
[10:21:43.183]   - Field: ‘state’
[10:21:43.183] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.183] - Launch lazy future ...
[10:21:43.183] Packages needed by the future expression (n = 0): <none>
[10:21:43.183] Packages needed by future strategies (n = 0): <none>
[10:21:43.184] {
[10:21:43.184]     {
[10:21:43.184]         {
[10:21:43.184]             ...future.startTime <- base::Sys.time()
[10:21:43.184]             {
[10:21:43.184]                 {
[10:21:43.184]                   {
[10:21:43.184]                     base::local({
[10:21:43.184]                       has_future <- base::requireNamespace("future", 
[10:21:43.184]                         quietly = TRUE)
[10:21:43.184]                       if (has_future) {
[10:21:43.184]                         ns <- base::getNamespace("future")
[10:21:43.184]                         version <- ns[[".package"]][["version"]]
[10:21:43.184]                         if (is.null(version)) 
[10:21:43.184]                           version <- utils::packageVersion("future")
[10:21:43.184]                       }
[10:21:43.184]                       else {
[10:21:43.184]                         version <- NULL
[10:21:43.184]                       }
[10:21:43.184]                       if (!has_future || version < "1.8.0") {
[10:21:43.184]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.184]                           "", base::R.version$version.string), 
[10:21:43.184]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.184]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.184]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.184]                             "release", "version")], collapse = " "), 
[10:21:43.184]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.184]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.184]                           info)
[10:21:43.184]                         info <- base::paste(info, collapse = "; ")
[10:21:43.184]                         if (!has_future) {
[10:21:43.184]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.184]                             info)
[10:21:43.184]                         }
[10:21:43.184]                         else {
[10:21:43.184]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.184]                             info, version)
[10:21:43.184]                         }
[10:21:43.184]                         base::stop(msg)
[10:21:43.184]                       }
[10:21:43.184]                     })
[10:21:43.184]                   }
[10:21:43.184]                   ...future.strategy.old <- future::plan("list")
[10:21:43.184]                   options(future.plan = NULL)
[10:21:43.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.184]                 }
[10:21:43.184]                 ...future.workdir <- getwd()
[10:21:43.184]             }
[10:21:43.184]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.184]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.184]         }
[10:21:43.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.184]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.184]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.184]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.184]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.184]             base::names(...future.oldOptions))
[10:21:43.184]     }
[10:21:43.184]     if (FALSE) {
[10:21:43.184]     }
[10:21:43.184]     else {
[10:21:43.184]         if (TRUE) {
[10:21:43.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.184]                 open = "w")
[10:21:43.184]         }
[10:21:43.184]         else {
[10:21:43.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.184]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.184]         }
[10:21:43.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.184]             base::sink(type = "output", split = FALSE)
[10:21:43.184]             base::close(...future.stdout)
[10:21:43.184]         }, add = TRUE)
[10:21:43.184]     }
[10:21:43.184]     ...future.frame <- base::sys.nframe()
[10:21:43.184]     ...future.conditions <- base::list()
[10:21:43.184]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.184]     if (FALSE) {
[10:21:43.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.184]     }
[10:21:43.184]     ...future.result <- base::tryCatch({
[10:21:43.184]         base::withCallingHandlers({
[10:21:43.184]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.184]             future::FutureResult(value = ...future.value$value, 
[10:21:43.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.184]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.184]                     ...future.globalenv.names))
[10:21:43.184]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.184]         }, condition = base::local({
[10:21:43.184]             c <- base::c
[10:21:43.184]             inherits <- base::inherits
[10:21:43.184]             invokeRestart <- base::invokeRestart
[10:21:43.184]             length <- base::length
[10:21:43.184]             list <- base::list
[10:21:43.184]             seq.int <- base::seq.int
[10:21:43.184]             signalCondition <- base::signalCondition
[10:21:43.184]             sys.calls <- base::sys.calls
[10:21:43.184]             `[[` <- base::`[[`
[10:21:43.184]             `+` <- base::`+`
[10:21:43.184]             `<<-` <- base::`<<-`
[10:21:43.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.184]                   3L)]
[10:21:43.184]             }
[10:21:43.184]             function(cond) {
[10:21:43.184]                 is_error <- inherits(cond, "error")
[10:21:43.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.184]                   NULL)
[10:21:43.184]                 if (is_error) {
[10:21:43.184]                   sessionInformation <- function() {
[10:21:43.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.184]                       search = base::search(), system = base::Sys.info())
[10:21:43.184]                   }
[10:21:43.184]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.184]                     cond$call), session = sessionInformation(), 
[10:21:43.184]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.184]                   signalCondition(cond)
[10:21:43.184]                 }
[10:21:43.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.184]                 "immediateCondition"))) {
[10:21:43.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.184]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.184]                   if (TRUE && !signal) {
[10:21:43.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.184]                     {
[10:21:43.184]                       inherits <- base::inherits
[10:21:43.184]                       invokeRestart <- base::invokeRestart
[10:21:43.184]                       is.null <- base::is.null
[10:21:43.184]                       muffled <- FALSE
[10:21:43.184]                       if (inherits(cond, "message")) {
[10:21:43.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.184]                         if (muffled) 
[10:21:43.184]                           invokeRestart("muffleMessage")
[10:21:43.184]                       }
[10:21:43.184]                       else if (inherits(cond, "warning")) {
[10:21:43.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.184]                         if (muffled) 
[10:21:43.184]                           invokeRestart("muffleWarning")
[10:21:43.184]                       }
[10:21:43.184]                       else if (inherits(cond, "condition")) {
[10:21:43.184]                         if (!is.null(pattern)) {
[10:21:43.184]                           computeRestarts <- base::computeRestarts
[10:21:43.184]                           grepl <- base::grepl
[10:21:43.184]                           restarts <- computeRestarts(cond)
[10:21:43.184]                           for (restart in restarts) {
[10:21:43.184]                             name <- restart$name
[10:21:43.184]                             if (is.null(name)) 
[10:21:43.184]                               next
[10:21:43.184]                             if (!grepl(pattern, name)) 
[10:21:43.184]                               next
[10:21:43.184]                             invokeRestart(restart)
[10:21:43.184]                             muffled <- TRUE
[10:21:43.184]                             break
[10:21:43.184]                           }
[10:21:43.184]                         }
[10:21:43.184]                       }
[10:21:43.184]                       invisible(muffled)
[10:21:43.184]                     }
[10:21:43.184]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.184]                   }
[10:21:43.184]                 }
[10:21:43.184]                 else {
[10:21:43.184]                   if (TRUE) {
[10:21:43.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.184]                     {
[10:21:43.184]                       inherits <- base::inherits
[10:21:43.184]                       invokeRestart <- base::invokeRestart
[10:21:43.184]                       is.null <- base::is.null
[10:21:43.184]                       muffled <- FALSE
[10:21:43.184]                       if (inherits(cond, "message")) {
[10:21:43.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.184]                         if (muffled) 
[10:21:43.184]                           invokeRestart("muffleMessage")
[10:21:43.184]                       }
[10:21:43.184]                       else if (inherits(cond, "warning")) {
[10:21:43.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.184]                         if (muffled) 
[10:21:43.184]                           invokeRestart("muffleWarning")
[10:21:43.184]                       }
[10:21:43.184]                       else if (inherits(cond, "condition")) {
[10:21:43.184]                         if (!is.null(pattern)) {
[10:21:43.184]                           computeRestarts <- base::computeRestarts
[10:21:43.184]                           grepl <- base::grepl
[10:21:43.184]                           restarts <- computeRestarts(cond)
[10:21:43.184]                           for (restart in restarts) {
[10:21:43.184]                             name <- restart$name
[10:21:43.184]                             if (is.null(name)) 
[10:21:43.184]                               next
[10:21:43.184]                             if (!grepl(pattern, name)) 
[10:21:43.184]                               next
[10:21:43.184]                             invokeRestart(restart)
[10:21:43.184]                             muffled <- TRUE
[10:21:43.184]                             break
[10:21:43.184]                           }
[10:21:43.184]                         }
[10:21:43.184]                       }
[10:21:43.184]                       invisible(muffled)
[10:21:43.184]                     }
[10:21:43.184]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.184]                   }
[10:21:43.184]                 }
[10:21:43.184]             }
[10:21:43.184]         }))
[10:21:43.184]     }, error = function(ex) {
[10:21:43.184]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.184]                 ...future.rng), started = ...future.startTime, 
[10:21:43.184]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.184]             version = "1.8"), class = "FutureResult")
[10:21:43.184]     }, finally = {
[10:21:43.184]         if (!identical(...future.workdir, getwd())) 
[10:21:43.184]             setwd(...future.workdir)
[10:21:43.184]         {
[10:21:43.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.184]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.184]             }
[10:21:43.184]             base::options(...future.oldOptions)
[10:21:43.184]             if (.Platform$OS.type == "windows") {
[10:21:43.184]                 old_names <- names(...future.oldEnvVars)
[10:21:43.184]                 envs <- base::Sys.getenv()
[10:21:43.184]                 names <- names(envs)
[10:21:43.184]                 common <- intersect(names, old_names)
[10:21:43.184]                 added <- setdiff(names, old_names)
[10:21:43.184]                 removed <- setdiff(old_names, names)
[10:21:43.184]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.184]                   envs[common]]
[10:21:43.184]                 NAMES <- toupper(changed)
[10:21:43.184]                 args <- list()
[10:21:43.184]                 for (kk in seq_along(NAMES)) {
[10:21:43.184]                   name <- changed[[kk]]
[10:21:43.184]                   NAME <- NAMES[[kk]]
[10:21:43.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.184]                     next
[10:21:43.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.184]                 }
[10:21:43.184]                 NAMES <- toupper(added)
[10:21:43.184]                 for (kk in seq_along(NAMES)) {
[10:21:43.184]                   name <- added[[kk]]
[10:21:43.184]                   NAME <- NAMES[[kk]]
[10:21:43.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.184]                     next
[10:21:43.184]                   args[[name]] <- ""
[10:21:43.184]                 }
[10:21:43.184]                 NAMES <- toupper(removed)
[10:21:43.184]                 for (kk in seq_along(NAMES)) {
[10:21:43.184]                   name <- removed[[kk]]
[10:21:43.184]                   NAME <- NAMES[[kk]]
[10:21:43.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.184]                     next
[10:21:43.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.184]                 }
[10:21:43.184]                 if (length(args) > 0) 
[10:21:43.184]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.184]             }
[10:21:43.184]             else {
[10:21:43.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.184]             }
[10:21:43.184]             {
[10:21:43.184]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.184]                   0L) {
[10:21:43.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.184]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.184]                   base::options(opts)
[10:21:43.184]                 }
[10:21:43.184]                 {
[10:21:43.184]                   {
[10:21:43.184]                     NULL
[10:21:43.184]                     RNGkind("Mersenne-Twister")
[10:21:43.184]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.184]                       inherits = FALSE)
[10:21:43.184]                   }
[10:21:43.184]                   options(future.plan = NULL)
[10:21:43.184]                   if (is.na(NA_character_)) 
[10:21:43.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.184]                     .init = FALSE)
[10:21:43.184]                 }
[10:21:43.184]             }
[10:21:43.184]         }
[10:21:43.184]     })
[10:21:43.184]     if (TRUE) {
[10:21:43.184]         base::sink(type = "output", split = FALSE)
[10:21:43.184]         if (TRUE) {
[10:21:43.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.184]         }
[10:21:43.184]         else {
[10:21:43.184]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.184]         }
[10:21:43.184]         base::close(...future.stdout)
[10:21:43.184]         ...future.stdout <- NULL
[10:21:43.184]     }
[10:21:43.184]     ...future.result$conditions <- ...future.conditions
[10:21:43.184]     ...future.result$finished <- base::Sys.time()
[10:21:43.184]     ...future.result
[10:21:43.184] }
[10:21:43.186] plan(): Setting new future strategy stack:
[10:21:43.186] List of future strategies:
[10:21:43.186] 1. sequential:
[10:21:43.186]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.186]    - tweaked: FALSE
[10:21:43.186]    - call: NULL
[10:21:43.186] plan(): nbrOfWorkers() = 1
[10:21:43.187] plan(): Setting new future strategy stack:
[10:21:43.187] List of future strategies:
[10:21:43.187] 1. sequential:
[10:21:43.187]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.187]    - tweaked: FALSE
[10:21:43.187]    - call: plan(strategy)
[10:21:43.187] plan(): nbrOfWorkers() = 1
[10:21:43.188] SequentialFuture started (and completed)
[10:21:43.188] - Launch lazy future ... done
[10:21:43.188] run() for ‘SequentialFuture’ ... done
[10:21:43.188] resolved() for ‘SequentialFuture’ ...
[10:21:43.188] - state: ‘finished’
[10:21:43.188] - run: TRUE
[10:21:43.188] - result: ‘FutureResult’
[10:21:43.188] resolved() for ‘SequentialFuture’ ... done
[10:21:43.188] Future #1
[10:21:43.189] resolved() for ‘SequentialFuture’ ...
[10:21:43.189] - state: ‘finished’
[10:21:43.189] - run: TRUE
[10:21:43.189] - result: ‘FutureResult’
[10:21:43.189] resolved() for ‘SequentialFuture’ ... done
[10:21:43.189] A SequentialFuture was resolved
[10:21:43.189]  length: 0 (resolved future 1)
[10:21:43.189] resolve() on list ... DONE
[10:21:43.189] - globals: [1] ‘a’
[10:21:43.189] Resolving futures part of globals (recursively) ... DONE
[10:21:43.190] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[10:21:43.190] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[10:21:43.190] - globals: [1] ‘a’
[10:21:43.190] - packages: [1] ‘future’
[10:21:43.190] getGlobalsAndPackages() ... DONE
[10:21:43.190] run() for ‘Future’ ...
[10:21:43.191] - state: ‘created’
[10:21:43.191] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.191] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.191]   - Field: ‘label’
[10:21:43.191]   - Field: ‘local’
[10:21:43.191]   - Field: ‘owner’
[10:21:43.191]   - Field: ‘envir’
[10:21:43.191]   - Field: ‘packages’
[10:21:43.192]   - Field: ‘gc’
[10:21:43.192]   - Field: ‘conditions’
[10:21:43.192]   - Field: ‘expr’
[10:21:43.192]   - Field: ‘uuid’
[10:21:43.192]   - Field: ‘seed’
[10:21:43.192]   - Field: ‘version’
[10:21:43.192]   - Field: ‘result’
[10:21:43.192]   - Field: ‘asynchronous’
[10:21:43.192]   - Field: ‘calls’
[10:21:43.192]   - Field: ‘globals’
[10:21:43.192]   - Field: ‘stdout’
[10:21:43.192]   - Field: ‘earlySignal’
[10:21:43.193]   - Field: ‘lazy’
[10:21:43.193]   - Field: ‘state’
[10:21:43.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.193] - Launch lazy future ...
[10:21:43.193] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.193] Packages needed by future strategies (n = 0): <none>
[10:21:43.194] {
[10:21:43.194]     {
[10:21:43.194]         {
[10:21:43.194]             ...future.startTime <- base::Sys.time()
[10:21:43.194]             {
[10:21:43.194]                 {
[10:21:43.194]                   {
[10:21:43.194]                     {
[10:21:43.194]                       base::local({
[10:21:43.194]                         has_future <- base::requireNamespace("future", 
[10:21:43.194]                           quietly = TRUE)
[10:21:43.194]                         if (has_future) {
[10:21:43.194]                           ns <- base::getNamespace("future")
[10:21:43.194]                           version <- ns[[".package"]][["version"]]
[10:21:43.194]                           if (is.null(version)) 
[10:21:43.194]                             version <- utils::packageVersion("future")
[10:21:43.194]                         }
[10:21:43.194]                         else {
[10:21:43.194]                           version <- NULL
[10:21:43.194]                         }
[10:21:43.194]                         if (!has_future || version < "1.8.0") {
[10:21:43.194]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.194]                             "", base::R.version$version.string), 
[10:21:43.194]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.194]                               "release", "version")], collapse = " "), 
[10:21:43.194]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.194]                             info)
[10:21:43.194]                           info <- base::paste(info, collapse = "; ")
[10:21:43.194]                           if (!has_future) {
[10:21:43.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.194]                               info)
[10:21:43.194]                           }
[10:21:43.194]                           else {
[10:21:43.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.194]                               info, version)
[10:21:43.194]                           }
[10:21:43.194]                           base::stop(msg)
[10:21:43.194]                         }
[10:21:43.194]                       })
[10:21:43.194]                     }
[10:21:43.194]                     base::local({
[10:21:43.194]                       for (pkg in "future") {
[10:21:43.194]                         base::loadNamespace(pkg)
[10:21:43.194]                         base::library(pkg, character.only = TRUE)
[10:21:43.194]                       }
[10:21:43.194]                     })
[10:21:43.194]                   }
[10:21:43.194]                   ...future.strategy.old <- future::plan("list")
[10:21:43.194]                   options(future.plan = NULL)
[10:21:43.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.194]                 }
[10:21:43.194]                 ...future.workdir <- getwd()
[10:21:43.194]             }
[10:21:43.194]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.194]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.194]         }
[10:21:43.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.194]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.194]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.194]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.194]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.194]             base::names(...future.oldOptions))
[10:21:43.194]     }
[10:21:43.194]     if (FALSE) {
[10:21:43.194]     }
[10:21:43.194]     else {
[10:21:43.194]         if (TRUE) {
[10:21:43.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.194]                 open = "w")
[10:21:43.194]         }
[10:21:43.194]         else {
[10:21:43.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.194]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.194]         }
[10:21:43.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.194]             base::sink(type = "output", split = FALSE)
[10:21:43.194]             base::close(...future.stdout)
[10:21:43.194]         }, add = TRUE)
[10:21:43.194]     }
[10:21:43.194]     ...future.frame <- base::sys.nframe()
[10:21:43.194]     ...future.conditions <- base::list()
[10:21:43.194]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.194]     if (FALSE) {
[10:21:43.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.194]     }
[10:21:43.194]     ...future.result <- base::tryCatch({
[10:21:43.194]         base::withCallingHandlers({
[10:21:43.194]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.194]                 1))
[10:21:43.194]             future::FutureResult(value = ...future.value$value, 
[10:21:43.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.194]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.194]                     ...future.globalenv.names))
[10:21:43.194]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.194]         }, condition = base::local({
[10:21:43.194]             c <- base::c
[10:21:43.194]             inherits <- base::inherits
[10:21:43.194]             invokeRestart <- base::invokeRestart
[10:21:43.194]             length <- base::length
[10:21:43.194]             list <- base::list
[10:21:43.194]             seq.int <- base::seq.int
[10:21:43.194]             signalCondition <- base::signalCondition
[10:21:43.194]             sys.calls <- base::sys.calls
[10:21:43.194]             `[[` <- base::`[[`
[10:21:43.194]             `+` <- base::`+`
[10:21:43.194]             `<<-` <- base::`<<-`
[10:21:43.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.194]                   3L)]
[10:21:43.194]             }
[10:21:43.194]             function(cond) {
[10:21:43.194]                 is_error <- inherits(cond, "error")
[10:21:43.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.194]                   NULL)
[10:21:43.194]                 if (is_error) {
[10:21:43.194]                   sessionInformation <- function() {
[10:21:43.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.194]                       search = base::search(), system = base::Sys.info())
[10:21:43.194]                   }
[10:21:43.194]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.194]                     cond$call), session = sessionInformation(), 
[10:21:43.194]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.194]                   signalCondition(cond)
[10:21:43.194]                 }
[10:21:43.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.194]                 "immediateCondition"))) {
[10:21:43.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.194]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.194]                   if (TRUE && !signal) {
[10:21:43.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.194]                     {
[10:21:43.194]                       inherits <- base::inherits
[10:21:43.194]                       invokeRestart <- base::invokeRestart
[10:21:43.194]                       is.null <- base::is.null
[10:21:43.194]                       muffled <- FALSE
[10:21:43.194]                       if (inherits(cond, "message")) {
[10:21:43.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.194]                         if (muffled) 
[10:21:43.194]                           invokeRestart("muffleMessage")
[10:21:43.194]                       }
[10:21:43.194]                       else if (inherits(cond, "warning")) {
[10:21:43.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.194]                         if (muffled) 
[10:21:43.194]                           invokeRestart("muffleWarning")
[10:21:43.194]                       }
[10:21:43.194]                       else if (inherits(cond, "condition")) {
[10:21:43.194]                         if (!is.null(pattern)) {
[10:21:43.194]                           computeRestarts <- base::computeRestarts
[10:21:43.194]                           grepl <- base::grepl
[10:21:43.194]                           restarts <- computeRestarts(cond)
[10:21:43.194]                           for (restart in restarts) {
[10:21:43.194]                             name <- restart$name
[10:21:43.194]                             if (is.null(name)) 
[10:21:43.194]                               next
[10:21:43.194]                             if (!grepl(pattern, name)) 
[10:21:43.194]                               next
[10:21:43.194]                             invokeRestart(restart)
[10:21:43.194]                             muffled <- TRUE
[10:21:43.194]                             break
[10:21:43.194]                           }
[10:21:43.194]                         }
[10:21:43.194]                       }
[10:21:43.194]                       invisible(muffled)
[10:21:43.194]                     }
[10:21:43.194]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.194]                   }
[10:21:43.194]                 }
[10:21:43.194]                 else {
[10:21:43.194]                   if (TRUE) {
[10:21:43.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.194]                     {
[10:21:43.194]                       inherits <- base::inherits
[10:21:43.194]                       invokeRestart <- base::invokeRestart
[10:21:43.194]                       is.null <- base::is.null
[10:21:43.194]                       muffled <- FALSE
[10:21:43.194]                       if (inherits(cond, "message")) {
[10:21:43.194]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.194]                         if (muffled) 
[10:21:43.194]                           invokeRestart("muffleMessage")
[10:21:43.194]                       }
[10:21:43.194]                       else if (inherits(cond, "warning")) {
[10:21:43.194]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.194]                         if (muffled) 
[10:21:43.194]                           invokeRestart("muffleWarning")
[10:21:43.194]                       }
[10:21:43.194]                       else if (inherits(cond, "condition")) {
[10:21:43.194]                         if (!is.null(pattern)) {
[10:21:43.194]                           computeRestarts <- base::computeRestarts
[10:21:43.194]                           grepl <- base::grepl
[10:21:43.194]                           restarts <- computeRestarts(cond)
[10:21:43.194]                           for (restart in restarts) {
[10:21:43.194]                             name <- restart$name
[10:21:43.194]                             if (is.null(name)) 
[10:21:43.194]                               next
[10:21:43.194]                             if (!grepl(pattern, name)) 
[10:21:43.194]                               next
[10:21:43.194]                             invokeRestart(restart)
[10:21:43.194]                             muffled <- TRUE
[10:21:43.194]                             break
[10:21:43.194]                           }
[10:21:43.194]                         }
[10:21:43.194]                       }
[10:21:43.194]                       invisible(muffled)
[10:21:43.194]                     }
[10:21:43.194]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.194]                   }
[10:21:43.194]                 }
[10:21:43.194]             }
[10:21:43.194]         }))
[10:21:43.194]     }, error = function(ex) {
[10:21:43.194]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.194]                 ...future.rng), started = ...future.startTime, 
[10:21:43.194]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.194]             version = "1.8"), class = "FutureResult")
[10:21:43.194]     }, finally = {
[10:21:43.194]         if (!identical(...future.workdir, getwd())) 
[10:21:43.194]             setwd(...future.workdir)
[10:21:43.194]         {
[10:21:43.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.194]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.194]             }
[10:21:43.194]             base::options(...future.oldOptions)
[10:21:43.194]             if (.Platform$OS.type == "windows") {
[10:21:43.194]                 old_names <- names(...future.oldEnvVars)
[10:21:43.194]                 envs <- base::Sys.getenv()
[10:21:43.194]                 names <- names(envs)
[10:21:43.194]                 common <- intersect(names, old_names)
[10:21:43.194]                 added <- setdiff(names, old_names)
[10:21:43.194]                 removed <- setdiff(old_names, names)
[10:21:43.194]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.194]                   envs[common]]
[10:21:43.194]                 NAMES <- toupper(changed)
[10:21:43.194]                 args <- list()
[10:21:43.194]                 for (kk in seq_along(NAMES)) {
[10:21:43.194]                   name <- changed[[kk]]
[10:21:43.194]                   NAME <- NAMES[[kk]]
[10:21:43.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.194]                     next
[10:21:43.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.194]                 }
[10:21:43.194]                 NAMES <- toupper(added)
[10:21:43.194]                 for (kk in seq_along(NAMES)) {
[10:21:43.194]                   name <- added[[kk]]
[10:21:43.194]                   NAME <- NAMES[[kk]]
[10:21:43.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.194]                     next
[10:21:43.194]                   args[[name]] <- ""
[10:21:43.194]                 }
[10:21:43.194]                 NAMES <- toupper(removed)
[10:21:43.194]                 for (kk in seq_along(NAMES)) {
[10:21:43.194]                   name <- removed[[kk]]
[10:21:43.194]                   NAME <- NAMES[[kk]]
[10:21:43.194]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.194]                     next
[10:21:43.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.194]                 }
[10:21:43.194]                 if (length(args) > 0) 
[10:21:43.194]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.194]             }
[10:21:43.194]             else {
[10:21:43.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.194]             }
[10:21:43.194]             {
[10:21:43.194]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.194]                   0L) {
[10:21:43.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.194]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.194]                   base::options(opts)
[10:21:43.194]                 }
[10:21:43.194]                 {
[10:21:43.194]                   {
[10:21:43.194]                     NULL
[10:21:43.194]                     RNGkind("Mersenne-Twister")
[10:21:43.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.194]                       inherits = FALSE)
[10:21:43.194]                   }
[10:21:43.194]                   options(future.plan = NULL)
[10:21:43.194]                   if (is.na(NA_character_)) 
[10:21:43.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.194]                     .init = FALSE)
[10:21:43.194]                 }
[10:21:43.194]             }
[10:21:43.194]         }
[10:21:43.194]     })
[10:21:43.194]     if (TRUE) {
[10:21:43.194]         base::sink(type = "output", split = FALSE)
[10:21:43.194]         if (TRUE) {
[10:21:43.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.194]         }
[10:21:43.194]         else {
[10:21:43.194]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.194]         }
[10:21:43.194]         base::close(...future.stdout)
[10:21:43.194]         ...future.stdout <- NULL
[10:21:43.194]     }
[10:21:43.194]     ...future.result$conditions <- ...future.conditions
[10:21:43.194]     ...future.result$finished <- base::Sys.time()
[10:21:43.194]     ...future.result
[10:21:43.194] }
[10:21:43.195] assign_globals() ...
[10:21:43.195] List of 1
[10:21:43.195]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18ea658a0> 
[10:21:43.195]  - attr(*, "where")=List of 1
[10:21:43.195]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.195]  - attr(*, "resolved")= logi TRUE
[10:21:43.195]  - attr(*, "total_size")= num 3555
[10:21:43.195]  - attr(*, "already-done")= logi TRUE
[10:21:43.198] - copied ‘a’ to environment
[10:21:43.198] assign_globals() ... done
[10:21:43.198] plan(): Setting new future strategy stack:
[10:21:43.198] List of future strategies:
[10:21:43.198] 1. sequential:
[10:21:43.198]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.198]    - tweaked: FALSE
[10:21:43.198]    - call: NULL
[10:21:43.199] plan(): nbrOfWorkers() = 1
[10:21:43.199] plan(): Setting new future strategy stack:
[10:21:43.200] List of future strategies:
[10:21:43.200] 1. sequential:
[10:21:43.200]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.200]    - tweaked: FALSE
[10:21:43.200]    - call: plan(strategy)
[10:21:43.200] plan(): nbrOfWorkers() = 1
[10:21:43.200] SequentialFuture started (and completed)
[10:21:43.200] - Launch lazy future ... done
[10:21:43.200] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.201] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.201] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.201] 
[10:21:43.202] Searching for globals ... DONE
[10:21:43.202] - globals: [0] <none>
[10:21:43.202] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.202] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.202] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.203] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.203] Searching for globals ... DONE
[10:21:43.203] Resolving globals: TRUE
[10:21:43.203] Resolving any globals that are futures ...
[10:21:43.203] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.204] Resolving any globals that are futures ... DONE
[10:21:43.204] Resolving futures part of globals (recursively) ...
[10:21:43.204] resolve() on list ...
[10:21:43.204]  recursive: 99
[10:21:43.204]  length: 1
[10:21:43.204]  elements: ‘a’
[10:21:43.204] run() for ‘Future’ ...
[10:21:43.204] - state: ‘created’
[10:21:43.205] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.205] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.205] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.205]   - Field: ‘label’
[10:21:43.205]   - Field: ‘local’
[10:21:43.205]   - Field: ‘owner’
[10:21:43.205]   - Field: ‘envir’
[10:21:43.205]   - Field: ‘packages’
[10:21:43.206]   - Field: ‘gc’
[10:21:43.206]   - Field: ‘conditions’
[10:21:43.206]   - Field: ‘expr’
[10:21:43.206]   - Field: ‘uuid’
[10:21:43.206]   - Field: ‘seed’
[10:21:43.206]   - Field: ‘version’
[10:21:43.208]   - Field: ‘result’
[10:21:43.208]   - Field: ‘asynchronous’
[10:21:43.208]   - Field: ‘calls’
[10:21:43.208]   - Field: ‘globals’
[10:21:43.208]   - Field: ‘stdout’
[10:21:43.208]   - Field: ‘earlySignal’
[10:21:43.208]   - Field: ‘lazy’
[10:21:43.208]   - Field: ‘state’
[10:21:43.208] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.208] - Launch lazy future ...
[10:21:43.209] Packages needed by the future expression (n = 0): <none>
[10:21:43.209] Packages needed by future strategies (n = 0): <none>
[10:21:43.209] {
[10:21:43.209]     {
[10:21:43.209]         {
[10:21:43.209]             ...future.startTime <- base::Sys.time()
[10:21:43.209]             {
[10:21:43.209]                 {
[10:21:43.209]                   {
[10:21:43.209]                     base::local({
[10:21:43.209]                       has_future <- base::requireNamespace("future", 
[10:21:43.209]                         quietly = TRUE)
[10:21:43.209]                       if (has_future) {
[10:21:43.209]                         ns <- base::getNamespace("future")
[10:21:43.209]                         version <- ns[[".package"]][["version"]]
[10:21:43.209]                         if (is.null(version)) 
[10:21:43.209]                           version <- utils::packageVersion("future")
[10:21:43.209]                       }
[10:21:43.209]                       else {
[10:21:43.209]                         version <- NULL
[10:21:43.209]                       }
[10:21:43.209]                       if (!has_future || version < "1.8.0") {
[10:21:43.209]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.209]                           "", base::R.version$version.string), 
[10:21:43.209]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.209]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.209]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.209]                             "release", "version")], collapse = " "), 
[10:21:43.209]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.209]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.209]                           info)
[10:21:43.209]                         info <- base::paste(info, collapse = "; ")
[10:21:43.209]                         if (!has_future) {
[10:21:43.209]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.209]                             info)
[10:21:43.209]                         }
[10:21:43.209]                         else {
[10:21:43.209]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.209]                             info, version)
[10:21:43.209]                         }
[10:21:43.209]                         base::stop(msg)
[10:21:43.209]                       }
[10:21:43.209]                     })
[10:21:43.209]                   }
[10:21:43.209]                   ...future.strategy.old <- future::plan("list")
[10:21:43.209]                   options(future.plan = NULL)
[10:21:43.209]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.209]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.209]                 }
[10:21:43.209]                 ...future.workdir <- getwd()
[10:21:43.209]             }
[10:21:43.209]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.209]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.209]         }
[10:21:43.209]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.209]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.209]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.209]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.209]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.209]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.209]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.209]             base::names(...future.oldOptions))
[10:21:43.209]     }
[10:21:43.209]     if (FALSE) {
[10:21:43.209]     }
[10:21:43.209]     else {
[10:21:43.209]         if (TRUE) {
[10:21:43.209]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.209]                 open = "w")
[10:21:43.209]         }
[10:21:43.209]         else {
[10:21:43.209]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.209]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.209]         }
[10:21:43.209]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.209]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.209]             base::sink(type = "output", split = FALSE)
[10:21:43.209]             base::close(...future.stdout)
[10:21:43.209]         }, add = TRUE)
[10:21:43.209]     }
[10:21:43.209]     ...future.frame <- base::sys.nframe()
[10:21:43.209]     ...future.conditions <- base::list()
[10:21:43.209]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.209]     if (FALSE) {
[10:21:43.209]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.209]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.209]     }
[10:21:43.209]     ...future.result <- base::tryCatch({
[10:21:43.209]         base::withCallingHandlers({
[10:21:43.209]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.209]             future::FutureResult(value = ...future.value$value, 
[10:21:43.209]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.209]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.209]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.209]                     ...future.globalenv.names))
[10:21:43.209]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.209]         }, condition = base::local({
[10:21:43.209]             c <- base::c
[10:21:43.209]             inherits <- base::inherits
[10:21:43.209]             invokeRestart <- base::invokeRestart
[10:21:43.209]             length <- base::length
[10:21:43.209]             list <- base::list
[10:21:43.209]             seq.int <- base::seq.int
[10:21:43.209]             signalCondition <- base::signalCondition
[10:21:43.209]             sys.calls <- base::sys.calls
[10:21:43.209]             `[[` <- base::`[[`
[10:21:43.209]             `+` <- base::`+`
[10:21:43.209]             `<<-` <- base::`<<-`
[10:21:43.209]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.209]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.209]                   3L)]
[10:21:43.209]             }
[10:21:43.209]             function(cond) {
[10:21:43.209]                 is_error <- inherits(cond, "error")
[10:21:43.209]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.209]                   NULL)
[10:21:43.209]                 if (is_error) {
[10:21:43.209]                   sessionInformation <- function() {
[10:21:43.209]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.209]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.209]                       search = base::search(), system = base::Sys.info())
[10:21:43.209]                   }
[10:21:43.209]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.209]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.209]                     cond$call), session = sessionInformation(), 
[10:21:43.209]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.209]                   signalCondition(cond)
[10:21:43.209]                 }
[10:21:43.209]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.209]                 "immediateCondition"))) {
[10:21:43.209]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.209]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.209]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.209]                   if (TRUE && !signal) {
[10:21:43.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.209]                     {
[10:21:43.209]                       inherits <- base::inherits
[10:21:43.209]                       invokeRestart <- base::invokeRestart
[10:21:43.209]                       is.null <- base::is.null
[10:21:43.209]                       muffled <- FALSE
[10:21:43.209]                       if (inherits(cond, "message")) {
[10:21:43.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.209]                         if (muffled) 
[10:21:43.209]                           invokeRestart("muffleMessage")
[10:21:43.209]                       }
[10:21:43.209]                       else if (inherits(cond, "warning")) {
[10:21:43.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.209]                         if (muffled) 
[10:21:43.209]                           invokeRestart("muffleWarning")
[10:21:43.209]                       }
[10:21:43.209]                       else if (inherits(cond, "condition")) {
[10:21:43.209]                         if (!is.null(pattern)) {
[10:21:43.209]                           computeRestarts <- base::computeRestarts
[10:21:43.209]                           grepl <- base::grepl
[10:21:43.209]                           restarts <- computeRestarts(cond)
[10:21:43.209]                           for (restart in restarts) {
[10:21:43.209]                             name <- restart$name
[10:21:43.209]                             if (is.null(name)) 
[10:21:43.209]                               next
[10:21:43.209]                             if (!grepl(pattern, name)) 
[10:21:43.209]                               next
[10:21:43.209]                             invokeRestart(restart)
[10:21:43.209]                             muffled <- TRUE
[10:21:43.209]                             break
[10:21:43.209]                           }
[10:21:43.209]                         }
[10:21:43.209]                       }
[10:21:43.209]                       invisible(muffled)
[10:21:43.209]                     }
[10:21:43.209]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.209]                   }
[10:21:43.209]                 }
[10:21:43.209]                 else {
[10:21:43.209]                   if (TRUE) {
[10:21:43.209]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.209]                     {
[10:21:43.209]                       inherits <- base::inherits
[10:21:43.209]                       invokeRestart <- base::invokeRestart
[10:21:43.209]                       is.null <- base::is.null
[10:21:43.209]                       muffled <- FALSE
[10:21:43.209]                       if (inherits(cond, "message")) {
[10:21:43.209]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.209]                         if (muffled) 
[10:21:43.209]                           invokeRestart("muffleMessage")
[10:21:43.209]                       }
[10:21:43.209]                       else if (inherits(cond, "warning")) {
[10:21:43.209]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.209]                         if (muffled) 
[10:21:43.209]                           invokeRestart("muffleWarning")
[10:21:43.209]                       }
[10:21:43.209]                       else if (inherits(cond, "condition")) {
[10:21:43.209]                         if (!is.null(pattern)) {
[10:21:43.209]                           computeRestarts <- base::computeRestarts
[10:21:43.209]                           grepl <- base::grepl
[10:21:43.209]                           restarts <- computeRestarts(cond)
[10:21:43.209]                           for (restart in restarts) {
[10:21:43.209]                             name <- restart$name
[10:21:43.209]                             if (is.null(name)) 
[10:21:43.209]                               next
[10:21:43.209]                             if (!grepl(pattern, name)) 
[10:21:43.209]                               next
[10:21:43.209]                             invokeRestart(restart)
[10:21:43.209]                             muffled <- TRUE
[10:21:43.209]                             break
[10:21:43.209]                           }
[10:21:43.209]                         }
[10:21:43.209]                       }
[10:21:43.209]                       invisible(muffled)
[10:21:43.209]                     }
[10:21:43.209]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.209]                   }
[10:21:43.209]                 }
[10:21:43.209]             }
[10:21:43.209]         }))
[10:21:43.209]     }, error = function(ex) {
[10:21:43.209]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.209]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.209]                 ...future.rng), started = ...future.startTime, 
[10:21:43.209]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.209]             version = "1.8"), class = "FutureResult")
[10:21:43.209]     }, finally = {
[10:21:43.209]         if (!identical(...future.workdir, getwd())) 
[10:21:43.209]             setwd(...future.workdir)
[10:21:43.209]         {
[10:21:43.209]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.209]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.209]             }
[10:21:43.209]             base::options(...future.oldOptions)
[10:21:43.209]             if (.Platform$OS.type == "windows") {
[10:21:43.209]                 old_names <- names(...future.oldEnvVars)
[10:21:43.209]                 envs <- base::Sys.getenv()
[10:21:43.209]                 names <- names(envs)
[10:21:43.209]                 common <- intersect(names, old_names)
[10:21:43.209]                 added <- setdiff(names, old_names)
[10:21:43.209]                 removed <- setdiff(old_names, names)
[10:21:43.209]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.209]                   envs[common]]
[10:21:43.209]                 NAMES <- toupper(changed)
[10:21:43.209]                 args <- list()
[10:21:43.209]                 for (kk in seq_along(NAMES)) {
[10:21:43.209]                   name <- changed[[kk]]
[10:21:43.209]                   NAME <- NAMES[[kk]]
[10:21:43.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.209]                     next
[10:21:43.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.209]                 }
[10:21:43.209]                 NAMES <- toupper(added)
[10:21:43.209]                 for (kk in seq_along(NAMES)) {
[10:21:43.209]                   name <- added[[kk]]
[10:21:43.209]                   NAME <- NAMES[[kk]]
[10:21:43.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.209]                     next
[10:21:43.209]                   args[[name]] <- ""
[10:21:43.209]                 }
[10:21:43.209]                 NAMES <- toupper(removed)
[10:21:43.209]                 for (kk in seq_along(NAMES)) {
[10:21:43.209]                   name <- removed[[kk]]
[10:21:43.209]                   NAME <- NAMES[[kk]]
[10:21:43.209]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.209]                     next
[10:21:43.209]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.209]                 }
[10:21:43.209]                 if (length(args) > 0) 
[10:21:43.209]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.209]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.209]             }
[10:21:43.209]             else {
[10:21:43.209]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.209]             }
[10:21:43.209]             {
[10:21:43.209]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.209]                   0L) {
[10:21:43.209]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.209]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.209]                   base::options(opts)
[10:21:43.209]                 }
[10:21:43.209]                 {
[10:21:43.209]                   {
[10:21:43.209]                     NULL
[10:21:43.209]                     RNGkind("Mersenne-Twister")
[10:21:43.209]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.209]                       inherits = FALSE)
[10:21:43.209]                   }
[10:21:43.209]                   options(future.plan = NULL)
[10:21:43.209]                   if (is.na(NA_character_)) 
[10:21:43.209]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.209]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.209]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.209]                     .init = FALSE)
[10:21:43.209]                 }
[10:21:43.209]             }
[10:21:43.209]         }
[10:21:43.209]     })
[10:21:43.209]     if (TRUE) {
[10:21:43.209]         base::sink(type = "output", split = FALSE)
[10:21:43.209]         if (TRUE) {
[10:21:43.209]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.209]         }
[10:21:43.209]         else {
[10:21:43.209]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.209]         }
[10:21:43.209]         base::close(...future.stdout)
[10:21:43.209]         ...future.stdout <- NULL
[10:21:43.209]     }
[10:21:43.209]     ...future.result$conditions <- ...future.conditions
[10:21:43.209]     ...future.result$finished <- base::Sys.time()
[10:21:43.209]     ...future.result
[10:21:43.209] }
[10:21:43.211] plan(): Setting new future strategy stack:
[10:21:43.211] List of future strategies:
[10:21:43.211] 1. sequential:
[10:21:43.211]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.211]    - tweaked: FALSE
[10:21:43.211]    - call: NULL
[10:21:43.211] plan(): nbrOfWorkers() = 1
[10:21:43.212] plan(): Setting new future strategy stack:
[10:21:43.212] List of future strategies:
[10:21:43.212] 1. sequential:
[10:21:43.212]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.212]    - tweaked: FALSE
[10:21:43.212]    - call: plan(strategy)
[10:21:43.213] plan(): nbrOfWorkers() = 1
[10:21:43.213] SequentialFuture started (and completed)
[10:21:43.213] - Launch lazy future ... done
[10:21:43.213] run() for ‘SequentialFuture’ ... done
[10:21:43.213] resolved() for ‘SequentialFuture’ ...
[10:21:43.213] - state: ‘finished’
[10:21:43.213] - run: TRUE
[10:21:43.213] - result: ‘FutureResult’
[10:21:43.213] resolved() for ‘SequentialFuture’ ... done
[10:21:43.214] Future #1
[10:21:43.214] resolved() for ‘SequentialFuture’ ...
[10:21:43.214] - state: ‘finished’
[10:21:43.214] - run: TRUE
[10:21:43.214] - result: ‘FutureResult’
[10:21:43.214] resolved() for ‘SequentialFuture’ ... done
[10:21:43.214] A SequentialFuture was resolved
[10:21:43.214]  length: 0 (resolved future 1)
[10:21:43.214] resolve() on list ... DONE
[10:21:43.214] - globals: [1] ‘a’
[10:21:43.215] Resolving futures part of globals (recursively) ... DONE
[10:21:43.215] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[10:21:43.215] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[10:21:43.215] - globals: [1] ‘a’
[10:21:43.215] - packages: [1] ‘future’
[10:21:43.215] getGlobalsAndPackages() ... DONE
[10:21:43.216] run() for ‘Future’ ...
[10:21:43.216] - state: ‘created’
[10:21:43.216] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.216] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.216] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.216]   - Field: ‘label’
[10:21:43.216]   - Field: ‘local’
[10:21:43.216]   - Field: ‘owner’
[10:21:43.217]   - Field: ‘envir’
[10:21:43.217]   - Field: ‘packages’
[10:21:43.217]   - Field: ‘gc’
[10:21:43.217]   - Field: ‘conditions’
[10:21:43.217]   - Field: ‘expr’
[10:21:43.217]   - Field: ‘uuid’
[10:21:43.217]   - Field: ‘seed’
[10:21:43.217]   - Field: ‘version’
[10:21:43.217]   - Field: ‘result’
[10:21:43.217]   - Field: ‘asynchronous’
[10:21:43.217]   - Field: ‘calls’
[10:21:43.217]   - Field: ‘globals’
[10:21:43.218]   - Field: ‘stdout’
[10:21:43.218]   - Field: ‘earlySignal’
[10:21:43.218]   - Field: ‘lazy’
[10:21:43.218]   - Field: ‘state’
[10:21:43.218] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.218] - Launch lazy future ...
[10:21:43.218] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.218] Packages needed by future strategies (n = 0): <none>
[10:21:43.219] {
[10:21:43.219]     {
[10:21:43.219]         {
[10:21:43.219]             ...future.startTime <- base::Sys.time()
[10:21:43.219]             {
[10:21:43.219]                 {
[10:21:43.219]                   {
[10:21:43.219]                     {
[10:21:43.219]                       base::local({
[10:21:43.219]                         has_future <- base::requireNamespace("future", 
[10:21:43.219]                           quietly = TRUE)
[10:21:43.219]                         if (has_future) {
[10:21:43.219]                           ns <- base::getNamespace("future")
[10:21:43.219]                           version <- ns[[".package"]][["version"]]
[10:21:43.219]                           if (is.null(version)) 
[10:21:43.219]                             version <- utils::packageVersion("future")
[10:21:43.219]                         }
[10:21:43.219]                         else {
[10:21:43.219]                           version <- NULL
[10:21:43.219]                         }
[10:21:43.219]                         if (!has_future || version < "1.8.0") {
[10:21:43.219]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.219]                             "", base::R.version$version.string), 
[10:21:43.219]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.219]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.219]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.219]                               "release", "version")], collapse = " "), 
[10:21:43.219]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.219]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.219]                             info)
[10:21:43.219]                           info <- base::paste(info, collapse = "; ")
[10:21:43.219]                           if (!has_future) {
[10:21:43.219]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.219]                               info)
[10:21:43.219]                           }
[10:21:43.219]                           else {
[10:21:43.219]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.219]                               info, version)
[10:21:43.219]                           }
[10:21:43.219]                           base::stop(msg)
[10:21:43.219]                         }
[10:21:43.219]                       })
[10:21:43.219]                     }
[10:21:43.219]                     base::local({
[10:21:43.219]                       for (pkg in "future") {
[10:21:43.219]                         base::loadNamespace(pkg)
[10:21:43.219]                         base::library(pkg, character.only = TRUE)
[10:21:43.219]                       }
[10:21:43.219]                     })
[10:21:43.219]                   }
[10:21:43.219]                   ...future.strategy.old <- future::plan("list")
[10:21:43.219]                   options(future.plan = NULL)
[10:21:43.219]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.219]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.219]                 }
[10:21:43.219]                 ...future.workdir <- getwd()
[10:21:43.219]             }
[10:21:43.219]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.219]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.219]         }
[10:21:43.219]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.219]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.219]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.219]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.219]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.219]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.219]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.219]             base::names(...future.oldOptions))
[10:21:43.219]     }
[10:21:43.219]     if (FALSE) {
[10:21:43.219]     }
[10:21:43.219]     else {
[10:21:43.219]         if (TRUE) {
[10:21:43.219]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.219]                 open = "w")
[10:21:43.219]         }
[10:21:43.219]         else {
[10:21:43.219]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.219]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.219]         }
[10:21:43.219]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.219]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.219]             base::sink(type = "output", split = FALSE)
[10:21:43.219]             base::close(...future.stdout)
[10:21:43.219]         }, add = TRUE)
[10:21:43.219]     }
[10:21:43.219]     ...future.frame <- base::sys.nframe()
[10:21:43.219]     ...future.conditions <- base::list()
[10:21:43.219]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.219]     if (FALSE) {
[10:21:43.219]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.219]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.219]     }
[10:21:43.219]     ...future.result <- base::tryCatch({
[10:21:43.219]         base::withCallingHandlers({
[10:21:43.219]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.219]                 1))
[10:21:43.219]             future::FutureResult(value = ...future.value$value, 
[10:21:43.219]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.219]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.219]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.219]                     ...future.globalenv.names))
[10:21:43.219]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.219]         }, condition = base::local({
[10:21:43.219]             c <- base::c
[10:21:43.219]             inherits <- base::inherits
[10:21:43.219]             invokeRestart <- base::invokeRestart
[10:21:43.219]             length <- base::length
[10:21:43.219]             list <- base::list
[10:21:43.219]             seq.int <- base::seq.int
[10:21:43.219]             signalCondition <- base::signalCondition
[10:21:43.219]             sys.calls <- base::sys.calls
[10:21:43.219]             `[[` <- base::`[[`
[10:21:43.219]             `+` <- base::`+`
[10:21:43.219]             `<<-` <- base::`<<-`
[10:21:43.219]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.219]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.219]                   3L)]
[10:21:43.219]             }
[10:21:43.219]             function(cond) {
[10:21:43.219]                 is_error <- inherits(cond, "error")
[10:21:43.219]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.219]                   NULL)
[10:21:43.219]                 if (is_error) {
[10:21:43.219]                   sessionInformation <- function() {
[10:21:43.219]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.219]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.219]                       search = base::search(), system = base::Sys.info())
[10:21:43.219]                   }
[10:21:43.219]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.219]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.219]                     cond$call), session = sessionInformation(), 
[10:21:43.219]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.219]                   signalCondition(cond)
[10:21:43.219]                 }
[10:21:43.219]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.219]                 "immediateCondition"))) {
[10:21:43.219]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.219]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.219]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.219]                   if (TRUE && !signal) {
[10:21:43.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.219]                     {
[10:21:43.219]                       inherits <- base::inherits
[10:21:43.219]                       invokeRestart <- base::invokeRestart
[10:21:43.219]                       is.null <- base::is.null
[10:21:43.219]                       muffled <- FALSE
[10:21:43.219]                       if (inherits(cond, "message")) {
[10:21:43.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.219]                         if (muffled) 
[10:21:43.219]                           invokeRestart("muffleMessage")
[10:21:43.219]                       }
[10:21:43.219]                       else if (inherits(cond, "warning")) {
[10:21:43.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.219]                         if (muffled) 
[10:21:43.219]                           invokeRestart("muffleWarning")
[10:21:43.219]                       }
[10:21:43.219]                       else if (inherits(cond, "condition")) {
[10:21:43.219]                         if (!is.null(pattern)) {
[10:21:43.219]                           computeRestarts <- base::computeRestarts
[10:21:43.219]                           grepl <- base::grepl
[10:21:43.219]                           restarts <- computeRestarts(cond)
[10:21:43.219]                           for (restart in restarts) {
[10:21:43.219]                             name <- restart$name
[10:21:43.219]                             if (is.null(name)) 
[10:21:43.219]                               next
[10:21:43.219]                             if (!grepl(pattern, name)) 
[10:21:43.219]                               next
[10:21:43.219]                             invokeRestart(restart)
[10:21:43.219]                             muffled <- TRUE
[10:21:43.219]                             break
[10:21:43.219]                           }
[10:21:43.219]                         }
[10:21:43.219]                       }
[10:21:43.219]                       invisible(muffled)
[10:21:43.219]                     }
[10:21:43.219]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.219]                   }
[10:21:43.219]                 }
[10:21:43.219]                 else {
[10:21:43.219]                   if (TRUE) {
[10:21:43.219]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.219]                     {
[10:21:43.219]                       inherits <- base::inherits
[10:21:43.219]                       invokeRestart <- base::invokeRestart
[10:21:43.219]                       is.null <- base::is.null
[10:21:43.219]                       muffled <- FALSE
[10:21:43.219]                       if (inherits(cond, "message")) {
[10:21:43.219]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.219]                         if (muffled) 
[10:21:43.219]                           invokeRestart("muffleMessage")
[10:21:43.219]                       }
[10:21:43.219]                       else if (inherits(cond, "warning")) {
[10:21:43.219]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.219]                         if (muffled) 
[10:21:43.219]                           invokeRestart("muffleWarning")
[10:21:43.219]                       }
[10:21:43.219]                       else if (inherits(cond, "condition")) {
[10:21:43.219]                         if (!is.null(pattern)) {
[10:21:43.219]                           computeRestarts <- base::computeRestarts
[10:21:43.219]                           grepl <- base::grepl
[10:21:43.219]                           restarts <- computeRestarts(cond)
[10:21:43.219]                           for (restart in restarts) {
[10:21:43.219]                             name <- restart$name
[10:21:43.219]                             if (is.null(name)) 
[10:21:43.219]                               next
[10:21:43.219]                             if (!grepl(pattern, name)) 
[10:21:43.219]                               next
[10:21:43.219]                             invokeRestart(restart)
[10:21:43.219]                             muffled <- TRUE
[10:21:43.219]                             break
[10:21:43.219]                           }
[10:21:43.219]                         }
[10:21:43.219]                       }
[10:21:43.219]                       invisible(muffled)
[10:21:43.219]                     }
[10:21:43.219]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.219]                   }
[10:21:43.219]                 }
[10:21:43.219]             }
[10:21:43.219]         }))
[10:21:43.219]     }, error = function(ex) {
[10:21:43.219]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.219]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.219]                 ...future.rng), started = ...future.startTime, 
[10:21:43.219]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.219]             version = "1.8"), class = "FutureResult")
[10:21:43.219]     }, finally = {
[10:21:43.219]         if (!identical(...future.workdir, getwd())) 
[10:21:43.219]             setwd(...future.workdir)
[10:21:43.219]         {
[10:21:43.219]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.219]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.219]             }
[10:21:43.219]             base::options(...future.oldOptions)
[10:21:43.219]             if (.Platform$OS.type == "windows") {
[10:21:43.219]                 old_names <- names(...future.oldEnvVars)
[10:21:43.219]                 envs <- base::Sys.getenv()
[10:21:43.219]                 names <- names(envs)
[10:21:43.219]                 common <- intersect(names, old_names)
[10:21:43.219]                 added <- setdiff(names, old_names)
[10:21:43.219]                 removed <- setdiff(old_names, names)
[10:21:43.219]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.219]                   envs[common]]
[10:21:43.219]                 NAMES <- toupper(changed)
[10:21:43.219]                 args <- list()
[10:21:43.219]                 for (kk in seq_along(NAMES)) {
[10:21:43.219]                   name <- changed[[kk]]
[10:21:43.219]                   NAME <- NAMES[[kk]]
[10:21:43.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.219]                     next
[10:21:43.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.219]                 }
[10:21:43.219]                 NAMES <- toupper(added)
[10:21:43.219]                 for (kk in seq_along(NAMES)) {
[10:21:43.219]                   name <- added[[kk]]
[10:21:43.219]                   NAME <- NAMES[[kk]]
[10:21:43.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.219]                     next
[10:21:43.219]                   args[[name]] <- ""
[10:21:43.219]                 }
[10:21:43.219]                 NAMES <- toupper(removed)
[10:21:43.219]                 for (kk in seq_along(NAMES)) {
[10:21:43.219]                   name <- removed[[kk]]
[10:21:43.219]                   NAME <- NAMES[[kk]]
[10:21:43.219]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.219]                     next
[10:21:43.219]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.219]                 }
[10:21:43.219]                 if (length(args) > 0) 
[10:21:43.219]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.219]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.219]             }
[10:21:43.219]             else {
[10:21:43.219]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.219]             }
[10:21:43.219]             {
[10:21:43.219]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.219]                   0L) {
[10:21:43.219]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.219]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.219]                   base::options(opts)
[10:21:43.219]                 }
[10:21:43.219]                 {
[10:21:43.219]                   {
[10:21:43.219]                     NULL
[10:21:43.219]                     RNGkind("Mersenne-Twister")
[10:21:43.219]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.219]                       inherits = FALSE)
[10:21:43.219]                   }
[10:21:43.219]                   options(future.plan = NULL)
[10:21:43.219]                   if (is.na(NA_character_)) 
[10:21:43.219]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.219]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.219]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.219]                     .init = FALSE)
[10:21:43.219]                 }
[10:21:43.219]             }
[10:21:43.219]         }
[10:21:43.219]     })
[10:21:43.219]     if (TRUE) {
[10:21:43.219]         base::sink(type = "output", split = FALSE)
[10:21:43.219]         if (TRUE) {
[10:21:43.219]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.219]         }
[10:21:43.219]         else {
[10:21:43.219]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.219]         }
[10:21:43.219]         base::close(...future.stdout)
[10:21:43.219]         ...future.stdout <- NULL
[10:21:43.219]     }
[10:21:43.219]     ...future.result$conditions <- ...future.conditions
[10:21:43.219]     ...future.result$finished <- base::Sys.time()
[10:21:43.219]     ...future.result
[10:21:43.219] }
[10:21:43.220] assign_globals() ...
[10:21:43.220] List of 1
[10:21:43.220]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18e84e5f0> 
[10:21:43.220]  - attr(*, "where")=List of 1
[10:21:43.220]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.220]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.220]  - attr(*, "resolved")= logi TRUE
[10:21:43.220]  - attr(*, "total_size")= num 3555
[10:21:43.220]  - attr(*, "already-done")= logi TRUE
[10:21:43.223] - copied ‘a’ to environment
[10:21:43.223] assign_globals() ... done
[10:21:43.223] plan(): Setting new future strategy stack:
[10:21:43.223] List of future strategies:
[10:21:43.223] 1. sequential:
[10:21:43.223]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.223]    - tweaked: FALSE
[10:21:43.223]    - call: NULL
[10:21:43.224] plan(): nbrOfWorkers() = 1
[10:21:43.224] plan(): Setting new future strategy stack:
[10:21:43.224] List of future strategies:
[10:21:43.224] 1. sequential:
[10:21:43.224]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.224]    - tweaked: FALSE
[10:21:43.224]    - call: plan(strategy)
[10:21:43.225] plan(): nbrOfWorkers() = 1
[10:21:43.225] SequentialFuture started (and completed)
[10:21:43.225] - Launch lazy future ... done
[10:21:43.225] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.226] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.226] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.227] - globals found: [2] ‘{’, ‘pkg’
[10:21:43.227] Searching for globals ... DONE
[10:21:43.227] Resolving globals: TRUE
[10:21:43.227] Resolving any globals that are futures ...
[10:21:43.227] - globals: [2] ‘{’, ‘pkg’
[10:21:43.227] Resolving any globals that are futures ... DONE
[10:21:43.227] Resolving futures part of globals (recursively) ...
[10:21:43.228] resolve() on list ...
[10:21:43.228]  recursive: 99
[10:21:43.228]  length: 1
[10:21:43.228]  elements: ‘pkg’
[10:21:43.228]  length: 0 (resolved future 1)
[10:21:43.228] resolve() on list ... DONE
[10:21:43.228] - globals: [1] ‘pkg’
[10:21:43.228] Resolving futures part of globals (recursively) ... DONE
[10:21:43.228] The total size of the 1 globals is 42 bytes (42 bytes)
[10:21:43.229] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[10:21:43.229] - globals: [1] ‘pkg’
[10:21:43.229] 
[10:21:43.229] getGlobalsAndPackages() ... DONE
[10:21:43.229] Packages needed by the future expression (n = 0): <none>
[10:21:43.229] Packages needed by future strategies (n = 0): <none>
[10:21:43.230] {
[10:21:43.230]     {
[10:21:43.230]         {
[10:21:43.230]             ...future.startTime <- base::Sys.time()
[10:21:43.230]             {
[10:21:43.230]                 {
[10:21:43.230]                   {
[10:21:43.230]                     base::local({
[10:21:43.230]                       has_future <- base::requireNamespace("future", 
[10:21:43.230]                         quietly = TRUE)
[10:21:43.230]                       if (has_future) {
[10:21:43.230]                         ns <- base::getNamespace("future")
[10:21:43.230]                         version <- ns[[".package"]][["version"]]
[10:21:43.230]                         if (is.null(version)) 
[10:21:43.230]                           version <- utils::packageVersion("future")
[10:21:43.230]                       }
[10:21:43.230]                       else {
[10:21:43.230]                         version <- NULL
[10:21:43.230]                       }
[10:21:43.230]                       if (!has_future || version < "1.8.0") {
[10:21:43.230]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.230]                           "", base::R.version$version.string), 
[10:21:43.230]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.230]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.230]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.230]                             "release", "version")], collapse = " "), 
[10:21:43.230]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.230]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.230]                           info)
[10:21:43.230]                         info <- base::paste(info, collapse = "; ")
[10:21:43.230]                         if (!has_future) {
[10:21:43.230]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.230]                             info)
[10:21:43.230]                         }
[10:21:43.230]                         else {
[10:21:43.230]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.230]                             info, version)
[10:21:43.230]                         }
[10:21:43.230]                         base::stop(msg)
[10:21:43.230]                       }
[10:21:43.230]                     })
[10:21:43.230]                   }
[10:21:43.230]                   ...future.strategy.old <- future::plan("list")
[10:21:43.230]                   options(future.plan = NULL)
[10:21:43.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.230]                 }
[10:21:43.230]                 ...future.workdir <- getwd()
[10:21:43.230]             }
[10:21:43.230]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.230]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.230]         }
[10:21:43.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.230]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.230]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.230]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.230]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.230]             base::names(...future.oldOptions))
[10:21:43.230]     }
[10:21:43.230]     if (FALSE) {
[10:21:43.230]     }
[10:21:43.230]     else {
[10:21:43.230]         if (TRUE) {
[10:21:43.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.230]                 open = "w")
[10:21:43.230]         }
[10:21:43.230]         else {
[10:21:43.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.230]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.230]         }
[10:21:43.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.230]             base::sink(type = "output", split = FALSE)
[10:21:43.230]             base::close(...future.stdout)
[10:21:43.230]         }, add = TRUE)
[10:21:43.230]     }
[10:21:43.230]     ...future.frame <- base::sys.nframe()
[10:21:43.230]     ...future.conditions <- base::list()
[10:21:43.230]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.230]     if (FALSE) {
[10:21:43.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.230]     }
[10:21:43.230]     ...future.result <- base::tryCatch({
[10:21:43.230]         base::withCallingHandlers({
[10:21:43.230]             ...future.value <- base::withVisible(base::local({
[10:21:43.230]                 pkg
[10:21:43.230]             }))
[10:21:43.230]             future::FutureResult(value = ...future.value$value, 
[10:21:43.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.230]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.230]                     ...future.globalenv.names))
[10:21:43.230]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.230]         }, condition = base::local({
[10:21:43.230]             c <- base::c
[10:21:43.230]             inherits <- base::inherits
[10:21:43.230]             invokeRestart <- base::invokeRestart
[10:21:43.230]             length <- base::length
[10:21:43.230]             list <- base::list
[10:21:43.230]             seq.int <- base::seq.int
[10:21:43.230]             signalCondition <- base::signalCondition
[10:21:43.230]             sys.calls <- base::sys.calls
[10:21:43.230]             `[[` <- base::`[[`
[10:21:43.230]             `+` <- base::`+`
[10:21:43.230]             `<<-` <- base::`<<-`
[10:21:43.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.230]                   3L)]
[10:21:43.230]             }
[10:21:43.230]             function(cond) {
[10:21:43.230]                 is_error <- inherits(cond, "error")
[10:21:43.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.230]                   NULL)
[10:21:43.230]                 if (is_error) {
[10:21:43.230]                   sessionInformation <- function() {
[10:21:43.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.230]                       search = base::search(), system = base::Sys.info())
[10:21:43.230]                   }
[10:21:43.230]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.230]                     cond$call), session = sessionInformation(), 
[10:21:43.230]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.230]                   signalCondition(cond)
[10:21:43.230]                 }
[10:21:43.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.230]                 "immediateCondition"))) {
[10:21:43.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.230]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.230]                   if (TRUE && !signal) {
[10:21:43.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.230]                     {
[10:21:43.230]                       inherits <- base::inherits
[10:21:43.230]                       invokeRestart <- base::invokeRestart
[10:21:43.230]                       is.null <- base::is.null
[10:21:43.230]                       muffled <- FALSE
[10:21:43.230]                       if (inherits(cond, "message")) {
[10:21:43.230]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.230]                         if (muffled) 
[10:21:43.230]                           invokeRestart("muffleMessage")
[10:21:43.230]                       }
[10:21:43.230]                       else if (inherits(cond, "warning")) {
[10:21:43.230]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.230]                         if (muffled) 
[10:21:43.230]                           invokeRestart("muffleWarning")
[10:21:43.230]                       }
[10:21:43.230]                       else if (inherits(cond, "condition")) {
[10:21:43.230]                         if (!is.null(pattern)) {
[10:21:43.230]                           computeRestarts <- base::computeRestarts
[10:21:43.230]                           grepl <- base::grepl
[10:21:43.230]                           restarts <- computeRestarts(cond)
[10:21:43.230]                           for (restart in restarts) {
[10:21:43.230]                             name <- restart$name
[10:21:43.230]                             if (is.null(name)) 
[10:21:43.230]                               next
[10:21:43.230]                             if (!grepl(pattern, name)) 
[10:21:43.230]                               next
[10:21:43.230]                             invokeRestart(restart)
[10:21:43.230]                             muffled <- TRUE
[10:21:43.230]                             break
[10:21:43.230]                           }
[10:21:43.230]                         }
[10:21:43.230]                       }
[10:21:43.230]                       invisible(muffled)
[10:21:43.230]                     }
[10:21:43.230]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.230]                   }
[10:21:43.230]                 }
[10:21:43.230]                 else {
[10:21:43.230]                   if (TRUE) {
[10:21:43.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.230]                     {
[10:21:43.230]                       inherits <- base::inherits
[10:21:43.230]                       invokeRestart <- base::invokeRestart
[10:21:43.230]                       is.null <- base::is.null
[10:21:43.230]                       muffled <- FALSE
[10:21:43.230]                       if (inherits(cond, "message")) {
[10:21:43.230]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.230]                         if (muffled) 
[10:21:43.230]                           invokeRestart("muffleMessage")
[10:21:43.230]                       }
[10:21:43.230]                       else if (inherits(cond, "warning")) {
[10:21:43.230]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.230]                         if (muffled) 
[10:21:43.230]                           invokeRestart("muffleWarning")
[10:21:43.230]                       }
[10:21:43.230]                       else if (inherits(cond, "condition")) {
[10:21:43.230]                         if (!is.null(pattern)) {
[10:21:43.230]                           computeRestarts <- base::computeRestarts
[10:21:43.230]                           grepl <- base::grepl
[10:21:43.230]                           restarts <- computeRestarts(cond)
[10:21:43.230]                           for (restart in restarts) {
[10:21:43.230]                             name <- restart$name
[10:21:43.230]                             if (is.null(name)) 
[10:21:43.230]                               next
[10:21:43.230]                             if (!grepl(pattern, name)) 
[10:21:43.230]                               next
[10:21:43.230]                             invokeRestart(restart)
[10:21:43.230]                             muffled <- TRUE
[10:21:43.230]                             break
[10:21:43.230]                           }
[10:21:43.230]                         }
[10:21:43.230]                       }
[10:21:43.230]                       invisible(muffled)
[10:21:43.230]                     }
[10:21:43.230]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.230]                   }
[10:21:43.230]                 }
[10:21:43.230]             }
[10:21:43.230]         }))
[10:21:43.230]     }, error = function(ex) {
[10:21:43.230]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.230]                 ...future.rng), started = ...future.startTime, 
[10:21:43.230]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.230]             version = "1.8"), class = "FutureResult")
[10:21:43.230]     }, finally = {
[10:21:43.230]         if (!identical(...future.workdir, getwd())) 
[10:21:43.230]             setwd(...future.workdir)
[10:21:43.230]         {
[10:21:43.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.230]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.230]             }
[10:21:43.230]             base::options(...future.oldOptions)
[10:21:43.230]             if (.Platform$OS.type == "windows") {
[10:21:43.230]                 old_names <- names(...future.oldEnvVars)
[10:21:43.230]                 envs <- base::Sys.getenv()
[10:21:43.230]                 names <- names(envs)
[10:21:43.230]                 common <- intersect(names, old_names)
[10:21:43.230]                 added <- setdiff(names, old_names)
[10:21:43.230]                 removed <- setdiff(old_names, names)
[10:21:43.230]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.230]                   envs[common]]
[10:21:43.230]                 NAMES <- toupper(changed)
[10:21:43.230]                 args <- list()
[10:21:43.230]                 for (kk in seq_along(NAMES)) {
[10:21:43.230]                   name <- changed[[kk]]
[10:21:43.230]                   NAME <- NAMES[[kk]]
[10:21:43.230]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.230]                     next
[10:21:43.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.230]                 }
[10:21:43.230]                 NAMES <- toupper(added)
[10:21:43.230]                 for (kk in seq_along(NAMES)) {
[10:21:43.230]                   name <- added[[kk]]
[10:21:43.230]                   NAME <- NAMES[[kk]]
[10:21:43.230]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.230]                     next
[10:21:43.230]                   args[[name]] <- ""
[10:21:43.230]                 }
[10:21:43.230]                 NAMES <- toupper(removed)
[10:21:43.230]                 for (kk in seq_along(NAMES)) {
[10:21:43.230]                   name <- removed[[kk]]
[10:21:43.230]                   NAME <- NAMES[[kk]]
[10:21:43.230]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.230]                     next
[10:21:43.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.230]                 }
[10:21:43.230]                 if (length(args) > 0) 
[10:21:43.230]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.230]             }
[10:21:43.230]             else {
[10:21:43.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.230]             }
[10:21:43.230]             {
[10:21:43.230]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.230]                   0L) {
[10:21:43.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.230]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.230]                   base::options(opts)
[10:21:43.230]                 }
[10:21:43.230]                 {
[10:21:43.230]                   {
[10:21:43.230]                     NULL
[10:21:43.230]                     RNGkind("Mersenne-Twister")
[10:21:43.230]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.230]                       inherits = FALSE)
[10:21:43.230]                   }
[10:21:43.230]                   options(future.plan = NULL)
[10:21:43.230]                   if (is.na(NA_character_)) 
[10:21:43.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.230]                     .init = FALSE)
[10:21:43.230]                 }
[10:21:43.230]             }
[10:21:43.230]         }
[10:21:43.230]     })
[10:21:43.230]     if (TRUE) {
[10:21:43.230]         base::sink(type = "output", split = FALSE)
[10:21:43.230]         if (TRUE) {
[10:21:43.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.230]         }
[10:21:43.230]         else {
[10:21:43.230]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.230]         }
[10:21:43.230]         base::close(...future.stdout)
[10:21:43.230]         ...future.stdout <- NULL
[10:21:43.230]     }
[10:21:43.230]     ...future.result$conditions <- ...future.conditions
[10:21:43.230]     ...future.result$finished <- base::Sys.time()
[10:21:43.230]     ...future.result
[10:21:43.230] }
[10:21:43.231] assign_globals() ...
[10:21:43.231] List of 1
[10:21:43.231]  $ pkg: chr "foo"
[10:21:43.231]  - attr(*, "where")=List of 1
[10:21:43.231]   ..$ pkg:<environment: R_EmptyEnv> 
[10:21:43.231]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.231]  - attr(*, "resolved")= logi TRUE
[10:21:43.231]  - attr(*, "total_size")= num 42
[10:21:43.233] - copied ‘pkg’ to environment
[10:21:43.234] assign_globals() ... done
[10:21:43.234] plan(): Setting new future strategy stack:
[10:21:43.234] List of future strategies:
[10:21:43.234] 1. sequential:
[10:21:43.234]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.234]    - tweaked: FALSE
[10:21:43.234]    - call: NULL
[10:21:43.234] plan(): nbrOfWorkers() = 1
[10:21:43.237] plan(): Setting new future strategy stack:
[10:21:43.237] List of future strategies:
[10:21:43.237] 1. sequential:
[10:21:43.237]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.237]    - tweaked: FALSE
[10:21:43.237]    - call: plan(strategy)
[10:21:43.237] plan(): nbrOfWorkers() = 1
[10:21:43.237] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.238] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.238] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.240] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:43.241] Searching for globals ... DONE
[10:21:43.241] Resolving globals: TRUE
[10:21:43.241] Resolving any globals that are futures ...
[10:21:43.241] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:43.241] Resolving any globals that are futures ... DONE
[10:21:43.241] Resolving futures part of globals (recursively) ...
[10:21:43.241] resolve() on list ...
[10:21:43.242]  recursive: 99
[10:21:43.242]  length: 1
[10:21:43.242]  elements: ‘a’
[10:21:43.242]  length: 0 (resolved future 1)
[10:21:43.242] resolve() on list ... DONE
[10:21:43.242] - globals: [1] ‘a’
[10:21:43.242] Resolving futures part of globals (recursively) ... DONE
[10:21:43.242] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:43.242] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:43.243] - globals: [1] ‘a’
[10:21:43.243] 
[10:21:43.243] getGlobalsAndPackages() ... DONE
[10:21:43.243] run() for ‘Future’ ...
[10:21:43.243] - state: ‘created’
[10:21:43.243] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.243] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.244]   - Field: ‘label’
[10:21:43.244]   - Field: ‘local’
[10:21:43.244]   - Field: ‘owner’
[10:21:43.244]   - Field: ‘envir’
[10:21:43.244]   - Field: ‘packages’
[10:21:43.244]   - Field: ‘gc’
[10:21:43.244]   - Field: ‘conditions’
[10:21:43.244]   - Field: ‘expr’
[10:21:43.244]   - Field: ‘uuid’
[10:21:43.244]   - Field: ‘seed’
[10:21:43.244]   - Field: ‘version’
[10:21:43.245]   - Field: ‘result’
[10:21:43.245]   - Field: ‘asynchronous’
[10:21:43.245]   - Field: ‘calls’
[10:21:43.245]   - Field: ‘globals’
[10:21:43.245]   - Field: ‘stdout’
[10:21:43.245]   - Field: ‘earlySignal’
[10:21:43.245]   - Field: ‘lazy’
[10:21:43.245]   - Field: ‘state’
[10:21:43.245] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.245] - Launch lazy future ...
[10:21:43.245] Packages needed by the future expression (n = 0): <none>
[10:21:43.246] Packages needed by future strategies (n = 0): <none>
[10:21:43.246] {
[10:21:43.246]     {
[10:21:43.246]         {
[10:21:43.246]             ...future.startTime <- base::Sys.time()
[10:21:43.246]             {
[10:21:43.246]                 {
[10:21:43.246]                   {
[10:21:43.246]                     base::local({
[10:21:43.246]                       has_future <- base::requireNamespace("future", 
[10:21:43.246]                         quietly = TRUE)
[10:21:43.246]                       if (has_future) {
[10:21:43.246]                         ns <- base::getNamespace("future")
[10:21:43.246]                         version <- ns[[".package"]][["version"]]
[10:21:43.246]                         if (is.null(version)) 
[10:21:43.246]                           version <- utils::packageVersion("future")
[10:21:43.246]                       }
[10:21:43.246]                       else {
[10:21:43.246]                         version <- NULL
[10:21:43.246]                       }
[10:21:43.246]                       if (!has_future || version < "1.8.0") {
[10:21:43.246]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.246]                           "", base::R.version$version.string), 
[10:21:43.246]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.246]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.246]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.246]                             "release", "version")], collapse = " "), 
[10:21:43.246]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.246]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.246]                           info)
[10:21:43.246]                         info <- base::paste(info, collapse = "; ")
[10:21:43.246]                         if (!has_future) {
[10:21:43.246]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.246]                             info)
[10:21:43.246]                         }
[10:21:43.246]                         else {
[10:21:43.246]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.246]                             info, version)
[10:21:43.246]                         }
[10:21:43.246]                         base::stop(msg)
[10:21:43.246]                       }
[10:21:43.246]                     })
[10:21:43.246]                   }
[10:21:43.246]                   ...future.strategy.old <- future::plan("list")
[10:21:43.246]                   options(future.plan = NULL)
[10:21:43.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.246]                 }
[10:21:43.246]                 ...future.workdir <- getwd()
[10:21:43.246]             }
[10:21:43.246]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.246]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.246]         }
[10:21:43.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.246]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.246]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.246]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.246]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.246]             base::names(...future.oldOptions))
[10:21:43.246]     }
[10:21:43.246]     if (FALSE) {
[10:21:43.246]     }
[10:21:43.246]     else {
[10:21:43.246]         if (TRUE) {
[10:21:43.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.246]                 open = "w")
[10:21:43.246]         }
[10:21:43.246]         else {
[10:21:43.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.246]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.246]         }
[10:21:43.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.246]             base::sink(type = "output", split = FALSE)
[10:21:43.246]             base::close(...future.stdout)
[10:21:43.246]         }, add = TRUE)
[10:21:43.246]     }
[10:21:43.246]     ...future.frame <- base::sys.nframe()
[10:21:43.246]     ...future.conditions <- base::list()
[10:21:43.246]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.246]     if (FALSE) {
[10:21:43.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.246]     }
[10:21:43.246]     ...future.result <- base::tryCatch({
[10:21:43.246]         base::withCallingHandlers({
[10:21:43.246]             ...future.value <- base::withVisible(base::local({
[10:21:43.246]                 b <- a
[10:21:43.246]                 a <- 2
[10:21:43.246]                 a * b
[10:21:43.246]             }))
[10:21:43.246]             future::FutureResult(value = ...future.value$value, 
[10:21:43.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.246]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.246]                     ...future.globalenv.names))
[10:21:43.246]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.246]         }, condition = base::local({
[10:21:43.246]             c <- base::c
[10:21:43.246]             inherits <- base::inherits
[10:21:43.246]             invokeRestart <- base::invokeRestart
[10:21:43.246]             length <- base::length
[10:21:43.246]             list <- base::list
[10:21:43.246]             seq.int <- base::seq.int
[10:21:43.246]             signalCondition <- base::signalCondition
[10:21:43.246]             sys.calls <- base::sys.calls
[10:21:43.246]             `[[` <- base::`[[`
[10:21:43.246]             `+` <- base::`+`
[10:21:43.246]             `<<-` <- base::`<<-`
[10:21:43.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.246]                   3L)]
[10:21:43.246]             }
[10:21:43.246]             function(cond) {
[10:21:43.246]                 is_error <- inherits(cond, "error")
[10:21:43.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.246]                   NULL)
[10:21:43.246]                 if (is_error) {
[10:21:43.246]                   sessionInformation <- function() {
[10:21:43.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.246]                       search = base::search(), system = base::Sys.info())
[10:21:43.246]                   }
[10:21:43.246]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.246]                     cond$call), session = sessionInformation(), 
[10:21:43.246]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.246]                   signalCondition(cond)
[10:21:43.246]                 }
[10:21:43.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.246]                 "immediateCondition"))) {
[10:21:43.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.246]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.246]                   if (TRUE && !signal) {
[10:21:43.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.246]                     {
[10:21:43.246]                       inherits <- base::inherits
[10:21:43.246]                       invokeRestart <- base::invokeRestart
[10:21:43.246]                       is.null <- base::is.null
[10:21:43.246]                       muffled <- FALSE
[10:21:43.246]                       if (inherits(cond, "message")) {
[10:21:43.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.246]                         if (muffled) 
[10:21:43.246]                           invokeRestart("muffleMessage")
[10:21:43.246]                       }
[10:21:43.246]                       else if (inherits(cond, "warning")) {
[10:21:43.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.246]                         if (muffled) 
[10:21:43.246]                           invokeRestart("muffleWarning")
[10:21:43.246]                       }
[10:21:43.246]                       else if (inherits(cond, "condition")) {
[10:21:43.246]                         if (!is.null(pattern)) {
[10:21:43.246]                           computeRestarts <- base::computeRestarts
[10:21:43.246]                           grepl <- base::grepl
[10:21:43.246]                           restarts <- computeRestarts(cond)
[10:21:43.246]                           for (restart in restarts) {
[10:21:43.246]                             name <- restart$name
[10:21:43.246]                             if (is.null(name)) 
[10:21:43.246]                               next
[10:21:43.246]                             if (!grepl(pattern, name)) 
[10:21:43.246]                               next
[10:21:43.246]                             invokeRestart(restart)
[10:21:43.246]                             muffled <- TRUE
[10:21:43.246]                             break
[10:21:43.246]                           }
[10:21:43.246]                         }
[10:21:43.246]                       }
[10:21:43.246]                       invisible(muffled)
[10:21:43.246]                     }
[10:21:43.246]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.246]                   }
[10:21:43.246]                 }
[10:21:43.246]                 else {
[10:21:43.246]                   if (TRUE) {
[10:21:43.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.246]                     {
[10:21:43.246]                       inherits <- base::inherits
[10:21:43.246]                       invokeRestart <- base::invokeRestart
[10:21:43.246]                       is.null <- base::is.null
[10:21:43.246]                       muffled <- FALSE
[10:21:43.246]                       if (inherits(cond, "message")) {
[10:21:43.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.246]                         if (muffled) 
[10:21:43.246]                           invokeRestart("muffleMessage")
[10:21:43.246]                       }
[10:21:43.246]                       else if (inherits(cond, "warning")) {
[10:21:43.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.246]                         if (muffled) 
[10:21:43.246]                           invokeRestart("muffleWarning")
[10:21:43.246]                       }
[10:21:43.246]                       else if (inherits(cond, "condition")) {
[10:21:43.246]                         if (!is.null(pattern)) {
[10:21:43.246]                           computeRestarts <- base::computeRestarts
[10:21:43.246]                           grepl <- base::grepl
[10:21:43.246]                           restarts <- computeRestarts(cond)
[10:21:43.246]                           for (restart in restarts) {
[10:21:43.246]                             name <- restart$name
[10:21:43.246]                             if (is.null(name)) 
[10:21:43.246]                               next
[10:21:43.246]                             if (!grepl(pattern, name)) 
[10:21:43.246]                               next
[10:21:43.246]                             invokeRestart(restart)
[10:21:43.246]                             muffled <- TRUE
[10:21:43.246]                             break
[10:21:43.246]                           }
[10:21:43.246]                         }
[10:21:43.246]                       }
[10:21:43.246]                       invisible(muffled)
[10:21:43.246]                     }
[10:21:43.246]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.246]                   }
[10:21:43.246]                 }
[10:21:43.246]             }
[10:21:43.246]         }))
[10:21:43.246]     }, error = function(ex) {
[10:21:43.246]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.246]                 ...future.rng), started = ...future.startTime, 
[10:21:43.246]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.246]             version = "1.8"), class = "FutureResult")
[10:21:43.246]     }, finally = {
[10:21:43.246]         if (!identical(...future.workdir, getwd())) 
[10:21:43.246]             setwd(...future.workdir)
[10:21:43.246]         {
[10:21:43.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.246]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.246]             }
[10:21:43.246]             base::options(...future.oldOptions)
[10:21:43.246]             if (.Platform$OS.type == "windows") {
[10:21:43.246]                 old_names <- names(...future.oldEnvVars)
[10:21:43.246]                 envs <- base::Sys.getenv()
[10:21:43.246]                 names <- names(envs)
[10:21:43.246]                 common <- intersect(names, old_names)
[10:21:43.246]                 added <- setdiff(names, old_names)
[10:21:43.246]                 removed <- setdiff(old_names, names)
[10:21:43.246]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.246]                   envs[common]]
[10:21:43.246]                 NAMES <- toupper(changed)
[10:21:43.246]                 args <- list()
[10:21:43.246]                 for (kk in seq_along(NAMES)) {
[10:21:43.246]                   name <- changed[[kk]]
[10:21:43.246]                   NAME <- NAMES[[kk]]
[10:21:43.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.246]                     next
[10:21:43.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.246]                 }
[10:21:43.246]                 NAMES <- toupper(added)
[10:21:43.246]                 for (kk in seq_along(NAMES)) {
[10:21:43.246]                   name <- added[[kk]]
[10:21:43.246]                   NAME <- NAMES[[kk]]
[10:21:43.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.246]                     next
[10:21:43.246]                   args[[name]] <- ""
[10:21:43.246]                 }
[10:21:43.246]                 NAMES <- toupper(removed)
[10:21:43.246]                 for (kk in seq_along(NAMES)) {
[10:21:43.246]                   name <- removed[[kk]]
[10:21:43.246]                   NAME <- NAMES[[kk]]
[10:21:43.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.246]                     next
[10:21:43.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.246]                 }
[10:21:43.246]                 if (length(args) > 0) 
[10:21:43.246]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.246]             }
[10:21:43.246]             else {
[10:21:43.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.246]             }
[10:21:43.246]             {
[10:21:43.246]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.246]                   0L) {
[10:21:43.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.246]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.246]                   base::options(opts)
[10:21:43.246]                 }
[10:21:43.246]                 {
[10:21:43.246]                   {
[10:21:43.246]                     NULL
[10:21:43.246]                     RNGkind("Mersenne-Twister")
[10:21:43.246]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.246]                       inherits = FALSE)
[10:21:43.246]                   }
[10:21:43.246]                   options(future.plan = NULL)
[10:21:43.246]                   if (is.na(NA_character_)) 
[10:21:43.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.246]                     .init = FALSE)
[10:21:43.246]                 }
[10:21:43.246]             }
[10:21:43.246]         }
[10:21:43.246]     })
[10:21:43.246]     if (TRUE) {
[10:21:43.246]         base::sink(type = "output", split = FALSE)
[10:21:43.246]         if (TRUE) {
[10:21:43.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.246]         }
[10:21:43.246]         else {
[10:21:43.246]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.246]         }
[10:21:43.246]         base::close(...future.stdout)
[10:21:43.246]         ...future.stdout <- NULL
[10:21:43.246]     }
[10:21:43.246]     ...future.result$conditions <- ...future.conditions
[10:21:43.246]     ...future.result$finished <- base::Sys.time()
[10:21:43.246]     ...future.result
[10:21:43.246] }
[10:21:43.248] assign_globals() ...
[10:21:43.248] List of 1
[10:21:43.248]  $ a: num 3
[10:21:43.248]  - attr(*, "where")=List of 1
[10:21:43.248]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.248]  - attr(*, "resolved")= logi TRUE
[10:21:43.248]  - attr(*, "total_size")= num 39
[10:21:43.248]  - attr(*, "already-done")= logi TRUE
[10:21:43.250] - copied ‘a’ to environment
[10:21:43.250] assign_globals() ... done
[10:21:43.250] plan(): Setting new future strategy stack:
[10:21:43.251] List of future strategies:
[10:21:43.251] 1. sequential:
[10:21:43.251]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.251]    - tweaked: FALSE
[10:21:43.251]    - call: NULL
[10:21:43.251] plan(): nbrOfWorkers() = 1
[10:21:43.252] plan(): Setting new future strategy stack:
[10:21:43.252] List of future strategies:
[10:21:43.252] 1. sequential:
[10:21:43.252]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.252]    - tweaked: FALSE
[10:21:43.252]    - call: plan(strategy)
[10:21:43.252] plan(): nbrOfWorkers() = 1
[10:21:43.252] SequentialFuture started (and completed)
[10:21:43.252] - Launch lazy future ... done
[10:21:43.252] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.253] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.253] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.255] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:43.255] Searching for globals ... DONE
[10:21:43.255] Resolving globals: TRUE
[10:21:43.255] Resolving any globals that are futures ...
[10:21:43.255] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:43.255] Resolving any globals that are futures ... DONE
[10:21:43.256] Resolving futures part of globals (recursively) ...
[10:21:43.256] resolve() on list ...
[10:21:43.256]  recursive: 99
[10:21:43.256]  length: 1
[10:21:43.256]  elements: ‘a’
[10:21:43.256]  length: 0 (resolved future 1)
[10:21:43.256] resolve() on list ... DONE
[10:21:43.256] - globals: [1] ‘a’
[10:21:43.256] Resolving futures part of globals (recursively) ... DONE
[10:21:43.256] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:43.257] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:43.257] - globals: [1] ‘a’
[10:21:43.257] 
[10:21:43.257] getGlobalsAndPackages() ... DONE
[10:21:43.257] run() for ‘Future’ ...
[10:21:43.257] - state: ‘created’
[10:21:43.258] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.258] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.258] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.258]   - Field: ‘label’
[10:21:43.258]   - Field: ‘local’
[10:21:43.258]   - Field: ‘owner’
[10:21:43.258]   - Field: ‘envir’
[10:21:43.258]   - Field: ‘packages’
[10:21:43.258]   - Field: ‘gc’
[10:21:43.259]   - Field: ‘conditions’
[10:21:43.259]   - Field: ‘expr’
[10:21:43.259]   - Field: ‘uuid’
[10:21:43.259]   - Field: ‘seed’
[10:21:43.259]   - Field: ‘version’
[10:21:43.259]   - Field: ‘result’
[10:21:43.259]   - Field: ‘asynchronous’
[10:21:43.259]   - Field: ‘calls’
[10:21:43.259]   - Field: ‘globals’
[10:21:43.259]   - Field: ‘stdout’
[10:21:43.261]   - Field: ‘earlySignal’
[10:21:43.261]   - Field: ‘lazy’
[10:21:43.261]   - Field: ‘state’
[10:21:43.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.261] - Launch lazy future ...
[10:21:43.262] Packages needed by the future expression (n = 0): <none>
[10:21:43.262] Packages needed by future strategies (n = 0): <none>
[10:21:43.262] {
[10:21:43.262]     {
[10:21:43.262]         {
[10:21:43.262]             ...future.startTime <- base::Sys.time()
[10:21:43.262]             {
[10:21:43.262]                 {
[10:21:43.262]                   {
[10:21:43.262]                     base::local({
[10:21:43.262]                       has_future <- base::requireNamespace("future", 
[10:21:43.262]                         quietly = TRUE)
[10:21:43.262]                       if (has_future) {
[10:21:43.262]                         ns <- base::getNamespace("future")
[10:21:43.262]                         version <- ns[[".package"]][["version"]]
[10:21:43.262]                         if (is.null(version)) 
[10:21:43.262]                           version <- utils::packageVersion("future")
[10:21:43.262]                       }
[10:21:43.262]                       else {
[10:21:43.262]                         version <- NULL
[10:21:43.262]                       }
[10:21:43.262]                       if (!has_future || version < "1.8.0") {
[10:21:43.262]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.262]                           "", base::R.version$version.string), 
[10:21:43.262]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.262]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.262]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.262]                             "release", "version")], collapse = " "), 
[10:21:43.262]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.262]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.262]                           info)
[10:21:43.262]                         info <- base::paste(info, collapse = "; ")
[10:21:43.262]                         if (!has_future) {
[10:21:43.262]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.262]                             info)
[10:21:43.262]                         }
[10:21:43.262]                         else {
[10:21:43.262]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.262]                             info, version)
[10:21:43.262]                         }
[10:21:43.262]                         base::stop(msg)
[10:21:43.262]                       }
[10:21:43.262]                     })
[10:21:43.262]                   }
[10:21:43.262]                   ...future.strategy.old <- future::plan("list")
[10:21:43.262]                   options(future.plan = NULL)
[10:21:43.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.262]                 }
[10:21:43.262]                 ...future.workdir <- getwd()
[10:21:43.262]             }
[10:21:43.262]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.262]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.262]         }
[10:21:43.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.262]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.262]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.262]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.262]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.262]             base::names(...future.oldOptions))
[10:21:43.262]     }
[10:21:43.262]     if (FALSE) {
[10:21:43.262]     }
[10:21:43.262]     else {
[10:21:43.262]         if (TRUE) {
[10:21:43.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.262]                 open = "w")
[10:21:43.262]         }
[10:21:43.262]         else {
[10:21:43.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.262]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.262]         }
[10:21:43.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.262]             base::sink(type = "output", split = FALSE)
[10:21:43.262]             base::close(...future.stdout)
[10:21:43.262]         }, add = TRUE)
[10:21:43.262]     }
[10:21:43.262]     ...future.frame <- base::sys.nframe()
[10:21:43.262]     ...future.conditions <- base::list()
[10:21:43.262]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.262]     if (FALSE) {
[10:21:43.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.262]     }
[10:21:43.262]     ...future.result <- base::tryCatch({
[10:21:43.262]         base::withCallingHandlers({
[10:21:43.262]             ...future.value <- base::withVisible(base::local({
[10:21:43.262]                 b <- a
[10:21:43.262]                 a <- 2
[10:21:43.262]                 a * b
[10:21:43.262]             }))
[10:21:43.262]             future::FutureResult(value = ...future.value$value, 
[10:21:43.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.262]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.262]                     ...future.globalenv.names))
[10:21:43.262]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.262]         }, condition = base::local({
[10:21:43.262]             c <- base::c
[10:21:43.262]             inherits <- base::inherits
[10:21:43.262]             invokeRestart <- base::invokeRestart
[10:21:43.262]             length <- base::length
[10:21:43.262]             list <- base::list
[10:21:43.262]             seq.int <- base::seq.int
[10:21:43.262]             signalCondition <- base::signalCondition
[10:21:43.262]             sys.calls <- base::sys.calls
[10:21:43.262]             `[[` <- base::`[[`
[10:21:43.262]             `+` <- base::`+`
[10:21:43.262]             `<<-` <- base::`<<-`
[10:21:43.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.262]                   3L)]
[10:21:43.262]             }
[10:21:43.262]             function(cond) {
[10:21:43.262]                 is_error <- inherits(cond, "error")
[10:21:43.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.262]                   NULL)
[10:21:43.262]                 if (is_error) {
[10:21:43.262]                   sessionInformation <- function() {
[10:21:43.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.262]                       search = base::search(), system = base::Sys.info())
[10:21:43.262]                   }
[10:21:43.262]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.262]                     cond$call), session = sessionInformation(), 
[10:21:43.262]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.262]                   signalCondition(cond)
[10:21:43.262]                 }
[10:21:43.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.262]                 "immediateCondition"))) {
[10:21:43.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.262]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.262]                   if (TRUE && !signal) {
[10:21:43.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.262]                     {
[10:21:43.262]                       inherits <- base::inherits
[10:21:43.262]                       invokeRestart <- base::invokeRestart
[10:21:43.262]                       is.null <- base::is.null
[10:21:43.262]                       muffled <- FALSE
[10:21:43.262]                       if (inherits(cond, "message")) {
[10:21:43.262]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.262]                         if (muffled) 
[10:21:43.262]                           invokeRestart("muffleMessage")
[10:21:43.262]                       }
[10:21:43.262]                       else if (inherits(cond, "warning")) {
[10:21:43.262]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.262]                         if (muffled) 
[10:21:43.262]                           invokeRestart("muffleWarning")
[10:21:43.262]                       }
[10:21:43.262]                       else if (inherits(cond, "condition")) {
[10:21:43.262]                         if (!is.null(pattern)) {
[10:21:43.262]                           computeRestarts <- base::computeRestarts
[10:21:43.262]                           grepl <- base::grepl
[10:21:43.262]                           restarts <- computeRestarts(cond)
[10:21:43.262]                           for (restart in restarts) {
[10:21:43.262]                             name <- restart$name
[10:21:43.262]                             if (is.null(name)) 
[10:21:43.262]                               next
[10:21:43.262]                             if (!grepl(pattern, name)) 
[10:21:43.262]                               next
[10:21:43.262]                             invokeRestart(restart)
[10:21:43.262]                             muffled <- TRUE
[10:21:43.262]                             break
[10:21:43.262]                           }
[10:21:43.262]                         }
[10:21:43.262]                       }
[10:21:43.262]                       invisible(muffled)
[10:21:43.262]                     }
[10:21:43.262]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.262]                   }
[10:21:43.262]                 }
[10:21:43.262]                 else {
[10:21:43.262]                   if (TRUE) {
[10:21:43.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.262]                     {
[10:21:43.262]                       inherits <- base::inherits
[10:21:43.262]                       invokeRestart <- base::invokeRestart
[10:21:43.262]                       is.null <- base::is.null
[10:21:43.262]                       muffled <- FALSE
[10:21:43.262]                       if (inherits(cond, "message")) {
[10:21:43.262]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.262]                         if (muffled) 
[10:21:43.262]                           invokeRestart("muffleMessage")
[10:21:43.262]                       }
[10:21:43.262]                       else if (inherits(cond, "warning")) {
[10:21:43.262]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.262]                         if (muffled) 
[10:21:43.262]                           invokeRestart("muffleWarning")
[10:21:43.262]                       }
[10:21:43.262]                       else if (inherits(cond, "condition")) {
[10:21:43.262]                         if (!is.null(pattern)) {
[10:21:43.262]                           computeRestarts <- base::computeRestarts
[10:21:43.262]                           grepl <- base::grepl
[10:21:43.262]                           restarts <- computeRestarts(cond)
[10:21:43.262]                           for (restart in restarts) {
[10:21:43.262]                             name <- restart$name
[10:21:43.262]                             if (is.null(name)) 
[10:21:43.262]                               next
[10:21:43.262]                             if (!grepl(pattern, name)) 
[10:21:43.262]                               next
[10:21:43.262]                             invokeRestart(restart)
[10:21:43.262]                             muffled <- TRUE
[10:21:43.262]                             break
[10:21:43.262]                           }
[10:21:43.262]                         }
[10:21:43.262]                       }
[10:21:43.262]                       invisible(muffled)
[10:21:43.262]                     }
[10:21:43.262]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.262]                   }
[10:21:43.262]                 }
[10:21:43.262]             }
[10:21:43.262]         }))
[10:21:43.262]     }, error = function(ex) {
[10:21:43.262]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.262]                 ...future.rng), started = ...future.startTime, 
[10:21:43.262]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.262]             version = "1.8"), class = "FutureResult")
[10:21:43.262]     }, finally = {
[10:21:43.262]         if (!identical(...future.workdir, getwd())) 
[10:21:43.262]             setwd(...future.workdir)
[10:21:43.262]         {
[10:21:43.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.262]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.262]             }
[10:21:43.262]             base::options(...future.oldOptions)
[10:21:43.262]             if (.Platform$OS.type == "windows") {
[10:21:43.262]                 old_names <- names(...future.oldEnvVars)
[10:21:43.262]                 envs <- base::Sys.getenv()
[10:21:43.262]                 names <- names(envs)
[10:21:43.262]                 common <- intersect(names, old_names)
[10:21:43.262]                 added <- setdiff(names, old_names)
[10:21:43.262]                 removed <- setdiff(old_names, names)
[10:21:43.262]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.262]                   envs[common]]
[10:21:43.262]                 NAMES <- toupper(changed)
[10:21:43.262]                 args <- list()
[10:21:43.262]                 for (kk in seq_along(NAMES)) {
[10:21:43.262]                   name <- changed[[kk]]
[10:21:43.262]                   NAME <- NAMES[[kk]]
[10:21:43.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.262]                     next
[10:21:43.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.262]                 }
[10:21:43.262]                 NAMES <- toupper(added)
[10:21:43.262]                 for (kk in seq_along(NAMES)) {
[10:21:43.262]                   name <- added[[kk]]
[10:21:43.262]                   NAME <- NAMES[[kk]]
[10:21:43.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.262]                     next
[10:21:43.262]                   args[[name]] <- ""
[10:21:43.262]                 }
[10:21:43.262]                 NAMES <- toupper(removed)
[10:21:43.262]                 for (kk in seq_along(NAMES)) {
[10:21:43.262]                   name <- removed[[kk]]
[10:21:43.262]                   NAME <- NAMES[[kk]]
[10:21:43.262]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.262]                     next
[10:21:43.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.262]                 }
[10:21:43.262]                 if (length(args) > 0) 
[10:21:43.262]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.262]             }
[10:21:43.262]             else {
[10:21:43.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.262]             }
[10:21:43.262]             {
[10:21:43.262]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.262]                   0L) {
[10:21:43.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.262]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.262]                   base::options(opts)
[10:21:43.262]                 }
[10:21:43.262]                 {
[10:21:43.262]                   {
[10:21:43.262]                     NULL
[10:21:43.262]                     RNGkind("Mersenne-Twister")
[10:21:43.262]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.262]                       inherits = FALSE)
[10:21:43.262]                   }
[10:21:43.262]                   options(future.plan = NULL)
[10:21:43.262]                   if (is.na(NA_character_)) 
[10:21:43.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.262]                     .init = FALSE)
[10:21:43.262]                 }
[10:21:43.262]             }
[10:21:43.262]         }
[10:21:43.262]     })
[10:21:43.262]     if (TRUE) {
[10:21:43.262]         base::sink(type = "output", split = FALSE)
[10:21:43.262]         if (TRUE) {
[10:21:43.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.262]         }
[10:21:43.262]         else {
[10:21:43.262]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.262]         }
[10:21:43.262]         base::close(...future.stdout)
[10:21:43.262]         ...future.stdout <- NULL
[10:21:43.262]     }
[10:21:43.262]     ...future.result$conditions <- ...future.conditions
[10:21:43.262]     ...future.result$finished <- base::Sys.time()
[10:21:43.262]     ...future.result
[10:21:43.262] }
[10:21:43.264] assign_globals() ...
[10:21:43.264] List of 1
[10:21:43.264]  $ a: num 3
[10:21:43.264]  - attr(*, "where")=List of 1
[10:21:43.264]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.264]  - attr(*, "resolved")= logi TRUE
[10:21:43.264]  - attr(*, "total_size")= num 39
[10:21:43.264]  - attr(*, "already-done")= logi TRUE
[10:21:43.266] - copied ‘a’ to environment
[10:21:43.266] assign_globals() ... done
[10:21:43.266] plan(): Setting new future strategy stack:
[10:21:43.267] List of future strategies:
[10:21:43.267] 1. sequential:
[10:21:43.267]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.267]    - tweaked: FALSE
[10:21:43.267]    - call: NULL
[10:21:43.267] plan(): nbrOfWorkers() = 1
[10:21:43.268] plan(): Setting new future strategy stack:
[10:21:43.268] List of future strategies:
[10:21:43.268] 1. sequential:
[10:21:43.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.268]    - tweaked: FALSE
[10:21:43.268]    - call: plan(strategy)
[10:21:43.268] plan(): nbrOfWorkers() = 1
[10:21:43.268] SequentialFuture started (and completed)
[10:21:43.268] - Launch lazy future ... done
[10:21:43.268] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.269] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.269] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.271] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.271] Searching for globals ... DONE
[10:21:43.271] Resolving globals: TRUE
[10:21:43.271] Resolving any globals that are futures ...
[10:21:43.271] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.271] Resolving any globals that are futures ... DONE
[10:21:43.272] Resolving futures part of globals (recursively) ...
[10:21:43.272] resolve() on list ...
[10:21:43.272]  recursive: 99
[10:21:43.272]  length: 2
[10:21:43.272]  elements: ‘a’, ‘ii’
[10:21:43.272]  length: 1 (resolved future 1)
[10:21:43.272]  length: 0 (resolved future 2)
[10:21:43.273] resolve() on list ... DONE
[10:21:43.273] - globals: [2] ‘a’, ‘ii’
[10:21:43.273] Resolving futures part of globals (recursively) ... DONE
[10:21:43.273] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:43.273] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.273] - globals: [2] ‘a’, ‘ii’
[10:21:43.273] 
[10:21:43.273] getGlobalsAndPackages() ... DONE
[10:21:43.274] run() for ‘Future’ ...
[10:21:43.274] - state: ‘created’
[10:21:43.274] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.274] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.274] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.274]   - Field: ‘label’
[10:21:43.274]   - Field: ‘local’
[10:21:43.274]   - Field: ‘owner’
[10:21:43.275]   - Field: ‘envir’
[10:21:43.275]   - Field: ‘packages’
[10:21:43.275]   - Field: ‘gc’
[10:21:43.275]   - Field: ‘conditions’
[10:21:43.275]   - Field: ‘expr’
[10:21:43.275]   - Field: ‘uuid’
[10:21:43.275]   - Field: ‘seed’
[10:21:43.275]   - Field: ‘version’
[10:21:43.275]   - Field: ‘result’
[10:21:43.275]   - Field: ‘asynchronous’
[10:21:43.275]   - Field: ‘calls’
[10:21:43.275]   - Field: ‘globals’
[10:21:43.276]   - Field: ‘stdout’
[10:21:43.276]   - Field: ‘earlySignal’
[10:21:43.276]   - Field: ‘lazy’
[10:21:43.276]   - Field: ‘state’
[10:21:43.276] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.276] - Launch lazy future ...
[10:21:43.276] Packages needed by the future expression (n = 0): <none>
[10:21:43.276] Packages needed by future strategies (n = 0): <none>
[10:21:43.277] {
[10:21:43.277]     {
[10:21:43.277]         {
[10:21:43.277]             ...future.startTime <- base::Sys.time()
[10:21:43.277]             {
[10:21:43.277]                 {
[10:21:43.277]                   {
[10:21:43.277]                     base::local({
[10:21:43.277]                       has_future <- base::requireNamespace("future", 
[10:21:43.277]                         quietly = TRUE)
[10:21:43.277]                       if (has_future) {
[10:21:43.277]                         ns <- base::getNamespace("future")
[10:21:43.277]                         version <- ns[[".package"]][["version"]]
[10:21:43.277]                         if (is.null(version)) 
[10:21:43.277]                           version <- utils::packageVersion("future")
[10:21:43.277]                       }
[10:21:43.277]                       else {
[10:21:43.277]                         version <- NULL
[10:21:43.277]                       }
[10:21:43.277]                       if (!has_future || version < "1.8.0") {
[10:21:43.277]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.277]                           "", base::R.version$version.string), 
[10:21:43.277]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.277]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.277]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.277]                             "release", "version")], collapse = " "), 
[10:21:43.277]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.277]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.277]                           info)
[10:21:43.277]                         info <- base::paste(info, collapse = "; ")
[10:21:43.277]                         if (!has_future) {
[10:21:43.277]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.277]                             info)
[10:21:43.277]                         }
[10:21:43.277]                         else {
[10:21:43.277]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.277]                             info, version)
[10:21:43.277]                         }
[10:21:43.277]                         base::stop(msg)
[10:21:43.277]                       }
[10:21:43.277]                     })
[10:21:43.277]                   }
[10:21:43.277]                   ...future.strategy.old <- future::plan("list")
[10:21:43.277]                   options(future.plan = NULL)
[10:21:43.277]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.277]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.277]                 }
[10:21:43.277]                 ...future.workdir <- getwd()
[10:21:43.277]             }
[10:21:43.277]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.277]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.277]         }
[10:21:43.277]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.277]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.277]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.277]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.277]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.277]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.277]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.277]             base::names(...future.oldOptions))
[10:21:43.277]     }
[10:21:43.277]     if (FALSE) {
[10:21:43.277]     }
[10:21:43.277]     else {
[10:21:43.277]         if (TRUE) {
[10:21:43.277]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.277]                 open = "w")
[10:21:43.277]         }
[10:21:43.277]         else {
[10:21:43.277]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.277]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.277]         }
[10:21:43.277]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.277]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.277]             base::sink(type = "output", split = FALSE)
[10:21:43.277]             base::close(...future.stdout)
[10:21:43.277]         }, add = TRUE)
[10:21:43.277]     }
[10:21:43.277]     ...future.frame <- base::sys.nframe()
[10:21:43.277]     ...future.conditions <- base::list()
[10:21:43.277]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.277]     if (FALSE) {
[10:21:43.277]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.277]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.277]     }
[10:21:43.277]     ...future.result <- base::tryCatch({
[10:21:43.277]         base::withCallingHandlers({
[10:21:43.277]             ...future.value <- base::withVisible(base::local({
[10:21:43.277]                 b <- a * ii
[10:21:43.277]                 a <- 0
[10:21:43.277]                 b
[10:21:43.277]             }))
[10:21:43.277]             future::FutureResult(value = ...future.value$value, 
[10:21:43.277]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.277]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.277]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.277]                     ...future.globalenv.names))
[10:21:43.277]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.277]         }, condition = base::local({
[10:21:43.277]             c <- base::c
[10:21:43.277]             inherits <- base::inherits
[10:21:43.277]             invokeRestart <- base::invokeRestart
[10:21:43.277]             length <- base::length
[10:21:43.277]             list <- base::list
[10:21:43.277]             seq.int <- base::seq.int
[10:21:43.277]             signalCondition <- base::signalCondition
[10:21:43.277]             sys.calls <- base::sys.calls
[10:21:43.277]             `[[` <- base::`[[`
[10:21:43.277]             `+` <- base::`+`
[10:21:43.277]             `<<-` <- base::`<<-`
[10:21:43.277]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.277]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.277]                   3L)]
[10:21:43.277]             }
[10:21:43.277]             function(cond) {
[10:21:43.277]                 is_error <- inherits(cond, "error")
[10:21:43.277]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.277]                   NULL)
[10:21:43.277]                 if (is_error) {
[10:21:43.277]                   sessionInformation <- function() {
[10:21:43.277]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.277]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.277]                       search = base::search(), system = base::Sys.info())
[10:21:43.277]                   }
[10:21:43.277]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.277]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.277]                     cond$call), session = sessionInformation(), 
[10:21:43.277]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.277]                   signalCondition(cond)
[10:21:43.277]                 }
[10:21:43.277]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.277]                 "immediateCondition"))) {
[10:21:43.277]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.277]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.277]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.277]                   if (TRUE && !signal) {
[10:21:43.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.277]                     {
[10:21:43.277]                       inherits <- base::inherits
[10:21:43.277]                       invokeRestart <- base::invokeRestart
[10:21:43.277]                       is.null <- base::is.null
[10:21:43.277]                       muffled <- FALSE
[10:21:43.277]                       if (inherits(cond, "message")) {
[10:21:43.277]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.277]                         if (muffled) 
[10:21:43.277]                           invokeRestart("muffleMessage")
[10:21:43.277]                       }
[10:21:43.277]                       else if (inherits(cond, "warning")) {
[10:21:43.277]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.277]                         if (muffled) 
[10:21:43.277]                           invokeRestart("muffleWarning")
[10:21:43.277]                       }
[10:21:43.277]                       else if (inherits(cond, "condition")) {
[10:21:43.277]                         if (!is.null(pattern)) {
[10:21:43.277]                           computeRestarts <- base::computeRestarts
[10:21:43.277]                           grepl <- base::grepl
[10:21:43.277]                           restarts <- computeRestarts(cond)
[10:21:43.277]                           for (restart in restarts) {
[10:21:43.277]                             name <- restart$name
[10:21:43.277]                             if (is.null(name)) 
[10:21:43.277]                               next
[10:21:43.277]                             if (!grepl(pattern, name)) 
[10:21:43.277]                               next
[10:21:43.277]                             invokeRestart(restart)
[10:21:43.277]                             muffled <- TRUE
[10:21:43.277]                             break
[10:21:43.277]                           }
[10:21:43.277]                         }
[10:21:43.277]                       }
[10:21:43.277]                       invisible(muffled)
[10:21:43.277]                     }
[10:21:43.277]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.277]                   }
[10:21:43.277]                 }
[10:21:43.277]                 else {
[10:21:43.277]                   if (TRUE) {
[10:21:43.277]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.277]                     {
[10:21:43.277]                       inherits <- base::inherits
[10:21:43.277]                       invokeRestart <- base::invokeRestart
[10:21:43.277]                       is.null <- base::is.null
[10:21:43.277]                       muffled <- FALSE
[10:21:43.277]                       if (inherits(cond, "message")) {
[10:21:43.277]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.277]                         if (muffled) 
[10:21:43.277]                           invokeRestart("muffleMessage")
[10:21:43.277]                       }
[10:21:43.277]                       else if (inherits(cond, "warning")) {
[10:21:43.277]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.277]                         if (muffled) 
[10:21:43.277]                           invokeRestart("muffleWarning")
[10:21:43.277]                       }
[10:21:43.277]                       else if (inherits(cond, "condition")) {
[10:21:43.277]                         if (!is.null(pattern)) {
[10:21:43.277]                           computeRestarts <- base::computeRestarts
[10:21:43.277]                           grepl <- base::grepl
[10:21:43.277]                           restarts <- computeRestarts(cond)
[10:21:43.277]                           for (restart in restarts) {
[10:21:43.277]                             name <- restart$name
[10:21:43.277]                             if (is.null(name)) 
[10:21:43.277]                               next
[10:21:43.277]                             if (!grepl(pattern, name)) 
[10:21:43.277]                               next
[10:21:43.277]                             invokeRestart(restart)
[10:21:43.277]                             muffled <- TRUE
[10:21:43.277]                             break
[10:21:43.277]                           }
[10:21:43.277]                         }
[10:21:43.277]                       }
[10:21:43.277]                       invisible(muffled)
[10:21:43.277]                     }
[10:21:43.277]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.277]                   }
[10:21:43.277]                 }
[10:21:43.277]             }
[10:21:43.277]         }))
[10:21:43.277]     }, error = function(ex) {
[10:21:43.277]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.277]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.277]                 ...future.rng), started = ...future.startTime, 
[10:21:43.277]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.277]             version = "1.8"), class = "FutureResult")
[10:21:43.277]     }, finally = {
[10:21:43.277]         if (!identical(...future.workdir, getwd())) 
[10:21:43.277]             setwd(...future.workdir)
[10:21:43.277]         {
[10:21:43.277]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.277]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.277]             }
[10:21:43.277]             base::options(...future.oldOptions)
[10:21:43.277]             if (.Platform$OS.type == "windows") {
[10:21:43.277]                 old_names <- names(...future.oldEnvVars)
[10:21:43.277]                 envs <- base::Sys.getenv()
[10:21:43.277]                 names <- names(envs)
[10:21:43.277]                 common <- intersect(names, old_names)
[10:21:43.277]                 added <- setdiff(names, old_names)
[10:21:43.277]                 removed <- setdiff(old_names, names)
[10:21:43.277]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.277]                   envs[common]]
[10:21:43.277]                 NAMES <- toupper(changed)
[10:21:43.277]                 args <- list()
[10:21:43.277]                 for (kk in seq_along(NAMES)) {
[10:21:43.277]                   name <- changed[[kk]]
[10:21:43.277]                   NAME <- NAMES[[kk]]
[10:21:43.277]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.277]                     next
[10:21:43.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.277]                 }
[10:21:43.277]                 NAMES <- toupper(added)
[10:21:43.277]                 for (kk in seq_along(NAMES)) {
[10:21:43.277]                   name <- added[[kk]]
[10:21:43.277]                   NAME <- NAMES[[kk]]
[10:21:43.277]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.277]                     next
[10:21:43.277]                   args[[name]] <- ""
[10:21:43.277]                 }
[10:21:43.277]                 NAMES <- toupper(removed)
[10:21:43.277]                 for (kk in seq_along(NAMES)) {
[10:21:43.277]                   name <- removed[[kk]]
[10:21:43.277]                   NAME <- NAMES[[kk]]
[10:21:43.277]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.277]                     next
[10:21:43.277]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.277]                 }
[10:21:43.277]                 if (length(args) > 0) 
[10:21:43.277]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.277]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.277]             }
[10:21:43.277]             else {
[10:21:43.277]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.277]             }
[10:21:43.277]             {
[10:21:43.277]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.277]                   0L) {
[10:21:43.277]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.277]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.277]                   base::options(opts)
[10:21:43.277]                 }
[10:21:43.277]                 {
[10:21:43.277]                   {
[10:21:43.277]                     NULL
[10:21:43.277]                     RNGkind("Mersenne-Twister")
[10:21:43.277]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.277]                       inherits = FALSE)
[10:21:43.277]                   }
[10:21:43.277]                   options(future.plan = NULL)
[10:21:43.277]                   if (is.na(NA_character_)) 
[10:21:43.277]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.277]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.277]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.277]                     .init = FALSE)
[10:21:43.277]                 }
[10:21:43.277]             }
[10:21:43.277]         }
[10:21:43.277]     })
[10:21:43.277]     if (TRUE) {
[10:21:43.277]         base::sink(type = "output", split = FALSE)
[10:21:43.277]         if (TRUE) {
[10:21:43.277]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.277]         }
[10:21:43.277]         else {
[10:21:43.277]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.277]         }
[10:21:43.277]         base::close(...future.stdout)
[10:21:43.277]         ...future.stdout <- NULL
[10:21:43.277]     }
[10:21:43.277]     ...future.result$conditions <- ...future.conditions
[10:21:43.277]     ...future.result$finished <- base::Sys.time()
[10:21:43.277]     ...future.result
[10:21:43.277] }
[10:21:43.278] assign_globals() ...
[10:21:43.278] List of 2
[10:21:43.278]  $ a : num 1
[10:21:43.278]  $ ii: int 1
[10:21:43.278]  - attr(*, "where")=List of 2
[10:21:43.278]   ..$ a :<environment: R_EmptyEnv> 
[10:21:43.278]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.278]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.278]  - attr(*, "resolved")= logi TRUE
[10:21:43.278]  - attr(*, "total_size")= num 74
[10:21:43.278]  - attr(*, "already-done")= logi TRUE
[10:21:43.281] - copied ‘a’ to environment
[10:21:43.281] - copied ‘ii’ to environment
[10:21:43.281] assign_globals() ... done
[10:21:43.282] plan(): Setting new future strategy stack:
[10:21:43.282] List of future strategies:
[10:21:43.282] 1. sequential:
[10:21:43.282]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.282]    - tweaked: FALSE
[10:21:43.282]    - call: NULL
[10:21:43.282] plan(): nbrOfWorkers() = 1
[10:21:43.283] plan(): Setting new future strategy stack:
[10:21:43.283] List of future strategies:
[10:21:43.283] 1. sequential:
[10:21:43.283]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.283]    - tweaked: FALSE
[10:21:43.283]    - call: plan(strategy)
[10:21:43.283] plan(): nbrOfWorkers() = 1
[10:21:43.283] SequentialFuture started (and completed)
[10:21:43.283] - Launch lazy future ... done
[10:21:43.284] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.284] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.284] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.287] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.287] Searching for globals ... DONE
[10:21:43.288] Resolving globals: TRUE
[10:21:43.288] Resolving any globals that are futures ...
[10:21:43.288] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.288] Resolving any globals that are futures ... DONE
[10:21:43.288] Resolving futures part of globals (recursively) ...
[10:21:43.288] resolve() on list ...
[10:21:43.288]  recursive: 99
[10:21:43.289]  length: 2
[10:21:43.289]  elements: ‘a’, ‘ii’
[10:21:43.289]  length: 1 (resolved future 1)
[10:21:43.289]  length: 0 (resolved future 2)
[10:21:43.289] resolve() on list ... DONE
[10:21:43.289] - globals: [2] ‘a’, ‘ii’
[10:21:43.289] Resolving futures part of globals (recursively) ... DONE
[10:21:43.289] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:43.290] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.290] - globals: [2] ‘a’, ‘ii’
[10:21:43.290] 
[10:21:43.290] getGlobalsAndPackages() ... DONE
[10:21:43.290] run() for ‘Future’ ...
[10:21:43.290] - state: ‘created’
[10:21:43.290] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.290] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.291] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.291]   - Field: ‘label’
[10:21:43.291]   - Field: ‘local’
[10:21:43.291]   - Field: ‘owner’
[10:21:43.291]   - Field: ‘envir’
[10:21:43.291]   - Field: ‘packages’
[10:21:43.291]   - Field: ‘gc’
[10:21:43.291]   - Field: ‘conditions’
[10:21:43.291]   - Field: ‘expr’
[10:21:43.291]   - Field: ‘uuid’
[10:21:43.291]   - Field: ‘seed’
[10:21:43.292]   - Field: ‘version’
[10:21:43.292]   - Field: ‘result’
[10:21:43.292]   - Field: ‘asynchronous’
[10:21:43.292]   - Field: ‘calls’
[10:21:43.292]   - Field: ‘globals’
[10:21:43.292]   - Field: ‘stdout’
[10:21:43.292]   - Field: ‘earlySignal’
[10:21:43.292]   - Field: ‘lazy’
[10:21:43.292]   - Field: ‘state’
[10:21:43.292] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.292] - Launch lazy future ...
[10:21:43.292] Packages needed by the future expression (n = 0): <none>
[10:21:43.293] Packages needed by future strategies (n = 0): <none>
[10:21:43.293] {
[10:21:43.293]     {
[10:21:43.293]         {
[10:21:43.293]             ...future.startTime <- base::Sys.time()
[10:21:43.293]             {
[10:21:43.293]                 {
[10:21:43.293]                   {
[10:21:43.293]                     base::local({
[10:21:43.293]                       has_future <- base::requireNamespace("future", 
[10:21:43.293]                         quietly = TRUE)
[10:21:43.293]                       if (has_future) {
[10:21:43.293]                         ns <- base::getNamespace("future")
[10:21:43.293]                         version <- ns[[".package"]][["version"]]
[10:21:43.293]                         if (is.null(version)) 
[10:21:43.293]                           version <- utils::packageVersion("future")
[10:21:43.293]                       }
[10:21:43.293]                       else {
[10:21:43.293]                         version <- NULL
[10:21:43.293]                       }
[10:21:43.293]                       if (!has_future || version < "1.8.0") {
[10:21:43.293]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.293]                           "", base::R.version$version.string), 
[10:21:43.293]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.293]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.293]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.293]                             "release", "version")], collapse = " "), 
[10:21:43.293]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.293]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.293]                           info)
[10:21:43.293]                         info <- base::paste(info, collapse = "; ")
[10:21:43.293]                         if (!has_future) {
[10:21:43.293]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.293]                             info)
[10:21:43.293]                         }
[10:21:43.293]                         else {
[10:21:43.293]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.293]                             info, version)
[10:21:43.293]                         }
[10:21:43.293]                         base::stop(msg)
[10:21:43.293]                       }
[10:21:43.293]                     })
[10:21:43.293]                   }
[10:21:43.293]                   ...future.strategy.old <- future::plan("list")
[10:21:43.293]                   options(future.plan = NULL)
[10:21:43.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.293]                 }
[10:21:43.293]                 ...future.workdir <- getwd()
[10:21:43.293]             }
[10:21:43.293]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.293]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.293]         }
[10:21:43.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.293]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.293]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.293]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.293]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.293]             base::names(...future.oldOptions))
[10:21:43.293]     }
[10:21:43.293]     if (FALSE) {
[10:21:43.293]     }
[10:21:43.293]     else {
[10:21:43.293]         if (TRUE) {
[10:21:43.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.293]                 open = "w")
[10:21:43.293]         }
[10:21:43.293]         else {
[10:21:43.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.293]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.293]         }
[10:21:43.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.293]             base::sink(type = "output", split = FALSE)
[10:21:43.293]             base::close(...future.stdout)
[10:21:43.293]         }, add = TRUE)
[10:21:43.293]     }
[10:21:43.293]     ...future.frame <- base::sys.nframe()
[10:21:43.293]     ...future.conditions <- base::list()
[10:21:43.293]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.293]     if (FALSE) {
[10:21:43.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.293]     }
[10:21:43.293]     ...future.result <- base::tryCatch({
[10:21:43.293]         base::withCallingHandlers({
[10:21:43.293]             ...future.value <- base::withVisible(base::local({
[10:21:43.293]                 b <- a * ii
[10:21:43.293]                 a <- 0
[10:21:43.293]                 b
[10:21:43.293]             }))
[10:21:43.293]             future::FutureResult(value = ...future.value$value, 
[10:21:43.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.293]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.293]                     ...future.globalenv.names))
[10:21:43.293]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.293]         }, condition = base::local({
[10:21:43.293]             c <- base::c
[10:21:43.293]             inherits <- base::inherits
[10:21:43.293]             invokeRestart <- base::invokeRestart
[10:21:43.293]             length <- base::length
[10:21:43.293]             list <- base::list
[10:21:43.293]             seq.int <- base::seq.int
[10:21:43.293]             signalCondition <- base::signalCondition
[10:21:43.293]             sys.calls <- base::sys.calls
[10:21:43.293]             `[[` <- base::`[[`
[10:21:43.293]             `+` <- base::`+`
[10:21:43.293]             `<<-` <- base::`<<-`
[10:21:43.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.293]                   3L)]
[10:21:43.293]             }
[10:21:43.293]             function(cond) {
[10:21:43.293]                 is_error <- inherits(cond, "error")
[10:21:43.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.293]                   NULL)
[10:21:43.293]                 if (is_error) {
[10:21:43.293]                   sessionInformation <- function() {
[10:21:43.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.293]                       search = base::search(), system = base::Sys.info())
[10:21:43.293]                   }
[10:21:43.293]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.293]                     cond$call), session = sessionInformation(), 
[10:21:43.293]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.293]                   signalCondition(cond)
[10:21:43.293]                 }
[10:21:43.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.293]                 "immediateCondition"))) {
[10:21:43.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.293]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.293]                   if (TRUE && !signal) {
[10:21:43.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.293]                     {
[10:21:43.293]                       inherits <- base::inherits
[10:21:43.293]                       invokeRestart <- base::invokeRestart
[10:21:43.293]                       is.null <- base::is.null
[10:21:43.293]                       muffled <- FALSE
[10:21:43.293]                       if (inherits(cond, "message")) {
[10:21:43.293]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.293]                         if (muffled) 
[10:21:43.293]                           invokeRestart("muffleMessage")
[10:21:43.293]                       }
[10:21:43.293]                       else if (inherits(cond, "warning")) {
[10:21:43.293]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.293]                         if (muffled) 
[10:21:43.293]                           invokeRestart("muffleWarning")
[10:21:43.293]                       }
[10:21:43.293]                       else if (inherits(cond, "condition")) {
[10:21:43.293]                         if (!is.null(pattern)) {
[10:21:43.293]                           computeRestarts <- base::computeRestarts
[10:21:43.293]                           grepl <- base::grepl
[10:21:43.293]                           restarts <- computeRestarts(cond)
[10:21:43.293]                           for (restart in restarts) {
[10:21:43.293]                             name <- restart$name
[10:21:43.293]                             if (is.null(name)) 
[10:21:43.293]                               next
[10:21:43.293]                             if (!grepl(pattern, name)) 
[10:21:43.293]                               next
[10:21:43.293]                             invokeRestart(restart)
[10:21:43.293]                             muffled <- TRUE
[10:21:43.293]                             break
[10:21:43.293]                           }
[10:21:43.293]                         }
[10:21:43.293]                       }
[10:21:43.293]                       invisible(muffled)
[10:21:43.293]                     }
[10:21:43.293]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.293]                   }
[10:21:43.293]                 }
[10:21:43.293]                 else {
[10:21:43.293]                   if (TRUE) {
[10:21:43.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.293]                     {
[10:21:43.293]                       inherits <- base::inherits
[10:21:43.293]                       invokeRestart <- base::invokeRestart
[10:21:43.293]                       is.null <- base::is.null
[10:21:43.293]                       muffled <- FALSE
[10:21:43.293]                       if (inherits(cond, "message")) {
[10:21:43.293]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.293]                         if (muffled) 
[10:21:43.293]                           invokeRestart("muffleMessage")
[10:21:43.293]                       }
[10:21:43.293]                       else if (inherits(cond, "warning")) {
[10:21:43.293]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.293]                         if (muffled) 
[10:21:43.293]                           invokeRestart("muffleWarning")
[10:21:43.293]                       }
[10:21:43.293]                       else if (inherits(cond, "condition")) {
[10:21:43.293]                         if (!is.null(pattern)) {
[10:21:43.293]                           computeRestarts <- base::computeRestarts
[10:21:43.293]                           grepl <- base::grepl
[10:21:43.293]                           restarts <- computeRestarts(cond)
[10:21:43.293]                           for (restart in restarts) {
[10:21:43.293]                             name <- restart$name
[10:21:43.293]                             if (is.null(name)) 
[10:21:43.293]                               next
[10:21:43.293]                             if (!grepl(pattern, name)) 
[10:21:43.293]                               next
[10:21:43.293]                             invokeRestart(restart)
[10:21:43.293]                             muffled <- TRUE
[10:21:43.293]                             break
[10:21:43.293]                           }
[10:21:43.293]                         }
[10:21:43.293]                       }
[10:21:43.293]                       invisible(muffled)
[10:21:43.293]                     }
[10:21:43.293]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.293]                   }
[10:21:43.293]                 }
[10:21:43.293]             }
[10:21:43.293]         }))
[10:21:43.293]     }, error = function(ex) {
[10:21:43.293]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.293]                 ...future.rng), started = ...future.startTime, 
[10:21:43.293]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.293]             version = "1.8"), class = "FutureResult")
[10:21:43.293]     }, finally = {
[10:21:43.293]         if (!identical(...future.workdir, getwd())) 
[10:21:43.293]             setwd(...future.workdir)
[10:21:43.293]         {
[10:21:43.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.293]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.293]             }
[10:21:43.293]             base::options(...future.oldOptions)
[10:21:43.293]             if (.Platform$OS.type == "windows") {
[10:21:43.293]                 old_names <- names(...future.oldEnvVars)
[10:21:43.293]                 envs <- base::Sys.getenv()
[10:21:43.293]                 names <- names(envs)
[10:21:43.293]                 common <- intersect(names, old_names)
[10:21:43.293]                 added <- setdiff(names, old_names)
[10:21:43.293]                 removed <- setdiff(old_names, names)
[10:21:43.293]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.293]                   envs[common]]
[10:21:43.293]                 NAMES <- toupper(changed)
[10:21:43.293]                 args <- list()
[10:21:43.293]                 for (kk in seq_along(NAMES)) {
[10:21:43.293]                   name <- changed[[kk]]
[10:21:43.293]                   NAME <- NAMES[[kk]]
[10:21:43.293]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.293]                     next
[10:21:43.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.293]                 }
[10:21:43.293]                 NAMES <- toupper(added)
[10:21:43.293]                 for (kk in seq_along(NAMES)) {
[10:21:43.293]                   name <- added[[kk]]
[10:21:43.293]                   NAME <- NAMES[[kk]]
[10:21:43.293]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.293]                     next
[10:21:43.293]                   args[[name]] <- ""
[10:21:43.293]                 }
[10:21:43.293]                 NAMES <- toupper(removed)
[10:21:43.293]                 for (kk in seq_along(NAMES)) {
[10:21:43.293]                   name <- removed[[kk]]
[10:21:43.293]                   NAME <- NAMES[[kk]]
[10:21:43.293]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.293]                     next
[10:21:43.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.293]                 }
[10:21:43.293]                 if (length(args) > 0) 
[10:21:43.293]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.293]             }
[10:21:43.293]             else {
[10:21:43.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.293]             }
[10:21:43.293]             {
[10:21:43.293]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.293]                   0L) {
[10:21:43.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.293]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.293]                   base::options(opts)
[10:21:43.293]                 }
[10:21:43.293]                 {
[10:21:43.293]                   {
[10:21:43.293]                     NULL
[10:21:43.293]                     RNGkind("Mersenne-Twister")
[10:21:43.293]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.293]                       inherits = FALSE)
[10:21:43.293]                   }
[10:21:43.293]                   options(future.plan = NULL)
[10:21:43.293]                   if (is.na(NA_character_)) 
[10:21:43.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.293]                     .init = FALSE)
[10:21:43.293]                 }
[10:21:43.293]             }
[10:21:43.293]         }
[10:21:43.293]     })
[10:21:43.293]     if (TRUE) {
[10:21:43.293]         base::sink(type = "output", split = FALSE)
[10:21:43.293]         if (TRUE) {
[10:21:43.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.293]         }
[10:21:43.293]         else {
[10:21:43.293]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.293]         }
[10:21:43.293]         base::close(...future.stdout)
[10:21:43.293]         ...future.stdout <- NULL
[10:21:43.293]     }
[10:21:43.293]     ...future.result$conditions <- ...future.conditions
[10:21:43.293]     ...future.result$finished <- base::Sys.time()
[10:21:43.293]     ...future.result
[10:21:43.293] }
[10:21:43.295] assign_globals() ...
[10:21:43.295] List of 2
[10:21:43.295]  $ a : num 1
[10:21:43.295]  $ ii: int 2
[10:21:43.295]  - attr(*, "where")=List of 2
[10:21:43.295]   ..$ a :<environment: R_EmptyEnv> 
[10:21:43.295]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.295]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.295]  - attr(*, "resolved")= logi TRUE
[10:21:43.295]  - attr(*, "total_size")= num 74
[10:21:43.295]  - attr(*, "already-done")= logi TRUE
[10:21:43.298] - copied ‘a’ to environment
[10:21:43.298] - copied ‘ii’ to environment
[10:21:43.298] assign_globals() ... done
[10:21:43.298] plan(): Setting new future strategy stack:
[10:21:43.298] List of future strategies:
[10:21:43.298] 1. sequential:
[10:21:43.298]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.298]    - tweaked: FALSE
[10:21:43.298]    - call: NULL
[10:21:43.298] plan(): nbrOfWorkers() = 1
[10:21:43.299] plan(): Setting new future strategy stack:
[10:21:43.299] List of future strategies:
[10:21:43.299] 1. sequential:
[10:21:43.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.299]    - tweaked: FALSE
[10:21:43.299]    - call: plan(strategy)
[10:21:43.300] plan(): nbrOfWorkers() = 1
[10:21:43.300] SequentialFuture started (and completed)
[10:21:43.300] - Launch lazy future ... done
[10:21:43.300] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.301] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.301] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.302] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.303] Searching for globals ... DONE
[10:21:43.303] Resolving globals: TRUE
[10:21:43.303] Resolving any globals that are futures ...
[10:21:43.303] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.303] Resolving any globals that are futures ... DONE
[10:21:43.303] Resolving futures part of globals (recursively) ...
[10:21:43.303] resolve() on list ...
[10:21:43.304]  recursive: 99
[10:21:43.304]  length: 2
[10:21:43.304]  elements: ‘a’, ‘ii’
[10:21:43.304]  length: 1 (resolved future 1)
[10:21:43.304]  length: 0 (resolved future 2)
[10:21:43.304] resolve() on list ... DONE
[10:21:43.304] - globals: [2] ‘a’, ‘ii’
[10:21:43.304] Resolving futures part of globals (recursively) ... DONE
[10:21:43.304] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:43.305] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.305] - globals: [2] ‘a’, ‘ii’
[10:21:43.305] 
[10:21:43.305] getGlobalsAndPackages() ... DONE
[10:21:43.305] run() for ‘Future’ ...
[10:21:43.305] - state: ‘created’
[10:21:43.305] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.306] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.306] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.306]   - Field: ‘label’
[10:21:43.306]   - Field: ‘local’
[10:21:43.306]   - Field: ‘owner’
[10:21:43.306]   - Field: ‘envir’
[10:21:43.306]   - Field: ‘packages’
[10:21:43.306]   - Field: ‘gc’
[10:21:43.306]   - Field: ‘conditions’
[10:21:43.306]   - Field: ‘expr’
[10:21:43.306]   - Field: ‘uuid’
[10:21:43.307]   - Field: ‘seed’
[10:21:43.307]   - Field: ‘version’
[10:21:43.307]   - Field: ‘result’
[10:21:43.307]   - Field: ‘asynchronous’
[10:21:43.307]   - Field: ‘calls’
[10:21:43.307]   - Field: ‘globals’
[10:21:43.307]   - Field: ‘stdout’
[10:21:43.307]   - Field: ‘earlySignal’
[10:21:43.307]   - Field: ‘lazy’
[10:21:43.307]   - Field: ‘state’
[10:21:43.307] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.307] - Launch lazy future ...
[10:21:43.308] Packages needed by the future expression (n = 0): <none>
[10:21:43.308] Packages needed by future strategies (n = 0): <none>
[10:21:43.310] {
[10:21:43.310]     {
[10:21:43.310]         {
[10:21:43.310]             ...future.startTime <- base::Sys.time()
[10:21:43.310]             {
[10:21:43.310]                 {
[10:21:43.310]                   {
[10:21:43.310]                     base::local({
[10:21:43.310]                       has_future <- base::requireNamespace("future", 
[10:21:43.310]                         quietly = TRUE)
[10:21:43.310]                       if (has_future) {
[10:21:43.310]                         ns <- base::getNamespace("future")
[10:21:43.310]                         version <- ns[[".package"]][["version"]]
[10:21:43.310]                         if (is.null(version)) 
[10:21:43.310]                           version <- utils::packageVersion("future")
[10:21:43.310]                       }
[10:21:43.310]                       else {
[10:21:43.310]                         version <- NULL
[10:21:43.310]                       }
[10:21:43.310]                       if (!has_future || version < "1.8.0") {
[10:21:43.310]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.310]                           "", base::R.version$version.string), 
[10:21:43.310]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.310]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.310]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.310]                             "release", "version")], collapse = " "), 
[10:21:43.310]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.310]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.310]                           info)
[10:21:43.310]                         info <- base::paste(info, collapse = "; ")
[10:21:43.310]                         if (!has_future) {
[10:21:43.310]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.310]                             info)
[10:21:43.310]                         }
[10:21:43.310]                         else {
[10:21:43.310]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.310]                             info, version)
[10:21:43.310]                         }
[10:21:43.310]                         base::stop(msg)
[10:21:43.310]                       }
[10:21:43.310]                     })
[10:21:43.310]                   }
[10:21:43.310]                   ...future.strategy.old <- future::plan("list")
[10:21:43.310]                   options(future.plan = NULL)
[10:21:43.310]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.310]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.310]                 }
[10:21:43.310]                 ...future.workdir <- getwd()
[10:21:43.310]             }
[10:21:43.310]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.310]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.310]         }
[10:21:43.310]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.310]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.310]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.310]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.310]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.310]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.310]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.310]             base::names(...future.oldOptions))
[10:21:43.310]     }
[10:21:43.310]     if (FALSE) {
[10:21:43.310]     }
[10:21:43.310]     else {
[10:21:43.310]         if (TRUE) {
[10:21:43.310]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.310]                 open = "w")
[10:21:43.310]         }
[10:21:43.310]         else {
[10:21:43.310]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.310]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.310]         }
[10:21:43.310]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.310]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.310]             base::sink(type = "output", split = FALSE)
[10:21:43.310]             base::close(...future.stdout)
[10:21:43.310]         }, add = TRUE)
[10:21:43.310]     }
[10:21:43.310]     ...future.frame <- base::sys.nframe()
[10:21:43.310]     ...future.conditions <- base::list()
[10:21:43.310]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.310]     if (FALSE) {
[10:21:43.310]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.310]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.310]     }
[10:21:43.310]     ...future.result <- base::tryCatch({
[10:21:43.310]         base::withCallingHandlers({
[10:21:43.310]             ...future.value <- base::withVisible(base::local({
[10:21:43.310]                 b <- a * ii
[10:21:43.310]                 a <- 0
[10:21:43.310]                 b
[10:21:43.310]             }))
[10:21:43.310]             future::FutureResult(value = ...future.value$value, 
[10:21:43.310]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.310]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.310]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.310]                     ...future.globalenv.names))
[10:21:43.310]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.310]         }, condition = base::local({
[10:21:43.310]             c <- base::c
[10:21:43.310]             inherits <- base::inherits
[10:21:43.310]             invokeRestart <- base::invokeRestart
[10:21:43.310]             length <- base::length
[10:21:43.310]             list <- base::list
[10:21:43.310]             seq.int <- base::seq.int
[10:21:43.310]             signalCondition <- base::signalCondition
[10:21:43.310]             sys.calls <- base::sys.calls
[10:21:43.310]             `[[` <- base::`[[`
[10:21:43.310]             `+` <- base::`+`
[10:21:43.310]             `<<-` <- base::`<<-`
[10:21:43.310]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.310]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.310]                   3L)]
[10:21:43.310]             }
[10:21:43.310]             function(cond) {
[10:21:43.310]                 is_error <- inherits(cond, "error")
[10:21:43.310]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.310]                   NULL)
[10:21:43.310]                 if (is_error) {
[10:21:43.310]                   sessionInformation <- function() {
[10:21:43.310]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.310]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.310]                       search = base::search(), system = base::Sys.info())
[10:21:43.310]                   }
[10:21:43.310]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.310]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.310]                     cond$call), session = sessionInformation(), 
[10:21:43.310]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.310]                   signalCondition(cond)
[10:21:43.310]                 }
[10:21:43.310]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.310]                 "immediateCondition"))) {
[10:21:43.310]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.310]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.310]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.310]                   if (TRUE && !signal) {
[10:21:43.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.310]                     {
[10:21:43.310]                       inherits <- base::inherits
[10:21:43.310]                       invokeRestart <- base::invokeRestart
[10:21:43.310]                       is.null <- base::is.null
[10:21:43.310]                       muffled <- FALSE
[10:21:43.310]                       if (inherits(cond, "message")) {
[10:21:43.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.310]                         if (muffled) 
[10:21:43.310]                           invokeRestart("muffleMessage")
[10:21:43.310]                       }
[10:21:43.310]                       else if (inherits(cond, "warning")) {
[10:21:43.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.310]                         if (muffled) 
[10:21:43.310]                           invokeRestart("muffleWarning")
[10:21:43.310]                       }
[10:21:43.310]                       else if (inherits(cond, "condition")) {
[10:21:43.310]                         if (!is.null(pattern)) {
[10:21:43.310]                           computeRestarts <- base::computeRestarts
[10:21:43.310]                           grepl <- base::grepl
[10:21:43.310]                           restarts <- computeRestarts(cond)
[10:21:43.310]                           for (restart in restarts) {
[10:21:43.310]                             name <- restart$name
[10:21:43.310]                             if (is.null(name)) 
[10:21:43.310]                               next
[10:21:43.310]                             if (!grepl(pattern, name)) 
[10:21:43.310]                               next
[10:21:43.310]                             invokeRestart(restart)
[10:21:43.310]                             muffled <- TRUE
[10:21:43.310]                             break
[10:21:43.310]                           }
[10:21:43.310]                         }
[10:21:43.310]                       }
[10:21:43.310]                       invisible(muffled)
[10:21:43.310]                     }
[10:21:43.310]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.310]                   }
[10:21:43.310]                 }
[10:21:43.310]                 else {
[10:21:43.310]                   if (TRUE) {
[10:21:43.310]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.310]                     {
[10:21:43.310]                       inherits <- base::inherits
[10:21:43.310]                       invokeRestart <- base::invokeRestart
[10:21:43.310]                       is.null <- base::is.null
[10:21:43.310]                       muffled <- FALSE
[10:21:43.310]                       if (inherits(cond, "message")) {
[10:21:43.310]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.310]                         if (muffled) 
[10:21:43.310]                           invokeRestart("muffleMessage")
[10:21:43.310]                       }
[10:21:43.310]                       else if (inherits(cond, "warning")) {
[10:21:43.310]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.310]                         if (muffled) 
[10:21:43.310]                           invokeRestart("muffleWarning")
[10:21:43.310]                       }
[10:21:43.310]                       else if (inherits(cond, "condition")) {
[10:21:43.310]                         if (!is.null(pattern)) {
[10:21:43.310]                           computeRestarts <- base::computeRestarts
[10:21:43.310]                           grepl <- base::grepl
[10:21:43.310]                           restarts <- computeRestarts(cond)
[10:21:43.310]                           for (restart in restarts) {
[10:21:43.310]                             name <- restart$name
[10:21:43.310]                             if (is.null(name)) 
[10:21:43.310]                               next
[10:21:43.310]                             if (!grepl(pattern, name)) 
[10:21:43.310]                               next
[10:21:43.310]                             invokeRestart(restart)
[10:21:43.310]                             muffled <- TRUE
[10:21:43.310]                             break
[10:21:43.310]                           }
[10:21:43.310]                         }
[10:21:43.310]                       }
[10:21:43.310]                       invisible(muffled)
[10:21:43.310]                     }
[10:21:43.310]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.310]                   }
[10:21:43.310]                 }
[10:21:43.310]             }
[10:21:43.310]         }))
[10:21:43.310]     }, error = function(ex) {
[10:21:43.310]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.310]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.310]                 ...future.rng), started = ...future.startTime, 
[10:21:43.310]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.310]             version = "1.8"), class = "FutureResult")
[10:21:43.310]     }, finally = {
[10:21:43.310]         if (!identical(...future.workdir, getwd())) 
[10:21:43.310]             setwd(...future.workdir)
[10:21:43.310]         {
[10:21:43.310]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.310]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.310]             }
[10:21:43.310]             base::options(...future.oldOptions)
[10:21:43.310]             if (.Platform$OS.type == "windows") {
[10:21:43.310]                 old_names <- names(...future.oldEnvVars)
[10:21:43.310]                 envs <- base::Sys.getenv()
[10:21:43.310]                 names <- names(envs)
[10:21:43.310]                 common <- intersect(names, old_names)
[10:21:43.310]                 added <- setdiff(names, old_names)
[10:21:43.310]                 removed <- setdiff(old_names, names)
[10:21:43.310]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.310]                   envs[common]]
[10:21:43.310]                 NAMES <- toupper(changed)
[10:21:43.310]                 args <- list()
[10:21:43.310]                 for (kk in seq_along(NAMES)) {
[10:21:43.310]                   name <- changed[[kk]]
[10:21:43.310]                   NAME <- NAMES[[kk]]
[10:21:43.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.310]                     next
[10:21:43.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.310]                 }
[10:21:43.310]                 NAMES <- toupper(added)
[10:21:43.310]                 for (kk in seq_along(NAMES)) {
[10:21:43.310]                   name <- added[[kk]]
[10:21:43.310]                   NAME <- NAMES[[kk]]
[10:21:43.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.310]                     next
[10:21:43.310]                   args[[name]] <- ""
[10:21:43.310]                 }
[10:21:43.310]                 NAMES <- toupper(removed)
[10:21:43.310]                 for (kk in seq_along(NAMES)) {
[10:21:43.310]                   name <- removed[[kk]]
[10:21:43.310]                   NAME <- NAMES[[kk]]
[10:21:43.310]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.310]                     next
[10:21:43.310]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.310]                 }
[10:21:43.310]                 if (length(args) > 0) 
[10:21:43.310]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.310]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.310]             }
[10:21:43.310]             else {
[10:21:43.310]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.310]             }
[10:21:43.310]             {
[10:21:43.310]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.310]                   0L) {
[10:21:43.310]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.310]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.310]                   base::options(opts)
[10:21:43.310]                 }
[10:21:43.310]                 {
[10:21:43.310]                   {
[10:21:43.310]                     NULL
[10:21:43.310]                     RNGkind("Mersenne-Twister")
[10:21:43.310]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.310]                       inherits = FALSE)
[10:21:43.310]                   }
[10:21:43.310]                   options(future.plan = NULL)
[10:21:43.310]                   if (is.na(NA_character_)) 
[10:21:43.310]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.310]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.310]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.310]                     .init = FALSE)
[10:21:43.310]                 }
[10:21:43.310]             }
[10:21:43.310]         }
[10:21:43.310]     })
[10:21:43.310]     if (TRUE) {
[10:21:43.310]         base::sink(type = "output", split = FALSE)
[10:21:43.310]         if (TRUE) {
[10:21:43.310]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.310]         }
[10:21:43.310]         else {
[10:21:43.310]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.310]         }
[10:21:43.310]         base::close(...future.stdout)
[10:21:43.310]         ...future.stdout <- NULL
[10:21:43.310]     }
[10:21:43.310]     ...future.result$conditions <- ...future.conditions
[10:21:43.310]     ...future.result$finished <- base::Sys.time()
[10:21:43.310]     ...future.result
[10:21:43.310] }
[10:21:43.311] assign_globals() ...
[10:21:43.311] List of 2
[10:21:43.311]  $ a : num 1
[10:21:43.311]  $ ii: int 3
[10:21:43.311]  - attr(*, "where")=List of 2
[10:21:43.311]   ..$ a :<environment: R_EmptyEnv> 
[10:21:43.311]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.311]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.311]  - attr(*, "resolved")= logi TRUE
[10:21:43.311]  - attr(*, "total_size")= num 74
[10:21:43.311]  - attr(*, "already-done")= logi TRUE
[10:21:43.314] - copied ‘a’ to environment
[10:21:43.314] - copied ‘ii’ to environment
[10:21:43.314] assign_globals() ... done
[10:21:43.315] plan(): Setting new future strategy stack:
[10:21:43.315] List of future strategies:
[10:21:43.315] 1. sequential:
[10:21:43.315]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.315]    - tweaked: FALSE
[10:21:43.315]    - call: NULL
[10:21:43.315] plan(): nbrOfWorkers() = 1
[10:21:43.316] plan(): Setting new future strategy stack:
[10:21:43.316] List of future strategies:
[10:21:43.316] 1. sequential:
[10:21:43.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.316]    - tweaked: FALSE
[10:21:43.316]    - call: plan(strategy)
[10:21:43.316] plan(): nbrOfWorkers() = 1
[10:21:43.317] SequentialFuture started (and completed)
[10:21:43.317] - Launch lazy future ... done
[10:21:43.317] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.318] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.318] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.319] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.320] Searching for globals ... DONE
[10:21:43.320] Resolving globals: TRUE
[10:21:43.320] Resolving any globals that are futures ...
[10:21:43.320] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.320] Resolving any globals that are futures ... DONE
[10:21:43.320] Resolving futures part of globals (recursively) ...
[10:21:43.320] resolve() on list ...
[10:21:43.321]  recursive: 99
[10:21:43.321]  length: 2
[10:21:43.321]  elements: ‘a’, ‘ii’
[10:21:43.321]  length: 1 (resolved future 1)
[10:21:43.321]  length: 0 (resolved future 2)
[10:21:43.321] resolve() on list ... DONE
[10:21:43.321] - globals: [2] ‘a’, ‘ii’
[10:21:43.321] Resolving futures part of globals (recursively) ... DONE
[10:21:43.321] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:43.322] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.322] - globals: [2] ‘a’, ‘ii’
[10:21:43.322] 
[10:21:43.322] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.322] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.323] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.324] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.324] Searching for globals ... DONE
[10:21:43.325] Resolving globals: TRUE
[10:21:43.325] Resolving any globals that are futures ...
[10:21:43.325] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.325] Resolving any globals that are futures ... DONE
[10:21:43.325] Resolving futures part of globals (recursively) ...
[10:21:43.325] resolve() on list ...
[10:21:43.325]  recursive: 99
[10:21:43.325]  length: 2
[10:21:43.326]  elements: ‘a’, ‘ii’
[10:21:43.326]  length: 1 (resolved future 1)
[10:21:43.326]  length: 0 (resolved future 2)
[10:21:43.326] resolve() on list ... DONE
[10:21:43.326] - globals: [2] ‘a’, ‘ii’
[10:21:43.326] Resolving futures part of globals (recursively) ... DONE
[10:21:43.326] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:43.327] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.327] - globals: [2] ‘a’, ‘ii’
[10:21:43.327] 
[10:21:43.327] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.327] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.328] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.329] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.329] Searching for globals ... DONE
[10:21:43.329] Resolving globals: TRUE
[10:21:43.330] Resolving any globals that are futures ...
[10:21:43.330] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:43.330] Resolving any globals that are futures ... DONE
[10:21:43.330] Resolving futures part of globals (recursively) ...
[10:21:43.330] resolve() on list ...
[10:21:43.330]  recursive: 99
[10:21:43.330]  length: 2
[10:21:43.330]  elements: ‘a’, ‘ii’
[10:21:43.331]  length: 1 (resolved future 1)
[10:21:43.331]  length: 0 (resolved future 2)
[10:21:43.331] resolve() on list ... DONE
[10:21:43.331] - globals: [2] ‘a’, ‘ii’
[10:21:43.332] Resolving futures part of globals (recursively) ... DONE
[10:21:43.332] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:43.333] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.333] - globals: [2] ‘a’, ‘ii’
[10:21:43.333] 
[10:21:43.333] getGlobalsAndPackages() ... DONE
[10:21:43.333] run() for ‘Future’ ...
[10:21:43.333] - state: ‘created’
[10:21:43.334] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.334] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.334] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.334]   - Field: ‘label’
[10:21:43.334]   - Field: ‘local’
[10:21:43.334]   - Field: ‘owner’
[10:21:43.334]   - Field: ‘envir’
[10:21:43.334]   - Field: ‘packages’
[10:21:43.334]   - Field: ‘gc’
[10:21:43.335]   - Field: ‘conditions’
[10:21:43.335]   - Field: ‘expr’
[10:21:43.335]   - Field: ‘uuid’
[10:21:43.335]   - Field: ‘seed’
[10:21:43.335]   - Field: ‘version’
[10:21:43.335]   - Field: ‘result’
[10:21:43.335]   - Field: ‘asynchronous’
[10:21:43.335]   - Field: ‘calls’
[10:21:43.335]   - Field: ‘globals’
[10:21:43.335]   - Field: ‘stdout’
[10:21:43.335]   - Field: ‘earlySignal’
[10:21:43.335]   - Field: ‘lazy’
[10:21:43.336]   - Field: ‘state’
[10:21:43.336] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.336] - Launch lazy future ...
[10:21:43.336] Packages needed by the future expression (n = 0): <none>
[10:21:43.336] Packages needed by future strategies (n = 0): <none>
[10:21:43.336] {
[10:21:43.336]     {
[10:21:43.336]         {
[10:21:43.336]             ...future.startTime <- base::Sys.time()
[10:21:43.336]             {
[10:21:43.336]                 {
[10:21:43.336]                   {
[10:21:43.336]                     base::local({
[10:21:43.336]                       has_future <- base::requireNamespace("future", 
[10:21:43.336]                         quietly = TRUE)
[10:21:43.336]                       if (has_future) {
[10:21:43.336]                         ns <- base::getNamespace("future")
[10:21:43.336]                         version <- ns[[".package"]][["version"]]
[10:21:43.336]                         if (is.null(version)) 
[10:21:43.336]                           version <- utils::packageVersion("future")
[10:21:43.336]                       }
[10:21:43.336]                       else {
[10:21:43.336]                         version <- NULL
[10:21:43.336]                       }
[10:21:43.336]                       if (!has_future || version < "1.8.0") {
[10:21:43.336]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.336]                           "", base::R.version$version.string), 
[10:21:43.336]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.336]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.336]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.336]                             "release", "version")], collapse = " "), 
[10:21:43.336]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.336]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.336]                           info)
[10:21:43.336]                         info <- base::paste(info, collapse = "; ")
[10:21:43.336]                         if (!has_future) {
[10:21:43.336]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.336]                             info)
[10:21:43.336]                         }
[10:21:43.336]                         else {
[10:21:43.336]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.336]                             info, version)
[10:21:43.336]                         }
[10:21:43.336]                         base::stop(msg)
[10:21:43.336]                       }
[10:21:43.336]                     })
[10:21:43.336]                   }
[10:21:43.336]                   ...future.strategy.old <- future::plan("list")
[10:21:43.336]                   options(future.plan = NULL)
[10:21:43.336]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.336]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.336]                 }
[10:21:43.336]                 ...future.workdir <- getwd()
[10:21:43.336]             }
[10:21:43.336]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.336]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.336]         }
[10:21:43.336]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.336]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.336]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.336]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.336]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.336]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.336]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.336]             base::names(...future.oldOptions))
[10:21:43.336]     }
[10:21:43.336]     if (FALSE) {
[10:21:43.336]     }
[10:21:43.336]     else {
[10:21:43.336]         if (TRUE) {
[10:21:43.336]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.336]                 open = "w")
[10:21:43.336]         }
[10:21:43.336]         else {
[10:21:43.336]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.336]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.336]         }
[10:21:43.336]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.336]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.336]             base::sink(type = "output", split = FALSE)
[10:21:43.336]             base::close(...future.stdout)
[10:21:43.336]         }, add = TRUE)
[10:21:43.336]     }
[10:21:43.336]     ...future.frame <- base::sys.nframe()
[10:21:43.336]     ...future.conditions <- base::list()
[10:21:43.336]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.336]     if (FALSE) {
[10:21:43.336]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.336]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.336]     }
[10:21:43.336]     ...future.result <- base::tryCatch({
[10:21:43.336]         base::withCallingHandlers({
[10:21:43.336]             ...future.value <- base::withVisible(base::local({
[10:21:43.336]                 b <- a * ii
[10:21:43.336]                 a <- 0
[10:21:43.336]                 b
[10:21:43.336]             }))
[10:21:43.336]             future::FutureResult(value = ...future.value$value, 
[10:21:43.336]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.336]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.336]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.336]                     ...future.globalenv.names))
[10:21:43.336]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.336]         }, condition = base::local({
[10:21:43.336]             c <- base::c
[10:21:43.336]             inherits <- base::inherits
[10:21:43.336]             invokeRestart <- base::invokeRestart
[10:21:43.336]             length <- base::length
[10:21:43.336]             list <- base::list
[10:21:43.336]             seq.int <- base::seq.int
[10:21:43.336]             signalCondition <- base::signalCondition
[10:21:43.336]             sys.calls <- base::sys.calls
[10:21:43.336]             `[[` <- base::`[[`
[10:21:43.336]             `+` <- base::`+`
[10:21:43.336]             `<<-` <- base::`<<-`
[10:21:43.336]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.336]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.336]                   3L)]
[10:21:43.336]             }
[10:21:43.336]             function(cond) {
[10:21:43.336]                 is_error <- inherits(cond, "error")
[10:21:43.336]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.336]                   NULL)
[10:21:43.336]                 if (is_error) {
[10:21:43.336]                   sessionInformation <- function() {
[10:21:43.336]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.336]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.336]                       search = base::search(), system = base::Sys.info())
[10:21:43.336]                   }
[10:21:43.336]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.336]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.336]                     cond$call), session = sessionInformation(), 
[10:21:43.336]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.336]                   signalCondition(cond)
[10:21:43.336]                 }
[10:21:43.336]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.336]                 "immediateCondition"))) {
[10:21:43.336]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.336]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.336]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.336]                   if (TRUE && !signal) {
[10:21:43.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.336]                     {
[10:21:43.336]                       inherits <- base::inherits
[10:21:43.336]                       invokeRestart <- base::invokeRestart
[10:21:43.336]                       is.null <- base::is.null
[10:21:43.336]                       muffled <- FALSE
[10:21:43.336]                       if (inherits(cond, "message")) {
[10:21:43.336]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.336]                         if (muffled) 
[10:21:43.336]                           invokeRestart("muffleMessage")
[10:21:43.336]                       }
[10:21:43.336]                       else if (inherits(cond, "warning")) {
[10:21:43.336]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.336]                         if (muffled) 
[10:21:43.336]                           invokeRestart("muffleWarning")
[10:21:43.336]                       }
[10:21:43.336]                       else if (inherits(cond, "condition")) {
[10:21:43.336]                         if (!is.null(pattern)) {
[10:21:43.336]                           computeRestarts <- base::computeRestarts
[10:21:43.336]                           grepl <- base::grepl
[10:21:43.336]                           restarts <- computeRestarts(cond)
[10:21:43.336]                           for (restart in restarts) {
[10:21:43.336]                             name <- restart$name
[10:21:43.336]                             if (is.null(name)) 
[10:21:43.336]                               next
[10:21:43.336]                             if (!grepl(pattern, name)) 
[10:21:43.336]                               next
[10:21:43.336]                             invokeRestart(restart)
[10:21:43.336]                             muffled <- TRUE
[10:21:43.336]                             break
[10:21:43.336]                           }
[10:21:43.336]                         }
[10:21:43.336]                       }
[10:21:43.336]                       invisible(muffled)
[10:21:43.336]                     }
[10:21:43.336]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.336]                   }
[10:21:43.336]                 }
[10:21:43.336]                 else {
[10:21:43.336]                   if (TRUE) {
[10:21:43.336]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.336]                     {
[10:21:43.336]                       inherits <- base::inherits
[10:21:43.336]                       invokeRestart <- base::invokeRestart
[10:21:43.336]                       is.null <- base::is.null
[10:21:43.336]                       muffled <- FALSE
[10:21:43.336]                       if (inherits(cond, "message")) {
[10:21:43.336]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.336]                         if (muffled) 
[10:21:43.336]                           invokeRestart("muffleMessage")
[10:21:43.336]                       }
[10:21:43.336]                       else if (inherits(cond, "warning")) {
[10:21:43.336]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.336]                         if (muffled) 
[10:21:43.336]                           invokeRestart("muffleWarning")
[10:21:43.336]                       }
[10:21:43.336]                       else if (inherits(cond, "condition")) {
[10:21:43.336]                         if (!is.null(pattern)) {
[10:21:43.336]                           computeRestarts <- base::computeRestarts
[10:21:43.336]                           grepl <- base::grepl
[10:21:43.336]                           restarts <- computeRestarts(cond)
[10:21:43.336]                           for (restart in restarts) {
[10:21:43.336]                             name <- restart$name
[10:21:43.336]                             if (is.null(name)) 
[10:21:43.336]                               next
[10:21:43.336]                             if (!grepl(pattern, name)) 
[10:21:43.336]                               next
[10:21:43.336]                             invokeRestart(restart)
[10:21:43.336]                             muffled <- TRUE
[10:21:43.336]                             break
[10:21:43.336]                           }
[10:21:43.336]                         }
[10:21:43.336]                       }
[10:21:43.336]                       invisible(muffled)
[10:21:43.336]                     }
[10:21:43.336]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.336]                   }
[10:21:43.336]                 }
[10:21:43.336]             }
[10:21:43.336]         }))
[10:21:43.336]     }, error = function(ex) {
[10:21:43.336]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.336]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.336]                 ...future.rng), started = ...future.startTime, 
[10:21:43.336]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.336]             version = "1.8"), class = "FutureResult")
[10:21:43.336]     }, finally = {
[10:21:43.336]         if (!identical(...future.workdir, getwd())) 
[10:21:43.336]             setwd(...future.workdir)
[10:21:43.336]         {
[10:21:43.336]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.336]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.336]             }
[10:21:43.336]             base::options(...future.oldOptions)
[10:21:43.336]             if (.Platform$OS.type == "windows") {
[10:21:43.336]                 old_names <- names(...future.oldEnvVars)
[10:21:43.336]                 envs <- base::Sys.getenv()
[10:21:43.336]                 names <- names(envs)
[10:21:43.336]                 common <- intersect(names, old_names)
[10:21:43.336]                 added <- setdiff(names, old_names)
[10:21:43.336]                 removed <- setdiff(old_names, names)
[10:21:43.336]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.336]                   envs[common]]
[10:21:43.336]                 NAMES <- toupper(changed)
[10:21:43.336]                 args <- list()
[10:21:43.336]                 for (kk in seq_along(NAMES)) {
[10:21:43.336]                   name <- changed[[kk]]
[10:21:43.336]                   NAME <- NAMES[[kk]]
[10:21:43.336]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.336]                     next
[10:21:43.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.336]                 }
[10:21:43.336]                 NAMES <- toupper(added)
[10:21:43.336]                 for (kk in seq_along(NAMES)) {
[10:21:43.336]                   name <- added[[kk]]
[10:21:43.336]                   NAME <- NAMES[[kk]]
[10:21:43.336]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.336]                     next
[10:21:43.336]                   args[[name]] <- ""
[10:21:43.336]                 }
[10:21:43.336]                 NAMES <- toupper(removed)
[10:21:43.336]                 for (kk in seq_along(NAMES)) {
[10:21:43.336]                   name <- removed[[kk]]
[10:21:43.336]                   NAME <- NAMES[[kk]]
[10:21:43.336]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.336]                     next
[10:21:43.336]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.336]                 }
[10:21:43.336]                 if (length(args) > 0) 
[10:21:43.336]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.336]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.336]             }
[10:21:43.336]             else {
[10:21:43.336]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.336]             }
[10:21:43.336]             {
[10:21:43.336]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.336]                   0L) {
[10:21:43.336]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.336]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.336]                   base::options(opts)
[10:21:43.336]                 }
[10:21:43.336]                 {
[10:21:43.336]                   {
[10:21:43.336]                     NULL
[10:21:43.336]                     RNGkind("Mersenne-Twister")
[10:21:43.336]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.336]                       inherits = FALSE)
[10:21:43.336]                   }
[10:21:43.336]                   options(future.plan = NULL)
[10:21:43.336]                   if (is.na(NA_character_)) 
[10:21:43.336]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.336]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.336]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.336]                     .init = FALSE)
[10:21:43.336]                 }
[10:21:43.336]             }
[10:21:43.336]         }
[10:21:43.336]     })
[10:21:43.336]     if (TRUE) {
[10:21:43.336]         base::sink(type = "output", split = FALSE)
[10:21:43.336]         if (TRUE) {
[10:21:43.336]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.336]         }
[10:21:43.336]         else {
[10:21:43.336]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.336]         }
[10:21:43.336]         base::close(...future.stdout)
[10:21:43.336]         ...future.stdout <- NULL
[10:21:43.336]     }
[10:21:43.336]     ...future.result$conditions <- ...future.conditions
[10:21:43.336]     ...future.result$finished <- base::Sys.time()
[10:21:43.336]     ...future.result
[10:21:43.336] }
[10:21:43.338] assign_globals() ...
[10:21:43.338] List of 2
[10:21:43.338]  $ a : num 1
[10:21:43.338]  $ ii: int 1
[10:21:43.338]  - attr(*, "where")=List of 2
[10:21:43.338]   ..$ a :<environment: R_EmptyEnv> 
[10:21:43.338]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.338]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.338]  - attr(*, "resolved")= logi TRUE
[10:21:43.338]  - attr(*, "total_size")= num 74
[10:21:43.338]  - attr(*, "already-done")= logi TRUE
[10:21:43.341] - copied ‘a’ to environment
[10:21:43.341] - copied ‘ii’ to environment
[10:21:43.341] assign_globals() ... done
[10:21:43.341] plan(): Setting new future strategy stack:
[10:21:43.341] List of future strategies:
[10:21:43.341] 1. sequential:
[10:21:43.341]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.341]    - tweaked: FALSE
[10:21:43.341]    - call: NULL
[10:21:43.342] plan(): nbrOfWorkers() = 1
[10:21:43.342] plan(): Setting new future strategy stack:
[10:21:43.343] List of future strategies:
[10:21:43.343] 1. sequential:
[10:21:43.343]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.343]    - tweaked: FALSE
[10:21:43.343]    - call: plan(strategy)
[10:21:43.343] plan(): nbrOfWorkers() = 1
[10:21:43.343] SequentialFuture started (and completed)
[10:21:43.343] - Launch lazy future ... done
[10:21:43.343] run() for ‘SequentialFuture’ ... done
[10:21:43.343] run() for ‘Future’ ...
[10:21:43.344] - state: ‘created’
[10:21:43.344] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.344] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.344] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.344]   - Field: ‘label’
[10:21:43.344]   - Field: ‘local’
[10:21:43.344]   - Field: ‘owner’
[10:21:43.344]   - Field: ‘envir’
[10:21:43.345]   - Field: ‘packages’
[10:21:43.345]   - Field: ‘gc’
[10:21:43.345]   - Field: ‘conditions’
[10:21:43.345]   - Field: ‘expr’
[10:21:43.345]   - Field: ‘uuid’
[10:21:43.345]   - Field: ‘seed’
[10:21:43.345]   - Field: ‘version’
[10:21:43.345]   - Field: ‘result’
[10:21:43.345]   - Field: ‘asynchronous’
[10:21:43.345]   - Field: ‘calls’
[10:21:43.345]   - Field: ‘globals’
[10:21:43.345]   - Field: ‘stdout’
[10:21:43.345]   - Field: ‘earlySignal’
[10:21:43.346]   - Field: ‘lazy’
[10:21:43.346]   - Field: ‘state’
[10:21:43.346] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.346] - Launch lazy future ...
[10:21:43.346] Packages needed by the future expression (n = 0): <none>
[10:21:43.346] Packages needed by future strategies (n = 0): <none>
[10:21:43.346] {
[10:21:43.346]     {
[10:21:43.346]         {
[10:21:43.346]             ...future.startTime <- base::Sys.time()
[10:21:43.346]             {
[10:21:43.346]                 {
[10:21:43.346]                   {
[10:21:43.346]                     base::local({
[10:21:43.346]                       has_future <- base::requireNamespace("future", 
[10:21:43.346]                         quietly = TRUE)
[10:21:43.346]                       if (has_future) {
[10:21:43.346]                         ns <- base::getNamespace("future")
[10:21:43.346]                         version <- ns[[".package"]][["version"]]
[10:21:43.346]                         if (is.null(version)) 
[10:21:43.346]                           version <- utils::packageVersion("future")
[10:21:43.346]                       }
[10:21:43.346]                       else {
[10:21:43.346]                         version <- NULL
[10:21:43.346]                       }
[10:21:43.346]                       if (!has_future || version < "1.8.0") {
[10:21:43.346]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.346]                           "", base::R.version$version.string), 
[10:21:43.346]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.346]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.346]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.346]                             "release", "version")], collapse = " "), 
[10:21:43.346]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.346]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.346]                           info)
[10:21:43.346]                         info <- base::paste(info, collapse = "; ")
[10:21:43.346]                         if (!has_future) {
[10:21:43.346]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.346]                             info)
[10:21:43.346]                         }
[10:21:43.346]                         else {
[10:21:43.346]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.346]                             info, version)
[10:21:43.346]                         }
[10:21:43.346]                         base::stop(msg)
[10:21:43.346]                       }
[10:21:43.346]                     })
[10:21:43.346]                   }
[10:21:43.346]                   ...future.strategy.old <- future::plan("list")
[10:21:43.346]                   options(future.plan = NULL)
[10:21:43.346]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.346]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.346]                 }
[10:21:43.346]                 ...future.workdir <- getwd()
[10:21:43.346]             }
[10:21:43.346]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.346]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.346]         }
[10:21:43.346]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.346]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.346]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.346]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.346]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.346]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.346]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.346]             base::names(...future.oldOptions))
[10:21:43.346]     }
[10:21:43.346]     if (FALSE) {
[10:21:43.346]     }
[10:21:43.346]     else {
[10:21:43.346]         if (TRUE) {
[10:21:43.346]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.346]                 open = "w")
[10:21:43.346]         }
[10:21:43.346]         else {
[10:21:43.346]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.346]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.346]         }
[10:21:43.346]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.346]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.346]             base::sink(type = "output", split = FALSE)
[10:21:43.346]             base::close(...future.stdout)
[10:21:43.346]         }, add = TRUE)
[10:21:43.346]     }
[10:21:43.346]     ...future.frame <- base::sys.nframe()
[10:21:43.346]     ...future.conditions <- base::list()
[10:21:43.346]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.346]     if (FALSE) {
[10:21:43.346]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.346]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.346]     }
[10:21:43.346]     ...future.result <- base::tryCatch({
[10:21:43.346]         base::withCallingHandlers({
[10:21:43.346]             ...future.value <- base::withVisible(base::local({
[10:21:43.346]                 b <- a * ii
[10:21:43.346]                 a <- 0
[10:21:43.346]                 b
[10:21:43.346]             }))
[10:21:43.346]             future::FutureResult(value = ...future.value$value, 
[10:21:43.346]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.346]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.346]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.346]                     ...future.globalenv.names))
[10:21:43.346]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.346]         }, condition = base::local({
[10:21:43.346]             c <- base::c
[10:21:43.346]             inherits <- base::inherits
[10:21:43.346]             invokeRestart <- base::invokeRestart
[10:21:43.346]             length <- base::length
[10:21:43.346]             list <- base::list
[10:21:43.346]             seq.int <- base::seq.int
[10:21:43.346]             signalCondition <- base::signalCondition
[10:21:43.346]             sys.calls <- base::sys.calls
[10:21:43.346]             `[[` <- base::`[[`
[10:21:43.346]             `+` <- base::`+`
[10:21:43.346]             `<<-` <- base::`<<-`
[10:21:43.346]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.346]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.346]                   3L)]
[10:21:43.346]             }
[10:21:43.346]             function(cond) {
[10:21:43.346]                 is_error <- inherits(cond, "error")
[10:21:43.346]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.346]                   NULL)
[10:21:43.346]                 if (is_error) {
[10:21:43.346]                   sessionInformation <- function() {
[10:21:43.346]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.346]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.346]                       search = base::search(), system = base::Sys.info())
[10:21:43.346]                   }
[10:21:43.346]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.346]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.346]                     cond$call), session = sessionInformation(), 
[10:21:43.346]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.346]                   signalCondition(cond)
[10:21:43.346]                 }
[10:21:43.346]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.346]                 "immediateCondition"))) {
[10:21:43.346]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.346]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.346]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.346]                   if (TRUE && !signal) {
[10:21:43.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.346]                     {
[10:21:43.346]                       inherits <- base::inherits
[10:21:43.346]                       invokeRestart <- base::invokeRestart
[10:21:43.346]                       is.null <- base::is.null
[10:21:43.346]                       muffled <- FALSE
[10:21:43.346]                       if (inherits(cond, "message")) {
[10:21:43.346]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.346]                         if (muffled) 
[10:21:43.346]                           invokeRestart("muffleMessage")
[10:21:43.346]                       }
[10:21:43.346]                       else if (inherits(cond, "warning")) {
[10:21:43.346]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.346]                         if (muffled) 
[10:21:43.346]                           invokeRestart("muffleWarning")
[10:21:43.346]                       }
[10:21:43.346]                       else if (inherits(cond, "condition")) {
[10:21:43.346]                         if (!is.null(pattern)) {
[10:21:43.346]                           computeRestarts <- base::computeRestarts
[10:21:43.346]                           grepl <- base::grepl
[10:21:43.346]                           restarts <- computeRestarts(cond)
[10:21:43.346]                           for (restart in restarts) {
[10:21:43.346]                             name <- restart$name
[10:21:43.346]                             if (is.null(name)) 
[10:21:43.346]                               next
[10:21:43.346]                             if (!grepl(pattern, name)) 
[10:21:43.346]                               next
[10:21:43.346]                             invokeRestart(restart)
[10:21:43.346]                             muffled <- TRUE
[10:21:43.346]                             break
[10:21:43.346]                           }
[10:21:43.346]                         }
[10:21:43.346]                       }
[10:21:43.346]                       invisible(muffled)
[10:21:43.346]                     }
[10:21:43.346]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.346]                   }
[10:21:43.346]                 }
[10:21:43.346]                 else {
[10:21:43.346]                   if (TRUE) {
[10:21:43.346]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.346]                     {
[10:21:43.346]                       inherits <- base::inherits
[10:21:43.346]                       invokeRestart <- base::invokeRestart
[10:21:43.346]                       is.null <- base::is.null
[10:21:43.346]                       muffled <- FALSE
[10:21:43.346]                       if (inherits(cond, "message")) {
[10:21:43.346]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.346]                         if (muffled) 
[10:21:43.346]                           invokeRestart("muffleMessage")
[10:21:43.346]                       }
[10:21:43.346]                       else if (inherits(cond, "warning")) {
[10:21:43.346]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.346]                         if (muffled) 
[10:21:43.346]                           invokeRestart("muffleWarning")
[10:21:43.346]                       }
[10:21:43.346]                       else if (inherits(cond, "condition")) {
[10:21:43.346]                         if (!is.null(pattern)) {
[10:21:43.346]                           computeRestarts <- base::computeRestarts
[10:21:43.346]                           grepl <- base::grepl
[10:21:43.346]                           restarts <- computeRestarts(cond)
[10:21:43.346]                           for (restart in restarts) {
[10:21:43.346]                             name <- restart$name
[10:21:43.346]                             if (is.null(name)) 
[10:21:43.346]                               next
[10:21:43.346]                             if (!grepl(pattern, name)) 
[10:21:43.346]                               next
[10:21:43.346]                             invokeRestart(restart)
[10:21:43.346]                             muffled <- TRUE
[10:21:43.346]                             break
[10:21:43.346]                           }
[10:21:43.346]                         }
[10:21:43.346]                       }
[10:21:43.346]                       invisible(muffled)
[10:21:43.346]                     }
[10:21:43.346]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.346]                   }
[10:21:43.346]                 }
[10:21:43.346]             }
[10:21:43.346]         }))
[10:21:43.346]     }, error = function(ex) {
[10:21:43.346]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.346]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.346]                 ...future.rng), started = ...future.startTime, 
[10:21:43.346]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.346]             version = "1.8"), class = "FutureResult")
[10:21:43.346]     }, finally = {
[10:21:43.346]         if (!identical(...future.workdir, getwd())) 
[10:21:43.346]             setwd(...future.workdir)
[10:21:43.346]         {
[10:21:43.346]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.346]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.346]             }
[10:21:43.346]             base::options(...future.oldOptions)
[10:21:43.346]             if (.Platform$OS.type == "windows") {
[10:21:43.346]                 old_names <- names(...future.oldEnvVars)
[10:21:43.346]                 envs <- base::Sys.getenv()
[10:21:43.346]                 names <- names(envs)
[10:21:43.346]                 common <- intersect(names, old_names)
[10:21:43.346]                 added <- setdiff(names, old_names)
[10:21:43.346]                 removed <- setdiff(old_names, names)
[10:21:43.346]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.346]                   envs[common]]
[10:21:43.346]                 NAMES <- toupper(changed)
[10:21:43.346]                 args <- list()
[10:21:43.346]                 for (kk in seq_along(NAMES)) {
[10:21:43.346]                   name <- changed[[kk]]
[10:21:43.346]                   NAME <- NAMES[[kk]]
[10:21:43.346]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.346]                     next
[10:21:43.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.346]                 }
[10:21:43.346]                 NAMES <- toupper(added)
[10:21:43.346]                 for (kk in seq_along(NAMES)) {
[10:21:43.346]                   name <- added[[kk]]
[10:21:43.346]                   NAME <- NAMES[[kk]]
[10:21:43.346]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.346]                     next
[10:21:43.346]                   args[[name]] <- ""
[10:21:43.346]                 }
[10:21:43.346]                 NAMES <- toupper(removed)
[10:21:43.346]                 for (kk in seq_along(NAMES)) {
[10:21:43.346]                   name <- removed[[kk]]
[10:21:43.346]                   NAME <- NAMES[[kk]]
[10:21:43.346]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.346]                     next
[10:21:43.346]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.346]                 }
[10:21:43.346]                 if (length(args) > 0) 
[10:21:43.346]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.346]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.346]             }
[10:21:43.346]             else {
[10:21:43.346]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.346]             }
[10:21:43.346]             {
[10:21:43.346]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.346]                   0L) {
[10:21:43.346]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.346]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.346]                   base::options(opts)
[10:21:43.346]                 }
[10:21:43.346]                 {
[10:21:43.346]                   {
[10:21:43.346]                     NULL
[10:21:43.346]                     RNGkind("Mersenne-Twister")
[10:21:43.346]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.346]                       inherits = FALSE)
[10:21:43.346]                   }
[10:21:43.346]                   options(future.plan = NULL)
[10:21:43.346]                   if (is.na(NA_character_)) 
[10:21:43.346]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.346]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.346]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.346]                     .init = FALSE)
[10:21:43.346]                 }
[10:21:43.346]             }
[10:21:43.346]         }
[10:21:43.346]     })
[10:21:43.346]     if (TRUE) {
[10:21:43.346]         base::sink(type = "output", split = FALSE)
[10:21:43.346]         if (TRUE) {
[10:21:43.346]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.346]         }
[10:21:43.346]         else {
[10:21:43.346]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.346]         }
[10:21:43.346]         base::close(...future.stdout)
[10:21:43.346]         ...future.stdout <- NULL
[10:21:43.346]     }
[10:21:43.346]     ...future.result$conditions <- ...future.conditions
[10:21:43.346]     ...future.result$finished <- base::Sys.time()
[10:21:43.346]     ...future.result
[10:21:43.346] }
[10:21:43.348] assign_globals() ...
[10:21:43.348] List of 2
[10:21:43.348]  $ a : num 1
[10:21:43.348]  $ ii: int 2
[10:21:43.348]  - attr(*, "where")=List of 2
[10:21:43.348]   ..$ a :<environment: R_EmptyEnv> 
[10:21:43.348]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.348]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.348]  - attr(*, "resolved")= logi TRUE
[10:21:43.348]  - attr(*, "total_size")= num 74
[10:21:43.348]  - attr(*, "already-done")= logi TRUE
[10:21:43.351] - copied ‘a’ to environment
[10:21:43.351] - copied ‘ii’ to environment
[10:21:43.351] assign_globals() ... done
[10:21:43.351] plan(): Setting new future strategy stack:
[10:21:43.351] List of future strategies:
[10:21:43.351] 1. sequential:
[10:21:43.351]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.351]    - tweaked: FALSE
[10:21:43.351]    - call: NULL
[10:21:43.352] plan(): nbrOfWorkers() = 1
[10:21:43.353] plan(): Setting new future strategy stack:
[10:21:43.353] List of future strategies:
[10:21:43.353] 1. sequential:
[10:21:43.353]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.353]    - tweaked: FALSE
[10:21:43.353]    - call: plan(strategy)
[10:21:43.353] plan(): nbrOfWorkers() = 1
[10:21:43.353] SequentialFuture started (and completed)
[10:21:43.353] - Launch lazy future ... done
[10:21:43.353] run() for ‘SequentialFuture’ ... done
[10:21:43.354] run() for ‘Future’ ...
[10:21:43.354] - state: ‘created’
[10:21:43.354] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.354] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.354] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.354]   - Field: ‘label’
[10:21:43.354]   - Field: ‘local’
[10:21:43.354]   - Field: ‘owner’
[10:21:43.354]   - Field: ‘envir’
[10:21:43.355]   - Field: ‘packages’
[10:21:43.355]   - Field: ‘gc’
[10:21:43.355]   - Field: ‘conditions’
[10:21:43.355]   - Field: ‘expr’
[10:21:43.355]   - Field: ‘uuid’
[10:21:43.355]   - Field: ‘seed’
[10:21:43.355]   - Field: ‘version’
[10:21:43.355]   - Field: ‘result’
[10:21:43.355]   - Field: ‘asynchronous’
[10:21:43.355]   - Field: ‘calls’
[10:21:43.355]   - Field: ‘globals’
[10:21:43.355]   - Field: ‘stdout’
[10:21:43.356]   - Field: ‘earlySignal’
[10:21:43.356]   - Field: ‘lazy’
[10:21:43.357]   - Field: ‘state’
[10:21:43.357] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.357] - Launch lazy future ...
[10:21:43.357] Packages needed by the future expression (n = 0): <none>
[10:21:43.358] Packages needed by future strategies (n = 0): <none>
[10:21:43.358] {
[10:21:43.358]     {
[10:21:43.358]         {
[10:21:43.358]             ...future.startTime <- base::Sys.time()
[10:21:43.358]             {
[10:21:43.358]                 {
[10:21:43.358]                   {
[10:21:43.358]                     base::local({
[10:21:43.358]                       has_future <- base::requireNamespace("future", 
[10:21:43.358]                         quietly = TRUE)
[10:21:43.358]                       if (has_future) {
[10:21:43.358]                         ns <- base::getNamespace("future")
[10:21:43.358]                         version <- ns[[".package"]][["version"]]
[10:21:43.358]                         if (is.null(version)) 
[10:21:43.358]                           version <- utils::packageVersion("future")
[10:21:43.358]                       }
[10:21:43.358]                       else {
[10:21:43.358]                         version <- NULL
[10:21:43.358]                       }
[10:21:43.358]                       if (!has_future || version < "1.8.0") {
[10:21:43.358]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.358]                           "", base::R.version$version.string), 
[10:21:43.358]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.358]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.358]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.358]                             "release", "version")], collapse = " "), 
[10:21:43.358]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.358]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.358]                           info)
[10:21:43.358]                         info <- base::paste(info, collapse = "; ")
[10:21:43.358]                         if (!has_future) {
[10:21:43.358]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.358]                             info)
[10:21:43.358]                         }
[10:21:43.358]                         else {
[10:21:43.358]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.358]                             info, version)
[10:21:43.358]                         }
[10:21:43.358]                         base::stop(msg)
[10:21:43.358]                       }
[10:21:43.358]                     })
[10:21:43.358]                   }
[10:21:43.358]                   ...future.strategy.old <- future::plan("list")
[10:21:43.358]                   options(future.plan = NULL)
[10:21:43.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.358]                 }
[10:21:43.358]                 ...future.workdir <- getwd()
[10:21:43.358]             }
[10:21:43.358]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.358]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.358]         }
[10:21:43.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.358]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.358]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.358]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.358]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.358]             base::names(...future.oldOptions))
[10:21:43.358]     }
[10:21:43.358]     if (FALSE) {
[10:21:43.358]     }
[10:21:43.358]     else {
[10:21:43.358]         if (TRUE) {
[10:21:43.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.358]                 open = "w")
[10:21:43.358]         }
[10:21:43.358]         else {
[10:21:43.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.358]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.358]         }
[10:21:43.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.358]             base::sink(type = "output", split = FALSE)
[10:21:43.358]             base::close(...future.stdout)
[10:21:43.358]         }, add = TRUE)
[10:21:43.358]     }
[10:21:43.358]     ...future.frame <- base::sys.nframe()
[10:21:43.358]     ...future.conditions <- base::list()
[10:21:43.358]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.358]     if (FALSE) {
[10:21:43.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.358]     }
[10:21:43.358]     ...future.result <- base::tryCatch({
[10:21:43.358]         base::withCallingHandlers({
[10:21:43.358]             ...future.value <- base::withVisible(base::local({
[10:21:43.358]                 b <- a * ii
[10:21:43.358]                 a <- 0
[10:21:43.358]                 b
[10:21:43.358]             }))
[10:21:43.358]             future::FutureResult(value = ...future.value$value, 
[10:21:43.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.358]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.358]                     ...future.globalenv.names))
[10:21:43.358]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.358]         }, condition = base::local({
[10:21:43.358]             c <- base::c
[10:21:43.358]             inherits <- base::inherits
[10:21:43.358]             invokeRestart <- base::invokeRestart
[10:21:43.358]             length <- base::length
[10:21:43.358]             list <- base::list
[10:21:43.358]             seq.int <- base::seq.int
[10:21:43.358]             signalCondition <- base::signalCondition
[10:21:43.358]             sys.calls <- base::sys.calls
[10:21:43.358]             `[[` <- base::`[[`
[10:21:43.358]             `+` <- base::`+`
[10:21:43.358]             `<<-` <- base::`<<-`
[10:21:43.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.358]                   3L)]
[10:21:43.358]             }
[10:21:43.358]             function(cond) {
[10:21:43.358]                 is_error <- inherits(cond, "error")
[10:21:43.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.358]                   NULL)
[10:21:43.358]                 if (is_error) {
[10:21:43.358]                   sessionInformation <- function() {
[10:21:43.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.358]                       search = base::search(), system = base::Sys.info())
[10:21:43.358]                   }
[10:21:43.358]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.358]                     cond$call), session = sessionInformation(), 
[10:21:43.358]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.358]                   signalCondition(cond)
[10:21:43.358]                 }
[10:21:43.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.358]                 "immediateCondition"))) {
[10:21:43.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.358]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.358]                   if (TRUE && !signal) {
[10:21:43.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.358]                     {
[10:21:43.358]                       inherits <- base::inherits
[10:21:43.358]                       invokeRestart <- base::invokeRestart
[10:21:43.358]                       is.null <- base::is.null
[10:21:43.358]                       muffled <- FALSE
[10:21:43.358]                       if (inherits(cond, "message")) {
[10:21:43.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.358]                         if (muffled) 
[10:21:43.358]                           invokeRestart("muffleMessage")
[10:21:43.358]                       }
[10:21:43.358]                       else if (inherits(cond, "warning")) {
[10:21:43.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.358]                         if (muffled) 
[10:21:43.358]                           invokeRestart("muffleWarning")
[10:21:43.358]                       }
[10:21:43.358]                       else if (inherits(cond, "condition")) {
[10:21:43.358]                         if (!is.null(pattern)) {
[10:21:43.358]                           computeRestarts <- base::computeRestarts
[10:21:43.358]                           grepl <- base::grepl
[10:21:43.358]                           restarts <- computeRestarts(cond)
[10:21:43.358]                           for (restart in restarts) {
[10:21:43.358]                             name <- restart$name
[10:21:43.358]                             if (is.null(name)) 
[10:21:43.358]                               next
[10:21:43.358]                             if (!grepl(pattern, name)) 
[10:21:43.358]                               next
[10:21:43.358]                             invokeRestart(restart)
[10:21:43.358]                             muffled <- TRUE
[10:21:43.358]                             break
[10:21:43.358]                           }
[10:21:43.358]                         }
[10:21:43.358]                       }
[10:21:43.358]                       invisible(muffled)
[10:21:43.358]                     }
[10:21:43.358]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.358]                   }
[10:21:43.358]                 }
[10:21:43.358]                 else {
[10:21:43.358]                   if (TRUE) {
[10:21:43.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.358]                     {
[10:21:43.358]                       inherits <- base::inherits
[10:21:43.358]                       invokeRestart <- base::invokeRestart
[10:21:43.358]                       is.null <- base::is.null
[10:21:43.358]                       muffled <- FALSE
[10:21:43.358]                       if (inherits(cond, "message")) {
[10:21:43.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.358]                         if (muffled) 
[10:21:43.358]                           invokeRestart("muffleMessage")
[10:21:43.358]                       }
[10:21:43.358]                       else if (inherits(cond, "warning")) {
[10:21:43.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.358]                         if (muffled) 
[10:21:43.358]                           invokeRestart("muffleWarning")
[10:21:43.358]                       }
[10:21:43.358]                       else if (inherits(cond, "condition")) {
[10:21:43.358]                         if (!is.null(pattern)) {
[10:21:43.358]                           computeRestarts <- base::computeRestarts
[10:21:43.358]                           grepl <- base::grepl
[10:21:43.358]                           restarts <- computeRestarts(cond)
[10:21:43.358]                           for (restart in restarts) {
[10:21:43.358]                             name <- restart$name
[10:21:43.358]                             if (is.null(name)) 
[10:21:43.358]                               next
[10:21:43.358]                             if (!grepl(pattern, name)) 
[10:21:43.358]                               next
[10:21:43.358]                             invokeRestart(restart)
[10:21:43.358]                             muffled <- TRUE
[10:21:43.358]                             break
[10:21:43.358]                           }
[10:21:43.358]                         }
[10:21:43.358]                       }
[10:21:43.358]                       invisible(muffled)
[10:21:43.358]                     }
[10:21:43.358]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.358]                   }
[10:21:43.358]                 }
[10:21:43.358]             }
[10:21:43.358]         }))
[10:21:43.358]     }, error = function(ex) {
[10:21:43.358]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.358]                 ...future.rng), started = ...future.startTime, 
[10:21:43.358]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.358]             version = "1.8"), class = "FutureResult")
[10:21:43.358]     }, finally = {
[10:21:43.358]         if (!identical(...future.workdir, getwd())) 
[10:21:43.358]             setwd(...future.workdir)
[10:21:43.358]         {
[10:21:43.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.358]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.358]             }
[10:21:43.358]             base::options(...future.oldOptions)
[10:21:43.358]             if (.Platform$OS.type == "windows") {
[10:21:43.358]                 old_names <- names(...future.oldEnvVars)
[10:21:43.358]                 envs <- base::Sys.getenv()
[10:21:43.358]                 names <- names(envs)
[10:21:43.358]                 common <- intersect(names, old_names)
[10:21:43.358]                 added <- setdiff(names, old_names)
[10:21:43.358]                 removed <- setdiff(old_names, names)
[10:21:43.358]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.358]                   envs[common]]
[10:21:43.358]                 NAMES <- toupper(changed)
[10:21:43.358]                 args <- list()
[10:21:43.358]                 for (kk in seq_along(NAMES)) {
[10:21:43.358]                   name <- changed[[kk]]
[10:21:43.358]                   NAME <- NAMES[[kk]]
[10:21:43.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.358]                     next
[10:21:43.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.358]                 }
[10:21:43.358]                 NAMES <- toupper(added)
[10:21:43.358]                 for (kk in seq_along(NAMES)) {
[10:21:43.358]                   name <- added[[kk]]
[10:21:43.358]                   NAME <- NAMES[[kk]]
[10:21:43.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.358]                     next
[10:21:43.358]                   args[[name]] <- ""
[10:21:43.358]                 }
[10:21:43.358]                 NAMES <- toupper(removed)
[10:21:43.358]                 for (kk in seq_along(NAMES)) {
[10:21:43.358]                   name <- removed[[kk]]
[10:21:43.358]                   NAME <- NAMES[[kk]]
[10:21:43.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.358]                     next
[10:21:43.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.358]                 }
[10:21:43.358]                 if (length(args) > 0) 
[10:21:43.358]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.358]             }
[10:21:43.358]             else {
[10:21:43.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.358]             }
[10:21:43.358]             {
[10:21:43.358]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.358]                   0L) {
[10:21:43.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.358]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.358]                   base::options(opts)
[10:21:43.358]                 }
[10:21:43.358]                 {
[10:21:43.358]                   {
[10:21:43.358]                     NULL
[10:21:43.358]                     RNGkind("Mersenne-Twister")
[10:21:43.358]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.358]                       inherits = FALSE)
[10:21:43.358]                   }
[10:21:43.358]                   options(future.plan = NULL)
[10:21:43.358]                   if (is.na(NA_character_)) 
[10:21:43.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.358]                     .init = FALSE)
[10:21:43.358]                 }
[10:21:43.358]             }
[10:21:43.358]         }
[10:21:43.358]     })
[10:21:43.358]     if (TRUE) {
[10:21:43.358]         base::sink(type = "output", split = FALSE)
[10:21:43.358]         if (TRUE) {
[10:21:43.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.358]         }
[10:21:43.358]         else {
[10:21:43.358]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.358]         }
[10:21:43.358]         base::close(...future.stdout)
[10:21:43.358]         ...future.stdout <- NULL
[10:21:43.358]     }
[10:21:43.358]     ...future.result$conditions <- ...future.conditions
[10:21:43.358]     ...future.result$finished <- base::Sys.time()
[10:21:43.358]     ...future.result
[10:21:43.358] }
[10:21:43.360] assign_globals() ...
[10:21:43.360] List of 2
[10:21:43.360]  $ a : num 1
[10:21:43.360]  $ ii: int 3
[10:21:43.360]  - attr(*, "where")=List of 2
[10:21:43.360]   ..$ a :<environment: R_EmptyEnv> 
[10:21:43.360]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.360]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.360]  - attr(*, "resolved")= logi TRUE
[10:21:43.360]  - attr(*, "total_size")= num 74
[10:21:43.360]  - attr(*, "already-done")= logi TRUE
[10:21:43.363] - copied ‘a’ to environment
[10:21:43.363] - copied ‘ii’ to environment
[10:21:43.363] assign_globals() ... done
[10:21:43.363] plan(): Setting new future strategy stack:
[10:21:43.363] List of future strategies:
[10:21:43.363] 1. sequential:
[10:21:43.363]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.363]    - tweaked: FALSE
[10:21:43.363]    - call: NULL
[10:21:43.364] plan(): nbrOfWorkers() = 1
[10:21:43.365] plan(): Setting new future strategy stack:
[10:21:43.365] List of future strategies:
[10:21:43.365] 1. sequential:
[10:21:43.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.365]    - tweaked: FALSE
[10:21:43.365]    - call: plan(strategy)
[10:21:43.365] plan(): nbrOfWorkers() = 1
[10:21:43.365] SequentialFuture started (and completed)
[10:21:43.365] - Launch lazy future ... done
[10:21:43.365] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.366] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.366] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.366] 
[10:21:43.367] Searching for globals ... DONE
[10:21:43.367] - globals: [0] <none>
[10:21:43.367] getGlobalsAndPackages() ... DONE
[10:21:43.367] run() for ‘Future’ ...
[10:21:43.367] - state: ‘created’
[10:21:43.367] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.367] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.368] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.368]   - Field: ‘label’
[10:21:43.368]   - Field: ‘local’
[10:21:43.368]   - Field: ‘owner’
[10:21:43.368]   - Field: ‘envir’
[10:21:43.368]   - Field: ‘packages’
[10:21:43.368]   - Field: ‘gc’
[10:21:43.368]   - Field: ‘conditions’
[10:21:43.368]   - Field: ‘expr’
[10:21:43.368]   - Field: ‘uuid’
[10:21:43.368]   - Field: ‘seed’
[10:21:43.368]   - Field: ‘version’
[10:21:43.369]   - Field: ‘result’
[10:21:43.369]   - Field: ‘asynchronous’
[10:21:43.369]   - Field: ‘calls’
[10:21:43.369]   - Field: ‘globals’
[10:21:43.369]   - Field: ‘stdout’
[10:21:43.369]   - Field: ‘earlySignal’
[10:21:43.369]   - Field: ‘lazy’
[10:21:43.369]   - Field: ‘state’
[10:21:43.369] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.369] - Launch lazy future ...
[10:21:43.370] Packages needed by the future expression (n = 0): <none>
[10:21:43.370] Packages needed by future strategies (n = 0): <none>
[10:21:43.370] {
[10:21:43.370]     {
[10:21:43.370]         {
[10:21:43.370]             ...future.startTime <- base::Sys.time()
[10:21:43.370]             {
[10:21:43.370]                 {
[10:21:43.370]                   {
[10:21:43.370]                     base::local({
[10:21:43.370]                       has_future <- base::requireNamespace("future", 
[10:21:43.370]                         quietly = TRUE)
[10:21:43.370]                       if (has_future) {
[10:21:43.370]                         ns <- base::getNamespace("future")
[10:21:43.370]                         version <- ns[[".package"]][["version"]]
[10:21:43.370]                         if (is.null(version)) 
[10:21:43.370]                           version <- utils::packageVersion("future")
[10:21:43.370]                       }
[10:21:43.370]                       else {
[10:21:43.370]                         version <- NULL
[10:21:43.370]                       }
[10:21:43.370]                       if (!has_future || version < "1.8.0") {
[10:21:43.370]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.370]                           "", base::R.version$version.string), 
[10:21:43.370]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.370]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.370]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.370]                             "release", "version")], collapse = " "), 
[10:21:43.370]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.370]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.370]                           info)
[10:21:43.370]                         info <- base::paste(info, collapse = "; ")
[10:21:43.370]                         if (!has_future) {
[10:21:43.370]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.370]                             info)
[10:21:43.370]                         }
[10:21:43.370]                         else {
[10:21:43.370]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.370]                             info, version)
[10:21:43.370]                         }
[10:21:43.370]                         base::stop(msg)
[10:21:43.370]                       }
[10:21:43.370]                     })
[10:21:43.370]                   }
[10:21:43.370]                   ...future.strategy.old <- future::plan("list")
[10:21:43.370]                   options(future.plan = NULL)
[10:21:43.370]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.370]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.370]                 }
[10:21:43.370]                 ...future.workdir <- getwd()
[10:21:43.370]             }
[10:21:43.370]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.370]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.370]         }
[10:21:43.370]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.370]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.370]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.370]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.370]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.370]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.370]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.370]             base::names(...future.oldOptions))
[10:21:43.370]     }
[10:21:43.370]     if (FALSE) {
[10:21:43.370]     }
[10:21:43.370]     else {
[10:21:43.370]         if (TRUE) {
[10:21:43.370]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.370]                 open = "w")
[10:21:43.370]         }
[10:21:43.370]         else {
[10:21:43.370]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.370]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.370]         }
[10:21:43.370]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.370]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.370]             base::sink(type = "output", split = FALSE)
[10:21:43.370]             base::close(...future.stdout)
[10:21:43.370]         }, add = TRUE)
[10:21:43.370]     }
[10:21:43.370]     ...future.frame <- base::sys.nframe()
[10:21:43.370]     ...future.conditions <- base::list()
[10:21:43.370]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.370]     if (FALSE) {
[10:21:43.370]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.370]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.370]     }
[10:21:43.370]     ...future.result <- base::tryCatch({
[10:21:43.370]         base::withCallingHandlers({
[10:21:43.370]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.370]             future::FutureResult(value = ...future.value$value, 
[10:21:43.370]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.370]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.370]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.370]                     ...future.globalenv.names))
[10:21:43.370]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.370]         }, condition = base::local({
[10:21:43.370]             c <- base::c
[10:21:43.370]             inherits <- base::inherits
[10:21:43.370]             invokeRestart <- base::invokeRestart
[10:21:43.370]             length <- base::length
[10:21:43.370]             list <- base::list
[10:21:43.370]             seq.int <- base::seq.int
[10:21:43.370]             signalCondition <- base::signalCondition
[10:21:43.370]             sys.calls <- base::sys.calls
[10:21:43.370]             `[[` <- base::`[[`
[10:21:43.370]             `+` <- base::`+`
[10:21:43.370]             `<<-` <- base::`<<-`
[10:21:43.370]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.370]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.370]                   3L)]
[10:21:43.370]             }
[10:21:43.370]             function(cond) {
[10:21:43.370]                 is_error <- inherits(cond, "error")
[10:21:43.370]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.370]                   NULL)
[10:21:43.370]                 if (is_error) {
[10:21:43.370]                   sessionInformation <- function() {
[10:21:43.370]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.370]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.370]                       search = base::search(), system = base::Sys.info())
[10:21:43.370]                   }
[10:21:43.370]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.370]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.370]                     cond$call), session = sessionInformation(), 
[10:21:43.370]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.370]                   signalCondition(cond)
[10:21:43.370]                 }
[10:21:43.370]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.370]                 "immediateCondition"))) {
[10:21:43.370]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.370]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.370]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.370]                   if (TRUE && !signal) {
[10:21:43.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.370]                     {
[10:21:43.370]                       inherits <- base::inherits
[10:21:43.370]                       invokeRestart <- base::invokeRestart
[10:21:43.370]                       is.null <- base::is.null
[10:21:43.370]                       muffled <- FALSE
[10:21:43.370]                       if (inherits(cond, "message")) {
[10:21:43.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.370]                         if (muffled) 
[10:21:43.370]                           invokeRestart("muffleMessage")
[10:21:43.370]                       }
[10:21:43.370]                       else if (inherits(cond, "warning")) {
[10:21:43.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.370]                         if (muffled) 
[10:21:43.370]                           invokeRestart("muffleWarning")
[10:21:43.370]                       }
[10:21:43.370]                       else if (inherits(cond, "condition")) {
[10:21:43.370]                         if (!is.null(pattern)) {
[10:21:43.370]                           computeRestarts <- base::computeRestarts
[10:21:43.370]                           grepl <- base::grepl
[10:21:43.370]                           restarts <- computeRestarts(cond)
[10:21:43.370]                           for (restart in restarts) {
[10:21:43.370]                             name <- restart$name
[10:21:43.370]                             if (is.null(name)) 
[10:21:43.370]                               next
[10:21:43.370]                             if (!grepl(pattern, name)) 
[10:21:43.370]                               next
[10:21:43.370]                             invokeRestart(restart)
[10:21:43.370]                             muffled <- TRUE
[10:21:43.370]                             break
[10:21:43.370]                           }
[10:21:43.370]                         }
[10:21:43.370]                       }
[10:21:43.370]                       invisible(muffled)
[10:21:43.370]                     }
[10:21:43.370]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.370]                   }
[10:21:43.370]                 }
[10:21:43.370]                 else {
[10:21:43.370]                   if (TRUE) {
[10:21:43.370]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.370]                     {
[10:21:43.370]                       inherits <- base::inherits
[10:21:43.370]                       invokeRestart <- base::invokeRestart
[10:21:43.370]                       is.null <- base::is.null
[10:21:43.370]                       muffled <- FALSE
[10:21:43.370]                       if (inherits(cond, "message")) {
[10:21:43.370]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.370]                         if (muffled) 
[10:21:43.370]                           invokeRestart("muffleMessage")
[10:21:43.370]                       }
[10:21:43.370]                       else if (inherits(cond, "warning")) {
[10:21:43.370]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.370]                         if (muffled) 
[10:21:43.370]                           invokeRestart("muffleWarning")
[10:21:43.370]                       }
[10:21:43.370]                       else if (inherits(cond, "condition")) {
[10:21:43.370]                         if (!is.null(pattern)) {
[10:21:43.370]                           computeRestarts <- base::computeRestarts
[10:21:43.370]                           grepl <- base::grepl
[10:21:43.370]                           restarts <- computeRestarts(cond)
[10:21:43.370]                           for (restart in restarts) {
[10:21:43.370]                             name <- restart$name
[10:21:43.370]                             if (is.null(name)) 
[10:21:43.370]                               next
[10:21:43.370]                             if (!grepl(pattern, name)) 
[10:21:43.370]                               next
[10:21:43.370]                             invokeRestart(restart)
[10:21:43.370]                             muffled <- TRUE
[10:21:43.370]                             break
[10:21:43.370]                           }
[10:21:43.370]                         }
[10:21:43.370]                       }
[10:21:43.370]                       invisible(muffled)
[10:21:43.370]                     }
[10:21:43.370]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.370]                   }
[10:21:43.370]                 }
[10:21:43.370]             }
[10:21:43.370]         }))
[10:21:43.370]     }, error = function(ex) {
[10:21:43.370]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.370]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.370]                 ...future.rng), started = ...future.startTime, 
[10:21:43.370]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.370]             version = "1.8"), class = "FutureResult")
[10:21:43.370]     }, finally = {
[10:21:43.370]         if (!identical(...future.workdir, getwd())) 
[10:21:43.370]             setwd(...future.workdir)
[10:21:43.370]         {
[10:21:43.370]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.370]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.370]             }
[10:21:43.370]             base::options(...future.oldOptions)
[10:21:43.370]             if (.Platform$OS.type == "windows") {
[10:21:43.370]                 old_names <- names(...future.oldEnvVars)
[10:21:43.370]                 envs <- base::Sys.getenv()
[10:21:43.370]                 names <- names(envs)
[10:21:43.370]                 common <- intersect(names, old_names)
[10:21:43.370]                 added <- setdiff(names, old_names)
[10:21:43.370]                 removed <- setdiff(old_names, names)
[10:21:43.370]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.370]                   envs[common]]
[10:21:43.370]                 NAMES <- toupper(changed)
[10:21:43.370]                 args <- list()
[10:21:43.370]                 for (kk in seq_along(NAMES)) {
[10:21:43.370]                   name <- changed[[kk]]
[10:21:43.370]                   NAME <- NAMES[[kk]]
[10:21:43.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.370]                     next
[10:21:43.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.370]                 }
[10:21:43.370]                 NAMES <- toupper(added)
[10:21:43.370]                 for (kk in seq_along(NAMES)) {
[10:21:43.370]                   name <- added[[kk]]
[10:21:43.370]                   NAME <- NAMES[[kk]]
[10:21:43.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.370]                     next
[10:21:43.370]                   args[[name]] <- ""
[10:21:43.370]                 }
[10:21:43.370]                 NAMES <- toupper(removed)
[10:21:43.370]                 for (kk in seq_along(NAMES)) {
[10:21:43.370]                   name <- removed[[kk]]
[10:21:43.370]                   NAME <- NAMES[[kk]]
[10:21:43.370]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.370]                     next
[10:21:43.370]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.370]                 }
[10:21:43.370]                 if (length(args) > 0) 
[10:21:43.370]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.370]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.370]             }
[10:21:43.370]             else {
[10:21:43.370]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.370]             }
[10:21:43.370]             {
[10:21:43.370]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.370]                   0L) {
[10:21:43.370]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.370]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.370]                   base::options(opts)
[10:21:43.370]                 }
[10:21:43.370]                 {
[10:21:43.370]                   {
[10:21:43.370]                     NULL
[10:21:43.370]                     RNGkind("Mersenne-Twister")
[10:21:43.370]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.370]                       inherits = FALSE)
[10:21:43.370]                   }
[10:21:43.370]                   options(future.plan = NULL)
[10:21:43.370]                   if (is.na(NA_character_)) 
[10:21:43.370]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.370]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.370]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.370]                     .init = FALSE)
[10:21:43.370]                 }
[10:21:43.370]             }
[10:21:43.370]         }
[10:21:43.370]     })
[10:21:43.370]     if (TRUE) {
[10:21:43.370]         base::sink(type = "output", split = FALSE)
[10:21:43.370]         if (TRUE) {
[10:21:43.370]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.370]         }
[10:21:43.370]         else {
[10:21:43.370]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.370]         }
[10:21:43.370]         base::close(...future.stdout)
[10:21:43.370]         ...future.stdout <- NULL
[10:21:43.370]     }
[10:21:43.370]     ...future.result$conditions <- ...future.conditions
[10:21:43.370]     ...future.result$finished <- base::Sys.time()
[10:21:43.370]     ...future.result
[10:21:43.370] }
[10:21:43.372] plan(): Setting new future strategy stack:
[10:21:43.372] List of future strategies:
[10:21:43.372] 1. sequential:
[10:21:43.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.372]    - tweaked: FALSE
[10:21:43.372]    - call: NULL
[10:21:43.372] plan(): nbrOfWorkers() = 1
[10:21:43.373] plan(): Setting new future strategy stack:
[10:21:43.373] List of future strategies:
[10:21:43.373] 1. sequential:
[10:21:43.373]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.373]    - tweaked: FALSE
[10:21:43.373]    - call: plan(strategy)
[10:21:43.374] plan(): nbrOfWorkers() = 1
[10:21:43.374] SequentialFuture started (and completed)
[10:21:43.374] - Launch lazy future ... done
[10:21:43.374] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.374] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.374] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.375] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.375] Searching for globals ... DONE
[10:21:43.375] Resolving globals: TRUE
[10:21:43.376] Resolving any globals that are futures ...
[10:21:43.376] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.376] Resolving any globals that are futures ... DONE
[10:21:43.376] Resolving futures part of globals (recursively) ...
[10:21:43.376] resolve() on list ...
[10:21:43.376]  recursive: 99
[10:21:43.376]  length: 1
[10:21:43.377]  elements: ‘a’
[10:21:43.377] resolved() for ‘SequentialFuture’ ...
[10:21:43.377] - state: ‘finished’
[10:21:43.377] - run: TRUE
[10:21:43.377] - result: ‘FutureResult’
[10:21:43.377] resolved() for ‘SequentialFuture’ ... done
[10:21:43.377] Future #1
[10:21:43.377] resolved() for ‘SequentialFuture’ ...
[10:21:43.377] - state: ‘finished’
[10:21:43.377] - run: TRUE
[10:21:43.377] - result: ‘FutureResult’
[10:21:43.378] resolved() for ‘SequentialFuture’ ... done
[10:21:43.378] A SequentialFuture was resolved
[10:21:43.378]  length: 0 (resolved future 1)
[10:21:43.378] resolve() on list ... DONE
[10:21:43.378] - globals: [1] ‘a’
[10:21:43.378] Resolving futures part of globals (recursively) ... DONE
[10:21:43.378] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[10:21:43.378] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[10:21:43.379] - globals: [1] ‘a’
[10:21:43.379] - packages: [1] ‘future’
[10:21:43.379] getGlobalsAndPackages() ... DONE
[10:21:43.379] run() for ‘Future’ ...
[10:21:43.379] - state: ‘created’
[10:21:43.379] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.380] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.380] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.380]   - Field: ‘label’
[10:21:43.380]   - Field: ‘local’
[10:21:43.380]   - Field: ‘owner’
[10:21:43.380]   - Field: ‘envir’
[10:21:43.380]   - Field: ‘packages’
[10:21:43.380]   - Field: ‘gc’
[10:21:43.380]   - Field: ‘conditions’
[10:21:43.380]   - Field: ‘expr’
[10:21:43.380]   - Field: ‘uuid’
[10:21:43.381]   - Field: ‘seed’
[10:21:43.381]   - Field: ‘version’
[10:21:43.381]   - Field: ‘result’
[10:21:43.381]   - Field: ‘asynchronous’
[10:21:43.381]   - Field: ‘calls’
[10:21:43.381]   - Field: ‘globals’
[10:21:43.381]   - Field: ‘stdout’
[10:21:43.381]   - Field: ‘earlySignal’
[10:21:43.381]   - Field: ‘lazy’
[10:21:43.381]   - Field: ‘state’
[10:21:43.381] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.382] - Launch lazy future ...
[10:21:43.382] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.382] Packages needed by future strategies (n = 0): <none>
[10:21:43.384] {
[10:21:43.384]     {
[10:21:43.384]         {
[10:21:43.384]             ...future.startTime <- base::Sys.time()
[10:21:43.384]             {
[10:21:43.384]                 {
[10:21:43.384]                   {
[10:21:43.384]                     {
[10:21:43.384]                       base::local({
[10:21:43.384]                         has_future <- base::requireNamespace("future", 
[10:21:43.384]                           quietly = TRUE)
[10:21:43.384]                         if (has_future) {
[10:21:43.384]                           ns <- base::getNamespace("future")
[10:21:43.384]                           version <- ns[[".package"]][["version"]]
[10:21:43.384]                           if (is.null(version)) 
[10:21:43.384]                             version <- utils::packageVersion("future")
[10:21:43.384]                         }
[10:21:43.384]                         else {
[10:21:43.384]                           version <- NULL
[10:21:43.384]                         }
[10:21:43.384]                         if (!has_future || version < "1.8.0") {
[10:21:43.384]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.384]                             "", base::R.version$version.string), 
[10:21:43.384]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.384]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.384]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.384]                               "release", "version")], collapse = " "), 
[10:21:43.384]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.384]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.384]                             info)
[10:21:43.384]                           info <- base::paste(info, collapse = "; ")
[10:21:43.384]                           if (!has_future) {
[10:21:43.384]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.384]                               info)
[10:21:43.384]                           }
[10:21:43.384]                           else {
[10:21:43.384]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.384]                               info, version)
[10:21:43.384]                           }
[10:21:43.384]                           base::stop(msg)
[10:21:43.384]                         }
[10:21:43.384]                       })
[10:21:43.384]                     }
[10:21:43.384]                     base::local({
[10:21:43.384]                       for (pkg in "future") {
[10:21:43.384]                         base::loadNamespace(pkg)
[10:21:43.384]                         base::library(pkg, character.only = TRUE)
[10:21:43.384]                       }
[10:21:43.384]                     })
[10:21:43.384]                   }
[10:21:43.384]                   ...future.strategy.old <- future::plan("list")
[10:21:43.384]                   options(future.plan = NULL)
[10:21:43.384]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.384]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.384]                 }
[10:21:43.384]                 ...future.workdir <- getwd()
[10:21:43.384]             }
[10:21:43.384]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.384]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.384]         }
[10:21:43.384]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.384]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.384]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.384]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.384]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.384]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.384]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.384]             base::names(...future.oldOptions))
[10:21:43.384]     }
[10:21:43.384]     if (FALSE) {
[10:21:43.384]     }
[10:21:43.384]     else {
[10:21:43.384]         if (TRUE) {
[10:21:43.384]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.384]                 open = "w")
[10:21:43.384]         }
[10:21:43.384]         else {
[10:21:43.384]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.384]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.384]         }
[10:21:43.384]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.384]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.384]             base::sink(type = "output", split = FALSE)
[10:21:43.384]             base::close(...future.stdout)
[10:21:43.384]         }, add = TRUE)
[10:21:43.384]     }
[10:21:43.384]     ...future.frame <- base::sys.nframe()
[10:21:43.384]     ...future.conditions <- base::list()
[10:21:43.384]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.384]     if (FALSE) {
[10:21:43.384]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.384]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.384]     }
[10:21:43.384]     ...future.result <- base::tryCatch({
[10:21:43.384]         base::withCallingHandlers({
[10:21:43.384]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.384]                 1))
[10:21:43.384]             future::FutureResult(value = ...future.value$value, 
[10:21:43.384]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.384]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.384]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.384]                     ...future.globalenv.names))
[10:21:43.384]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.384]         }, condition = base::local({
[10:21:43.384]             c <- base::c
[10:21:43.384]             inherits <- base::inherits
[10:21:43.384]             invokeRestart <- base::invokeRestart
[10:21:43.384]             length <- base::length
[10:21:43.384]             list <- base::list
[10:21:43.384]             seq.int <- base::seq.int
[10:21:43.384]             signalCondition <- base::signalCondition
[10:21:43.384]             sys.calls <- base::sys.calls
[10:21:43.384]             `[[` <- base::`[[`
[10:21:43.384]             `+` <- base::`+`
[10:21:43.384]             `<<-` <- base::`<<-`
[10:21:43.384]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.384]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.384]                   3L)]
[10:21:43.384]             }
[10:21:43.384]             function(cond) {
[10:21:43.384]                 is_error <- inherits(cond, "error")
[10:21:43.384]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.384]                   NULL)
[10:21:43.384]                 if (is_error) {
[10:21:43.384]                   sessionInformation <- function() {
[10:21:43.384]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.384]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.384]                       search = base::search(), system = base::Sys.info())
[10:21:43.384]                   }
[10:21:43.384]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.384]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.384]                     cond$call), session = sessionInformation(), 
[10:21:43.384]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.384]                   signalCondition(cond)
[10:21:43.384]                 }
[10:21:43.384]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.384]                 "immediateCondition"))) {
[10:21:43.384]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.384]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.384]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.384]                   if (TRUE && !signal) {
[10:21:43.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.384]                     {
[10:21:43.384]                       inherits <- base::inherits
[10:21:43.384]                       invokeRestart <- base::invokeRestart
[10:21:43.384]                       is.null <- base::is.null
[10:21:43.384]                       muffled <- FALSE
[10:21:43.384]                       if (inherits(cond, "message")) {
[10:21:43.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.384]                         if (muffled) 
[10:21:43.384]                           invokeRestart("muffleMessage")
[10:21:43.384]                       }
[10:21:43.384]                       else if (inherits(cond, "warning")) {
[10:21:43.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.384]                         if (muffled) 
[10:21:43.384]                           invokeRestart("muffleWarning")
[10:21:43.384]                       }
[10:21:43.384]                       else if (inherits(cond, "condition")) {
[10:21:43.384]                         if (!is.null(pattern)) {
[10:21:43.384]                           computeRestarts <- base::computeRestarts
[10:21:43.384]                           grepl <- base::grepl
[10:21:43.384]                           restarts <- computeRestarts(cond)
[10:21:43.384]                           for (restart in restarts) {
[10:21:43.384]                             name <- restart$name
[10:21:43.384]                             if (is.null(name)) 
[10:21:43.384]                               next
[10:21:43.384]                             if (!grepl(pattern, name)) 
[10:21:43.384]                               next
[10:21:43.384]                             invokeRestart(restart)
[10:21:43.384]                             muffled <- TRUE
[10:21:43.384]                             break
[10:21:43.384]                           }
[10:21:43.384]                         }
[10:21:43.384]                       }
[10:21:43.384]                       invisible(muffled)
[10:21:43.384]                     }
[10:21:43.384]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.384]                   }
[10:21:43.384]                 }
[10:21:43.384]                 else {
[10:21:43.384]                   if (TRUE) {
[10:21:43.384]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.384]                     {
[10:21:43.384]                       inherits <- base::inherits
[10:21:43.384]                       invokeRestart <- base::invokeRestart
[10:21:43.384]                       is.null <- base::is.null
[10:21:43.384]                       muffled <- FALSE
[10:21:43.384]                       if (inherits(cond, "message")) {
[10:21:43.384]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.384]                         if (muffled) 
[10:21:43.384]                           invokeRestart("muffleMessage")
[10:21:43.384]                       }
[10:21:43.384]                       else if (inherits(cond, "warning")) {
[10:21:43.384]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.384]                         if (muffled) 
[10:21:43.384]                           invokeRestart("muffleWarning")
[10:21:43.384]                       }
[10:21:43.384]                       else if (inherits(cond, "condition")) {
[10:21:43.384]                         if (!is.null(pattern)) {
[10:21:43.384]                           computeRestarts <- base::computeRestarts
[10:21:43.384]                           grepl <- base::grepl
[10:21:43.384]                           restarts <- computeRestarts(cond)
[10:21:43.384]                           for (restart in restarts) {
[10:21:43.384]                             name <- restart$name
[10:21:43.384]                             if (is.null(name)) 
[10:21:43.384]                               next
[10:21:43.384]                             if (!grepl(pattern, name)) 
[10:21:43.384]                               next
[10:21:43.384]                             invokeRestart(restart)
[10:21:43.384]                             muffled <- TRUE
[10:21:43.384]                             break
[10:21:43.384]                           }
[10:21:43.384]                         }
[10:21:43.384]                       }
[10:21:43.384]                       invisible(muffled)
[10:21:43.384]                     }
[10:21:43.384]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.384]                   }
[10:21:43.384]                 }
[10:21:43.384]             }
[10:21:43.384]         }))
[10:21:43.384]     }, error = function(ex) {
[10:21:43.384]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.384]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.384]                 ...future.rng), started = ...future.startTime, 
[10:21:43.384]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.384]             version = "1.8"), class = "FutureResult")
[10:21:43.384]     }, finally = {
[10:21:43.384]         if (!identical(...future.workdir, getwd())) 
[10:21:43.384]             setwd(...future.workdir)
[10:21:43.384]         {
[10:21:43.384]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.384]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.384]             }
[10:21:43.384]             base::options(...future.oldOptions)
[10:21:43.384]             if (.Platform$OS.type == "windows") {
[10:21:43.384]                 old_names <- names(...future.oldEnvVars)
[10:21:43.384]                 envs <- base::Sys.getenv()
[10:21:43.384]                 names <- names(envs)
[10:21:43.384]                 common <- intersect(names, old_names)
[10:21:43.384]                 added <- setdiff(names, old_names)
[10:21:43.384]                 removed <- setdiff(old_names, names)
[10:21:43.384]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.384]                   envs[common]]
[10:21:43.384]                 NAMES <- toupper(changed)
[10:21:43.384]                 args <- list()
[10:21:43.384]                 for (kk in seq_along(NAMES)) {
[10:21:43.384]                   name <- changed[[kk]]
[10:21:43.384]                   NAME <- NAMES[[kk]]
[10:21:43.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.384]                     next
[10:21:43.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.384]                 }
[10:21:43.384]                 NAMES <- toupper(added)
[10:21:43.384]                 for (kk in seq_along(NAMES)) {
[10:21:43.384]                   name <- added[[kk]]
[10:21:43.384]                   NAME <- NAMES[[kk]]
[10:21:43.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.384]                     next
[10:21:43.384]                   args[[name]] <- ""
[10:21:43.384]                 }
[10:21:43.384]                 NAMES <- toupper(removed)
[10:21:43.384]                 for (kk in seq_along(NAMES)) {
[10:21:43.384]                   name <- removed[[kk]]
[10:21:43.384]                   NAME <- NAMES[[kk]]
[10:21:43.384]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.384]                     next
[10:21:43.384]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.384]                 }
[10:21:43.384]                 if (length(args) > 0) 
[10:21:43.384]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.384]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.384]             }
[10:21:43.384]             else {
[10:21:43.384]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.384]             }
[10:21:43.384]             {
[10:21:43.384]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.384]                   0L) {
[10:21:43.384]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.384]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.384]                   base::options(opts)
[10:21:43.384]                 }
[10:21:43.384]                 {
[10:21:43.384]                   {
[10:21:43.384]                     NULL
[10:21:43.384]                     RNGkind("Mersenne-Twister")
[10:21:43.384]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.384]                       inherits = FALSE)
[10:21:43.384]                   }
[10:21:43.384]                   options(future.plan = NULL)
[10:21:43.384]                   if (is.na(NA_character_)) 
[10:21:43.384]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.384]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.384]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.384]                     .init = FALSE)
[10:21:43.384]                 }
[10:21:43.384]             }
[10:21:43.384]         }
[10:21:43.384]     })
[10:21:43.384]     if (TRUE) {
[10:21:43.384]         base::sink(type = "output", split = FALSE)
[10:21:43.384]         if (TRUE) {
[10:21:43.384]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.384]         }
[10:21:43.384]         else {
[10:21:43.384]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.384]         }
[10:21:43.384]         base::close(...future.stdout)
[10:21:43.384]         ...future.stdout <- NULL
[10:21:43.384]     }
[10:21:43.384]     ...future.result$conditions <- ...future.conditions
[10:21:43.384]     ...future.result$finished <- base::Sys.time()
[10:21:43.384]     ...future.result
[10:21:43.384] }
[10:21:43.386] assign_globals() ...
[10:21:43.386] List of 1
[10:21:43.386]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18dd078c8> 
[10:21:43.386]  - attr(*, "where")=List of 1
[10:21:43.386]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.386]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.386]  - attr(*, "resolved")= logi TRUE
[10:21:43.386]  - attr(*, "total_size")= num 3535
[10:21:43.386]  - attr(*, "already-done")= logi TRUE
[10:21:43.388] - copied ‘a’ to environment
[10:21:43.388] assign_globals() ... done
[10:21:43.389] plan(): Setting new future strategy stack:
[10:21:43.389] List of future strategies:
[10:21:43.389] 1. sequential:
[10:21:43.389]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.389]    - tweaked: FALSE
[10:21:43.389]    - call: NULL
[10:21:43.389] plan(): nbrOfWorkers() = 1
[10:21:43.390] plan(): Setting new future strategy stack:
[10:21:43.390] List of future strategies:
[10:21:43.390] 1. sequential:
[10:21:43.390]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.390]    - tweaked: FALSE
[10:21:43.390]    - call: plan(strategy)
[10:21:43.391] plan(): nbrOfWorkers() = 1
[10:21:43.391] SequentialFuture started (and completed)
[10:21:43.391] - Launch lazy future ... done
[10:21:43.391] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.391] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.392] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.392] 
[10:21:43.392] Searching for globals ... DONE
[10:21:43.392] - globals: [0] <none>
[10:21:43.392] getGlobalsAndPackages() ... DONE
[10:21:43.392] run() for ‘Future’ ...
[10:21:43.393] - state: ‘created’
[10:21:43.393] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.393] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.393] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.393]   - Field: ‘label’
[10:21:43.393]   - Field: ‘local’
[10:21:43.393]   - Field: ‘owner’
[10:21:43.393]   - Field: ‘envir’
[10:21:43.393]   - Field: ‘packages’
[10:21:43.394]   - Field: ‘gc’
[10:21:43.394]   - Field: ‘conditions’
[10:21:43.394]   - Field: ‘expr’
[10:21:43.394]   - Field: ‘uuid’
[10:21:43.394]   - Field: ‘seed’
[10:21:43.394]   - Field: ‘version’
[10:21:43.394]   - Field: ‘result’
[10:21:43.394]   - Field: ‘asynchronous’
[10:21:43.394]   - Field: ‘calls’
[10:21:43.394]   - Field: ‘globals’
[10:21:43.394]   - Field: ‘stdout’
[10:21:43.394]   - Field: ‘earlySignal’
[10:21:43.395]   - Field: ‘lazy’
[10:21:43.395]   - Field: ‘state’
[10:21:43.395] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.395] - Launch lazy future ...
[10:21:43.395] Packages needed by the future expression (n = 0): <none>
[10:21:43.395] Packages needed by future strategies (n = 0): <none>
[10:21:43.395] {
[10:21:43.395]     {
[10:21:43.395]         {
[10:21:43.395]             ...future.startTime <- base::Sys.time()
[10:21:43.395]             {
[10:21:43.395]                 {
[10:21:43.395]                   {
[10:21:43.395]                     base::local({
[10:21:43.395]                       has_future <- base::requireNamespace("future", 
[10:21:43.395]                         quietly = TRUE)
[10:21:43.395]                       if (has_future) {
[10:21:43.395]                         ns <- base::getNamespace("future")
[10:21:43.395]                         version <- ns[[".package"]][["version"]]
[10:21:43.395]                         if (is.null(version)) 
[10:21:43.395]                           version <- utils::packageVersion("future")
[10:21:43.395]                       }
[10:21:43.395]                       else {
[10:21:43.395]                         version <- NULL
[10:21:43.395]                       }
[10:21:43.395]                       if (!has_future || version < "1.8.0") {
[10:21:43.395]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.395]                           "", base::R.version$version.string), 
[10:21:43.395]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.395]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.395]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.395]                             "release", "version")], collapse = " "), 
[10:21:43.395]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.395]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.395]                           info)
[10:21:43.395]                         info <- base::paste(info, collapse = "; ")
[10:21:43.395]                         if (!has_future) {
[10:21:43.395]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.395]                             info)
[10:21:43.395]                         }
[10:21:43.395]                         else {
[10:21:43.395]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.395]                             info, version)
[10:21:43.395]                         }
[10:21:43.395]                         base::stop(msg)
[10:21:43.395]                       }
[10:21:43.395]                     })
[10:21:43.395]                   }
[10:21:43.395]                   ...future.strategy.old <- future::plan("list")
[10:21:43.395]                   options(future.plan = NULL)
[10:21:43.395]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.395]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.395]                 }
[10:21:43.395]                 ...future.workdir <- getwd()
[10:21:43.395]             }
[10:21:43.395]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.395]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.395]         }
[10:21:43.395]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.395]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.395]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.395]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.395]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.395]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.395]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.395]             base::names(...future.oldOptions))
[10:21:43.395]     }
[10:21:43.395]     if (FALSE) {
[10:21:43.395]     }
[10:21:43.395]     else {
[10:21:43.395]         if (TRUE) {
[10:21:43.395]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.395]                 open = "w")
[10:21:43.395]         }
[10:21:43.395]         else {
[10:21:43.395]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.395]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.395]         }
[10:21:43.395]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.395]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.395]             base::sink(type = "output", split = FALSE)
[10:21:43.395]             base::close(...future.stdout)
[10:21:43.395]         }, add = TRUE)
[10:21:43.395]     }
[10:21:43.395]     ...future.frame <- base::sys.nframe()
[10:21:43.395]     ...future.conditions <- base::list()
[10:21:43.395]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.395]     if (FALSE) {
[10:21:43.395]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.395]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.395]     }
[10:21:43.395]     ...future.result <- base::tryCatch({
[10:21:43.395]         base::withCallingHandlers({
[10:21:43.395]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.395]             future::FutureResult(value = ...future.value$value, 
[10:21:43.395]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.395]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.395]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.395]                     ...future.globalenv.names))
[10:21:43.395]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.395]         }, condition = base::local({
[10:21:43.395]             c <- base::c
[10:21:43.395]             inherits <- base::inherits
[10:21:43.395]             invokeRestart <- base::invokeRestart
[10:21:43.395]             length <- base::length
[10:21:43.395]             list <- base::list
[10:21:43.395]             seq.int <- base::seq.int
[10:21:43.395]             signalCondition <- base::signalCondition
[10:21:43.395]             sys.calls <- base::sys.calls
[10:21:43.395]             `[[` <- base::`[[`
[10:21:43.395]             `+` <- base::`+`
[10:21:43.395]             `<<-` <- base::`<<-`
[10:21:43.395]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.395]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.395]                   3L)]
[10:21:43.395]             }
[10:21:43.395]             function(cond) {
[10:21:43.395]                 is_error <- inherits(cond, "error")
[10:21:43.395]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.395]                   NULL)
[10:21:43.395]                 if (is_error) {
[10:21:43.395]                   sessionInformation <- function() {
[10:21:43.395]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.395]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.395]                       search = base::search(), system = base::Sys.info())
[10:21:43.395]                   }
[10:21:43.395]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.395]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.395]                     cond$call), session = sessionInformation(), 
[10:21:43.395]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.395]                   signalCondition(cond)
[10:21:43.395]                 }
[10:21:43.395]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.395]                 "immediateCondition"))) {
[10:21:43.395]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.395]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.395]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.395]                   if (TRUE && !signal) {
[10:21:43.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.395]                     {
[10:21:43.395]                       inherits <- base::inherits
[10:21:43.395]                       invokeRestart <- base::invokeRestart
[10:21:43.395]                       is.null <- base::is.null
[10:21:43.395]                       muffled <- FALSE
[10:21:43.395]                       if (inherits(cond, "message")) {
[10:21:43.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.395]                         if (muffled) 
[10:21:43.395]                           invokeRestart("muffleMessage")
[10:21:43.395]                       }
[10:21:43.395]                       else if (inherits(cond, "warning")) {
[10:21:43.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.395]                         if (muffled) 
[10:21:43.395]                           invokeRestart("muffleWarning")
[10:21:43.395]                       }
[10:21:43.395]                       else if (inherits(cond, "condition")) {
[10:21:43.395]                         if (!is.null(pattern)) {
[10:21:43.395]                           computeRestarts <- base::computeRestarts
[10:21:43.395]                           grepl <- base::grepl
[10:21:43.395]                           restarts <- computeRestarts(cond)
[10:21:43.395]                           for (restart in restarts) {
[10:21:43.395]                             name <- restart$name
[10:21:43.395]                             if (is.null(name)) 
[10:21:43.395]                               next
[10:21:43.395]                             if (!grepl(pattern, name)) 
[10:21:43.395]                               next
[10:21:43.395]                             invokeRestart(restart)
[10:21:43.395]                             muffled <- TRUE
[10:21:43.395]                             break
[10:21:43.395]                           }
[10:21:43.395]                         }
[10:21:43.395]                       }
[10:21:43.395]                       invisible(muffled)
[10:21:43.395]                     }
[10:21:43.395]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.395]                   }
[10:21:43.395]                 }
[10:21:43.395]                 else {
[10:21:43.395]                   if (TRUE) {
[10:21:43.395]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.395]                     {
[10:21:43.395]                       inherits <- base::inherits
[10:21:43.395]                       invokeRestart <- base::invokeRestart
[10:21:43.395]                       is.null <- base::is.null
[10:21:43.395]                       muffled <- FALSE
[10:21:43.395]                       if (inherits(cond, "message")) {
[10:21:43.395]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.395]                         if (muffled) 
[10:21:43.395]                           invokeRestart("muffleMessage")
[10:21:43.395]                       }
[10:21:43.395]                       else if (inherits(cond, "warning")) {
[10:21:43.395]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.395]                         if (muffled) 
[10:21:43.395]                           invokeRestart("muffleWarning")
[10:21:43.395]                       }
[10:21:43.395]                       else if (inherits(cond, "condition")) {
[10:21:43.395]                         if (!is.null(pattern)) {
[10:21:43.395]                           computeRestarts <- base::computeRestarts
[10:21:43.395]                           grepl <- base::grepl
[10:21:43.395]                           restarts <- computeRestarts(cond)
[10:21:43.395]                           for (restart in restarts) {
[10:21:43.395]                             name <- restart$name
[10:21:43.395]                             if (is.null(name)) 
[10:21:43.395]                               next
[10:21:43.395]                             if (!grepl(pattern, name)) 
[10:21:43.395]                               next
[10:21:43.395]                             invokeRestart(restart)
[10:21:43.395]                             muffled <- TRUE
[10:21:43.395]                             break
[10:21:43.395]                           }
[10:21:43.395]                         }
[10:21:43.395]                       }
[10:21:43.395]                       invisible(muffled)
[10:21:43.395]                     }
[10:21:43.395]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.395]                   }
[10:21:43.395]                 }
[10:21:43.395]             }
[10:21:43.395]         }))
[10:21:43.395]     }, error = function(ex) {
[10:21:43.395]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.395]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.395]                 ...future.rng), started = ...future.startTime, 
[10:21:43.395]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.395]             version = "1.8"), class = "FutureResult")
[10:21:43.395]     }, finally = {
[10:21:43.395]         if (!identical(...future.workdir, getwd())) 
[10:21:43.395]             setwd(...future.workdir)
[10:21:43.395]         {
[10:21:43.395]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.395]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.395]             }
[10:21:43.395]             base::options(...future.oldOptions)
[10:21:43.395]             if (.Platform$OS.type == "windows") {
[10:21:43.395]                 old_names <- names(...future.oldEnvVars)
[10:21:43.395]                 envs <- base::Sys.getenv()
[10:21:43.395]                 names <- names(envs)
[10:21:43.395]                 common <- intersect(names, old_names)
[10:21:43.395]                 added <- setdiff(names, old_names)
[10:21:43.395]                 removed <- setdiff(old_names, names)
[10:21:43.395]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.395]                   envs[common]]
[10:21:43.395]                 NAMES <- toupper(changed)
[10:21:43.395]                 args <- list()
[10:21:43.395]                 for (kk in seq_along(NAMES)) {
[10:21:43.395]                   name <- changed[[kk]]
[10:21:43.395]                   NAME <- NAMES[[kk]]
[10:21:43.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.395]                     next
[10:21:43.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.395]                 }
[10:21:43.395]                 NAMES <- toupper(added)
[10:21:43.395]                 for (kk in seq_along(NAMES)) {
[10:21:43.395]                   name <- added[[kk]]
[10:21:43.395]                   NAME <- NAMES[[kk]]
[10:21:43.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.395]                     next
[10:21:43.395]                   args[[name]] <- ""
[10:21:43.395]                 }
[10:21:43.395]                 NAMES <- toupper(removed)
[10:21:43.395]                 for (kk in seq_along(NAMES)) {
[10:21:43.395]                   name <- removed[[kk]]
[10:21:43.395]                   NAME <- NAMES[[kk]]
[10:21:43.395]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.395]                     next
[10:21:43.395]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.395]                 }
[10:21:43.395]                 if (length(args) > 0) 
[10:21:43.395]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.395]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.395]             }
[10:21:43.395]             else {
[10:21:43.395]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.395]             }
[10:21:43.395]             {
[10:21:43.395]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.395]                   0L) {
[10:21:43.395]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.395]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.395]                   base::options(opts)
[10:21:43.395]                 }
[10:21:43.395]                 {
[10:21:43.395]                   {
[10:21:43.395]                     NULL
[10:21:43.395]                     RNGkind("Mersenne-Twister")
[10:21:43.395]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.395]                       inherits = FALSE)
[10:21:43.395]                   }
[10:21:43.395]                   options(future.plan = NULL)
[10:21:43.395]                   if (is.na(NA_character_)) 
[10:21:43.395]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.395]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.395]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.395]                     .init = FALSE)
[10:21:43.395]                 }
[10:21:43.395]             }
[10:21:43.395]         }
[10:21:43.395]     })
[10:21:43.395]     if (TRUE) {
[10:21:43.395]         base::sink(type = "output", split = FALSE)
[10:21:43.395]         if (TRUE) {
[10:21:43.395]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.395]         }
[10:21:43.395]         else {
[10:21:43.395]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.395]         }
[10:21:43.395]         base::close(...future.stdout)
[10:21:43.395]         ...future.stdout <- NULL
[10:21:43.395]     }
[10:21:43.395]     ...future.result$conditions <- ...future.conditions
[10:21:43.395]     ...future.result$finished <- base::Sys.time()
[10:21:43.395]     ...future.result
[10:21:43.395] }
[10:21:43.397] plan(): Setting new future strategy stack:
[10:21:43.397] List of future strategies:
[10:21:43.397] 1. sequential:
[10:21:43.397]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.397]    - tweaked: FALSE
[10:21:43.397]    - call: NULL
[10:21:43.398] plan(): nbrOfWorkers() = 1
[10:21:43.398] plan(): Setting new future strategy stack:
[10:21:43.399] List of future strategies:
[10:21:43.399] 1. sequential:
[10:21:43.399]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.399]    - tweaked: FALSE
[10:21:43.399]    - call: plan(strategy)
[10:21:43.399] plan(): nbrOfWorkers() = 1
[10:21:43.399] SequentialFuture started (and completed)
[10:21:43.399] - Launch lazy future ... done
[10:21:43.399] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.400] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.400] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.400] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.401] Searching for globals ... DONE
[10:21:43.401] Resolving globals: TRUE
[10:21:43.401] Resolving any globals that are futures ...
[10:21:43.401] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.401] Resolving any globals that are futures ... DONE
[10:21:43.401] Resolving futures part of globals (recursively) ...
[10:21:43.401] resolve() on list ...
[10:21:43.402]  recursive: 99
[10:21:43.402]  length: 1
[10:21:43.402]  elements: ‘a’
[10:21:43.402] resolved() for ‘SequentialFuture’ ...
[10:21:43.402] - state: ‘finished’
[10:21:43.402] - run: TRUE
[10:21:43.402] - result: ‘FutureResult’
[10:21:43.402] resolved() for ‘SequentialFuture’ ... done
[10:21:43.402] Future #1
[10:21:43.402] resolved() for ‘SequentialFuture’ ...
[10:21:43.403] - state: ‘finished’
[10:21:43.403] - run: TRUE
[10:21:43.403] - result: ‘FutureResult’
[10:21:43.403] resolved() for ‘SequentialFuture’ ... done
[10:21:43.403] A SequentialFuture was resolved
[10:21:43.403]  length: 0 (resolved future 1)
[10:21:43.403] resolve() on list ... DONE
[10:21:43.403] - globals: [1] ‘a’
[10:21:43.403] Resolving futures part of globals (recursively) ... DONE
[10:21:43.403] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[10:21:43.404] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[10:21:43.404] - globals: [1] ‘a’
[10:21:43.404] - packages: [1] ‘future’
[10:21:43.404] getGlobalsAndPackages() ... DONE
[10:21:43.404] run() for ‘Future’ ...
[10:21:43.404] - state: ‘created’
[10:21:43.405] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.405] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.405] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.405]   - Field: ‘label’
[10:21:43.405]   - Field: ‘local’
[10:21:43.405]   - Field: ‘owner’
[10:21:43.405]   - Field: ‘envir’
[10:21:43.405]   - Field: ‘packages’
[10:21:43.405]   - Field: ‘gc’
[10:21:43.406]   - Field: ‘conditions’
[10:21:43.406]   - Field: ‘expr’
[10:21:43.406]   - Field: ‘uuid’
[10:21:43.406]   - Field: ‘seed’
[10:21:43.406]   - Field: ‘version’
[10:21:43.406]   - Field: ‘result’
[10:21:43.406]   - Field: ‘asynchronous’
[10:21:43.406]   - Field: ‘calls’
[10:21:43.406]   - Field: ‘globals’
[10:21:43.406]   - Field: ‘stdout’
[10:21:43.406]   - Field: ‘earlySignal’
[10:21:43.406]   - Field: ‘lazy’
[10:21:43.407]   - Field: ‘state’
[10:21:43.407] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.407] - Launch lazy future ...
[10:21:43.407] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.407] Packages needed by future strategies (n = 0): <none>
[10:21:43.407] {
[10:21:43.407]     {
[10:21:43.407]         {
[10:21:43.407]             ...future.startTime <- base::Sys.time()
[10:21:43.407]             {
[10:21:43.407]                 {
[10:21:43.407]                   {
[10:21:43.407]                     {
[10:21:43.407]                       base::local({
[10:21:43.407]                         has_future <- base::requireNamespace("future", 
[10:21:43.407]                           quietly = TRUE)
[10:21:43.407]                         if (has_future) {
[10:21:43.407]                           ns <- base::getNamespace("future")
[10:21:43.407]                           version <- ns[[".package"]][["version"]]
[10:21:43.407]                           if (is.null(version)) 
[10:21:43.407]                             version <- utils::packageVersion("future")
[10:21:43.407]                         }
[10:21:43.407]                         else {
[10:21:43.407]                           version <- NULL
[10:21:43.407]                         }
[10:21:43.407]                         if (!has_future || version < "1.8.0") {
[10:21:43.407]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.407]                             "", base::R.version$version.string), 
[10:21:43.407]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.407]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.407]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.407]                               "release", "version")], collapse = " "), 
[10:21:43.407]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.407]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.407]                             info)
[10:21:43.407]                           info <- base::paste(info, collapse = "; ")
[10:21:43.407]                           if (!has_future) {
[10:21:43.407]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.407]                               info)
[10:21:43.407]                           }
[10:21:43.407]                           else {
[10:21:43.407]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.407]                               info, version)
[10:21:43.407]                           }
[10:21:43.407]                           base::stop(msg)
[10:21:43.407]                         }
[10:21:43.407]                       })
[10:21:43.407]                     }
[10:21:43.407]                     base::local({
[10:21:43.407]                       for (pkg in "future") {
[10:21:43.407]                         base::loadNamespace(pkg)
[10:21:43.407]                         base::library(pkg, character.only = TRUE)
[10:21:43.407]                       }
[10:21:43.407]                     })
[10:21:43.407]                   }
[10:21:43.407]                   ...future.strategy.old <- future::plan("list")
[10:21:43.407]                   options(future.plan = NULL)
[10:21:43.407]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.407]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.407]                 }
[10:21:43.407]                 ...future.workdir <- getwd()
[10:21:43.407]             }
[10:21:43.407]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.407]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.407]         }
[10:21:43.407]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.407]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.407]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.407]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.407]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.407]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.407]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.407]             base::names(...future.oldOptions))
[10:21:43.407]     }
[10:21:43.407]     if (FALSE) {
[10:21:43.407]     }
[10:21:43.407]     else {
[10:21:43.407]         if (TRUE) {
[10:21:43.407]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.407]                 open = "w")
[10:21:43.407]         }
[10:21:43.407]         else {
[10:21:43.407]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.407]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.407]         }
[10:21:43.407]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.407]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.407]             base::sink(type = "output", split = FALSE)
[10:21:43.407]             base::close(...future.stdout)
[10:21:43.407]         }, add = TRUE)
[10:21:43.407]     }
[10:21:43.407]     ...future.frame <- base::sys.nframe()
[10:21:43.407]     ...future.conditions <- base::list()
[10:21:43.407]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.407]     if (FALSE) {
[10:21:43.407]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.407]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.407]     }
[10:21:43.407]     ...future.result <- base::tryCatch({
[10:21:43.407]         base::withCallingHandlers({
[10:21:43.407]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.407]                 1))
[10:21:43.407]             future::FutureResult(value = ...future.value$value, 
[10:21:43.407]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.407]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.407]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.407]                     ...future.globalenv.names))
[10:21:43.407]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.407]         }, condition = base::local({
[10:21:43.407]             c <- base::c
[10:21:43.407]             inherits <- base::inherits
[10:21:43.407]             invokeRestart <- base::invokeRestart
[10:21:43.407]             length <- base::length
[10:21:43.407]             list <- base::list
[10:21:43.407]             seq.int <- base::seq.int
[10:21:43.407]             signalCondition <- base::signalCondition
[10:21:43.407]             sys.calls <- base::sys.calls
[10:21:43.407]             `[[` <- base::`[[`
[10:21:43.407]             `+` <- base::`+`
[10:21:43.407]             `<<-` <- base::`<<-`
[10:21:43.407]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.407]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.407]                   3L)]
[10:21:43.407]             }
[10:21:43.407]             function(cond) {
[10:21:43.407]                 is_error <- inherits(cond, "error")
[10:21:43.407]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.407]                   NULL)
[10:21:43.407]                 if (is_error) {
[10:21:43.407]                   sessionInformation <- function() {
[10:21:43.407]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.407]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.407]                       search = base::search(), system = base::Sys.info())
[10:21:43.407]                   }
[10:21:43.407]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.407]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.407]                     cond$call), session = sessionInformation(), 
[10:21:43.407]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.407]                   signalCondition(cond)
[10:21:43.407]                 }
[10:21:43.407]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.407]                 "immediateCondition"))) {
[10:21:43.407]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.407]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.407]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.407]                   if (TRUE && !signal) {
[10:21:43.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.407]                     {
[10:21:43.407]                       inherits <- base::inherits
[10:21:43.407]                       invokeRestart <- base::invokeRestart
[10:21:43.407]                       is.null <- base::is.null
[10:21:43.407]                       muffled <- FALSE
[10:21:43.407]                       if (inherits(cond, "message")) {
[10:21:43.407]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.407]                         if (muffled) 
[10:21:43.407]                           invokeRestart("muffleMessage")
[10:21:43.407]                       }
[10:21:43.407]                       else if (inherits(cond, "warning")) {
[10:21:43.407]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.407]                         if (muffled) 
[10:21:43.407]                           invokeRestart("muffleWarning")
[10:21:43.407]                       }
[10:21:43.407]                       else if (inherits(cond, "condition")) {
[10:21:43.407]                         if (!is.null(pattern)) {
[10:21:43.407]                           computeRestarts <- base::computeRestarts
[10:21:43.407]                           grepl <- base::grepl
[10:21:43.407]                           restarts <- computeRestarts(cond)
[10:21:43.407]                           for (restart in restarts) {
[10:21:43.407]                             name <- restart$name
[10:21:43.407]                             if (is.null(name)) 
[10:21:43.407]                               next
[10:21:43.407]                             if (!grepl(pattern, name)) 
[10:21:43.407]                               next
[10:21:43.407]                             invokeRestart(restart)
[10:21:43.407]                             muffled <- TRUE
[10:21:43.407]                             break
[10:21:43.407]                           }
[10:21:43.407]                         }
[10:21:43.407]                       }
[10:21:43.407]                       invisible(muffled)
[10:21:43.407]                     }
[10:21:43.407]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.407]                   }
[10:21:43.407]                 }
[10:21:43.407]                 else {
[10:21:43.407]                   if (TRUE) {
[10:21:43.407]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.407]                     {
[10:21:43.407]                       inherits <- base::inherits
[10:21:43.407]                       invokeRestart <- base::invokeRestart
[10:21:43.407]                       is.null <- base::is.null
[10:21:43.407]                       muffled <- FALSE
[10:21:43.407]                       if (inherits(cond, "message")) {
[10:21:43.407]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.407]                         if (muffled) 
[10:21:43.407]                           invokeRestart("muffleMessage")
[10:21:43.407]                       }
[10:21:43.407]                       else if (inherits(cond, "warning")) {
[10:21:43.407]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.407]                         if (muffled) 
[10:21:43.407]                           invokeRestart("muffleWarning")
[10:21:43.407]                       }
[10:21:43.407]                       else if (inherits(cond, "condition")) {
[10:21:43.407]                         if (!is.null(pattern)) {
[10:21:43.407]                           computeRestarts <- base::computeRestarts
[10:21:43.407]                           grepl <- base::grepl
[10:21:43.407]                           restarts <- computeRestarts(cond)
[10:21:43.407]                           for (restart in restarts) {
[10:21:43.407]                             name <- restart$name
[10:21:43.407]                             if (is.null(name)) 
[10:21:43.407]                               next
[10:21:43.407]                             if (!grepl(pattern, name)) 
[10:21:43.407]                               next
[10:21:43.407]                             invokeRestart(restart)
[10:21:43.407]                             muffled <- TRUE
[10:21:43.407]                             break
[10:21:43.407]                           }
[10:21:43.407]                         }
[10:21:43.407]                       }
[10:21:43.407]                       invisible(muffled)
[10:21:43.407]                     }
[10:21:43.407]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.407]                   }
[10:21:43.407]                 }
[10:21:43.407]             }
[10:21:43.407]         }))
[10:21:43.407]     }, error = function(ex) {
[10:21:43.407]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.407]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.407]                 ...future.rng), started = ...future.startTime, 
[10:21:43.407]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.407]             version = "1.8"), class = "FutureResult")
[10:21:43.407]     }, finally = {
[10:21:43.407]         if (!identical(...future.workdir, getwd())) 
[10:21:43.407]             setwd(...future.workdir)
[10:21:43.407]         {
[10:21:43.407]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.407]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.407]             }
[10:21:43.407]             base::options(...future.oldOptions)
[10:21:43.407]             if (.Platform$OS.type == "windows") {
[10:21:43.407]                 old_names <- names(...future.oldEnvVars)
[10:21:43.407]                 envs <- base::Sys.getenv()
[10:21:43.407]                 names <- names(envs)
[10:21:43.407]                 common <- intersect(names, old_names)
[10:21:43.407]                 added <- setdiff(names, old_names)
[10:21:43.407]                 removed <- setdiff(old_names, names)
[10:21:43.407]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.407]                   envs[common]]
[10:21:43.407]                 NAMES <- toupper(changed)
[10:21:43.407]                 args <- list()
[10:21:43.407]                 for (kk in seq_along(NAMES)) {
[10:21:43.407]                   name <- changed[[kk]]
[10:21:43.407]                   NAME <- NAMES[[kk]]
[10:21:43.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.407]                     next
[10:21:43.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.407]                 }
[10:21:43.407]                 NAMES <- toupper(added)
[10:21:43.407]                 for (kk in seq_along(NAMES)) {
[10:21:43.407]                   name <- added[[kk]]
[10:21:43.407]                   NAME <- NAMES[[kk]]
[10:21:43.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.407]                     next
[10:21:43.407]                   args[[name]] <- ""
[10:21:43.407]                 }
[10:21:43.407]                 NAMES <- toupper(removed)
[10:21:43.407]                 for (kk in seq_along(NAMES)) {
[10:21:43.407]                   name <- removed[[kk]]
[10:21:43.407]                   NAME <- NAMES[[kk]]
[10:21:43.407]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.407]                     next
[10:21:43.407]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.407]                 }
[10:21:43.407]                 if (length(args) > 0) 
[10:21:43.407]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.407]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.407]             }
[10:21:43.407]             else {
[10:21:43.407]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.407]             }
[10:21:43.407]             {
[10:21:43.407]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.407]                   0L) {
[10:21:43.407]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.407]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.407]                   base::options(opts)
[10:21:43.407]                 }
[10:21:43.407]                 {
[10:21:43.407]                   {
[10:21:43.407]                     NULL
[10:21:43.407]                     RNGkind("Mersenne-Twister")
[10:21:43.407]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.407]                       inherits = FALSE)
[10:21:43.407]                   }
[10:21:43.407]                   options(future.plan = NULL)
[10:21:43.407]                   if (is.na(NA_character_)) 
[10:21:43.407]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.407]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.407]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.407]                     .init = FALSE)
[10:21:43.407]                 }
[10:21:43.407]             }
[10:21:43.407]         }
[10:21:43.407]     })
[10:21:43.407]     if (TRUE) {
[10:21:43.407]         base::sink(type = "output", split = FALSE)
[10:21:43.407]         if (TRUE) {
[10:21:43.407]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.407]         }
[10:21:43.407]         else {
[10:21:43.407]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.407]         }
[10:21:43.407]         base::close(...future.stdout)
[10:21:43.407]         ...future.stdout <- NULL
[10:21:43.407]     }
[10:21:43.407]     ...future.result$conditions <- ...future.conditions
[10:21:43.407]     ...future.result$finished <- base::Sys.time()
[10:21:43.407]     ...future.result
[10:21:43.407] }
[10:21:43.410] assign_globals() ...
[10:21:43.410] List of 1
[10:21:43.410]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18c800160> 
[10:21:43.410]  - attr(*, "where")=List of 1
[10:21:43.410]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.410]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.410]  - attr(*, "resolved")= logi TRUE
[10:21:43.410]  - attr(*, "total_size")= num 3535
[10:21:43.410]  - attr(*, "already-done")= logi TRUE
[10:21:43.440] - copied ‘a’ to environment
[10:21:43.441] assign_globals() ... done
[10:21:43.441] plan(): Setting new future strategy stack:
[10:21:43.441] List of future strategies:
[10:21:43.441] 1. sequential:
[10:21:43.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.441]    - tweaked: FALSE
[10:21:43.441]    - call: NULL
[10:21:43.441] plan(): nbrOfWorkers() = 1
[10:21:43.442] plan(): Setting new future strategy stack:
[10:21:43.442] List of future strategies:
[10:21:43.442] 1. sequential:
[10:21:43.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.442]    - tweaked: FALSE
[10:21:43.442]    - call: plan(strategy)
[10:21:43.443] plan(): nbrOfWorkers() = 1
[10:21:43.443] SequentialFuture started (and completed)
[10:21:43.443] - Launch lazy future ... done
[10:21:43.443] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.444] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.444] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.444] 
[10:21:43.444] Searching for globals ... DONE
[10:21:43.444] - globals: [0] <none>
[10:21:43.444] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.445] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.445] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.446] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.446] Searching for globals ... DONE
[10:21:43.446] Resolving globals: TRUE
[10:21:43.446] Resolving any globals that are futures ...
[10:21:43.446] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.446] Resolving any globals that are futures ... DONE
[10:21:43.446] Resolving futures part of globals (recursively) ...
[10:21:43.447] resolve() on list ...
[10:21:43.447]  recursive: 99
[10:21:43.447]  length: 1
[10:21:43.447]  elements: ‘a’
[10:21:43.447] run() for ‘Future’ ...
[10:21:43.447] - state: ‘created’
[10:21:43.447] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.448] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.448] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.448]   - Field: ‘label’
[10:21:43.448]   - Field: ‘local’
[10:21:43.448]   - Field: ‘owner’
[10:21:43.448]   - Field: ‘envir’
[10:21:43.448]   - Field: ‘packages’
[10:21:43.448]   - Field: ‘gc’
[10:21:43.448]   - Field: ‘conditions’
[10:21:43.448]   - Field: ‘expr’
[10:21:43.448]   - Field: ‘uuid’
[10:21:43.449]   - Field: ‘seed’
[10:21:43.449]   - Field: ‘version’
[10:21:43.449]   - Field: ‘result’
[10:21:43.449]   - Field: ‘asynchronous’
[10:21:43.449]   - Field: ‘calls’
[10:21:43.449]   - Field: ‘globals’
[10:21:43.449]   - Field: ‘stdout’
[10:21:43.449]   - Field: ‘earlySignal’
[10:21:43.449]   - Field: ‘lazy’
[10:21:43.449]   - Field: ‘state’
[10:21:43.449] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.449] - Launch lazy future ...
[10:21:43.450] Packages needed by the future expression (n = 0): <none>
[10:21:43.450] Packages needed by future strategies (n = 0): <none>
[10:21:43.450] {
[10:21:43.450]     {
[10:21:43.450]         {
[10:21:43.450]             ...future.startTime <- base::Sys.time()
[10:21:43.450]             {
[10:21:43.450]                 {
[10:21:43.450]                   {
[10:21:43.450]                     base::local({
[10:21:43.450]                       has_future <- base::requireNamespace("future", 
[10:21:43.450]                         quietly = TRUE)
[10:21:43.450]                       if (has_future) {
[10:21:43.450]                         ns <- base::getNamespace("future")
[10:21:43.450]                         version <- ns[[".package"]][["version"]]
[10:21:43.450]                         if (is.null(version)) 
[10:21:43.450]                           version <- utils::packageVersion("future")
[10:21:43.450]                       }
[10:21:43.450]                       else {
[10:21:43.450]                         version <- NULL
[10:21:43.450]                       }
[10:21:43.450]                       if (!has_future || version < "1.8.0") {
[10:21:43.450]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.450]                           "", base::R.version$version.string), 
[10:21:43.450]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.450]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.450]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.450]                             "release", "version")], collapse = " "), 
[10:21:43.450]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.450]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.450]                           info)
[10:21:43.450]                         info <- base::paste(info, collapse = "; ")
[10:21:43.450]                         if (!has_future) {
[10:21:43.450]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.450]                             info)
[10:21:43.450]                         }
[10:21:43.450]                         else {
[10:21:43.450]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.450]                             info, version)
[10:21:43.450]                         }
[10:21:43.450]                         base::stop(msg)
[10:21:43.450]                       }
[10:21:43.450]                     })
[10:21:43.450]                   }
[10:21:43.450]                   ...future.strategy.old <- future::plan("list")
[10:21:43.450]                   options(future.plan = NULL)
[10:21:43.450]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.450]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.450]                 }
[10:21:43.450]                 ...future.workdir <- getwd()
[10:21:43.450]             }
[10:21:43.450]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.450]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.450]         }
[10:21:43.450]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.450]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.450]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.450]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.450]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.450]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.450]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.450]             base::names(...future.oldOptions))
[10:21:43.450]     }
[10:21:43.450]     if (FALSE) {
[10:21:43.450]     }
[10:21:43.450]     else {
[10:21:43.450]         if (TRUE) {
[10:21:43.450]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.450]                 open = "w")
[10:21:43.450]         }
[10:21:43.450]         else {
[10:21:43.450]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.450]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.450]         }
[10:21:43.450]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.450]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.450]             base::sink(type = "output", split = FALSE)
[10:21:43.450]             base::close(...future.stdout)
[10:21:43.450]         }, add = TRUE)
[10:21:43.450]     }
[10:21:43.450]     ...future.frame <- base::sys.nframe()
[10:21:43.450]     ...future.conditions <- base::list()
[10:21:43.450]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.450]     if (FALSE) {
[10:21:43.450]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.450]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.450]     }
[10:21:43.450]     ...future.result <- base::tryCatch({
[10:21:43.450]         base::withCallingHandlers({
[10:21:43.450]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.450]             future::FutureResult(value = ...future.value$value, 
[10:21:43.450]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.450]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.450]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.450]                     ...future.globalenv.names))
[10:21:43.450]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.450]         }, condition = base::local({
[10:21:43.450]             c <- base::c
[10:21:43.450]             inherits <- base::inherits
[10:21:43.450]             invokeRestart <- base::invokeRestart
[10:21:43.450]             length <- base::length
[10:21:43.450]             list <- base::list
[10:21:43.450]             seq.int <- base::seq.int
[10:21:43.450]             signalCondition <- base::signalCondition
[10:21:43.450]             sys.calls <- base::sys.calls
[10:21:43.450]             `[[` <- base::`[[`
[10:21:43.450]             `+` <- base::`+`
[10:21:43.450]             `<<-` <- base::`<<-`
[10:21:43.450]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.450]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.450]                   3L)]
[10:21:43.450]             }
[10:21:43.450]             function(cond) {
[10:21:43.450]                 is_error <- inherits(cond, "error")
[10:21:43.450]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.450]                   NULL)
[10:21:43.450]                 if (is_error) {
[10:21:43.450]                   sessionInformation <- function() {
[10:21:43.450]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.450]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.450]                       search = base::search(), system = base::Sys.info())
[10:21:43.450]                   }
[10:21:43.450]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.450]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.450]                     cond$call), session = sessionInformation(), 
[10:21:43.450]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.450]                   signalCondition(cond)
[10:21:43.450]                 }
[10:21:43.450]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.450]                 "immediateCondition"))) {
[10:21:43.450]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.450]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.450]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.450]                   if (TRUE && !signal) {
[10:21:43.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.450]                     {
[10:21:43.450]                       inherits <- base::inherits
[10:21:43.450]                       invokeRestart <- base::invokeRestart
[10:21:43.450]                       is.null <- base::is.null
[10:21:43.450]                       muffled <- FALSE
[10:21:43.450]                       if (inherits(cond, "message")) {
[10:21:43.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.450]                         if (muffled) 
[10:21:43.450]                           invokeRestart("muffleMessage")
[10:21:43.450]                       }
[10:21:43.450]                       else if (inherits(cond, "warning")) {
[10:21:43.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.450]                         if (muffled) 
[10:21:43.450]                           invokeRestart("muffleWarning")
[10:21:43.450]                       }
[10:21:43.450]                       else if (inherits(cond, "condition")) {
[10:21:43.450]                         if (!is.null(pattern)) {
[10:21:43.450]                           computeRestarts <- base::computeRestarts
[10:21:43.450]                           grepl <- base::grepl
[10:21:43.450]                           restarts <- computeRestarts(cond)
[10:21:43.450]                           for (restart in restarts) {
[10:21:43.450]                             name <- restart$name
[10:21:43.450]                             if (is.null(name)) 
[10:21:43.450]                               next
[10:21:43.450]                             if (!grepl(pattern, name)) 
[10:21:43.450]                               next
[10:21:43.450]                             invokeRestart(restart)
[10:21:43.450]                             muffled <- TRUE
[10:21:43.450]                             break
[10:21:43.450]                           }
[10:21:43.450]                         }
[10:21:43.450]                       }
[10:21:43.450]                       invisible(muffled)
[10:21:43.450]                     }
[10:21:43.450]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.450]                   }
[10:21:43.450]                 }
[10:21:43.450]                 else {
[10:21:43.450]                   if (TRUE) {
[10:21:43.450]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.450]                     {
[10:21:43.450]                       inherits <- base::inherits
[10:21:43.450]                       invokeRestart <- base::invokeRestart
[10:21:43.450]                       is.null <- base::is.null
[10:21:43.450]                       muffled <- FALSE
[10:21:43.450]                       if (inherits(cond, "message")) {
[10:21:43.450]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.450]                         if (muffled) 
[10:21:43.450]                           invokeRestart("muffleMessage")
[10:21:43.450]                       }
[10:21:43.450]                       else if (inherits(cond, "warning")) {
[10:21:43.450]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.450]                         if (muffled) 
[10:21:43.450]                           invokeRestart("muffleWarning")
[10:21:43.450]                       }
[10:21:43.450]                       else if (inherits(cond, "condition")) {
[10:21:43.450]                         if (!is.null(pattern)) {
[10:21:43.450]                           computeRestarts <- base::computeRestarts
[10:21:43.450]                           grepl <- base::grepl
[10:21:43.450]                           restarts <- computeRestarts(cond)
[10:21:43.450]                           for (restart in restarts) {
[10:21:43.450]                             name <- restart$name
[10:21:43.450]                             if (is.null(name)) 
[10:21:43.450]                               next
[10:21:43.450]                             if (!grepl(pattern, name)) 
[10:21:43.450]                               next
[10:21:43.450]                             invokeRestart(restart)
[10:21:43.450]                             muffled <- TRUE
[10:21:43.450]                             break
[10:21:43.450]                           }
[10:21:43.450]                         }
[10:21:43.450]                       }
[10:21:43.450]                       invisible(muffled)
[10:21:43.450]                     }
[10:21:43.450]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.450]                   }
[10:21:43.450]                 }
[10:21:43.450]             }
[10:21:43.450]         }))
[10:21:43.450]     }, error = function(ex) {
[10:21:43.450]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.450]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.450]                 ...future.rng), started = ...future.startTime, 
[10:21:43.450]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.450]             version = "1.8"), class = "FutureResult")
[10:21:43.450]     }, finally = {
[10:21:43.450]         if (!identical(...future.workdir, getwd())) 
[10:21:43.450]             setwd(...future.workdir)
[10:21:43.450]         {
[10:21:43.450]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.450]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.450]             }
[10:21:43.450]             base::options(...future.oldOptions)
[10:21:43.450]             if (.Platform$OS.type == "windows") {
[10:21:43.450]                 old_names <- names(...future.oldEnvVars)
[10:21:43.450]                 envs <- base::Sys.getenv()
[10:21:43.450]                 names <- names(envs)
[10:21:43.450]                 common <- intersect(names, old_names)
[10:21:43.450]                 added <- setdiff(names, old_names)
[10:21:43.450]                 removed <- setdiff(old_names, names)
[10:21:43.450]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.450]                   envs[common]]
[10:21:43.450]                 NAMES <- toupper(changed)
[10:21:43.450]                 args <- list()
[10:21:43.450]                 for (kk in seq_along(NAMES)) {
[10:21:43.450]                   name <- changed[[kk]]
[10:21:43.450]                   NAME <- NAMES[[kk]]
[10:21:43.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.450]                     next
[10:21:43.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.450]                 }
[10:21:43.450]                 NAMES <- toupper(added)
[10:21:43.450]                 for (kk in seq_along(NAMES)) {
[10:21:43.450]                   name <- added[[kk]]
[10:21:43.450]                   NAME <- NAMES[[kk]]
[10:21:43.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.450]                     next
[10:21:43.450]                   args[[name]] <- ""
[10:21:43.450]                 }
[10:21:43.450]                 NAMES <- toupper(removed)
[10:21:43.450]                 for (kk in seq_along(NAMES)) {
[10:21:43.450]                   name <- removed[[kk]]
[10:21:43.450]                   NAME <- NAMES[[kk]]
[10:21:43.450]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.450]                     next
[10:21:43.450]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.450]                 }
[10:21:43.450]                 if (length(args) > 0) 
[10:21:43.450]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.450]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.450]             }
[10:21:43.450]             else {
[10:21:43.450]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.450]             }
[10:21:43.450]             {
[10:21:43.450]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.450]                   0L) {
[10:21:43.450]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.450]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.450]                   base::options(opts)
[10:21:43.450]                 }
[10:21:43.450]                 {
[10:21:43.450]                   {
[10:21:43.450]                     NULL
[10:21:43.450]                     RNGkind("Mersenne-Twister")
[10:21:43.450]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.450]                       inherits = FALSE)
[10:21:43.450]                   }
[10:21:43.450]                   options(future.plan = NULL)
[10:21:43.450]                   if (is.na(NA_character_)) 
[10:21:43.450]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.450]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.450]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.450]                     .init = FALSE)
[10:21:43.450]                 }
[10:21:43.450]             }
[10:21:43.450]         }
[10:21:43.450]     })
[10:21:43.450]     if (TRUE) {
[10:21:43.450]         base::sink(type = "output", split = FALSE)
[10:21:43.450]         if (TRUE) {
[10:21:43.450]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.450]         }
[10:21:43.450]         else {
[10:21:43.450]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.450]         }
[10:21:43.450]         base::close(...future.stdout)
[10:21:43.450]         ...future.stdout <- NULL
[10:21:43.450]     }
[10:21:43.450]     ...future.result$conditions <- ...future.conditions
[10:21:43.450]     ...future.result$finished <- base::Sys.time()
[10:21:43.450]     ...future.result
[10:21:43.450] }
[10:21:43.452] plan(): Setting new future strategy stack:
[10:21:43.452] List of future strategies:
[10:21:43.452] 1. sequential:
[10:21:43.452]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.452]    - tweaked: FALSE
[10:21:43.452]    - call: NULL
[10:21:43.452] plan(): nbrOfWorkers() = 1
[10:21:43.453] plan(): Setting new future strategy stack:
[10:21:43.453] List of future strategies:
[10:21:43.453] 1. sequential:
[10:21:43.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.453]    - tweaked: FALSE
[10:21:43.453]    - call: plan(strategy)
[10:21:43.454] plan(): nbrOfWorkers() = 1
[10:21:43.454] SequentialFuture started (and completed)
[10:21:43.454] - Launch lazy future ... done
[10:21:43.454] run() for ‘SequentialFuture’ ... done
[10:21:43.454] resolved() for ‘SequentialFuture’ ...
[10:21:43.454] - state: ‘finished’
[10:21:43.454] - run: TRUE
[10:21:43.455] - result: ‘FutureResult’
[10:21:43.455] resolved() for ‘SequentialFuture’ ... done
[10:21:43.455] Future #1
[10:21:43.455] resolved() for ‘SequentialFuture’ ...
[10:21:43.455] - state: ‘finished’
[10:21:43.455] - run: TRUE
[10:21:43.455] - result: ‘FutureResult’
[10:21:43.455] resolved() for ‘SequentialFuture’ ... done
[10:21:43.455] A SequentialFuture was resolved
[10:21:43.455]  length: 0 (resolved future 1)
[10:21:43.456] resolve() on list ... DONE
[10:21:43.456] - globals: [1] ‘a’
[10:21:43.456] Resolving futures part of globals (recursively) ... DONE
[10:21:43.456] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[10:21:43.456] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[10:21:43.456] - globals: [1] ‘a’
[10:21:43.456] - packages: [1] ‘future’
[10:21:43.457] getGlobalsAndPackages() ... DONE
[10:21:43.457] run() for ‘Future’ ...
[10:21:43.457] - state: ‘created’
[10:21:43.457] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.457] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.457] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.457]   - Field: ‘label’
[10:21:43.458]   - Field: ‘local’
[10:21:43.458]   - Field: ‘owner’
[10:21:43.458]   - Field: ‘envir’
[10:21:43.458]   - Field: ‘packages’
[10:21:43.458]   - Field: ‘gc’
[10:21:43.458]   - Field: ‘conditions’
[10:21:43.458]   - Field: ‘expr’
[10:21:43.458]   - Field: ‘uuid’
[10:21:43.458]   - Field: ‘seed’
[10:21:43.458]   - Field: ‘version’
[10:21:43.458]   - Field: ‘result’
[10:21:43.458]   - Field: ‘asynchronous’
[10:21:43.459]   - Field: ‘calls’
[10:21:43.459]   - Field: ‘globals’
[10:21:43.459]   - Field: ‘stdout’
[10:21:43.459]   - Field: ‘earlySignal’
[10:21:43.459]   - Field: ‘lazy’
[10:21:43.459]   - Field: ‘state’
[10:21:43.459] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.459] - Launch lazy future ...
[10:21:43.459] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.459] Packages needed by future strategies (n = 0): <none>
[10:21:43.460] {
[10:21:43.460]     {
[10:21:43.460]         {
[10:21:43.460]             ...future.startTime <- base::Sys.time()
[10:21:43.460]             {
[10:21:43.460]                 {
[10:21:43.460]                   {
[10:21:43.460]                     {
[10:21:43.460]                       base::local({
[10:21:43.460]                         has_future <- base::requireNamespace("future", 
[10:21:43.460]                           quietly = TRUE)
[10:21:43.460]                         if (has_future) {
[10:21:43.460]                           ns <- base::getNamespace("future")
[10:21:43.460]                           version <- ns[[".package"]][["version"]]
[10:21:43.460]                           if (is.null(version)) 
[10:21:43.460]                             version <- utils::packageVersion("future")
[10:21:43.460]                         }
[10:21:43.460]                         else {
[10:21:43.460]                           version <- NULL
[10:21:43.460]                         }
[10:21:43.460]                         if (!has_future || version < "1.8.0") {
[10:21:43.460]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.460]                             "", base::R.version$version.string), 
[10:21:43.460]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.460]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.460]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.460]                               "release", "version")], collapse = " "), 
[10:21:43.460]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.460]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.460]                             info)
[10:21:43.460]                           info <- base::paste(info, collapse = "; ")
[10:21:43.460]                           if (!has_future) {
[10:21:43.460]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.460]                               info)
[10:21:43.460]                           }
[10:21:43.460]                           else {
[10:21:43.460]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.460]                               info, version)
[10:21:43.460]                           }
[10:21:43.460]                           base::stop(msg)
[10:21:43.460]                         }
[10:21:43.460]                       })
[10:21:43.460]                     }
[10:21:43.460]                     base::local({
[10:21:43.460]                       for (pkg in "future") {
[10:21:43.460]                         base::loadNamespace(pkg)
[10:21:43.460]                         base::library(pkg, character.only = TRUE)
[10:21:43.460]                       }
[10:21:43.460]                     })
[10:21:43.460]                   }
[10:21:43.460]                   ...future.strategy.old <- future::plan("list")
[10:21:43.460]                   options(future.plan = NULL)
[10:21:43.460]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.460]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.460]                 }
[10:21:43.460]                 ...future.workdir <- getwd()
[10:21:43.460]             }
[10:21:43.460]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.460]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.460]         }
[10:21:43.460]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.460]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.460]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.460]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.460]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.460]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.460]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.460]             base::names(...future.oldOptions))
[10:21:43.460]     }
[10:21:43.460]     if (FALSE) {
[10:21:43.460]     }
[10:21:43.460]     else {
[10:21:43.460]         if (TRUE) {
[10:21:43.460]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.460]                 open = "w")
[10:21:43.460]         }
[10:21:43.460]         else {
[10:21:43.460]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.460]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.460]         }
[10:21:43.460]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.460]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.460]             base::sink(type = "output", split = FALSE)
[10:21:43.460]             base::close(...future.stdout)
[10:21:43.460]         }, add = TRUE)
[10:21:43.460]     }
[10:21:43.460]     ...future.frame <- base::sys.nframe()
[10:21:43.460]     ...future.conditions <- base::list()
[10:21:43.460]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.460]     if (FALSE) {
[10:21:43.460]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.460]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.460]     }
[10:21:43.460]     ...future.result <- base::tryCatch({
[10:21:43.460]         base::withCallingHandlers({
[10:21:43.460]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.460]                 1))
[10:21:43.460]             future::FutureResult(value = ...future.value$value, 
[10:21:43.460]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.460]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.460]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.460]                     ...future.globalenv.names))
[10:21:43.460]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.460]         }, condition = base::local({
[10:21:43.460]             c <- base::c
[10:21:43.460]             inherits <- base::inherits
[10:21:43.460]             invokeRestart <- base::invokeRestart
[10:21:43.460]             length <- base::length
[10:21:43.460]             list <- base::list
[10:21:43.460]             seq.int <- base::seq.int
[10:21:43.460]             signalCondition <- base::signalCondition
[10:21:43.460]             sys.calls <- base::sys.calls
[10:21:43.460]             `[[` <- base::`[[`
[10:21:43.460]             `+` <- base::`+`
[10:21:43.460]             `<<-` <- base::`<<-`
[10:21:43.460]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.460]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.460]                   3L)]
[10:21:43.460]             }
[10:21:43.460]             function(cond) {
[10:21:43.460]                 is_error <- inherits(cond, "error")
[10:21:43.460]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.460]                   NULL)
[10:21:43.460]                 if (is_error) {
[10:21:43.460]                   sessionInformation <- function() {
[10:21:43.460]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.460]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.460]                       search = base::search(), system = base::Sys.info())
[10:21:43.460]                   }
[10:21:43.460]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.460]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.460]                     cond$call), session = sessionInformation(), 
[10:21:43.460]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.460]                   signalCondition(cond)
[10:21:43.460]                 }
[10:21:43.460]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.460]                 "immediateCondition"))) {
[10:21:43.460]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.460]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.460]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.460]                   if (TRUE && !signal) {
[10:21:43.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.460]                     {
[10:21:43.460]                       inherits <- base::inherits
[10:21:43.460]                       invokeRestart <- base::invokeRestart
[10:21:43.460]                       is.null <- base::is.null
[10:21:43.460]                       muffled <- FALSE
[10:21:43.460]                       if (inherits(cond, "message")) {
[10:21:43.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.460]                         if (muffled) 
[10:21:43.460]                           invokeRestart("muffleMessage")
[10:21:43.460]                       }
[10:21:43.460]                       else if (inherits(cond, "warning")) {
[10:21:43.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.460]                         if (muffled) 
[10:21:43.460]                           invokeRestart("muffleWarning")
[10:21:43.460]                       }
[10:21:43.460]                       else if (inherits(cond, "condition")) {
[10:21:43.460]                         if (!is.null(pattern)) {
[10:21:43.460]                           computeRestarts <- base::computeRestarts
[10:21:43.460]                           grepl <- base::grepl
[10:21:43.460]                           restarts <- computeRestarts(cond)
[10:21:43.460]                           for (restart in restarts) {
[10:21:43.460]                             name <- restart$name
[10:21:43.460]                             if (is.null(name)) 
[10:21:43.460]                               next
[10:21:43.460]                             if (!grepl(pattern, name)) 
[10:21:43.460]                               next
[10:21:43.460]                             invokeRestart(restart)
[10:21:43.460]                             muffled <- TRUE
[10:21:43.460]                             break
[10:21:43.460]                           }
[10:21:43.460]                         }
[10:21:43.460]                       }
[10:21:43.460]                       invisible(muffled)
[10:21:43.460]                     }
[10:21:43.460]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.460]                   }
[10:21:43.460]                 }
[10:21:43.460]                 else {
[10:21:43.460]                   if (TRUE) {
[10:21:43.460]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.460]                     {
[10:21:43.460]                       inherits <- base::inherits
[10:21:43.460]                       invokeRestart <- base::invokeRestart
[10:21:43.460]                       is.null <- base::is.null
[10:21:43.460]                       muffled <- FALSE
[10:21:43.460]                       if (inherits(cond, "message")) {
[10:21:43.460]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.460]                         if (muffled) 
[10:21:43.460]                           invokeRestart("muffleMessage")
[10:21:43.460]                       }
[10:21:43.460]                       else if (inherits(cond, "warning")) {
[10:21:43.460]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.460]                         if (muffled) 
[10:21:43.460]                           invokeRestart("muffleWarning")
[10:21:43.460]                       }
[10:21:43.460]                       else if (inherits(cond, "condition")) {
[10:21:43.460]                         if (!is.null(pattern)) {
[10:21:43.460]                           computeRestarts <- base::computeRestarts
[10:21:43.460]                           grepl <- base::grepl
[10:21:43.460]                           restarts <- computeRestarts(cond)
[10:21:43.460]                           for (restart in restarts) {
[10:21:43.460]                             name <- restart$name
[10:21:43.460]                             if (is.null(name)) 
[10:21:43.460]                               next
[10:21:43.460]                             if (!grepl(pattern, name)) 
[10:21:43.460]                               next
[10:21:43.460]                             invokeRestart(restart)
[10:21:43.460]                             muffled <- TRUE
[10:21:43.460]                             break
[10:21:43.460]                           }
[10:21:43.460]                         }
[10:21:43.460]                       }
[10:21:43.460]                       invisible(muffled)
[10:21:43.460]                     }
[10:21:43.460]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.460]                   }
[10:21:43.460]                 }
[10:21:43.460]             }
[10:21:43.460]         }))
[10:21:43.460]     }, error = function(ex) {
[10:21:43.460]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.460]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.460]                 ...future.rng), started = ...future.startTime, 
[10:21:43.460]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.460]             version = "1.8"), class = "FutureResult")
[10:21:43.460]     }, finally = {
[10:21:43.460]         if (!identical(...future.workdir, getwd())) 
[10:21:43.460]             setwd(...future.workdir)
[10:21:43.460]         {
[10:21:43.460]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.460]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.460]             }
[10:21:43.460]             base::options(...future.oldOptions)
[10:21:43.460]             if (.Platform$OS.type == "windows") {
[10:21:43.460]                 old_names <- names(...future.oldEnvVars)
[10:21:43.460]                 envs <- base::Sys.getenv()
[10:21:43.460]                 names <- names(envs)
[10:21:43.460]                 common <- intersect(names, old_names)
[10:21:43.460]                 added <- setdiff(names, old_names)
[10:21:43.460]                 removed <- setdiff(old_names, names)
[10:21:43.460]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.460]                   envs[common]]
[10:21:43.460]                 NAMES <- toupper(changed)
[10:21:43.460]                 args <- list()
[10:21:43.460]                 for (kk in seq_along(NAMES)) {
[10:21:43.460]                   name <- changed[[kk]]
[10:21:43.460]                   NAME <- NAMES[[kk]]
[10:21:43.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.460]                     next
[10:21:43.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.460]                 }
[10:21:43.460]                 NAMES <- toupper(added)
[10:21:43.460]                 for (kk in seq_along(NAMES)) {
[10:21:43.460]                   name <- added[[kk]]
[10:21:43.460]                   NAME <- NAMES[[kk]]
[10:21:43.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.460]                     next
[10:21:43.460]                   args[[name]] <- ""
[10:21:43.460]                 }
[10:21:43.460]                 NAMES <- toupper(removed)
[10:21:43.460]                 for (kk in seq_along(NAMES)) {
[10:21:43.460]                   name <- removed[[kk]]
[10:21:43.460]                   NAME <- NAMES[[kk]]
[10:21:43.460]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.460]                     next
[10:21:43.460]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.460]                 }
[10:21:43.460]                 if (length(args) > 0) 
[10:21:43.460]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.460]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.460]             }
[10:21:43.460]             else {
[10:21:43.460]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.460]             }
[10:21:43.460]             {
[10:21:43.460]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.460]                   0L) {
[10:21:43.460]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.460]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.460]                   base::options(opts)
[10:21:43.460]                 }
[10:21:43.460]                 {
[10:21:43.460]                   {
[10:21:43.460]                     NULL
[10:21:43.460]                     RNGkind("Mersenne-Twister")
[10:21:43.460]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.460]                       inherits = FALSE)
[10:21:43.460]                   }
[10:21:43.460]                   options(future.plan = NULL)
[10:21:43.460]                   if (is.na(NA_character_)) 
[10:21:43.460]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.460]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.460]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.460]                     .init = FALSE)
[10:21:43.460]                 }
[10:21:43.460]             }
[10:21:43.460]         }
[10:21:43.460]     })
[10:21:43.460]     if (TRUE) {
[10:21:43.460]         base::sink(type = "output", split = FALSE)
[10:21:43.460]         if (TRUE) {
[10:21:43.460]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.460]         }
[10:21:43.460]         else {
[10:21:43.460]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.460]         }
[10:21:43.460]         base::close(...future.stdout)
[10:21:43.460]         ...future.stdout <- NULL
[10:21:43.460]     }
[10:21:43.460]     ...future.result$conditions <- ...future.conditions
[10:21:43.460]     ...future.result$finished <- base::Sys.time()
[10:21:43.460]     ...future.result
[10:21:43.460] }
[10:21:43.462] assign_globals() ...
[10:21:43.462] List of 1
[10:21:43.462]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18c369108> 
[10:21:43.462]  - attr(*, "where")=List of 1
[10:21:43.462]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.462]  - attr(*, "resolved")= logi TRUE
[10:21:43.462]  - attr(*, "total_size")= num 3555
[10:21:43.462]  - attr(*, "already-done")= logi TRUE
[10:21:43.464] - copied ‘a’ to environment
[10:21:43.464] assign_globals() ... done
[10:21:43.464] plan(): Setting new future strategy stack:
[10:21:43.464] List of future strategies:
[10:21:43.464] 1. sequential:
[10:21:43.464]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.464]    - tweaked: FALSE
[10:21:43.464]    - call: NULL
[10:21:43.465] plan(): nbrOfWorkers() = 1
[10:21:43.466] plan(): Setting new future strategy stack:
[10:21:43.466] List of future strategies:
[10:21:43.466] 1. sequential:
[10:21:43.466]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.466]    - tweaked: FALSE
[10:21:43.466]    - call: plan(strategy)
[10:21:43.466] plan(): nbrOfWorkers() = 1
[10:21:43.468] SequentialFuture started (and completed)
[10:21:43.468] - Launch lazy future ... done
[10:21:43.468] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.468] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.468] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.469] 
[10:21:43.469] Searching for globals ... DONE
[10:21:43.469] - globals: [0] <none>
[10:21:43.469] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.469] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.470] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.470] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.471] Searching for globals ... DONE
[10:21:43.471] Resolving globals: TRUE
[10:21:43.471] Resolving any globals that are futures ...
[10:21:43.471] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.471] Resolving any globals that are futures ... DONE
[10:21:43.471] Resolving futures part of globals (recursively) ...
[10:21:43.471] resolve() on list ...
[10:21:43.471]  recursive: 99
[10:21:43.472]  length: 1
[10:21:43.472]  elements: ‘a’
[10:21:43.472] run() for ‘Future’ ...
[10:21:43.472] - state: ‘created’
[10:21:43.472] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.472] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.472] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.472]   - Field: ‘label’
[10:21:43.473]   - Field: ‘local’
[10:21:43.473]   - Field: ‘owner’
[10:21:43.473]   - Field: ‘envir’
[10:21:43.473]   - Field: ‘packages’
[10:21:43.473]   - Field: ‘gc’
[10:21:43.473]   - Field: ‘conditions’
[10:21:43.473]   - Field: ‘expr’
[10:21:43.473]   - Field: ‘uuid’
[10:21:43.473]   - Field: ‘seed’
[10:21:43.473]   - Field: ‘version’
[10:21:43.473]   - Field: ‘result’
[10:21:43.473]   - Field: ‘asynchronous’
[10:21:43.474]   - Field: ‘calls’
[10:21:43.474]   - Field: ‘globals’
[10:21:43.474]   - Field: ‘stdout’
[10:21:43.474]   - Field: ‘earlySignal’
[10:21:43.474]   - Field: ‘lazy’
[10:21:43.474]   - Field: ‘state’
[10:21:43.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.474] - Launch lazy future ...
[10:21:43.474] Packages needed by the future expression (n = 0): <none>
[10:21:43.474] Packages needed by future strategies (n = 0): <none>
[10:21:43.475] {
[10:21:43.475]     {
[10:21:43.475]         {
[10:21:43.475]             ...future.startTime <- base::Sys.time()
[10:21:43.475]             {
[10:21:43.475]                 {
[10:21:43.475]                   {
[10:21:43.475]                     base::local({
[10:21:43.475]                       has_future <- base::requireNamespace("future", 
[10:21:43.475]                         quietly = TRUE)
[10:21:43.475]                       if (has_future) {
[10:21:43.475]                         ns <- base::getNamespace("future")
[10:21:43.475]                         version <- ns[[".package"]][["version"]]
[10:21:43.475]                         if (is.null(version)) 
[10:21:43.475]                           version <- utils::packageVersion("future")
[10:21:43.475]                       }
[10:21:43.475]                       else {
[10:21:43.475]                         version <- NULL
[10:21:43.475]                       }
[10:21:43.475]                       if (!has_future || version < "1.8.0") {
[10:21:43.475]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.475]                           "", base::R.version$version.string), 
[10:21:43.475]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.475]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.475]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.475]                             "release", "version")], collapse = " "), 
[10:21:43.475]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.475]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.475]                           info)
[10:21:43.475]                         info <- base::paste(info, collapse = "; ")
[10:21:43.475]                         if (!has_future) {
[10:21:43.475]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.475]                             info)
[10:21:43.475]                         }
[10:21:43.475]                         else {
[10:21:43.475]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.475]                             info, version)
[10:21:43.475]                         }
[10:21:43.475]                         base::stop(msg)
[10:21:43.475]                       }
[10:21:43.475]                     })
[10:21:43.475]                   }
[10:21:43.475]                   ...future.strategy.old <- future::plan("list")
[10:21:43.475]                   options(future.plan = NULL)
[10:21:43.475]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.475]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.475]                 }
[10:21:43.475]                 ...future.workdir <- getwd()
[10:21:43.475]             }
[10:21:43.475]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.475]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.475]         }
[10:21:43.475]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.475]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.475]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.475]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.475]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.475]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.475]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.475]             base::names(...future.oldOptions))
[10:21:43.475]     }
[10:21:43.475]     if (FALSE) {
[10:21:43.475]     }
[10:21:43.475]     else {
[10:21:43.475]         if (TRUE) {
[10:21:43.475]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.475]                 open = "w")
[10:21:43.475]         }
[10:21:43.475]         else {
[10:21:43.475]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.475]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.475]         }
[10:21:43.475]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.475]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.475]             base::sink(type = "output", split = FALSE)
[10:21:43.475]             base::close(...future.stdout)
[10:21:43.475]         }, add = TRUE)
[10:21:43.475]     }
[10:21:43.475]     ...future.frame <- base::sys.nframe()
[10:21:43.475]     ...future.conditions <- base::list()
[10:21:43.475]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.475]     if (FALSE) {
[10:21:43.475]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.475]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.475]     }
[10:21:43.475]     ...future.result <- base::tryCatch({
[10:21:43.475]         base::withCallingHandlers({
[10:21:43.475]             ...future.value <- base::withVisible(base::local(1))
[10:21:43.475]             future::FutureResult(value = ...future.value$value, 
[10:21:43.475]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.475]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.475]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.475]                     ...future.globalenv.names))
[10:21:43.475]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.475]         }, condition = base::local({
[10:21:43.475]             c <- base::c
[10:21:43.475]             inherits <- base::inherits
[10:21:43.475]             invokeRestart <- base::invokeRestart
[10:21:43.475]             length <- base::length
[10:21:43.475]             list <- base::list
[10:21:43.475]             seq.int <- base::seq.int
[10:21:43.475]             signalCondition <- base::signalCondition
[10:21:43.475]             sys.calls <- base::sys.calls
[10:21:43.475]             `[[` <- base::`[[`
[10:21:43.475]             `+` <- base::`+`
[10:21:43.475]             `<<-` <- base::`<<-`
[10:21:43.475]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.475]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.475]                   3L)]
[10:21:43.475]             }
[10:21:43.475]             function(cond) {
[10:21:43.475]                 is_error <- inherits(cond, "error")
[10:21:43.475]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.475]                   NULL)
[10:21:43.475]                 if (is_error) {
[10:21:43.475]                   sessionInformation <- function() {
[10:21:43.475]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.475]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.475]                       search = base::search(), system = base::Sys.info())
[10:21:43.475]                   }
[10:21:43.475]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.475]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.475]                     cond$call), session = sessionInformation(), 
[10:21:43.475]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.475]                   signalCondition(cond)
[10:21:43.475]                 }
[10:21:43.475]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.475]                 "immediateCondition"))) {
[10:21:43.475]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.475]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.475]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.475]                   if (TRUE && !signal) {
[10:21:43.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.475]                     {
[10:21:43.475]                       inherits <- base::inherits
[10:21:43.475]                       invokeRestart <- base::invokeRestart
[10:21:43.475]                       is.null <- base::is.null
[10:21:43.475]                       muffled <- FALSE
[10:21:43.475]                       if (inherits(cond, "message")) {
[10:21:43.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.475]                         if (muffled) 
[10:21:43.475]                           invokeRestart("muffleMessage")
[10:21:43.475]                       }
[10:21:43.475]                       else if (inherits(cond, "warning")) {
[10:21:43.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.475]                         if (muffled) 
[10:21:43.475]                           invokeRestart("muffleWarning")
[10:21:43.475]                       }
[10:21:43.475]                       else if (inherits(cond, "condition")) {
[10:21:43.475]                         if (!is.null(pattern)) {
[10:21:43.475]                           computeRestarts <- base::computeRestarts
[10:21:43.475]                           grepl <- base::grepl
[10:21:43.475]                           restarts <- computeRestarts(cond)
[10:21:43.475]                           for (restart in restarts) {
[10:21:43.475]                             name <- restart$name
[10:21:43.475]                             if (is.null(name)) 
[10:21:43.475]                               next
[10:21:43.475]                             if (!grepl(pattern, name)) 
[10:21:43.475]                               next
[10:21:43.475]                             invokeRestart(restart)
[10:21:43.475]                             muffled <- TRUE
[10:21:43.475]                             break
[10:21:43.475]                           }
[10:21:43.475]                         }
[10:21:43.475]                       }
[10:21:43.475]                       invisible(muffled)
[10:21:43.475]                     }
[10:21:43.475]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.475]                   }
[10:21:43.475]                 }
[10:21:43.475]                 else {
[10:21:43.475]                   if (TRUE) {
[10:21:43.475]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.475]                     {
[10:21:43.475]                       inherits <- base::inherits
[10:21:43.475]                       invokeRestart <- base::invokeRestart
[10:21:43.475]                       is.null <- base::is.null
[10:21:43.475]                       muffled <- FALSE
[10:21:43.475]                       if (inherits(cond, "message")) {
[10:21:43.475]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.475]                         if (muffled) 
[10:21:43.475]                           invokeRestart("muffleMessage")
[10:21:43.475]                       }
[10:21:43.475]                       else if (inherits(cond, "warning")) {
[10:21:43.475]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.475]                         if (muffled) 
[10:21:43.475]                           invokeRestart("muffleWarning")
[10:21:43.475]                       }
[10:21:43.475]                       else if (inherits(cond, "condition")) {
[10:21:43.475]                         if (!is.null(pattern)) {
[10:21:43.475]                           computeRestarts <- base::computeRestarts
[10:21:43.475]                           grepl <- base::grepl
[10:21:43.475]                           restarts <- computeRestarts(cond)
[10:21:43.475]                           for (restart in restarts) {
[10:21:43.475]                             name <- restart$name
[10:21:43.475]                             if (is.null(name)) 
[10:21:43.475]                               next
[10:21:43.475]                             if (!grepl(pattern, name)) 
[10:21:43.475]                               next
[10:21:43.475]                             invokeRestart(restart)
[10:21:43.475]                             muffled <- TRUE
[10:21:43.475]                             break
[10:21:43.475]                           }
[10:21:43.475]                         }
[10:21:43.475]                       }
[10:21:43.475]                       invisible(muffled)
[10:21:43.475]                     }
[10:21:43.475]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.475]                   }
[10:21:43.475]                 }
[10:21:43.475]             }
[10:21:43.475]         }))
[10:21:43.475]     }, error = function(ex) {
[10:21:43.475]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.475]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.475]                 ...future.rng), started = ...future.startTime, 
[10:21:43.475]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.475]             version = "1.8"), class = "FutureResult")
[10:21:43.475]     }, finally = {
[10:21:43.475]         if (!identical(...future.workdir, getwd())) 
[10:21:43.475]             setwd(...future.workdir)
[10:21:43.475]         {
[10:21:43.475]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.475]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.475]             }
[10:21:43.475]             base::options(...future.oldOptions)
[10:21:43.475]             if (.Platform$OS.type == "windows") {
[10:21:43.475]                 old_names <- names(...future.oldEnvVars)
[10:21:43.475]                 envs <- base::Sys.getenv()
[10:21:43.475]                 names <- names(envs)
[10:21:43.475]                 common <- intersect(names, old_names)
[10:21:43.475]                 added <- setdiff(names, old_names)
[10:21:43.475]                 removed <- setdiff(old_names, names)
[10:21:43.475]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.475]                   envs[common]]
[10:21:43.475]                 NAMES <- toupper(changed)
[10:21:43.475]                 args <- list()
[10:21:43.475]                 for (kk in seq_along(NAMES)) {
[10:21:43.475]                   name <- changed[[kk]]
[10:21:43.475]                   NAME <- NAMES[[kk]]
[10:21:43.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.475]                     next
[10:21:43.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.475]                 }
[10:21:43.475]                 NAMES <- toupper(added)
[10:21:43.475]                 for (kk in seq_along(NAMES)) {
[10:21:43.475]                   name <- added[[kk]]
[10:21:43.475]                   NAME <- NAMES[[kk]]
[10:21:43.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.475]                     next
[10:21:43.475]                   args[[name]] <- ""
[10:21:43.475]                 }
[10:21:43.475]                 NAMES <- toupper(removed)
[10:21:43.475]                 for (kk in seq_along(NAMES)) {
[10:21:43.475]                   name <- removed[[kk]]
[10:21:43.475]                   NAME <- NAMES[[kk]]
[10:21:43.475]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.475]                     next
[10:21:43.475]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.475]                 }
[10:21:43.475]                 if (length(args) > 0) 
[10:21:43.475]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.475]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.475]             }
[10:21:43.475]             else {
[10:21:43.475]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.475]             }
[10:21:43.475]             {
[10:21:43.475]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.475]                   0L) {
[10:21:43.475]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.475]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.475]                   base::options(opts)
[10:21:43.475]                 }
[10:21:43.475]                 {
[10:21:43.475]                   {
[10:21:43.475]                     NULL
[10:21:43.475]                     RNGkind("Mersenne-Twister")
[10:21:43.475]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.475]                       inherits = FALSE)
[10:21:43.475]                   }
[10:21:43.475]                   options(future.plan = NULL)
[10:21:43.475]                   if (is.na(NA_character_)) 
[10:21:43.475]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.475]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.475]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.475]                     .init = FALSE)
[10:21:43.475]                 }
[10:21:43.475]             }
[10:21:43.475]         }
[10:21:43.475]     })
[10:21:43.475]     if (TRUE) {
[10:21:43.475]         base::sink(type = "output", split = FALSE)
[10:21:43.475]         if (TRUE) {
[10:21:43.475]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.475]         }
[10:21:43.475]         else {
[10:21:43.475]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.475]         }
[10:21:43.475]         base::close(...future.stdout)
[10:21:43.475]         ...future.stdout <- NULL
[10:21:43.475]     }
[10:21:43.475]     ...future.result$conditions <- ...future.conditions
[10:21:43.475]     ...future.result$finished <- base::Sys.time()
[10:21:43.475]     ...future.result
[10:21:43.475] }
[10:21:43.477] plan(): Setting new future strategy stack:
[10:21:43.477] List of future strategies:
[10:21:43.477] 1. sequential:
[10:21:43.477]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.477]    - tweaked: FALSE
[10:21:43.477]    - call: NULL
[10:21:43.477] plan(): nbrOfWorkers() = 1
[10:21:43.478] plan(): Setting new future strategy stack:
[10:21:43.478] List of future strategies:
[10:21:43.478] 1. sequential:
[10:21:43.478]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.478]    - tweaked: FALSE
[10:21:43.478]    - call: plan(strategy)
[10:21:43.478] plan(): nbrOfWorkers() = 1
[10:21:43.478] SequentialFuture started (and completed)
[10:21:43.478] - Launch lazy future ... done
[10:21:43.479] run() for ‘SequentialFuture’ ... done
[10:21:43.479] resolved() for ‘SequentialFuture’ ...
[10:21:43.479] - state: ‘finished’
[10:21:43.479] - run: TRUE
[10:21:43.479] - result: ‘FutureResult’
[10:21:43.479] resolved() for ‘SequentialFuture’ ... done
[10:21:43.479] Future #1
[10:21:43.479] resolved() for ‘SequentialFuture’ ...
[10:21:43.479] - state: ‘finished’
[10:21:43.479] - run: TRUE
[10:21:43.480] - result: ‘FutureResult’
[10:21:43.480] resolved() for ‘SequentialFuture’ ... done
[10:21:43.480] A SequentialFuture was resolved
[10:21:43.480]  length: 0 (resolved future 1)
[10:21:43.480] resolve() on list ... DONE
[10:21:43.480] - globals: [1] ‘a’
[10:21:43.480] Resolving futures part of globals (recursively) ... DONE
[10:21:43.480] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[10:21:43.481] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[10:21:43.481] - globals: [1] ‘a’
[10:21:43.481] - packages: [1] ‘future’
[10:21:43.481] getGlobalsAndPackages() ... DONE
[10:21:43.481] run() for ‘Future’ ...
[10:21:43.481] - state: ‘created’
[10:21:43.481] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.482] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.482] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.482]   - Field: ‘label’
[10:21:43.482]   - Field: ‘local’
[10:21:43.482]   - Field: ‘owner’
[10:21:43.482]   - Field: ‘envir’
[10:21:43.482]   - Field: ‘packages’
[10:21:43.482]   - Field: ‘gc’
[10:21:43.482]   - Field: ‘conditions’
[10:21:43.482]   - Field: ‘expr’
[10:21:43.482]   - Field: ‘uuid’
[10:21:43.483]   - Field: ‘seed’
[10:21:43.483]   - Field: ‘version’
[10:21:43.483]   - Field: ‘result’
[10:21:43.483]   - Field: ‘asynchronous’
[10:21:43.483]   - Field: ‘calls’
[10:21:43.483]   - Field: ‘globals’
[10:21:43.483]   - Field: ‘stdout’
[10:21:43.483]   - Field: ‘earlySignal’
[10:21:43.483]   - Field: ‘lazy’
[10:21:43.483]   - Field: ‘state’
[10:21:43.483] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.483] - Launch lazy future ...
[10:21:43.484] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.484] Packages needed by future strategies (n = 0): <none>
[10:21:43.484] {
[10:21:43.484]     {
[10:21:43.484]         {
[10:21:43.484]             ...future.startTime <- base::Sys.time()
[10:21:43.484]             {
[10:21:43.484]                 {
[10:21:43.484]                   {
[10:21:43.484]                     {
[10:21:43.484]                       base::local({
[10:21:43.484]                         has_future <- base::requireNamespace("future", 
[10:21:43.484]                           quietly = TRUE)
[10:21:43.484]                         if (has_future) {
[10:21:43.484]                           ns <- base::getNamespace("future")
[10:21:43.484]                           version <- ns[[".package"]][["version"]]
[10:21:43.484]                           if (is.null(version)) 
[10:21:43.484]                             version <- utils::packageVersion("future")
[10:21:43.484]                         }
[10:21:43.484]                         else {
[10:21:43.484]                           version <- NULL
[10:21:43.484]                         }
[10:21:43.484]                         if (!has_future || version < "1.8.0") {
[10:21:43.484]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.484]                             "", base::R.version$version.string), 
[10:21:43.484]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.484]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.484]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.484]                               "release", "version")], collapse = " "), 
[10:21:43.484]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.484]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.484]                             info)
[10:21:43.484]                           info <- base::paste(info, collapse = "; ")
[10:21:43.484]                           if (!has_future) {
[10:21:43.484]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.484]                               info)
[10:21:43.484]                           }
[10:21:43.484]                           else {
[10:21:43.484]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.484]                               info, version)
[10:21:43.484]                           }
[10:21:43.484]                           base::stop(msg)
[10:21:43.484]                         }
[10:21:43.484]                       })
[10:21:43.484]                     }
[10:21:43.484]                     base::local({
[10:21:43.484]                       for (pkg in "future") {
[10:21:43.484]                         base::loadNamespace(pkg)
[10:21:43.484]                         base::library(pkg, character.only = TRUE)
[10:21:43.484]                       }
[10:21:43.484]                     })
[10:21:43.484]                   }
[10:21:43.484]                   ...future.strategy.old <- future::plan("list")
[10:21:43.484]                   options(future.plan = NULL)
[10:21:43.484]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.484]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.484]                 }
[10:21:43.484]                 ...future.workdir <- getwd()
[10:21:43.484]             }
[10:21:43.484]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.484]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.484]         }
[10:21:43.484]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.484]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.484]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.484]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.484]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.484]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.484]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.484]             base::names(...future.oldOptions))
[10:21:43.484]     }
[10:21:43.484]     if (FALSE) {
[10:21:43.484]     }
[10:21:43.484]     else {
[10:21:43.484]         if (TRUE) {
[10:21:43.484]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.484]                 open = "w")
[10:21:43.484]         }
[10:21:43.484]         else {
[10:21:43.484]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.484]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.484]         }
[10:21:43.484]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.484]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.484]             base::sink(type = "output", split = FALSE)
[10:21:43.484]             base::close(...future.stdout)
[10:21:43.484]         }, add = TRUE)
[10:21:43.484]     }
[10:21:43.484]     ...future.frame <- base::sys.nframe()
[10:21:43.484]     ...future.conditions <- base::list()
[10:21:43.484]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.484]     if (FALSE) {
[10:21:43.484]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.484]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.484]     }
[10:21:43.484]     ...future.result <- base::tryCatch({
[10:21:43.484]         base::withCallingHandlers({
[10:21:43.484]             ...future.value <- base::withVisible(base::local(value(a) + 
[10:21:43.484]                 1))
[10:21:43.484]             future::FutureResult(value = ...future.value$value, 
[10:21:43.484]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.484]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.484]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.484]                     ...future.globalenv.names))
[10:21:43.484]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.484]         }, condition = base::local({
[10:21:43.484]             c <- base::c
[10:21:43.484]             inherits <- base::inherits
[10:21:43.484]             invokeRestart <- base::invokeRestart
[10:21:43.484]             length <- base::length
[10:21:43.484]             list <- base::list
[10:21:43.484]             seq.int <- base::seq.int
[10:21:43.484]             signalCondition <- base::signalCondition
[10:21:43.484]             sys.calls <- base::sys.calls
[10:21:43.484]             `[[` <- base::`[[`
[10:21:43.484]             `+` <- base::`+`
[10:21:43.484]             `<<-` <- base::`<<-`
[10:21:43.484]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.484]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.484]                   3L)]
[10:21:43.484]             }
[10:21:43.484]             function(cond) {
[10:21:43.484]                 is_error <- inherits(cond, "error")
[10:21:43.484]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.484]                   NULL)
[10:21:43.484]                 if (is_error) {
[10:21:43.484]                   sessionInformation <- function() {
[10:21:43.484]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.484]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.484]                       search = base::search(), system = base::Sys.info())
[10:21:43.484]                   }
[10:21:43.484]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.484]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.484]                     cond$call), session = sessionInformation(), 
[10:21:43.484]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.484]                   signalCondition(cond)
[10:21:43.484]                 }
[10:21:43.484]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.484]                 "immediateCondition"))) {
[10:21:43.484]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.484]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.484]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.484]                   if (TRUE && !signal) {
[10:21:43.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.484]                     {
[10:21:43.484]                       inherits <- base::inherits
[10:21:43.484]                       invokeRestart <- base::invokeRestart
[10:21:43.484]                       is.null <- base::is.null
[10:21:43.484]                       muffled <- FALSE
[10:21:43.484]                       if (inherits(cond, "message")) {
[10:21:43.484]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.484]                         if (muffled) 
[10:21:43.484]                           invokeRestart("muffleMessage")
[10:21:43.484]                       }
[10:21:43.484]                       else if (inherits(cond, "warning")) {
[10:21:43.484]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.484]                         if (muffled) 
[10:21:43.484]                           invokeRestart("muffleWarning")
[10:21:43.484]                       }
[10:21:43.484]                       else if (inherits(cond, "condition")) {
[10:21:43.484]                         if (!is.null(pattern)) {
[10:21:43.484]                           computeRestarts <- base::computeRestarts
[10:21:43.484]                           grepl <- base::grepl
[10:21:43.484]                           restarts <- computeRestarts(cond)
[10:21:43.484]                           for (restart in restarts) {
[10:21:43.484]                             name <- restart$name
[10:21:43.484]                             if (is.null(name)) 
[10:21:43.484]                               next
[10:21:43.484]                             if (!grepl(pattern, name)) 
[10:21:43.484]                               next
[10:21:43.484]                             invokeRestart(restart)
[10:21:43.484]                             muffled <- TRUE
[10:21:43.484]                             break
[10:21:43.484]                           }
[10:21:43.484]                         }
[10:21:43.484]                       }
[10:21:43.484]                       invisible(muffled)
[10:21:43.484]                     }
[10:21:43.484]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.484]                   }
[10:21:43.484]                 }
[10:21:43.484]                 else {
[10:21:43.484]                   if (TRUE) {
[10:21:43.484]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.484]                     {
[10:21:43.484]                       inherits <- base::inherits
[10:21:43.484]                       invokeRestart <- base::invokeRestart
[10:21:43.484]                       is.null <- base::is.null
[10:21:43.484]                       muffled <- FALSE
[10:21:43.484]                       if (inherits(cond, "message")) {
[10:21:43.484]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.484]                         if (muffled) 
[10:21:43.484]                           invokeRestart("muffleMessage")
[10:21:43.484]                       }
[10:21:43.484]                       else if (inherits(cond, "warning")) {
[10:21:43.484]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.484]                         if (muffled) 
[10:21:43.484]                           invokeRestart("muffleWarning")
[10:21:43.484]                       }
[10:21:43.484]                       else if (inherits(cond, "condition")) {
[10:21:43.484]                         if (!is.null(pattern)) {
[10:21:43.484]                           computeRestarts <- base::computeRestarts
[10:21:43.484]                           grepl <- base::grepl
[10:21:43.484]                           restarts <- computeRestarts(cond)
[10:21:43.484]                           for (restart in restarts) {
[10:21:43.484]                             name <- restart$name
[10:21:43.484]                             if (is.null(name)) 
[10:21:43.484]                               next
[10:21:43.484]                             if (!grepl(pattern, name)) 
[10:21:43.484]                               next
[10:21:43.484]                             invokeRestart(restart)
[10:21:43.484]                             muffled <- TRUE
[10:21:43.484]                             break
[10:21:43.484]                           }
[10:21:43.484]                         }
[10:21:43.484]                       }
[10:21:43.484]                       invisible(muffled)
[10:21:43.484]                     }
[10:21:43.484]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.484]                   }
[10:21:43.484]                 }
[10:21:43.484]             }
[10:21:43.484]         }))
[10:21:43.484]     }, error = function(ex) {
[10:21:43.484]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.484]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.484]                 ...future.rng), started = ...future.startTime, 
[10:21:43.484]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.484]             version = "1.8"), class = "FutureResult")
[10:21:43.484]     }, finally = {
[10:21:43.484]         if (!identical(...future.workdir, getwd())) 
[10:21:43.484]             setwd(...future.workdir)
[10:21:43.484]         {
[10:21:43.484]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.484]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.484]             }
[10:21:43.484]             base::options(...future.oldOptions)
[10:21:43.484]             if (.Platform$OS.type == "windows") {
[10:21:43.484]                 old_names <- names(...future.oldEnvVars)
[10:21:43.484]                 envs <- base::Sys.getenv()
[10:21:43.484]                 names <- names(envs)
[10:21:43.484]                 common <- intersect(names, old_names)
[10:21:43.484]                 added <- setdiff(names, old_names)
[10:21:43.484]                 removed <- setdiff(old_names, names)
[10:21:43.484]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.484]                   envs[common]]
[10:21:43.484]                 NAMES <- toupper(changed)
[10:21:43.484]                 args <- list()
[10:21:43.484]                 for (kk in seq_along(NAMES)) {
[10:21:43.484]                   name <- changed[[kk]]
[10:21:43.484]                   NAME <- NAMES[[kk]]
[10:21:43.484]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.484]                     next
[10:21:43.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.484]                 }
[10:21:43.484]                 NAMES <- toupper(added)
[10:21:43.484]                 for (kk in seq_along(NAMES)) {
[10:21:43.484]                   name <- added[[kk]]
[10:21:43.484]                   NAME <- NAMES[[kk]]
[10:21:43.484]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.484]                     next
[10:21:43.484]                   args[[name]] <- ""
[10:21:43.484]                 }
[10:21:43.484]                 NAMES <- toupper(removed)
[10:21:43.484]                 for (kk in seq_along(NAMES)) {
[10:21:43.484]                   name <- removed[[kk]]
[10:21:43.484]                   NAME <- NAMES[[kk]]
[10:21:43.484]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.484]                     next
[10:21:43.484]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.484]                 }
[10:21:43.484]                 if (length(args) > 0) 
[10:21:43.484]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.484]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.484]             }
[10:21:43.484]             else {
[10:21:43.484]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.484]             }
[10:21:43.484]             {
[10:21:43.484]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.484]                   0L) {
[10:21:43.484]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.484]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.484]                   base::options(opts)
[10:21:43.484]                 }
[10:21:43.484]                 {
[10:21:43.484]                   {
[10:21:43.484]                     NULL
[10:21:43.484]                     RNGkind("Mersenne-Twister")
[10:21:43.484]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.484]                       inherits = FALSE)
[10:21:43.484]                   }
[10:21:43.484]                   options(future.plan = NULL)
[10:21:43.484]                   if (is.na(NA_character_)) 
[10:21:43.484]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.484]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.484]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.484]                     .init = FALSE)
[10:21:43.484]                 }
[10:21:43.484]             }
[10:21:43.484]         }
[10:21:43.484]     })
[10:21:43.484]     if (TRUE) {
[10:21:43.484]         base::sink(type = "output", split = FALSE)
[10:21:43.484]         if (TRUE) {
[10:21:43.484]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.484]         }
[10:21:43.484]         else {
[10:21:43.484]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.484]         }
[10:21:43.484]         base::close(...future.stdout)
[10:21:43.484]         ...future.stdout <- NULL
[10:21:43.484]     }
[10:21:43.484]     ...future.result$conditions <- ...future.conditions
[10:21:43.484]     ...future.result$finished <- base::Sys.time()
[10:21:43.484]     ...future.result
[10:21:43.484] }
[10:21:43.486] assign_globals() ...
[10:21:43.486] List of 1
[10:21:43.486]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55f18e9e2510> 
[10:21:43.486]  - attr(*, "where")=List of 1
[10:21:43.486]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.486]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.486]  - attr(*, "resolved")= logi TRUE
[10:21:43.486]  - attr(*, "total_size")= num 3555
[10:21:43.486]  - attr(*, "already-done")= logi TRUE
[10:21:43.488] - copied ‘a’ to environment
[10:21:43.488] assign_globals() ... done
[10:21:43.489] plan(): Setting new future strategy stack:
[10:21:43.489] List of future strategies:
[10:21:43.489] 1. sequential:
[10:21:43.489]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.489]    - tweaked: FALSE
[10:21:43.489]    - call: NULL
[10:21:43.489] plan(): nbrOfWorkers() = 1
[10:21:43.490] plan(): Setting new future strategy stack:
[10:21:43.490] List of future strategies:
[10:21:43.490] 1. sequential:
[10:21:43.490]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.490]    - tweaked: FALSE
[10:21:43.490]    - call: plan(strategy)
[10:21:43.490] plan(): nbrOfWorkers() = 1
[10:21:43.491] SequentialFuture started (and completed)
[10:21:43.491] - Launch lazy future ... done
[10:21:43.491] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.491] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.491] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.492] - globals found: [2] ‘{’, ‘pkg’
[10:21:43.492] Searching for globals ... DONE
[10:21:43.492] Resolving globals: TRUE
[10:21:43.492] Resolving any globals that are futures ...
[10:21:43.493] - globals: [2] ‘{’, ‘pkg’
[10:21:43.493] Resolving any globals that are futures ... DONE
[10:21:43.493] Resolving futures part of globals (recursively) ...
[10:21:43.493] resolve() on list ...
[10:21:43.493]  recursive: 99
[10:21:43.493]  length: 1
[10:21:43.493]  elements: ‘pkg’
[10:21:43.494]  length: 0 (resolved future 1)
[10:21:43.494] resolve() on list ... DONE
[10:21:43.494] - globals: [1] ‘pkg’
[10:21:43.494] Resolving futures part of globals (recursively) ... DONE
[10:21:43.494] The total size of the 1 globals is 42 bytes (42 bytes)
[10:21:43.494] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[10:21:43.494] - globals: [1] ‘pkg’
[10:21:43.494] 
[10:21:43.496] getGlobalsAndPackages() ... DONE
[10:21:43.496] Packages needed by the future expression (n = 0): <none>
[10:21:43.496] Packages needed by future strategies (n = 0): <none>
[10:21:43.496] {
[10:21:43.496]     {
[10:21:43.496]         {
[10:21:43.496]             ...future.startTime <- base::Sys.time()
[10:21:43.496]             {
[10:21:43.496]                 {
[10:21:43.496]                   {
[10:21:43.496]                     base::local({
[10:21:43.496]                       has_future <- base::requireNamespace("future", 
[10:21:43.496]                         quietly = TRUE)
[10:21:43.496]                       if (has_future) {
[10:21:43.496]                         ns <- base::getNamespace("future")
[10:21:43.496]                         version <- ns[[".package"]][["version"]]
[10:21:43.496]                         if (is.null(version)) 
[10:21:43.496]                           version <- utils::packageVersion("future")
[10:21:43.496]                       }
[10:21:43.496]                       else {
[10:21:43.496]                         version <- NULL
[10:21:43.496]                       }
[10:21:43.496]                       if (!has_future || version < "1.8.0") {
[10:21:43.496]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.496]                           "", base::R.version$version.string), 
[10:21:43.496]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.496]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.496]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.496]                             "release", "version")], collapse = " "), 
[10:21:43.496]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.496]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.496]                           info)
[10:21:43.496]                         info <- base::paste(info, collapse = "; ")
[10:21:43.496]                         if (!has_future) {
[10:21:43.496]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.496]                             info)
[10:21:43.496]                         }
[10:21:43.496]                         else {
[10:21:43.496]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.496]                             info, version)
[10:21:43.496]                         }
[10:21:43.496]                         base::stop(msg)
[10:21:43.496]                       }
[10:21:43.496]                     })
[10:21:43.496]                   }
[10:21:43.496]                   ...future.strategy.old <- future::plan("list")
[10:21:43.496]                   options(future.plan = NULL)
[10:21:43.496]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.496]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.496]                 }
[10:21:43.496]                 ...future.workdir <- getwd()
[10:21:43.496]             }
[10:21:43.496]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.496]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.496]         }
[10:21:43.496]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.496]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.496]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.496]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.496]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.496]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.496]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.496]             base::names(...future.oldOptions))
[10:21:43.496]     }
[10:21:43.496]     if (FALSE) {
[10:21:43.496]     }
[10:21:43.496]     else {
[10:21:43.496]         if (TRUE) {
[10:21:43.496]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.496]                 open = "w")
[10:21:43.496]         }
[10:21:43.496]         else {
[10:21:43.496]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.496]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.496]         }
[10:21:43.496]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.496]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.496]             base::sink(type = "output", split = FALSE)
[10:21:43.496]             base::close(...future.stdout)
[10:21:43.496]         }, add = TRUE)
[10:21:43.496]     }
[10:21:43.496]     ...future.frame <- base::sys.nframe()
[10:21:43.496]     ...future.conditions <- base::list()
[10:21:43.496]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.496]     if (FALSE) {
[10:21:43.496]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.496]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.496]     }
[10:21:43.496]     ...future.result <- base::tryCatch({
[10:21:43.496]         base::withCallingHandlers({
[10:21:43.496]             ...future.value <- base::withVisible(base::local({
[10:21:43.496]                 pkg
[10:21:43.496]             }))
[10:21:43.496]             future::FutureResult(value = ...future.value$value, 
[10:21:43.496]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.496]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.496]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.496]                     ...future.globalenv.names))
[10:21:43.496]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.496]         }, condition = base::local({
[10:21:43.496]             c <- base::c
[10:21:43.496]             inherits <- base::inherits
[10:21:43.496]             invokeRestart <- base::invokeRestart
[10:21:43.496]             length <- base::length
[10:21:43.496]             list <- base::list
[10:21:43.496]             seq.int <- base::seq.int
[10:21:43.496]             signalCondition <- base::signalCondition
[10:21:43.496]             sys.calls <- base::sys.calls
[10:21:43.496]             `[[` <- base::`[[`
[10:21:43.496]             `+` <- base::`+`
[10:21:43.496]             `<<-` <- base::`<<-`
[10:21:43.496]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.496]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.496]                   3L)]
[10:21:43.496]             }
[10:21:43.496]             function(cond) {
[10:21:43.496]                 is_error <- inherits(cond, "error")
[10:21:43.496]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.496]                   NULL)
[10:21:43.496]                 if (is_error) {
[10:21:43.496]                   sessionInformation <- function() {
[10:21:43.496]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.496]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.496]                       search = base::search(), system = base::Sys.info())
[10:21:43.496]                   }
[10:21:43.496]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.496]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.496]                     cond$call), session = sessionInformation(), 
[10:21:43.496]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.496]                   signalCondition(cond)
[10:21:43.496]                 }
[10:21:43.496]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.496]                 "immediateCondition"))) {
[10:21:43.496]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.496]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.496]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.496]                   if (TRUE && !signal) {
[10:21:43.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.496]                     {
[10:21:43.496]                       inherits <- base::inherits
[10:21:43.496]                       invokeRestart <- base::invokeRestart
[10:21:43.496]                       is.null <- base::is.null
[10:21:43.496]                       muffled <- FALSE
[10:21:43.496]                       if (inherits(cond, "message")) {
[10:21:43.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.496]                         if (muffled) 
[10:21:43.496]                           invokeRestart("muffleMessage")
[10:21:43.496]                       }
[10:21:43.496]                       else if (inherits(cond, "warning")) {
[10:21:43.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.496]                         if (muffled) 
[10:21:43.496]                           invokeRestart("muffleWarning")
[10:21:43.496]                       }
[10:21:43.496]                       else if (inherits(cond, "condition")) {
[10:21:43.496]                         if (!is.null(pattern)) {
[10:21:43.496]                           computeRestarts <- base::computeRestarts
[10:21:43.496]                           grepl <- base::grepl
[10:21:43.496]                           restarts <- computeRestarts(cond)
[10:21:43.496]                           for (restart in restarts) {
[10:21:43.496]                             name <- restart$name
[10:21:43.496]                             if (is.null(name)) 
[10:21:43.496]                               next
[10:21:43.496]                             if (!grepl(pattern, name)) 
[10:21:43.496]                               next
[10:21:43.496]                             invokeRestart(restart)
[10:21:43.496]                             muffled <- TRUE
[10:21:43.496]                             break
[10:21:43.496]                           }
[10:21:43.496]                         }
[10:21:43.496]                       }
[10:21:43.496]                       invisible(muffled)
[10:21:43.496]                     }
[10:21:43.496]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.496]                   }
[10:21:43.496]                 }
[10:21:43.496]                 else {
[10:21:43.496]                   if (TRUE) {
[10:21:43.496]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.496]                     {
[10:21:43.496]                       inherits <- base::inherits
[10:21:43.496]                       invokeRestart <- base::invokeRestart
[10:21:43.496]                       is.null <- base::is.null
[10:21:43.496]                       muffled <- FALSE
[10:21:43.496]                       if (inherits(cond, "message")) {
[10:21:43.496]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.496]                         if (muffled) 
[10:21:43.496]                           invokeRestart("muffleMessage")
[10:21:43.496]                       }
[10:21:43.496]                       else if (inherits(cond, "warning")) {
[10:21:43.496]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.496]                         if (muffled) 
[10:21:43.496]                           invokeRestart("muffleWarning")
[10:21:43.496]                       }
[10:21:43.496]                       else if (inherits(cond, "condition")) {
[10:21:43.496]                         if (!is.null(pattern)) {
[10:21:43.496]                           computeRestarts <- base::computeRestarts
[10:21:43.496]                           grepl <- base::grepl
[10:21:43.496]                           restarts <- computeRestarts(cond)
[10:21:43.496]                           for (restart in restarts) {
[10:21:43.496]                             name <- restart$name
[10:21:43.496]                             if (is.null(name)) 
[10:21:43.496]                               next
[10:21:43.496]                             if (!grepl(pattern, name)) 
[10:21:43.496]                               next
[10:21:43.496]                             invokeRestart(restart)
[10:21:43.496]                             muffled <- TRUE
[10:21:43.496]                             break
[10:21:43.496]                           }
[10:21:43.496]                         }
[10:21:43.496]                       }
[10:21:43.496]                       invisible(muffled)
[10:21:43.496]                     }
[10:21:43.496]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.496]                   }
[10:21:43.496]                 }
[10:21:43.496]             }
[10:21:43.496]         }))
[10:21:43.496]     }, error = function(ex) {
[10:21:43.496]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.496]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.496]                 ...future.rng), started = ...future.startTime, 
[10:21:43.496]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.496]             version = "1.8"), class = "FutureResult")
[10:21:43.496]     }, finally = {
[10:21:43.496]         if (!identical(...future.workdir, getwd())) 
[10:21:43.496]             setwd(...future.workdir)
[10:21:43.496]         {
[10:21:43.496]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.496]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.496]             }
[10:21:43.496]             base::options(...future.oldOptions)
[10:21:43.496]             if (.Platform$OS.type == "windows") {
[10:21:43.496]                 old_names <- names(...future.oldEnvVars)
[10:21:43.496]                 envs <- base::Sys.getenv()
[10:21:43.496]                 names <- names(envs)
[10:21:43.496]                 common <- intersect(names, old_names)
[10:21:43.496]                 added <- setdiff(names, old_names)
[10:21:43.496]                 removed <- setdiff(old_names, names)
[10:21:43.496]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.496]                   envs[common]]
[10:21:43.496]                 NAMES <- toupper(changed)
[10:21:43.496]                 args <- list()
[10:21:43.496]                 for (kk in seq_along(NAMES)) {
[10:21:43.496]                   name <- changed[[kk]]
[10:21:43.496]                   NAME <- NAMES[[kk]]
[10:21:43.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.496]                     next
[10:21:43.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.496]                 }
[10:21:43.496]                 NAMES <- toupper(added)
[10:21:43.496]                 for (kk in seq_along(NAMES)) {
[10:21:43.496]                   name <- added[[kk]]
[10:21:43.496]                   NAME <- NAMES[[kk]]
[10:21:43.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.496]                     next
[10:21:43.496]                   args[[name]] <- ""
[10:21:43.496]                 }
[10:21:43.496]                 NAMES <- toupper(removed)
[10:21:43.496]                 for (kk in seq_along(NAMES)) {
[10:21:43.496]                   name <- removed[[kk]]
[10:21:43.496]                   NAME <- NAMES[[kk]]
[10:21:43.496]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.496]                     next
[10:21:43.496]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.496]                 }
[10:21:43.496]                 if (length(args) > 0) 
[10:21:43.496]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.496]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.496]             }
[10:21:43.496]             else {
[10:21:43.496]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.496]             }
[10:21:43.496]             {
[10:21:43.496]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.496]                   0L) {
[10:21:43.496]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.496]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.496]                   base::options(opts)
[10:21:43.496]                 }
[10:21:43.496]                 {
[10:21:43.496]                   {
[10:21:43.496]                     NULL
[10:21:43.496]                     RNGkind("Mersenne-Twister")
[10:21:43.496]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.496]                       inherits = FALSE)
[10:21:43.496]                   }
[10:21:43.496]                   options(future.plan = NULL)
[10:21:43.496]                   if (is.na(NA_character_)) 
[10:21:43.496]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.496]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.496]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.496]                     .init = FALSE)
[10:21:43.496]                 }
[10:21:43.496]             }
[10:21:43.496]         }
[10:21:43.496]     })
[10:21:43.496]     if (TRUE) {
[10:21:43.496]         base::sink(type = "output", split = FALSE)
[10:21:43.496]         if (TRUE) {
[10:21:43.496]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.496]         }
[10:21:43.496]         else {
[10:21:43.496]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.496]         }
[10:21:43.496]         base::close(...future.stdout)
[10:21:43.496]         ...future.stdout <- NULL
[10:21:43.496]     }
[10:21:43.496]     ...future.result$conditions <- ...future.conditions
[10:21:43.496]     ...future.result$finished <- base::Sys.time()
[10:21:43.496]     ...future.result
[10:21:43.496] }
[10:21:43.498] assign_globals() ...
[10:21:43.498] List of 1
[10:21:43.498]  $ pkg: chr "foo"
[10:21:43.498]  - attr(*, "where")=List of 1
[10:21:43.498]   ..$ pkg:<environment: R_EmptyEnv> 
[10:21:43.498]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.498]  - attr(*, "resolved")= logi TRUE
[10:21:43.498]  - attr(*, "total_size")= num 42
[10:21:43.500] - copied ‘pkg’ to environment
[10:21:43.500] assign_globals() ... done
[10:21:43.501] plan(): Setting new future strategy stack:
[10:21:43.501] List of future strategies:
[10:21:43.501] 1. sequential:
[10:21:43.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.501]    - tweaked: FALSE
[10:21:43.501]    - call: NULL
[10:21:43.501] plan(): nbrOfWorkers() = 1
[10:21:43.502] plan(): Setting new future strategy stack:
[10:21:43.502] List of future strategies:
[10:21:43.502] 1. sequential:
[10:21:43.502]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.502]    - tweaked: FALSE
[10:21:43.502]    - call: plan(strategy)
[10:21:43.502] plan(): nbrOfWorkers() = 1
[10:21:43.502] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.503] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.503] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.505] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:21:43.505] Searching for globals ... DONE
[10:21:43.505] Resolving globals: TRUE
[10:21:43.505] Resolving any globals that are futures ...
[10:21:43.505] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:21:43.505] Resolving any globals that are futures ... DONE
[10:21:43.505] 
[10:21:43.506] 
[10:21:43.506] getGlobalsAndPackages() ... DONE
[10:21:43.506] run() for ‘Future’ ...
[10:21:43.506] - state: ‘created’
[10:21:43.506] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.506] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.506] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.506]   - Field: ‘label’
[10:21:43.507]   - Field: ‘local’
[10:21:43.507]   - Field: ‘owner’
[10:21:43.507]   - Field: ‘envir’
[10:21:43.507]   - Field: ‘packages’
[10:21:43.507]   - Field: ‘gc’
[10:21:43.507]   - Field: ‘conditions’
[10:21:43.507]   - Field: ‘expr’
[10:21:43.507]   - Field: ‘uuid’
[10:21:43.507]   - Field: ‘seed’
[10:21:43.507]   - Field: ‘version’
[10:21:43.507]   - Field: ‘result’
[10:21:43.507]   - Field: ‘asynchronous’
[10:21:43.508]   - Field: ‘calls’
[10:21:43.508]   - Field: ‘globals’
[10:21:43.508]   - Field: ‘stdout’
[10:21:43.508]   - Field: ‘earlySignal’
[10:21:43.508]   - Field: ‘lazy’
[10:21:43.508]   - Field: ‘state’
[10:21:43.508] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.508] - Launch lazy future ...
[10:21:43.508] Packages needed by the future expression (n = 0): <none>
[10:21:43.508] Packages needed by future strategies (n = 0): <none>
[10:21:43.509] {
[10:21:43.509]     {
[10:21:43.509]         {
[10:21:43.509]             ...future.startTime <- base::Sys.time()
[10:21:43.509]             {
[10:21:43.509]                 {
[10:21:43.509]                   {
[10:21:43.509]                     base::local({
[10:21:43.509]                       has_future <- base::requireNamespace("future", 
[10:21:43.509]                         quietly = TRUE)
[10:21:43.509]                       if (has_future) {
[10:21:43.509]                         ns <- base::getNamespace("future")
[10:21:43.509]                         version <- ns[[".package"]][["version"]]
[10:21:43.509]                         if (is.null(version)) 
[10:21:43.509]                           version <- utils::packageVersion("future")
[10:21:43.509]                       }
[10:21:43.509]                       else {
[10:21:43.509]                         version <- NULL
[10:21:43.509]                       }
[10:21:43.509]                       if (!has_future || version < "1.8.0") {
[10:21:43.509]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.509]                           "", base::R.version$version.string), 
[10:21:43.509]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.509]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.509]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.509]                             "release", "version")], collapse = " "), 
[10:21:43.509]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.509]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.509]                           info)
[10:21:43.509]                         info <- base::paste(info, collapse = "; ")
[10:21:43.509]                         if (!has_future) {
[10:21:43.509]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.509]                             info)
[10:21:43.509]                         }
[10:21:43.509]                         else {
[10:21:43.509]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.509]                             info, version)
[10:21:43.509]                         }
[10:21:43.509]                         base::stop(msg)
[10:21:43.509]                       }
[10:21:43.509]                     })
[10:21:43.509]                   }
[10:21:43.509]                   ...future.strategy.old <- future::plan("list")
[10:21:43.509]                   options(future.plan = NULL)
[10:21:43.509]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.509]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.509]                 }
[10:21:43.509]                 ...future.workdir <- getwd()
[10:21:43.509]             }
[10:21:43.509]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.509]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.509]         }
[10:21:43.509]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.509]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.509]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.509]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.509]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.509]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.509]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.509]             base::names(...future.oldOptions))
[10:21:43.509]     }
[10:21:43.509]     if (FALSE) {
[10:21:43.509]     }
[10:21:43.509]     else {
[10:21:43.509]         if (TRUE) {
[10:21:43.509]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.509]                 open = "w")
[10:21:43.509]         }
[10:21:43.509]         else {
[10:21:43.509]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.509]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.509]         }
[10:21:43.509]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.509]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.509]             base::sink(type = "output", split = FALSE)
[10:21:43.509]             base::close(...future.stdout)
[10:21:43.509]         }, add = TRUE)
[10:21:43.509]     }
[10:21:43.509]     ...future.frame <- base::sys.nframe()
[10:21:43.509]     ...future.conditions <- base::list()
[10:21:43.509]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.509]     if (FALSE) {
[10:21:43.509]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.509]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.509]     }
[10:21:43.509]     ...future.result <- base::tryCatch({
[10:21:43.509]         base::withCallingHandlers({
[10:21:43.509]             ...future.value <- base::withVisible(base::local({
[10:21:43.509]                 x <- 0
[10:21:43.509]                 x <- x + 1
[10:21:43.509]                 x
[10:21:43.509]             }))
[10:21:43.509]             future::FutureResult(value = ...future.value$value, 
[10:21:43.509]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.509]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.509]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.509]                     ...future.globalenv.names))
[10:21:43.509]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.509]         }, condition = base::local({
[10:21:43.509]             c <- base::c
[10:21:43.509]             inherits <- base::inherits
[10:21:43.509]             invokeRestart <- base::invokeRestart
[10:21:43.509]             length <- base::length
[10:21:43.509]             list <- base::list
[10:21:43.509]             seq.int <- base::seq.int
[10:21:43.509]             signalCondition <- base::signalCondition
[10:21:43.509]             sys.calls <- base::sys.calls
[10:21:43.509]             `[[` <- base::`[[`
[10:21:43.509]             `+` <- base::`+`
[10:21:43.509]             `<<-` <- base::`<<-`
[10:21:43.509]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.509]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.509]                   3L)]
[10:21:43.509]             }
[10:21:43.509]             function(cond) {
[10:21:43.509]                 is_error <- inherits(cond, "error")
[10:21:43.509]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.509]                   NULL)
[10:21:43.509]                 if (is_error) {
[10:21:43.509]                   sessionInformation <- function() {
[10:21:43.509]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.509]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.509]                       search = base::search(), system = base::Sys.info())
[10:21:43.509]                   }
[10:21:43.509]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.509]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.509]                     cond$call), session = sessionInformation(), 
[10:21:43.509]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.509]                   signalCondition(cond)
[10:21:43.509]                 }
[10:21:43.509]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.509]                 "immediateCondition"))) {
[10:21:43.509]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.509]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.509]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.509]                   if (TRUE && !signal) {
[10:21:43.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.509]                     {
[10:21:43.509]                       inherits <- base::inherits
[10:21:43.509]                       invokeRestart <- base::invokeRestart
[10:21:43.509]                       is.null <- base::is.null
[10:21:43.509]                       muffled <- FALSE
[10:21:43.509]                       if (inherits(cond, "message")) {
[10:21:43.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.509]                         if (muffled) 
[10:21:43.509]                           invokeRestart("muffleMessage")
[10:21:43.509]                       }
[10:21:43.509]                       else if (inherits(cond, "warning")) {
[10:21:43.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.509]                         if (muffled) 
[10:21:43.509]                           invokeRestart("muffleWarning")
[10:21:43.509]                       }
[10:21:43.509]                       else if (inherits(cond, "condition")) {
[10:21:43.509]                         if (!is.null(pattern)) {
[10:21:43.509]                           computeRestarts <- base::computeRestarts
[10:21:43.509]                           grepl <- base::grepl
[10:21:43.509]                           restarts <- computeRestarts(cond)
[10:21:43.509]                           for (restart in restarts) {
[10:21:43.509]                             name <- restart$name
[10:21:43.509]                             if (is.null(name)) 
[10:21:43.509]                               next
[10:21:43.509]                             if (!grepl(pattern, name)) 
[10:21:43.509]                               next
[10:21:43.509]                             invokeRestart(restart)
[10:21:43.509]                             muffled <- TRUE
[10:21:43.509]                             break
[10:21:43.509]                           }
[10:21:43.509]                         }
[10:21:43.509]                       }
[10:21:43.509]                       invisible(muffled)
[10:21:43.509]                     }
[10:21:43.509]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.509]                   }
[10:21:43.509]                 }
[10:21:43.509]                 else {
[10:21:43.509]                   if (TRUE) {
[10:21:43.509]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.509]                     {
[10:21:43.509]                       inherits <- base::inherits
[10:21:43.509]                       invokeRestart <- base::invokeRestart
[10:21:43.509]                       is.null <- base::is.null
[10:21:43.509]                       muffled <- FALSE
[10:21:43.509]                       if (inherits(cond, "message")) {
[10:21:43.509]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.509]                         if (muffled) 
[10:21:43.509]                           invokeRestart("muffleMessage")
[10:21:43.509]                       }
[10:21:43.509]                       else if (inherits(cond, "warning")) {
[10:21:43.509]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.509]                         if (muffled) 
[10:21:43.509]                           invokeRestart("muffleWarning")
[10:21:43.509]                       }
[10:21:43.509]                       else if (inherits(cond, "condition")) {
[10:21:43.509]                         if (!is.null(pattern)) {
[10:21:43.509]                           computeRestarts <- base::computeRestarts
[10:21:43.509]                           grepl <- base::grepl
[10:21:43.509]                           restarts <- computeRestarts(cond)
[10:21:43.509]                           for (restart in restarts) {
[10:21:43.509]                             name <- restart$name
[10:21:43.509]                             if (is.null(name)) 
[10:21:43.509]                               next
[10:21:43.509]                             if (!grepl(pattern, name)) 
[10:21:43.509]                               next
[10:21:43.509]                             invokeRestart(restart)
[10:21:43.509]                             muffled <- TRUE
[10:21:43.509]                             break
[10:21:43.509]                           }
[10:21:43.509]                         }
[10:21:43.509]                       }
[10:21:43.509]                       invisible(muffled)
[10:21:43.509]                     }
[10:21:43.509]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.509]                   }
[10:21:43.509]                 }
[10:21:43.509]             }
[10:21:43.509]         }))
[10:21:43.509]     }, error = function(ex) {
[10:21:43.509]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.509]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.509]                 ...future.rng), started = ...future.startTime, 
[10:21:43.509]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.509]             version = "1.8"), class = "FutureResult")
[10:21:43.509]     }, finally = {
[10:21:43.509]         if (!identical(...future.workdir, getwd())) 
[10:21:43.509]             setwd(...future.workdir)
[10:21:43.509]         {
[10:21:43.509]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.509]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.509]             }
[10:21:43.509]             base::options(...future.oldOptions)
[10:21:43.509]             if (.Platform$OS.type == "windows") {
[10:21:43.509]                 old_names <- names(...future.oldEnvVars)
[10:21:43.509]                 envs <- base::Sys.getenv()
[10:21:43.509]                 names <- names(envs)
[10:21:43.509]                 common <- intersect(names, old_names)
[10:21:43.509]                 added <- setdiff(names, old_names)
[10:21:43.509]                 removed <- setdiff(old_names, names)
[10:21:43.509]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.509]                   envs[common]]
[10:21:43.509]                 NAMES <- toupper(changed)
[10:21:43.509]                 args <- list()
[10:21:43.509]                 for (kk in seq_along(NAMES)) {
[10:21:43.509]                   name <- changed[[kk]]
[10:21:43.509]                   NAME <- NAMES[[kk]]
[10:21:43.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.509]                     next
[10:21:43.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.509]                 }
[10:21:43.509]                 NAMES <- toupper(added)
[10:21:43.509]                 for (kk in seq_along(NAMES)) {
[10:21:43.509]                   name <- added[[kk]]
[10:21:43.509]                   NAME <- NAMES[[kk]]
[10:21:43.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.509]                     next
[10:21:43.509]                   args[[name]] <- ""
[10:21:43.509]                 }
[10:21:43.509]                 NAMES <- toupper(removed)
[10:21:43.509]                 for (kk in seq_along(NAMES)) {
[10:21:43.509]                   name <- removed[[kk]]
[10:21:43.509]                   NAME <- NAMES[[kk]]
[10:21:43.509]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.509]                     next
[10:21:43.509]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.509]                 }
[10:21:43.509]                 if (length(args) > 0) 
[10:21:43.509]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.509]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.509]             }
[10:21:43.509]             else {
[10:21:43.509]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.509]             }
[10:21:43.509]             {
[10:21:43.509]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.509]                   0L) {
[10:21:43.509]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.509]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.509]                   base::options(opts)
[10:21:43.509]                 }
[10:21:43.509]                 {
[10:21:43.509]                   {
[10:21:43.509]                     NULL
[10:21:43.509]                     RNGkind("Mersenne-Twister")
[10:21:43.509]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.509]                       inherits = FALSE)
[10:21:43.509]                   }
[10:21:43.509]                   options(future.plan = NULL)
[10:21:43.509]                   if (is.na(NA_character_)) 
[10:21:43.509]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.509]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.509]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.509]                     .init = FALSE)
[10:21:43.509]                 }
[10:21:43.509]             }
[10:21:43.509]         }
[10:21:43.509]     })
[10:21:43.509]     if (TRUE) {
[10:21:43.509]         base::sink(type = "output", split = FALSE)
[10:21:43.509]         if (TRUE) {
[10:21:43.509]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.509]         }
[10:21:43.509]         else {
[10:21:43.509]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.509]         }
[10:21:43.509]         base::close(...future.stdout)
[10:21:43.509]         ...future.stdout <- NULL
[10:21:43.509]     }
[10:21:43.509]     ...future.result$conditions <- ...future.conditions
[10:21:43.509]     ...future.result$finished <- base::Sys.time()
[10:21:43.509]     ...future.result
[10:21:43.509] }
[10:21:43.511] plan(): Setting new future strategy stack:
[10:21:43.511] List of future strategies:
[10:21:43.511] 1. sequential:
[10:21:43.511]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.511]    - tweaked: FALSE
[10:21:43.511]    - call: NULL
[10:21:43.511] plan(): nbrOfWorkers() = 1
[10:21:43.512] plan(): Setting new future strategy stack:
[10:21:43.512] List of future strategies:
[10:21:43.512] 1. sequential:
[10:21:43.512]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.512]    - tweaked: FALSE
[10:21:43.512]    - call: plan(strategy)
[10:21:43.512] plan(): nbrOfWorkers() = 1
[10:21:43.512] SequentialFuture started (and completed)
[10:21:43.513] - Launch lazy future ... done
[10:21:43.513] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.513] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.513] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.514] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:21:43.515] Searching for globals ... DONE
[10:21:43.515] Resolving globals: TRUE
[10:21:43.515] Resolving any globals that are futures ...
[10:21:43.515] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:21:43.515] Resolving any globals that are futures ... DONE
[10:21:43.515] Resolving futures part of globals (recursively) ...
[10:21:43.515] resolve() on list ...
[10:21:43.516]  recursive: 99
[10:21:43.516]  length: 1
[10:21:43.516]  elements: ‘x’
[10:21:43.516]  length: 0 (resolved future 1)
[10:21:43.516] resolve() on list ... DONE
[10:21:43.516] - globals: [1] ‘x’
[10:21:43.516] Resolving futures part of globals (recursively) ... DONE
[10:21:43.516] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:43.517] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[10:21:43.517] - globals: [1] ‘x’
[10:21:43.517] 
[10:21:43.517] getGlobalsAndPackages() ... DONE
[10:21:43.517] run() for ‘Future’ ...
[10:21:43.517] - state: ‘created’
[10:21:43.517] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.517] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.518] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.518]   - Field: ‘label’
[10:21:43.518]   - Field: ‘local’
[10:21:43.518]   - Field: ‘owner’
[10:21:43.518]   - Field: ‘envir’
[10:21:43.518]   - Field: ‘packages’
[10:21:43.518]   - Field: ‘gc’
[10:21:43.518]   - Field: ‘conditions’
[10:21:43.518]   - Field: ‘expr’
[10:21:43.518]   - Field: ‘uuid’
[10:21:43.518]   - Field: ‘seed’
[10:21:43.519]   - Field: ‘version’
[10:21:43.519]   - Field: ‘result’
[10:21:43.519]   - Field: ‘asynchronous’
[10:21:43.519]   - Field: ‘calls’
[10:21:43.519]   - Field: ‘globals’
[10:21:43.519]   - Field: ‘stdout’
[10:21:43.519]   - Field: ‘earlySignal’
[10:21:43.519]   - Field: ‘lazy’
[10:21:43.519]   - Field: ‘state’
[10:21:43.519] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.519] - Launch lazy future ...
[10:21:43.520] Packages needed by the future expression (n = 0): <none>
[10:21:43.520] Packages needed by future strategies (n = 0): <none>
[10:21:43.520] {
[10:21:43.520]     {
[10:21:43.520]         {
[10:21:43.520]             ...future.startTime <- base::Sys.time()
[10:21:43.520]             {
[10:21:43.520]                 {
[10:21:43.520]                   {
[10:21:43.520]                     base::local({
[10:21:43.520]                       has_future <- base::requireNamespace("future", 
[10:21:43.520]                         quietly = TRUE)
[10:21:43.520]                       if (has_future) {
[10:21:43.520]                         ns <- base::getNamespace("future")
[10:21:43.520]                         version <- ns[[".package"]][["version"]]
[10:21:43.520]                         if (is.null(version)) 
[10:21:43.520]                           version <- utils::packageVersion("future")
[10:21:43.520]                       }
[10:21:43.520]                       else {
[10:21:43.520]                         version <- NULL
[10:21:43.520]                       }
[10:21:43.520]                       if (!has_future || version < "1.8.0") {
[10:21:43.520]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.520]                           "", base::R.version$version.string), 
[10:21:43.520]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.520]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.520]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.520]                             "release", "version")], collapse = " "), 
[10:21:43.520]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.520]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.520]                           info)
[10:21:43.520]                         info <- base::paste(info, collapse = "; ")
[10:21:43.520]                         if (!has_future) {
[10:21:43.520]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.520]                             info)
[10:21:43.520]                         }
[10:21:43.520]                         else {
[10:21:43.520]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.520]                             info, version)
[10:21:43.520]                         }
[10:21:43.520]                         base::stop(msg)
[10:21:43.520]                       }
[10:21:43.520]                     })
[10:21:43.520]                   }
[10:21:43.520]                   ...future.strategy.old <- future::plan("list")
[10:21:43.520]                   options(future.plan = NULL)
[10:21:43.520]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.520]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.520]                 }
[10:21:43.520]                 ...future.workdir <- getwd()
[10:21:43.520]             }
[10:21:43.520]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.520]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.520]         }
[10:21:43.520]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.520]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.520]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.520]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.520]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.520]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.520]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.520]             base::names(...future.oldOptions))
[10:21:43.520]     }
[10:21:43.520]     if (FALSE) {
[10:21:43.520]     }
[10:21:43.520]     else {
[10:21:43.520]         if (TRUE) {
[10:21:43.520]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.520]                 open = "w")
[10:21:43.520]         }
[10:21:43.520]         else {
[10:21:43.520]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.520]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.520]         }
[10:21:43.520]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.520]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.520]             base::sink(type = "output", split = FALSE)
[10:21:43.520]             base::close(...future.stdout)
[10:21:43.520]         }, add = TRUE)
[10:21:43.520]     }
[10:21:43.520]     ...future.frame <- base::sys.nframe()
[10:21:43.520]     ...future.conditions <- base::list()
[10:21:43.520]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.520]     if (FALSE) {
[10:21:43.520]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.520]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.520]     }
[10:21:43.520]     ...future.result <- base::tryCatch({
[10:21:43.520]         base::withCallingHandlers({
[10:21:43.520]             ...future.value <- base::withVisible(base::local({
[10:21:43.520]                 x <- x + 1
[10:21:43.520]                 x
[10:21:43.520]             }))
[10:21:43.520]             future::FutureResult(value = ...future.value$value, 
[10:21:43.520]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.520]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.520]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.520]                     ...future.globalenv.names))
[10:21:43.520]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.520]         }, condition = base::local({
[10:21:43.520]             c <- base::c
[10:21:43.520]             inherits <- base::inherits
[10:21:43.520]             invokeRestart <- base::invokeRestart
[10:21:43.520]             length <- base::length
[10:21:43.520]             list <- base::list
[10:21:43.520]             seq.int <- base::seq.int
[10:21:43.520]             signalCondition <- base::signalCondition
[10:21:43.520]             sys.calls <- base::sys.calls
[10:21:43.520]             `[[` <- base::`[[`
[10:21:43.520]             `+` <- base::`+`
[10:21:43.520]             `<<-` <- base::`<<-`
[10:21:43.520]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.520]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.520]                   3L)]
[10:21:43.520]             }
[10:21:43.520]             function(cond) {
[10:21:43.520]                 is_error <- inherits(cond, "error")
[10:21:43.520]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.520]                   NULL)
[10:21:43.520]                 if (is_error) {
[10:21:43.520]                   sessionInformation <- function() {
[10:21:43.520]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.520]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.520]                       search = base::search(), system = base::Sys.info())
[10:21:43.520]                   }
[10:21:43.520]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.520]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.520]                     cond$call), session = sessionInformation(), 
[10:21:43.520]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.520]                   signalCondition(cond)
[10:21:43.520]                 }
[10:21:43.520]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.520]                 "immediateCondition"))) {
[10:21:43.520]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.520]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.520]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.520]                   if (TRUE && !signal) {
[10:21:43.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.520]                     {
[10:21:43.520]                       inherits <- base::inherits
[10:21:43.520]                       invokeRestart <- base::invokeRestart
[10:21:43.520]                       is.null <- base::is.null
[10:21:43.520]                       muffled <- FALSE
[10:21:43.520]                       if (inherits(cond, "message")) {
[10:21:43.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.520]                         if (muffled) 
[10:21:43.520]                           invokeRestart("muffleMessage")
[10:21:43.520]                       }
[10:21:43.520]                       else if (inherits(cond, "warning")) {
[10:21:43.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.520]                         if (muffled) 
[10:21:43.520]                           invokeRestart("muffleWarning")
[10:21:43.520]                       }
[10:21:43.520]                       else if (inherits(cond, "condition")) {
[10:21:43.520]                         if (!is.null(pattern)) {
[10:21:43.520]                           computeRestarts <- base::computeRestarts
[10:21:43.520]                           grepl <- base::grepl
[10:21:43.520]                           restarts <- computeRestarts(cond)
[10:21:43.520]                           for (restart in restarts) {
[10:21:43.520]                             name <- restart$name
[10:21:43.520]                             if (is.null(name)) 
[10:21:43.520]                               next
[10:21:43.520]                             if (!grepl(pattern, name)) 
[10:21:43.520]                               next
[10:21:43.520]                             invokeRestart(restart)
[10:21:43.520]                             muffled <- TRUE
[10:21:43.520]                             break
[10:21:43.520]                           }
[10:21:43.520]                         }
[10:21:43.520]                       }
[10:21:43.520]                       invisible(muffled)
[10:21:43.520]                     }
[10:21:43.520]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.520]                   }
[10:21:43.520]                 }
[10:21:43.520]                 else {
[10:21:43.520]                   if (TRUE) {
[10:21:43.520]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.520]                     {
[10:21:43.520]                       inherits <- base::inherits
[10:21:43.520]                       invokeRestart <- base::invokeRestart
[10:21:43.520]                       is.null <- base::is.null
[10:21:43.520]                       muffled <- FALSE
[10:21:43.520]                       if (inherits(cond, "message")) {
[10:21:43.520]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.520]                         if (muffled) 
[10:21:43.520]                           invokeRestart("muffleMessage")
[10:21:43.520]                       }
[10:21:43.520]                       else if (inherits(cond, "warning")) {
[10:21:43.520]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.520]                         if (muffled) 
[10:21:43.520]                           invokeRestart("muffleWarning")
[10:21:43.520]                       }
[10:21:43.520]                       else if (inherits(cond, "condition")) {
[10:21:43.520]                         if (!is.null(pattern)) {
[10:21:43.520]                           computeRestarts <- base::computeRestarts
[10:21:43.520]                           grepl <- base::grepl
[10:21:43.520]                           restarts <- computeRestarts(cond)
[10:21:43.520]                           for (restart in restarts) {
[10:21:43.520]                             name <- restart$name
[10:21:43.520]                             if (is.null(name)) 
[10:21:43.520]                               next
[10:21:43.520]                             if (!grepl(pattern, name)) 
[10:21:43.520]                               next
[10:21:43.520]                             invokeRestart(restart)
[10:21:43.520]                             muffled <- TRUE
[10:21:43.520]                             break
[10:21:43.520]                           }
[10:21:43.520]                         }
[10:21:43.520]                       }
[10:21:43.520]                       invisible(muffled)
[10:21:43.520]                     }
[10:21:43.520]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.520]                   }
[10:21:43.520]                 }
[10:21:43.520]             }
[10:21:43.520]         }))
[10:21:43.520]     }, error = function(ex) {
[10:21:43.520]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.520]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.520]                 ...future.rng), started = ...future.startTime, 
[10:21:43.520]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.520]             version = "1.8"), class = "FutureResult")
[10:21:43.520]     }, finally = {
[10:21:43.520]         if (!identical(...future.workdir, getwd())) 
[10:21:43.520]             setwd(...future.workdir)
[10:21:43.520]         {
[10:21:43.520]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.520]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.520]             }
[10:21:43.520]             base::options(...future.oldOptions)
[10:21:43.520]             if (.Platform$OS.type == "windows") {
[10:21:43.520]                 old_names <- names(...future.oldEnvVars)
[10:21:43.520]                 envs <- base::Sys.getenv()
[10:21:43.520]                 names <- names(envs)
[10:21:43.520]                 common <- intersect(names, old_names)
[10:21:43.520]                 added <- setdiff(names, old_names)
[10:21:43.520]                 removed <- setdiff(old_names, names)
[10:21:43.520]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.520]                   envs[common]]
[10:21:43.520]                 NAMES <- toupper(changed)
[10:21:43.520]                 args <- list()
[10:21:43.520]                 for (kk in seq_along(NAMES)) {
[10:21:43.520]                   name <- changed[[kk]]
[10:21:43.520]                   NAME <- NAMES[[kk]]
[10:21:43.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.520]                     next
[10:21:43.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.520]                 }
[10:21:43.520]                 NAMES <- toupper(added)
[10:21:43.520]                 for (kk in seq_along(NAMES)) {
[10:21:43.520]                   name <- added[[kk]]
[10:21:43.520]                   NAME <- NAMES[[kk]]
[10:21:43.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.520]                     next
[10:21:43.520]                   args[[name]] <- ""
[10:21:43.520]                 }
[10:21:43.520]                 NAMES <- toupper(removed)
[10:21:43.520]                 for (kk in seq_along(NAMES)) {
[10:21:43.520]                   name <- removed[[kk]]
[10:21:43.520]                   NAME <- NAMES[[kk]]
[10:21:43.520]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.520]                     next
[10:21:43.520]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.520]                 }
[10:21:43.520]                 if (length(args) > 0) 
[10:21:43.520]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.520]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.520]             }
[10:21:43.520]             else {
[10:21:43.520]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.520]             }
[10:21:43.520]             {
[10:21:43.520]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.520]                   0L) {
[10:21:43.520]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.520]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.520]                   base::options(opts)
[10:21:43.520]                 }
[10:21:43.520]                 {
[10:21:43.520]                   {
[10:21:43.520]                     NULL
[10:21:43.520]                     RNGkind("Mersenne-Twister")
[10:21:43.520]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.520]                       inherits = FALSE)
[10:21:43.520]                   }
[10:21:43.520]                   options(future.plan = NULL)
[10:21:43.520]                   if (is.na(NA_character_)) 
[10:21:43.520]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.520]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.520]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.520]                     .init = FALSE)
[10:21:43.520]                 }
[10:21:43.520]             }
[10:21:43.520]         }
[10:21:43.520]     })
[10:21:43.520]     if (TRUE) {
[10:21:43.520]         base::sink(type = "output", split = FALSE)
[10:21:43.520]         if (TRUE) {
[10:21:43.520]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.520]         }
[10:21:43.520]         else {
[10:21:43.520]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.520]         }
[10:21:43.520]         base::close(...future.stdout)
[10:21:43.520]         ...future.stdout <- NULL
[10:21:43.520]     }
[10:21:43.520]     ...future.result$conditions <- ...future.conditions
[10:21:43.520]     ...future.result$finished <- base::Sys.time()
[10:21:43.520]     ...future.result
[10:21:43.520] }
[10:21:43.522] assign_globals() ...
[10:21:43.522] List of 1
[10:21:43.522]  $ x: num 1
[10:21:43.522]  - attr(*, "where")=List of 1
[10:21:43.522]   ..$ x:<environment: R_EmptyEnv> 
[10:21:43.522]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.522]  - attr(*, "resolved")= logi TRUE
[10:21:43.522]  - attr(*, "total_size")= num 39
[10:21:43.522]  - attr(*, "already-done")= logi TRUE
[10:21:43.525] - copied ‘x’ to environment
[10:21:43.526] assign_globals() ... done
[10:21:43.526] plan(): Setting new future strategy stack:
[10:21:43.526] List of future strategies:
[10:21:43.526] 1. sequential:
[10:21:43.526]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.526]    - tweaked: FALSE
[10:21:43.526]    - call: NULL
[10:21:43.526] plan(): nbrOfWorkers() = 1
[10:21:43.527] plan(): Setting new future strategy stack:
[10:21:43.527] List of future strategies:
[10:21:43.527] 1. sequential:
[10:21:43.527]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.527]    - tweaked: FALSE
[10:21:43.527]    - call: plan(strategy)
[10:21:43.528] plan(): nbrOfWorkers() = 1
[10:21:43.528] SequentialFuture started (and completed)
[10:21:43.528] - Launch lazy future ... done
[10:21:43.528] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.528] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.528] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:43.530] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:21:43.530] Searching for globals ... DONE
[10:21:43.530] Resolving globals: TRUE
[10:21:43.530] Resolving any globals that are futures ...
[10:21:43.530] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:21:43.531] Resolving any globals that are futures ... DONE
[10:21:43.531] Resolving futures part of globals (recursively) ...
[10:21:43.531] resolve() on list ...
[10:21:43.531]  recursive: 99
[10:21:43.531]  length: 1
[10:21:43.531]  elements: ‘x’
[10:21:43.531]  length: 0 (resolved future 1)
[10:21:43.532] resolve() on list ... DONE
[10:21:43.532] - globals: [1] ‘x’
[10:21:43.532] Resolving futures part of globals (recursively) ... DONE
[10:21:43.532] The total size of the 1 globals is 260 bytes (260 bytes)
[10:21:43.532] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[10:21:43.532] - globals: [1] ‘x’
[10:21:43.532] 
[10:21:43.532] getGlobalsAndPackages() ... DONE
[10:21:43.533] run() for ‘Future’ ...
[10:21:43.533] - state: ‘created’
[10:21:43.533] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[10:21:43.533] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[10:21:43.533] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[10:21:43.533]   - Field: ‘label’
[10:21:43.533]   - Field: ‘local’
[10:21:43.533]   - Field: ‘owner’
[10:21:43.534]   - Field: ‘envir’
[10:21:43.534]   - Field: ‘packages’
[10:21:43.534]   - Field: ‘gc’
[10:21:43.534]   - Field: ‘conditions’
[10:21:43.534]   - Field: ‘expr’
[10:21:43.534]   - Field: ‘uuid’
[10:21:43.534]   - Field: ‘seed’
[10:21:43.534]   - Field: ‘version’
[10:21:43.534]   - Field: ‘result’
[10:21:43.534]   - Field: ‘asynchronous’
[10:21:43.534]   - Field: ‘calls’
[10:21:43.534]   - Field: ‘globals’
[10:21:43.535]   - Field: ‘stdout’
[10:21:43.535]   - Field: ‘earlySignal’
[10:21:43.535]   - Field: ‘lazy’
[10:21:43.535]   - Field: ‘state’
[10:21:43.535] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[10:21:43.535] - Launch lazy future ...
[10:21:43.535] Packages needed by the future expression (n = 0): <none>
[10:21:43.535] Packages needed by future strategies (n = 0): <none>
[10:21:43.536] {
[10:21:43.536]     {
[10:21:43.536]         {
[10:21:43.536]             ...future.startTime <- base::Sys.time()
[10:21:43.536]             {
[10:21:43.536]                 {
[10:21:43.536]                   {
[10:21:43.536]                     base::local({
[10:21:43.536]                       has_future <- base::requireNamespace("future", 
[10:21:43.536]                         quietly = TRUE)
[10:21:43.536]                       if (has_future) {
[10:21:43.536]                         ns <- base::getNamespace("future")
[10:21:43.536]                         version <- ns[[".package"]][["version"]]
[10:21:43.536]                         if (is.null(version)) 
[10:21:43.536]                           version <- utils::packageVersion("future")
[10:21:43.536]                       }
[10:21:43.536]                       else {
[10:21:43.536]                         version <- NULL
[10:21:43.536]                       }
[10:21:43.536]                       if (!has_future || version < "1.8.0") {
[10:21:43.536]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.536]                           "", base::R.version$version.string), 
[10:21:43.536]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:43.536]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.536]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.536]                             "release", "version")], collapse = " "), 
[10:21:43.536]                           hostname = base::Sys.info()[["nodename"]])
[10:21:43.536]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.536]                           info)
[10:21:43.536]                         info <- base::paste(info, collapse = "; ")
[10:21:43.536]                         if (!has_future) {
[10:21:43.536]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.536]                             info)
[10:21:43.536]                         }
[10:21:43.536]                         else {
[10:21:43.536]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.536]                             info, version)
[10:21:43.536]                         }
[10:21:43.536]                         base::stop(msg)
[10:21:43.536]                       }
[10:21:43.536]                     })
[10:21:43.536]                   }
[10:21:43.536]                   ...future.strategy.old <- future::plan("list")
[10:21:43.536]                   options(future.plan = NULL)
[10:21:43.536]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.536]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.536]                 }
[10:21:43.536]                 ...future.workdir <- getwd()
[10:21:43.536]             }
[10:21:43.536]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.536]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.536]         }
[10:21:43.536]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.536]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:43.536]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.536]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.536]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.536]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.536]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.536]             base::names(...future.oldOptions))
[10:21:43.536]     }
[10:21:43.536]     if (FALSE) {
[10:21:43.536]     }
[10:21:43.536]     else {
[10:21:43.536]         if (TRUE) {
[10:21:43.536]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.536]                 open = "w")
[10:21:43.536]         }
[10:21:43.536]         else {
[10:21:43.536]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.536]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.536]         }
[10:21:43.536]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.536]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.536]             base::sink(type = "output", split = FALSE)
[10:21:43.536]             base::close(...future.stdout)
[10:21:43.536]         }, add = TRUE)
[10:21:43.536]     }
[10:21:43.536]     ...future.frame <- base::sys.nframe()
[10:21:43.536]     ...future.conditions <- base::list()
[10:21:43.536]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.536]     if (FALSE) {
[10:21:43.536]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.536]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.536]     }
[10:21:43.536]     ...future.result <- base::tryCatch({
[10:21:43.536]         base::withCallingHandlers({
[10:21:43.536]             ...future.value <- base::withVisible(base::local({
[10:21:43.536]                 x <- x()
[10:21:43.536]                 x
[10:21:43.536]             }))
[10:21:43.536]             future::FutureResult(value = ...future.value$value, 
[10:21:43.536]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.536]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.536]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.536]                     ...future.globalenv.names))
[10:21:43.536]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.536]         }, condition = base::local({
[10:21:43.536]             c <- base::c
[10:21:43.536]             inherits <- base::inherits
[10:21:43.536]             invokeRestart <- base::invokeRestart
[10:21:43.536]             length <- base::length
[10:21:43.536]             list <- base::list
[10:21:43.536]             seq.int <- base::seq.int
[10:21:43.536]             signalCondition <- base::signalCondition
[10:21:43.536]             sys.calls <- base::sys.calls
[10:21:43.536]             `[[` <- base::`[[`
[10:21:43.536]             `+` <- base::`+`
[10:21:43.536]             `<<-` <- base::`<<-`
[10:21:43.536]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.536]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.536]                   3L)]
[10:21:43.536]             }
[10:21:43.536]             function(cond) {
[10:21:43.536]                 is_error <- inherits(cond, "error")
[10:21:43.536]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.536]                   NULL)
[10:21:43.536]                 if (is_error) {
[10:21:43.536]                   sessionInformation <- function() {
[10:21:43.536]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.536]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.536]                       search = base::search(), system = base::Sys.info())
[10:21:43.536]                   }
[10:21:43.536]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.536]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.536]                     cond$call), session = sessionInformation(), 
[10:21:43.536]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.536]                   signalCondition(cond)
[10:21:43.536]                 }
[10:21:43.536]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.536]                 "immediateCondition"))) {
[10:21:43.536]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.536]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.536]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.536]                   if (TRUE && !signal) {
[10:21:43.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.536]                     {
[10:21:43.536]                       inherits <- base::inherits
[10:21:43.536]                       invokeRestart <- base::invokeRestart
[10:21:43.536]                       is.null <- base::is.null
[10:21:43.536]                       muffled <- FALSE
[10:21:43.536]                       if (inherits(cond, "message")) {
[10:21:43.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.536]                         if (muffled) 
[10:21:43.536]                           invokeRestart("muffleMessage")
[10:21:43.536]                       }
[10:21:43.536]                       else if (inherits(cond, "warning")) {
[10:21:43.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.536]                         if (muffled) 
[10:21:43.536]                           invokeRestart("muffleWarning")
[10:21:43.536]                       }
[10:21:43.536]                       else if (inherits(cond, "condition")) {
[10:21:43.536]                         if (!is.null(pattern)) {
[10:21:43.536]                           computeRestarts <- base::computeRestarts
[10:21:43.536]                           grepl <- base::grepl
[10:21:43.536]                           restarts <- computeRestarts(cond)
[10:21:43.536]                           for (restart in restarts) {
[10:21:43.536]                             name <- restart$name
[10:21:43.536]                             if (is.null(name)) 
[10:21:43.536]                               next
[10:21:43.536]                             if (!grepl(pattern, name)) 
[10:21:43.536]                               next
[10:21:43.536]                             invokeRestart(restart)
[10:21:43.536]                             muffled <- TRUE
[10:21:43.536]                             break
[10:21:43.536]                           }
[10:21:43.536]                         }
[10:21:43.536]                       }
[10:21:43.536]                       invisible(muffled)
[10:21:43.536]                     }
[10:21:43.536]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.536]                   }
[10:21:43.536]                 }
[10:21:43.536]                 else {
[10:21:43.536]                   if (TRUE) {
[10:21:43.536]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.536]                     {
[10:21:43.536]                       inherits <- base::inherits
[10:21:43.536]                       invokeRestart <- base::invokeRestart
[10:21:43.536]                       is.null <- base::is.null
[10:21:43.536]                       muffled <- FALSE
[10:21:43.536]                       if (inherits(cond, "message")) {
[10:21:43.536]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.536]                         if (muffled) 
[10:21:43.536]                           invokeRestart("muffleMessage")
[10:21:43.536]                       }
[10:21:43.536]                       else if (inherits(cond, "warning")) {
[10:21:43.536]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.536]                         if (muffled) 
[10:21:43.536]                           invokeRestart("muffleWarning")
[10:21:43.536]                       }
[10:21:43.536]                       else if (inherits(cond, "condition")) {
[10:21:43.536]                         if (!is.null(pattern)) {
[10:21:43.536]                           computeRestarts <- base::computeRestarts
[10:21:43.536]                           grepl <- base::grepl
[10:21:43.536]                           restarts <- computeRestarts(cond)
[10:21:43.536]                           for (restart in restarts) {
[10:21:43.536]                             name <- restart$name
[10:21:43.536]                             if (is.null(name)) 
[10:21:43.536]                               next
[10:21:43.536]                             if (!grepl(pattern, name)) 
[10:21:43.536]                               next
[10:21:43.536]                             invokeRestart(restart)
[10:21:43.536]                             muffled <- TRUE
[10:21:43.536]                             break
[10:21:43.536]                           }
[10:21:43.536]                         }
[10:21:43.536]                       }
[10:21:43.536]                       invisible(muffled)
[10:21:43.536]                     }
[10:21:43.536]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.536]                   }
[10:21:43.536]                 }
[10:21:43.536]             }
[10:21:43.536]         }))
[10:21:43.536]     }, error = function(ex) {
[10:21:43.536]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.536]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.536]                 ...future.rng), started = ...future.startTime, 
[10:21:43.536]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.536]             version = "1.8"), class = "FutureResult")
[10:21:43.536]     }, finally = {
[10:21:43.536]         if (!identical(...future.workdir, getwd())) 
[10:21:43.536]             setwd(...future.workdir)
[10:21:43.536]         {
[10:21:43.536]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.536]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.536]             }
[10:21:43.536]             base::options(...future.oldOptions)
[10:21:43.536]             if (.Platform$OS.type == "windows") {
[10:21:43.536]                 old_names <- names(...future.oldEnvVars)
[10:21:43.536]                 envs <- base::Sys.getenv()
[10:21:43.536]                 names <- names(envs)
[10:21:43.536]                 common <- intersect(names, old_names)
[10:21:43.536]                 added <- setdiff(names, old_names)
[10:21:43.536]                 removed <- setdiff(old_names, names)
[10:21:43.536]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.536]                   envs[common]]
[10:21:43.536]                 NAMES <- toupper(changed)
[10:21:43.536]                 args <- list()
[10:21:43.536]                 for (kk in seq_along(NAMES)) {
[10:21:43.536]                   name <- changed[[kk]]
[10:21:43.536]                   NAME <- NAMES[[kk]]
[10:21:43.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.536]                     next
[10:21:43.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.536]                 }
[10:21:43.536]                 NAMES <- toupper(added)
[10:21:43.536]                 for (kk in seq_along(NAMES)) {
[10:21:43.536]                   name <- added[[kk]]
[10:21:43.536]                   NAME <- NAMES[[kk]]
[10:21:43.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.536]                     next
[10:21:43.536]                   args[[name]] <- ""
[10:21:43.536]                 }
[10:21:43.536]                 NAMES <- toupper(removed)
[10:21:43.536]                 for (kk in seq_along(NAMES)) {
[10:21:43.536]                   name <- removed[[kk]]
[10:21:43.536]                   NAME <- NAMES[[kk]]
[10:21:43.536]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.536]                     next
[10:21:43.536]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.536]                 }
[10:21:43.536]                 if (length(args) > 0) 
[10:21:43.536]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.536]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.536]             }
[10:21:43.536]             else {
[10:21:43.536]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.536]             }
[10:21:43.536]             {
[10:21:43.536]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.536]                   0L) {
[10:21:43.536]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.536]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.536]                   base::options(opts)
[10:21:43.536]                 }
[10:21:43.536]                 {
[10:21:43.536]                   {
[10:21:43.536]                     NULL
[10:21:43.536]                     RNGkind("Mersenne-Twister")
[10:21:43.536]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:43.536]                       inherits = FALSE)
[10:21:43.536]                   }
[10:21:43.536]                   options(future.plan = NULL)
[10:21:43.536]                   if (is.na(NA_character_)) 
[10:21:43.536]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.536]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.536]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.536]                     .init = FALSE)
[10:21:43.536]                 }
[10:21:43.536]             }
[10:21:43.536]         }
[10:21:43.536]     })
[10:21:43.536]     if (TRUE) {
[10:21:43.536]         base::sink(type = "output", split = FALSE)
[10:21:43.536]         if (TRUE) {
[10:21:43.536]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.536]         }
[10:21:43.536]         else {
[10:21:43.536]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.536]         }
[10:21:43.536]         base::close(...future.stdout)
[10:21:43.536]         ...future.stdout <- NULL
[10:21:43.536]     }
[10:21:43.536]     ...future.result$conditions <- ...future.conditions
[10:21:43.536]     ...future.result$finished <- base::Sys.time()
[10:21:43.536]     ...future.result
[10:21:43.536] }
[10:21:43.537] assign_globals() ...
[10:21:43.537] List of 1
[10:21:43.537]  $ x:function ()  
[10:21:43.537]  - attr(*, "where")=List of 1
[10:21:43.537]   ..$ x:<environment: R_EmptyEnv> 
[10:21:43.537]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.537]  - attr(*, "resolved")= logi TRUE
[10:21:43.537]  - attr(*, "total_size")= num 260
[10:21:43.537]  - attr(*, "already-done")= logi TRUE
[10:21:43.540] - reassign environment for ‘x’
[10:21:43.540] - copied ‘x’ to environment
[10:21:43.540] assign_globals() ... done
[10:21:43.540] plan(): Setting new future strategy stack:
[10:21:43.540] List of future strategies:
[10:21:43.540] 1. sequential:
[10:21:43.540]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.540]    - tweaked: FALSE
[10:21:43.540]    - call: NULL
[10:21:43.540] plan(): nbrOfWorkers() = 1
[10:21:43.541] plan(): Setting new future strategy stack:
[10:21:43.541] List of future strategies:
[10:21:43.541] 1. sequential:
[10:21:43.541]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.541]    - tweaked: FALSE
[10:21:43.541]    - call: plan(strategy)
[10:21:43.542] plan(): nbrOfWorkers() = 1
[10:21:43.542] SequentialFuture started (and completed)
[10:21:43.542] - Launch lazy future ... done
[10:21:43.542] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[10:21:43.550] plan(): Setting new future strategy stack:
[10:21:43.550] List of future strategies:
[10:21:43.550] 1. multicore:
[10:21:43.550]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.550]    - tweaked: FALSE
[10:21:43.550]    - call: plan(strategy)
[10:21:43.552] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.552] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.552] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.554] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:21:43.554] Searching for globals ... DONE
[10:21:43.554] Resolving globals: TRUE
[10:21:43.554] Resolving any globals that are futures ...
[10:21:43.554] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:21:43.554] Resolving any globals that are futures ... DONE
[10:21:43.554] 
[10:21:43.554] 
[10:21:43.554] getGlobalsAndPackages() ... DONE
[10:21:43.555] run() for ‘Future’ ...
[10:21:43.555] - state: ‘created’
[10:21:43.555] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.557]   - Field: ‘label’
[10:21:43.557]   - Field: ‘local’
[10:21:43.557]   - Field: ‘owner’
[10:21:43.557]   - Field: ‘envir’
[10:21:43.557]   - Field: ‘workers’
[10:21:43.557]   - Field: ‘packages’
[10:21:43.557]   - Field: ‘gc’
[10:21:43.557]   - Field: ‘job’
[10:21:43.557]   - Field: ‘conditions’
[10:21:43.557]   - Field: ‘expr’
[10:21:43.558]   - Field: ‘uuid’
[10:21:43.558]   - Field: ‘seed’
[10:21:43.558]   - Field: ‘version’
[10:21:43.558]   - Field: ‘result’
[10:21:43.558]   - Field: ‘asynchronous’
[10:21:43.558]   - Field: ‘calls’
[10:21:43.558]   - Field: ‘globals’
[10:21:43.558]   - Field: ‘stdout’
[10:21:43.558]   - Field: ‘earlySignal’
[10:21:43.558]   - Field: ‘lazy’
[10:21:43.558]   - Field: ‘state’
[10:21:43.558] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.559] - Launch lazy future ...
[10:21:43.559] Packages needed by the future expression (n = 0): <none>
[10:21:43.560] Packages needed by future strategies (n = 0): <none>
[10:21:43.560] {
[10:21:43.560]     {
[10:21:43.560]         {
[10:21:43.560]             ...future.startTime <- base::Sys.time()
[10:21:43.560]             {
[10:21:43.560]                 {
[10:21:43.560]                   {
[10:21:43.560]                     {
[10:21:43.560]                       base::local({
[10:21:43.560]                         has_future <- base::requireNamespace("future", 
[10:21:43.560]                           quietly = TRUE)
[10:21:43.560]                         if (has_future) {
[10:21:43.560]                           ns <- base::getNamespace("future")
[10:21:43.560]                           version <- ns[[".package"]][["version"]]
[10:21:43.560]                           if (is.null(version)) 
[10:21:43.560]                             version <- utils::packageVersion("future")
[10:21:43.560]                         }
[10:21:43.560]                         else {
[10:21:43.560]                           version <- NULL
[10:21:43.560]                         }
[10:21:43.560]                         if (!has_future || version < "1.8.0") {
[10:21:43.560]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.560]                             "", base::R.version$version.string), 
[10:21:43.560]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.560]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.560]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.560]                               "release", "version")], collapse = " "), 
[10:21:43.560]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.560]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.560]                             info)
[10:21:43.560]                           info <- base::paste(info, collapse = "; ")
[10:21:43.560]                           if (!has_future) {
[10:21:43.560]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.560]                               info)
[10:21:43.560]                           }
[10:21:43.560]                           else {
[10:21:43.560]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.560]                               info, version)
[10:21:43.560]                           }
[10:21:43.560]                           base::stop(msg)
[10:21:43.560]                         }
[10:21:43.560]                       })
[10:21:43.560]                     }
[10:21:43.560]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.560]                     base::options(mc.cores = 1L)
[10:21:43.560]                   }
[10:21:43.560]                   ...future.strategy.old <- future::plan("list")
[10:21:43.560]                   options(future.plan = NULL)
[10:21:43.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.560]                 }
[10:21:43.560]                 ...future.workdir <- getwd()
[10:21:43.560]             }
[10:21:43.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.560]         }
[10:21:43.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.560]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.560]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.560]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.560]             base::names(...future.oldOptions))
[10:21:43.560]     }
[10:21:43.560]     if (FALSE) {
[10:21:43.560]     }
[10:21:43.560]     else {
[10:21:43.560]         if (TRUE) {
[10:21:43.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.560]                 open = "w")
[10:21:43.560]         }
[10:21:43.560]         else {
[10:21:43.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.560]         }
[10:21:43.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.560]             base::sink(type = "output", split = FALSE)
[10:21:43.560]             base::close(...future.stdout)
[10:21:43.560]         }, add = TRUE)
[10:21:43.560]     }
[10:21:43.560]     ...future.frame <- base::sys.nframe()
[10:21:43.560]     ...future.conditions <- base::list()
[10:21:43.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.560]     if (FALSE) {
[10:21:43.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.560]     }
[10:21:43.560]     ...future.result <- base::tryCatch({
[10:21:43.560]         base::withCallingHandlers({
[10:21:43.560]             ...future.value <- base::withVisible(base::local({
[10:21:43.560]                 withCallingHandlers({
[10:21:43.560]                   {
[10:21:43.560]                     b <- a
[10:21:43.560]                     a <- 2
[10:21:43.560]                     a * b
[10:21:43.560]                   }
[10:21:43.560]                 }, immediateCondition = function(cond) {
[10:21:43.560]                   save_rds <- function (object, pathname, ...) 
[10:21:43.560]                   {
[10:21:43.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.560]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.560]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.560]                         fi_tmp[["mtime"]])
[10:21:43.560]                     }
[10:21:43.560]                     tryCatch({
[10:21:43.560]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.560]                     }, error = function(ex) {
[10:21:43.560]                       msg <- conditionMessage(ex)
[10:21:43.560]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.560]                         fi_tmp[["mtime"]], msg)
[10:21:43.560]                       ex$message <- msg
[10:21:43.560]                       stop(ex)
[10:21:43.560]                     })
[10:21:43.560]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.560]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.560]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.560]                       fi <- file.info(pathname)
[10:21:43.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.560]                         fi[["size"]], fi[["mtime"]])
[10:21:43.560]                       stop(msg)
[10:21:43.560]                     }
[10:21:43.560]                     invisible(pathname)
[10:21:43.560]                   }
[10:21:43.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.560]                     rootPath = tempdir()) 
[10:21:43.560]                   {
[10:21:43.560]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.560]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.560]                       tmpdir = path, fileext = ".rds")
[10:21:43.560]                     save_rds(obj, file)
[10:21:43.560]                   }
[10:21:43.560]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.560]                   {
[10:21:43.560]                     inherits <- base::inherits
[10:21:43.560]                     invokeRestart <- base::invokeRestart
[10:21:43.560]                     is.null <- base::is.null
[10:21:43.560]                     muffled <- FALSE
[10:21:43.560]                     if (inherits(cond, "message")) {
[10:21:43.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.560]                       if (muffled) 
[10:21:43.560]                         invokeRestart("muffleMessage")
[10:21:43.560]                     }
[10:21:43.560]                     else if (inherits(cond, "warning")) {
[10:21:43.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.560]                       if (muffled) 
[10:21:43.560]                         invokeRestart("muffleWarning")
[10:21:43.560]                     }
[10:21:43.560]                     else if (inherits(cond, "condition")) {
[10:21:43.560]                       if (!is.null(pattern)) {
[10:21:43.560]                         computeRestarts <- base::computeRestarts
[10:21:43.560]                         grepl <- base::grepl
[10:21:43.560]                         restarts <- computeRestarts(cond)
[10:21:43.560]                         for (restart in restarts) {
[10:21:43.560]                           name <- restart$name
[10:21:43.560]                           if (is.null(name)) 
[10:21:43.560]                             next
[10:21:43.560]                           if (!grepl(pattern, name)) 
[10:21:43.560]                             next
[10:21:43.560]                           invokeRestart(restart)
[10:21:43.560]                           muffled <- TRUE
[10:21:43.560]                           break
[10:21:43.560]                         }
[10:21:43.560]                       }
[10:21:43.560]                     }
[10:21:43.560]                     invisible(muffled)
[10:21:43.560]                   }
[10:21:43.560]                   muffleCondition(cond)
[10:21:43.560]                 })
[10:21:43.560]             }))
[10:21:43.560]             future::FutureResult(value = ...future.value$value, 
[10:21:43.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.560]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.560]                     ...future.globalenv.names))
[10:21:43.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.560]         }, condition = base::local({
[10:21:43.560]             c <- base::c
[10:21:43.560]             inherits <- base::inherits
[10:21:43.560]             invokeRestart <- base::invokeRestart
[10:21:43.560]             length <- base::length
[10:21:43.560]             list <- base::list
[10:21:43.560]             seq.int <- base::seq.int
[10:21:43.560]             signalCondition <- base::signalCondition
[10:21:43.560]             sys.calls <- base::sys.calls
[10:21:43.560]             `[[` <- base::`[[`
[10:21:43.560]             `+` <- base::`+`
[10:21:43.560]             `<<-` <- base::`<<-`
[10:21:43.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.560]                   3L)]
[10:21:43.560]             }
[10:21:43.560]             function(cond) {
[10:21:43.560]                 is_error <- inherits(cond, "error")
[10:21:43.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.560]                   NULL)
[10:21:43.560]                 if (is_error) {
[10:21:43.560]                   sessionInformation <- function() {
[10:21:43.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.560]                       search = base::search(), system = base::Sys.info())
[10:21:43.560]                   }
[10:21:43.560]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.560]                     cond$call), session = sessionInformation(), 
[10:21:43.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.560]                   signalCondition(cond)
[10:21:43.560]                 }
[10:21:43.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.560]                 "immediateCondition"))) {
[10:21:43.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.560]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.560]                   if (TRUE && !signal) {
[10:21:43.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.560]                     {
[10:21:43.560]                       inherits <- base::inherits
[10:21:43.560]                       invokeRestart <- base::invokeRestart
[10:21:43.560]                       is.null <- base::is.null
[10:21:43.560]                       muffled <- FALSE
[10:21:43.560]                       if (inherits(cond, "message")) {
[10:21:43.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.560]                         if (muffled) 
[10:21:43.560]                           invokeRestart("muffleMessage")
[10:21:43.560]                       }
[10:21:43.560]                       else if (inherits(cond, "warning")) {
[10:21:43.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.560]                         if (muffled) 
[10:21:43.560]                           invokeRestart("muffleWarning")
[10:21:43.560]                       }
[10:21:43.560]                       else if (inherits(cond, "condition")) {
[10:21:43.560]                         if (!is.null(pattern)) {
[10:21:43.560]                           computeRestarts <- base::computeRestarts
[10:21:43.560]                           grepl <- base::grepl
[10:21:43.560]                           restarts <- computeRestarts(cond)
[10:21:43.560]                           for (restart in restarts) {
[10:21:43.560]                             name <- restart$name
[10:21:43.560]                             if (is.null(name)) 
[10:21:43.560]                               next
[10:21:43.560]                             if (!grepl(pattern, name)) 
[10:21:43.560]                               next
[10:21:43.560]                             invokeRestart(restart)
[10:21:43.560]                             muffled <- TRUE
[10:21:43.560]                             break
[10:21:43.560]                           }
[10:21:43.560]                         }
[10:21:43.560]                       }
[10:21:43.560]                       invisible(muffled)
[10:21:43.560]                     }
[10:21:43.560]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.560]                   }
[10:21:43.560]                 }
[10:21:43.560]                 else {
[10:21:43.560]                   if (TRUE) {
[10:21:43.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.560]                     {
[10:21:43.560]                       inherits <- base::inherits
[10:21:43.560]                       invokeRestart <- base::invokeRestart
[10:21:43.560]                       is.null <- base::is.null
[10:21:43.560]                       muffled <- FALSE
[10:21:43.560]                       if (inherits(cond, "message")) {
[10:21:43.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.560]                         if (muffled) 
[10:21:43.560]                           invokeRestart("muffleMessage")
[10:21:43.560]                       }
[10:21:43.560]                       else if (inherits(cond, "warning")) {
[10:21:43.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.560]                         if (muffled) 
[10:21:43.560]                           invokeRestart("muffleWarning")
[10:21:43.560]                       }
[10:21:43.560]                       else if (inherits(cond, "condition")) {
[10:21:43.560]                         if (!is.null(pattern)) {
[10:21:43.560]                           computeRestarts <- base::computeRestarts
[10:21:43.560]                           grepl <- base::grepl
[10:21:43.560]                           restarts <- computeRestarts(cond)
[10:21:43.560]                           for (restart in restarts) {
[10:21:43.560]                             name <- restart$name
[10:21:43.560]                             if (is.null(name)) 
[10:21:43.560]                               next
[10:21:43.560]                             if (!grepl(pattern, name)) 
[10:21:43.560]                               next
[10:21:43.560]                             invokeRestart(restart)
[10:21:43.560]                             muffled <- TRUE
[10:21:43.560]                             break
[10:21:43.560]                           }
[10:21:43.560]                         }
[10:21:43.560]                       }
[10:21:43.560]                       invisible(muffled)
[10:21:43.560]                     }
[10:21:43.560]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.560]                   }
[10:21:43.560]                 }
[10:21:43.560]             }
[10:21:43.560]         }))
[10:21:43.560]     }, error = function(ex) {
[10:21:43.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.560]                 ...future.rng), started = ...future.startTime, 
[10:21:43.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.560]             version = "1.8"), class = "FutureResult")
[10:21:43.560]     }, finally = {
[10:21:43.560]         if (!identical(...future.workdir, getwd())) 
[10:21:43.560]             setwd(...future.workdir)
[10:21:43.560]         {
[10:21:43.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.560]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.560]             }
[10:21:43.560]             base::options(...future.oldOptions)
[10:21:43.560]             if (.Platform$OS.type == "windows") {
[10:21:43.560]                 old_names <- names(...future.oldEnvVars)
[10:21:43.560]                 envs <- base::Sys.getenv()
[10:21:43.560]                 names <- names(envs)
[10:21:43.560]                 common <- intersect(names, old_names)
[10:21:43.560]                 added <- setdiff(names, old_names)
[10:21:43.560]                 removed <- setdiff(old_names, names)
[10:21:43.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.560]                   envs[common]]
[10:21:43.560]                 NAMES <- toupper(changed)
[10:21:43.560]                 args <- list()
[10:21:43.560]                 for (kk in seq_along(NAMES)) {
[10:21:43.560]                   name <- changed[[kk]]
[10:21:43.560]                   NAME <- NAMES[[kk]]
[10:21:43.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.560]                     next
[10:21:43.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.560]                 }
[10:21:43.560]                 NAMES <- toupper(added)
[10:21:43.560]                 for (kk in seq_along(NAMES)) {
[10:21:43.560]                   name <- added[[kk]]
[10:21:43.560]                   NAME <- NAMES[[kk]]
[10:21:43.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.560]                     next
[10:21:43.560]                   args[[name]] <- ""
[10:21:43.560]                 }
[10:21:43.560]                 NAMES <- toupper(removed)
[10:21:43.560]                 for (kk in seq_along(NAMES)) {
[10:21:43.560]                   name <- removed[[kk]]
[10:21:43.560]                   NAME <- NAMES[[kk]]
[10:21:43.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.560]                     next
[10:21:43.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.560]                 }
[10:21:43.560]                 if (length(args) > 0) 
[10:21:43.560]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.560]             }
[10:21:43.560]             else {
[10:21:43.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.560]             }
[10:21:43.560]             {
[10:21:43.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.560]                   0L) {
[10:21:43.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.560]                   base::options(opts)
[10:21:43.560]                 }
[10:21:43.560]                 {
[10:21:43.560]                   {
[10:21:43.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.560]                     NULL
[10:21:43.560]                   }
[10:21:43.560]                   options(future.plan = NULL)
[10:21:43.560]                   if (is.na(NA_character_)) 
[10:21:43.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.560]                     .init = FALSE)
[10:21:43.560]                 }
[10:21:43.560]             }
[10:21:43.560]         }
[10:21:43.560]     })
[10:21:43.560]     if (TRUE) {
[10:21:43.560]         base::sink(type = "output", split = FALSE)
[10:21:43.560]         if (TRUE) {
[10:21:43.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.560]         }
[10:21:43.560]         else {
[10:21:43.560]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.560]         }
[10:21:43.560]         base::close(...future.stdout)
[10:21:43.560]         ...future.stdout <- NULL
[10:21:43.560]     }
[10:21:43.560]     ...future.result$conditions <- ...future.conditions
[10:21:43.560]     ...future.result$finished <- base::Sys.time()
[10:21:43.560]     ...future.result
[10:21:43.560] }
[10:21:43.562] requestCore(): workers = 2
[10:21:43.565] MulticoreFuture started
[10:21:43.566] - Launch lazy future ... done
[10:21:43.566] plan(): Setting new future strategy stack:
[10:21:43.566] run() for ‘MulticoreFuture’ ... done
[10:21:43.566] List of future strategies:
[10:21:43.566] 1. sequential:
[10:21:43.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.566]    - tweaked: FALSE
[10:21:43.566]    - call: NULL
[10:21:43.567] plan(): nbrOfWorkers() = 1
[10:21:43.567] result() for MulticoreFuture ...
[10:21:43.569] plan(): Setting new future strategy stack:
[10:21:43.570] List of future strategies:
[10:21:43.570] 1. multicore:
[10:21:43.570]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.570]    - tweaked: FALSE
[10:21:43.570]    - call: plan(strategy)
[10:21:43.573] plan(): nbrOfWorkers() = 2
[10:21:43.577] result() for MulticoreFuture ...
[10:21:43.578] result() for MulticoreFuture ... done
[10:21:43.578] result() for MulticoreFuture ... done
[10:21:43.578] result() for MulticoreFuture ...
[10:21:43.578] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.579] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.579] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.581] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:21:43.581] Searching for globals ... DONE
[10:21:43.581] Resolving globals: TRUE
[10:21:43.581] Resolving any globals that are futures ...
[10:21:43.581] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:21:43.581] Resolving any globals that are futures ... DONE
[10:21:43.582] 
[10:21:43.582] 
[10:21:43.582] getGlobalsAndPackages() ... DONE
[10:21:43.582] run() for ‘Future’ ...
[10:21:43.583] - state: ‘created’
[10:21:43.583] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.585] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.585] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.585]   - Field: ‘label’
[10:21:43.585]   - Field: ‘local’
[10:21:43.585]   - Field: ‘owner’
[10:21:43.585]   - Field: ‘envir’
[10:21:43.586]   - Field: ‘workers’
[10:21:43.586]   - Field: ‘packages’
[10:21:43.586]   - Field: ‘gc’
[10:21:43.586]   - Field: ‘job’
[10:21:43.586]   - Field: ‘conditions’
[10:21:43.586]   - Field: ‘expr’
[10:21:43.586]   - Field: ‘uuid’
[10:21:43.586]   - Field: ‘seed’
[10:21:43.586]   - Field: ‘version’
[10:21:43.587]   - Field: ‘result’
[10:21:43.587]   - Field: ‘asynchronous’
[10:21:43.587]   - Field: ‘calls’
[10:21:43.587]   - Field: ‘globals’
[10:21:43.587]   - Field: ‘stdout’
[10:21:43.587]   - Field: ‘earlySignal’
[10:21:43.587]   - Field: ‘lazy’
[10:21:43.587]   - Field: ‘state’
[10:21:43.587] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.588] - Launch lazy future ...
[10:21:43.588] Packages needed by the future expression (n = 0): <none>
[10:21:43.588] Packages needed by future strategies (n = 0): <none>
[10:21:43.589] {
[10:21:43.589]     {
[10:21:43.589]         {
[10:21:43.589]             ...future.startTime <- base::Sys.time()
[10:21:43.589]             {
[10:21:43.589]                 {
[10:21:43.589]                   {
[10:21:43.589]                     {
[10:21:43.589]                       base::local({
[10:21:43.589]                         has_future <- base::requireNamespace("future", 
[10:21:43.589]                           quietly = TRUE)
[10:21:43.589]                         if (has_future) {
[10:21:43.589]                           ns <- base::getNamespace("future")
[10:21:43.589]                           version <- ns[[".package"]][["version"]]
[10:21:43.589]                           if (is.null(version)) 
[10:21:43.589]                             version <- utils::packageVersion("future")
[10:21:43.589]                         }
[10:21:43.589]                         else {
[10:21:43.589]                           version <- NULL
[10:21:43.589]                         }
[10:21:43.589]                         if (!has_future || version < "1.8.0") {
[10:21:43.589]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.589]                             "", base::R.version$version.string), 
[10:21:43.589]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.589]                               "release", "version")], collapse = " "), 
[10:21:43.589]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.589]                             info)
[10:21:43.589]                           info <- base::paste(info, collapse = "; ")
[10:21:43.589]                           if (!has_future) {
[10:21:43.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.589]                               info)
[10:21:43.589]                           }
[10:21:43.589]                           else {
[10:21:43.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.589]                               info, version)
[10:21:43.589]                           }
[10:21:43.589]                           base::stop(msg)
[10:21:43.589]                         }
[10:21:43.589]                       })
[10:21:43.589]                     }
[10:21:43.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.589]                     base::options(mc.cores = 1L)
[10:21:43.589]                   }
[10:21:43.589]                   ...future.strategy.old <- future::plan("list")
[10:21:43.589]                   options(future.plan = NULL)
[10:21:43.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.589]                 }
[10:21:43.589]                 ...future.workdir <- getwd()
[10:21:43.589]             }
[10:21:43.589]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.589]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.589]         }
[10:21:43.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.589]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.589]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.589]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.589]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.589]             base::names(...future.oldOptions))
[10:21:43.589]     }
[10:21:43.589]     if (FALSE) {
[10:21:43.589]     }
[10:21:43.589]     else {
[10:21:43.589]         if (TRUE) {
[10:21:43.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.589]                 open = "w")
[10:21:43.589]         }
[10:21:43.589]         else {
[10:21:43.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.589]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.589]         }
[10:21:43.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.589]             base::sink(type = "output", split = FALSE)
[10:21:43.589]             base::close(...future.stdout)
[10:21:43.589]         }, add = TRUE)
[10:21:43.589]     }
[10:21:43.589]     ...future.frame <- base::sys.nframe()
[10:21:43.589]     ...future.conditions <- base::list()
[10:21:43.589]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.589]     if (FALSE) {
[10:21:43.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.589]     }
[10:21:43.589]     ...future.result <- base::tryCatch({
[10:21:43.589]         base::withCallingHandlers({
[10:21:43.589]             ...future.value <- base::withVisible(base::local({
[10:21:43.589]                 withCallingHandlers({
[10:21:43.589]                   {
[10:21:43.589]                     b <- a
[10:21:43.589]                     a <- 2
[10:21:43.589]                     a * b
[10:21:43.589]                   }
[10:21:43.589]                 }, immediateCondition = function(cond) {
[10:21:43.589]                   save_rds <- function (object, pathname, ...) 
[10:21:43.589]                   {
[10:21:43.589]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.589]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.589]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.589]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.589]                         fi_tmp[["mtime"]])
[10:21:43.589]                     }
[10:21:43.589]                     tryCatch({
[10:21:43.589]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.589]                     }, error = function(ex) {
[10:21:43.589]                       msg <- conditionMessage(ex)
[10:21:43.589]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.589]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.589]                         fi_tmp[["mtime"]], msg)
[10:21:43.589]                       ex$message <- msg
[10:21:43.589]                       stop(ex)
[10:21:43.589]                     })
[10:21:43.589]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.589]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.589]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.589]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.589]                       fi <- file.info(pathname)
[10:21:43.589]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.589]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.589]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.589]                         fi[["size"]], fi[["mtime"]])
[10:21:43.589]                       stop(msg)
[10:21:43.589]                     }
[10:21:43.589]                     invisible(pathname)
[10:21:43.589]                   }
[10:21:43.589]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.589]                     rootPath = tempdir()) 
[10:21:43.589]                   {
[10:21:43.589]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.589]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.589]                       tmpdir = path, fileext = ".rds")
[10:21:43.589]                     save_rds(obj, file)
[10:21:43.589]                   }
[10:21:43.589]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.589]                   {
[10:21:43.589]                     inherits <- base::inherits
[10:21:43.589]                     invokeRestart <- base::invokeRestart
[10:21:43.589]                     is.null <- base::is.null
[10:21:43.589]                     muffled <- FALSE
[10:21:43.589]                     if (inherits(cond, "message")) {
[10:21:43.589]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.589]                       if (muffled) 
[10:21:43.589]                         invokeRestart("muffleMessage")
[10:21:43.589]                     }
[10:21:43.589]                     else if (inherits(cond, "warning")) {
[10:21:43.589]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.589]                       if (muffled) 
[10:21:43.589]                         invokeRestart("muffleWarning")
[10:21:43.589]                     }
[10:21:43.589]                     else if (inherits(cond, "condition")) {
[10:21:43.589]                       if (!is.null(pattern)) {
[10:21:43.589]                         computeRestarts <- base::computeRestarts
[10:21:43.589]                         grepl <- base::grepl
[10:21:43.589]                         restarts <- computeRestarts(cond)
[10:21:43.589]                         for (restart in restarts) {
[10:21:43.589]                           name <- restart$name
[10:21:43.589]                           if (is.null(name)) 
[10:21:43.589]                             next
[10:21:43.589]                           if (!grepl(pattern, name)) 
[10:21:43.589]                             next
[10:21:43.589]                           invokeRestart(restart)
[10:21:43.589]                           muffled <- TRUE
[10:21:43.589]                           break
[10:21:43.589]                         }
[10:21:43.589]                       }
[10:21:43.589]                     }
[10:21:43.589]                     invisible(muffled)
[10:21:43.589]                   }
[10:21:43.589]                   muffleCondition(cond)
[10:21:43.589]                 })
[10:21:43.589]             }))
[10:21:43.589]             future::FutureResult(value = ...future.value$value, 
[10:21:43.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.589]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.589]                     ...future.globalenv.names))
[10:21:43.589]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.589]         }, condition = base::local({
[10:21:43.589]             c <- base::c
[10:21:43.589]             inherits <- base::inherits
[10:21:43.589]             invokeRestart <- base::invokeRestart
[10:21:43.589]             length <- base::length
[10:21:43.589]             list <- base::list
[10:21:43.589]             seq.int <- base::seq.int
[10:21:43.589]             signalCondition <- base::signalCondition
[10:21:43.589]             sys.calls <- base::sys.calls
[10:21:43.589]             `[[` <- base::`[[`
[10:21:43.589]             `+` <- base::`+`
[10:21:43.589]             `<<-` <- base::`<<-`
[10:21:43.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.589]                   3L)]
[10:21:43.589]             }
[10:21:43.589]             function(cond) {
[10:21:43.589]                 is_error <- inherits(cond, "error")
[10:21:43.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.589]                   NULL)
[10:21:43.589]                 if (is_error) {
[10:21:43.589]                   sessionInformation <- function() {
[10:21:43.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.589]                       search = base::search(), system = base::Sys.info())
[10:21:43.589]                   }
[10:21:43.589]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.589]                     cond$call), session = sessionInformation(), 
[10:21:43.589]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.589]                   signalCondition(cond)
[10:21:43.589]                 }
[10:21:43.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.589]                 "immediateCondition"))) {
[10:21:43.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.589]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.589]                   if (TRUE && !signal) {
[10:21:43.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.589]                     {
[10:21:43.589]                       inherits <- base::inherits
[10:21:43.589]                       invokeRestart <- base::invokeRestart
[10:21:43.589]                       is.null <- base::is.null
[10:21:43.589]                       muffled <- FALSE
[10:21:43.589]                       if (inherits(cond, "message")) {
[10:21:43.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.589]                         if (muffled) 
[10:21:43.589]                           invokeRestart("muffleMessage")
[10:21:43.589]                       }
[10:21:43.589]                       else if (inherits(cond, "warning")) {
[10:21:43.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.589]                         if (muffled) 
[10:21:43.589]                           invokeRestart("muffleWarning")
[10:21:43.589]                       }
[10:21:43.589]                       else if (inherits(cond, "condition")) {
[10:21:43.589]                         if (!is.null(pattern)) {
[10:21:43.589]                           computeRestarts <- base::computeRestarts
[10:21:43.589]                           grepl <- base::grepl
[10:21:43.589]                           restarts <- computeRestarts(cond)
[10:21:43.589]                           for (restart in restarts) {
[10:21:43.589]                             name <- restart$name
[10:21:43.589]                             if (is.null(name)) 
[10:21:43.589]                               next
[10:21:43.589]                             if (!grepl(pattern, name)) 
[10:21:43.589]                               next
[10:21:43.589]                             invokeRestart(restart)
[10:21:43.589]                             muffled <- TRUE
[10:21:43.589]                             break
[10:21:43.589]                           }
[10:21:43.589]                         }
[10:21:43.589]                       }
[10:21:43.589]                       invisible(muffled)
[10:21:43.589]                     }
[10:21:43.589]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.589]                   }
[10:21:43.589]                 }
[10:21:43.589]                 else {
[10:21:43.589]                   if (TRUE) {
[10:21:43.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.589]                     {
[10:21:43.589]                       inherits <- base::inherits
[10:21:43.589]                       invokeRestart <- base::invokeRestart
[10:21:43.589]                       is.null <- base::is.null
[10:21:43.589]                       muffled <- FALSE
[10:21:43.589]                       if (inherits(cond, "message")) {
[10:21:43.589]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.589]                         if (muffled) 
[10:21:43.589]                           invokeRestart("muffleMessage")
[10:21:43.589]                       }
[10:21:43.589]                       else if (inherits(cond, "warning")) {
[10:21:43.589]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.589]                         if (muffled) 
[10:21:43.589]                           invokeRestart("muffleWarning")
[10:21:43.589]                       }
[10:21:43.589]                       else if (inherits(cond, "condition")) {
[10:21:43.589]                         if (!is.null(pattern)) {
[10:21:43.589]                           computeRestarts <- base::computeRestarts
[10:21:43.589]                           grepl <- base::grepl
[10:21:43.589]                           restarts <- computeRestarts(cond)
[10:21:43.589]                           for (restart in restarts) {
[10:21:43.589]                             name <- restart$name
[10:21:43.589]                             if (is.null(name)) 
[10:21:43.589]                               next
[10:21:43.589]                             if (!grepl(pattern, name)) 
[10:21:43.589]                               next
[10:21:43.589]                             invokeRestart(restart)
[10:21:43.589]                             muffled <- TRUE
[10:21:43.589]                             break
[10:21:43.589]                           }
[10:21:43.589]                         }
[10:21:43.589]                       }
[10:21:43.589]                       invisible(muffled)
[10:21:43.589]                     }
[10:21:43.589]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.589]                   }
[10:21:43.589]                 }
[10:21:43.589]             }
[10:21:43.589]         }))
[10:21:43.589]     }, error = function(ex) {
[10:21:43.589]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.589]                 ...future.rng), started = ...future.startTime, 
[10:21:43.589]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.589]             version = "1.8"), class = "FutureResult")
[10:21:43.589]     }, finally = {
[10:21:43.589]         if (!identical(...future.workdir, getwd())) 
[10:21:43.589]             setwd(...future.workdir)
[10:21:43.589]         {
[10:21:43.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.589]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.589]             }
[10:21:43.589]             base::options(...future.oldOptions)
[10:21:43.589]             if (.Platform$OS.type == "windows") {
[10:21:43.589]                 old_names <- names(...future.oldEnvVars)
[10:21:43.589]                 envs <- base::Sys.getenv()
[10:21:43.589]                 names <- names(envs)
[10:21:43.589]                 common <- intersect(names, old_names)
[10:21:43.589]                 added <- setdiff(names, old_names)
[10:21:43.589]                 removed <- setdiff(old_names, names)
[10:21:43.589]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.589]                   envs[common]]
[10:21:43.589]                 NAMES <- toupper(changed)
[10:21:43.589]                 args <- list()
[10:21:43.589]                 for (kk in seq_along(NAMES)) {
[10:21:43.589]                   name <- changed[[kk]]
[10:21:43.589]                   NAME <- NAMES[[kk]]
[10:21:43.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.589]                     next
[10:21:43.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.589]                 }
[10:21:43.589]                 NAMES <- toupper(added)
[10:21:43.589]                 for (kk in seq_along(NAMES)) {
[10:21:43.589]                   name <- added[[kk]]
[10:21:43.589]                   NAME <- NAMES[[kk]]
[10:21:43.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.589]                     next
[10:21:43.589]                   args[[name]] <- ""
[10:21:43.589]                 }
[10:21:43.589]                 NAMES <- toupper(removed)
[10:21:43.589]                 for (kk in seq_along(NAMES)) {
[10:21:43.589]                   name <- removed[[kk]]
[10:21:43.589]                   NAME <- NAMES[[kk]]
[10:21:43.589]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.589]                     next
[10:21:43.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.589]                 }
[10:21:43.589]                 if (length(args) > 0) 
[10:21:43.589]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.589]             }
[10:21:43.589]             else {
[10:21:43.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.589]             }
[10:21:43.589]             {
[10:21:43.589]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.589]                   0L) {
[10:21:43.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.589]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.589]                   base::options(opts)
[10:21:43.589]                 }
[10:21:43.589]                 {
[10:21:43.589]                   {
[10:21:43.589]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.589]                     NULL
[10:21:43.589]                   }
[10:21:43.589]                   options(future.plan = NULL)
[10:21:43.589]                   if (is.na(NA_character_)) 
[10:21:43.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.589]                     .init = FALSE)
[10:21:43.589]                 }
[10:21:43.589]             }
[10:21:43.589]         }
[10:21:43.589]     })
[10:21:43.589]     if (TRUE) {
[10:21:43.589]         base::sink(type = "output", split = FALSE)
[10:21:43.589]         if (TRUE) {
[10:21:43.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.589]         }
[10:21:43.589]         else {
[10:21:43.589]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.589]         }
[10:21:43.589]         base::close(...future.stdout)
[10:21:43.589]         ...future.stdout <- NULL
[10:21:43.589]     }
[10:21:43.589]     ...future.result$conditions <- ...future.conditions
[10:21:43.589]     ...future.result$finished <- base::Sys.time()
[10:21:43.589]     ...future.result
[10:21:43.589] }
[10:21:43.591] requestCore(): workers = 2
[10:21:43.593] MulticoreFuture started
[10:21:43.593] - Launch lazy future ... done
[10:21:43.594] run() for ‘MulticoreFuture’ ... done
[10:21:43.594] result() for MulticoreFuture ...
[10:21:43.594] plan(): Setting new future strategy stack:
[10:21:43.594] List of future strategies:
[10:21:43.594] 1. sequential:
[10:21:43.594]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.594]    - tweaked: FALSE
[10:21:43.594]    - call: NULL
[10:21:43.601] plan(): nbrOfWorkers() = 1
[10:21:43.604] plan(): Setting new future strategy stack:
[10:21:43.604] List of future strategies:
[10:21:43.604] 1. multicore:
[10:21:43.604]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.604]    - tweaked: FALSE
[10:21:43.604]    - call: plan(strategy)
[10:21:43.608] plan(): nbrOfWorkers() = 2
[10:21:43.615] result() for MulticoreFuture ...
[10:21:43.615] result() for MulticoreFuture ... done
[10:21:43.615] signalConditions() ...
[10:21:43.616]  - include = ‘immediateCondition’
[10:21:43.616]  - exclude = 
[10:21:43.616]  - resignal = FALSE
[10:21:43.616]  - Number of conditions: 1
[10:21:43.616] signalConditions() ... done
[10:21:43.616] result() for MulticoreFuture ... done
[10:21:43.616] result() for MulticoreFuture ...
[10:21:43.617] result() for MulticoreFuture ... done
[10:21:43.617] signalConditions() ...
[10:21:43.617]  - include = ‘immediateCondition’
[10:21:43.617]  - exclude = 
[10:21:43.617]  - resignal = FALSE
[10:21:43.617]  - Number of conditions: 1
[10:21:43.617] signalConditions() ... done
[10:21:43.617] Future state: ‘finished’
[10:21:43.618] result() for MulticoreFuture ...
[10:21:43.618] result() for MulticoreFuture ... done
[10:21:43.618] signalConditions() ...
[10:21:43.618]  - include = ‘condition’
[10:21:43.618]  - exclude = ‘immediateCondition’
[10:21:43.618]  - resignal = TRUE
[10:21:43.618]  - Number of conditions: 1
[10:21:43.618]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:43.619] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:43"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.645] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.645] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.647] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.647] Searching for globals ... DONE
[10:21:43.647] Resolving globals: TRUE
[10:21:43.647] Resolving any globals that are futures ...
[10:21:43.647] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.647] Resolving any globals that are futures ... DONE
[10:21:43.647] Resolving futures part of globals (recursively) ...
[10:21:43.648] resolve() on list ...
[10:21:43.648]  recursive: 99
[10:21:43.648]  length: 1
[10:21:43.648]  elements: ‘ii’
[10:21:43.648]  length: 0 (resolved future 1)
[10:21:43.648] resolve() on list ... DONE
[10:21:43.648] - globals: [1] ‘ii’
[10:21:43.648] Resolving futures part of globals (recursively) ... DONE
[10:21:43.648] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.649] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.649] - globals: [1] ‘ii’
[10:21:43.649] 
[10:21:43.649] getGlobalsAndPackages() ... DONE
[10:21:43.649] run() for ‘Future’ ...
[10:21:43.649] - state: ‘created’
[10:21:43.650] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.651] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.652] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.652]   - Field: ‘label’
[10:21:43.652]   - Field: ‘local’
[10:21:43.652]   - Field: ‘owner’
[10:21:43.652]   - Field: ‘envir’
[10:21:43.652]   - Field: ‘workers’
[10:21:43.652]   - Field: ‘packages’
[10:21:43.652]   - Field: ‘gc’
[10:21:43.652]   - Field: ‘job’
[10:21:43.652]   - Field: ‘conditions’
[10:21:43.652]   - Field: ‘expr’
[10:21:43.653]   - Field: ‘uuid’
[10:21:43.653]   - Field: ‘seed’
[10:21:43.653]   - Field: ‘version’
[10:21:43.653]   - Field: ‘result’
[10:21:43.653]   - Field: ‘asynchronous’
[10:21:43.653]   - Field: ‘calls’
[10:21:43.653]   - Field: ‘globals’
[10:21:43.653]   - Field: ‘stdout’
[10:21:43.653]   - Field: ‘earlySignal’
[10:21:43.653]   - Field: ‘lazy’
[10:21:43.653]   - Field: ‘state’
[10:21:43.653] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.654] - Launch lazy future ...
[10:21:43.654] Packages needed by the future expression (n = 0): <none>
[10:21:43.654] Packages needed by future strategies (n = 0): <none>
[10:21:43.654] {
[10:21:43.654]     {
[10:21:43.654]         {
[10:21:43.654]             ...future.startTime <- base::Sys.time()
[10:21:43.654]             {
[10:21:43.654]                 {
[10:21:43.654]                   {
[10:21:43.654]                     {
[10:21:43.654]                       base::local({
[10:21:43.654]                         has_future <- base::requireNamespace("future", 
[10:21:43.654]                           quietly = TRUE)
[10:21:43.654]                         if (has_future) {
[10:21:43.654]                           ns <- base::getNamespace("future")
[10:21:43.654]                           version <- ns[[".package"]][["version"]]
[10:21:43.654]                           if (is.null(version)) 
[10:21:43.654]                             version <- utils::packageVersion("future")
[10:21:43.654]                         }
[10:21:43.654]                         else {
[10:21:43.654]                           version <- NULL
[10:21:43.654]                         }
[10:21:43.654]                         if (!has_future || version < "1.8.0") {
[10:21:43.654]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.654]                             "", base::R.version$version.string), 
[10:21:43.654]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.654]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.654]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.654]                               "release", "version")], collapse = " "), 
[10:21:43.654]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.654]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.654]                             info)
[10:21:43.654]                           info <- base::paste(info, collapse = "; ")
[10:21:43.654]                           if (!has_future) {
[10:21:43.654]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.654]                               info)
[10:21:43.654]                           }
[10:21:43.654]                           else {
[10:21:43.654]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.654]                               info, version)
[10:21:43.654]                           }
[10:21:43.654]                           base::stop(msg)
[10:21:43.654]                         }
[10:21:43.654]                       })
[10:21:43.654]                     }
[10:21:43.654]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.654]                     base::options(mc.cores = 1L)
[10:21:43.654]                   }
[10:21:43.654]                   ...future.strategy.old <- future::plan("list")
[10:21:43.654]                   options(future.plan = NULL)
[10:21:43.654]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.654]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.654]                 }
[10:21:43.654]                 ...future.workdir <- getwd()
[10:21:43.654]             }
[10:21:43.654]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.654]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.654]         }
[10:21:43.654]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.654]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.654]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.654]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.654]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.654]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.654]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.654]             base::names(...future.oldOptions))
[10:21:43.654]     }
[10:21:43.654]     if (FALSE) {
[10:21:43.654]     }
[10:21:43.654]     else {
[10:21:43.654]         if (TRUE) {
[10:21:43.654]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.654]                 open = "w")
[10:21:43.654]         }
[10:21:43.654]         else {
[10:21:43.654]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.654]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.654]         }
[10:21:43.654]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.654]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.654]             base::sink(type = "output", split = FALSE)
[10:21:43.654]             base::close(...future.stdout)
[10:21:43.654]         }, add = TRUE)
[10:21:43.654]     }
[10:21:43.654]     ...future.frame <- base::sys.nframe()
[10:21:43.654]     ...future.conditions <- base::list()
[10:21:43.654]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.654]     if (FALSE) {
[10:21:43.654]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.654]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.654]     }
[10:21:43.654]     ...future.result <- base::tryCatch({
[10:21:43.654]         base::withCallingHandlers({
[10:21:43.654]             ...future.value <- base::withVisible(base::local({
[10:21:43.654]                 withCallingHandlers({
[10:21:43.654]                   {
[10:21:43.654]                     b <- a * ii
[10:21:43.654]                     a <- 0
[10:21:43.654]                     b
[10:21:43.654]                   }
[10:21:43.654]                 }, immediateCondition = function(cond) {
[10:21:43.654]                   save_rds <- function (object, pathname, ...) 
[10:21:43.654]                   {
[10:21:43.654]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.654]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.654]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.654]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.654]                         fi_tmp[["mtime"]])
[10:21:43.654]                     }
[10:21:43.654]                     tryCatch({
[10:21:43.654]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.654]                     }, error = function(ex) {
[10:21:43.654]                       msg <- conditionMessage(ex)
[10:21:43.654]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.654]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.654]                         fi_tmp[["mtime"]], msg)
[10:21:43.654]                       ex$message <- msg
[10:21:43.654]                       stop(ex)
[10:21:43.654]                     })
[10:21:43.654]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.654]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.654]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.654]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.654]                       fi <- file.info(pathname)
[10:21:43.654]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.654]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.654]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.654]                         fi[["size"]], fi[["mtime"]])
[10:21:43.654]                       stop(msg)
[10:21:43.654]                     }
[10:21:43.654]                     invisible(pathname)
[10:21:43.654]                   }
[10:21:43.654]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.654]                     rootPath = tempdir()) 
[10:21:43.654]                   {
[10:21:43.654]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.654]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.654]                       tmpdir = path, fileext = ".rds")
[10:21:43.654]                     save_rds(obj, file)
[10:21:43.654]                   }
[10:21:43.654]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.654]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.654]                   {
[10:21:43.654]                     inherits <- base::inherits
[10:21:43.654]                     invokeRestart <- base::invokeRestart
[10:21:43.654]                     is.null <- base::is.null
[10:21:43.654]                     muffled <- FALSE
[10:21:43.654]                     if (inherits(cond, "message")) {
[10:21:43.654]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.654]                       if (muffled) 
[10:21:43.654]                         invokeRestart("muffleMessage")
[10:21:43.654]                     }
[10:21:43.654]                     else if (inherits(cond, "warning")) {
[10:21:43.654]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.654]                       if (muffled) 
[10:21:43.654]                         invokeRestart("muffleWarning")
[10:21:43.654]                     }
[10:21:43.654]                     else if (inherits(cond, "condition")) {
[10:21:43.654]                       if (!is.null(pattern)) {
[10:21:43.654]                         computeRestarts <- base::computeRestarts
[10:21:43.654]                         grepl <- base::grepl
[10:21:43.654]                         restarts <- computeRestarts(cond)
[10:21:43.654]                         for (restart in restarts) {
[10:21:43.654]                           name <- restart$name
[10:21:43.654]                           if (is.null(name)) 
[10:21:43.654]                             next
[10:21:43.654]                           if (!grepl(pattern, name)) 
[10:21:43.654]                             next
[10:21:43.654]                           invokeRestart(restart)
[10:21:43.654]                           muffled <- TRUE
[10:21:43.654]                           break
[10:21:43.654]                         }
[10:21:43.654]                       }
[10:21:43.654]                     }
[10:21:43.654]                     invisible(muffled)
[10:21:43.654]                   }
[10:21:43.654]                   muffleCondition(cond)
[10:21:43.654]                 })
[10:21:43.654]             }))
[10:21:43.654]             future::FutureResult(value = ...future.value$value, 
[10:21:43.654]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.654]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.654]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.654]                     ...future.globalenv.names))
[10:21:43.654]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.654]         }, condition = base::local({
[10:21:43.654]             c <- base::c
[10:21:43.654]             inherits <- base::inherits
[10:21:43.654]             invokeRestart <- base::invokeRestart
[10:21:43.654]             length <- base::length
[10:21:43.654]             list <- base::list
[10:21:43.654]             seq.int <- base::seq.int
[10:21:43.654]             signalCondition <- base::signalCondition
[10:21:43.654]             sys.calls <- base::sys.calls
[10:21:43.654]             `[[` <- base::`[[`
[10:21:43.654]             `+` <- base::`+`
[10:21:43.654]             `<<-` <- base::`<<-`
[10:21:43.654]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.654]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.654]                   3L)]
[10:21:43.654]             }
[10:21:43.654]             function(cond) {
[10:21:43.654]                 is_error <- inherits(cond, "error")
[10:21:43.654]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.654]                   NULL)
[10:21:43.654]                 if (is_error) {
[10:21:43.654]                   sessionInformation <- function() {
[10:21:43.654]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.654]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.654]                       search = base::search(), system = base::Sys.info())
[10:21:43.654]                   }
[10:21:43.654]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.654]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.654]                     cond$call), session = sessionInformation(), 
[10:21:43.654]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.654]                   signalCondition(cond)
[10:21:43.654]                 }
[10:21:43.654]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.654]                 "immediateCondition"))) {
[10:21:43.654]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.654]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.654]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.654]                   if (TRUE && !signal) {
[10:21:43.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.654]                     {
[10:21:43.654]                       inherits <- base::inherits
[10:21:43.654]                       invokeRestart <- base::invokeRestart
[10:21:43.654]                       is.null <- base::is.null
[10:21:43.654]                       muffled <- FALSE
[10:21:43.654]                       if (inherits(cond, "message")) {
[10:21:43.654]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.654]                         if (muffled) 
[10:21:43.654]                           invokeRestart("muffleMessage")
[10:21:43.654]                       }
[10:21:43.654]                       else if (inherits(cond, "warning")) {
[10:21:43.654]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.654]                         if (muffled) 
[10:21:43.654]                           invokeRestart("muffleWarning")
[10:21:43.654]                       }
[10:21:43.654]                       else if (inherits(cond, "condition")) {
[10:21:43.654]                         if (!is.null(pattern)) {
[10:21:43.654]                           computeRestarts <- base::computeRestarts
[10:21:43.654]                           grepl <- base::grepl
[10:21:43.654]                           restarts <- computeRestarts(cond)
[10:21:43.654]                           for (restart in restarts) {
[10:21:43.654]                             name <- restart$name
[10:21:43.654]                             if (is.null(name)) 
[10:21:43.654]                               next
[10:21:43.654]                             if (!grepl(pattern, name)) 
[10:21:43.654]                               next
[10:21:43.654]                             invokeRestart(restart)
[10:21:43.654]                             muffled <- TRUE
[10:21:43.654]                             break
[10:21:43.654]                           }
[10:21:43.654]                         }
[10:21:43.654]                       }
[10:21:43.654]                       invisible(muffled)
[10:21:43.654]                     }
[10:21:43.654]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.654]                   }
[10:21:43.654]                 }
[10:21:43.654]                 else {
[10:21:43.654]                   if (TRUE) {
[10:21:43.654]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.654]                     {
[10:21:43.654]                       inherits <- base::inherits
[10:21:43.654]                       invokeRestart <- base::invokeRestart
[10:21:43.654]                       is.null <- base::is.null
[10:21:43.654]                       muffled <- FALSE
[10:21:43.654]                       if (inherits(cond, "message")) {
[10:21:43.654]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.654]                         if (muffled) 
[10:21:43.654]                           invokeRestart("muffleMessage")
[10:21:43.654]                       }
[10:21:43.654]                       else if (inherits(cond, "warning")) {
[10:21:43.654]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.654]                         if (muffled) 
[10:21:43.654]                           invokeRestart("muffleWarning")
[10:21:43.654]                       }
[10:21:43.654]                       else if (inherits(cond, "condition")) {
[10:21:43.654]                         if (!is.null(pattern)) {
[10:21:43.654]                           computeRestarts <- base::computeRestarts
[10:21:43.654]                           grepl <- base::grepl
[10:21:43.654]                           restarts <- computeRestarts(cond)
[10:21:43.654]                           for (restart in restarts) {
[10:21:43.654]                             name <- restart$name
[10:21:43.654]                             if (is.null(name)) 
[10:21:43.654]                               next
[10:21:43.654]                             if (!grepl(pattern, name)) 
[10:21:43.654]                               next
[10:21:43.654]                             invokeRestart(restart)
[10:21:43.654]                             muffled <- TRUE
[10:21:43.654]                             break
[10:21:43.654]                           }
[10:21:43.654]                         }
[10:21:43.654]                       }
[10:21:43.654]                       invisible(muffled)
[10:21:43.654]                     }
[10:21:43.654]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.654]                   }
[10:21:43.654]                 }
[10:21:43.654]             }
[10:21:43.654]         }))
[10:21:43.654]     }, error = function(ex) {
[10:21:43.654]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.654]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.654]                 ...future.rng), started = ...future.startTime, 
[10:21:43.654]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.654]             version = "1.8"), class = "FutureResult")
[10:21:43.654]     }, finally = {
[10:21:43.654]         if (!identical(...future.workdir, getwd())) 
[10:21:43.654]             setwd(...future.workdir)
[10:21:43.654]         {
[10:21:43.654]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.654]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.654]             }
[10:21:43.654]             base::options(...future.oldOptions)
[10:21:43.654]             if (.Platform$OS.type == "windows") {
[10:21:43.654]                 old_names <- names(...future.oldEnvVars)
[10:21:43.654]                 envs <- base::Sys.getenv()
[10:21:43.654]                 names <- names(envs)
[10:21:43.654]                 common <- intersect(names, old_names)
[10:21:43.654]                 added <- setdiff(names, old_names)
[10:21:43.654]                 removed <- setdiff(old_names, names)
[10:21:43.654]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.654]                   envs[common]]
[10:21:43.654]                 NAMES <- toupper(changed)
[10:21:43.654]                 args <- list()
[10:21:43.654]                 for (kk in seq_along(NAMES)) {
[10:21:43.654]                   name <- changed[[kk]]
[10:21:43.654]                   NAME <- NAMES[[kk]]
[10:21:43.654]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.654]                     next
[10:21:43.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.654]                 }
[10:21:43.654]                 NAMES <- toupper(added)
[10:21:43.654]                 for (kk in seq_along(NAMES)) {
[10:21:43.654]                   name <- added[[kk]]
[10:21:43.654]                   NAME <- NAMES[[kk]]
[10:21:43.654]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.654]                     next
[10:21:43.654]                   args[[name]] <- ""
[10:21:43.654]                 }
[10:21:43.654]                 NAMES <- toupper(removed)
[10:21:43.654]                 for (kk in seq_along(NAMES)) {
[10:21:43.654]                   name <- removed[[kk]]
[10:21:43.654]                   NAME <- NAMES[[kk]]
[10:21:43.654]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.654]                     next
[10:21:43.654]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.654]                 }
[10:21:43.654]                 if (length(args) > 0) 
[10:21:43.654]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.654]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.654]             }
[10:21:43.654]             else {
[10:21:43.654]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.654]             }
[10:21:43.654]             {
[10:21:43.654]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.654]                   0L) {
[10:21:43.654]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.654]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.654]                   base::options(opts)
[10:21:43.654]                 }
[10:21:43.654]                 {
[10:21:43.654]                   {
[10:21:43.654]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.654]                     NULL
[10:21:43.654]                   }
[10:21:43.654]                   options(future.plan = NULL)
[10:21:43.654]                   if (is.na(NA_character_)) 
[10:21:43.654]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.654]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.654]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.654]                     .init = FALSE)
[10:21:43.654]                 }
[10:21:43.654]             }
[10:21:43.654]         }
[10:21:43.654]     })
[10:21:43.654]     if (TRUE) {
[10:21:43.654]         base::sink(type = "output", split = FALSE)
[10:21:43.654]         if (TRUE) {
[10:21:43.654]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.654]         }
[10:21:43.654]         else {
[10:21:43.654]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.654]         }
[10:21:43.654]         base::close(...future.stdout)
[10:21:43.654]         ...future.stdout <- NULL
[10:21:43.654]     }
[10:21:43.654]     ...future.result$conditions <- ...future.conditions
[10:21:43.654]     ...future.result$finished <- base::Sys.time()
[10:21:43.654]     ...future.result
[10:21:43.654] }
[10:21:43.657] assign_globals() ...
[10:21:43.657] List of 1
[10:21:43.657]  $ ii: int 1
[10:21:43.657]  - attr(*, "where")=List of 1
[10:21:43.657]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.657]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.657]  - attr(*, "resolved")= logi TRUE
[10:21:43.657]  - attr(*, "total_size")= num 35
[10:21:43.657]  - attr(*, "already-done")= logi TRUE
[10:21:43.659] - copied ‘ii’ to environment
[10:21:43.659] assign_globals() ... done
[10:21:43.659] requestCore(): workers = 2
[10:21:43.662] MulticoreFuture started
[10:21:43.662] - Launch lazy future ... done
[10:21:43.662] run() for ‘MulticoreFuture’ ... done
[10:21:43.663] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.663] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.663] List of future strategies:
[10:21:43.663] 1. sequential:
[10:21:43.663]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.663]    - tweaked: FALSE
[10:21:43.663]    - call: NULL
[10:21:43.664] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.664] plan(): nbrOfWorkers() = 1
[10:21:43.666] plan(): Setting new future strategy stack:
[10:21:43.666] List of future strategies:
[10:21:43.666] 1. multicore:
[10:21:43.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.666]    - tweaked: FALSE
[10:21:43.666]    - call: plan(strategy)
[10:21:43.666] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.667] Searching for globals ... DONE
[10:21:43.667] Resolving globals: TRUE
[10:21:43.667] Resolving any globals that are futures ...
[10:21:43.667] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.667] Resolving any globals that are futures ... DONE
[10:21:43.668] Resolving futures part of globals (recursively) ...
[10:21:43.668] resolve() on list ...
[10:21:43.669]  recursive: 99
[10:21:43.669]  length: 1
[10:21:43.669] plan(): nbrOfWorkers() = 2
[10:21:43.669]  elements: ‘ii’
[10:21:43.669]  length: 0 (resolved future 1)
[10:21:43.672] resolve() on list ... DONE
[10:21:43.673] - globals: [1] ‘ii’
[10:21:43.673] Resolving futures part of globals (recursively) ... DONE
[10:21:43.673] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.674] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.674] - globals: [1] ‘ii’
[10:21:43.675] 
[10:21:43.675] getGlobalsAndPackages() ... DONE
[10:21:43.675] run() for ‘Future’ ...
[10:21:43.675] - state: ‘created’
[10:21:43.676] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.679] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.679] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.679]   - Field: ‘label’
[10:21:43.679]   - Field: ‘local’
[10:21:43.679]   - Field: ‘owner’
[10:21:43.679]   - Field: ‘envir’
[10:21:43.680]   - Field: ‘workers’
[10:21:43.680]   - Field: ‘packages’
[10:21:43.680]   - Field: ‘gc’
[10:21:43.680]   - Field: ‘job’
[10:21:43.680]   - Field: ‘conditions’
[10:21:43.680]   - Field: ‘expr’
[10:21:43.681]   - Field: ‘uuid’
[10:21:43.681]   - Field: ‘seed’
[10:21:43.681]   - Field: ‘version’
[10:21:43.681]   - Field: ‘result’
[10:21:43.681]   - Field: ‘asynchronous’
[10:21:43.681]   - Field: ‘calls’
[10:21:43.681]   - Field: ‘globals’
[10:21:43.681]   - Field: ‘stdout’
[10:21:43.682]   - Field: ‘earlySignal’
[10:21:43.682]   - Field: ‘lazy’
[10:21:43.682]   - Field: ‘state’
[10:21:43.682] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.682] - Launch lazy future ...
[10:21:43.683] Packages needed by the future expression (n = 0): <none>
[10:21:43.683] Packages needed by future strategies (n = 0): <none>
[10:21:43.683] {
[10:21:43.683]     {
[10:21:43.683]         {
[10:21:43.683]             ...future.startTime <- base::Sys.time()
[10:21:43.683]             {
[10:21:43.683]                 {
[10:21:43.683]                   {
[10:21:43.683]                     {
[10:21:43.683]                       base::local({
[10:21:43.683]                         has_future <- base::requireNamespace("future", 
[10:21:43.683]                           quietly = TRUE)
[10:21:43.683]                         if (has_future) {
[10:21:43.683]                           ns <- base::getNamespace("future")
[10:21:43.683]                           version <- ns[[".package"]][["version"]]
[10:21:43.683]                           if (is.null(version)) 
[10:21:43.683]                             version <- utils::packageVersion("future")
[10:21:43.683]                         }
[10:21:43.683]                         else {
[10:21:43.683]                           version <- NULL
[10:21:43.683]                         }
[10:21:43.683]                         if (!has_future || version < "1.8.0") {
[10:21:43.683]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.683]                             "", base::R.version$version.string), 
[10:21:43.683]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.683]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.683]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.683]                               "release", "version")], collapse = " "), 
[10:21:43.683]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.683]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.683]                             info)
[10:21:43.683]                           info <- base::paste(info, collapse = "; ")
[10:21:43.683]                           if (!has_future) {
[10:21:43.683]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.683]                               info)
[10:21:43.683]                           }
[10:21:43.683]                           else {
[10:21:43.683]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.683]                               info, version)
[10:21:43.683]                           }
[10:21:43.683]                           base::stop(msg)
[10:21:43.683]                         }
[10:21:43.683]                       })
[10:21:43.683]                     }
[10:21:43.683]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.683]                     base::options(mc.cores = 1L)
[10:21:43.683]                   }
[10:21:43.683]                   ...future.strategy.old <- future::plan("list")
[10:21:43.683]                   options(future.plan = NULL)
[10:21:43.683]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.683]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.683]                 }
[10:21:43.683]                 ...future.workdir <- getwd()
[10:21:43.683]             }
[10:21:43.683]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.683]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.683]         }
[10:21:43.683]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.683]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.683]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.683]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.683]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.683]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.683]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.683]             base::names(...future.oldOptions))
[10:21:43.683]     }
[10:21:43.683]     if (FALSE) {
[10:21:43.683]     }
[10:21:43.683]     else {
[10:21:43.683]         if (TRUE) {
[10:21:43.683]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.683]                 open = "w")
[10:21:43.683]         }
[10:21:43.683]         else {
[10:21:43.683]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.683]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.683]         }
[10:21:43.683]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.683]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.683]             base::sink(type = "output", split = FALSE)
[10:21:43.683]             base::close(...future.stdout)
[10:21:43.683]         }, add = TRUE)
[10:21:43.683]     }
[10:21:43.683]     ...future.frame <- base::sys.nframe()
[10:21:43.683]     ...future.conditions <- base::list()
[10:21:43.683]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.683]     if (FALSE) {
[10:21:43.683]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.683]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.683]     }
[10:21:43.683]     ...future.result <- base::tryCatch({
[10:21:43.683]         base::withCallingHandlers({
[10:21:43.683]             ...future.value <- base::withVisible(base::local({
[10:21:43.683]                 withCallingHandlers({
[10:21:43.683]                   {
[10:21:43.683]                     b <- a * ii
[10:21:43.683]                     a <- 0
[10:21:43.683]                     b
[10:21:43.683]                   }
[10:21:43.683]                 }, immediateCondition = function(cond) {
[10:21:43.683]                   save_rds <- function (object, pathname, ...) 
[10:21:43.683]                   {
[10:21:43.683]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.683]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.683]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.683]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.683]                         fi_tmp[["mtime"]])
[10:21:43.683]                     }
[10:21:43.683]                     tryCatch({
[10:21:43.683]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.683]                     }, error = function(ex) {
[10:21:43.683]                       msg <- conditionMessage(ex)
[10:21:43.683]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.683]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.683]                         fi_tmp[["mtime"]], msg)
[10:21:43.683]                       ex$message <- msg
[10:21:43.683]                       stop(ex)
[10:21:43.683]                     })
[10:21:43.683]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.683]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.683]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.683]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.683]                       fi <- file.info(pathname)
[10:21:43.683]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.683]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.683]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.683]                         fi[["size"]], fi[["mtime"]])
[10:21:43.683]                       stop(msg)
[10:21:43.683]                     }
[10:21:43.683]                     invisible(pathname)
[10:21:43.683]                   }
[10:21:43.683]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.683]                     rootPath = tempdir()) 
[10:21:43.683]                   {
[10:21:43.683]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.683]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.683]                       tmpdir = path, fileext = ".rds")
[10:21:43.683]                     save_rds(obj, file)
[10:21:43.683]                   }
[10:21:43.683]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.683]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.683]                   {
[10:21:43.683]                     inherits <- base::inherits
[10:21:43.683]                     invokeRestart <- base::invokeRestart
[10:21:43.683]                     is.null <- base::is.null
[10:21:43.683]                     muffled <- FALSE
[10:21:43.683]                     if (inherits(cond, "message")) {
[10:21:43.683]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.683]                       if (muffled) 
[10:21:43.683]                         invokeRestart("muffleMessage")
[10:21:43.683]                     }
[10:21:43.683]                     else if (inherits(cond, "warning")) {
[10:21:43.683]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.683]                       if (muffled) 
[10:21:43.683]                         invokeRestart("muffleWarning")
[10:21:43.683]                     }
[10:21:43.683]                     else if (inherits(cond, "condition")) {
[10:21:43.683]                       if (!is.null(pattern)) {
[10:21:43.683]                         computeRestarts <- base::computeRestarts
[10:21:43.683]                         grepl <- base::grepl
[10:21:43.683]                         restarts <- computeRestarts(cond)
[10:21:43.683]                         for (restart in restarts) {
[10:21:43.683]                           name <- restart$name
[10:21:43.683]                           if (is.null(name)) 
[10:21:43.683]                             next
[10:21:43.683]                           if (!grepl(pattern, name)) 
[10:21:43.683]                             next
[10:21:43.683]                           invokeRestart(restart)
[10:21:43.683]                           muffled <- TRUE
[10:21:43.683]                           break
[10:21:43.683]                         }
[10:21:43.683]                       }
[10:21:43.683]                     }
[10:21:43.683]                     invisible(muffled)
[10:21:43.683]                   }
[10:21:43.683]                   muffleCondition(cond)
[10:21:43.683]                 })
[10:21:43.683]             }))
[10:21:43.683]             future::FutureResult(value = ...future.value$value, 
[10:21:43.683]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.683]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.683]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.683]                     ...future.globalenv.names))
[10:21:43.683]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.683]         }, condition = base::local({
[10:21:43.683]             c <- base::c
[10:21:43.683]             inherits <- base::inherits
[10:21:43.683]             invokeRestart <- base::invokeRestart
[10:21:43.683]             length <- base::length
[10:21:43.683]             list <- base::list
[10:21:43.683]             seq.int <- base::seq.int
[10:21:43.683]             signalCondition <- base::signalCondition
[10:21:43.683]             sys.calls <- base::sys.calls
[10:21:43.683]             `[[` <- base::`[[`
[10:21:43.683]             `+` <- base::`+`
[10:21:43.683]             `<<-` <- base::`<<-`
[10:21:43.683]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.683]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.683]                   3L)]
[10:21:43.683]             }
[10:21:43.683]             function(cond) {
[10:21:43.683]                 is_error <- inherits(cond, "error")
[10:21:43.683]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.683]                   NULL)
[10:21:43.683]                 if (is_error) {
[10:21:43.683]                   sessionInformation <- function() {
[10:21:43.683]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.683]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.683]                       search = base::search(), system = base::Sys.info())
[10:21:43.683]                   }
[10:21:43.683]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.683]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.683]                     cond$call), session = sessionInformation(), 
[10:21:43.683]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.683]                   signalCondition(cond)
[10:21:43.683]                 }
[10:21:43.683]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.683]                 "immediateCondition"))) {
[10:21:43.683]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.683]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.683]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.683]                   if (TRUE && !signal) {
[10:21:43.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.683]                     {
[10:21:43.683]                       inherits <- base::inherits
[10:21:43.683]                       invokeRestart <- base::invokeRestart
[10:21:43.683]                       is.null <- base::is.null
[10:21:43.683]                       muffled <- FALSE
[10:21:43.683]                       if (inherits(cond, "message")) {
[10:21:43.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.683]                         if (muffled) 
[10:21:43.683]                           invokeRestart("muffleMessage")
[10:21:43.683]                       }
[10:21:43.683]                       else if (inherits(cond, "warning")) {
[10:21:43.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.683]                         if (muffled) 
[10:21:43.683]                           invokeRestart("muffleWarning")
[10:21:43.683]                       }
[10:21:43.683]                       else if (inherits(cond, "condition")) {
[10:21:43.683]                         if (!is.null(pattern)) {
[10:21:43.683]                           computeRestarts <- base::computeRestarts
[10:21:43.683]                           grepl <- base::grepl
[10:21:43.683]                           restarts <- computeRestarts(cond)
[10:21:43.683]                           for (restart in restarts) {
[10:21:43.683]                             name <- restart$name
[10:21:43.683]                             if (is.null(name)) 
[10:21:43.683]                               next
[10:21:43.683]                             if (!grepl(pattern, name)) 
[10:21:43.683]                               next
[10:21:43.683]                             invokeRestart(restart)
[10:21:43.683]                             muffled <- TRUE
[10:21:43.683]                             break
[10:21:43.683]                           }
[10:21:43.683]                         }
[10:21:43.683]                       }
[10:21:43.683]                       invisible(muffled)
[10:21:43.683]                     }
[10:21:43.683]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.683]                   }
[10:21:43.683]                 }
[10:21:43.683]                 else {
[10:21:43.683]                   if (TRUE) {
[10:21:43.683]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.683]                     {
[10:21:43.683]                       inherits <- base::inherits
[10:21:43.683]                       invokeRestart <- base::invokeRestart
[10:21:43.683]                       is.null <- base::is.null
[10:21:43.683]                       muffled <- FALSE
[10:21:43.683]                       if (inherits(cond, "message")) {
[10:21:43.683]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.683]                         if (muffled) 
[10:21:43.683]                           invokeRestart("muffleMessage")
[10:21:43.683]                       }
[10:21:43.683]                       else if (inherits(cond, "warning")) {
[10:21:43.683]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.683]                         if (muffled) 
[10:21:43.683]                           invokeRestart("muffleWarning")
[10:21:43.683]                       }
[10:21:43.683]                       else if (inherits(cond, "condition")) {
[10:21:43.683]                         if (!is.null(pattern)) {
[10:21:43.683]                           computeRestarts <- base::computeRestarts
[10:21:43.683]                           grepl <- base::grepl
[10:21:43.683]                           restarts <- computeRestarts(cond)
[10:21:43.683]                           for (restart in restarts) {
[10:21:43.683]                             name <- restart$name
[10:21:43.683]                             if (is.null(name)) 
[10:21:43.683]                               next
[10:21:43.683]                             if (!grepl(pattern, name)) 
[10:21:43.683]                               next
[10:21:43.683]                             invokeRestart(restart)
[10:21:43.683]                             muffled <- TRUE
[10:21:43.683]                             break
[10:21:43.683]                           }
[10:21:43.683]                         }
[10:21:43.683]                       }
[10:21:43.683]                       invisible(muffled)
[10:21:43.683]                     }
[10:21:43.683]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.683]                   }
[10:21:43.683]                 }
[10:21:43.683]             }
[10:21:43.683]         }))
[10:21:43.683]     }, error = function(ex) {
[10:21:43.683]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.683]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.683]                 ...future.rng), started = ...future.startTime, 
[10:21:43.683]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.683]             version = "1.8"), class = "FutureResult")
[10:21:43.683]     }, finally = {
[10:21:43.683]         if (!identical(...future.workdir, getwd())) 
[10:21:43.683]             setwd(...future.workdir)
[10:21:43.683]         {
[10:21:43.683]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.683]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.683]             }
[10:21:43.683]             base::options(...future.oldOptions)
[10:21:43.683]             if (.Platform$OS.type == "windows") {
[10:21:43.683]                 old_names <- names(...future.oldEnvVars)
[10:21:43.683]                 envs <- base::Sys.getenv()
[10:21:43.683]                 names <- names(envs)
[10:21:43.683]                 common <- intersect(names, old_names)
[10:21:43.683]                 added <- setdiff(names, old_names)
[10:21:43.683]                 removed <- setdiff(old_names, names)
[10:21:43.683]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.683]                   envs[common]]
[10:21:43.683]                 NAMES <- toupper(changed)
[10:21:43.683]                 args <- list()
[10:21:43.683]                 for (kk in seq_along(NAMES)) {
[10:21:43.683]                   name <- changed[[kk]]
[10:21:43.683]                   NAME <- NAMES[[kk]]
[10:21:43.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.683]                     next
[10:21:43.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.683]                 }
[10:21:43.683]                 NAMES <- toupper(added)
[10:21:43.683]                 for (kk in seq_along(NAMES)) {
[10:21:43.683]                   name <- added[[kk]]
[10:21:43.683]                   NAME <- NAMES[[kk]]
[10:21:43.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.683]                     next
[10:21:43.683]                   args[[name]] <- ""
[10:21:43.683]                 }
[10:21:43.683]                 NAMES <- toupper(removed)
[10:21:43.683]                 for (kk in seq_along(NAMES)) {
[10:21:43.683]                   name <- removed[[kk]]
[10:21:43.683]                   NAME <- NAMES[[kk]]
[10:21:43.683]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.683]                     next
[10:21:43.683]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.683]                 }
[10:21:43.683]                 if (length(args) > 0) 
[10:21:43.683]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.683]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.683]             }
[10:21:43.683]             else {
[10:21:43.683]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.683]             }
[10:21:43.683]             {
[10:21:43.683]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.683]                   0L) {
[10:21:43.683]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.683]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.683]                   base::options(opts)
[10:21:43.683]                 }
[10:21:43.683]                 {
[10:21:43.683]                   {
[10:21:43.683]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.683]                     NULL
[10:21:43.683]                   }
[10:21:43.683]                   options(future.plan = NULL)
[10:21:43.683]                   if (is.na(NA_character_)) 
[10:21:43.683]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.683]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.683]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.683]                     .init = FALSE)
[10:21:43.683]                 }
[10:21:43.683]             }
[10:21:43.683]         }
[10:21:43.683]     })
[10:21:43.683]     if (TRUE) {
[10:21:43.683]         base::sink(type = "output", split = FALSE)
[10:21:43.683]         if (TRUE) {
[10:21:43.683]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.683]         }
[10:21:43.683]         else {
[10:21:43.683]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.683]         }
[10:21:43.683]         base::close(...future.stdout)
[10:21:43.683]         ...future.stdout <- NULL
[10:21:43.683]     }
[10:21:43.683]     ...future.result$conditions <- ...future.conditions
[10:21:43.683]     ...future.result$finished <- base::Sys.time()
[10:21:43.683]     ...future.result
[10:21:43.683] }
[10:21:43.686] assign_globals() ...
[10:21:43.686] List of 1
[10:21:43.686]  $ ii: int 2
[10:21:43.686]  - attr(*, "where")=List of 1
[10:21:43.686]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.686]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.686]  - attr(*, "resolved")= logi TRUE
[10:21:43.686]  - attr(*, "total_size")= num 35
[10:21:43.686]  - attr(*, "already-done")= logi TRUE
[10:21:43.690] - copied ‘ii’ to environment
[10:21:43.690] assign_globals() ... done
[10:21:43.690] requestCore(): workers = 2
[10:21:43.692] MulticoreFuture started
[10:21:43.693] - Launch lazy future ... done
[10:21:43.693] run() for ‘MulticoreFuture’ ... done
[10:21:43.693] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.694] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.694] List of future strategies:
[10:21:43.694] 1. sequential:
[10:21:43.694]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.694]    - tweaked: FALSE
[10:21:43.694]    - call: NULL
[10:21:43.694] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.695] plan(): nbrOfWorkers() = 1
[10:21:43.697] plan(): Setting new future strategy stack:
[10:21:43.697] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.697] List of future strategies:
[10:21:43.697] 1. multicore:
[10:21:43.697]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.697]    - tweaked: FALSE
[10:21:43.697]    - call: plan(strategy)
[10:21:43.697] Searching for globals ... DONE
[10:21:43.698] Resolving globals: TRUE
[10:21:43.698] Resolving any globals that are futures ...
[10:21:43.698] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.698] Resolving any globals that are futures ... DONE
[10:21:43.699] Resolving futures part of globals (recursively) ...
[10:21:43.699] resolve() on list ...
[10:21:43.699]  recursive: 99
[10:21:43.699]  length: 1
[10:21:43.700]  elements: ‘ii’
[10:21:43.700]  length: 0 (resolved future 1)
[10:21:43.700] resolve() on list ... DONE
[10:21:43.700] plan(): nbrOfWorkers() = 2
[10:21:43.700] - globals: [1] ‘ii’
[10:21:43.700] Resolving futures part of globals (recursively) ... DONE
[10:21:43.700] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.701] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.701] - globals: [1] ‘ii’
[10:21:43.701] 
[10:21:43.701] getGlobalsAndPackages() ... DONE
[10:21:43.702] run() for ‘Future’ ...
[10:21:43.702] - state: ‘created’
[10:21:43.702] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.705] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.705] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.705]   - Field: ‘label’
[10:21:43.705]   - Field: ‘local’
[10:21:43.705]   - Field: ‘owner’
[10:21:43.705]   - Field: ‘envir’
[10:21:43.705]   - Field: ‘workers’
[10:21:43.706]   - Field: ‘packages’
[10:21:43.706]   - Field: ‘gc’
[10:21:43.706]   - Field: ‘job’
[10:21:43.706]   - Field: ‘conditions’
[10:21:43.706]   - Field: ‘expr’
[10:21:43.706]   - Field: ‘uuid’
[10:21:43.706]   - Field: ‘seed’
[10:21:43.707]   - Field: ‘version’
[10:21:43.707]   - Field: ‘result’
[10:21:43.707]   - Field: ‘asynchronous’
[10:21:43.707]   - Field: ‘calls’
[10:21:43.707]   - Field: ‘globals’
[10:21:43.707]   - Field: ‘stdout’
[10:21:43.707]   - Field: ‘earlySignal’
[10:21:43.708]   - Field: ‘lazy’
[10:21:43.708]   - Field: ‘state’
[10:21:43.708] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.708] - Launch lazy future ...
[10:21:43.708] Packages needed by the future expression (n = 0): <none>
[10:21:43.709] Packages needed by future strategies (n = 0): <none>
[10:21:43.709] {
[10:21:43.709]     {
[10:21:43.709]         {
[10:21:43.709]             ...future.startTime <- base::Sys.time()
[10:21:43.709]             {
[10:21:43.709]                 {
[10:21:43.709]                   {
[10:21:43.709]                     {
[10:21:43.709]                       base::local({
[10:21:43.709]                         has_future <- base::requireNamespace("future", 
[10:21:43.709]                           quietly = TRUE)
[10:21:43.709]                         if (has_future) {
[10:21:43.709]                           ns <- base::getNamespace("future")
[10:21:43.709]                           version <- ns[[".package"]][["version"]]
[10:21:43.709]                           if (is.null(version)) 
[10:21:43.709]                             version <- utils::packageVersion("future")
[10:21:43.709]                         }
[10:21:43.709]                         else {
[10:21:43.709]                           version <- NULL
[10:21:43.709]                         }
[10:21:43.709]                         if (!has_future || version < "1.8.0") {
[10:21:43.709]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.709]                             "", base::R.version$version.string), 
[10:21:43.709]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.709]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.709]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.709]                               "release", "version")], collapse = " "), 
[10:21:43.709]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.709]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.709]                             info)
[10:21:43.709]                           info <- base::paste(info, collapse = "; ")
[10:21:43.709]                           if (!has_future) {
[10:21:43.709]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.709]                               info)
[10:21:43.709]                           }
[10:21:43.709]                           else {
[10:21:43.709]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.709]                               info, version)
[10:21:43.709]                           }
[10:21:43.709]                           base::stop(msg)
[10:21:43.709]                         }
[10:21:43.709]                       })
[10:21:43.709]                     }
[10:21:43.709]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.709]                     base::options(mc.cores = 1L)
[10:21:43.709]                   }
[10:21:43.709]                   ...future.strategy.old <- future::plan("list")
[10:21:43.709]                   options(future.plan = NULL)
[10:21:43.709]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.709]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.709]                 }
[10:21:43.709]                 ...future.workdir <- getwd()
[10:21:43.709]             }
[10:21:43.709]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.709]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.709]         }
[10:21:43.709]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.709]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.709]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.709]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.709]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.709]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.709]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.709]             base::names(...future.oldOptions))
[10:21:43.709]     }
[10:21:43.709]     if (FALSE) {
[10:21:43.709]     }
[10:21:43.709]     else {
[10:21:43.709]         if (TRUE) {
[10:21:43.709]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.709]                 open = "w")
[10:21:43.709]         }
[10:21:43.709]         else {
[10:21:43.709]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.709]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.709]         }
[10:21:43.709]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.709]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.709]             base::sink(type = "output", split = FALSE)
[10:21:43.709]             base::close(...future.stdout)
[10:21:43.709]         }, add = TRUE)
[10:21:43.709]     }
[10:21:43.709]     ...future.frame <- base::sys.nframe()
[10:21:43.709]     ...future.conditions <- base::list()
[10:21:43.709]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.709]     if (FALSE) {
[10:21:43.709]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.709]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.709]     }
[10:21:43.709]     ...future.result <- base::tryCatch({
[10:21:43.709]         base::withCallingHandlers({
[10:21:43.709]             ...future.value <- base::withVisible(base::local({
[10:21:43.709]                 withCallingHandlers({
[10:21:43.709]                   {
[10:21:43.709]                     b <- a * ii
[10:21:43.709]                     a <- 0
[10:21:43.709]                     b
[10:21:43.709]                   }
[10:21:43.709]                 }, immediateCondition = function(cond) {
[10:21:43.709]                   save_rds <- function (object, pathname, ...) 
[10:21:43.709]                   {
[10:21:43.709]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.709]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.709]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.709]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.709]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.709]                         fi_tmp[["mtime"]])
[10:21:43.709]                     }
[10:21:43.709]                     tryCatch({
[10:21:43.709]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.709]                     }, error = function(ex) {
[10:21:43.709]                       msg <- conditionMessage(ex)
[10:21:43.709]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.709]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.709]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.709]                         fi_tmp[["mtime"]], msg)
[10:21:43.709]                       ex$message <- msg
[10:21:43.709]                       stop(ex)
[10:21:43.709]                     })
[10:21:43.709]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.709]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.709]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.709]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.709]                       fi <- file.info(pathname)
[10:21:43.709]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.709]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.709]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.709]                         fi[["size"]], fi[["mtime"]])
[10:21:43.709]                       stop(msg)
[10:21:43.709]                     }
[10:21:43.709]                     invisible(pathname)
[10:21:43.709]                   }
[10:21:43.709]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.709]                     rootPath = tempdir()) 
[10:21:43.709]                   {
[10:21:43.709]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.709]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.709]                       tmpdir = path, fileext = ".rds")
[10:21:43.709]                     save_rds(obj, file)
[10:21:43.709]                   }
[10:21:43.709]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.709]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.709]                   {
[10:21:43.709]                     inherits <- base::inherits
[10:21:43.709]                     invokeRestart <- base::invokeRestart
[10:21:43.709]                     is.null <- base::is.null
[10:21:43.709]                     muffled <- FALSE
[10:21:43.709]                     if (inherits(cond, "message")) {
[10:21:43.709]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.709]                       if (muffled) 
[10:21:43.709]                         invokeRestart("muffleMessage")
[10:21:43.709]                     }
[10:21:43.709]                     else if (inherits(cond, "warning")) {
[10:21:43.709]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.709]                       if (muffled) 
[10:21:43.709]                         invokeRestart("muffleWarning")
[10:21:43.709]                     }
[10:21:43.709]                     else if (inherits(cond, "condition")) {
[10:21:43.709]                       if (!is.null(pattern)) {
[10:21:43.709]                         computeRestarts <- base::computeRestarts
[10:21:43.709]                         grepl <- base::grepl
[10:21:43.709]                         restarts <- computeRestarts(cond)
[10:21:43.709]                         for (restart in restarts) {
[10:21:43.709]                           name <- restart$name
[10:21:43.709]                           if (is.null(name)) 
[10:21:43.709]                             next
[10:21:43.709]                           if (!grepl(pattern, name)) 
[10:21:43.709]                             next
[10:21:43.709]                           invokeRestart(restart)
[10:21:43.709]                           muffled <- TRUE
[10:21:43.709]                           break
[10:21:43.709]                         }
[10:21:43.709]                       }
[10:21:43.709]                     }
[10:21:43.709]                     invisible(muffled)
[10:21:43.709]                   }
[10:21:43.709]                   muffleCondition(cond)
[10:21:43.709]                 })
[10:21:43.709]             }))
[10:21:43.709]             future::FutureResult(value = ...future.value$value, 
[10:21:43.709]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.709]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.709]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.709]                     ...future.globalenv.names))
[10:21:43.709]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.709]         }, condition = base::local({
[10:21:43.709]             c <- base::c
[10:21:43.709]             inherits <- base::inherits
[10:21:43.709]             invokeRestart <- base::invokeRestart
[10:21:43.709]             length <- base::length
[10:21:43.709]             list <- base::list
[10:21:43.709]             seq.int <- base::seq.int
[10:21:43.709]             signalCondition <- base::signalCondition
[10:21:43.709]             sys.calls <- base::sys.calls
[10:21:43.709]             `[[` <- base::`[[`
[10:21:43.709]             `+` <- base::`+`
[10:21:43.709]             `<<-` <- base::`<<-`
[10:21:43.709]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.709]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.709]                   3L)]
[10:21:43.709]             }
[10:21:43.709]             function(cond) {
[10:21:43.709]                 is_error <- inherits(cond, "error")
[10:21:43.709]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.709]                   NULL)
[10:21:43.709]                 if (is_error) {
[10:21:43.709]                   sessionInformation <- function() {
[10:21:43.709]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.709]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.709]                       search = base::search(), system = base::Sys.info())
[10:21:43.709]                   }
[10:21:43.709]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.709]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.709]                     cond$call), session = sessionInformation(), 
[10:21:43.709]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.709]                   signalCondition(cond)
[10:21:43.709]                 }
[10:21:43.709]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.709]                 "immediateCondition"))) {
[10:21:43.709]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.709]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.709]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.709]                   if (TRUE && !signal) {
[10:21:43.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.709]                     {
[10:21:43.709]                       inherits <- base::inherits
[10:21:43.709]                       invokeRestart <- base::invokeRestart
[10:21:43.709]                       is.null <- base::is.null
[10:21:43.709]                       muffled <- FALSE
[10:21:43.709]                       if (inherits(cond, "message")) {
[10:21:43.709]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.709]                         if (muffled) 
[10:21:43.709]                           invokeRestart("muffleMessage")
[10:21:43.709]                       }
[10:21:43.709]                       else if (inherits(cond, "warning")) {
[10:21:43.709]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.709]                         if (muffled) 
[10:21:43.709]                           invokeRestart("muffleWarning")
[10:21:43.709]                       }
[10:21:43.709]                       else if (inherits(cond, "condition")) {
[10:21:43.709]                         if (!is.null(pattern)) {
[10:21:43.709]                           computeRestarts <- base::computeRestarts
[10:21:43.709]                           grepl <- base::grepl
[10:21:43.709]                           restarts <- computeRestarts(cond)
[10:21:43.709]                           for (restart in restarts) {
[10:21:43.709]                             name <- restart$name
[10:21:43.709]                             if (is.null(name)) 
[10:21:43.709]                               next
[10:21:43.709]                             if (!grepl(pattern, name)) 
[10:21:43.709]                               next
[10:21:43.709]                             invokeRestart(restart)
[10:21:43.709]                             muffled <- TRUE
[10:21:43.709]                             break
[10:21:43.709]                           }
[10:21:43.709]                         }
[10:21:43.709]                       }
[10:21:43.709]                       invisible(muffled)
[10:21:43.709]                     }
[10:21:43.709]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.709]                   }
[10:21:43.709]                 }
[10:21:43.709]                 else {
[10:21:43.709]                   if (TRUE) {
[10:21:43.709]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.709]                     {
[10:21:43.709]                       inherits <- base::inherits
[10:21:43.709]                       invokeRestart <- base::invokeRestart
[10:21:43.709]                       is.null <- base::is.null
[10:21:43.709]                       muffled <- FALSE
[10:21:43.709]                       if (inherits(cond, "message")) {
[10:21:43.709]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.709]                         if (muffled) 
[10:21:43.709]                           invokeRestart("muffleMessage")
[10:21:43.709]                       }
[10:21:43.709]                       else if (inherits(cond, "warning")) {
[10:21:43.709]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.709]                         if (muffled) 
[10:21:43.709]                           invokeRestart("muffleWarning")
[10:21:43.709]                       }
[10:21:43.709]                       else if (inherits(cond, "condition")) {
[10:21:43.709]                         if (!is.null(pattern)) {
[10:21:43.709]                           computeRestarts <- base::computeRestarts
[10:21:43.709]                           grepl <- base::grepl
[10:21:43.709]                           restarts <- computeRestarts(cond)
[10:21:43.709]                           for (restart in restarts) {
[10:21:43.709]                             name <- restart$name
[10:21:43.709]                             if (is.null(name)) 
[10:21:43.709]                               next
[10:21:43.709]                             if (!grepl(pattern, name)) 
[10:21:43.709]                               next
[10:21:43.709]                             invokeRestart(restart)
[10:21:43.709]                             muffled <- TRUE
[10:21:43.709]                             break
[10:21:43.709]                           }
[10:21:43.709]                         }
[10:21:43.709]                       }
[10:21:43.709]                       invisible(muffled)
[10:21:43.709]                     }
[10:21:43.709]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.709]                   }
[10:21:43.709]                 }
[10:21:43.709]             }
[10:21:43.709]         }))
[10:21:43.709]     }, error = function(ex) {
[10:21:43.709]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.709]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.709]                 ...future.rng), started = ...future.startTime, 
[10:21:43.709]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.709]             version = "1.8"), class = "FutureResult")
[10:21:43.709]     }, finally = {
[10:21:43.709]         if (!identical(...future.workdir, getwd())) 
[10:21:43.709]             setwd(...future.workdir)
[10:21:43.709]         {
[10:21:43.709]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.709]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.709]             }
[10:21:43.709]             base::options(...future.oldOptions)
[10:21:43.709]             if (.Platform$OS.type == "windows") {
[10:21:43.709]                 old_names <- names(...future.oldEnvVars)
[10:21:43.709]                 envs <- base::Sys.getenv()
[10:21:43.709]                 names <- names(envs)
[10:21:43.709]                 common <- intersect(names, old_names)
[10:21:43.709]                 added <- setdiff(names, old_names)
[10:21:43.709]                 removed <- setdiff(old_names, names)
[10:21:43.709]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.709]                   envs[common]]
[10:21:43.709]                 NAMES <- toupper(changed)
[10:21:43.709]                 args <- list()
[10:21:43.709]                 for (kk in seq_along(NAMES)) {
[10:21:43.709]                   name <- changed[[kk]]
[10:21:43.709]                   NAME <- NAMES[[kk]]
[10:21:43.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.709]                     next
[10:21:43.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.709]                 }
[10:21:43.709]                 NAMES <- toupper(added)
[10:21:43.709]                 for (kk in seq_along(NAMES)) {
[10:21:43.709]                   name <- added[[kk]]
[10:21:43.709]                   NAME <- NAMES[[kk]]
[10:21:43.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.709]                     next
[10:21:43.709]                   args[[name]] <- ""
[10:21:43.709]                 }
[10:21:43.709]                 NAMES <- toupper(removed)
[10:21:43.709]                 for (kk in seq_along(NAMES)) {
[10:21:43.709]                   name <- removed[[kk]]
[10:21:43.709]                   NAME <- NAMES[[kk]]
[10:21:43.709]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.709]                     next
[10:21:43.709]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.709]                 }
[10:21:43.709]                 if (length(args) > 0) 
[10:21:43.709]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.709]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.709]             }
[10:21:43.709]             else {
[10:21:43.709]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.709]             }
[10:21:43.709]             {
[10:21:43.709]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.709]                   0L) {
[10:21:43.709]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.709]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.709]                   base::options(opts)
[10:21:43.709]                 }
[10:21:43.709]                 {
[10:21:43.709]                   {
[10:21:43.709]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.709]                     NULL
[10:21:43.709]                   }
[10:21:43.709]                   options(future.plan = NULL)
[10:21:43.709]                   if (is.na(NA_character_)) 
[10:21:43.709]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.709]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.709]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.709]                     .init = FALSE)
[10:21:43.709]                 }
[10:21:43.709]             }
[10:21:43.709]         }
[10:21:43.709]     })
[10:21:43.709]     if (TRUE) {
[10:21:43.709]         base::sink(type = "output", split = FALSE)
[10:21:43.709]         if (TRUE) {
[10:21:43.709]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.709]         }
[10:21:43.709]         else {
[10:21:43.709]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.709]         }
[10:21:43.709]         base::close(...future.stdout)
[10:21:43.709]         ...future.stdout <- NULL
[10:21:43.709]     }
[10:21:43.709]     ...future.result$conditions <- ...future.conditions
[10:21:43.709]     ...future.result$finished <- base::Sys.time()
[10:21:43.709]     ...future.result
[10:21:43.709] }
[10:21:43.712] assign_globals() ...
[10:21:43.713] List of 1
[10:21:43.713]  $ ii: int 3
[10:21:43.713]  - attr(*, "where")=List of 1
[10:21:43.713]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.713]  - attr(*, "resolved")= logi TRUE
[10:21:43.713]  - attr(*, "total_size")= num 35
[10:21:43.713]  - attr(*, "already-done")= logi TRUE
[10:21:43.720] - copied ‘ii’ to environment
[10:21:43.720] assign_globals() ... done
[10:21:43.720] requestCore(): workers = 2
[10:21:43.720] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:43.732] result() for MulticoreFuture ...
[10:21:43.733] result() for MulticoreFuture ...
[10:21:43.733] result() for MulticoreFuture ... done
[10:21:43.733] result() for MulticoreFuture ... done
[10:21:43.733] result() for MulticoreFuture ...
[10:21:43.733] result() for MulticoreFuture ... done
[10:21:43.736] MulticoreFuture started
[10:21:43.737] - Launch lazy future ... done
[10:21:43.737] run() for ‘MulticoreFuture’ ... done
[10:21:43.737] plan(): Setting new future strategy stack:
[10:21:43.738] result() for MulticoreFuture ...
[10:21:43.738] result() for MulticoreFuture ... done
[10:21:43.739] result() for MulticoreFuture ...
[10:21:43.739] result() for MulticoreFuture ... done
[10:21:43.738] List of future strategies:
[10:21:43.738] 1. sequential:
[10:21:43.738]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.738]    - tweaked: FALSE
[10:21:43.738]    - call: NULL
[10:21:43.739] result() for MulticoreFuture ...
[10:21:43.739] plan(): nbrOfWorkers() = 1
[10:21:43.741] result() for MulticoreFuture ...
[10:21:43.741] result() for MulticoreFuture ... done
[10:21:43.741] result() for MulticoreFuture ... done
[10:21:43.742] result() for MulticoreFuture ...
[10:21:43.742] result() for MulticoreFuture ... done
[10:21:43.742] plan(): Setting new future strategy stack:
[10:21:43.742] result() for MulticoreFuture ...
[10:21:43.742] List of future strategies:
[10:21:43.742] 1. multicore:
[10:21:43.742]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.742]    - tweaked: FALSE
[10:21:43.742]    - call: plan(strategy)
[10:21:43.746] plan(): nbrOfWorkers() = 2
[10:21:43.746] result() for MulticoreFuture ...
[10:21:43.747] result() for MulticoreFuture ... done
[10:21:43.747] result() for MulticoreFuture ... done
[10:21:43.747] result() for MulticoreFuture ...
[10:21:43.747] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.748] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.749] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.751] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.751] Searching for globals ... DONE
[10:21:43.751] Resolving globals: TRUE
[10:21:43.751] Resolving any globals that are futures ...
[10:21:43.751] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.752] Resolving any globals that are futures ... DONE
[10:21:43.752] Resolving futures part of globals (recursively) ...
[10:21:43.752] resolve() on list ...
[10:21:43.752]  recursive: 99
[10:21:43.753]  length: 1
[10:21:43.753]  elements: ‘ii’
[10:21:43.753]  length: 0 (resolved future 1)
[10:21:43.753] resolve() on list ... DONE
[10:21:43.753] - globals: [1] ‘ii’
[10:21:43.753] Resolving futures part of globals (recursively) ... DONE
[10:21:43.753] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.754] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.754] - globals: [1] ‘ii’
[10:21:43.754] 
[10:21:43.754] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.755] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.755] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.757] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.757] Searching for globals ... DONE
[10:21:43.757] Resolving globals: TRUE
[10:21:43.757] Resolving any globals that are futures ...
[10:21:43.757] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.757] Resolving any globals that are futures ... DONE
[10:21:43.758] Resolving futures part of globals (recursively) ...
[10:21:43.758] resolve() on list ...
[10:21:43.758]  recursive: 99
[10:21:43.758]  length: 1
[10:21:43.758]  elements: ‘ii’
[10:21:43.759]  length: 0 (resolved future 1)
[10:21:43.759] resolve() on list ... DONE
[10:21:43.759] - globals: [1] ‘ii’
[10:21:43.759] Resolving futures part of globals (recursively) ... DONE
[10:21:43.759] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.759] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.759] - globals: [1] ‘ii’
[10:21:43.760] 
[10:21:43.760] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.760] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.761] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.762] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.762] Searching for globals ... DONE
[10:21:43.762] Resolving globals: TRUE
[10:21:43.763] Resolving any globals that are futures ...
[10:21:43.763] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:43.763] Resolving any globals that are futures ... DONE
[10:21:43.763] Resolving futures part of globals (recursively) ...
[10:21:43.763] resolve() on list ...
[10:21:43.764]  recursive: 99
[10:21:43.764]  length: 1
[10:21:43.764]  elements: ‘ii’
[10:21:43.764]  length: 0 (resolved future 1)
[10:21:43.764] resolve() on list ... DONE
[10:21:43.764] - globals: [1] ‘ii’
[10:21:43.764] Resolving futures part of globals (recursively) ... DONE
[10:21:43.764] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:43.765] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:43.765] - globals: [1] ‘ii’
[10:21:43.765] 
[10:21:43.765] getGlobalsAndPackages() ... DONE
[10:21:43.766] run() for ‘Future’ ...
[10:21:43.766] - state: ‘created’
[10:21:43.768] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.770] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.770] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.770]   - Field: ‘label’
[10:21:43.770]   - Field: ‘local’
[10:21:43.770]   - Field: ‘owner’
[10:21:43.770]   - Field: ‘envir’
[10:21:43.771]   - Field: ‘workers’
[10:21:43.771]   - Field: ‘packages’
[10:21:43.771]   - Field: ‘gc’
[10:21:43.771]   - Field: ‘job’
[10:21:43.771]   - Field: ‘conditions’
[10:21:43.771]   - Field: ‘expr’
[10:21:43.771]   - Field: ‘uuid’
[10:21:43.771]   - Field: ‘seed’
[10:21:43.771]   - Field: ‘version’
[10:21:43.772]   - Field: ‘result’
[10:21:43.772]   - Field: ‘asynchronous’
[10:21:43.772]   - Field: ‘calls’
[10:21:43.772]   - Field: ‘globals’
[10:21:43.772]   - Field: ‘stdout’
[10:21:43.772]   - Field: ‘earlySignal’
[10:21:43.772]   - Field: ‘lazy’
[10:21:43.772]   - Field: ‘state’
[10:21:43.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.772] - Launch lazy future ...
[10:21:43.773] Packages needed by the future expression (n = 0): <none>
[10:21:43.773] Packages needed by future strategies (n = 0): <none>
[10:21:43.773] {
[10:21:43.773]     {
[10:21:43.773]         {
[10:21:43.773]             ...future.startTime <- base::Sys.time()
[10:21:43.773]             {
[10:21:43.773]                 {
[10:21:43.773]                   {
[10:21:43.773]                     {
[10:21:43.773]                       base::local({
[10:21:43.773]                         has_future <- base::requireNamespace("future", 
[10:21:43.773]                           quietly = TRUE)
[10:21:43.773]                         if (has_future) {
[10:21:43.773]                           ns <- base::getNamespace("future")
[10:21:43.773]                           version <- ns[[".package"]][["version"]]
[10:21:43.773]                           if (is.null(version)) 
[10:21:43.773]                             version <- utils::packageVersion("future")
[10:21:43.773]                         }
[10:21:43.773]                         else {
[10:21:43.773]                           version <- NULL
[10:21:43.773]                         }
[10:21:43.773]                         if (!has_future || version < "1.8.0") {
[10:21:43.773]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.773]                             "", base::R.version$version.string), 
[10:21:43.773]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.773]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.773]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.773]                               "release", "version")], collapse = " "), 
[10:21:43.773]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.773]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.773]                             info)
[10:21:43.773]                           info <- base::paste(info, collapse = "; ")
[10:21:43.773]                           if (!has_future) {
[10:21:43.773]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.773]                               info)
[10:21:43.773]                           }
[10:21:43.773]                           else {
[10:21:43.773]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.773]                               info, version)
[10:21:43.773]                           }
[10:21:43.773]                           base::stop(msg)
[10:21:43.773]                         }
[10:21:43.773]                       })
[10:21:43.773]                     }
[10:21:43.773]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.773]                     base::options(mc.cores = 1L)
[10:21:43.773]                   }
[10:21:43.773]                   ...future.strategy.old <- future::plan("list")
[10:21:43.773]                   options(future.plan = NULL)
[10:21:43.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.773]                 }
[10:21:43.773]                 ...future.workdir <- getwd()
[10:21:43.773]             }
[10:21:43.773]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.773]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.773]         }
[10:21:43.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.773]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.773]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.773]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.773]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.773]             base::names(...future.oldOptions))
[10:21:43.773]     }
[10:21:43.773]     if (FALSE) {
[10:21:43.773]     }
[10:21:43.773]     else {
[10:21:43.773]         if (TRUE) {
[10:21:43.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.773]                 open = "w")
[10:21:43.773]         }
[10:21:43.773]         else {
[10:21:43.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.773]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.773]         }
[10:21:43.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.773]             base::sink(type = "output", split = FALSE)
[10:21:43.773]             base::close(...future.stdout)
[10:21:43.773]         }, add = TRUE)
[10:21:43.773]     }
[10:21:43.773]     ...future.frame <- base::sys.nframe()
[10:21:43.773]     ...future.conditions <- base::list()
[10:21:43.773]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.773]     if (FALSE) {
[10:21:43.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.773]     }
[10:21:43.773]     ...future.result <- base::tryCatch({
[10:21:43.773]         base::withCallingHandlers({
[10:21:43.773]             ...future.value <- base::withVisible(base::local({
[10:21:43.773]                 withCallingHandlers({
[10:21:43.773]                   {
[10:21:43.773]                     b <- a * ii
[10:21:43.773]                     a <- 0
[10:21:43.773]                     b
[10:21:43.773]                   }
[10:21:43.773]                 }, immediateCondition = function(cond) {
[10:21:43.773]                   save_rds <- function (object, pathname, ...) 
[10:21:43.773]                   {
[10:21:43.773]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.773]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.773]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.773]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.773]                         fi_tmp[["mtime"]])
[10:21:43.773]                     }
[10:21:43.773]                     tryCatch({
[10:21:43.773]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.773]                     }, error = function(ex) {
[10:21:43.773]                       msg <- conditionMessage(ex)
[10:21:43.773]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.773]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.773]                         fi_tmp[["mtime"]], msg)
[10:21:43.773]                       ex$message <- msg
[10:21:43.773]                       stop(ex)
[10:21:43.773]                     })
[10:21:43.773]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.773]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.773]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.773]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.773]                       fi <- file.info(pathname)
[10:21:43.773]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.773]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.773]                         fi[["size"]], fi[["mtime"]])
[10:21:43.773]                       stop(msg)
[10:21:43.773]                     }
[10:21:43.773]                     invisible(pathname)
[10:21:43.773]                   }
[10:21:43.773]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.773]                     rootPath = tempdir()) 
[10:21:43.773]                   {
[10:21:43.773]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.773]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.773]                       tmpdir = path, fileext = ".rds")
[10:21:43.773]                     save_rds(obj, file)
[10:21:43.773]                   }
[10:21:43.773]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.773]                   {
[10:21:43.773]                     inherits <- base::inherits
[10:21:43.773]                     invokeRestart <- base::invokeRestart
[10:21:43.773]                     is.null <- base::is.null
[10:21:43.773]                     muffled <- FALSE
[10:21:43.773]                     if (inherits(cond, "message")) {
[10:21:43.773]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.773]                       if (muffled) 
[10:21:43.773]                         invokeRestart("muffleMessage")
[10:21:43.773]                     }
[10:21:43.773]                     else if (inherits(cond, "warning")) {
[10:21:43.773]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.773]                       if (muffled) 
[10:21:43.773]                         invokeRestart("muffleWarning")
[10:21:43.773]                     }
[10:21:43.773]                     else if (inherits(cond, "condition")) {
[10:21:43.773]                       if (!is.null(pattern)) {
[10:21:43.773]                         computeRestarts <- base::computeRestarts
[10:21:43.773]                         grepl <- base::grepl
[10:21:43.773]                         restarts <- computeRestarts(cond)
[10:21:43.773]                         for (restart in restarts) {
[10:21:43.773]                           name <- restart$name
[10:21:43.773]                           if (is.null(name)) 
[10:21:43.773]                             next
[10:21:43.773]                           if (!grepl(pattern, name)) 
[10:21:43.773]                             next
[10:21:43.773]                           invokeRestart(restart)
[10:21:43.773]                           muffled <- TRUE
[10:21:43.773]                           break
[10:21:43.773]                         }
[10:21:43.773]                       }
[10:21:43.773]                     }
[10:21:43.773]                     invisible(muffled)
[10:21:43.773]                   }
[10:21:43.773]                   muffleCondition(cond)
[10:21:43.773]                 })
[10:21:43.773]             }))
[10:21:43.773]             future::FutureResult(value = ...future.value$value, 
[10:21:43.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.773]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.773]                     ...future.globalenv.names))
[10:21:43.773]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.773]         }, condition = base::local({
[10:21:43.773]             c <- base::c
[10:21:43.773]             inherits <- base::inherits
[10:21:43.773]             invokeRestart <- base::invokeRestart
[10:21:43.773]             length <- base::length
[10:21:43.773]             list <- base::list
[10:21:43.773]             seq.int <- base::seq.int
[10:21:43.773]             signalCondition <- base::signalCondition
[10:21:43.773]             sys.calls <- base::sys.calls
[10:21:43.773]             `[[` <- base::`[[`
[10:21:43.773]             `+` <- base::`+`
[10:21:43.773]             `<<-` <- base::`<<-`
[10:21:43.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.773]                   3L)]
[10:21:43.773]             }
[10:21:43.773]             function(cond) {
[10:21:43.773]                 is_error <- inherits(cond, "error")
[10:21:43.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.773]                   NULL)
[10:21:43.773]                 if (is_error) {
[10:21:43.773]                   sessionInformation <- function() {
[10:21:43.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.773]                       search = base::search(), system = base::Sys.info())
[10:21:43.773]                   }
[10:21:43.773]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.773]                     cond$call), session = sessionInformation(), 
[10:21:43.773]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.773]                   signalCondition(cond)
[10:21:43.773]                 }
[10:21:43.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.773]                 "immediateCondition"))) {
[10:21:43.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.773]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.773]                   if (TRUE && !signal) {
[10:21:43.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.773]                     {
[10:21:43.773]                       inherits <- base::inherits
[10:21:43.773]                       invokeRestart <- base::invokeRestart
[10:21:43.773]                       is.null <- base::is.null
[10:21:43.773]                       muffled <- FALSE
[10:21:43.773]                       if (inherits(cond, "message")) {
[10:21:43.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.773]                         if (muffled) 
[10:21:43.773]                           invokeRestart("muffleMessage")
[10:21:43.773]                       }
[10:21:43.773]                       else if (inherits(cond, "warning")) {
[10:21:43.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.773]                         if (muffled) 
[10:21:43.773]                           invokeRestart("muffleWarning")
[10:21:43.773]                       }
[10:21:43.773]                       else if (inherits(cond, "condition")) {
[10:21:43.773]                         if (!is.null(pattern)) {
[10:21:43.773]                           computeRestarts <- base::computeRestarts
[10:21:43.773]                           grepl <- base::grepl
[10:21:43.773]                           restarts <- computeRestarts(cond)
[10:21:43.773]                           for (restart in restarts) {
[10:21:43.773]                             name <- restart$name
[10:21:43.773]                             if (is.null(name)) 
[10:21:43.773]                               next
[10:21:43.773]                             if (!grepl(pattern, name)) 
[10:21:43.773]                               next
[10:21:43.773]                             invokeRestart(restart)
[10:21:43.773]                             muffled <- TRUE
[10:21:43.773]                             break
[10:21:43.773]                           }
[10:21:43.773]                         }
[10:21:43.773]                       }
[10:21:43.773]                       invisible(muffled)
[10:21:43.773]                     }
[10:21:43.773]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.773]                   }
[10:21:43.773]                 }
[10:21:43.773]                 else {
[10:21:43.773]                   if (TRUE) {
[10:21:43.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.773]                     {
[10:21:43.773]                       inherits <- base::inherits
[10:21:43.773]                       invokeRestart <- base::invokeRestart
[10:21:43.773]                       is.null <- base::is.null
[10:21:43.773]                       muffled <- FALSE
[10:21:43.773]                       if (inherits(cond, "message")) {
[10:21:43.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.773]                         if (muffled) 
[10:21:43.773]                           invokeRestart("muffleMessage")
[10:21:43.773]                       }
[10:21:43.773]                       else if (inherits(cond, "warning")) {
[10:21:43.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.773]                         if (muffled) 
[10:21:43.773]                           invokeRestart("muffleWarning")
[10:21:43.773]                       }
[10:21:43.773]                       else if (inherits(cond, "condition")) {
[10:21:43.773]                         if (!is.null(pattern)) {
[10:21:43.773]                           computeRestarts <- base::computeRestarts
[10:21:43.773]                           grepl <- base::grepl
[10:21:43.773]                           restarts <- computeRestarts(cond)
[10:21:43.773]                           for (restart in restarts) {
[10:21:43.773]                             name <- restart$name
[10:21:43.773]                             if (is.null(name)) 
[10:21:43.773]                               next
[10:21:43.773]                             if (!grepl(pattern, name)) 
[10:21:43.773]                               next
[10:21:43.773]                             invokeRestart(restart)
[10:21:43.773]                             muffled <- TRUE
[10:21:43.773]                             break
[10:21:43.773]                           }
[10:21:43.773]                         }
[10:21:43.773]                       }
[10:21:43.773]                       invisible(muffled)
[10:21:43.773]                     }
[10:21:43.773]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.773]                   }
[10:21:43.773]                 }
[10:21:43.773]             }
[10:21:43.773]         }))
[10:21:43.773]     }, error = function(ex) {
[10:21:43.773]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.773]                 ...future.rng), started = ...future.startTime, 
[10:21:43.773]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.773]             version = "1.8"), class = "FutureResult")
[10:21:43.773]     }, finally = {
[10:21:43.773]         if (!identical(...future.workdir, getwd())) 
[10:21:43.773]             setwd(...future.workdir)
[10:21:43.773]         {
[10:21:43.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.773]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.773]             }
[10:21:43.773]             base::options(...future.oldOptions)
[10:21:43.773]             if (.Platform$OS.type == "windows") {
[10:21:43.773]                 old_names <- names(...future.oldEnvVars)
[10:21:43.773]                 envs <- base::Sys.getenv()
[10:21:43.773]                 names <- names(envs)
[10:21:43.773]                 common <- intersect(names, old_names)
[10:21:43.773]                 added <- setdiff(names, old_names)
[10:21:43.773]                 removed <- setdiff(old_names, names)
[10:21:43.773]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.773]                   envs[common]]
[10:21:43.773]                 NAMES <- toupper(changed)
[10:21:43.773]                 args <- list()
[10:21:43.773]                 for (kk in seq_along(NAMES)) {
[10:21:43.773]                   name <- changed[[kk]]
[10:21:43.773]                   NAME <- NAMES[[kk]]
[10:21:43.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.773]                     next
[10:21:43.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.773]                 }
[10:21:43.773]                 NAMES <- toupper(added)
[10:21:43.773]                 for (kk in seq_along(NAMES)) {
[10:21:43.773]                   name <- added[[kk]]
[10:21:43.773]                   NAME <- NAMES[[kk]]
[10:21:43.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.773]                     next
[10:21:43.773]                   args[[name]] <- ""
[10:21:43.773]                 }
[10:21:43.773]                 NAMES <- toupper(removed)
[10:21:43.773]                 for (kk in seq_along(NAMES)) {
[10:21:43.773]                   name <- removed[[kk]]
[10:21:43.773]                   NAME <- NAMES[[kk]]
[10:21:43.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.773]                     next
[10:21:43.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.773]                 }
[10:21:43.773]                 if (length(args) > 0) 
[10:21:43.773]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.773]             }
[10:21:43.773]             else {
[10:21:43.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.773]             }
[10:21:43.773]             {
[10:21:43.773]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.773]                   0L) {
[10:21:43.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.773]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.773]                   base::options(opts)
[10:21:43.773]                 }
[10:21:43.773]                 {
[10:21:43.773]                   {
[10:21:43.773]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.773]                     NULL
[10:21:43.773]                   }
[10:21:43.773]                   options(future.plan = NULL)
[10:21:43.773]                   if (is.na(NA_character_)) 
[10:21:43.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.773]                     .init = FALSE)
[10:21:43.773]                 }
[10:21:43.773]             }
[10:21:43.773]         }
[10:21:43.773]     })
[10:21:43.773]     if (TRUE) {
[10:21:43.773]         base::sink(type = "output", split = FALSE)
[10:21:43.773]         if (TRUE) {
[10:21:43.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.773]         }
[10:21:43.773]         else {
[10:21:43.773]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.773]         }
[10:21:43.773]         base::close(...future.stdout)
[10:21:43.773]         ...future.stdout <- NULL
[10:21:43.773]     }
[10:21:43.773]     ...future.result$conditions <- ...future.conditions
[10:21:43.773]     ...future.result$finished <- base::Sys.time()
[10:21:43.773]     ...future.result
[10:21:43.773] }
[10:21:43.776] assign_globals() ...
[10:21:43.776] List of 1
[10:21:43.776]  $ ii: int 1
[10:21:43.776]  - attr(*, "where")=List of 1
[10:21:43.776]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:43.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.776]  - attr(*, "resolved")= logi TRUE
[10:21:43.776]  - attr(*, "total_size")= num 35
[10:21:43.776]  - attr(*, "already-done")= logi TRUE
[10:21:43.778] - copied ‘ii’ to environment
[10:21:43.779] assign_globals() ... done
[10:21:43.779] requestCore(): workers = 2
[10:21:43.780] MulticoreFuture started
[10:21:43.781] - Launch lazy future ... done
[10:21:43.781] run() for ‘MulticoreFuture’ ... done
[10:21:43.781] result() for MulticoreFuture ...
[10:21:43.781] plan(): Setting new future strategy stack:
[10:21:43.782] List of future strategies:
[10:21:43.782] 1. sequential:
[10:21:43.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.782]    - tweaked: FALSE
[10:21:43.782]    - call: NULL
[10:21:43.783] plan(): nbrOfWorkers() = 1
[10:21:43.785] plan(): Setting new future strategy stack:
[10:21:43.785] List of future strategies:
[10:21:43.785] 1. multicore:
[10:21:43.785]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.785]    - tweaked: FALSE
[10:21:43.785]    - call: plan(strategy)
[10:21:43.788] plan(): nbrOfWorkers() = 2
[10:21:43.794] result() for MulticoreFuture ...
[10:21:43.794] result() for MulticoreFuture ... done
[10:21:43.794] signalConditions() ...
[10:21:43.794]  - include = ‘immediateCondition’
[10:21:43.794]  - exclude = 
[10:21:43.795]  - resignal = FALSE
[10:21:43.795]  - Number of conditions: 1
[10:21:43.795] signalConditions() ... done
[10:21:43.795] result() for MulticoreFuture ... done
[10:21:43.795] result() for MulticoreFuture ...
[10:21:43.795] result() for MulticoreFuture ... done
[10:21:43.795] signalConditions() ...
[10:21:43.795]  - include = ‘immediateCondition’
[10:21:43.795]  - exclude = 
[10:21:43.796]  - resignal = FALSE
[10:21:43.796]  - Number of conditions: 1
[10:21:43.796] signalConditions() ... done
[10:21:43.796] Future state: ‘finished’
[10:21:43.796] result() for MulticoreFuture ...
[10:21:43.796] result() for MulticoreFuture ... done
[10:21:43.796] signalConditions() ...
[10:21:43.796]  - include = ‘condition’
[10:21:43.797]  - exclude = ‘immediateCondition’
[10:21:43.797]  - resignal = TRUE
[10:21:43.797]  - Number of conditions: 1
[10:21:43.797]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:43.797] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:43"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.825] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.825] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.827] 
[10:21:43.827] Searching for globals ... DONE
[10:21:43.827] - globals: [0] <none>
[10:21:43.827] getGlobalsAndPackages() ... DONE
[10:21:43.828] run() for ‘Future’ ...
[10:21:43.828] - state: ‘created’
[10:21:43.828] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.830]   - Field: ‘label’
[10:21:43.830]   - Field: ‘local’
[10:21:43.830]   - Field: ‘owner’
[10:21:43.830]   - Field: ‘envir’
[10:21:43.830]   - Field: ‘workers’
[10:21:43.830]   - Field: ‘packages’
[10:21:43.831]   - Field: ‘gc’
[10:21:43.831]   - Field: ‘job’
[10:21:43.831]   - Field: ‘conditions’
[10:21:43.831]   - Field: ‘expr’
[10:21:43.831]   - Field: ‘uuid’
[10:21:43.831]   - Field: ‘seed’
[10:21:43.831]   - Field: ‘version’
[10:21:43.831]   - Field: ‘result’
[10:21:43.831]   - Field: ‘asynchronous’
[10:21:43.831]   - Field: ‘calls’
[10:21:43.831]   - Field: ‘globals’
[10:21:43.831]   - Field: ‘stdout’
[10:21:43.832]   - Field: ‘earlySignal’
[10:21:43.832]   - Field: ‘lazy’
[10:21:43.832]   - Field: ‘state’
[10:21:43.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.832] - Launch lazy future ...
[10:21:43.832] Packages needed by the future expression (n = 0): <none>
[10:21:43.832] Packages needed by future strategies (n = 0): <none>
[10:21:43.833] {
[10:21:43.833]     {
[10:21:43.833]         {
[10:21:43.833]             ...future.startTime <- base::Sys.time()
[10:21:43.833]             {
[10:21:43.833]                 {
[10:21:43.833]                   {
[10:21:43.833]                     {
[10:21:43.833]                       base::local({
[10:21:43.833]                         has_future <- base::requireNamespace("future", 
[10:21:43.833]                           quietly = TRUE)
[10:21:43.833]                         if (has_future) {
[10:21:43.833]                           ns <- base::getNamespace("future")
[10:21:43.833]                           version <- ns[[".package"]][["version"]]
[10:21:43.833]                           if (is.null(version)) 
[10:21:43.833]                             version <- utils::packageVersion("future")
[10:21:43.833]                         }
[10:21:43.833]                         else {
[10:21:43.833]                           version <- NULL
[10:21:43.833]                         }
[10:21:43.833]                         if (!has_future || version < "1.8.0") {
[10:21:43.833]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.833]                             "", base::R.version$version.string), 
[10:21:43.833]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.833]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.833]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.833]                               "release", "version")], collapse = " "), 
[10:21:43.833]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.833]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.833]                             info)
[10:21:43.833]                           info <- base::paste(info, collapse = "; ")
[10:21:43.833]                           if (!has_future) {
[10:21:43.833]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.833]                               info)
[10:21:43.833]                           }
[10:21:43.833]                           else {
[10:21:43.833]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.833]                               info, version)
[10:21:43.833]                           }
[10:21:43.833]                           base::stop(msg)
[10:21:43.833]                         }
[10:21:43.833]                       })
[10:21:43.833]                     }
[10:21:43.833]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.833]                     base::options(mc.cores = 1L)
[10:21:43.833]                   }
[10:21:43.833]                   ...future.strategy.old <- future::plan("list")
[10:21:43.833]                   options(future.plan = NULL)
[10:21:43.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.833]                 }
[10:21:43.833]                 ...future.workdir <- getwd()
[10:21:43.833]             }
[10:21:43.833]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.833]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.833]         }
[10:21:43.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.833]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.833]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.833]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.833]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.833]             base::names(...future.oldOptions))
[10:21:43.833]     }
[10:21:43.833]     if (FALSE) {
[10:21:43.833]     }
[10:21:43.833]     else {
[10:21:43.833]         if (TRUE) {
[10:21:43.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.833]                 open = "w")
[10:21:43.833]         }
[10:21:43.833]         else {
[10:21:43.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.833]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.833]         }
[10:21:43.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.833]             base::sink(type = "output", split = FALSE)
[10:21:43.833]             base::close(...future.stdout)
[10:21:43.833]         }, add = TRUE)
[10:21:43.833]     }
[10:21:43.833]     ...future.frame <- base::sys.nframe()
[10:21:43.833]     ...future.conditions <- base::list()
[10:21:43.833]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.833]     if (FALSE) {
[10:21:43.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.833]     }
[10:21:43.833]     ...future.result <- base::tryCatch({
[10:21:43.833]         base::withCallingHandlers({
[10:21:43.833]             ...future.value <- base::withVisible(base::local({
[10:21:43.833]                 withCallingHandlers({
[10:21:43.833]                   1
[10:21:43.833]                 }, immediateCondition = function(cond) {
[10:21:43.833]                   save_rds <- function (object, pathname, ...) 
[10:21:43.833]                   {
[10:21:43.833]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.833]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.833]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.833]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.833]                         fi_tmp[["mtime"]])
[10:21:43.833]                     }
[10:21:43.833]                     tryCatch({
[10:21:43.833]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.833]                     }, error = function(ex) {
[10:21:43.833]                       msg <- conditionMessage(ex)
[10:21:43.833]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.833]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.833]                         fi_tmp[["mtime"]], msg)
[10:21:43.833]                       ex$message <- msg
[10:21:43.833]                       stop(ex)
[10:21:43.833]                     })
[10:21:43.833]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.833]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.833]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.833]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.833]                       fi <- file.info(pathname)
[10:21:43.833]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.833]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.833]                         fi[["size"]], fi[["mtime"]])
[10:21:43.833]                       stop(msg)
[10:21:43.833]                     }
[10:21:43.833]                     invisible(pathname)
[10:21:43.833]                   }
[10:21:43.833]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.833]                     rootPath = tempdir()) 
[10:21:43.833]                   {
[10:21:43.833]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.833]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.833]                       tmpdir = path, fileext = ".rds")
[10:21:43.833]                     save_rds(obj, file)
[10:21:43.833]                   }
[10:21:43.833]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.833]                   {
[10:21:43.833]                     inherits <- base::inherits
[10:21:43.833]                     invokeRestart <- base::invokeRestart
[10:21:43.833]                     is.null <- base::is.null
[10:21:43.833]                     muffled <- FALSE
[10:21:43.833]                     if (inherits(cond, "message")) {
[10:21:43.833]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.833]                       if (muffled) 
[10:21:43.833]                         invokeRestart("muffleMessage")
[10:21:43.833]                     }
[10:21:43.833]                     else if (inherits(cond, "warning")) {
[10:21:43.833]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.833]                       if (muffled) 
[10:21:43.833]                         invokeRestart("muffleWarning")
[10:21:43.833]                     }
[10:21:43.833]                     else if (inherits(cond, "condition")) {
[10:21:43.833]                       if (!is.null(pattern)) {
[10:21:43.833]                         computeRestarts <- base::computeRestarts
[10:21:43.833]                         grepl <- base::grepl
[10:21:43.833]                         restarts <- computeRestarts(cond)
[10:21:43.833]                         for (restart in restarts) {
[10:21:43.833]                           name <- restart$name
[10:21:43.833]                           if (is.null(name)) 
[10:21:43.833]                             next
[10:21:43.833]                           if (!grepl(pattern, name)) 
[10:21:43.833]                             next
[10:21:43.833]                           invokeRestart(restart)
[10:21:43.833]                           muffled <- TRUE
[10:21:43.833]                           break
[10:21:43.833]                         }
[10:21:43.833]                       }
[10:21:43.833]                     }
[10:21:43.833]                     invisible(muffled)
[10:21:43.833]                   }
[10:21:43.833]                   muffleCondition(cond)
[10:21:43.833]                 })
[10:21:43.833]             }))
[10:21:43.833]             future::FutureResult(value = ...future.value$value, 
[10:21:43.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.833]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.833]                     ...future.globalenv.names))
[10:21:43.833]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.833]         }, condition = base::local({
[10:21:43.833]             c <- base::c
[10:21:43.833]             inherits <- base::inherits
[10:21:43.833]             invokeRestart <- base::invokeRestart
[10:21:43.833]             length <- base::length
[10:21:43.833]             list <- base::list
[10:21:43.833]             seq.int <- base::seq.int
[10:21:43.833]             signalCondition <- base::signalCondition
[10:21:43.833]             sys.calls <- base::sys.calls
[10:21:43.833]             `[[` <- base::`[[`
[10:21:43.833]             `+` <- base::`+`
[10:21:43.833]             `<<-` <- base::`<<-`
[10:21:43.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.833]                   3L)]
[10:21:43.833]             }
[10:21:43.833]             function(cond) {
[10:21:43.833]                 is_error <- inherits(cond, "error")
[10:21:43.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.833]                   NULL)
[10:21:43.833]                 if (is_error) {
[10:21:43.833]                   sessionInformation <- function() {
[10:21:43.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.833]                       search = base::search(), system = base::Sys.info())
[10:21:43.833]                   }
[10:21:43.833]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.833]                     cond$call), session = sessionInformation(), 
[10:21:43.833]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.833]                   signalCondition(cond)
[10:21:43.833]                 }
[10:21:43.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.833]                 "immediateCondition"))) {
[10:21:43.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.833]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.833]                   if (TRUE && !signal) {
[10:21:43.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.833]                     {
[10:21:43.833]                       inherits <- base::inherits
[10:21:43.833]                       invokeRestart <- base::invokeRestart
[10:21:43.833]                       is.null <- base::is.null
[10:21:43.833]                       muffled <- FALSE
[10:21:43.833]                       if (inherits(cond, "message")) {
[10:21:43.833]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.833]                         if (muffled) 
[10:21:43.833]                           invokeRestart("muffleMessage")
[10:21:43.833]                       }
[10:21:43.833]                       else if (inherits(cond, "warning")) {
[10:21:43.833]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.833]                         if (muffled) 
[10:21:43.833]                           invokeRestart("muffleWarning")
[10:21:43.833]                       }
[10:21:43.833]                       else if (inherits(cond, "condition")) {
[10:21:43.833]                         if (!is.null(pattern)) {
[10:21:43.833]                           computeRestarts <- base::computeRestarts
[10:21:43.833]                           grepl <- base::grepl
[10:21:43.833]                           restarts <- computeRestarts(cond)
[10:21:43.833]                           for (restart in restarts) {
[10:21:43.833]                             name <- restart$name
[10:21:43.833]                             if (is.null(name)) 
[10:21:43.833]                               next
[10:21:43.833]                             if (!grepl(pattern, name)) 
[10:21:43.833]                               next
[10:21:43.833]                             invokeRestart(restart)
[10:21:43.833]                             muffled <- TRUE
[10:21:43.833]                             break
[10:21:43.833]                           }
[10:21:43.833]                         }
[10:21:43.833]                       }
[10:21:43.833]                       invisible(muffled)
[10:21:43.833]                     }
[10:21:43.833]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.833]                   }
[10:21:43.833]                 }
[10:21:43.833]                 else {
[10:21:43.833]                   if (TRUE) {
[10:21:43.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.833]                     {
[10:21:43.833]                       inherits <- base::inherits
[10:21:43.833]                       invokeRestart <- base::invokeRestart
[10:21:43.833]                       is.null <- base::is.null
[10:21:43.833]                       muffled <- FALSE
[10:21:43.833]                       if (inherits(cond, "message")) {
[10:21:43.833]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.833]                         if (muffled) 
[10:21:43.833]                           invokeRestart("muffleMessage")
[10:21:43.833]                       }
[10:21:43.833]                       else if (inherits(cond, "warning")) {
[10:21:43.833]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.833]                         if (muffled) 
[10:21:43.833]                           invokeRestart("muffleWarning")
[10:21:43.833]                       }
[10:21:43.833]                       else if (inherits(cond, "condition")) {
[10:21:43.833]                         if (!is.null(pattern)) {
[10:21:43.833]                           computeRestarts <- base::computeRestarts
[10:21:43.833]                           grepl <- base::grepl
[10:21:43.833]                           restarts <- computeRestarts(cond)
[10:21:43.833]                           for (restart in restarts) {
[10:21:43.833]                             name <- restart$name
[10:21:43.833]                             if (is.null(name)) 
[10:21:43.833]                               next
[10:21:43.833]                             if (!grepl(pattern, name)) 
[10:21:43.833]                               next
[10:21:43.833]                             invokeRestart(restart)
[10:21:43.833]                             muffled <- TRUE
[10:21:43.833]                             break
[10:21:43.833]                           }
[10:21:43.833]                         }
[10:21:43.833]                       }
[10:21:43.833]                       invisible(muffled)
[10:21:43.833]                     }
[10:21:43.833]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.833]                   }
[10:21:43.833]                 }
[10:21:43.833]             }
[10:21:43.833]         }))
[10:21:43.833]     }, error = function(ex) {
[10:21:43.833]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.833]                 ...future.rng), started = ...future.startTime, 
[10:21:43.833]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.833]             version = "1.8"), class = "FutureResult")
[10:21:43.833]     }, finally = {
[10:21:43.833]         if (!identical(...future.workdir, getwd())) 
[10:21:43.833]             setwd(...future.workdir)
[10:21:43.833]         {
[10:21:43.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.833]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.833]             }
[10:21:43.833]             base::options(...future.oldOptions)
[10:21:43.833]             if (.Platform$OS.type == "windows") {
[10:21:43.833]                 old_names <- names(...future.oldEnvVars)
[10:21:43.833]                 envs <- base::Sys.getenv()
[10:21:43.833]                 names <- names(envs)
[10:21:43.833]                 common <- intersect(names, old_names)
[10:21:43.833]                 added <- setdiff(names, old_names)
[10:21:43.833]                 removed <- setdiff(old_names, names)
[10:21:43.833]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.833]                   envs[common]]
[10:21:43.833]                 NAMES <- toupper(changed)
[10:21:43.833]                 args <- list()
[10:21:43.833]                 for (kk in seq_along(NAMES)) {
[10:21:43.833]                   name <- changed[[kk]]
[10:21:43.833]                   NAME <- NAMES[[kk]]
[10:21:43.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.833]                     next
[10:21:43.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.833]                 }
[10:21:43.833]                 NAMES <- toupper(added)
[10:21:43.833]                 for (kk in seq_along(NAMES)) {
[10:21:43.833]                   name <- added[[kk]]
[10:21:43.833]                   NAME <- NAMES[[kk]]
[10:21:43.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.833]                     next
[10:21:43.833]                   args[[name]] <- ""
[10:21:43.833]                 }
[10:21:43.833]                 NAMES <- toupper(removed)
[10:21:43.833]                 for (kk in seq_along(NAMES)) {
[10:21:43.833]                   name <- removed[[kk]]
[10:21:43.833]                   NAME <- NAMES[[kk]]
[10:21:43.833]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.833]                     next
[10:21:43.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.833]                 }
[10:21:43.833]                 if (length(args) > 0) 
[10:21:43.833]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.833]             }
[10:21:43.833]             else {
[10:21:43.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.833]             }
[10:21:43.833]             {
[10:21:43.833]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.833]                   0L) {
[10:21:43.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.833]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.833]                   base::options(opts)
[10:21:43.833]                 }
[10:21:43.833]                 {
[10:21:43.833]                   {
[10:21:43.833]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.833]                     NULL
[10:21:43.833]                   }
[10:21:43.833]                   options(future.plan = NULL)
[10:21:43.833]                   if (is.na(NA_character_)) 
[10:21:43.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.833]                     .init = FALSE)
[10:21:43.833]                 }
[10:21:43.833]             }
[10:21:43.833]         }
[10:21:43.833]     })
[10:21:43.833]     if (TRUE) {
[10:21:43.833]         base::sink(type = "output", split = FALSE)
[10:21:43.833]         if (TRUE) {
[10:21:43.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.833]         }
[10:21:43.833]         else {
[10:21:43.833]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.833]         }
[10:21:43.833]         base::close(...future.stdout)
[10:21:43.833]         ...future.stdout <- NULL
[10:21:43.833]     }
[10:21:43.833]     ...future.result$conditions <- ...future.conditions
[10:21:43.833]     ...future.result$finished <- base::Sys.time()
[10:21:43.833]     ...future.result
[10:21:43.833] }
[10:21:43.835] requestCore(): workers = 2
[10:21:43.837] MulticoreFuture started
[10:21:43.837] - Launch lazy future ... done
[10:21:43.837] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.838] getGlobalsAndPackages() ...
[10:21:43.838] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.838] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.838] List of future strategies:
[10:21:43.838] 1. sequential:
[10:21:43.838]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.838]    - tweaked: FALSE
[10:21:43.838]    - call: NULL
[10:21:43.839] plan(): nbrOfWorkers() = 1
[10:21:43.840] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.841] Searching for globals ... DONE
[10:21:43.841] Resolving globals: TRUE
[10:21:43.841] Resolving any globals that are futures ...
[10:21:43.841] plan(): Setting new future strategy stack:
[10:21:43.841] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.841] Resolving any globals that are futures ... DONE
[10:21:43.841] List of future strategies:
[10:21:43.841] 1. multicore:
[10:21:43.841]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.841]    - tweaked: FALSE
[10:21:43.841]    - call: plan(strategy)
[10:21:43.842] Resolving futures part of globals (recursively) ...
[10:21:43.843] resolve() on list ...
[10:21:43.843]  recursive: 99
[10:21:43.843]  length: 1
[10:21:43.843]  elements: ‘a’
[10:21:43.844] plan(): nbrOfWorkers() = 2
[10:21:43.845] Future #1
[10:21:43.845] result() for MulticoreFuture ...
[10:21:43.846] result() for MulticoreFuture ...
[10:21:43.846] result() for MulticoreFuture ... done
[10:21:43.846] result() for MulticoreFuture ... done
[10:21:43.846] result() for MulticoreFuture ...
[10:21:43.847] result() for MulticoreFuture ... done
[10:21:43.847] A MulticoreFuture was resolved
[10:21:43.847]  length: 0 (resolved future 1)
[10:21:43.847] resolve() on list ... DONE
[10:21:43.847] - globals: [1] ‘a’
[10:21:43.847] Resolving futures part of globals (recursively) ... DONE
[10:21:43.848] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[10:21:43.848] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[10:21:43.848] - globals: [1] ‘a’
[10:21:43.848] - packages: [1] ‘future’
[10:21:43.848] getGlobalsAndPackages() ... DONE
[10:21:43.849] run() for ‘Future’ ...
[10:21:43.849] - state: ‘created’
[10:21:43.849] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.851] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.851] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.852]   - Field: ‘label’
[10:21:43.852]   - Field: ‘local’
[10:21:43.852]   - Field: ‘owner’
[10:21:43.852]   - Field: ‘envir’
[10:21:43.852]   - Field: ‘workers’
[10:21:43.852]   - Field: ‘packages’
[10:21:43.852]   - Field: ‘gc’
[10:21:43.852]   - Field: ‘job’
[10:21:43.852]   - Field: ‘conditions’
[10:21:43.852]   - Field: ‘expr’
[10:21:43.853]   - Field: ‘uuid’
[10:21:43.853]   - Field: ‘seed’
[10:21:43.853]   - Field: ‘version’
[10:21:43.853]   - Field: ‘result’
[10:21:43.853]   - Field: ‘asynchronous’
[10:21:43.853]   - Field: ‘calls’
[10:21:43.853]   - Field: ‘globals’
[10:21:43.853]   - Field: ‘stdout’
[10:21:43.853]   - Field: ‘earlySignal’
[10:21:43.854]   - Field: ‘lazy’
[10:21:43.854]   - Field: ‘state’
[10:21:43.854] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.854] - Launch lazy future ...
[10:21:43.854] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.854] Packages needed by future strategies (n = 0): <none>
[10:21:43.855] {
[10:21:43.855]     {
[10:21:43.855]         {
[10:21:43.855]             ...future.startTime <- base::Sys.time()
[10:21:43.855]             {
[10:21:43.855]                 {
[10:21:43.855]                   {
[10:21:43.855]                     {
[10:21:43.855]                       {
[10:21:43.855]                         base::local({
[10:21:43.855]                           has_future <- base::requireNamespace("future", 
[10:21:43.855]                             quietly = TRUE)
[10:21:43.855]                           if (has_future) {
[10:21:43.855]                             ns <- base::getNamespace("future")
[10:21:43.855]                             version <- ns[[".package"]][["version"]]
[10:21:43.855]                             if (is.null(version)) 
[10:21:43.855]                               version <- utils::packageVersion("future")
[10:21:43.855]                           }
[10:21:43.855]                           else {
[10:21:43.855]                             version <- NULL
[10:21:43.855]                           }
[10:21:43.855]                           if (!has_future || version < "1.8.0") {
[10:21:43.855]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.855]                               "", base::R.version$version.string), 
[10:21:43.855]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:43.855]                                 base::R.version$platform, 8 * 
[10:21:43.855]                                   base::.Machine$sizeof.pointer), 
[10:21:43.855]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.855]                                 "release", "version")], collapse = " "), 
[10:21:43.855]                               hostname = base::Sys.info()[["nodename"]])
[10:21:43.855]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.855]                               info)
[10:21:43.855]                             info <- base::paste(info, collapse = "; ")
[10:21:43.855]                             if (!has_future) {
[10:21:43.855]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.855]                                 info)
[10:21:43.855]                             }
[10:21:43.855]                             else {
[10:21:43.855]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.855]                                 info, version)
[10:21:43.855]                             }
[10:21:43.855]                             base::stop(msg)
[10:21:43.855]                           }
[10:21:43.855]                         })
[10:21:43.855]                       }
[10:21:43.855]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.855]                       base::options(mc.cores = 1L)
[10:21:43.855]                     }
[10:21:43.855]                     base::local({
[10:21:43.855]                       for (pkg in "future") {
[10:21:43.855]                         base::loadNamespace(pkg)
[10:21:43.855]                         base::library(pkg, character.only = TRUE)
[10:21:43.855]                       }
[10:21:43.855]                     })
[10:21:43.855]                   }
[10:21:43.855]                   ...future.strategy.old <- future::plan("list")
[10:21:43.855]                   options(future.plan = NULL)
[10:21:43.855]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.855]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.855]                 }
[10:21:43.855]                 ...future.workdir <- getwd()
[10:21:43.855]             }
[10:21:43.855]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.855]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.855]         }
[10:21:43.855]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.855]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.855]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.855]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.855]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.855]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.855]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.855]             base::names(...future.oldOptions))
[10:21:43.855]     }
[10:21:43.855]     if (FALSE) {
[10:21:43.855]     }
[10:21:43.855]     else {
[10:21:43.855]         if (TRUE) {
[10:21:43.855]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.855]                 open = "w")
[10:21:43.855]         }
[10:21:43.855]         else {
[10:21:43.855]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.855]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.855]         }
[10:21:43.855]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.855]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.855]             base::sink(type = "output", split = FALSE)
[10:21:43.855]             base::close(...future.stdout)
[10:21:43.855]         }, add = TRUE)
[10:21:43.855]     }
[10:21:43.855]     ...future.frame <- base::sys.nframe()
[10:21:43.855]     ...future.conditions <- base::list()
[10:21:43.855]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.855]     if (FALSE) {
[10:21:43.855]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.855]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.855]     }
[10:21:43.855]     ...future.result <- base::tryCatch({
[10:21:43.855]         base::withCallingHandlers({
[10:21:43.855]             ...future.value <- base::withVisible(base::local({
[10:21:43.855]                 withCallingHandlers({
[10:21:43.855]                   value(a) + 1
[10:21:43.855]                 }, immediateCondition = function(cond) {
[10:21:43.855]                   save_rds <- function (object, pathname, ...) 
[10:21:43.855]                   {
[10:21:43.855]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.855]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.855]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.855]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.855]                         fi_tmp[["mtime"]])
[10:21:43.855]                     }
[10:21:43.855]                     tryCatch({
[10:21:43.855]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.855]                     }, error = function(ex) {
[10:21:43.855]                       msg <- conditionMessage(ex)
[10:21:43.855]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.855]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.855]                         fi_tmp[["mtime"]], msg)
[10:21:43.855]                       ex$message <- msg
[10:21:43.855]                       stop(ex)
[10:21:43.855]                     })
[10:21:43.855]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.855]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.855]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.855]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.855]                       fi <- file.info(pathname)
[10:21:43.855]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.855]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.855]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.855]                         fi[["size"]], fi[["mtime"]])
[10:21:43.855]                       stop(msg)
[10:21:43.855]                     }
[10:21:43.855]                     invisible(pathname)
[10:21:43.855]                   }
[10:21:43.855]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.855]                     rootPath = tempdir()) 
[10:21:43.855]                   {
[10:21:43.855]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.855]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.855]                       tmpdir = path, fileext = ".rds")
[10:21:43.855]                     save_rds(obj, file)
[10:21:43.855]                   }
[10:21:43.855]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.855]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.855]                   {
[10:21:43.855]                     inherits <- base::inherits
[10:21:43.855]                     invokeRestart <- base::invokeRestart
[10:21:43.855]                     is.null <- base::is.null
[10:21:43.855]                     muffled <- FALSE
[10:21:43.855]                     if (inherits(cond, "message")) {
[10:21:43.855]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.855]                       if (muffled) 
[10:21:43.855]                         invokeRestart("muffleMessage")
[10:21:43.855]                     }
[10:21:43.855]                     else if (inherits(cond, "warning")) {
[10:21:43.855]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.855]                       if (muffled) 
[10:21:43.855]                         invokeRestart("muffleWarning")
[10:21:43.855]                     }
[10:21:43.855]                     else if (inherits(cond, "condition")) {
[10:21:43.855]                       if (!is.null(pattern)) {
[10:21:43.855]                         computeRestarts <- base::computeRestarts
[10:21:43.855]                         grepl <- base::grepl
[10:21:43.855]                         restarts <- computeRestarts(cond)
[10:21:43.855]                         for (restart in restarts) {
[10:21:43.855]                           name <- restart$name
[10:21:43.855]                           if (is.null(name)) 
[10:21:43.855]                             next
[10:21:43.855]                           if (!grepl(pattern, name)) 
[10:21:43.855]                             next
[10:21:43.855]                           invokeRestart(restart)
[10:21:43.855]                           muffled <- TRUE
[10:21:43.855]                           break
[10:21:43.855]                         }
[10:21:43.855]                       }
[10:21:43.855]                     }
[10:21:43.855]                     invisible(muffled)
[10:21:43.855]                   }
[10:21:43.855]                   muffleCondition(cond)
[10:21:43.855]                 })
[10:21:43.855]             }))
[10:21:43.855]             future::FutureResult(value = ...future.value$value, 
[10:21:43.855]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.855]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.855]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.855]                     ...future.globalenv.names))
[10:21:43.855]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.855]         }, condition = base::local({
[10:21:43.855]             c <- base::c
[10:21:43.855]             inherits <- base::inherits
[10:21:43.855]             invokeRestart <- base::invokeRestart
[10:21:43.855]             length <- base::length
[10:21:43.855]             list <- base::list
[10:21:43.855]             seq.int <- base::seq.int
[10:21:43.855]             signalCondition <- base::signalCondition
[10:21:43.855]             sys.calls <- base::sys.calls
[10:21:43.855]             `[[` <- base::`[[`
[10:21:43.855]             `+` <- base::`+`
[10:21:43.855]             `<<-` <- base::`<<-`
[10:21:43.855]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.855]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.855]                   3L)]
[10:21:43.855]             }
[10:21:43.855]             function(cond) {
[10:21:43.855]                 is_error <- inherits(cond, "error")
[10:21:43.855]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.855]                   NULL)
[10:21:43.855]                 if (is_error) {
[10:21:43.855]                   sessionInformation <- function() {
[10:21:43.855]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.855]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.855]                       search = base::search(), system = base::Sys.info())
[10:21:43.855]                   }
[10:21:43.855]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.855]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.855]                     cond$call), session = sessionInformation(), 
[10:21:43.855]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.855]                   signalCondition(cond)
[10:21:43.855]                 }
[10:21:43.855]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.855]                 "immediateCondition"))) {
[10:21:43.855]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.855]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.855]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.855]                   if (TRUE && !signal) {
[10:21:43.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.855]                     {
[10:21:43.855]                       inherits <- base::inherits
[10:21:43.855]                       invokeRestart <- base::invokeRestart
[10:21:43.855]                       is.null <- base::is.null
[10:21:43.855]                       muffled <- FALSE
[10:21:43.855]                       if (inherits(cond, "message")) {
[10:21:43.855]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.855]                         if (muffled) 
[10:21:43.855]                           invokeRestart("muffleMessage")
[10:21:43.855]                       }
[10:21:43.855]                       else if (inherits(cond, "warning")) {
[10:21:43.855]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.855]                         if (muffled) 
[10:21:43.855]                           invokeRestart("muffleWarning")
[10:21:43.855]                       }
[10:21:43.855]                       else if (inherits(cond, "condition")) {
[10:21:43.855]                         if (!is.null(pattern)) {
[10:21:43.855]                           computeRestarts <- base::computeRestarts
[10:21:43.855]                           grepl <- base::grepl
[10:21:43.855]                           restarts <- computeRestarts(cond)
[10:21:43.855]                           for (restart in restarts) {
[10:21:43.855]                             name <- restart$name
[10:21:43.855]                             if (is.null(name)) 
[10:21:43.855]                               next
[10:21:43.855]                             if (!grepl(pattern, name)) 
[10:21:43.855]                               next
[10:21:43.855]                             invokeRestart(restart)
[10:21:43.855]                             muffled <- TRUE
[10:21:43.855]                             break
[10:21:43.855]                           }
[10:21:43.855]                         }
[10:21:43.855]                       }
[10:21:43.855]                       invisible(muffled)
[10:21:43.855]                     }
[10:21:43.855]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.855]                   }
[10:21:43.855]                 }
[10:21:43.855]                 else {
[10:21:43.855]                   if (TRUE) {
[10:21:43.855]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.855]                     {
[10:21:43.855]                       inherits <- base::inherits
[10:21:43.855]                       invokeRestart <- base::invokeRestart
[10:21:43.855]                       is.null <- base::is.null
[10:21:43.855]                       muffled <- FALSE
[10:21:43.855]                       if (inherits(cond, "message")) {
[10:21:43.855]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.855]                         if (muffled) 
[10:21:43.855]                           invokeRestart("muffleMessage")
[10:21:43.855]                       }
[10:21:43.855]                       else if (inherits(cond, "warning")) {
[10:21:43.855]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.855]                         if (muffled) 
[10:21:43.855]                           invokeRestart("muffleWarning")
[10:21:43.855]                       }
[10:21:43.855]                       else if (inherits(cond, "condition")) {
[10:21:43.855]                         if (!is.null(pattern)) {
[10:21:43.855]                           computeRestarts <- base::computeRestarts
[10:21:43.855]                           grepl <- base::grepl
[10:21:43.855]                           restarts <- computeRestarts(cond)
[10:21:43.855]                           for (restart in restarts) {
[10:21:43.855]                             name <- restart$name
[10:21:43.855]                             if (is.null(name)) 
[10:21:43.855]                               next
[10:21:43.855]                             if (!grepl(pattern, name)) 
[10:21:43.855]                               next
[10:21:43.855]                             invokeRestart(restart)
[10:21:43.855]                             muffled <- TRUE
[10:21:43.855]                             break
[10:21:43.855]                           }
[10:21:43.855]                         }
[10:21:43.855]                       }
[10:21:43.855]                       invisible(muffled)
[10:21:43.855]                     }
[10:21:43.855]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.855]                   }
[10:21:43.855]                 }
[10:21:43.855]             }
[10:21:43.855]         }))
[10:21:43.855]     }, error = function(ex) {
[10:21:43.855]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.855]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.855]                 ...future.rng), started = ...future.startTime, 
[10:21:43.855]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.855]             version = "1.8"), class = "FutureResult")
[10:21:43.855]     }, finally = {
[10:21:43.855]         if (!identical(...future.workdir, getwd())) 
[10:21:43.855]             setwd(...future.workdir)
[10:21:43.855]         {
[10:21:43.855]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.855]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.855]             }
[10:21:43.855]             base::options(...future.oldOptions)
[10:21:43.855]             if (.Platform$OS.type == "windows") {
[10:21:43.855]                 old_names <- names(...future.oldEnvVars)
[10:21:43.855]                 envs <- base::Sys.getenv()
[10:21:43.855]                 names <- names(envs)
[10:21:43.855]                 common <- intersect(names, old_names)
[10:21:43.855]                 added <- setdiff(names, old_names)
[10:21:43.855]                 removed <- setdiff(old_names, names)
[10:21:43.855]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.855]                   envs[common]]
[10:21:43.855]                 NAMES <- toupper(changed)
[10:21:43.855]                 args <- list()
[10:21:43.855]                 for (kk in seq_along(NAMES)) {
[10:21:43.855]                   name <- changed[[kk]]
[10:21:43.855]                   NAME <- NAMES[[kk]]
[10:21:43.855]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.855]                     next
[10:21:43.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.855]                 }
[10:21:43.855]                 NAMES <- toupper(added)
[10:21:43.855]                 for (kk in seq_along(NAMES)) {
[10:21:43.855]                   name <- added[[kk]]
[10:21:43.855]                   NAME <- NAMES[[kk]]
[10:21:43.855]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.855]                     next
[10:21:43.855]                   args[[name]] <- ""
[10:21:43.855]                 }
[10:21:43.855]                 NAMES <- toupper(removed)
[10:21:43.855]                 for (kk in seq_along(NAMES)) {
[10:21:43.855]                   name <- removed[[kk]]
[10:21:43.855]                   NAME <- NAMES[[kk]]
[10:21:43.855]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.855]                     next
[10:21:43.855]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.855]                 }
[10:21:43.855]                 if (length(args) > 0) 
[10:21:43.855]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.855]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.855]             }
[10:21:43.855]             else {
[10:21:43.855]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.855]             }
[10:21:43.855]             {
[10:21:43.855]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.855]                   0L) {
[10:21:43.855]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.855]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.855]                   base::options(opts)
[10:21:43.855]                 }
[10:21:43.855]                 {
[10:21:43.855]                   {
[10:21:43.855]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.855]                     NULL
[10:21:43.855]                   }
[10:21:43.855]                   options(future.plan = NULL)
[10:21:43.855]                   if (is.na(NA_character_)) 
[10:21:43.855]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.855]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.855]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.855]                     .init = FALSE)
[10:21:43.855]                 }
[10:21:43.855]             }
[10:21:43.855]         }
[10:21:43.855]     })
[10:21:43.855]     if (TRUE) {
[10:21:43.855]         base::sink(type = "output", split = FALSE)
[10:21:43.855]         if (TRUE) {
[10:21:43.855]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.855]         }
[10:21:43.855]         else {
[10:21:43.855]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.855]         }
[10:21:43.855]         base::close(...future.stdout)
[10:21:43.855]         ...future.stdout <- NULL
[10:21:43.855]     }
[10:21:43.855]     ...future.result$conditions <- ...future.conditions
[10:21:43.855]     ...future.result$finished <- base::Sys.time()
[10:21:43.855]     ...future.result
[10:21:43.855] }
[10:21:43.858] assign_globals() ...
[10:21:43.858] List of 1
[10:21:43.858]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18da93578> 
[10:21:43.858]  - attr(*, "where")=List of 1
[10:21:43.858]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.858]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.858]  - attr(*, "resolved")= logi TRUE
[10:21:43.858]  - attr(*, "total_size")= num 3815
[10:21:43.858]  - attr(*, "already-done")= logi TRUE
[10:21:43.863] - copied ‘a’ to environment
[10:21:43.863] assign_globals() ... done
[10:21:43.863] requestCore(): workers = 2
[10:21:43.865] MulticoreFuture started
[10:21:43.866] - Launch lazy future ... done
[10:21:43.866] run() for ‘MulticoreFuture’ ... done
[10:21:43.866] result() for MulticoreFuture ...
[10:21:43.867] plan(): Setting new future strategy stack:
[10:21:43.867] List of future strategies:
[10:21:43.867] 1. sequential:
[10:21:43.867]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.867]    - tweaked: FALSE
[10:21:43.867]    - call: NULL
[10:21:43.868] plan(): nbrOfWorkers() = 1
[10:21:43.872] plan(): Setting new future strategy stack:
[10:21:43.872] List of future strategies:
[10:21:43.872] 1. multicore:
[10:21:43.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.872]    - tweaked: FALSE
[10:21:43.872]    - call: plan(strategy)
[10:21:43.875] plan(): nbrOfWorkers() = 2
[10:21:43.876] result() for MulticoreFuture ...
[10:21:43.876] result() for MulticoreFuture ... done
[10:21:43.876] signalConditions() ...
[10:21:43.876]  - include = ‘immediateCondition’
[10:21:43.876]  - exclude = 
[10:21:43.877]  - resignal = FALSE
[10:21:43.877]  - Number of conditions: 4
[10:21:43.877] signalConditions() ... done
[10:21:43.877] result() for MulticoreFuture ... done
[10:21:43.877] result() for MulticoreFuture ...
[10:21:43.877] result() for MulticoreFuture ... done
[10:21:43.877] signalConditions() ...
[10:21:43.878]  - include = ‘immediateCondition’
[10:21:43.878]  - exclude = 
[10:21:43.878]  - resignal = FALSE
[10:21:43.878]  - Number of conditions: 4
[10:21:43.878] signalConditions() ... done
[10:21:43.878] Future state: ‘finished’
[10:21:43.878] result() for MulticoreFuture ...
[10:21:43.879] result() for MulticoreFuture ... done
[10:21:43.879] signalConditions() ...
[10:21:43.879]  - include = ‘condition’
[10:21:43.879]  - exclude = ‘immediateCondition’
[10:21:43.879]  - resignal = TRUE
[10:21:43.879]  - Number of conditions: 4
[10:21:43.879]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.869] result() for MulticoreFuture ...
[10:21:43.879]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.870] result() for MulticoreFuture ... done
[10:21:43.880]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.870] result() for MulticoreFuture ...
[10:21:43.880]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.870] result() for MulticoreFuture ... done
[10:21:43.880] signalConditions() ... done
value(b) = 2
[10:21:43.880] result() for MulticoreFuture ...
[10:21:43.880] result() for MulticoreFuture ... done
[10:21:43.880] result() for MulticoreFuture ...
[10:21:43.881] result() for MulticoreFuture ... done
[10:21:43.881] signalConditions() ...
[10:21:43.881]  - include = ‘immediateCondition’
[10:21:43.881]  - exclude = 
[10:21:43.881]  - resignal = FALSE
[10:21:43.881]  - Number of conditions: 4
[10:21:43.881] signalConditions() ... done
[10:21:43.881] Future state: ‘finished’
[10:21:43.881] result() for MulticoreFuture ...
[10:21:43.882] result() for MulticoreFuture ... done
[10:21:43.882] signalConditions() ...
[10:21:43.882]  - include = ‘condition’
[10:21:43.882]  - exclude = ‘immediateCondition’
[10:21:43.882]  - resignal = TRUE
[10:21:43.882]  - Number of conditions: 4
[10:21:43.882]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.869] result() for MulticoreFuture ...
[10:21:43.882]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.870] result() for MulticoreFuture ... done
[10:21:43.883]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.870] result() for MulticoreFuture ...
[10:21:43.883]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.870] result() for MulticoreFuture ... done
[10:21:43.883] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.883] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.883] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.884] 
[10:21:43.884] Searching for globals ... DONE
[10:21:43.884] - globals: [0] <none>
[10:21:43.885] getGlobalsAndPackages() ... DONE
[10:21:43.885] run() for ‘Future’ ...
[10:21:43.885] - state: ‘created’
[10:21:43.885] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.887] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.888]   - Field: ‘label’
[10:21:43.888]   - Field: ‘local’
[10:21:43.888]   - Field: ‘owner’
[10:21:43.888]   - Field: ‘envir’
[10:21:43.888]   - Field: ‘workers’
[10:21:43.888]   - Field: ‘packages’
[10:21:43.888]   - Field: ‘gc’
[10:21:43.888]   - Field: ‘job’
[10:21:43.888]   - Field: ‘conditions’
[10:21:43.888]   - Field: ‘expr’
[10:21:43.889]   - Field: ‘uuid’
[10:21:43.889]   - Field: ‘seed’
[10:21:43.889]   - Field: ‘version’
[10:21:43.889]   - Field: ‘result’
[10:21:43.889]   - Field: ‘asynchronous’
[10:21:43.889]   - Field: ‘calls’
[10:21:43.889]   - Field: ‘globals’
[10:21:43.889]   - Field: ‘stdout’
[10:21:43.889]   - Field: ‘earlySignal’
[10:21:43.890]   - Field: ‘lazy’
[10:21:43.890]   - Field: ‘state’
[10:21:43.890] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.890] - Launch lazy future ...
[10:21:43.890] Packages needed by the future expression (n = 0): <none>
[10:21:43.890] Packages needed by future strategies (n = 0): <none>
[10:21:43.891] {
[10:21:43.891]     {
[10:21:43.891]         {
[10:21:43.891]             ...future.startTime <- base::Sys.time()
[10:21:43.891]             {
[10:21:43.891]                 {
[10:21:43.891]                   {
[10:21:43.891]                     {
[10:21:43.891]                       base::local({
[10:21:43.891]                         has_future <- base::requireNamespace("future", 
[10:21:43.891]                           quietly = TRUE)
[10:21:43.891]                         if (has_future) {
[10:21:43.891]                           ns <- base::getNamespace("future")
[10:21:43.891]                           version <- ns[[".package"]][["version"]]
[10:21:43.891]                           if (is.null(version)) 
[10:21:43.891]                             version <- utils::packageVersion("future")
[10:21:43.891]                         }
[10:21:43.891]                         else {
[10:21:43.891]                           version <- NULL
[10:21:43.891]                         }
[10:21:43.891]                         if (!has_future || version < "1.8.0") {
[10:21:43.891]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.891]                             "", base::R.version$version.string), 
[10:21:43.891]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.891]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.891]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.891]                               "release", "version")], collapse = " "), 
[10:21:43.891]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.891]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.891]                             info)
[10:21:43.891]                           info <- base::paste(info, collapse = "; ")
[10:21:43.891]                           if (!has_future) {
[10:21:43.891]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.891]                               info)
[10:21:43.891]                           }
[10:21:43.891]                           else {
[10:21:43.891]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.891]                               info, version)
[10:21:43.891]                           }
[10:21:43.891]                           base::stop(msg)
[10:21:43.891]                         }
[10:21:43.891]                       })
[10:21:43.891]                     }
[10:21:43.891]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.891]                     base::options(mc.cores = 1L)
[10:21:43.891]                   }
[10:21:43.891]                   ...future.strategy.old <- future::plan("list")
[10:21:43.891]                   options(future.plan = NULL)
[10:21:43.891]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.891]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.891]                 }
[10:21:43.891]                 ...future.workdir <- getwd()
[10:21:43.891]             }
[10:21:43.891]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.891]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.891]         }
[10:21:43.891]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.891]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.891]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.891]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.891]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.891]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.891]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.891]             base::names(...future.oldOptions))
[10:21:43.891]     }
[10:21:43.891]     if (FALSE) {
[10:21:43.891]     }
[10:21:43.891]     else {
[10:21:43.891]         if (TRUE) {
[10:21:43.891]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.891]                 open = "w")
[10:21:43.891]         }
[10:21:43.891]         else {
[10:21:43.891]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.891]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.891]         }
[10:21:43.891]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.891]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.891]             base::sink(type = "output", split = FALSE)
[10:21:43.891]             base::close(...future.stdout)
[10:21:43.891]         }, add = TRUE)
[10:21:43.891]     }
[10:21:43.891]     ...future.frame <- base::sys.nframe()
[10:21:43.891]     ...future.conditions <- base::list()
[10:21:43.891]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.891]     if (FALSE) {
[10:21:43.891]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.891]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.891]     }
[10:21:43.891]     ...future.result <- base::tryCatch({
[10:21:43.891]         base::withCallingHandlers({
[10:21:43.891]             ...future.value <- base::withVisible(base::local({
[10:21:43.891]                 withCallingHandlers({
[10:21:43.891]                   1
[10:21:43.891]                 }, immediateCondition = function(cond) {
[10:21:43.891]                   save_rds <- function (object, pathname, ...) 
[10:21:43.891]                   {
[10:21:43.891]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.891]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.891]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.891]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.891]                         fi_tmp[["mtime"]])
[10:21:43.891]                     }
[10:21:43.891]                     tryCatch({
[10:21:43.891]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.891]                     }, error = function(ex) {
[10:21:43.891]                       msg <- conditionMessage(ex)
[10:21:43.891]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.891]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.891]                         fi_tmp[["mtime"]], msg)
[10:21:43.891]                       ex$message <- msg
[10:21:43.891]                       stop(ex)
[10:21:43.891]                     })
[10:21:43.891]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.891]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.891]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.891]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.891]                       fi <- file.info(pathname)
[10:21:43.891]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.891]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.891]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.891]                         fi[["size"]], fi[["mtime"]])
[10:21:43.891]                       stop(msg)
[10:21:43.891]                     }
[10:21:43.891]                     invisible(pathname)
[10:21:43.891]                   }
[10:21:43.891]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.891]                     rootPath = tempdir()) 
[10:21:43.891]                   {
[10:21:43.891]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.891]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.891]                       tmpdir = path, fileext = ".rds")
[10:21:43.891]                     save_rds(obj, file)
[10:21:43.891]                   }
[10:21:43.891]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.891]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.891]                   {
[10:21:43.891]                     inherits <- base::inherits
[10:21:43.891]                     invokeRestart <- base::invokeRestart
[10:21:43.891]                     is.null <- base::is.null
[10:21:43.891]                     muffled <- FALSE
[10:21:43.891]                     if (inherits(cond, "message")) {
[10:21:43.891]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.891]                       if (muffled) 
[10:21:43.891]                         invokeRestart("muffleMessage")
[10:21:43.891]                     }
[10:21:43.891]                     else if (inherits(cond, "warning")) {
[10:21:43.891]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.891]                       if (muffled) 
[10:21:43.891]                         invokeRestart("muffleWarning")
[10:21:43.891]                     }
[10:21:43.891]                     else if (inherits(cond, "condition")) {
[10:21:43.891]                       if (!is.null(pattern)) {
[10:21:43.891]                         computeRestarts <- base::computeRestarts
[10:21:43.891]                         grepl <- base::grepl
[10:21:43.891]                         restarts <- computeRestarts(cond)
[10:21:43.891]                         for (restart in restarts) {
[10:21:43.891]                           name <- restart$name
[10:21:43.891]                           if (is.null(name)) 
[10:21:43.891]                             next
[10:21:43.891]                           if (!grepl(pattern, name)) 
[10:21:43.891]                             next
[10:21:43.891]                           invokeRestart(restart)
[10:21:43.891]                           muffled <- TRUE
[10:21:43.891]                           break
[10:21:43.891]                         }
[10:21:43.891]                       }
[10:21:43.891]                     }
[10:21:43.891]                     invisible(muffled)
[10:21:43.891]                   }
[10:21:43.891]                   muffleCondition(cond)
[10:21:43.891]                 })
[10:21:43.891]             }))
[10:21:43.891]             future::FutureResult(value = ...future.value$value, 
[10:21:43.891]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.891]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.891]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.891]                     ...future.globalenv.names))
[10:21:43.891]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.891]         }, condition = base::local({
[10:21:43.891]             c <- base::c
[10:21:43.891]             inherits <- base::inherits
[10:21:43.891]             invokeRestart <- base::invokeRestart
[10:21:43.891]             length <- base::length
[10:21:43.891]             list <- base::list
[10:21:43.891]             seq.int <- base::seq.int
[10:21:43.891]             signalCondition <- base::signalCondition
[10:21:43.891]             sys.calls <- base::sys.calls
[10:21:43.891]             `[[` <- base::`[[`
[10:21:43.891]             `+` <- base::`+`
[10:21:43.891]             `<<-` <- base::`<<-`
[10:21:43.891]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.891]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.891]                   3L)]
[10:21:43.891]             }
[10:21:43.891]             function(cond) {
[10:21:43.891]                 is_error <- inherits(cond, "error")
[10:21:43.891]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.891]                   NULL)
[10:21:43.891]                 if (is_error) {
[10:21:43.891]                   sessionInformation <- function() {
[10:21:43.891]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.891]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.891]                       search = base::search(), system = base::Sys.info())
[10:21:43.891]                   }
[10:21:43.891]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.891]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.891]                     cond$call), session = sessionInformation(), 
[10:21:43.891]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.891]                   signalCondition(cond)
[10:21:43.891]                 }
[10:21:43.891]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.891]                 "immediateCondition"))) {
[10:21:43.891]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.891]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.891]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.891]                   if (TRUE && !signal) {
[10:21:43.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.891]                     {
[10:21:43.891]                       inherits <- base::inherits
[10:21:43.891]                       invokeRestart <- base::invokeRestart
[10:21:43.891]                       is.null <- base::is.null
[10:21:43.891]                       muffled <- FALSE
[10:21:43.891]                       if (inherits(cond, "message")) {
[10:21:43.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.891]                         if (muffled) 
[10:21:43.891]                           invokeRestart("muffleMessage")
[10:21:43.891]                       }
[10:21:43.891]                       else if (inherits(cond, "warning")) {
[10:21:43.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.891]                         if (muffled) 
[10:21:43.891]                           invokeRestart("muffleWarning")
[10:21:43.891]                       }
[10:21:43.891]                       else if (inherits(cond, "condition")) {
[10:21:43.891]                         if (!is.null(pattern)) {
[10:21:43.891]                           computeRestarts <- base::computeRestarts
[10:21:43.891]                           grepl <- base::grepl
[10:21:43.891]                           restarts <- computeRestarts(cond)
[10:21:43.891]                           for (restart in restarts) {
[10:21:43.891]                             name <- restart$name
[10:21:43.891]                             if (is.null(name)) 
[10:21:43.891]                               next
[10:21:43.891]                             if (!grepl(pattern, name)) 
[10:21:43.891]                               next
[10:21:43.891]                             invokeRestart(restart)
[10:21:43.891]                             muffled <- TRUE
[10:21:43.891]                             break
[10:21:43.891]                           }
[10:21:43.891]                         }
[10:21:43.891]                       }
[10:21:43.891]                       invisible(muffled)
[10:21:43.891]                     }
[10:21:43.891]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.891]                   }
[10:21:43.891]                 }
[10:21:43.891]                 else {
[10:21:43.891]                   if (TRUE) {
[10:21:43.891]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.891]                     {
[10:21:43.891]                       inherits <- base::inherits
[10:21:43.891]                       invokeRestart <- base::invokeRestart
[10:21:43.891]                       is.null <- base::is.null
[10:21:43.891]                       muffled <- FALSE
[10:21:43.891]                       if (inherits(cond, "message")) {
[10:21:43.891]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.891]                         if (muffled) 
[10:21:43.891]                           invokeRestart("muffleMessage")
[10:21:43.891]                       }
[10:21:43.891]                       else if (inherits(cond, "warning")) {
[10:21:43.891]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.891]                         if (muffled) 
[10:21:43.891]                           invokeRestart("muffleWarning")
[10:21:43.891]                       }
[10:21:43.891]                       else if (inherits(cond, "condition")) {
[10:21:43.891]                         if (!is.null(pattern)) {
[10:21:43.891]                           computeRestarts <- base::computeRestarts
[10:21:43.891]                           grepl <- base::grepl
[10:21:43.891]                           restarts <- computeRestarts(cond)
[10:21:43.891]                           for (restart in restarts) {
[10:21:43.891]                             name <- restart$name
[10:21:43.891]                             if (is.null(name)) 
[10:21:43.891]                               next
[10:21:43.891]                             if (!grepl(pattern, name)) 
[10:21:43.891]                               next
[10:21:43.891]                             invokeRestart(restart)
[10:21:43.891]                             muffled <- TRUE
[10:21:43.891]                             break
[10:21:43.891]                           }
[10:21:43.891]                         }
[10:21:43.891]                       }
[10:21:43.891]                       invisible(muffled)
[10:21:43.891]                     }
[10:21:43.891]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.891]                   }
[10:21:43.891]                 }
[10:21:43.891]             }
[10:21:43.891]         }))
[10:21:43.891]     }, error = function(ex) {
[10:21:43.891]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.891]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.891]                 ...future.rng), started = ...future.startTime, 
[10:21:43.891]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.891]             version = "1.8"), class = "FutureResult")
[10:21:43.891]     }, finally = {
[10:21:43.891]         if (!identical(...future.workdir, getwd())) 
[10:21:43.891]             setwd(...future.workdir)
[10:21:43.891]         {
[10:21:43.891]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.891]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.891]             }
[10:21:43.891]             base::options(...future.oldOptions)
[10:21:43.891]             if (.Platform$OS.type == "windows") {
[10:21:43.891]                 old_names <- names(...future.oldEnvVars)
[10:21:43.891]                 envs <- base::Sys.getenv()
[10:21:43.891]                 names <- names(envs)
[10:21:43.891]                 common <- intersect(names, old_names)
[10:21:43.891]                 added <- setdiff(names, old_names)
[10:21:43.891]                 removed <- setdiff(old_names, names)
[10:21:43.891]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.891]                   envs[common]]
[10:21:43.891]                 NAMES <- toupper(changed)
[10:21:43.891]                 args <- list()
[10:21:43.891]                 for (kk in seq_along(NAMES)) {
[10:21:43.891]                   name <- changed[[kk]]
[10:21:43.891]                   NAME <- NAMES[[kk]]
[10:21:43.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.891]                     next
[10:21:43.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.891]                 }
[10:21:43.891]                 NAMES <- toupper(added)
[10:21:43.891]                 for (kk in seq_along(NAMES)) {
[10:21:43.891]                   name <- added[[kk]]
[10:21:43.891]                   NAME <- NAMES[[kk]]
[10:21:43.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.891]                     next
[10:21:43.891]                   args[[name]] <- ""
[10:21:43.891]                 }
[10:21:43.891]                 NAMES <- toupper(removed)
[10:21:43.891]                 for (kk in seq_along(NAMES)) {
[10:21:43.891]                   name <- removed[[kk]]
[10:21:43.891]                   NAME <- NAMES[[kk]]
[10:21:43.891]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.891]                     next
[10:21:43.891]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.891]                 }
[10:21:43.891]                 if (length(args) > 0) 
[10:21:43.891]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.891]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.891]             }
[10:21:43.891]             else {
[10:21:43.891]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.891]             }
[10:21:43.891]             {
[10:21:43.891]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.891]                   0L) {
[10:21:43.891]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.891]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.891]                   base::options(opts)
[10:21:43.891]                 }
[10:21:43.891]                 {
[10:21:43.891]                   {
[10:21:43.891]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.891]                     NULL
[10:21:43.891]                   }
[10:21:43.891]                   options(future.plan = NULL)
[10:21:43.891]                   if (is.na(NA_character_)) 
[10:21:43.891]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.891]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.891]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.891]                     .init = FALSE)
[10:21:43.891]                 }
[10:21:43.891]             }
[10:21:43.891]         }
[10:21:43.891]     })
[10:21:43.891]     if (TRUE) {
[10:21:43.891]         base::sink(type = "output", split = FALSE)
[10:21:43.891]         if (TRUE) {
[10:21:43.891]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.891]         }
[10:21:43.891]         else {
[10:21:43.891]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.891]         }
[10:21:43.891]         base::close(...future.stdout)
[10:21:43.891]         ...future.stdout <- NULL
[10:21:43.891]     }
[10:21:43.891]     ...future.result$conditions <- ...future.conditions
[10:21:43.891]     ...future.result$finished <- base::Sys.time()
[10:21:43.891]     ...future.result
[10:21:43.891] }
[10:21:43.894] requestCore(): workers = 2
[10:21:43.895] MulticoreFuture started
[10:21:43.896] - Launch lazy future ... done
[10:21:43.896] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.896] getGlobalsAndPackages() ...
[10:21:43.896] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.897] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.897] List of future strategies:
[10:21:43.897] 1. sequential:
[10:21:43.897]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.897]    - tweaked: FALSE
[10:21:43.897]    - call: NULL
[10:21:43.898] plan(): nbrOfWorkers() = 1
[10:21:43.899] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.899] Searching for globals ... DONE
[10:21:43.899] Resolving globals: TRUE
[10:21:43.899] Resolving any globals that are futures ...
[10:21:43.900] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.900] Resolving any globals that are futures ... DONE
[10:21:43.900] plan(): Setting new future strategy stack:
[10:21:43.900] List of future strategies:
[10:21:43.900] 1. multicore:
[10:21:43.900]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.900]    - tweaked: FALSE
[10:21:43.900]    - call: plan(strategy)
[10:21:43.900] Resolving futures part of globals (recursively) ...
[10:21:43.901] resolve() on list ...
[10:21:43.901]  recursive: 99
[10:21:43.901]  length: 1
[10:21:43.901]  elements: ‘a’
[10:21:43.903] plan(): nbrOfWorkers() = 2
[10:21:43.903] Future #1
[10:21:43.904] result() for MulticoreFuture ...
[10:21:43.904] result() for MulticoreFuture ...
[10:21:43.905] result() for MulticoreFuture ... done
[10:21:43.905] result() for MulticoreFuture ... done
[10:21:43.905] result() for MulticoreFuture ...
[10:21:43.905] result() for MulticoreFuture ... done
[10:21:43.908] A MulticoreFuture was resolved
[10:21:43.908]  length: 0 (resolved future 1)
[10:21:43.909] resolve() on list ... DONE
[10:21:43.909] - globals: [1] ‘a’
[10:21:43.909] Resolving futures part of globals (recursively) ... DONE
[10:21:43.909] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[10:21:43.910] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[10:21:43.910] - globals: [1] ‘a’
[10:21:43.910] - packages: [1] ‘future’
[10:21:43.910] getGlobalsAndPackages() ... DONE
[10:21:43.911] run() for ‘Future’ ...
[10:21:43.911] - state: ‘created’
[10:21:43.911] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.913] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.914]   - Field: ‘label’
[10:21:43.914]   - Field: ‘local’
[10:21:43.914]   - Field: ‘owner’
[10:21:43.914]   - Field: ‘envir’
[10:21:43.914]   - Field: ‘workers’
[10:21:43.914]   - Field: ‘packages’
[10:21:43.914]   - Field: ‘gc’
[10:21:43.914]   - Field: ‘job’
[10:21:43.915]   - Field: ‘conditions’
[10:21:43.915]   - Field: ‘expr’
[10:21:43.915]   - Field: ‘uuid’
[10:21:43.915]   - Field: ‘seed’
[10:21:43.915]   - Field: ‘version’
[10:21:43.915]   - Field: ‘result’
[10:21:43.915]   - Field: ‘asynchronous’
[10:21:43.915]   - Field: ‘calls’
[10:21:43.915]   - Field: ‘globals’
[10:21:43.916]   - Field: ‘stdout’
[10:21:43.916]   - Field: ‘earlySignal’
[10:21:43.916]   - Field: ‘lazy’
[10:21:43.916]   - Field: ‘state’
[10:21:43.916] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.916] - Launch lazy future ...
[10:21:43.916] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.917] Packages needed by future strategies (n = 0): <none>
[10:21:43.917] {
[10:21:43.917]     {
[10:21:43.917]         {
[10:21:43.917]             ...future.startTime <- base::Sys.time()
[10:21:43.917]             {
[10:21:43.917]                 {
[10:21:43.917]                   {
[10:21:43.917]                     {
[10:21:43.917]                       {
[10:21:43.917]                         base::local({
[10:21:43.917]                           has_future <- base::requireNamespace("future", 
[10:21:43.917]                             quietly = TRUE)
[10:21:43.917]                           if (has_future) {
[10:21:43.917]                             ns <- base::getNamespace("future")
[10:21:43.917]                             version <- ns[[".package"]][["version"]]
[10:21:43.917]                             if (is.null(version)) 
[10:21:43.917]                               version <- utils::packageVersion("future")
[10:21:43.917]                           }
[10:21:43.917]                           else {
[10:21:43.917]                             version <- NULL
[10:21:43.917]                           }
[10:21:43.917]                           if (!has_future || version < "1.8.0") {
[10:21:43.917]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.917]                               "", base::R.version$version.string), 
[10:21:43.917]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:43.917]                                 base::R.version$platform, 8 * 
[10:21:43.917]                                   base::.Machine$sizeof.pointer), 
[10:21:43.917]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.917]                                 "release", "version")], collapse = " "), 
[10:21:43.917]                               hostname = base::Sys.info()[["nodename"]])
[10:21:43.917]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.917]                               info)
[10:21:43.917]                             info <- base::paste(info, collapse = "; ")
[10:21:43.917]                             if (!has_future) {
[10:21:43.917]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.917]                                 info)
[10:21:43.917]                             }
[10:21:43.917]                             else {
[10:21:43.917]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.917]                                 info, version)
[10:21:43.917]                             }
[10:21:43.917]                             base::stop(msg)
[10:21:43.917]                           }
[10:21:43.917]                         })
[10:21:43.917]                       }
[10:21:43.917]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.917]                       base::options(mc.cores = 1L)
[10:21:43.917]                     }
[10:21:43.917]                     base::local({
[10:21:43.917]                       for (pkg in "future") {
[10:21:43.917]                         base::loadNamespace(pkg)
[10:21:43.917]                         base::library(pkg, character.only = TRUE)
[10:21:43.917]                       }
[10:21:43.917]                     })
[10:21:43.917]                   }
[10:21:43.917]                   ...future.strategy.old <- future::plan("list")
[10:21:43.917]                   options(future.plan = NULL)
[10:21:43.917]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.917]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.917]                 }
[10:21:43.917]                 ...future.workdir <- getwd()
[10:21:43.917]             }
[10:21:43.917]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.917]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.917]         }
[10:21:43.917]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.917]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.917]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.917]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.917]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.917]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.917]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.917]             base::names(...future.oldOptions))
[10:21:43.917]     }
[10:21:43.917]     if (FALSE) {
[10:21:43.917]     }
[10:21:43.917]     else {
[10:21:43.917]         if (TRUE) {
[10:21:43.917]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.917]                 open = "w")
[10:21:43.917]         }
[10:21:43.917]         else {
[10:21:43.917]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.917]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.917]         }
[10:21:43.917]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.917]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.917]             base::sink(type = "output", split = FALSE)
[10:21:43.917]             base::close(...future.stdout)
[10:21:43.917]         }, add = TRUE)
[10:21:43.917]     }
[10:21:43.917]     ...future.frame <- base::sys.nframe()
[10:21:43.917]     ...future.conditions <- base::list()
[10:21:43.917]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.917]     if (FALSE) {
[10:21:43.917]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.917]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.917]     }
[10:21:43.917]     ...future.result <- base::tryCatch({
[10:21:43.917]         base::withCallingHandlers({
[10:21:43.917]             ...future.value <- base::withVisible(base::local({
[10:21:43.917]                 withCallingHandlers({
[10:21:43.917]                   value(a) + 1
[10:21:43.917]                 }, immediateCondition = function(cond) {
[10:21:43.917]                   save_rds <- function (object, pathname, ...) 
[10:21:43.917]                   {
[10:21:43.917]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.917]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.917]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.917]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.917]                         fi_tmp[["mtime"]])
[10:21:43.917]                     }
[10:21:43.917]                     tryCatch({
[10:21:43.917]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.917]                     }, error = function(ex) {
[10:21:43.917]                       msg <- conditionMessage(ex)
[10:21:43.917]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.917]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.917]                         fi_tmp[["mtime"]], msg)
[10:21:43.917]                       ex$message <- msg
[10:21:43.917]                       stop(ex)
[10:21:43.917]                     })
[10:21:43.917]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.917]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.917]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.917]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.917]                       fi <- file.info(pathname)
[10:21:43.917]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.917]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.917]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.917]                         fi[["size"]], fi[["mtime"]])
[10:21:43.917]                       stop(msg)
[10:21:43.917]                     }
[10:21:43.917]                     invisible(pathname)
[10:21:43.917]                   }
[10:21:43.917]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.917]                     rootPath = tempdir()) 
[10:21:43.917]                   {
[10:21:43.917]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.917]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.917]                       tmpdir = path, fileext = ".rds")
[10:21:43.917]                     save_rds(obj, file)
[10:21:43.917]                   }
[10:21:43.917]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.917]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.917]                   {
[10:21:43.917]                     inherits <- base::inherits
[10:21:43.917]                     invokeRestart <- base::invokeRestart
[10:21:43.917]                     is.null <- base::is.null
[10:21:43.917]                     muffled <- FALSE
[10:21:43.917]                     if (inherits(cond, "message")) {
[10:21:43.917]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.917]                       if (muffled) 
[10:21:43.917]                         invokeRestart("muffleMessage")
[10:21:43.917]                     }
[10:21:43.917]                     else if (inherits(cond, "warning")) {
[10:21:43.917]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.917]                       if (muffled) 
[10:21:43.917]                         invokeRestart("muffleWarning")
[10:21:43.917]                     }
[10:21:43.917]                     else if (inherits(cond, "condition")) {
[10:21:43.917]                       if (!is.null(pattern)) {
[10:21:43.917]                         computeRestarts <- base::computeRestarts
[10:21:43.917]                         grepl <- base::grepl
[10:21:43.917]                         restarts <- computeRestarts(cond)
[10:21:43.917]                         for (restart in restarts) {
[10:21:43.917]                           name <- restart$name
[10:21:43.917]                           if (is.null(name)) 
[10:21:43.917]                             next
[10:21:43.917]                           if (!grepl(pattern, name)) 
[10:21:43.917]                             next
[10:21:43.917]                           invokeRestart(restart)
[10:21:43.917]                           muffled <- TRUE
[10:21:43.917]                           break
[10:21:43.917]                         }
[10:21:43.917]                       }
[10:21:43.917]                     }
[10:21:43.917]                     invisible(muffled)
[10:21:43.917]                   }
[10:21:43.917]                   muffleCondition(cond)
[10:21:43.917]                 })
[10:21:43.917]             }))
[10:21:43.917]             future::FutureResult(value = ...future.value$value, 
[10:21:43.917]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.917]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.917]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.917]                     ...future.globalenv.names))
[10:21:43.917]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.917]         }, condition = base::local({
[10:21:43.917]             c <- base::c
[10:21:43.917]             inherits <- base::inherits
[10:21:43.917]             invokeRestart <- base::invokeRestart
[10:21:43.917]             length <- base::length
[10:21:43.917]             list <- base::list
[10:21:43.917]             seq.int <- base::seq.int
[10:21:43.917]             signalCondition <- base::signalCondition
[10:21:43.917]             sys.calls <- base::sys.calls
[10:21:43.917]             `[[` <- base::`[[`
[10:21:43.917]             `+` <- base::`+`
[10:21:43.917]             `<<-` <- base::`<<-`
[10:21:43.917]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.917]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.917]                   3L)]
[10:21:43.917]             }
[10:21:43.917]             function(cond) {
[10:21:43.917]                 is_error <- inherits(cond, "error")
[10:21:43.917]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.917]                   NULL)
[10:21:43.917]                 if (is_error) {
[10:21:43.917]                   sessionInformation <- function() {
[10:21:43.917]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.917]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.917]                       search = base::search(), system = base::Sys.info())
[10:21:43.917]                   }
[10:21:43.917]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.917]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.917]                     cond$call), session = sessionInformation(), 
[10:21:43.917]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.917]                   signalCondition(cond)
[10:21:43.917]                 }
[10:21:43.917]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.917]                 "immediateCondition"))) {
[10:21:43.917]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.917]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.917]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.917]                   if (TRUE && !signal) {
[10:21:43.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.917]                     {
[10:21:43.917]                       inherits <- base::inherits
[10:21:43.917]                       invokeRestart <- base::invokeRestart
[10:21:43.917]                       is.null <- base::is.null
[10:21:43.917]                       muffled <- FALSE
[10:21:43.917]                       if (inherits(cond, "message")) {
[10:21:43.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.917]                         if (muffled) 
[10:21:43.917]                           invokeRestart("muffleMessage")
[10:21:43.917]                       }
[10:21:43.917]                       else if (inherits(cond, "warning")) {
[10:21:43.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.917]                         if (muffled) 
[10:21:43.917]                           invokeRestart("muffleWarning")
[10:21:43.917]                       }
[10:21:43.917]                       else if (inherits(cond, "condition")) {
[10:21:43.917]                         if (!is.null(pattern)) {
[10:21:43.917]                           computeRestarts <- base::computeRestarts
[10:21:43.917]                           grepl <- base::grepl
[10:21:43.917]                           restarts <- computeRestarts(cond)
[10:21:43.917]                           for (restart in restarts) {
[10:21:43.917]                             name <- restart$name
[10:21:43.917]                             if (is.null(name)) 
[10:21:43.917]                               next
[10:21:43.917]                             if (!grepl(pattern, name)) 
[10:21:43.917]                               next
[10:21:43.917]                             invokeRestart(restart)
[10:21:43.917]                             muffled <- TRUE
[10:21:43.917]                             break
[10:21:43.917]                           }
[10:21:43.917]                         }
[10:21:43.917]                       }
[10:21:43.917]                       invisible(muffled)
[10:21:43.917]                     }
[10:21:43.917]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.917]                   }
[10:21:43.917]                 }
[10:21:43.917]                 else {
[10:21:43.917]                   if (TRUE) {
[10:21:43.917]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.917]                     {
[10:21:43.917]                       inherits <- base::inherits
[10:21:43.917]                       invokeRestart <- base::invokeRestart
[10:21:43.917]                       is.null <- base::is.null
[10:21:43.917]                       muffled <- FALSE
[10:21:43.917]                       if (inherits(cond, "message")) {
[10:21:43.917]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.917]                         if (muffled) 
[10:21:43.917]                           invokeRestart("muffleMessage")
[10:21:43.917]                       }
[10:21:43.917]                       else if (inherits(cond, "warning")) {
[10:21:43.917]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.917]                         if (muffled) 
[10:21:43.917]                           invokeRestart("muffleWarning")
[10:21:43.917]                       }
[10:21:43.917]                       else if (inherits(cond, "condition")) {
[10:21:43.917]                         if (!is.null(pattern)) {
[10:21:43.917]                           computeRestarts <- base::computeRestarts
[10:21:43.917]                           grepl <- base::grepl
[10:21:43.917]                           restarts <- computeRestarts(cond)
[10:21:43.917]                           for (restart in restarts) {
[10:21:43.917]                             name <- restart$name
[10:21:43.917]                             if (is.null(name)) 
[10:21:43.917]                               next
[10:21:43.917]                             if (!grepl(pattern, name)) 
[10:21:43.917]                               next
[10:21:43.917]                             invokeRestart(restart)
[10:21:43.917]                             muffled <- TRUE
[10:21:43.917]                             break
[10:21:43.917]                           }
[10:21:43.917]                         }
[10:21:43.917]                       }
[10:21:43.917]                       invisible(muffled)
[10:21:43.917]                     }
[10:21:43.917]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.917]                   }
[10:21:43.917]                 }
[10:21:43.917]             }
[10:21:43.917]         }))
[10:21:43.917]     }, error = function(ex) {
[10:21:43.917]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.917]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.917]                 ...future.rng), started = ...future.startTime, 
[10:21:43.917]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.917]             version = "1.8"), class = "FutureResult")
[10:21:43.917]     }, finally = {
[10:21:43.917]         if (!identical(...future.workdir, getwd())) 
[10:21:43.917]             setwd(...future.workdir)
[10:21:43.917]         {
[10:21:43.917]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.917]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.917]             }
[10:21:43.917]             base::options(...future.oldOptions)
[10:21:43.917]             if (.Platform$OS.type == "windows") {
[10:21:43.917]                 old_names <- names(...future.oldEnvVars)
[10:21:43.917]                 envs <- base::Sys.getenv()
[10:21:43.917]                 names <- names(envs)
[10:21:43.917]                 common <- intersect(names, old_names)
[10:21:43.917]                 added <- setdiff(names, old_names)
[10:21:43.917]                 removed <- setdiff(old_names, names)
[10:21:43.917]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.917]                   envs[common]]
[10:21:43.917]                 NAMES <- toupper(changed)
[10:21:43.917]                 args <- list()
[10:21:43.917]                 for (kk in seq_along(NAMES)) {
[10:21:43.917]                   name <- changed[[kk]]
[10:21:43.917]                   NAME <- NAMES[[kk]]
[10:21:43.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.917]                     next
[10:21:43.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.917]                 }
[10:21:43.917]                 NAMES <- toupper(added)
[10:21:43.917]                 for (kk in seq_along(NAMES)) {
[10:21:43.917]                   name <- added[[kk]]
[10:21:43.917]                   NAME <- NAMES[[kk]]
[10:21:43.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.917]                     next
[10:21:43.917]                   args[[name]] <- ""
[10:21:43.917]                 }
[10:21:43.917]                 NAMES <- toupper(removed)
[10:21:43.917]                 for (kk in seq_along(NAMES)) {
[10:21:43.917]                   name <- removed[[kk]]
[10:21:43.917]                   NAME <- NAMES[[kk]]
[10:21:43.917]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.917]                     next
[10:21:43.917]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.917]                 }
[10:21:43.917]                 if (length(args) > 0) 
[10:21:43.917]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.917]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.917]             }
[10:21:43.917]             else {
[10:21:43.917]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.917]             }
[10:21:43.917]             {
[10:21:43.917]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.917]                   0L) {
[10:21:43.917]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.917]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.917]                   base::options(opts)
[10:21:43.917]                 }
[10:21:43.917]                 {
[10:21:43.917]                   {
[10:21:43.917]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.917]                     NULL
[10:21:43.917]                   }
[10:21:43.917]                   options(future.plan = NULL)
[10:21:43.917]                   if (is.na(NA_character_)) 
[10:21:43.917]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.917]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.917]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.917]                     .init = FALSE)
[10:21:43.917]                 }
[10:21:43.917]             }
[10:21:43.917]         }
[10:21:43.917]     })
[10:21:43.917]     if (TRUE) {
[10:21:43.917]         base::sink(type = "output", split = FALSE)
[10:21:43.917]         if (TRUE) {
[10:21:43.917]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.917]         }
[10:21:43.917]         else {
[10:21:43.917]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.917]         }
[10:21:43.917]         base::close(...future.stdout)
[10:21:43.917]         ...future.stdout <- NULL
[10:21:43.917]     }
[10:21:43.917]     ...future.result$conditions <- ...future.conditions
[10:21:43.917]     ...future.result$finished <- base::Sys.time()
[10:21:43.917]     ...future.result
[10:21:43.917] }
[10:21:43.920] assign_globals() ...
[10:21:43.920] List of 1
[10:21:43.920]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18e35cc68> 
[10:21:43.920]  - attr(*, "where")=List of 1
[10:21:43.920]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.920]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.920]  - attr(*, "resolved")= logi TRUE
[10:21:43.920]  - attr(*, "total_size")= num 3815
[10:21:43.920]  - attr(*, "already-done")= logi TRUE
[10:21:43.923] - copied ‘a’ to environment
[10:21:43.923] assign_globals() ... done
[10:21:43.923] requestCore(): workers = 2
[10:21:43.925] MulticoreFuture started
[10:21:43.925] - Launch lazy future ... done
[10:21:43.926] run() for ‘MulticoreFuture’ ... done
[10:21:43.926] result() for MulticoreFuture ...
[10:21:43.927] plan(): Setting new future strategy stack:
[10:21:43.927] List of future strategies:
[10:21:43.927] 1. sequential:
[10:21:43.927]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.927]    - tweaked: FALSE
[10:21:43.927]    - call: NULL
[10:21:43.928] plan(): nbrOfWorkers() = 1
[10:21:43.931] plan(): Setting new future strategy stack:
[10:21:43.931] List of future strategies:
[10:21:43.931] 1. multicore:
[10:21:43.931]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.931]    - tweaked: FALSE
[10:21:43.931]    - call: plan(strategy)
[10:21:43.935] plan(): nbrOfWorkers() = 2
[10:21:43.935] result() for MulticoreFuture ...
[10:21:43.935] result() for MulticoreFuture ... done
[10:21:43.936] signalConditions() ...
[10:21:43.936]  - include = ‘immediateCondition’
[10:21:43.936]  - exclude = 
[10:21:43.936]  - resignal = FALSE
[10:21:43.936]  - Number of conditions: 4
[10:21:43.936] signalConditions() ... done
[10:21:43.936] result() for MulticoreFuture ... done
[10:21:43.936] result() for MulticoreFuture ...
[10:21:43.937] result() for MulticoreFuture ... done
[10:21:43.937] signalConditions() ...
[10:21:43.937]  - include = ‘immediateCondition’
[10:21:43.937]  - exclude = 
[10:21:43.937]  - resignal = FALSE
[10:21:43.937]  - Number of conditions: 4
[10:21:43.937] signalConditions() ... done
[10:21:43.937] Future state: ‘finished’
[10:21:43.938] result() for MulticoreFuture ...
[10:21:43.938] result() for MulticoreFuture ... done
[10:21:43.938] signalConditions() ...
[10:21:43.938]  - include = ‘condition’
[10:21:43.938]  - exclude = ‘immediateCondition’
[10:21:43.938]  - resignal = TRUE
[10:21:43.938]  - Number of conditions: 4
[10:21:43.938]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.929] result() for MulticoreFuture ...
[10:21:43.939]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.930] result() for MulticoreFuture ... done
[10:21:43.939]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.930] result() for MulticoreFuture ...
[10:21:43.939]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.930] result() for MulticoreFuture ... done
[10:21:43.939] signalConditions() ... done
value(b) = 2
[10:21:43.939] result() for MulticoreFuture ...
[10:21:43.939] result() for MulticoreFuture ... done
[10:21:43.940] result() for MulticoreFuture ...
[10:21:43.940] result() for MulticoreFuture ... done
[10:21:43.940] signalConditions() ...
[10:21:43.940]  - include = ‘immediateCondition’
[10:21:43.940]  - exclude = 
[10:21:43.940]  - resignal = FALSE
[10:21:43.940]  - Number of conditions: 4
[10:21:43.940] signalConditions() ... done
[10:21:43.940] Future state: ‘finished’
[10:21:43.941] result() for MulticoreFuture ...
[10:21:43.941] result() for MulticoreFuture ... done
[10:21:43.941] signalConditions() ...
[10:21:43.941]  - include = ‘condition’
[10:21:43.941]  - exclude = ‘immediateCondition’
[10:21:43.941]  - resignal = TRUE
[10:21:43.941]  - Number of conditions: 4
[10:21:43.941]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.929] result() for MulticoreFuture ...
[10:21:43.941]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.930] result() for MulticoreFuture ... done
[10:21:43.942]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.930] result() for MulticoreFuture ...
[10:21:43.942]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.930] result() for MulticoreFuture ... done
[10:21:43.942] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.942] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.942] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.943] 
[10:21:43.943] Searching for globals ... DONE
[10:21:43.944] - globals: [0] <none>
[10:21:43.944] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:43.944] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:43.944] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:43.948] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:43.948] Searching for globals ... DONE
[10:21:43.948] Resolving globals: TRUE
[10:21:43.948] Resolving any globals that are futures ...
[10:21:43.949] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:43.949] Resolving any globals that are futures ... DONE
[10:21:43.949] Resolving futures part of globals (recursively) ...
[10:21:43.950] resolve() on list ...
[10:21:43.950]  recursive: 99
[10:21:43.950]  length: 1
[10:21:43.950]  elements: ‘a’
[10:21:43.950] run() for ‘Future’ ...
[10:21:43.950] - state: ‘created’
[10:21:43.950] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.953] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.953] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.953]   - Field: ‘label’
[10:21:43.953]   - Field: ‘local’
[10:21:43.953]   - Field: ‘owner’
[10:21:43.953]   - Field: ‘envir’
[10:21:43.953]   - Field: ‘workers’
[10:21:43.953]   - Field: ‘packages’
[10:21:43.954]   - Field: ‘gc’
[10:21:43.954]   - Field: ‘job’
[10:21:43.954]   - Field: ‘conditions’
[10:21:43.954]   - Field: ‘expr’
[10:21:43.954]   - Field: ‘uuid’
[10:21:43.954]   - Field: ‘seed’
[10:21:43.954]   - Field: ‘version’
[10:21:43.954]   - Field: ‘result’
[10:21:43.955]   - Field: ‘asynchronous’
[10:21:43.955]   - Field: ‘calls’
[10:21:43.955]   - Field: ‘globals’
[10:21:43.955]   - Field: ‘stdout’
[10:21:43.955]   - Field: ‘earlySignal’
[10:21:43.955]   - Field: ‘lazy’
[10:21:43.955]   - Field: ‘state’
[10:21:43.955] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.955] - Launch lazy future ...
[10:21:43.956] Packages needed by the future expression (n = 0): <none>
[10:21:43.956] Packages needed by future strategies (n = 0): <none>
[10:21:43.956] {
[10:21:43.956]     {
[10:21:43.956]         {
[10:21:43.956]             ...future.startTime <- base::Sys.time()
[10:21:43.956]             {
[10:21:43.956]                 {
[10:21:43.956]                   {
[10:21:43.956]                     {
[10:21:43.956]                       base::local({
[10:21:43.956]                         has_future <- base::requireNamespace("future", 
[10:21:43.956]                           quietly = TRUE)
[10:21:43.956]                         if (has_future) {
[10:21:43.956]                           ns <- base::getNamespace("future")
[10:21:43.956]                           version <- ns[[".package"]][["version"]]
[10:21:43.956]                           if (is.null(version)) 
[10:21:43.956]                             version <- utils::packageVersion("future")
[10:21:43.956]                         }
[10:21:43.956]                         else {
[10:21:43.956]                           version <- NULL
[10:21:43.956]                         }
[10:21:43.956]                         if (!has_future || version < "1.8.0") {
[10:21:43.956]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.956]                             "", base::R.version$version.string), 
[10:21:43.956]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:43.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:43.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.956]                               "release", "version")], collapse = " "), 
[10:21:43.956]                             hostname = base::Sys.info()[["nodename"]])
[10:21:43.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.956]                             info)
[10:21:43.956]                           info <- base::paste(info, collapse = "; ")
[10:21:43.956]                           if (!has_future) {
[10:21:43.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.956]                               info)
[10:21:43.956]                           }
[10:21:43.956]                           else {
[10:21:43.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.956]                               info, version)
[10:21:43.956]                           }
[10:21:43.956]                           base::stop(msg)
[10:21:43.956]                         }
[10:21:43.956]                       })
[10:21:43.956]                     }
[10:21:43.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.956]                     base::options(mc.cores = 1L)
[10:21:43.956]                   }
[10:21:43.956]                   ...future.strategy.old <- future::plan("list")
[10:21:43.956]                   options(future.plan = NULL)
[10:21:43.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.956]                 }
[10:21:43.956]                 ...future.workdir <- getwd()
[10:21:43.956]             }
[10:21:43.956]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.956]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.956]         }
[10:21:43.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.956]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.956]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.956]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.956]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.956]             base::names(...future.oldOptions))
[10:21:43.956]     }
[10:21:43.956]     if (FALSE) {
[10:21:43.956]     }
[10:21:43.956]     else {
[10:21:43.956]         if (TRUE) {
[10:21:43.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.956]                 open = "w")
[10:21:43.956]         }
[10:21:43.956]         else {
[10:21:43.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.956]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.956]         }
[10:21:43.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.956]             base::sink(type = "output", split = FALSE)
[10:21:43.956]             base::close(...future.stdout)
[10:21:43.956]         }, add = TRUE)
[10:21:43.956]     }
[10:21:43.956]     ...future.frame <- base::sys.nframe()
[10:21:43.956]     ...future.conditions <- base::list()
[10:21:43.956]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.956]     if (FALSE) {
[10:21:43.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.956]     }
[10:21:43.956]     ...future.result <- base::tryCatch({
[10:21:43.956]         base::withCallingHandlers({
[10:21:43.956]             ...future.value <- base::withVisible(base::local({
[10:21:43.956]                 withCallingHandlers({
[10:21:43.956]                   1
[10:21:43.956]                 }, immediateCondition = function(cond) {
[10:21:43.956]                   save_rds <- function (object, pathname, ...) 
[10:21:43.956]                   {
[10:21:43.956]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.956]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.956]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.956]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.956]                         fi_tmp[["mtime"]])
[10:21:43.956]                     }
[10:21:43.956]                     tryCatch({
[10:21:43.956]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.956]                     }, error = function(ex) {
[10:21:43.956]                       msg <- conditionMessage(ex)
[10:21:43.956]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.956]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.956]                         fi_tmp[["mtime"]], msg)
[10:21:43.956]                       ex$message <- msg
[10:21:43.956]                       stop(ex)
[10:21:43.956]                     })
[10:21:43.956]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.956]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.956]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.956]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.956]                       fi <- file.info(pathname)
[10:21:43.956]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.956]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.956]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.956]                         fi[["size"]], fi[["mtime"]])
[10:21:43.956]                       stop(msg)
[10:21:43.956]                     }
[10:21:43.956]                     invisible(pathname)
[10:21:43.956]                   }
[10:21:43.956]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.956]                     rootPath = tempdir()) 
[10:21:43.956]                   {
[10:21:43.956]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.956]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.956]                       tmpdir = path, fileext = ".rds")
[10:21:43.956]                     save_rds(obj, file)
[10:21:43.956]                   }
[10:21:43.956]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.956]                   {
[10:21:43.956]                     inherits <- base::inherits
[10:21:43.956]                     invokeRestart <- base::invokeRestart
[10:21:43.956]                     is.null <- base::is.null
[10:21:43.956]                     muffled <- FALSE
[10:21:43.956]                     if (inherits(cond, "message")) {
[10:21:43.956]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.956]                       if (muffled) 
[10:21:43.956]                         invokeRestart("muffleMessage")
[10:21:43.956]                     }
[10:21:43.956]                     else if (inherits(cond, "warning")) {
[10:21:43.956]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.956]                       if (muffled) 
[10:21:43.956]                         invokeRestart("muffleWarning")
[10:21:43.956]                     }
[10:21:43.956]                     else if (inherits(cond, "condition")) {
[10:21:43.956]                       if (!is.null(pattern)) {
[10:21:43.956]                         computeRestarts <- base::computeRestarts
[10:21:43.956]                         grepl <- base::grepl
[10:21:43.956]                         restarts <- computeRestarts(cond)
[10:21:43.956]                         for (restart in restarts) {
[10:21:43.956]                           name <- restart$name
[10:21:43.956]                           if (is.null(name)) 
[10:21:43.956]                             next
[10:21:43.956]                           if (!grepl(pattern, name)) 
[10:21:43.956]                             next
[10:21:43.956]                           invokeRestart(restart)
[10:21:43.956]                           muffled <- TRUE
[10:21:43.956]                           break
[10:21:43.956]                         }
[10:21:43.956]                       }
[10:21:43.956]                     }
[10:21:43.956]                     invisible(muffled)
[10:21:43.956]                   }
[10:21:43.956]                   muffleCondition(cond)
[10:21:43.956]                 })
[10:21:43.956]             }))
[10:21:43.956]             future::FutureResult(value = ...future.value$value, 
[10:21:43.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.956]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.956]                     ...future.globalenv.names))
[10:21:43.956]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.956]         }, condition = base::local({
[10:21:43.956]             c <- base::c
[10:21:43.956]             inherits <- base::inherits
[10:21:43.956]             invokeRestart <- base::invokeRestart
[10:21:43.956]             length <- base::length
[10:21:43.956]             list <- base::list
[10:21:43.956]             seq.int <- base::seq.int
[10:21:43.956]             signalCondition <- base::signalCondition
[10:21:43.956]             sys.calls <- base::sys.calls
[10:21:43.956]             `[[` <- base::`[[`
[10:21:43.956]             `+` <- base::`+`
[10:21:43.956]             `<<-` <- base::`<<-`
[10:21:43.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.956]                   3L)]
[10:21:43.956]             }
[10:21:43.956]             function(cond) {
[10:21:43.956]                 is_error <- inherits(cond, "error")
[10:21:43.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.956]                   NULL)
[10:21:43.956]                 if (is_error) {
[10:21:43.956]                   sessionInformation <- function() {
[10:21:43.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.956]                       search = base::search(), system = base::Sys.info())
[10:21:43.956]                   }
[10:21:43.956]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.956]                     cond$call), session = sessionInformation(), 
[10:21:43.956]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.956]                   signalCondition(cond)
[10:21:43.956]                 }
[10:21:43.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.956]                 "immediateCondition"))) {
[10:21:43.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.956]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.956]                   if (TRUE && !signal) {
[10:21:43.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.956]                     {
[10:21:43.956]                       inherits <- base::inherits
[10:21:43.956]                       invokeRestart <- base::invokeRestart
[10:21:43.956]                       is.null <- base::is.null
[10:21:43.956]                       muffled <- FALSE
[10:21:43.956]                       if (inherits(cond, "message")) {
[10:21:43.956]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.956]                         if (muffled) 
[10:21:43.956]                           invokeRestart("muffleMessage")
[10:21:43.956]                       }
[10:21:43.956]                       else if (inherits(cond, "warning")) {
[10:21:43.956]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.956]                         if (muffled) 
[10:21:43.956]                           invokeRestart("muffleWarning")
[10:21:43.956]                       }
[10:21:43.956]                       else if (inherits(cond, "condition")) {
[10:21:43.956]                         if (!is.null(pattern)) {
[10:21:43.956]                           computeRestarts <- base::computeRestarts
[10:21:43.956]                           grepl <- base::grepl
[10:21:43.956]                           restarts <- computeRestarts(cond)
[10:21:43.956]                           for (restart in restarts) {
[10:21:43.956]                             name <- restart$name
[10:21:43.956]                             if (is.null(name)) 
[10:21:43.956]                               next
[10:21:43.956]                             if (!grepl(pattern, name)) 
[10:21:43.956]                               next
[10:21:43.956]                             invokeRestart(restart)
[10:21:43.956]                             muffled <- TRUE
[10:21:43.956]                             break
[10:21:43.956]                           }
[10:21:43.956]                         }
[10:21:43.956]                       }
[10:21:43.956]                       invisible(muffled)
[10:21:43.956]                     }
[10:21:43.956]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.956]                   }
[10:21:43.956]                 }
[10:21:43.956]                 else {
[10:21:43.956]                   if (TRUE) {
[10:21:43.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.956]                     {
[10:21:43.956]                       inherits <- base::inherits
[10:21:43.956]                       invokeRestart <- base::invokeRestart
[10:21:43.956]                       is.null <- base::is.null
[10:21:43.956]                       muffled <- FALSE
[10:21:43.956]                       if (inherits(cond, "message")) {
[10:21:43.956]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.956]                         if (muffled) 
[10:21:43.956]                           invokeRestart("muffleMessage")
[10:21:43.956]                       }
[10:21:43.956]                       else if (inherits(cond, "warning")) {
[10:21:43.956]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.956]                         if (muffled) 
[10:21:43.956]                           invokeRestart("muffleWarning")
[10:21:43.956]                       }
[10:21:43.956]                       else if (inherits(cond, "condition")) {
[10:21:43.956]                         if (!is.null(pattern)) {
[10:21:43.956]                           computeRestarts <- base::computeRestarts
[10:21:43.956]                           grepl <- base::grepl
[10:21:43.956]                           restarts <- computeRestarts(cond)
[10:21:43.956]                           for (restart in restarts) {
[10:21:43.956]                             name <- restart$name
[10:21:43.956]                             if (is.null(name)) 
[10:21:43.956]                               next
[10:21:43.956]                             if (!grepl(pattern, name)) 
[10:21:43.956]                               next
[10:21:43.956]                             invokeRestart(restart)
[10:21:43.956]                             muffled <- TRUE
[10:21:43.956]                             break
[10:21:43.956]                           }
[10:21:43.956]                         }
[10:21:43.956]                       }
[10:21:43.956]                       invisible(muffled)
[10:21:43.956]                     }
[10:21:43.956]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.956]                   }
[10:21:43.956]                 }
[10:21:43.956]             }
[10:21:43.956]         }))
[10:21:43.956]     }, error = function(ex) {
[10:21:43.956]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.956]                 ...future.rng), started = ...future.startTime, 
[10:21:43.956]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.956]             version = "1.8"), class = "FutureResult")
[10:21:43.956]     }, finally = {
[10:21:43.956]         if (!identical(...future.workdir, getwd())) 
[10:21:43.956]             setwd(...future.workdir)
[10:21:43.956]         {
[10:21:43.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.956]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.956]             }
[10:21:43.956]             base::options(...future.oldOptions)
[10:21:43.956]             if (.Platform$OS.type == "windows") {
[10:21:43.956]                 old_names <- names(...future.oldEnvVars)
[10:21:43.956]                 envs <- base::Sys.getenv()
[10:21:43.956]                 names <- names(envs)
[10:21:43.956]                 common <- intersect(names, old_names)
[10:21:43.956]                 added <- setdiff(names, old_names)
[10:21:43.956]                 removed <- setdiff(old_names, names)
[10:21:43.956]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.956]                   envs[common]]
[10:21:43.956]                 NAMES <- toupper(changed)
[10:21:43.956]                 args <- list()
[10:21:43.956]                 for (kk in seq_along(NAMES)) {
[10:21:43.956]                   name <- changed[[kk]]
[10:21:43.956]                   NAME <- NAMES[[kk]]
[10:21:43.956]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.956]                     next
[10:21:43.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.956]                 }
[10:21:43.956]                 NAMES <- toupper(added)
[10:21:43.956]                 for (kk in seq_along(NAMES)) {
[10:21:43.956]                   name <- added[[kk]]
[10:21:43.956]                   NAME <- NAMES[[kk]]
[10:21:43.956]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.956]                     next
[10:21:43.956]                   args[[name]] <- ""
[10:21:43.956]                 }
[10:21:43.956]                 NAMES <- toupper(removed)
[10:21:43.956]                 for (kk in seq_along(NAMES)) {
[10:21:43.956]                   name <- removed[[kk]]
[10:21:43.956]                   NAME <- NAMES[[kk]]
[10:21:43.956]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.956]                     next
[10:21:43.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.956]                 }
[10:21:43.956]                 if (length(args) > 0) 
[10:21:43.956]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.956]             }
[10:21:43.956]             else {
[10:21:43.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.956]             }
[10:21:43.956]             {
[10:21:43.956]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.956]                   0L) {
[10:21:43.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.956]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.956]                   base::options(opts)
[10:21:43.956]                 }
[10:21:43.956]                 {
[10:21:43.956]                   {
[10:21:43.956]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.956]                     NULL
[10:21:43.956]                   }
[10:21:43.956]                   options(future.plan = NULL)
[10:21:43.956]                   if (is.na(NA_character_)) 
[10:21:43.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.956]                     .init = FALSE)
[10:21:43.956]                 }
[10:21:43.956]             }
[10:21:43.956]         }
[10:21:43.956]     })
[10:21:43.956]     if (TRUE) {
[10:21:43.956]         base::sink(type = "output", split = FALSE)
[10:21:43.956]         if (TRUE) {
[10:21:43.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.956]         }
[10:21:43.956]         else {
[10:21:43.956]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.956]         }
[10:21:43.956]         base::close(...future.stdout)
[10:21:43.956]         ...future.stdout <- NULL
[10:21:43.956]     }
[10:21:43.956]     ...future.result$conditions <- ...future.conditions
[10:21:43.956]     ...future.result$finished <- base::Sys.time()
[10:21:43.956]     ...future.result
[10:21:43.956] }
[10:21:43.959] requestCore(): workers = 2
[10:21:43.960] MulticoreFuture started
[10:21:43.961] - Launch lazy future ... done
[10:21:43.961] run() for ‘MulticoreFuture’ ... done
[10:21:43.961] plan(): Setting new future strategy stack:
[10:21:43.962] List of future strategies:
[10:21:43.962] 1. sequential:
[10:21:43.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.962]    - tweaked: FALSE
[10:21:43.962]    - call: NULL
[10:21:43.963] plan(): nbrOfWorkers() = 1
[10:21:43.965] plan(): Setting new future strategy stack:
[10:21:43.965] List of future strategies:
[10:21:43.965] 1. multicore:
[10:21:43.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.965]    - tweaked: FALSE
[10:21:43.965]    - call: plan(strategy)
[10:21:43.968] plan(): nbrOfWorkers() = 2
[10:21:43.969] Future #1
[10:21:43.969] result() for MulticoreFuture ...
[10:21:43.970] result() for MulticoreFuture ...
[10:21:43.970] result() for MulticoreFuture ... done
[10:21:43.970] result() for MulticoreFuture ... done
[10:21:43.970] result() for MulticoreFuture ...
[10:21:43.971] result() for MulticoreFuture ... done
[10:21:43.971] A MulticoreFuture was resolved
[10:21:43.971]  length: 0 (resolved future 1)
[10:21:43.971] resolve() on list ... DONE
[10:21:43.971] - globals: [1] ‘a’
[10:21:43.971] Resolving futures part of globals (recursively) ... DONE
[10:21:43.972] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[10:21:43.972] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[10:21:43.972] - globals: [1] ‘a’
[10:21:43.972] - packages: [1] ‘future’
[10:21:43.973] getGlobalsAndPackages() ... DONE
[10:21:43.973] run() for ‘Future’ ...
[10:21:43.973] - state: ‘created’
[10:21:43.973] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:43.975] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:43.976] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:43.976]   - Field: ‘label’
[10:21:43.976]   - Field: ‘local’
[10:21:43.976]   - Field: ‘owner’
[10:21:43.976]   - Field: ‘envir’
[10:21:43.976]   - Field: ‘workers’
[10:21:43.976]   - Field: ‘packages’
[10:21:43.976]   - Field: ‘gc’
[10:21:43.976]   - Field: ‘job’
[10:21:43.977]   - Field: ‘conditions’
[10:21:43.977]   - Field: ‘expr’
[10:21:43.977]   - Field: ‘uuid’
[10:21:43.977]   - Field: ‘seed’
[10:21:43.977]   - Field: ‘version’
[10:21:43.977]   - Field: ‘result’
[10:21:43.977]   - Field: ‘asynchronous’
[10:21:43.977]   - Field: ‘calls’
[10:21:43.977]   - Field: ‘globals’
[10:21:43.978]   - Field: ‘stdout’
[10:21:43.978]   - Field: ‘earlySignal’
[10:21:43.978]   - Field: ‘lazy’
[10:21:43.978]   - Field: ‘state’
[10:21:43.978] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:43.978] - Launch lazy future ...
[10:21:43.978] Packages needed by the future expression (n = 1): ‘future’
[10:21:43.979] Packages needed by future strategies (n = 0): <none>
[10:21:43.979] {
[10:21:43.979]     {
[10:21:43.979]         {
[10:21:43.979]             ...future.startTime <- base::Sys.time()
[10:21:43.979]             {
[10:21:43.979]                 {
[10:21:43.979]                   {
[10:21:43.979]                     {
[10:21:43.979]                       {
[10:21:43.979]                         base::local({
[10:21:43.979]                           has_future <- base::requireNamespace("future", 
[10:21:43.979]                             quietly = TRUE)
[10:21:43.979]                           if (has_future) {
[10:21:43.979]                             ns <- base::getNamespace("future")
[10:21:43.979]                             version <- ns[[".package"]][["version"]]
[10:21:43.979]                             if (is.null(version)) 
[10:21:43.979]                               version <- utils::packageVersion("future")
[10:21:43.979]                           }
[10:21:43.979]                           else {
[10:21:43.979]                             version <- NULL
[10:21:43.979]                           }
[10:21:43.979]                           if (!has_future || version < "1.8.0") {
[10:21:43.979]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:43.979]                               "", base::R.version$version.string), 
[10:21:43.979]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:43.979]                                 base::R.version$platform, 8 * 
[10:21:43.979]                                   base::.Machine$sizeof.pointer), 
[10:21:43.979]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:43.979]                                 "release", "version")], collapse = " "), 
[10:21:43.979]                               hostname = base::Sys.info()[["nodename"]])
[10:21:43.979]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:43.979]                               info)
[10:21:43.979]                             info <- base::paste(info, collapse = "; ")
[10:21:43.979]                             if (!has_future) {
[10:21:43.979]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:43.979]                                 info)
[10:21:43.979]                             }
[10:21:43.979]                             else {
[10:21:43.979]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:43.979]                                 info, version)
[10:21:43.979]                             }
[10:21:43.979]                             base::stop(msg)
[10:21:43.979]                           }
[10:21:43.979]                         })
[10:21:43.979]                       }
[10:21:43.979]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:43.979]                       base::options(mc.cores = 1L)
[10:21:43.979]                     }
[10:21:43.979]                     base::local({
[10:21:43.979]                       for (pkg in "future") {
[10:21:43.979]                         base::loadNamespace(pkg)
[10:21:43.979]                         base::library(pkg, character.only = TRUE)
[10:21:43.979]                       }
[10:21:43.979]                     })
[10:21:43.979]                   }
[10:21:43.979]                   ...future.strategy.old <- future::plan("list")
[10:21:43.979]                   options(future.plan = NULL)
[10:21:43.979]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.979]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:43.979]                 }
[10:21:43.979]                 ...future.workdir <- getwd()
[10:21:43.979]             }
[10:21:43.979]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:43.979]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:43.979]         }
[10:21:43.979]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:43.979]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:43.979]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:43.979]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:43.979]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:43.979]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:43.979]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:43.979]             base::names(...future.oldOptions))
[10:21:43.979]     }
[10:21:43.979]     if (FALSE) {
[10:21:43.979]     }
[10:21:43.979]     else {
[10:21:43.979]         if (TRUE) {
[10:21:43.979]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:43.979]                 open = "w")
[10:21:43.979]         }
[10:21:43.979]         else {
[10:21:43.979]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:43.979]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:43.979]         }
[10:21:43.979]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:43.979]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:43.979]             base::sink(type = "output", split = FALSE)
[10:21:43.979]             base::close(...future.stdout)
[10:21:43.979]         }, add = TRUE)
[10:21:43.979]     }
[10:21:43.979]     ...future.frame <- base::sys.nframe()
[10:21:43.979]     ...future.conditions <- base::list()
[10:21:43.979]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:43.979]     if (FALSE) {
[10:21:43.979]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:43.979]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:43.979]     }
[10:21:43.979]     ...future.result <- base::tryCatch({
[10:21:43.979]         base::withCallingHandlers({
[10:21:43.979]             ...future.value <- base::withVisible(base::local({
[10:21:43.979]                 withCallingHandlers({
[10:21:43.979]                   value(a) + 1
[10:21:43.979]                 }, immediateCondition = function(cond) {
[10:21:43.979]                   save_rds <- function (object, pathname, ...) 
[10:21:43.979]                   {
[10:21:43.979]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:43.979]                     if (file_test("-f", pathname_tmp)) {
[10:21:43.979]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.979]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:43.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.979]                         fi_tmp[["mtime"]])
[10:21:43.979]                     }
[10:21:43.979]                     tryCatch({
[10:21:43.979]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:43.979]                     }, error = function(ex) {
[10:21:43.979]                       msg <- conditionMessage(ex)
[10:21:43.979]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.979]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:43.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.979]                         fi_tmp[["mtime"]], msg)
[10:21:43.979]                       ex$message <- msg
[10:21:43.979]                       stop(ex)
[10:21:43.979]                     })
[10:21:43.979]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:43.979]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:43.979]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:43.979]                       fi_tmp <- file.info(pathname_tmp)
[10:21:43.979]                       fi <- file.info(pathname)
[10:21:43.979]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:43.979]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:43.979]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:43.979]                         fi[["size"]], fi[["mtime"]])
[10:21:43.979]                       stop(msg)
[10:21:43.979]                     }
[10:21:43.979]                     invisible(pathname)
[10:21:43.979]                   }
[10:21:43.979]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:43.979]                     rootPath = tempdir()) 
[10:21:43.979]                   {
[10:21:43.979]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:43.979]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:43.979]                       tmpdir = path, fileext = ".rds")
[10:21:43.979]                     save_rds(obj, file)
[10:21:43.979]                   }
[10:21:43.979]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:43.979]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.979]                   {
[10:21:43.979]                     inherits <- base::inherits
[10:21:43.979]                     invokeRestart <- base::invokeRestart
[10:21:43.979]                     is.null <- base::is.null
[10:21:43.979]                     muffled <- FALSE
[10:21:43.979]                     if (inherits(cond, "message")) {
[10:21:43.979]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:43.979]                       if (muffled) 
[10:21:43.979]                         invokeRestart("muffleMessage")
[10:21:43.979]                     }
[10:21:43.979]                     else if (inherits(cond, "warning")) {
[10:21:43.979]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:43.979]                       if (muffled) 
[10:21:43.979]                         invokeRestart("muffleWarning")
[10:21:43.979]                     }
[10:21:43.979]                     else if (inherits(cond, "condition")) {
[10:21:43.979]                       if (!is.null(pattern)) {
[10:21:43.979]                         computeRestarts <- base::computeRestarts
[10:21:43.979]                         grepl <- base::grepl
[10:21:43.979]                         restarts <- computeRestarts(cond)
[10:21:43.979]                         for (restart in restarts) {
[10:21:43.979]                           name <- restart$name
[10:21:43.979]                           if (is.null(name)) 
[10:21:43.979]                             next
[10:21:43.979]                           if (!grepl(pattern, name)) 
[10:21:43.979]                             next
[10:21:43.979]                           invokeRestart(restart)
[10:21:43.979]                           muffled <- TRUE
[10:21:43.979]                           break
[10:21:43.979]                         }
[10:21:43.979]                       }
[10:21:43.979]                     }
[10:21:43.979]                     invisible(muffled)
[10:21:43.979]                   }
[10:21:43.979]                   muffleCondition(cond)
[10:21:43.979]                 })
[10:21:43.979]             }))
[10:21:43.979]             future::FutureResult(value = ...future.value$value, 
[10:21:43.979]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.979]                   ...future.rng), globalenv = if (FALSE) 
[10:21:43.979]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:43.979]                     ...future.globalenv.names))
[10:21:43.979]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:43.979]         }, condition = base::local({
[10:21:43.979]             c <- base::c
[10:21:43.979]             inherits <- base::inherits
[10:21:43.979]             invokeRestart <- base::invokeRestart
[10:21:43.979]             length <- base::length
[10:21:43.979]             list <- base::list
[10:21:43.979]             seq.int <- base::seq.int
[10:21:43.979]             signalCondition <- base::signalCondition
[10:21:43.979]             sys.calls <- base::sys.calls
[10:21:43.979]             `[[` <- base::`[[`
[10:21:43.979]             `+` <- base::`+`
[10:21:43.979]             `<<-` <- base::`<<-`
[10:21:43.979]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:43.979]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:43.979]                   3L)]
[10:21:43.979]             }
[10:21:43.979]             function(cond) {
[10:21:43.979]                 is_error <- inherits(cond, "error")
[10:21:43.979]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:43.979]                   NULL)
[10:21:43.979]                 if (is_error) {
[10:21:43.979]                   sessionInformation <- function() {
[10:21:43.979]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:43.979]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:43.979]                       search = base::search(), system = base::Sys.info())
[10:21:43.979]                   }
[10:21:43.979]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.979]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:43.979]                     cond$call), session = sessionInformation(), 
[10:21:43.979]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:43.979]                   signalCondition(cond)
[10:21:43.979]                 }
[10:21:43.979]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:43.979]                 "immediateCondition"))) {
[10:21:43.979]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:43.979]                   ...future.conditions[[length(...future.conditions) + 
[10:21:43.979]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:43.979]                   if (TRUE && !signal) {
[10:21:43.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.979]                     {
[10:21:43.979]                       inherits <- base::inherits
[10:21:43.979]                       invokeRestart <- base::invokeRestart
[10:21:43.979]                       is.null <- base::is.null
[10:21:43.979]                       muffled <- FALSE
[10:21:43.979]                       if (inherits(cond, "message")) {
[10:21:43.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.979]                         if (muffled) 
[10:21:43.979]                           invokeRestart("muffleMessage")
[10:21:43.979]                       }
[10:21:43.979]                       else if (inherits(cond, "warning")) {
[10:21:43.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.979]                         if (muffled) 
[10:21:43.979]                           invokeRestart("muffleWarning")
[10:21:43.979]                       }
[10:21:43.979]                       else if (inherits(cond, "condition")) {
[10:21:43.979]                         if (!is.null(pattern)) {
[10:21:43.979]                           computeRestarts <- base::computeRestarts
[10:21:43.979]                           grepl <- base::grepl
[10:21:43.979]                           restarts <- computeRestarts(cond)
[10:21:43.979]                           for (restart in restarts) {
[10:21:43.979]                             name <- restart$name
[10:21:43.979]                             if (is.null(name)) 
[10:21:43.979]                               next
[10:21:43.979]                             if (!grepl(pattern, name)) 
[10:21:43.979]                               next
[10:21:43.979]                             invokeRestart(restart)
[10:21:43.979]                             muffled <- TRUE
[10:21:43.979]                             break
[10:21:43.979]                           }
[10:21:43.979]                         }
[10:21:43.979]                       }
[10:21:43.979]                       invisible(muffled)
[10:21:43.979]                     }
[10:21:43.979]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.979]                   }
[10:21:43.979]                 }
[10:21:43.979]                 else {
[10:21:43.979]                   if (TRUE) {
[10:21:43.979]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:43.979]                     {
[10:21:43.979]                       inherits <- base::inherits
[10:21:43.979]                       invokeRestart <- base::invokeRestart
[10:21:43.979]                       is.null <- base::is.null
[10:21:43.979]                       muffled <- FALSE
[10:21:43.979]                       if (inherits(cond, "message")) {
[10:21:43.979]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:43.979]                         if (muffled) 
[10:21:43.979]                           invokeRestart("muffleMessage")
[10:21:43.979]                       }
[10:21:43.979]                       else if (inherits(cond, "warning")) {
[10:21:43.979]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:43.979]                         if (muffled) 
[10:21:43.979]                           invokeRestart("muffleWarning")
[10:21:43.979]                       }
[10:21:43.979]                       else if (inherits(cond, "condition")) {
[10:21:43.979]                         if (!is.null(pattern)) {
[10:21:43.979]                           computeRestarts <- base::computeRestarts
[10:21:43.979]                           grepl <- base::grepl
[10:21:43.979]                           restarts <- computeRestarts(cond)
[10:21:43.979]                           for (restart in restarts) {
[10:21:43.979]                             name <- restart$name
[10:21:43.979]                             if (is.null(name)) 
[10:21:43.979]                               next
[10:21:43.979]                             if (!grepl(pattern, name)) 
[10:21:43.979]                               next
[10:21:43.979]                             invokeRestart(restart)
[10:21:43.979]                             muffled <- TRUE
[10:21:43.979]                             break
[10:21:43.979]                           }
[10:21:43.979]                         }
[10:21:43.979]                       }
[10:21:43.979]                       invisible(muffled)
[10:21:43.979]                     }
[10:21:43.979]                     muffleCondition(cond, pattern = "^muffle")
[10:21:43.979]                   }
[10:21:43.979]                 }
[10:21:43.979]             }
[10:21:43.979]         }))
[10:21:43.979]     }, error = function(ex) {
[10:21:43.979]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:43.979]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:43.979]                 ...future.rng), started = ...future.startTime, 
[10:21:43.979]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:43.979]             version = "1.8"), class = "FutureResult")
[10:21:43.979]     }, finally = {
[10:21:43.979]         if (!identical(...future.workdir, getwd())) 
[10:21:43.979]             setwd(...future.workdir)
[10:21:43.979]         {
[10:21:43.979]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:43.979]                 ...future.oldOptions$nwarnings <- NULL
[10:21:43.979]             }
[10:21:43.979]             base::options(...future.oldOptions)
[10:21:43.979]             if (.Platform$OS.type == "windows") {
[10:21:43.979]                 old_names <- names(...future.oldEnvVars)
[10:21:43.979]                 envs <- base::Sys.getenv()
[10:21:43.979]                 names <- names(envs)
[10:21:43.979]                 common <- intersect(names, old_names)
[10:21:43.979]                 added <- setdiff(names, old_names)
[10:21:43.979]                 removed <- setdiff(old_names, names)
[10:21:43.979]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:43.979]                   envs[common]]
[10:21:43.979]                 NAMES <- toupper(changed)
[10:21:43.979]                 args <- list()
[10:21:43.979]                 for (kk in seq_along(NAMES)) {
[10:21:43.979]                   name <- changed[[kk]]
[10:21:43.979]                   NAME <- NAMES[[kk]]
[10:21:43.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.979]                     next
[10:21:43.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.979]                 }
[10:21:43.979]                 NAMES <- toupper(added)
[10:21:43.979]                 for (kk in seq_along(NAMES)) {
[10:21:43.979]                   name <- added[[kk]]
[10:21:43.979]                   NAME <- NAMES[[kk]]
[10:21:43.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.979]                     next
[10:21:43.979]                   args[[name]] <- ""
[10:21:43.979]                 }
[10:21:43.979]                 NAMES <- toupper(removed)
[10:21:43.979]                 for (kk in seq_along(NAMES)) {
[10:21:43.979]                   name <- removed[[kk]]
[10:21:43.979]                   NAME <- NAMES[[kk]]
[10:21:43.979]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:43.979]                     next
[10:21:43.979]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:43.979]                 }
[10:21:43.979]                 if (length(args) > 0) 
[10:21:43.979]                   base::do.call(base::Sys.setenv, args = args)
[10:21:43.979]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:43.979]             }
[10:21:43.979]             else {
[10:21:43.979]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:43.979]             }
[10:21:43.979]             {
[10:21:43.979]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:43.979]                   0L) {
[10:21:43.979]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:43.979]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:43.979]                   base::options(opts)
[10:21:43.979]                 }
[10:21:43.979]                 {
[10:21:43.979]                   {
[10:21:43.979]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:43.979]                     NULL
[10:21:43.979]                   }
[10:21:43.979]                   options(future.plan = NULL)
[10:21:43.979]                   if (is.na(NA_character_)) 
[10:21:43.979]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:43.979]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:43.979]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:43.979]                     .init = FALSE)
[10:21:43.979]                 }
[10:21:43.979]             }
[10:21:43.979]         }
[10:21:43.979]     })
[10:21:43.979]     if (TRUE) {
[10:21:43.979]         base::sink(type = "output", split = FALSE)
[10:21:43.979]         if (TRUE) {
[10:21:43.979]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:43.979]         }
[10:21:43.979]         else {
[10:21:43.979]             ...future.result["stdout"] <- base::list(NULL)
[10:21:43.979]         }
[10:21:43.979]         base::close(...future.stdout)
[10:21:43.979]         ...future.stdout <- NULL
[10:21:43.979]     }
[10:21:43.979]     ...future.result$conditions <- ...future.conditions
[10:21:43.979]     ...future.result$finished <- base::Sys.time()
[10:21:43.979]     ...future.result
[10:21:43.979] }
[10:21:43.982] assign_globals() ...
[10:21:43.982] List of 1
[10:21:43.982]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18ea70df0> 
[10:21:43.982]  - attr(*, "where")=List of 1
[10:21:43.982]   ..$ a:<environment: R_EmptyEnv> 
[10:21:43.982]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:43.982]  - attr(*, "resolved")= logi TRUE
[10:21:43.982]  - attr(*, "total_size")= num 3835
[10:21:43.982]  - attr(*, "already-done")= logi TRUE
[10:21:43.987] - copied ‘a’ to environment
[10:21:43.987] assign_globals() ... done
[10:21:43.988] requestCore(): workers = 2
[10:21:43.989] MulticoreFuture started
[10:21:43.990] - Launch lazy future ... done
[10:21:43.990] run() for ‘MulticoreFuture’ ... done
[10:21:43.991] result() for MulticoreFuture ...
[10:21:43.991] plan(): Setting new future strategy stack:
[10:21:43.991] List of future strategies:
[10:21:43.991] 1. sequential:
[10:21:43.991]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:43.991]    - tweaked: FALSE
[10:21:43.991]    - call: NULL
[10:21:43.992] plan(): nbrOfWorkers() = 1
[10:21:43.996] plan(): Setting new future strategy stack:
[10:21:43.996] List of future strategies:
[10:21:43.996] 1. multicore:
[10:21:43.996]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:43.996]    - tweaked: FALSE
[10:21:43.996]    - call: plan(strategy)
[10:21:44.000] plan(): nbrOfWorkers() = 2
[10:21:44.001] result() for MulticoreFuture ...
[10:21:44.001] result() for MulticoreFuture ... done
[10:21:44.001] signalConditions() ...
[10:21:44.001]  - include = ‘immediateCondition’
[10:21:44.001]  - exclude = 
[10:21:44.001]  - resignal = FALSE
[10:21:44.001]  - Number of conditions: 4
[10:21:44.002] signalConditions() ... done
[10:21:44.002] result() for MulticoreFuture ... done
[10:21:44.002] result() for MulticoreFuture ...
[10:21:44.002] result() for MulticoreFuture ... done
[10:21:44.002] signalConditions() ...
[10:21:44.002]  - include = ‘immediateCondition’
[10:21:44.003]  - exclude = 
[10:21:44.003]  - resignal = FALSE
[10:21:44.003]  - Number of conditions: 4
[10:21:44.003] signalConditions() ... done
[10:21:44.003] Future state: ‘finished’
[10:21:44.003] result() for MulticoreFuture ...
[10:21:44.003] result() for MulticoreFuture ... done
[10:21:44.003] signalConditions() ...
[10:21:44.004]  - include = ‘condition’
[10:21:44.004]  - exclude = ‘immediateCondition’
[10:21:44.004]  - resignal = TRUE
[10:21:44.004]  - Number of conditions: 4
[10:21:44.004]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.994] result() for MulticoreFuture ...
[10:21:44.004]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.994] result() for MulticoreFuture ... done
[10:21:44.004]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.995] result() for MulticoreFuture ...
[10:21:44.005]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.995] result() for MulticoreFuture ... done
[10:21:44.005] signalConditions() ... done
value(b) = 2
[10:21:44.005] result() for MulticoreFuture ...
[10:21:44.005] result() for MulticoreFuture ... done
[10:21:44.005] result() for MulticoreFuture ...
[10:21:44.005] result() for MulticoreFuture ... done
[10:21:44.005] signalConditions() ...
[10:21:44.006]  - include = ‘immediateCondition’
[10:21:44.006]  - exclude = 
[10:21:44.006]  - resignal = FALSE
[10:21:44.006]  - Number of conditions: 4
[10:21:44.006] signalConditions() ... done
[10:21:44.006] Future state: ‘finished’
[10:21:44.006] result() for MulticoreFuture ...
[10:21:44.006] result() for MulticoreFuture ... done
[10:21:44.006] signalConditions() ...
[10:21:44.007]  - include = ‘condition’
[10:21:44.007]  - exclude = ‘immediateCondition’
[10:21:44.007]  - resignal = TRUE
[10:21:44.007]  - Number of conditions: 4
[10:21:44.007]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.994] result() for MulticoreFuture ...
[10:21:44.007]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.994] result() for MulticoreFuture ... done
[10:21:44.007]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.995] result() for MulticoreFuture ...
[10:21:44.007]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:43.995] result() for MulticoreFuture ... done
[10:21:44.008] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.008] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.008] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:44.009] 
[10:21:44.009] Searching for globals ... DONE
[10:21:44.009] - globals: [0] <none>
[10:21:44.009] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.010] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.010] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:44.011] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:44.011] Searching for globals ... DONE
[10:21:44.011] Resolving globals: TRUE
[10:21:44.011] Resolving any globals that are futures ...
[10:21:44.012] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:44.012] Resolving any globals that are futures ... DONE
[10:21:44.012] Resolving futures part of globals (recursively) ...
[10:21:44.012] resolve() on list ...
[10:21:44.013]  recursive: 99
[10:21:44.013]  length: 1
[10:21:44.013]  elements: ‘a’
[10:21:44.013] run() for ‘Future’ ...
[10:21:44.013] - state: ‘created’
[10:21:44.013] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.015] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.015] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.016]   - Field: ‘label’
[10:21:44.016]   - Field: ‘local’
[10:21:44.016]   - Field: ‘owner’
[10:21:44.016]   - Field: ‘envir’
[10:21:44.016]   - Field: ‘workers’
[10:21:44.016]   - Field: ‘packages’
[10:21:44.016]   - Field: ‘gc’
[10:21:44.016]   - Field: ‘job’
[10:21:44.016]   - Field: ‘conditions’
[10:21:44.017]   - Field: ‘expr’
[10:21:44.017]   - Field: ‘uuid’
[10:21:44.017]   - Field: ‘seed’
[10:21:44.017]   - Field: ‘version’
[10:21:44.017]   - Field: ‘result’
[10:21:44.017]   - Field: ‘asynchronous’
[10:21:44.017]   - Field: ‘calls’
[10:21:44.017]   - Field: ‘globals’
[10:21:44.017]   - Field: ‘stdout’
[10:21:44.017]   - Field: ‘earlySignal’
[10:21:44.018]   - Field: ‘lazy’
[10:21:44.018]   - Field: ‘state’
[10:21:44.018] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.018] - Launch lazy future ...
[10:21:44.018] Packages needed by the future expression (n = 0): <none>
[10:21:44.018] Packages needed by future strategies (n = 0): <none>
[10:21:44.019] {
[10:21:44.019]     {
[10:21:44.019]         {
[10:21:44.019]             ...future.startTime <- base::Sys.time()
[10:21:44.019]             {
[10:21:44.019]                 {
[10:21:44.019]                   {
[10:21:44.019]                     {
[10:21:44.019]                       base::local({
[10:21:44.019]                         has_future <- base::requireNamespace("future", 
[10:21:44.019]                           quietly = TRUE)
[10:21:44.019]                         if (has_future) {
[10:21:44.019]                           ns <- base::getNamespace("future")
[10:21:44.019]                           version <- ns[[".package"]][["version"]]
[10:21:44.019]                           if (is.null(version)) 
[10:21:44.019]                             version <- utils::packageVersion("future")
[10:21:44.019]                         }
[10:21:44.019]                         else {
[10:21:44.019]                           version <- NULL
[10:21:44.019]                         }
[10:21:44.019]                         if (!has_future || version < "1.8.0") {
[10:21:44.019]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.019]                             "", base::R.version$version.string), 
[10:21:44.019]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.019]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.019]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.019]                               "release", "version")], collapse = " "), 
[10:21:44.019]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.019]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.019]                             info)
[10:21:44.019]                           info <- base::paste(info, collapse = "; ")
[10:21:44.019]                           if (!has_future) {
[10:21:44.019]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.019]                               info)
[10:21:44.019]                           }
[10:21:44.019]                           else {
[10:21:44.019]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.019]                               info, version)
[10:21:44.019]                           }
[10:21:44.019]                           base::stop(msg)
[10:21:44.019]                         }
[10:21:44.019]                       })
[10:21:44.019]                     }
[10:21:44.019]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.019]                     base::options(mc.cores = 1L)
[10:21:44.019]                   }
[10:21:44.019]                   ...future.strategy.old <- future::plan("list")
[10:21:44.019]                   options(future.plan = NULL)
[10:21:44.019]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.019]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.019]                 }
[10:21:44.019]                 ...future.workdir <- getwd()
[10:21:44.019]             }
[10:21:44.019]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.019]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.019]         }
[10:21:44.019]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.019]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:44.019]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.019]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.019]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.019]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.019]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.019]             base::names(...future.oldOptions))
[10:21:44.019]     }
[10:21:44.019]     if (FALSE) {
[10:21:44.019]     }
[10:21:44.019]     else {
[10:21:44.019]         if (TRUE) {
[10:21:44.019]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.019]                 open = "w")
[10:21:44.019]         }
[10:21:44.019]         else {
[10:21:44.019]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.019]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.019]         }
[10:21:44.019]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.019]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.019]             base::sink(type = "output", split = FALSE)
[10:21:44.019]             base::close(...future.stdout)
[10:21:44.019]         }, add = TRUE)
[10:21:44.019]     }
[10:21:44.019]     ...future.frame <- base::sys.nframe()
[10:21:44.019]     ...future.conditions <- base::list()
[10:21:44.019]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.019]     if (FALSE) {
[10:21:44.019]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.019]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.019]     }
[10:21:44.019]     ...future.result <- base::tryCatch({
[10:21:44.019]         base::withCallingHandlers({
[10:21:44.019]             ...future.value <- base::withVisible(base::local({
[10:21:44.019]                 withCallingHandlers({
[10:21:44.019]                   1
[10:21:44.019]                 }, immediateCondition = function(cond) {
[10:21:44.019]                   save_rds <- function (object, pathname, ...) 
[10:21:44.019]                   {
[10:21:44.019]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.019]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.019]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.019]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.019]                         fi_tmp[["mtime"]])
[10:21:44.019]                     }
[10:21:44.019]                     tryCatch({
[10:21:44.019]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.019]                     }, error = function(ex) {
[10:21:44.019]                       msg <- conditionMessage(ex)
[10:21:44.019]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.019]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.019]                         fi_tmp[["mtime"]], msg)
[10:21:44.019]                       ex$message <- msg
[10:21:44.019]                       stop(ex)
[10:21:44.019]                     })
[10:21:44.019]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.019]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.019]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.019]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.019]                       fi <- file.info(pathname)
[10:21:44.019]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.019]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.019]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.019]                         fi[["size"]], fi[["mtime"]])
[10:21:44.019]                       stop(msg)
[10:21:44.019]                     }
[10:21:44.019]                     invisible(pathname)
[10:21:44.019]                   }
[10:21:44.019]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.019]                     rootPath = tempdir()) 
[10:21:44.019]                   {
[10:21:44.019]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.019]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.019]                       tmpdir = path, fileext = ".rds")
[10:21:44.019]                     save_rds(obj, file)
[10:21:44.019]                   }
[10:21:44.019]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.019]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.019]                   {
[10:21:44.019]                     inherits <- base::inherits
[10:21:44.019]                     invokeRestart <- base::invokeRestart
[10:21:44.019]                     is.null <- base::is.null
[10:21:44.019]                     muffled <- FALSE
[10:21:44.019]                     if (inherits(cond, "message")) {
[10:21:44.019]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.019]                       if (muffled) 
[10:21:44.019]                         invokeRestart("muffleMessage")
[10:21:44.019]                     }
[10:21:44.019]                     else if (inherits(cond, "warning")) {
[10:21:44.019]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.019]                       if (muffled) 
[10:21:44.019]                         invokeRestart("muffleWarning")
[10:21:44.019]                     }
[10:21:44.019]                     else if (inherits(cond, "condition")) {
[10:21:44.019]                       if (!is.null(pattern)) {
[10:21:44.019]                         computeRestarts <- base::computeRestarts
[10:21:44.019]                         grepl <- base::grepl
[10:21:44.019]                         restarts <- computeRestarts(cond)
[10:21:44.019]                         for (restart in restarts) {
[10:21:44.019]                           name <- restart$name
[10:21:44.019]                           if (is.null(name)) 
[10:21:44.019]                             next
[10:21:44.019]                           if (!grepl(pattern, name)) 
[10:21:44.019]                             next
[10:21:44.019]                           invokeRestart(restart)
[10:21:44.019]                           muffled <- TRUE
[10:21:44.019]                           break
[10:21:44.019]                         }
[10:21:44.019]                       }
[10:21:44.019]                     }
[10:21:44.019]                     invisible(muffled)
[10:21:44.019]                   }
[10:21:44.019]                   muffleCondition(cond)
[10:21:44.019]                 })
[10:21:44.019]             }))
[10:21:44.019]             future::FutureResult(value = ...future.value$value, 
[10:21:44.019]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.019]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.019]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.019]                     ...future.globalenv.names))
[10:21:44.019]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.019]         }, condition = base::local({
[10:21:44.019]             c <- base::c
[10:21:44.019]             inherits <- base::inherits
[10:21:44.019]             invokeRestart <- base::invokeRestart
[10:21:44.019]             length <- base::length
[10:21:44.019]             list <- base::list
[10:21:44.019]             seq.int <- base::seq.int
[10:21:44.019]             signalCondition <- base::signalCondition
[10:21:44.019]             sys.calls <- base::sys.calls
[10:21:44.019]             `[[` <- base::`[[`
[10:21:44.019]             `+` <- base::`+`
[10:21:44.019]             `<<-` <- base::`<<-`
[10:21:44.019]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.019]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.019]                   3L)]
[10:21:44.019]             }
[10:21:44.019]             function(cond) {
[10:21:44.019]                 is_error <- inherits(cond, "error")
[10:21:44.019]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.019]                   NULL)
[10:21:44.019]                 if (is_error) {
[10:21:44.019]                   sessionInformation <- function() {
[10:21:44.019]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.019]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.019]                       search = base::search(), system = base::Sys.info())
[10:21:44.019]                   }
[10:21:44.019]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.019]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.019]                     cond$call), session = sessionInformation(), 
[10:21:44.019]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.019]                   signalCondition(cond)
[10:21:44.019]                 }
[10:21:44.019]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.019]                 "immediateCondition"))) {
[10:21:44.019]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.019]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.019]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.019]                   if (TRUE && !signal) {
[10:21:44.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.019]                     {
[10:21:44.019]                       inherits <- base::inherits
[10:21:44.019]                       invokeRestart <- base::invokeRestart
[10:21:44.019]                       is.null <- base::is.null
[10:21:44.019]                       muffled <- FALSE
[10:21:44.019]                       if (inherits(cond, "message")) {
[10:21:44.019]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.019]                         if (muffled) 
[10:21:44.019]                           invokeRestart("muffleMessage")
[10:21:44.019]                       }
[10:21:44.019]                       else if (inherits(cond, "warning")) {
[10:21:44.019]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.019]                         if (muffled) 
[10:21:44.019]                           invokeRestart("muffleWarning")
[10:21:44.019]                       }
[10:21:44.019]                       else if (inherits(cond, "condition")) {
[10:21:44.019]                         if (!is.null(pattern)) {
[10:21:44.019]                           computeRestarts <- base::computeRestarts
[10:21:44.019]                           grepl <- base::grepl
[10:21:44.019]                           restarts <- computeRestarts(cond)
[10:21:44.019]                           for (restart in restarts) {
[10:21:44.019]                             name <- restart$name
[10:21:44.019]                             if (is.null(name)) 
[10:21:44.019]                               next
[10:21:44.019]                             if (!grepl(pattern, name)) 
[10:21:44.019]                               next
[10:21:44.019]                             invokeRestart(restart)
[10:21:44.019]                             muffled <- TRUE
[10:21:44.019]                             break
[10:21:44.019]                           }
[10:21:44.019]                         }
[10:21:44.019]                       }
[10:21:44.019]                       invisible(muffled)
[10:21:44.019]                     }
[10:21:44.019]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.019]                   }
[10:21:44.019]                 }
[10:21:44.019]                 else {
[10:21:44.019]                   if (TRUE) {
[10:21:44.019]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.019]                     {
[10:21:44.019]                       inherits <- base::inherits
[10:21:44.019]                       invokeRestart <- base::invokeRestart
[10:21:44.019]                       is.null <- base::is.null
[10:21:44.019]                       muffled <- FALSE
[10:21:44.019]                       if (inherits(cond, "message")) {
[10:21:44.019]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.019]                         if (muffled) 
[10:21:44.019]                           invokeRestart("muffleMessage")
[10:21:44.019]                       }
[10:21:44.019]                       else if (inherits(cond, "warning")) {
[10:21:44.019]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.019]                         if (muffled) 
[10:21:44.019]                           invokeRestart("muffleWarning")
[10:21:44.019]                       }
[10:21:44.019]                       else if (inherits(cond, "condition")) {
[10:21:44.019]                         if (!is.null(pattern)) {
[10:21:44.019]                           computeRestarts <- base::computeRestarts
[10:21:44.019]                           grepl <- base::grepl
[10:21:44.019]                           restarts <- computeRestarts(cond)
[10:21:44.019]                           for (restart in restarts) {
[10:21:44.019]                             name <- restart$name
[10:21:44.019]                             if (is.null(name)) 
[10:21:44.019]                               next
[10:21:44.019]                             if (!grepl(pattern, name)) 
[10:21:44.019]                               next
[10:21:44.019]                             invokeRestart(restart)
[10:21:44.019]                             muffled <- TRUE
[10:21:44.019]                             break
[10:21:44.019]                           }
[10:21:44.019]                         }
[10:21:44.019]                       }
[10:21:44.019]                       invisible(muffled)
[10:21:44.019]                     }
[10:21:44.019]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.019]                   }
[10:21:44.019]                 }
[10:21:44.019]             }
[10:21:44.019]         }))
[10:21:44.019]     }, error = function(ex) {
[10:21:44.019]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.019]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.019]                 ...future.rng), started = ...future.startTime, 
[10:21:44.019]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.019]             version = "1.8"), class = "FutureResult")
[10:21:44.019]     }, finally = {
[10:21:44.019]         if (!identical(...future.workdir, getwd())) 
[10:21:44.019]             setwd(...future.workdir)
[10:21:44.019]         {
[10:21:44.019]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.019]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.019]             }
[10:21:44.019]             base::options(...future.oldOptions)
[10:21:44.019]             if (.Platform$OS.type == "windows") {
[10:21:44.019]                 old_names <- names(...future.oldEnvVars)
[10:21:44.019]                 envs <- base::Sys.getenv()
[10:21:44.019]                 names <- names(envs)
[10:21:44.019]                 common <- intersect(names, old_names)
[10:21:44.019]                 added <- setdiff(names, old_names)
[10:21:44.019]                 removed <- setdiff(old_names, names)
[10:21:44.019]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.019]                   envs[common]]
[10:21:44.019]                 NAMES <- toupper(changed)
[10:21:44.019]                 args <- list()
[10:21:44.019]                 for (kk in seq_along(NAMES)) {
[10:21:44.019]                   name <- changed[[kk]]
[10:21:44.019]                   NAME <- NAMES[[kk]]
[10:21:44.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.019]                     next
[10:21:44.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.019]                 }
[10:21:44.019]                 NAMES <- toupper(added)
[10:21:44.019]                 for (kk in seq_along(NAMES)) {
[10:21:44.019]                   name <- added[[kk]]
[10:21:44.019]                   NAME <- NAMES[[kk]]
[10:21:44.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.019]                     next
[10:21:44.019]                   args[[name]] <- ""
[10:21:44.019]                 }
[10:21:44.019]                 NAMES <- toupper(removed)
[10:21:44.019]                 for (kk in seq_along(NAMES)) {
[10:21:44.019]                   name <- removed[[kk]]
[10:21:44.019]                   NAME <- NAMES[[kk]]
[10:21:44.019]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.019]                     next
[10:21:44.019]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.019]                 }
[10:21:44.019]                 if (length(args) > 0) 
[10:21:44.019]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.019]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.019]             }
[10:21:44.019]             else {
[10:21:44.019]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.019]             }
[10:21:44.019]             {
[10:21:44.019]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.019]                   0L) {
[10:21:44.019]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.019]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.019]                   base::options(opts)
[10:21:44.019]                 }
[10:21:44.019]                 {
[10:21:44.019]                   {
[10:21:44.019]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.019]                     NULL
[10:21:44.019]                   }
[10:21:44.019]                   options(future.plan = NULL)
[10:21:44.019]                   if (is.na(NA_character_)) 
[10:21:44.019]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.019]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.019]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.019]                     .init = FALSE)
[10:21:44.019]                 }
[10:21:44.019]             }
[10:21:44.019]         }
[10:21:44.019]     })
[10:21:44.019]     if (TRUE) {
[10:21:44.019]         base::sink(type = "output", split = FALSE)
[10:21:44.019]         if (TRUE) {
[10:21:44.019]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.019]         }
[10:21:44.019]         else {
[10:21:44.019]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.019]         }
[10:21:44.019]         base::close(...future.stdout)
[10:21:44.019]         ...future.stdout <- NULL
[10:21:44.019]     }
[10:21:44.019]     ...future.result$conditions <- ...future.conditions
[10:21:44.019]     ...future.result$finished <- base::Sys.time()
[10:21:44.019]     ...future.result
[10:21:44.019] }
[10:21:44.022] requestCore(): workers = 2
[10:21:44.023] MulticoreFuture started
[10:21:44.024] - Launch lazy future ... done
[10:21:44.024] run() for ‘MulticoreFuture’ ... done
[10:21:44.024] plan(): Setting new future strategy stack:
[10:21:44.024] List of future strategies:
[10:21:44.024] 1. sequential:
[10:21:44.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.024]    - tweaked: FALSE
[10:21:44.024]    - call: NULL
[10:21:44.025] plan(): nbrOfWorkers() = 1
[10:21:44.028] plan(): Setting new future strategy stack:
[10:21:44.032] List of future strategies:
[10:21:44.032] 1. multicore:
[10:21:44.032]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.032]    - tweaked: FALSE
[10:21:44.032]    - call: plan(strategy)
[10:21:44.036] plan(): nbrOfWorkers() = 2
[10:21:44.045] Future #1
[10:21:44.045] result() for MulticoreFuture ...
[10:21:44.046] result() for MulticoreFuture ...
[10:21:44.046] result() for MulticoreFuture ... done
[10:21:44.046] result() for MulticoreFuture ... done
[10:21:44.046] result() for MulticoreFuture ...
[10:21:44.047] result() for MulticoreFuture ... done
[10:21:44.049] A MulticoreFuture was resolved
[10:21:44.050]  length: 0 (resolved future 1)
[10:21:44.050] resolve() on list ... DONE
[10:21:44.050] - globals: [1] ‘a’
[10:21:44.050] Resolving futures part of globals (recursively) ... DONE
[10:21:44.050] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[10:21:44.051] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[10:21:44.051] - globals: [1] ‘a’
[10:21:44.051] - packages: [1] ‘future’
[10:21:44.051] getGlobalsAndPackages() ... DONE
[10:21:44.052] run() for ‘Future’ ...
[10:21:44.052] - state: ‘created’
[10:21:44.052] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.054] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.055] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.055]   - Field: ‘label’
[10:21:44.055]   - Field: ‘local’
[10:21:44.055]   - Field: ‘owner’
[10:21:44.055]   - Field: ‘envir’
[10:21:44.055]   - Field: ‘workers’
[10:21:44.055]   - Field: ‘packages’
[10:21:44.055]   - Field: ‘gc’
[10:21:44.056]   - Field: ‘job’
[10:21:44.056]   - Field: ‘conditions’
[10:21:44.056]   - Field: ‘expr’
[10:21:44.056]   - Field: ‘uuid’
[10:21:44.056]   - Field: ‘seed’
[10:21:44.056]   - Field: ‘version’
[10:21:44.056]   - Field: ‘result’
[10:21:44.056]   - Field: ‘asynchronous’
[10:21:44.057]   - Field: ‘calls’
[10:21:44.057]   - Field: ‘globals’
[10:21:44.057]   - Field: ‘stdout’
[10:21:44.057]   - Field: ‘earlySignal’
[10:21:44.057]   - Field: ‘lazy’
[10:21:44.057]   - Field: ‘state’
[10:21:44.057] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.057] - Launch lazy future ...
[10:21:44.058] Packages needed by the future expression (n = 1): ‘future’
[10:21:44.058] Packages needed by future strategies (n = 0): <none>
[10:21:44.058] {
[10:21:44.058]     {
[10:21:44.058]         {
[10:21:44.058]             ...future.startTime <- base::Sys.time()
[10:21:44.058]             {
[10:21:44.058]                 {
[10:21:44.058]                   {
[10:21:44.058]                     {
[10:21:44.058]                       {
[10:21:44.058]                         base::local({
[10:21:44.058]                           has_future <- base::requireNamespace("future", 
[10:21:44.058]                             quietly = TRUE)
[10:21:44.058]                           if (has_future) {
[10:21:44.058]                             ns <- base::getNamespace("future")
[10:21:44.058]                             version <- ns[[".package"]][["version"]]
[10:21:44.058]                             if (is.null(version)) 
[10:21:44.058]                               version <- utils::packageVersion("future")
[10:21:44.058]                           }
[10:21:44.058]                           else {
[10:21:44.058]                             version <- NULL
[10:21:44.058]                           }
[10:21:44.058]                           if (!has_future || version < "1.8.0") {
[10:21:44.058]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.058]                               "", base::R.version$version.string), 
[10:21:44.058]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:44.058]                                 base::R.version$platform, 8 * 
[10:21:44.058]                                   base::.Machine$sizeof.pointer), 
[10:21:44.058]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.058]                                 "release", "version")], collapse = " "), 
[10:21:44.058]                               hostname = base::Sys.info()[["nodename"]])
[10:21:44.058]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.058]                               info)
[10:21:44.058]                             info <- base::paste(info, collapse = "; ")
[10:21:44.058]                             if (!has_future) {
[10:21:44.058]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.058]                                 info)
[10:21:44.058]                             }
[10:21:44.058]                             else {
[10:21:44.058]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.058]                                 info, version)
[10:21:44.058]                             }
[10:21:44.058]                             base::stop(msg)
[10:21:44.058]                           }
[10:21:44.058]                         })
[10:21:44.058]                       }
[10:21:44.058]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.058]                       base::options(mc.cores = 1L)
[10:21:44.058]                     }
[10:21:44.058]                     base::local({
[10:21:44.058]                       for (pkg in "future") {
[10:21:44.058]                         base::loadNamespace(pkg)
[10:21:44.058]                         base::library(pkg, character.only = TRUE)
[10:21:44.058]                       }
[10:21:44.058]                     })
[10:21:44.058]                   }
[10:21:44.058]                   ...future.strategy.old <- future::plan("list")
[10:21:44.058]                   options(future.plan = NULL)
[10:21:44.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.058]                 }
[10:21:44.058]                 ...future.workdir <- getwd()
[10:21:44.058]             }
[10:21:44.058]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.058]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.058]         }
[10:21:44.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.058]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:44.058]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.058]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.058]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.058]             base::names(...future.oldOptions))
[10:21:44.058]     }
[10:21:44.058]     if (FALSE) {
[10:21:44.058]     }
[10:21:44.058]     else {
[10:21:44.058]         if (TRUE) {
[10:21:44.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.058]                 open = "w")
[10:21:44.058]         }
[10:21:44.058]         else {
[10:21:44.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.058]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.058]         }
[10:21:44.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.058]             base::sink(type = "output", split = FALSE)
[10:21:44.058]             base::close(...future.stdout)
[10:21:44.058]         }, add = TRUE)
[10:21:44.058]     }
[10:21:44.058]     ...future.frame <- base::sys.nframe()
[10:21:44.058]     ...future.conditions <- base::list()
[10:21:44.058]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.058]     if (FALSE) {
[10:21:44.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.058]     }
[10:21:44.058]     ...future.result <- base::tryCatch({
[10:21:44.058]         base::withCallingHandlers({
[10:21:44.058]             ...future.value <- base::withVisible(base::local({
[10:21:44.058]                 withCallingHandlers({
[10:21:44.058]                   value(a) + 1
[10:21:44.058]                 }, immediateCondition = function(cond) {
[10:21:44.058]                   save_rds <- function (object, pathname, ...) 
[10:21:44.058]                   {
[10:21:44.058]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.058]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.058]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.058]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.058]                         fi_tmp[["mtime"]])
[10:21:44.058]                     }
[10:21:44.058]                     tryCatch({
[10:21:44.058]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.058]                     }, error = function(ex) {
[10:21:44.058]                       msg <- conditionMessage(ex)
[10:21:44.058]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.058]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.058]                         fi_tmp[["mtime"]], msg)
[10:21:44.058]                       ex$message <- msg
[10:21:44.058]                       stop(ex)
[10:21:44.058]                     })
[10:21:44.058]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.058]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.058]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.058]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.058]                       fi <- file.info(pathname)
[10:21:44.058]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.058]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.058]                         fi[["size"]], fi[["mtime"]])
[10:21:44.058]                       stop(msg)
[10:21:44.058]                     }
[10:21:44.058]                     invisible(pathname)
[10:21:44.058]                   }
[10:21:44.058]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.058]                     rootPath = tempdir()) 
[10:21:44.058]                   {
[10:21:44.058]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.058]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.058]                       tmpdir = path, fileext = ".rds")
[10:21:44.058]                     save_rds(obj, file)
[10:21:44.058]                   }
[10:21:44.058]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.058]                   {
[10:21:44.058]                     inherits <- base::inherits
[10:21:44.058]                     invokeRestart <- base::invokeRestart
[10:21:44.058]                     is.null <- base::is.null
[10:21:44.058]                     muffled <- FALSE
[10:21:44.058]                     if (inherits(cond, "message")) {
[10:21:44.058]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.058]                       if (muffled) 
[10:21:44.058]                         invokeRestart("muffleMessage")
[10:21:44.058]                     }
[10:21:44.058]                     else if (inherits(cond, "warning")) {
[10:21:44.058]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.058]                       if (muffled) 
[10:21:44.058]                         invokeRestart("muffleWarning")
[10:21:44.058]                     }
[10:21:44.058]                     else if (inherits(cond, "condition")) {
[10:21:44.058]                       if (!is.null(pattern)) {
[10:21:44.058]                         computeRestarts <- base::computeRestarts
[10:21:44.058]                         grepl <- base::grepl
[10:21:44.058]                         restarts <- computeRestarts(cond)
[10:21:44.058]                         for (restart in restarts) {
[10:21:44.058]                           name <- restart$name
[10:21:44.058]                           if (is.null(name)) 
[10:21:44.058]                             next
[10:21:44.058]                           if (!grepl(pattern, name)) 
[10:21:44.058]                             next
[10:21:44.058]                           invokeRestart(restart)
[10:21:44.058]                           muffled <- TRUE
[10:21:44.058]                           break
[10:21:44.058]                         }
[10:21:44.058]                       }
[10:21:44.058]                     }
[10:21:44.058]                     invisible(muffled)
[10:21:44.058]                   }
[10:21:44.058]                   muffleCondition(cond)
[10:21:44.058]                 })
[10:21:44.058]             }))
[10:21:44.058]             future::FutureResult(value = ...future.value$value, 
[10:21:44.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.058]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.058]                     ...future.globalenv.names))
[10:21:44.058]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.058]         }, condition = base::local({
[10:21:44.058]             c <- base::c
[10:21:44.058]             inherits <- base::inherits
[10:21:44.058]             invokeRestart <- base::invokeRestart
[10:21:44.058]             length <- base::length
[10:21:44.058]             list <- base::list
[10:21:44.058]             seq.int <- base::seq.int
[10:21:44.058]             signalCondition <- base::signalCondition
[10:21:44.058]             sys.calls <- base::sys.calls
[10:21:44.058]             `[[` <- base::`[[`
[10:21:44.058]             `+` <- base::`+`
[10:21:44.058]             `<<-` <- base::`<<-`
[10:21:44.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.058]                   3L)]
[10:21:44.058]             }
[10:21:44.058]             function(cond) {
[10:21:44.058]                 is_error <- inherits(cond, "error")
[10:21:44.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.058]                   NULL)
[10:21:44.058]                 if (is_error) {
[10:21:44.058]                   sessionInformation <- function() {
[10:21:44.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.058]                       search = base::search(), system = base::Sys.info())
[10:21:44.058]                   }
[10:21:44.058]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.058]                     cond$call), session = sessionInformation(), 
[10:21:44.058]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.058]                   signalCondition(cond)
[10:21:44.058]                 }
[10:21:44.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.058]                 "immediateCondition"))) {
[10:21:44.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.058]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.058]                   if (TRUE && !signal) {
[10:21:44.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.058]                     {
[10:21:44.058]                       inherits <- base::inherits
[10:21:44.058]                       invokeRestart <- base::invokeRestart
[10:21:44.058]                       is.null <- base::is.null
[10:21:44.058]                       muffled <- FALSE
[10:21:44.058]                       if (inherits(cond, "message")) {
[10:21:44.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.058]                         if (muffled) 
[10:21:44.058]                           invokeRestart("muffleMessage")
[10:21:44.058]                       }
[10:21:44.058]                       else if (inherits(cond, "warning")) {
[10:21:44.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.058]                         if (muffled) 
[10:21:44.058]                           invokeRestart("muffleWarning")
[10:21:44.058]                       }
[10:21:44.058]                       else if (inherits(cond, "condition")) {
[10:21:44.058]                         if (!is.null(pattern)) {
[10:21:44.058]                           computeRestarts <- base::computeRestarts
[10:21:44.058]                           grepl <- base::grepl
[10:21:44.058]                           restarts <- computeRestarts(cond)
[10:21:44.058]                           for (restart in restarts) {
[10:21:44.058]                             name <- restart$name
[10:21:44.058]                             if (is.null(name)) 
[10:21:44.058]                               next
[10:21:44.058]                             if (!grepl(pattern, name)) 
[10:21:44.058]                               next
[10:21:44.058]                             invokeRestart(restart)
[10:21:44.058]                             muffled <- TRUE
[10:21:44.058]                             break
[10:21:44.058]                           }
[10:21:44.058]                         }
[10:21:44.058]                       }
[10:21:44.058]                       invisible(muffled)
[10:21:44.058]                     }
[10:21:44.058]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.058]                   }
[10:21:44.058]                 }
[10:21:44.058]                 else {
[10:21:44.058]                   if (TRUE) {
[10:21:44.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.058]                     {
[10:21:44.058]                       inherits <- base::inherits
[10:21:44.058]                       invokeRestart <- base::invokeRestart
[10:21:44.058]                       is.null <- base::is.null
[10:21:44.058]                       muffled <- FALSE
[10:21:44.058]                       if (inherits(cond, "message")) {
[10:21:44.058]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.058]                         if (muffled) 
[10:21:44.058]                           invokeRestart("muffleMessage")
[10:21:44.058]                       }
[10:21:44.058]                       else if (inherits(cond, "warning")) {
[10:21:44.058]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.058]                         if (muffled) 
[10:21:44.058]                           invokeRestart("muffleWarning")
[10:21:44.058]                       }
[10:21:44.058]                       else if (inherits(cond, "condition")) {
[10:21:44.058]                         if (!is.null(pattern)) {
[10:21:44.058]                           computeRestarts <- base::computeRestarts
[10:21:44.058]                           grepl <- base::grepl
[10:21:44.058]                           restarts <- computeRestarts(cond)
[10:21:44.058]                           for (restart in restarts) {
[10:21:44.058]                             name <- restart$name
[10:21:44.058]                             if (is.null(name)) 
[10:21:44.058]                               next
[10:21:44.058]                             if (!grepl(pattern, name)) 
[10:21:44.058]                               next
[10:21:44.058]                             invokeRestart(restart)
[10:21:44.058]                             muffled <- TRUE
[10:21:44.058]                             break
[10:21:44.058]                           }
[10:21:44.058]                         }
[10:21:44.058]                       }
[10:21:44.058]                       invisible(muffled)
[10:21:44.058]                     }
[10:21:44.058]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.058]                   }
[10:21:44.058]                 }
[10:21:44.058]             }
[10:21:44.058]         }))
[10:21:44.058]     }, error = function(ex) {
[10:21:44.058]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.058]                 ...future.rng), started = ...future.startTime, 
[10:21:44.058]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.058]             version = "1.8"), class = "FutureResult")
[10:21:44.058]     }, finally = {
[10:21:44.058]         if (!identical(...future.workdir, getwd())) 
[10:21:44.058]             setwd(...future.workdir)
[10:21:44.058]         {
[10:21:44.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.058]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.058]             }
[10:21:44.058]             base::options(...future.oldOptions)
[10:21:44.058]             if (.Platform$OS.type == "windows") {
[10:21:44.058]                 old_names <- names(...future.oldEnvVars)
[10:21:44.058]                 envs <- base::Sys.getenv()
[10:21:44.058]                 names <- names(envs)
[10:21:44.058]                 common <- intersect(names, old_names)
[10:21:44.058]                 added <- setdiff(names, old_names)
[10:21:44.058]                 removed <- setdiff(old_names, names)
[10:21:44.058]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.058]                   envs[common]]
[10:21:44.058]                 NAMES <- toupper(changed)
[10:21:44.058]                 args <- list()
[10:21:44.058]                 for (kk in seq_along(NAMES)) {
[10:21:44.058]                   name <- changed[[kk]]
[10:21:44.058]                   NAME <- NAMES[[kk]]
[10:21:44.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.058]                     next
[10:21:44.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.058]                 }
[10:21:44.058]                 NAMES <- toupper(added)
[10:21:44.058]                 for (kk in seq_along(NAMES)) {
[10:21:44.058]                   name <- added[[kk]]
[10:21:44.058]                   NAME <- NAMES[[kk]]
[10:21:44.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.058]                     next
[10:21:44.058]                   args[[name]] <- ""
[10:21:44.058]                 }
[10:21:44.058]                 NAMES <- toupper(removed)
[10:21:44.058]                 for (kk in seq_along(NAMES)) {
[10:21:44.058]                   name <- removed[[kk]]
[10:21:44.058]                   NAME <- NAMES[[kk]]
[10:21:44.058]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.058]                     next
[10:21:44.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.058]                 }
[10:21:44.058]                 if (length(args) > 0) 
[10:21:44.058]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.058]             }
[10:21:44.058]             else {
[10:21:44.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.058]             }
[10:21:44.058]             {
[10:21:44.058]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.058]                   0L) {
[10:21:44.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.058]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.058]                   base::options(opts)
[10:21:44.058]                 }
[10:21:44.058]                 {
[10:21:44.058]                   {
[10:21:44.058]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.058]                     NULL
[10:21:44.058]                   }
[10:21:44.058]                   options(future.plan = NULL)
[10:21:44.058]                   if (is.na(NA_character_)) 
[10:21:44.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.058]                     .init = FALSE)
[10:21:44.058]                 }
[10:21:44.058]             }
[10:21:44.058]         }
[10:21:44.058]     })
[10:21:44.058]     if (TRUE) {
[10:21:44.058]         base::sink(type = "output", split = FALSE)
[10:21:44.058]         if (TRUE) {
[10:21:44.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.058]         }
[10:21:44.058]         else {
[10:21:44.058]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.058]         }
[10:21:44.058]         base::close(...future.stdout)
[10:21:44.058]         ...future.stdout <- NULL
[10:21:44.058]     }
[10:21:44.058]     ...future.result$conditions <- ...future.conditions
[10:21:44.058]     ...future.result$finished <- base::Sys.time()
[10:21:44.058]     ...future.result
[10:21:44.058] }
[10:21:44.061] assign_globals() ...
[10:21:44.061] List of 1
[10:21:44.061]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18e015b58> 
[10:21:44.061]  - attr(*, "where")=List of 1
[10:21:44.061]   ..$ a:<environment: R_EmptyEnv> 
[10:21:44.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.061]  - attr(*, "resolved")= logi TRUE
[10:21:44.061]  - attr(*, "total_size")= num 3835
[10:21:44.061]  - attr(*, "already-done")= logi TRUE
[10:21:44.064] - copied ‘a’ to environment
[10:21:44.064] assign_globals() ... done
[10:21:44.064] requestCore(): workers = 2
[10:21:44.066] MulticoreFuture started
[10:21:44.066] - Launch lazy future ... done
[10:21:44.067] run() for ‘MulticoreFuture’ ... done
[10:21:44.067] result() for MulticoreFuture ...
[10:21:44.067] plan(): Setting new future strategy stack:
[10:21:44.068] List of future strategies:
[10:21:44.068] 1. sequential:
[10:21:44.068]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.068]    - tweaked: FALSE
[10:21:44.068]    - call: NULL
[10:21:44.069] plan(): nbrOfWorkers() = 1
[10:21:44.072] plan(): Setting new future strategy stack:
[10:21:44.072] List of future strategies:
[10:21:44.072] 1. multicore:
[10:21:44.072]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.072]    - tweaked: FALSE
[10:21:44.072]    - call: plan(strategy)
[10:21:44.075] plan(): nbrOfWorkers() = 2
[10:21:44.076] result() for MulticoreFuture ...
[10:21:44.076] result() for MulticoreFuture ... done
[10:21:44.076] signalConditions() ...
[10:21:44.076]  - include = ‘immediateCondition’
[10:21:44.076]  - exclude = 
[10:21:44.076]  - resignal = FALSE
[10:21:44.077]  - Number of conditions: 4
[10:21:44.077] signalConditions() ... done
[10:21:44.077] result() for MulticoreFuture ... done
[10:21:44.077] result() for MulticoreFuture ...
[10:21:44.077] result() for MulticoreFuture ... done
[10:21:44.077] signalConditions() ...
[10:21:44.077]  - include = ‘immediateCondition’
[10:21:44.077]  - exclude = 
[10:21:44.078]  - resignal = FALSE
[10:21:44.078]  - Number of conditions: 4
[10:21:44.078] signalConditions() ... done
[10:21:44.078] Future state: ‘finished’
[10:21:44.078] result() for MulticoreFuture ...
[10:21:44.078] result() for MulticoreFuture ... done
[10:21:44.078] signalConditions() ...
[10:21:44.078]  - include = ‘condition’
[10:21:44.079]  - exclude = ‘immediateCondition’
[10:21:44.079]  - resignal = TRUE
[10:21:44.079]  - Number of conditions: 4
[10:21:44.079]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.070] result() for MulticoreFuture ...
[10:21:44.079]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.070] result() for MulticoreFuture ... done
[10:21:44.079]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.071] result() for MulticoreFuture ...
[10:21:44.079]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.071] result() for MulticoreFuture ... done
[10:21:44.079] signalConditions() ... done
value(b) = 2
[10:21:44.080] result() for MulticoreFuture ...
[10:21:44.080] result() for MulticoreFuture ... done
[10:21:44.080] result() for MulticoreFuture ...
[10:21:44.080] result() for MulticoreFuture ... done
[10:21:44.080] signalConditions() ...
[10:21:44.080]  - include = ‘immediateCondition’
[10:21:44.080]  - exclude = 
[10:21:44.080]  - resignal = FALSE
[10:21:44.080]  - Number of conditions: 4
[10:21:44.081] signalConditions() ... done
[10:21:44.081] Future state: ‘finished’
[10:21:44.081] result() for MulticoreFuture ...
[10:21:44.081] result() for MulticoreFuture ... done
[10:21:44.081] signalConditions() ...
[10:21:44.081]  - include = ‘condition’
[10:21:44.081]  - exclude = ‘immediateCondition’
[10:21:44.081]  - resignal = TRUE
[10:21:44.082]  - Number of conditions: 4
[10:21:44.082]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.070] result() for MulticoreFuture ...
[10:21:44.082]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.070] result() for MulticoreFuture ... done
[10:21:44.082]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.071] result() for MulticoreFuture ...
[10:21:44.082]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.071] result() for MulticoreFuture ... done
[10:21:44.082] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.083] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.083] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:44.084] - globals found: [2] ‘{’, ‘pkg’
[10:21:44.084] Searching for globals ... DONE
[10:21:44.092] Resolving globals: TRUE
[10:21:44.092] Resolving any globals that are futures ...
[10:21:44.092] - globals: [2] ‘{’, ‘pkg’
[10:21:44.093] Resolving any globals that are futures ... DONE
[10:21:44.093] Resolving futures part of globals (recursively) ...
[10:21:44.093] resolve() on list ...
[10:21:44.093]  recursive: 99
[10:21:44.093]  length: 1
[10:21:44.093]  elements: ‘pkg’
[10:21:44.094]  length: 0 (resolved future 1)
[10:21:44.094] resolve() on list ... DONE
[10:21:44.094] - globals: [1] ‘pkg’
[10:21:44.094] Resolving futures part of globals (recursively) ... DONE
[10:21:44.094] The total size of the 1 globals is 42 bytes (42 bytes)
[10:21:44.094] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[10:21:44.094] - globals: [1] ‘pkg’
[10:21:44.095] 
[10:21:44.095] getGlobalsAndPackages() ... DONE
[10:21:44.095] Packages needed by the future expression (n = 0): <none>
[10:21:44.095] Packages needed by future strategies (n = 0): <none>
[10:21:44.096] {
[10:21:44.096]     {
[10:21:44.096]         {
[10:21:44.096]             ...future.startTime <- base::Sys.time()
[10:21:44.096]             {
[10:21:44.096]                 {
[10:21:44.096]                   {
[10:21:44.096]                     base::local({
[10:21:44.096]                       has_future <- base::requireNamespace("future", 
[10:21:44.096]                         quietly = TRUE)
[10:21:44.096]                       if (has_future) {
[10:21:44.096]                         ns <- base::getNamespace("future")
[10:21:44.096]                         version <- ns[[".package"]][["version"]]
[10:21:44.096]                         if (is.null(version)) 
[10:21:44.096]                           version <- utils::packageVersion("future")
[10:21:44.096]                       }
[10:21:44.096]                       else {
[10:21:44.096]                         version <- NULL
[10:21:44.096]                       }
[10:21:44.096]                       if (!has_future || version < "1.8.0") {
[10:21:44.096]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.096]                           "", base::R.version$version.string), 
[10:21:44.096]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:44.096]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.096]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.096]                             "release", "version")], collapse = " "), 
[10:21:44.096]                           hostname = base::Sys.info()[["nodename"]])
[10:21:44.096]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.096]                           info)
[10:21:44.096]                         info <- base::paste(info, collapse = "; ")
[10:21:44.096]                         if (!has_future) {
[10:21:44.096]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.096]                             info)
[10:21:44.096]                         }
[10:21:44.096]                         else {
[10:21:44.096]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.096]                             info, version)
[10:21:44.096]                         }
[10:21:44.096]                         base::stop(msg)
[10:21:44.096]                       }
[10:21:44.096]                     })
[10:21:44.096]                   }
[10:21:44.096]                   ...future.strategy.old <- future::plan("list")
[10:21:44.096]                   options(future.plan = NULL)
[10:21:44.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.096]                 }
[10:21:44.096]                 ...future.workdir <- getwd()
[10:21:44.096]             }
[10:21:44.096]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.096]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.096]         }
[10:21:44.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.096]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:44.096]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.096]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.096]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.096]             base::names(...future.oldOptions))
[10:21:44.096]     }
[10:21:44.096]     if (FALSE) {
[10:21:44.096]     }
[10:21:44.096]     else {
[10:21:44.096]         if (TRUE) {
[10:21:44.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.096]                 open = "w")
[10:21:44.096]         }
[10:21:44.096]         else {
[10:21:44.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.096]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.096]         }
[10:21:44.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.096]             base::sink(type = "output", split = FALSE)
[10:21:44.096]             base::close(...future.stdout)
[10:21:44.096]         }, add = TRUE)
[10:21:44.096]     }
[10:21:44.096]     ...future.frame <- base::sys.nframe()
[10:21:44.096]     ...future.conditions <- base::list()
[10:21:44.096]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.096]     if (FALSE) {
[10:21:44.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.096]     }
[10:21:44.096]     ...future.result <- base::tryCatch({
[10:21:44.096]         base::withCallingHandlers({
[10:21:44.096]             ...future.value <- base::withVisible(base::local({
[10:21:44.096]                 pkg
[10:21:44.096]             }))
[10:21:44.096]             future::FutureResult(value = ...future.value$value, 
[10:21:44.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.096]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.096]                     ...future.globalenv.names))
[10:21:44.096]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.096]         }, condition = base::local({
[10:21:44.096]             c <- base::c
[10:21:44.096]             inherits <- base::inherits
[10:21:44.096]             invokeRestart <- base::invokeRestart
[10:21:44.096]             length <- base::length
[10:21:44.096]             list <- base::list
[10:21:44.096]             seq.int <- base::seq.int
[10:21:44.096]             signalCondition <- base::signalCondition
[10:21:44.096]             sys.calls <- base::sys.calls
[10:21:44.096]             `[[` <- base::`[[`
[10:21:44.096]             `+` <- base::`+`
[10:21:44.096]             `<<-` <- base::`<<-`
[10:21:44.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.096]                   3L)]
[10:21:44.096]             }
[10:21:44.096]             function(cond) {
[10:21:44.096]                 is_error <- inherits(cond, "error")
[10:21:44.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.096]                   NULL)
[10:21:44.096]                 if (is_error) {
[10:21:44.096]                   sessionInformation <- function() {
[10:21:44.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.096]                       search = base::search(), system = base::Sys.info())
[10:21:44.096]                   }
[10:21:44.096]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.096]                     cond$call), session = sessionInformation(), 
[10:21:44.096]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.096]                   signalCondition(cond)
[10:21:44.096]                 }
[10:21:44.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.096]                 "immediateCondition"))) {
[10:21:44.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.096]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.096]                   if (TRUE && !signal) {
[10:21:44.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.096]                     {
[10:21:44.096]                       inherits <- base::inherits
[10:21:44.096]                       invokeRestart <- base::invokeRestart
[10:21:44.096]                       is.null <- base::is.null
[10:21:44.096]                       muffled <- FALSE
[10:21:44.096]                       if (inherits(cond, "message")) {
[10:21:44.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.096]                         if (muffled) 
[10:21:44.096]                           invokeRestart("muffleMessage")
[10:21:44.096]                       }
[10:21:44.096]                       else if (inherits(cond, "warning")) {
[10:21:44.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.096]                         if (muffled) 
[10:21:44.096]                           invokeRestart("muffleWarning")
[10:21:44.096]                       }
[10:21:44.096]                       else if (inherits(cond, "condition")) {
[10:21:44.096]                         if (!is.null(pattern)) {
[10:21:44.096]                           computeRestarts <- base::computeRestarts
[10:21:44.096]                           grepl <- base::grepl
[10:21:44.096]                           restarts <- computeRestarts(cond)
[10:21:44.096]                           for (restart in restarts) {
[10:21:44.096]                             name <- restart$name
[10:21:44.096]                             if (is.null(name)) 
[10:21:44.096]                               next
[10:21:44.096]                             if (!grepl(pattern, name)) 
[10:21:44.096]                               next
[10:21:44.096]                             invokeRestart(restart)
[10:21:44.096]                             muffled <- TRUE
[10:21:44.096]                             break
[10:21:44.096]                           }
[10:21:44.096]                         }
[10:21:44.096]                       }
[10:21:44.096]                       invisible(muffled)
[10:21:44.096]                     }
[10:21:44.096]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.096]                   }
[10:21:44.096]                 }
[10:21:44.096]                 else {
[10:21:44.096]                   if (TRUE) {
[10:21:44.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.096]                     {
[10:21:44.096]                       inherits <- base::inherits
[10:21:44.096]                       invokeRestart <- base::invokeRestart
[10:21:44.096]                       is.null <- base::is.null
[10:21:44.096]                       muffled <- FALSE
[10:21:44.096]                       if (inherits(cond, "message")) {
[10:21:44.096]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.096]                         if (muffled) 
[10:21:44.096]                           invokeRestart("muffleMessage")
[10:21:44.096]                       }
[10:21:44.096]                       else if (inherits(cond, "warning")) {
[10:21:44.096]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.096]                         if (muffled) 
[10:21:44.096]                           invokeRestart("muffleWarning")
[10:21:44.096]                       }
[10:21:44.096]                       else if (inherits(cond, "condition")) {
[10:21:44.096]                         if (!is.null(pattern)) {
[10:21:44.096]                           computeRestarts <- base::computeRestarts
[10:21:44.096]                           grepl <- base::grepl
[10:21:44.096]                           restarts <- computeRestarts(cond)
[10:21:44.096]                           for (restart in restarts) {
[10:21:44.096]                             name <- restart$name
[10:21:44.096]                             if (is.null(name)) 
[10:21:44.096]                               next
[10:21:44.096]                             if (!grepl(pattern, name)) 
[10:21:44.096]                               next
[10:21:44.096]                             invokeRestart(restart)
[10:21:44.096]                             muffled <- TRUE
[10:21:44.096]                             break
[10:21:44.096]                           }
[10:21:44.096]                         }
[10:21:44.096]                       }
[10:21:44.096]                       invisible(muffled)
[10:21:44.096]                     }
[10:21:44.096]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.096]                   }
[10:21:44.096]                 }
[10:21:44.096]             }
[10:21:44.096]         }))
[10:21:44.096]     }, error = function(ex) {
[10:21:44.096]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.096]                 ...future.rng), started = ...future.startTime, 
[10:21:44.096]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.096]             version = "1.8"), class = "FutureResult")
[10:21:44.096]     }, finally = {
[10:21:44.096]         if (!identical(...future.workdir, getwd())) 
[10:21:44.096]             setwd(...future.workdir)
[10:21:44.096]         {
[10:21:44.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.096]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.096]             }
[10:21:44.096]             base::options(...future.oldOptions)
[10:21:44.096]             if (.Platform$OS.type == "windows") {
[10:21:44.096]                 old_names <- names(...future.oldEnvVars)
[10:21:44.096]                 envs <- base::Sys.getenv()
[10:21:44.096]                 names <- names(envs)
[10:21:44.096]                 common <- intersect(names, old_names)
[10:21:44.096]                 added <- setdiff(names, old_names)
[10:21:44.096]                 removed <- setdiff(old_names, names)
[10:21:44.096]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.096]                   envs[common]]
[10:21:44.096]                 NAMES <- toupper(changed)
[10:21:44.096]                 args <- list()
[10:21:44.096]                 for (kk in seq_along(NAMES)) {
[10:21:44.096]                   name <- changed[[kk]]
[10:21:44.096]                   NAME <- NAMES[[kk]]
[10:21:44.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.096]                     next
[10:21:44.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.096]                 }
[10:21:44.096]                 NAMES <- toupper(added)
[10:21:44.096]                 for (kk in seq_along(NAMES)) {
[10:21:44.096]                   name <- added[[kk]]
[10:21:44.096]                   NAME <- NAMES[[kk]]
[10:21:44.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.096]                     next
[10:21:44.096]                   args[[name]] <- ""
[10:21:44.096]                 }
[10:21:44.096]                 NAMES <- toupper(removed)
[10:21:44.096]                 for (kk in seq_along(NAMES)) {
[10:21:44.096]                   name <- removed[[kk]]
[10:21:44.096]                   NAME <- NAMES[[kk]]
[10:21:44.096]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.096]                     next
[10:21:44.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.096]                 }
[10:21:44.096]                 if (length(args) > 0) 
[10:21:44.096]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.096]             }
[10:21:44.096]             else {
[10:21:44.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.096]             }
[10:21:44.096]             {
[10:21:44.096]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.096]                   0L) {
[10:21:44.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.096]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.096]                   base::options(opts)
[10:21:44.096]                 }
[10:21:44.096]                 {
[10:21:44.096]                   {
[10:21:44.096]                     NULL
[10:21:44.096]                     RNGkind("Mersenne-Twister")
[10:21:44.096]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:44.096]                       inherits = FALSE)
[10:21:44.096]                   }
[10:21:44.096]                   options(future.plan = NULL)
[10:21:44.096]                   if (is.na(NA_character_)) 
[10:21:44.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.096]                     .init = FALSE)
[10:21:44.096]                 }
[10:21:44.096]             }
[10:21:44.096]         }
[10:21:44.096]     })
[10:21:44.096]     if (TRUE) {
[10:21:44.096]         base::sink(type = "output", split = FALSE)
[10:21:44.096]         if (TRUE) {
[10:21:44.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.096]         }
[10:21:44.096]         else {
[10:21:44.096]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.096]         }
[10:21:44.096]         base::close(...future.stdout)
[10:21:44.096]         ...future.stdout <- NULL
[10:21:44.096]     }
[10:21:44.096]     ...future.result$conditions <- ...future.conditions
[10:21:44.096]     ...future.result$finished <- base::Sys.time()
[10:21:44.096]     ...future.result
[10:21:44.096] }
[10:21:44.097] assign_globals() ...
[10:21:44.098] List of 1
[10:21:44.098]  $ pkg: chr "foo"
[10:21:44.098]  - attr(*, "where")=List of 1
[10:21:44.098]   ..$ pkg:<environment: R_EmptyEnv> 
[10:21:44.098]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.098]  - attr(*, "resolved")= logi TRUE
[10:21:44.098]  - attr(*, "total_size")= num 42
[10:21:44.100] - copied ‘pkg’ to environment
[10:21:44.100] assign_globals() ... done
[10:21:44.101] plan(): Setting new future strategy stack:
[10:21:44.101] List of future strategies:
[10:21:44.101] 1. sequential:
[10:21:44.101]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.101]    - tweaked: FALSE
[10:21:44.101]    - call: NULL
[10:21:44.101] plan(): nbrOfWorkers() = 1
[10:21:44.102] plan(): Setting new future strategy stack:
[10:21:44.102] List of future strategies:
[10:21:44.102] 1. multicore:
[10:21:44.102]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.102]    - tweaked: FALSE
[10:21:44.102]    - call: plan(strategy)
[10:21:44.104] plan(): nbrOfWorkers() = 2
[10:21:44.104] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.105] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.105] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.107] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:44.107] Searching for globals ... DONE
[10:21:44.107] Resolving globals: TRUE
[10:21:44.107] Resolving any globals that are futures ...
[10:21:44.108] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:44.108] Resolving any globals that are futures ... DONE
[10:21:44.108] Resolving futures part of globals (recursively) ...
[10:21:44.108] resolve() on list ...
[10:21:44.108]  recursive: 99
[10:21:44.108]  length: 1
[10:21:44.108]  elements: ‘a’
[10:21:44.109]  length: 0 (resolved future 1)
[10:21:44.109] resolve() on list ... DONE
[10:21:44.109] - globals: [1] ‘a’
[10:21:44.109] Resolving futures part of globals (recursively) ... DONE
[10:21:44.109] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:44.109] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:44.109] - globals: [1] ‘a’
[10:21:44.109] 
[10:21:44.110] getGlobalsAndPackages() ... DONE
[10:21:44.110] run() for ‘Future’ ...
[10:21:44.110] - state: ‘created’
[10:21:44.110] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.112]   - Field: ‘label’
[10:21:44.112]   - Field: ‘local’
[10:21:44.112]   - Field: ‘owner’
[10:21:44.112]   - Field: ‘envir’
[10:21:44.112]   - Field: ‘workers’
[10:21:44.112]   - Field: ‘packages’
[10:21:44.112]   - Field: ‘gc’
[10:21:44.112]   - Field: ‘job’
[10:21:44.113]   - Field: ‘conditions’
[10:21:44.113]   - Field: ‘expr’
[10:21:44.113]   - Field: ‘uuid’
[10:21:44.113]   - Field: ‘seed’
[10:21:44.113]   - Field: ‘version’
[10:21:44.113]   - Field: ‘result’
[10:21:44.113]   - Field: ‘asynchronous’
[10:21:44.113]   - Field: ‘calls’
[10:21:44.113]   - Field: ‘globals’
[10:21:44.113]   - Field: ‘stdout’
[10:21:44.113]   - Field: ‘earlySignal’
[10:21:44.113]   - Field: ‘lazy’
[10:21:44.114]   - Field: ‘state’
[10:21:44.114] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.114] - Launch lazy future ...
[10:21:44.114] Packages needed by the future expression (n = 0): <none>
[10:21:44.114] Packages needed by future strategies (n = 0): <none>
[10:21:44.114] {
[10:21:44.114]     {
[10:21:44.114]         {
[10:21:44.114]             ...future.startTime <- base::Sys.time()
[10:21:44.114]             {
[10:21:44.114]                 {
[10:21:44.114]                   {
[10:21:44.114]                     {
[10:21:44.114]                       base::local({
[10:21:44.114]                         has_future <- base::requireNamespace("future", 
[10:21:44.114]                           quietly = TRUE)
[10:21:44.114]                         if (has_future) {
[10:21:44.114]                           ns <- base::getNamespace("future")
[10:21:44.114]                           version <- ns[[".package"]][["version"]]
[10:21:44.114]                           if (is.null(version)) 
[10:21:44.114]                             version <- utils::packageVersion("future")
[10:21:44.114]                         }
[10:21:44.114]                         else {
[10:21:44.114]                           version <- NULL
[10:21:44.114]                         }
[10:21:44.114]                         if (!has_future || version < "1.8.0") {
[10:21:44.114]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.114]                             "", base::R.version$version.string), 
[10:21:44.114]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.114]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.114]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.114]                               "release", "version")], collapse = " "), 
[10:21:44.114]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.114]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.114]                             info)
[10:21:44.114]                           info <- base::paste(info, collapse = "; ")
[10:21:44.114]                           if (!has_future) {
[10:21:44.114]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.114]                               info)
[10:21:44.114]                           }
[10:21:44.114]                           else {
[10:21:44.114]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.114]                               info, version)
[10:21:44.114]                           }
[10:21:44.114]                           base::stop(msg)
[10:21:44.114]                         }
[10:21:44.114]                       })
[10:21:44.114]                     }
[10:21:44.114]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.114]                     base::options(mc.cores = 1L)
[10:21:44.114]                   }
[10:21:44.114]                   ...future.strategy.old <- future::plan("list")
[10:21:44.114]                   options(future.plan = NULL)
[10:21:44.114]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.114]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.114]                 }
[10:21:44.114]                 ...future.workdir <- getwd()
[10:21:44.114]             }
[10:21:44.114]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.114]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.114]         }
[10:21:44.114]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.114]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.114]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.114]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.114]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.114]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.114]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.114]             base::names(...future.oldOptions))
[10:21:44.114]     }
[10:21:44.114]     if (FALSE) {
[10:21:44.114]     }
[10:21:44.114]     else {
[10:21:44.114]         if (TRUE) {
[10:21:44.114]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.114]                 open = "w")
[10:21:44.114]         }
[10:21:44.114]         else {
[10:21:44.114]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.114]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.114]         }
[10:21:44.114]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.114]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.114]             base::sink(type = "output", split = FALSE)
[10:21:44.114]             base::close(...future.stdout)
[10:21:44.114]         }, add = TRUE)
[10:21:44.114]     }
[10:21:44.114]     ...future.frame <- base::sys.nframe()
[10:21:44.114]     ...future.conditions <- base::list()
[10:21:44.114]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.114]     if (FALSE) {
[10:21:44.114]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.114]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.114]     }
[10:21:44.114]     ...future.result <- base::tryCatch({
[10:21:44.114]         base::withCallingHandlers({
[10:21:44.114]             ...future.value <- base::withVisible(base::local({
[10:21:44.114]                 withCallingHandlers({
[10:21:44.114]                   {
[10:21:44.114]                     b <- a
[10:21:44.114]                     a <- 2
[10:21:44.114]                     a * b
[10:21:44.114]                   }
[10:21:44.114]                 }, immediateCondition = function(cond) {
[10:21:44.114]                   save_rds <- function (object, pathname, ...) 
[10:21:44.114]                   {
[10:21:44.114]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.114]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.114]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.114]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.114]                         fi_tmp[["mtime"]])
[10:21:44.114]                     }
[10:21:44.114]                     tryCatch({
[10:21:44.114]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.114]                     }, error = function(ex) {
[10:21:44.114]                       msg <- conditionMessage(ex)
[10:21:44.114]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.114]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.114]                         fi_tmp[["mtime"]], msg)
[10:21:44.114]                       ex$message <- msg
[10:21:44.114]                       stop(ex)
[10:21:44.114]                     })
[10:21:44.114]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.114]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.114]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.114]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.114]                       fi <- file.info(pathname)
[10:21:44.114]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.114]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.114]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.114]                         fi[["size"]], fi[["mtime"]])
[10:21:44.114]                       stop(msg)
[10:21:44.114]                     }
[10:21:44.114]                     invisible(pathname)
[10:21:44.114]                   }
[10:21:44.114]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.114]                     rootPath = tempdir()) 
[10:21:44.114]                   {
[10:21:44.114]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.114]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.114]                       tmpdir = path, fileext = ".rds")
[10:21:44.114]                     save_rds(obj, file)
[10:21:44.114]                   }
[10:21:44.114]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.114]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.114]                   {
[10:21:44.114]                     inherits <- base::inherits
[10:21:44.114]                     invokeRestart <- base::invokeRestart
[10:21:44.114]                     is.null <- base::is.null
[10:21:44.114]                     muffled <- FALSE
[10:21:44.114]                     if (inherits(cond, "message")) {
[10:21:44.114]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.114]                       if (muffled) 
[10:21:44.114]                         invokeRestart("muffleMessage")
[10:21:44.114]                     }
[10:21:44.114]                     else if (inherits(cond, "warning")) {
[10:21:44.114]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.114]                       if (muffled) 
[10:21:44.114]                         invokeRestart("muffleWarning")
[10:21:44.114]                     }
[10:21:44.114]                     else if (inherits(cond, "condition")) {
[10:21:44.114]                       if (!is.null(pattern)) {
[10:21:44.114]                         computeRestarts <- base::computeRestarts
[10:21:44.114]                         grepl <- base::grepl
[10:21:44.114]                         restarts <- computeRestarts(cond)
[10:21:44.114]                         for (restart in restarts) {
[10:21:44.114]                           name <- restart$name
[10:21:44.114]                           if (is.null(name)) 
[10:21:44.114]                             next
[10:21:44.114]                           if (!grepl(pattern, name)) 
[10:21:44.114]                             next
[10:21:44.114]                           invokeRestart(restart)
[10:21:44.114]                           muffled <- TRUE
[10:21:44.114]                           break
[10:21:44.114]                         }
[10:21:44.114]                       }
[10:21:44.114]                     }
[10:21:44.114]                     invisible(muffled)
[10:21:44.114]                   }
[10:21:44.114]                   muffleCondition(cond)
[10:21:44.114]                 })
[10:21:44.114]             }))
[10:21:44.114]             future::FutureResult(value = ...future.value$value, 
[10:21:44.114]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.114]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.114]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.114]                     ...future.globalenv.names))
[10:21:44.114]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.114]         }, condition = base::local({
[10:21:44.114]             c <- base::c
[10:21:44.114]             inherits <- base::inherits
[10:21:44.114]             invokeRestart <- base::invokeRestart
[10:21:44.114]             length <- base::length
[10:21:44.114]             list <- base::list
[10:21:44.114]             seq.int <- base::seq.int
[10:21:44.114]             signalCondition <- base::signalCondition
[10:21:44.114]             sys.calls <- base::sys.calls
[10:21:44.114]             `[[` <- base::`[[`
[10:21:44.114]             `+` <- base::`+`
[10:21:44.114]             `<<-` <- base::`<<-`
[10:21:44.114]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.114]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.114]                   3L)]
[10:21:44.114]             }
[10:21:44.114]             function(cond) {
[10:21:44.114]                 is_error <- inherits(cond, "error")
[10:21:44.114]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.114]                   NULL)
[10:21:44.114]                 if (is_error) {
[10:21:44.114]                   sessionInformation <- function() {
[10:21:44.114]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.114]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.114]                       search = base::search(), system = base::Sys.info())
[10:21:44.114]                   }
[10:21:44.114]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.114]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.114]                     cond$call), session = sessionInformation(), 
[10:21:44.114]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.114]                   signalCondition(cond)
[10:21:44.114]                 }
[10:21:44.114]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.114]                 "immediateCondition"))) {
[10:21:44.114]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.114]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.114]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.114]                   if (TRUE && !signal) {
[10:21:44.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.114]                     {
[10:21:44.114]                       inherits <- base::inherits
[10:21:44.114]                       invokeRestart <- base::invokeRestart
[10:21:44.114]                       is.null <- base::is.null
[10:21:44.114]                       muffled <- FALSE
[10:21:44.114]                       if (inherits(cond, "message")) {
[10:21:44.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.114]                         if (muffled) 
[10:21:44.114]                           invokeRestart("muffleMessage")
[10:21:44.114]                       }
[10:21:44.114]                       else if (inherits(cond, "warning")) {
[10:21:44.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.114]                         if (muffled) 
[10:21:44.114]                           invokeRestart("muffleWarning")
[10:21:44.114]                       }
[10:21:44.114]                       else if (inherits(cond, "condition")) {
[10:21:44.114]                         if (!is.null(pattern)) {
[10:21:44.114]                           computeRestarts <- base::computeRestarts
[10:21:44.114]                           grepl <- base::grepl
[10:21:44.114]                           restarts <- computeRestarts(cond)
[10:21:44.114]                           for (restart in restarts) {
[10:21:44.114]                             name <- restart$name
[10:21:44.114]                             if (is.null(name)) 
[10:21:44.114]                               next
[10:21:44.114]                             if (!grepl(pattern, name)) 
[10:21:44.114]                               next
[10:21:44.114]                             invokeRestart(restart)
[10:21:44.114]                             muffled <- TRUE
[10:21:44.114]                             break
[10:21:44.114]                           }
[10:21:44.114]                         }
[10:21:44.114]                       }
[10:21:44.114]                       invisible(muffled)
[10:21:44.114]                     }
[10:21:44.114]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.114]                   }
[10:21:44.114]                 }
[10:21:44.114]                 else {
[10:21:44.114]                   if (TRUE) {
[10:21:44.114]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.114]                     {
[10:21:44.114]                       inherits <- base::inherits
[10:21:44.114]                       invokeRestart <- base::invokeRestart
[10:21:44.114]                       is.null <- base::is.null
[10:21:44.114]                       muffled <- FALSE
[10:21:44.114]                       if (inherits(cond, "message")) {
[10:21:44.114]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.114]                         if (muffled) 
[10:21:44.114]                           invokeRestart("muffleMessage")
[10:21:44.114]                       }
[10:21:44.114]                       else if (inherits(cond, "warning")) {
[10:21:44.114]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.114]                         if (muffled) 
[10:21:44.114]                           invokeRestart("muffleWarning")
[10:21:44.114]                       }
[10:21:44.114]                       else if (inherits(cond, "condition")) {
[10:21:44.114]                         if (!is.null(pattern)) {
[10:21:44.114]                           computeRestarts <- base::computeRestarts
[10:21:44.114]                           grepl <- base::grepl
[10:21:44.114]                           restarts <- computeRestarts(cond)
[10:21:44.114]                           for (restart in restarts) {
[10:21:44.114]                             name <- restart$name
[10:21:44.114]                             if (is.null(name)) 
[10:21:44.114]                               next
[10:21:44.114]                             if (!grepl(pattern, name)) 
[10:21:44.114]                               next
[10:21:44.114]                             invokeRestart(restart)
[10:21:44.114]                             muffled <- TRUE
[10:21:44.114]                             break
[10:21:44.114]                           }
[10:21:44.114]                         }
[10:21:44.114]                       }
[10:21:44.114]                       invisible(muffled)
[10:21:44.114]                     }
[10:21:44.114]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.114]                   }
[10:21:44.114]                 }
[10:21:44.114]             }
[10:21:44.114]         }))
[10:21:44.114]     }, error = function(ex) {
[10:21:44.114]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.114]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.114]                 ...future.rng), started = ...future.startTime, 
[10:21:44.114]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.114]             version = "1.8"), class = "FutureResult")
[10:21:44.114]     }, finally = {
[10:21:44.114]         if (!identical(...future.workdir, getwd())) 
[10:21:44.114]             setwd(...future.workdir)
[10:21:44.114]         {
[10:21:44.114]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.114]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.114]             }
[10:21:44.114]             base::options(...future.oldOptions)
[10:21:44.114]             if (.Platform$OS.type == "windows") {
[10:21:44.114]                 old_names <- names(...future.oldEnvVars)
[10:21:44.114]                 envs <- base::Sys.getenv()
[10:21:44.114]                 names <- names(envs)
[10:21:44.114]                 common <- intersect(names, old_names)
[10:21:44.114]                 added <- setdiff(names, old_names)
[10:21:44.114]                 removed <- setdiff(old_names, names)
[10:21:44.114]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.114]                   envs[common]]
[10:21:44.114]                 NAMES <- toupper(changed)
[10:21:44.114]                 args <- list()
[10:21:44.114]                 for (kk in seq_along(NAMES)) {
[10:21:44.114]                   name <- changed[[kk]]
[10:21:44.114]                   NAME <- NAMES[[kk]]
[10:21:44.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.114]                     next
[10:21:44.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.114]                 }
[10:21:44.114]                 NAMES <- toupper(added)
[10:21:44.114]                 for (kk in seq_along(NAMES)) {
[10:21:44.114]                   name <- added[[kk]]
[10:21:44.114]                   NAME <- NAMES[[kk]]
[10:21:44.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.114]                     next
[10:21:44.114]                   args[[name]] <- ""
[10:21:44.114]                 }
[10:21:44.114]                 NAMES <- toupper(removed)
[10:21:44.114]                 for (kk in seq_along(NAMES)) {
[10:21:44.114]                   name <- removed[[kk]]
[10:21:44.114]                   NAME <- NAMES[[kk]]
[10:21:44.114]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.114]                     next
[10:21:44.114]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.114]                 }
[10:21:44.114]                 if (length(args) > 0) 
[10:21:44.114]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.114]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.114]             }
[10:21:44.114]             else {
[10:21:44.114]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.114]             }
[10:21:44.114]             {
[10:21:44.114]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.114]                   0L) {
[10:21:44.114]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.114]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.114]                   base::options(opts)
[10:21:44.114]                 }
[10:21:44.114]                 {
[10:21:44.114]                   {
[10:21:44.114]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.114]                     NULL
[10:21:44.114]                   }
[10:21:44.114]                   options(future.plan = NULL)
[10:21:44.114]                   if (is.na(NA_character_)) 
[10:21:44.114]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.114]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.114]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.114]                     .init = FALSE)
[10:21:44.114]                 }
[10:21:44.114]             }
[10:21:44.114]         }
[10:21:44.114]     })
[10:21:44.114]     if (TRUE) {
[10:21:44.114]         base::sink(type = "output", split = FALSE)
[10:21:44.114]         if (TRUE) {
[10:21:44.114]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.114]         }
[10:21:44.114]         else {
[10:21:44.114]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.114]         }
[10:21:44.114]         base::close(...future.stdout)
[10:21:44.114]         ...future.stdout <- NULL
[10:21:44.114]     }
[10:21:44.114]     ...future.result$conditions <- ...future.conditions
[10:21:44.114]     ...future.result$finished <- base::Sys.time()
[10:21:44.114]     ...future.result
[10:21:44.114] }
[10:21:44.117] assign_globals() ...
[10:21:44.117] List of 1
[10:21:44.117]  $ a: num 3
[10:21:44.117]  - attr(*, "where")=List of 1
[10:21:44.117]   ..$ a:<environment: R_EmptyEnv> 
[10:21:44.117]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.117]  - attr(*, "resolved")= logi TRUE
[10:21:44.117]  - attr(*, "total_size")= num 39
[10:21:44.117]  - attr(*, "already-done")= logi TRUE
[10:21:44.121] - copied ‘a’ to environment
[10:21:44.121] assign_globals() ... done
[10:21:44.121] requestCore(): workers = 2
[10:21:44.123] MulticoreFuture started
[10:21:44.123] - Launch lazy future ... done
[10:21:44.124] run() for ‘MulticoreFuture’ ... done
[10:21:44.124] plan(): Setting new future strategy stack:
[10:21:44.124] result() for MulticoreFuture ...
[10:21:44.124] List of future strategies:
[10:21:44.124] 1. sequential:
[10:21:44.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.124]    - tweaked: FALSE
[10:21:44.124]    - call: NULL
[10:21:44.126] plan(): nbrOfWorkers() = 1
[10:21:44.129] plan(): Setting new future strategy stack:
[10:21:44.130] List of future strategies:
[10:21:44.130] 1. multicore:
[10:21:44.130]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.130]    - tweaked: FALSE
[10:21:44.130]    - call: plan(strategy)
[10:21:44.133] plan(): nbrOfWorkers() = 2
[10:21:44.134] result() for MulticoreFuture ...
[10:21:44.135] result() for MulticoreFuture ... done
[10:21:44.135] result() for MulticoreFuture ... done
[10:21:44.135] result() for MulticoreFuture ...
[10:21:44.135] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.136] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.137] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.139] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:44.140] Searching for globals ... DONE
[10:21:44.140] Resolving globals: TRUE
[10:21:44.140] Resolving any globals that are futures ...
[10:21:44.140] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:44.140] Resolving any globals that are futures ... DONE
[10:21:44.141] Resolving futures part of globals (recursively) ...
[10:21:44.141] resolve() on list ...
[10:21:44.141]  recursive: 99
[10:21:44.141]  length: 1
[10:21:44.141]  elements: ‘a’
[10:21:44.141]  length: 0 (resolved future 1)
[10:21:44.142] resolve() on list ... DONE
[10:21:44.142] - globals: [1] ‘a’
[10:21:44.142] Resolving futures part of globals (recursively) ... DONE
[10:21:44.142] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:44.142] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:44.143] - globals: [1] ‘a’
[10:21:44.143] 
[10:21:44.143] getGlobalsAndPackages() ... DONE
[10:21:44.143] run() for ‘Future’ ...
[10:21:44.143] - state: ‘created’
[10:21:44.143] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.145] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.146] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.146]   - Field: ‘label’
[10:21:44.146]   - Field: ‘local’
[10:21:44.146]   - Field: ‘owner’
[10:21:44.146]   - Field: ‘envir’
[10:21:44.146]   - Field: ‘workers’
[10:21:44.146]   - Field: ‘packages’
[10:21:44.146]   - Field: ‘gc’
[10:21:44.147]   - Field: ‘job’
[10:21:44.147]   - Field: ‘conditions’
[10:21:44.147]   - Field: ‘expr’
[10:21:44.147]   - Field: ‘uuid’
[10:21:44.147]   - Field: ‘seed’
[10:21:44.147]   - Field: ‘version’
[10:21:44.147]   - Field: ‘result’
[10:21:44.147]   - Field: ‘asynchronous’
[10:21:44.147]   - Field: ‘calls’
[10:21:44.147]   - Field: ‘globals’
[10:21:44.148]   - Field: ‘stdout’
[10:21:44.148]   - Field: ‘earlySignal’
[10:21:44.148]   - Field: ‘lazy’
[10:21:44.148]   - Field: ‘state’
[10:21:44.148] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.148] - Launch lazy future ...
[10:21:44.148] Packages needed by the future expression (n = 0): <none>
[10:21:44.149] Packages needed by future strategies (n = 0): <none>
[10:21:44.149] {
[10:21:44.149]     {
[10:21:44.149]         {
[10:21:44.149]             ...future.startTime <- base::Sys.time()
[10:21:44.149]             {
[10:21:44.149]                 {
[10:21:44.149]                   {
[10:21:44.149]                     {
[10:21:44.149]                       base::local({
[10:21:44.149]                         has_future <- base::requireNamespace("future", 
[10:21:44.149]                           quietly = TRUE)
[10:21:44.149]                         if (has_future) {
[10:21:44.149]                           ns <- base::getNamespace("future")
[10:21:44.149]                           version <- ns[[".package"]][["version"]]
[10:21:44.149]                           if (is.null(version)) 
[10:21:44.149]                             version <- utils::packageVersion("future")
[10:21:44.149]                         }
[10:21:44.149]                         else {
[10:21:44.149]                           version <- NULL
[10:21:44.149]                         }
[10:21:44.149]                         if (!has_future || version < "1.8.0") {
[10:21:44.149]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.149]                             "", base::R.version$version.string), 
[10:21:44.149]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.149]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.149]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.149]                               "release", "version")], collapse = " "), 
[10:21:44.149]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.149]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.149]                             info)
[10:21:44.149]                           info <- base::paste(info, collapse = "; ")
[10:21:44.149]                           if (!has_future) {
[10:21:44.149]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.149]                               info)
[10:21:44.149]                           }
[10:21:44.149]                           else {
[10:21:44.149]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.149]                               info, version)
[10:21:44.149]                           }
[10:21:44.149]                           base::stop(msg)
[10:21:44.149]                         }
[10:21:44.149]                       })
[10:21:44.149]                     }
[10:21:44.149]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.149]                     base::options(mc.cores = 1L)
[10:21:44.149]                   }
[10:21:44.149]                   ...future.strategy.old <- future::plan("list")
[10:21:44.149]                   options(future.plan = NULL)
[10:21:44.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.149]                 }
[10:21:44.149]                 ...future.workdir <- getwd()
[10:21:44.149]             }
[10:21:44.149]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.149]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.149]         }
[10:21:44.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.149]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.149]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.149]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.149]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.149]             base::names(...future.oldOptions))
[10:21:44.149]     }
[10:21:44.149]     if (FALSE) {
[10:21:44.149]     }
[10:21:44.149]     else {
[10:21:44.149]         if (TRUE) {
[10:21:44.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.149]                 open = "w")
[10:21:44.149]         }
[10:21:44.149]         else {
[10:21:44.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.149]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.149]         }
[10:21:44.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.149]             base::sink(type = "output", split = FALSE)
[10:21:44.149]             base::close(...future.stdout)
[10:21:44.149]         }, add = TRUE)
[10:21:44.149]     }
[10:21:44.149]     ...future.frame <- base::sys.nframe()
[10:21:44.149]     ...future.conditions <- base::list()
[10:21:44.149]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.149]     if (FALSE) {
[10:21:44.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.149]     }
[10:21:44.149]     ...future.result <- base::tryCatch({
[10:21:44.149]         base::withCallingHandlers({
[10:21:44.149]             ...future.value <- base::withVisible(base::local({
[10:21:44.149]                 withCallingHandlers({
[10:21:44.149]                   {
[10:21:44.149]                     b <- a
[10:21:44.149]                     a <- 2
[10:21:44.149]                     a * b
[10:21:44.149]                   }
[10:21:44.149]                 }, immediateCondition = function(cond) {
[10:21:44.149]                   save_rds <- function (object, pathname, ...) 
[10:21:44.149]                   {
[10:21:44.149]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.149]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.149]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.149]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.149]                         fi_tmp[["mtime"]])
[10:21:44.149]                     }
[10:21:44.149]                     tryCatch({
[10:21:44.149]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.149]                     }, error = function(ex) {
[10:21:44.149]                       msg <- conditionMessage(ex)
[10:21:44.149]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.149]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.149]                         fi_tmp[["mtime"]], msg)
[10:21:44.149]                       ex$message <- msg
[10:21:44.149]                       stop(ex)
[10:21:44.149]                     })
[10:21:44.149]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.149]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.149]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.149]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.149]                       fi <- file.info(pathname)
[10:21:44.149]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.149]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.149]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.149]                         fi[["size"]], fi[["mtime"]])
[10:21:44.149]                       stop(msg)
[10:21:44.149]                     }
[10:21:44.149]                     invisible(pathname)
[10:21:44.149]                   }
[10:21:44.149]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.149]                     rootPath = tempdir()) 
[10:21:44.149]                   {
[10:21:44.149]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.149]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.149]                       tmpdir = path, fileext = ".rds")
[10:21:44.149]                     save_rds(obj, file)
[10:21:44.149]                   }
[10:21:44.149]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.149]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.149]                   {
[10:21:44.149]                     inherits <- base::inherits
[10:21:44.149]                     invokeRestart <- base::invokeRestart
[10:21:44.149]                     is.null <- base::is.null
[10:21:44.149]                     muffled <- FALSE
[10:21:44.149]                     if (inherits(cond, "message")) {
[10:21:44.149]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.149]                       if (muffled) 
[10:21:44.149]                         invokeRestart("muffleMessage")
[10:21:44.149]                     }
[10:21:44.149]                     else if (inherits(cond, "warning")) {
[10:21:44.149]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.149]                       if (muffled) 
[10:21:44.149]                         invokeRestart("muffleWarning")
[10:21:44.149]                     }
[10:21:44.149]                     else if (inherits(cond, "condition")) {
[10:21:44.149]                       if (!is.null(pattern)) {
[10:21:44.149]                         computeRestarts <- base::computeRestarts
[10:21:44.149]                         grepl <- base::grepl
[10:21:44.149]                         restarts <- computeRestarts(cond)
[10:21:44.149]                         for (restart in restarts) {
[10:21:44.149]                           name <- restart$name
[10:21:44.149]                           if (is.null(name)) 
[10:21:44.149]                             next
[10:21:44.149]                           if (!grepl(pattern, name)) 
[10:21:44.149]                             next
[10:21:44.149]                           invokeRestart(restart)
[10:21:44.149]                           muffled <- TRUE
[10:21:44.149]                           break
[10:21:44.149]                         }
[10:21:44.149]                       }
[10:21:44.149]                     }
[10:21:44.149]                     invisible(muffled)
[10:21:44.149]                   }
[10:21:44.149]                   muffleCondition(cond)
[10:21:44.149]                 })
[10:21:44.149]             }))
[10:21:44.149]             future::FutureResult(value = ...future.value$value, 
[10:21:44.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.149]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.149]                     ...future.globalenv.names))
[10:21:44.149]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.149]         }, condition = base::local({
[10:21:44.149]             c <- base::c
[10:21:44.149]             inherits <- base::inherits
[10:21:44.149]             invokeRestart <- base::invokeRestart
[10:21:44.149]             length <- base::length
[10:21:44.149]             list <- base::list
[10:21:44.149]             seq.int <- base::seq.int
[10:21:44.149]             signalCondition <- base::signalCondition
[10:21:44.149]             sys.calls <- base::sys.calls
[10:21:44.149]             `[[` <- base::`[[`
[10:21:44.149]             `+` <- base::`+`
[10:21:44.149]             `<<-` <- base::`<<-`
[10:21:44.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.149]                   3L)]
[10:21:44.149]             }
[10:21:44.149]             function(cond) {
[10:21:44.149]                 is_error <- inherits(cond, "error")
[10:21:44.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.149]                   NULL)
[10:21:44.149]                 if (is_error) {
[10:21:44.149]                   sessionInformation <- function() {
[10:21:44.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.149]                       search = base::search(), system = base::Sys.info())
[10:21:44.149]                   }
[10:21:44.149]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.149]                     cond$call), session = sessionInformation(), 
[10:21:44.149]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.149]                   signalCondition(cond)
[10:21:44.149]                 }
[10:21:44.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.149]                 "immediateCondition"))) {
[10:21:44.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.149]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.149]                   if (TRUE && !signal) {
[10:21:44.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.149]                     {
[10:21:44.149]                       inherits <- base::inherits
[10:21:44.149]                       invokeRestart <- base::invokeRestart
[10:21:44.149]                       is.null <- base::is.null
[10:21:44.149]                       muffled <- FALSE
[10:21:44.149]                       if (inherits(cond, "message")) {
[10:21:44.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.149]                         if (muffled) 
[10:21:44.149]                           invokeRestart("muffleMessage")
[10:21:44.149]                       }
[10:21:44.149]                       else if (inherits(cond, "warning")) {
[10:21:44.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.149]                         if (muffled) 
[10:21:44.149]                           invokeRestart("muffleWarning")
[10:21:44.149]                       }
[10:21:44.149]                       else if (inherits(cond, "condition")) {
[10:21:44.149]                         if (!is.null(pattern)) {
[10:21:44.149]                           computeRestarts <- base::computeRestarts
[10:21:44.149]                           grepl <- base::grepl
[10:21:44.149]                           restarts <- computeRestarts(cond)
[10:21:44.149]                           for (restart in restarts) {
[10:21:44.149]                             name <- restart$name
[10:21:44.149]                             if (is.null(name)) 
[10:21:44.149]                               next
[10:21:44.149]                             if (!grepl(pattern, name)) 
[10:21:44.149]                               next
[10:21:44.149]                             invokeRestart(restart)
[10:21:44.149]                             muffled <- TRUE
[10:21:44.149]                             break
[10:21:44.149]                           }
[10:21:44.149]                         }
[10:21:44.149]                       }
[10:21:44.149]                       invisible(muffled)
[10:21:44.149]                     }
[10:21:44.149]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.149]                   }
[10:21:44.149]                 }
[10:21:44.149]                 else {
[10:21:44.149]                   if (TRUE) {
[10:21:44.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.149]                     {
[10:21:44.149]                       inherits <- base::inherits
[10:21:44.149]                       invokeRestart <- base::invokeRestart
[10:21:44.149]                       is.null <- base::is.null
[10:21:44.149]                       muffled <- FALSE
[10:21:44.149]                       if (inherits(cond, "message")) {
[10:21:44.149]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.149]                         if (muffled) 
[10:21:44.149]                           invokeRestart("muffleMessage")
[10:21:44.149]                       }
[10:21:44.149]                       else if (inherits(cond, "warning")) {
[10:21:44.149]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.149]                         if (muffled) 
[10:21:44.149]                           invokeRestart("muffleWarning")
[10:21:44.149]                       }
[10:21:44.149]                       else if (inherits(cond, "condition")) {
[10:21:44.149]                         if (!is.null(pattern)) {
[10:21:44.149]                           computeRestarts <- base::computeRestarts
[10:21:44.149]                           grepl <- base::grepl
[10:21:44.149]                           restarts <- computeRestarts(cond)
[10:21:44.149]                           for (restart in restarts) {
[10:21:44.149]                             name <- restart$name
[10:21:44.149]                             if (is.null(name)) 
[10:21:44.149]                               next
[10:21:44.149]                             if (!grepl(pattern, name)) 
[10:21:44.149]                               next
[10:21:44.149]                             invokeRestart(restart)
[10:21:44.149]                             muffled <- TRUE
[10:21:44.149]                             break
[10:21:44.149]                           }
[10:21:44.149]                         }
[10:21:44.149]                       }
[10:21:44.149]                       invisible(muffled)
[10:21:44.149]                     }
[10:21:44.149]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.149]                   }
[10:21:44.149]                 }
[10:21:44.149]             }
[10:21:44.149]         }))
[10:21:44.149]     }, error = function(ex) {
[10:21:44.149]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.149]                 ...future.rng), started = ...future.startTime, 
[10:21:44.149]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.149]             version = "1.8"), class = "FutureResult")
[10:21:44.149]     }, finally = {
[10:21:44.149]         if (!identical(...future.workdir, getwd())) 
[10:21:44.149]             setwd(...future.workdir)
[10:21:44.149]         {
[10:21:44.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.149]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.149]             }
[10:21:44.149]             base::options(...future.oldOptions)
[10:21:44.149]             if (.Platform$OS.type == "windows") {
[10:21:44.149]                 old_names <- names(...future.oldEnvVars)
[10:21:44.149]                 envs <- base::Sys.getenv()
[10:21:44.149]                 names <- names(envs)
[10:21:44.149]                 common <- intersect(names, old_names)
[10:21:44.149]                 added <- setdiff(names, old_names)
[10:21:44.149]                 removed <- setdiff(old_names, names)
[10:21:44.149]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.149]                   envs[common]]
[10:21:44.149]                 NAMES <- toupper(changed)
[10:21:44.149]                 args <- list()
[10:21:44.149]                 for (kk in seq_along(NAMES)) {
[10:21:44.149]                   name <- changed[[kk]]
[10:21:44.149]                   NAME <- NAMES[[kk]]
[10:21:44.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.149]                     next
[10:21:44.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.149]                 }
[10:21:44.149]                 NAMES <- toupper(added)
[10:21:44.149]                 for (kk in seq_along(NAMES)) {
[10:21:44.149]                   name <- added[[kk]]
[10:21:44.149]                   NAME <- NAMES[[kk]]
[10:21:44.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.149]                     next
[10:21:44.149]                   args[[name]] <- ""
[10:21:44.149]                 }
[10:21:44.149]                 NAMES <- toupper(removed)
[10:21:44.149]                 for (kk in seq_along(NAMES)) {
[10:21:44.149]                   name <- removed[[kk]]
[10:21:44.149]                   NAME <- NAMES[[kk]]
[10:21:44.149]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.149]                     next
[10:21:44.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.149]                 }
[10:21:44.149]                 if (length(args) > 0) 
[10:21:44.149]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.149]             }
[10:21:44.149]             else {
[10:21:44.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.149]             }
[10:21:44.149]             {
[10:21:44.149]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.149]                   0L) {
[10:21:44.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.149]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.149]                   base::options(opts)
[10:21:44.149]                 }
[10:21:44.149]                 {
[10:21:44.149]                   {
[10:21:44.149]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.149]                     NULL
[10:21:44.149]                   }
[10:21:44.149]                   options(future.plan = NULL)
[10:21:44.149]                   if (is.na(NA_character_)) 
[10:21:44.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.149]                     .init = FALSE)
[10:21:44.149]                 }
[10:21:44.149]             }
[10:21:44.149]         }
[10:21:44.149]     })
[10:21:44.149]     if (TRUE) {
[10:21:44.149]         base::sink(type = "output", split = FALSE)
[10:21:44.149]         if (TRUE) {
[10:21:44.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.149]         }
[10:21:44.149]         else {
[10:21:44.149]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.149]         }
[10:21:44.149]         base::close(...future.stdout)
[10:21:44.149]         ...future.stdout <- NULL
[10:21:44.149]     }
[10:21:44.149]     ...future.result$conditions <- ...future.conditions
[10:21:44.149]     ...future.result$finished <- base::Sys.time()
[10:21:44.149]     ...future.result
[10:21:44.149] }
[10:21:44.152] assign_globals() ...
[10:21:44.152] List of 1
[10:21:44.152]  $ a: num 3
[10:21:44.152]  - attr(*, "where")=List of 1
[10:21:44.152]   ..$ a:<environment: R_EmptyEnv> 
[10:21:44.152]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.152]  - attr(*, "resolved")= logi TRUE
[10:21:44.152]  - attr(*, "total_size")= num 39
[10:21:44.152]  - attr(*, "already-done")= logi TRUE
[10:21:44.155] - copied ‘a’ to environment
[10:21:44.155] assign_globals() ... done
[10:21:44.155] requestCore(): workers = 2
[10:21:44.157] MulticoreFuture started
[10:21:44.157] - Launch lazy future ... done
[10:21:44.157] run() for ‘MulticoreFuture’ ... done
[10:21:44.158] result() for MulticoreFuture ...
[10:21:44.158] plan(): Setting new future strategy stack:
[10:21:44.158] List of future strategies:
[10:21:44.158] 1. sequential:
[10:21:44.158]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.158]    - tweaked: FALSE
[10:21:44.158]    - call: NULL
[10:21:44.159] plan(): nbrOfWorkers() = 1
[10:21:44.161] plan(): Setting new future strategy stack:
[10:21:44.161] List of future strategies:
[10:21:44.161] 1. multicore:
[10:21:44.161]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.161]    - tweaked: FALSE
[10:21:44.161]    - call: plan(strategy)
[10:21:44.165] plan(): nbrOfWorkers() = 2
[10:21:44.165] result() for MulticoreFuture ...
[10:21:44.166] result() for MulticoreFuture ... done
[10:21:44.166] result() for MulticoreFuture ... done
[10:21:44.166] result() for MulticoreFuture ...
[10:21:44.166] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.167] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.167] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.173] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.173] Searching for globals ... DONE
[10:21:44.173] Resolving globals: TRUE
[10:21:44.173] Resolving any globals that are futures ...
[10:21:44.174] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.174] Resolving any globals that are futures ... DONE
[10:21:44.175] Resolving futures part of globals (recursively) ...
[10:21:44.175] resolve() on list ...
[10:21:44.175]  recursive: 99
[10:21:44.175]  length: 2
[10:21:44.175]  elements: ‘a’, ‘ii’
[10:21:44.175]  length: 1 (resolved future 1)
[10:21:44.176]  length: 0 (resolved future 2)
[10:21:44.176] resolve() on list ... DONE
[10:21:44.176] - globals: [2] ‘a’, ‘ii’
[10:21:44.176] Resolving futures part of globals (recursively) ... DONE
[10:21:44.176] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:44.177] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:44.177] - globals: [2] ‘a’, ‘ii’
[10:21:44.177] 
[10:21:44.177] getGlobalsAndPackages() ... DONE
[10:21:44.178] run() for ‘Future’ ...
[10:21:44.178] - state: ‘created’
[10:21:44.178] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.180] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.180] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.180]   - Field: ‘label’
[10:21:44.181]   - Field: ‘local’
[10:21:44.181]   - Field: ‘owner’
[10:21:44.181]   - Field: ‘envir’
[10:21:44.181]   - Field: ‘workers’
[10:21:44.181]   - Field: ‘packages’
[10:21:44.181]   - Field: ‘gc’
[10:21:44.181]   - Field: ‘job’
[10:21:44.181]   - Field: ‘conditions’
[10:21:44.181]   - Field: ‘expr’
[10:21:44.181]   - Field: ‘uuid’
[10:21:44.182]   - Field: ‘seed’
[10:21:44.182]   - Field: ‘version’
[10:21:44.182]   - Field: ‘result’
[10:21:44.182]   - Field: ‘asynchronous’
[10:21:44.182]   - Field: ‘calls’
[10:21:44.182]   - Field: ‘globals’
[10:21:44.182]   - Field: ‘stdout’
[10:21:44.182]   - Field: ‘earlySignal’
[10:21:44.182]   - Field: ‘lazy’
[10:21:44.183]   - Field: ‘state’
[10:21:44.183] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.183] - Launch lazy future ...
[10:21:44.183] Packages needed by the future expression (n = 0): <none>
[10:21:44.183] Packages needed by future strategies (n = 0): <none>
[10:21:44.184] {
[10:21:44.184]     {
[10:21:44.184]         {
[10:21:44.184]             ...future.startTime <- base::Sys.time()
[10:21:44.184]             {
[10:21:44.184]                 {
[10:21:44.184]                   {
[10:21:44.184]                     {
[10:21:44.184]                       base::local({
[10:21:44.184]                         has_future <- base::requireNamespace("future", 
[10:21:44.184]                           quietly = TRUE)
[10:21:44.184]                         if (has_future) {
[10:21:44.184]                           ns <- base::getNamespace("future")
[10:21:44.184]                           version <- ns[[".package"]][["version"]]
[10:21:44.184]                           if (is.null(version)) 
[10:21:44.184]                             version <- utils::packageVersion("future")
[10:21:44.184]                         }
[10:21:44.184]                         else {
[10:21:44.184]                           version <- NULL
[10:21:44.184]                         }
[10:21:44.184]                         if (!has_future || version < "1.8.0") {
[10:21:44.184]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.184]                             "", base::R.version$version.string), 
[10:21:44.184]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.184]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.184]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.184]                               "release", "version")], collapse = " "), 
[10:21:44.184]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.184]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.184]                             info)
[10:21:44.184]                           info <- base::paste(info, collapse = "; ")
[10:21:44.184]                           if (!has_future) {
[10:21:44.184]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.184]                               info)
[10:21:44.184]                           }
[10:21:44.184]                           else {
[10:21:44.184]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.184]                               info, version)
[10:21:44.184]                           }
[10:21:44.184]                           base::stop(msg)
[10:21:44.184]                         }
[10:21:44.184]                       })
[10:21:44.184]                     }
[10:21:44.184]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.184]                     base::options(mc.cores = 1L)
[10:21:44.184]                   }
[10:21:44.184]                   ...future.strategy.old <- future::plan("list")
[10:21:44.184]                   options(future.plan = NULL)
[10:21:44.184]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.184]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.184]                 }
[10:21:44.184]                 ...future.workdir <- getwd()
[10:21:44.184]             }
[10:21:44.184]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.184]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.184]         }
[10:21:44.184]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.184]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.184]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.184]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.184]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.184]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.184]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.184]             base::names(...future.oldOptions))
[10:21:44.184]     }
[10:21:44.184]     if (FALSE) {
[10:21:44.184]     }
[10:21:44.184]     else {
[10:21:44.184]         if (TRUE) {
[10:21:44.184]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.184]                 open = "w")
[10:21:44.184]         }
[10:21:44.184]         else {
[10:21:44.184]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.184]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.184]         }
[10:21:44.184]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.184]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.184]             base::sink(type = "output", split = FALSE)
[10:21:44.184]             base::close(...future.stdout)
[10:21:44.184]         }, add = TRUE)
[10:21:44.184]     }
[10:21:44.184]     ...future.frame <- base::sys.nframe()
[10:21:44.184]     ...future.conditions <- base::list()
[10:21:44.184]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.184]     if (FALSE) {
[10:21:44.184]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.184]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.184]     }
[10:21:44.184]     ...future.result <- base::tryCatch({
[10:21:44.184]         base::withCallingHandlers({
[10:21:44.184]             ...future.value <- base::withVisible(base::local({
[10:21:44.184]                 withCallingHandlers({
[10:21:44.184]                   {
[10:21:44.184]                     b <- a * ii
[10:21:44.184]                     a <- 0
[10:21:44.184]                     b
[10:21:44.184]                   }
[10:21:44.184]                 }, immediateCondition = function(cond) {
[10:21:44.184]                   save_rds <- function (object, pathname, ...) 
[10:21:44.184]                   {
[10:21:44.184]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.184]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.184]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.184]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.184]                         fi_tmp[["mtime"]])
[10:21:44.184]                     }
[10:21:44.184]                     tryCatch({
[10:21:44.184]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.184]                     }, error = function(ex) {
[10:21:44.184]                       msg <- conditionMessage(ex)
[10:21:44.184]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.184]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.184]                         fi_tmp[["mtime"]], msg)
[10:21:44.184]                       ex$message <- msg
[10:21:44.184]                       stop(ex)
[10:21:44.184]                     })
[10:21:44.184]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.184]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.184]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.184]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.184]                       fi <- file.info(pathname)
[10:21:44.184]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.184]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.184]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.184]                         fi[["size"]], fi[["mtime"]])
[10:21:44.184]                       stop(msg)
[10:21:44.184]                     }
[10:21:44.184]                     invisible(pathname)
[10:21:44.184]                   }
[10:21:44.184]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.184]                     rootPath = tempdir()) 
[10:21:44.184]                   {
[10:21:44.184]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.184]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.184]                       tmpdir = path, fileext = ".rds")
[10:21:44.184]                     save_rds(obj, file)
[10:21:44.184]                   }
[10:21:44.184]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.184]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.184]                   {
[10:21:44.184]                     inherits <- base::inherits
[10:21:44.184]                     invokeRestart <- base::invokeRestart
[10:21:44.184]                     is.null <- base::is.null
[10:21:44.184]                     muffled <- FALSE
[10:21:44.184]                     if (inherits(cond, "message")) {
[10:21:44.184]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.184]                       if (muffled) 
[10:21:44.184]                         invokeRestart("muffleMessage")
[10:21:44.184]                     }
[10:21:44.184]                     else if (inherits(cond, "warning")) {
[10:21:44.184]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.184]                       if (muffled) 
[10:21:44.184]                         invokeRestart("muffleWarning")
[10:21:44.184]                     }
[10:21:44.184]                     else if (inherits(cond, "condition")) {
[10:21:44.184]                       if (!is.null(pattern)) {
[10:21:44.184]                         computeRestarts <- base::computeRestarts
[10:21:44.184]                         grepl <- base::grepl
[10:21:44.184]                         restarts <- computeRestarts(cond)
[10:21:44.184]                         for (restart in restarts) {
[10:21:44.184]                           name <- restart$name
[10:21:44.184]                           if (is.null(name)) 
[10:21:44.184]                             next
[10:21:44.184]                           if (!grepl(pattern, name)) 
[10:21:44.184]                             next
[10:21:44.184]                           invokeRestart(restart)
[10:21:44.184]                           muffled <- TRUE
[10:21:44.184]                           break
[10:21:44.184]                         }
[10:21:44.184]                       }
[10:21:44.184]                     }
[10:21:44.184]                     invisible(muffled)
[10:21:44.184]                   }
[10:21:44.184]                   muffleCondition(cond)
[10:21:44.184]                 })
[10:21:44.184]             }))
[10:21:44.184]             future::FutureResult(value = ...future.value$value, 
[10:21:44.184]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.184]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.184]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.184]                     ...future.globalenv.names))
[10:21:44.184]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.184]         }, condition = base::local({
[10:21:44.184]             c <- base::c
[10:21:44.184]             inherits <- base::inherits
[10:21:44.184]             invokeRestart <- base::invokeRestart
[10:21:44.184]             length <- base::length
[10:21:44.184]             list <- base::list
[10:21:44.184]             seq.int <- base::seq.int
[10:21:44.184]             signalCondition <- base::signalCondition
[10:21:44.184]             sys.calls <- base::sys.calls
[10:21:44.184]             `[[` <- base::`[[`
[10:21:44.184]             `+` <- base::`+`
[10:21:44.184]             `<<-` <- base::`<<-`
[10:21:44.184]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.184]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.184]                   3L)]
[10:21:44.184]             }
[10:21:44.184]             function(cond) {
[10:21:44.184]                 is_error <- inherits(cond, "error")
[10:21:44.184]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.184]                   NULL)
[10:21:44.184]                 if (is_error) {
[10:21:44.184]                   sessionInformation <- function() {
[10:21:44.184]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.184]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.184]                       search = base::search(), system = base::Sys.info())
[10:21:44.184]                   }
[10:21:44.184]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.184]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.184]                     cond$call), session = sessionInformation(), 
[10:21:44.184]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.184]                   signalCondition(cond)
[10:21:44.184]                 }
[10:21:44.184]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.184]                 "immediateCondition"))) {
[10:21:44.184]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.184]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.184]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.184]                   if (TRUE && !signal) {
[10:21:44.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.184]                     {
[10:21:44.184]                       inherits <- base::inherits
[10:21:44.184]                       invokeRestart <- base::invokeRestart
[10:21:44.184]                       is.null <- base::is.null
[10:21:44.184]                       muffled <- FALSE
[10:21:44.184]                       if (inherits(cond, "message")) {
[10:21:44.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.184]                         if (muffled) 
[10:21:44.184]                           invokeRestart("muffleMessage")
[10:21:44.184]                       }
[10:21:44.184]                       else if (inherits(cond, "warning")) {
[10:21:44.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.184]                         if (muffled) 
[10:21:44.184]                           invokeRestart("muffleWarning")
[10:21:44.184]                       }
[10:21:44.184]                       else if (inherits(cond, "condition")) {
[10:21:44.184]                         if (!is.null(pattern)) {
[10:21:44.184]                           computeRestarts <- base::computeRestarts
[10:21:44.184]                           grepl <- base::grepl
[10:21:44.184]                           restarts <- computeRestarts(cond)
[10:21:44.184]                           for (restart in restarts) {
[10:21:44.184]                             name <- restart$name
[10:21:44.184]                             if (is.null(name)) 
[10:21:44.184]                               next
[10:21:44.184]                             if (!grepl(pattern, name)) 
[10:21:44.184]                               next
[10:21:44.184]                             invokeRestart(restart)
[10:21:44.184]                             muffled <- TRUE
[10:21:44.184]                             break
[10:21:44.184]                           }
[10:21:44.184]                         }
[10:21:44.184]                       }
[10:21:44.184]                       invisible(muffled)
[10:21:44.184]                     }
[10:21:44.184]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.184]                   }
[10:21:44.184]                 }
[10:21:44.184]                 else {
[10:21:44.184]                   if (TRUE) {
[10:21:44.184]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.184]                     {
[10:21:44.184]                       inherits <- base::inherits
[10:21:44.184]                       invokeRestart <- base::invokeRestart
[10:21:44.184]                       is.null <- base::is.null
[10:21:44.184]                       muffled <- FALSE
[10:21:44.184]                       if (inherits(cond, "message")) {
[10:21:44.184]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.184]                         if (muffled) 
[10:21:44.184]                           invokeRestart("muffleMessage")
[10:21:44.184]                       }
[10:21:44.184]                       else if (inherits(cond, "warning")) {
[10:21:44.184]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.184]                         if (muffled) 
[10:21:44.184]                           invokeRestart("muffleWarning")
[10:21:44.184]                       }
[10:21:44.184]                       else if (inherits(cond, "condition")) {
[10:21:44.184]                         if (!is.null(pattern)) {
[10:21:44.184]                           computeRestarts <- base::computeRestarts
[10:21:44.184]                           grepl <- base::grepl
[10:21:44.184]                           restarts <- computeRestarts(cond)
[10:21:44.184]                           for (restart in restarts) {
[10:21:44.184]                             name <- restart$name
[10:21:44.184]                             if (is.null(name)) 
[10:21:44.184]                               next
[10:21:44.184]                             if (!grepl(pattern, name)) 
[10:21:44.184]                               next
[10:21:44.184]                             invokeRestart(restart)
[10:21:44.184]                             muffled <- TRUE
[10:21:44.184]                             break
[10:21:44.184]                           }
[10:21:44.184]                         }
[10:21:44.184]                       }
[10:21:44.184]                       invisible(muffled)
[10:21:44.184]                     }
[10:21:44.184]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.184]                   }
[10:21:44.184]                 }
[10:21:44.184]             }
[10:21:44.184]         }))
[10:21:44.184]     }, error = function(ex) {
[10:21:44.184]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.184]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.184]                 ...future.rng), started = ...future.startTime, 
[10:21:44.184]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.184]             version = "1.8"), class = "FutureResult")
[10:21:44.184]     }, finally = {
[10:21:44.184]         if (!identical(...future.workdir, getwd())) 
[10:21:44.184]             setwd(...future.workdir)
[10:21:44.184]         {
[10:21:44.184]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.184]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.184]             }
[10:21:44.184]             base::options(...future.oldOptions)
[10:21:44.184]             if (.Platform$OS.type == "windows") {
[10:21:44.184]                 old_names <- names(...future.oldEnvVars)
[10:21:44.184]                 envs <- base::Sys.getenv()
[10:21:44.184]                 names <- names(envs)
[10:21:44.184]                 common <- intersect(names, old_names)
[10:21:44.184]                 added <- setdiff(names, old_names)
[10:21:44.184]                 removed <- setdiff(old_names, names)
[10:21:44.184]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.184]                   envs[common]]
[10:21:44.184]                 NAMES <- toupper(changed)
[10:21:44.184]                 args <- list()
[10:21:44.184]                 for (kk in seq_along(NAMES)) {
[10:21:44.184]                   name <- changed[[kk]]
[10:21:44.184]                   NAME <- NAMES[[kk]]
[10:21:44.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.184]                     next
[10:21:44.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.184]                 }
[10:21:44.184]                 NAMES <- toupper(added)
[10:21:44.184]                 for (kk in seq_along(NAMES)) {
[10:21:44.184]                   name <- added[[kk]]
[10:21:44.184]                   NAME <- NAMES[[kk]]
[10:21:44.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.184]                     next
[10:21:44.184]                   args[[name]] <- ""
[10:21:44.184]                 }
[10:21:44.184]                 NAMES <- toupper(removed)
[10:21:44.184]                 for (kk in seq_along(NAMES)) {
[10:21:44.184]                   name <- removed[[kk]]
[10:21:44.184]                   NAME <- NAMES[[kk]]
[10:21:44.184]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.184]                     next
[10:21:44.184]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.184]                 }
[10:21:44.184]                 if (length(args) > 0) 
[10:21:44.184]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.184]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.184]             }
[10:21:44.184]             else {
[10:21:44.184]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.184]             }
[10:21:44.184]             {
[10:21:44.184]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.184]                   0L) {
[10:21:44.184]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.184]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.184]                   base::options(opts)
[10:21:44.184]                 }
[10:21:44.184]                 {
[10:21:44.184]                   {
[10:21:44.184]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.184]                     NULL
[10:21:44.184]                   }
[10:21:44.184]                   options(future.plan = NULL)
[10:21:44.184]                   if (is.na(NA_character_)) 
[10:21:44.184]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.184]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.184]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.184]                     .init = FALSE)
[10:21:44.184]                 }
[10:21:44.184]             }
[10:21:44.184]         }
[10:21:44.184]     })
[10:21:44.184]     if (TRUE) {
[10:21:44.184]         base::sink(type = "output", split = FALSE)
[10:21:44.184]         if (TRUE) {
[10:21:44.184]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.184]         }
[10:21:44.184]         else {
[10:21:44.184]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.184]         }
[10:21:44.184]         base::close(...future.stdout)
[10:21:44.184]         ...future.stdout <- NULL
[10:21:44.184]     }
[10:21:44.184]     ...future.result$conditions <- ...future.conditions
[10:21:44.184]     ...future.result$finished <- base::Sys.time()
[10:21:44.184]     ...future.result
[10:21:44.184] }
[10:21:44.186] assign_globals() ...
[10:21:44.186] List of 2
[10:21:44.186]  $ a : num 1
[10:21:44.186]  $ ii: int 1
[10:21:44.186]  - attr(*, "where")=List of 2
[10:21:44.186]   ..$ a :<environment: R_EmptyEnv> 
[10:21:44.186]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:44.186]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.186]  - attr(*, "resolved")= logi TRUE
[10:21:44.186]  - attr(*, "total_size")= num 74
[10:21:44.186]  - attr(*, "already-done")= logi TRUE
[10:21:44.190] - copied ‘a’ to environment
[10:21:44.190] - copied ‘ii’ to environment
[10:21:44.190] assign_globals() ... done
[10:21:44.190] requestCore(): workers = 2
[10:21:44.192] MulticoreFuture started
[10:21:44.192] - Launch lazy future ... done
[10:21:44.192] run() for ‘MulticoreFuture’ ... done
[10:21:44.193] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.194] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.193] List of future strategies:
[10:21:44.193] 1. sequential:
[10:21:44.193]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.193]    - tweaked: FALSE
[10:21:44.193]    - call: NULL
[10:21:44.194] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.194] plan(): nbrOfWorkers() = 1
[10:21:44.196] plan(): Setting new future strategy stack:
[10:21:44.196] List of future strategies:
[10:21:44.196] 1. multicore:
[10:21:44.196]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.196]    - tweaked: FALSE
[10:21:44.196]    - call: plan(strategy)
[10:21:44.198] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.198] Searching for globals ... DONE
[10:21:44.198] Resolving globals: TRUE
[10:21:44.198] Resolving any globals that are futures ...
[10:21:44.198] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.198] Resolving any globals that are futures ... DONE
[10:21:44.199] plan(): nbrOfWorkers() = 2
[10:21:44.199] Resolving futures part of globals (recursively) ...
[10:21:44.200] resolve() on list ...
[10:21:44.200]  recursive: 99
[10:21:44.200]  length: 2
[10:21:44.200]  elements: ‘a’, ‘ii’
[10:21:44.200]  length: 1 (resolved future 1)
[10:21:44.200]  length: 0 (resolved future 2)
[10:21:44.201] resolve() on list ... DONE
[10:21:44.201] - globals: [2] ‘a’, ‘ii’
[10:21:44.201] Resolving futures part of globals (recursively) ... DONE
[10:21:44.201] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:44.202] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:44.202] - globals: [2] ‘a’, ‘ii’
[10:21:44.202] 
[10:21:44.202] getGlobalsAndPackages() ... DONE
[10:21:44.203] run() for ‘Future’ ...
[10:21:44.203] - state: ‘created’
[10:21:44.203] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.209] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.210] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.210]   - Field: ‘label’
[10:21:44.210]   - Field: ‘local’
[10:21:44.210]   - Field: ‘owner’
[10:21:44.211]   - Field: ‘envir’
[10:21:44.211]   - Field: ‘workers’
[10:21:44.211]   - Field: ‘packages’
[10:21:44.211]   - Field: ‘gc’
[10:21:44.211]   - Field: ‘job’
[10:21:44.211]   - Field: ‘conditions’
[10:21:44.212]   - Field: ‘expr’
[10:21:44.212]   - Field: ‘uuid’
[10:21:44.212]   - Field: ‘seed’
[10:21:44.212]   - Field: ‘version’
[10:21:44.212]   - Field: ‘result’
[10:21:44.212]   - Field: ‘asynchronous’
[10:21:44.213]   - Field: ‘calls’
[10:21:44.213]   - Field: ‘globals’
[10:21:44.213]   - Field: ‘stdout’
[10:21:44.213]   - Field: ‘earlySignal’
[10:21:44.213]   - Field: ‘lazy’
[10:21:44.214]   - Field: ‘state’
[10:21:44.214] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.214] - Launch lazy future ...
[10:21:44.215] Packages needed by the future expression (n = 0): <none>
[10:21:44.215] Packages needed by future strategies (n = 0): <none>
[10:21:44.216] {
[10:21:44.216]     {
[10:21:44.216]         {
[10:21:44.216]             ...future.startTime <- base::Sys.time()
[10:21:44.216]             {
[10:21:44.216]                 {
[10:21:44.216]                   {
[10:21:44.216]                     {
[10:21:44.216]                       base::local({
[10:21:44.216]                         has_future <- base::requireNamespace("future", 
[10:21:44.216]                           quietly = TRUE)
[10:21:44.216]                         if (has_future) {
[10:21:44.216]                           ns <- base::getNamespace("future")
[10:21:44.216]                           version <- ns[[".package"]][["version"]]
[10:21:44.216]                           if (is.null(version)) 
[10:21:44.216]                             version <- utils::packageVersion("future")
[10:21:44.216]                         }
[10:21:44.216]                         else {
[10:21:44.216]                           version <- NULL
[10:21:44.216]                         }
[10:21:44.216]                         if (!has_future || version < "1.8.0") {
[10:21:44.216]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.216]                             "", base::R.version$version.string), 
[10:21:44.216]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.216]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.216]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.216]                               "release", "version")], collapse = " "), 
[10:21:44.216]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.216]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.216]                             info)
[10:21:44.216]                           info <- base::paste(info, collapse = "; ")
[10:21:44.216]                           if (!has_future) {
[10:21:44.216]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.216]                               info)
[10:21:44.216]                           }
[10:21:44.216]                           else {
[10:21:44.216]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.216]                               info, version)
[10:21:44.216]                           }
[10:21:44.216]                           base::stop(msg)
[10:21:44.216]                         }
[10:21:44.216]                       })
[10:21:44.216]                     }
[10:21:44.216]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.216]                     base::options(mc.cores = 1L)
[10:21:44.216]                   }
[10:21:44.216]                   ...future.strategy.old <- future::plan("list")
[10:21:44.216]                   options(future.plan = NULL)
[10:21:44.216]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.216]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.216]                 }
[10:21:44.216]                 ...future.workdir <- getwd()
[10:21:44.216]             }
[10:21:44.216]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.216]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.216]         }
[10:21:44.216]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.216]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.216]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.216]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.216]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.216]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.216]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.216]             base::names(...future.oldOptions))
[10:21:44.216]     }
[10:21:44.216]     if (FALSE) {
[10:21:44.216]     }
[10:21:44.216]     else {
[10:21:44.216]         if (TRUE) {
[10:21:44.216]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.216]                 open = "w")
[10:21:44.216]         }
[10:21:44.216]         else {
[10:21:44.216]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.216]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.216]         }
[10:21:44.216]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.216]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.216]             base::sink(type = "output", split = FALSE)
[10:21:44.216]             base::close(...future.stdout)
[10:21:44.216]         }, add = TRUE)
[10:21:44.216]     }
[10:21:44.216]     ...future.frame <- base::sys.nframe()
[10:21:44.216]     ...future.conditions <- base::list()
[10:21:44.216]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.216]     if (FALSE) {
[10:21:44.216]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.216]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.216]     }
[10:21:44.216]     ...future.result <- base::tryCatch({
[10:21:44.216]         base::withCallingHandlers({
[10:21:44.216]             ...future.value <- base::withVisible(base::local({
[10:21:44.216]                 withCallingHandlers({
[10:21:44.216]                   {
[10:21:44.216]                     b <- a * ii
[10:21:44.216]                     a <- 0
[10:21:44.216]                     b
[10:21:44.216]                   }
[10:21:44.216]                 }, immediateCondition = function(cond) {
[10:21:44.216]                   save_rds <- function (object, pathname, ...) 
[10:21:44.216]                   {
[10:21:44.216]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.216]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.216]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.216]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.216]                         fi_tmp[["mtime"]])
[10:21:44.216]                     }
[10:21:44.216]                     tryCatch({
[10:21:44.216]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.216]                     }, error = function(ex) {
[10:21:44.216]                       msg <- conditionMessage(ex)
[10:21:44.216]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.216]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.216]                         fi_tmp[["mtime"]], msg)
[10:21:44.216]                       ex$message <- msg
[10:21:44.216]                       stop(ex)
[10:21:44.216]                     })
[10:21:44.216]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.216]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.216]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.216]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.216]                       fi <- file.info(pathname)
[10:21:44.216]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.216]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.216]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.216]                         fi[["size"]], fi[["mtime"]])
[10:21:44.216]                       stop(msg)
[10:21:44.216]                     }
[10:21:44.216]                     invisible(pathname)
[10:21:44.216]                   }
[10:21:44.216]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.216]                     rootPath = tempdir()) 
[10:21:44.216]                   {
[10:21:44.216]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.216]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.216]                       tmpdir = path, fileext = ".rds")
[10:21:44.216]                     save_rds(obj, file)
[10:21:44.216]                   }
[10:21:44.216]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.216]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.216]                   {
[10:21:44.216]                     inherits <- base::inherits
[10:21:44.216]                     invokeRestart <- base::invokeRestart
[10:21:44.216]                     is.null <- base::is.null
[10:21:44.216]                     muffled <- FALSE
[10:21:44.216]                     if (inherits(cond, "message")) {
[10:21:44.216]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.216]                       if (muffled) 
[10:21:44.216]                         invokeRestart("muffleMessage")
[10:21:44.216]                     }
[10:21:44.216]                     else if (inherits(cond, "warning")) {
[10:21:44.216]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.216]                       if (muffled) 
[10:21:44.216]                         invokeRestart("muffleWarning")
[10:21:44.216]                     }
[10:21:44.216]                     else if (inherits(cond, "condition")) {
[10:21:44.216]                       if (!is.null(pattern)) {
[10:21:44.216]                         computeRestarts <- base::computeRestarts
[10:21:44.216]                         grepl <- base::grepl
[10:21:44.216]                         restarts <- computeRestarts(cond)
[10:21:44.216]                         for (restart in restarts) {
[10:21:44.216]                           name <- restart$name
[10:21:44.216]                           if (is.null(name)) 
[10:21:44.216]                             next
[10:21:44.216]                           if (!grepl(pattern, name)) 
[10:21:44.216]                             next
[10:21:44.216]                           invokeRestart(restart)
[10:21:44.216]                           muffled <- TRUE
[10:21:44.216]                           break
[10:21:44.216]                         }
[10:21:44.216]                       }
[10:21:44.216]                     }
[10:21:44.216]                     invisible(muffled)
[10:21:44.216]                   }
[10:21:44.216]                   muffleCondition(cond)
[10:21:44.216]                 })
[10:21:44.216]             }))
[10:21:44.216]             future::FutureResult(value = ...future.value$value, 
[10:21:44.216]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.216]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.216]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.216]                     ...future.globalenv.names))
[10:21:44.216]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.216]         }, condition = base::local({
[10:21:44.216]             c <- base::c
[10:21:44.216]             inherits <- base::inherits
[10:21:44.216]             invokeRestart <- base::invokeRestart
[10:21:44.216]             length <- base::length
[10:21:44.216]             list <- base::list
[10:21:44.216]             seq.int <- base::seq.int
[10:21:44.216]             signalCondition <- base::signalCondition
[10:21:44.216]             sys.calls <- base::sys.calls
[10:21:44.216]             `[[` <- base::`[[`
[10:21:44.216]             `+` <- base::`+`
[10:21:44.216]             `<<-` <- base::`<<-`
[10:21:44.216]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.216]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.216]                   3L)]
[10:21:44.216]             }
[10:21:44.216]             function(cond) {
[10:21:44.216]                 is_error <- inherits(cond, "error")
[10:21:44.216]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.216]                   NULL)
[10:21:44.216]                 if (is_error) {
[10:21:44.216]                   sessionInformation <- function() {
[10:21:44.216]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.216]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.216]                       search = base::search(), system = base::Sys.info())
[10:21:44.216]                   }
[10:21:44.216]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.216]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.216]                     cond$call), session = sessionInformation(), 
[10:21:44.216]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.216]                   signalCondition(cond)
[10:21:44.216]                 }
[10:21:44.216]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.216]                 "immediateCondition"))) {
[10:21:44.216]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.216]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.216]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.216]                   if (TRUE && !signal) {
[10:21:44.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.216]                     {
[10:21:44.216]                       inherits <- base::inherits
[10:21:44.216]                       invokeRestart <- base::invokeRestart
[10:21:44.216]                       is.null <- base::is.null
[10:21:44.216]                       muffled <- FALSE
[10:21:44.216]                       if (inherits(cond, "message")) {
[10:21:44.216]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.216]                         if (muffled) 
[10:21:44.216]                           invokeRestart("muffleMessage")
[10:21:44.216]                       }
[10:21:44.216]                       else if (inherits(cond, "warning")) {
[10:21:44.216]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.216]                         if (muffled) 
[10:21:44.216]                           invokeRestart("muffleWarning")
[10:21:44.216]                       }
[10:21:44.216]                       else if (inherits(cond, "condition")) {
[10:21:44.216]                         if (!is.null(pattern)) {
[10:21:44.216]                           computeRestarts <- base::computeRestarts
[10:21:44.216]                           grepl <- base::grepl
[10:21:44.216]                           restarts <- computeRestarts(cond)
[10:21:44.216]                           for (restart in restarts) {
[10:21:44.216]                             name <- restart$name
[10:21:44.216]                             if (is.null(name)) 
[10:21:44.216]                               next
[10:21:44.216]                             if (!grepl(pattern, name)) 
[10:21:44.216]                               next
[10:21:44.216]                             invokeRestart(restart)
[10:21:44.216]                             muffled <- TRUE
[10:21:44.216]                             break
[10:21:44.216]                           }
[10:21:44.216]                         }
[10:21:44.216]                       }
[10:21:44.216]                       invisible(muffled)
[10:21:44.216]                     }
[10:21:44.216]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.216]                   }
[10:21:44.216]                 }
[10:21:44.216]                 else {
[10:21:44.216]                   if (TRUE) {
[10:21:44.216]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.216]                     {
[10:21:44.216]                       inherits <- base::inherits
[10:21:44.216]                       invokeRestart <- base::invokeRestart
[10:21:44.216]                       is.null <- base::is.null
[10:21:44.216]                       muffled <- FALSE
[10:21:44.216]                       if (inherits(cond, "message")) {
[10:21:44.216]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.216]                         if (muffled) 
[10:21:44.216]                           invokeRestart("muffleMessage")
[10:21:44.216]                       }
[10:21:44.216]                       else if (inherits(cond, "warning")) {
[10:21:44.216]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.216]                         if (muffled) 
[10:21:44.216]                           invokeRestart("muffleWarning")
[10:21:44.216]                       }
[10:21:44.216]                       else if (inherits(cond, "condition")) {
[10:21:44.216]                         if (!is.null(pattern)) {
[10:21:44.216]                           computeRestarts <- base::computeRestarts
[10:21:44.216]                           grepl <- base::grepl
[10:21:44.216]                           restarts <- computeRestarts(cond)
[10:21:44.216]                           for (restart in restarts) {
[10:21:44.216]                             name <- restart$name
[10:21:44.216]                             if (is.null(name)) 
[10:21:44.216]                               next
[10:21:44.216]                             if (!grepl(pattern, name)) 
[10:21:44.216]                               next
[10:21:44.216]                             invokeRestart(restart)
[10:21:44.216]                             muffled <- TRUE
[10:21:44.216]                             break
[10:21:44.216]                           }
[10:21:44.216]                         }
[10:21:44.216]                       }
[10:21:44.216]                       invisible(muffled)
[10:21:44.216]                     }
[10:21:44.216]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.216]                   }
[10:21:44.216]                 }
[10:21:44.216]             }
[10:21:44.216]         }))
[10:21:44.216]     }, error = function(ex) {
[10:21:44.216]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.216]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.216]                 ...future.rng), started = ...future.startTime, 
[10:21:44.216]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.216]             version = "1.8"), class = "FutureResult")
[10:21:44.216]     }, finally = {
[10:21:44.216]         if (!identical(...future.workdir, getwd())) 
[10:21:44.216]             setwd(...future.workdir)
[10:21:44.216]         {
[10:21:44.216]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.216]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.216]             }
[10:21:44.216]             base::options(...future.oldOptions)
[10:21:44.216]             if (.Platform$OS.type == "windows") {
[10:21:44.216]                 old_names <- names(...future.oldEnvVars)
[10:21:44.216]                 envs <- base::Sys.getenv()
[10:21:44.216]                 names <- names(envs)
[10:21:44.216]                 common <- intersect(names, old_names)
[10:21:44.216]                 added <- setdiff(names, old_names)
[10:21:44.216]                 removed <- setdiff(old_names, names)
[10:21:44.216]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.216]                   envs[common]]
[10:21:44.216]                 NAMES <- toupper(changed)
[10:21:44.216]                 args <- list()
[10:21:44.216]                 for (kk in seq_along(NAMES)) {
[10:21:44.216]                   name <- changed[[kk]]
[10:21:44.216]                   NAME <- NAMES[[kk]]
[10:21:44.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.216]                     next
[10:21:44.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.216]                 }
[10:21:44.216]                 NAMES <- toupper(added)
[10:21:44.216]                 for (kk in seq_along(NAMES)) {
[10:21:44.216]                   name <- added[[kk]]
[10:21:44.216]                   NAME <- NAMES[[kk]]
[10:21:44.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.216]                     next
[10:21:44.216]                   args[[name]] <- ""
[10:21:44.216]                 }
[10:21:44.216]                 NAMES <- toupper(removed)
[10:21:44.216]                 for (kk in seq_along(NAMES)) {
[10:21:44.216]                   name <- removed[[kk]]
[10:21:44.216]                   NAME <- NAMES[[kk]]
[10:21:44.216]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.216]                     next
[10:21:44.216]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.216]                 }
[10:21:44.216]                 if (length(args) > 0) 
[10:21:44.216]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.216]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.216]             }
[10:21:44.216]             else {
[10:21:44.216]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.216]             }
[10:21:44.216]             {
[10:21:44.216]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.216]                   0L) {
[10:21:44.216]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.216]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.216]                   base::options(opts)
[10:21:44.216]                 }
[10:21:44.216]                 {
[10:21:44.216]                   {
[10:21:44.216]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.216]                     NULL
[10:21:44.216]                   }
[10:21:44.216]                   options(future.plan = NULL)
[10:21:44.216]                   if (is.na(NA_character_)) 
[10:21:44.216]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.216]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.216]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.216]                     .init = FALSE)
[10:21:44.216]                 }
[10:21:44.216]             }
[10:21:44.216]         }
[10:21:44.216]     })
[10:21:44.216]     if (TRUE) {
[10:21:44.216]         base::sink(type = "output", split = FALSE)
[10:21:44.216]         if (TRUE) {
[10:21:44.216]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.216]         }
[10:21:44.216]         else {
[10:21:44.216]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.216]         }
[10:21:44.216]         base::close(...future.stdout)
[10:21:44.216]         ...future.stdout <- NULL
[10:21:44.216]     }
[10:21:44.216]     ...future.result$conditions <- ...future.conditions
[10:21:44.216]     ...future.result$finished <- base::Sys.time()
[10:21:44.216]     ...future.result
[10:21:44.216] }
[10:21:44.218] assign_globals() ...
[10:21:44.218] List of 2
[10:21:44.218]  $ a : num 1
[10:21:44.218]  $ ii: int 2
[10:21:44.218]  - attr(*, "where")=List of 2
[10:21:44.218]   ..$ a :<environment: R_EmptyEnv> 
[10:21:44.218]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:44.218]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.218]  - attr(*, "resolved")= logi TRUE
[10:21:44.218]  - attr(*, "total_size")= num 74
[10:21:44.218]  - attr(*, "already-done")= logi TRUE
[10:21:44.223] - copied ‘a’ to environment
[10:21:44.223] - copied ‘ii’ to environment
[10:21:44.223] assign_globals() ... done
[10:21:44.223] requestCore(): workers = 2
[10:21:44.226] MulticoreFuture started
[10:21:44.226] - Launch lazy future ... done
[10:21:44.226] run() for ‘MulticoreFuture’ ... done
[10:21:44.227] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.228] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.228] Searching for globals...
[10:21:44.227] List of future strategies:
[10:21:44.227] 1. sequential:
[10:21:44.227]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.227]    - tweaked: FALSE
[10:21:44.227]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.228] plan(): nbrOfWorkers() = 1
[10:21:44.230] plan(): Setting new future strategy stack:
[10:21:44.231] List of future strategies:
[10:21:44.231] 1. multicore:
[10:21:44.231]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.231]    - tweaked: FALSE
[10:21:44.231]    - call: plan(strategy)
[10:21:44.232] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.232] Searching for globals ... DONE
[10:21:44.232] Resolving globals: TRUE
[10:21:44.232] Resolving any globals that are futures ...
[10:21:44.233] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.233] Resolving any globals that are futures ... DONE
[10:21:44.234] Resolving futures part of globals (recursively) ...
[10:21:44.234] plan(): nbrOfWorkers() = 2
[10:21:44.234] resolve() on list ...
[10:21:44.234]  recursive: 99
[10:21:44.234]  length: 2
[10:21:44.235]  elements: ‘a’, ‘ii’
[10:21:44.235]  length: 1 (resolved future 1)
[10:21:44.235]  length: 0 (resolved future 2)
[10:21:44.235] resolve() on list ... DONE
[10:21:44.235] - globals: [2] ‘a’, ‘ii’
[10:21:44.235] Resolving futures part of globals (recursively) ... DONE
[10:21:44.236] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:44.236] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:44.236] - globals: [2] ‘a’, ‘ii’
[10:21:44.237] 
[10:21:44.237] getGlobalsAndPackages() ... DONE
[10:21:44.237] run() for ‘Future’ ...
[10:21:44.237] - state: ‘created’
[10:21:44.238] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.240] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.240] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.241]   - Field: ‘label’
[10:21:44.241]   - Field: ‘local’
[10:21:44.241]   - Field: ‘owner’
[10:21:44.241]   - Field: ‘envir’
[10:21:44.241]   - Field: ‘workers’
[10:21:44.241]   - Field: ‘packages’
[10:21:44.242]   - Field: ‘gc’
[10:21:44.242]   - Field: ‘job’
[10:21:44.242]   - Field: ‘conditions’
[10:21:44.242]   - Field: ‘expr’
[10:21:44.242]   - Field: ‘uuid’
[10:21:44.242]   - Field: ‘seed’
[10:21:44.242]   - Field: ‘version’
[10:21:44.242]   - Field: ‘result’
[10:21:44.243]   - Field: ‘asynchronous’
[10:21:44.243]   - Field: ‘calls’
[10:21:44.243]   - Field: ‘globals’
[10:21:44.243]   - Field: ‘stdout’
[10:21:44.243]   - Field: ‘earlySignal’
[10:21:44.243]   - Field: ‘lazy’
[10:21:44.243]   - Field: ‘state’
[10:21:44.244] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.244] - Launch lazy future ...
[10:21:44.244] Packages needed by the future expression (n = 0): <none>
[10:21:44.244] Packages needed by future strategies (n = 0): <none>
[10:21:44.245] {
[10:21:44.245]     {
[10:21:44.245]         {
[10:21:44.245]             ...future.startTime <- base::Sys.time()
[10:21:44.245]             {
[10:21:44.245]                 {
[10:21:44.245]                   {
[10:21:44.245]                     {
[10:21:44.245]                       base::local({
[10:21:44.245]                         has_future <- base::requireNamespace("future", 
[10:21:44.245]                           quietly = TRUE)
[10:21:44.245]                         if (has_future) {
[10:21:44.245]                           ns <- base::getNamespace("future")
[10:21:44.245]                           version <- ns[[".package"]][["version"]]
[10:21:44.245]                           if (is.null(version)) 
[10:21:44.245]                             version <- utils::packageVersion("future")
[10:21:44.245]                         }
[10:21:44.245]                         else {
[10:21:44.245]                           version <- NULL
[10:21:44.245]                         }
[10:21:44.245]                         if (!has_future || version < "1.8.0") {
[10:21:44.245]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.245]                             "", base::R.version$version.string), 
[10:21:44.245]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.245]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.245]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.245]                               "release", "version")], collapse = " "), 
[10:21:44.245]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.245]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.245]                             info)
[10:21:44.245]                           info <- base::paste(info, collapse = "; ")
[10:21:44.245]                           if (!has_future) {
[10:21:44.245]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.245]                               info)
[10:21:44.245]                           }
[10:21:44.245]                           else {
[10:21:44.245]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.245]                               info, version)
[10:21:44.245]                           }
[10:21:44.245]                           base::stop(msg)
[10:21:44.245]                         }
[10:21:44.245]                       })
[10:21:44.245]                     }
[10:21:44.245]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.245]                     base::options(mc.cores = 1L)
[10:21:44.245]                   }
[10:21:44.245]                   ...future.strategy.old <- future::plan("list")
[10:21:44.245]                   options(future.plan = NULL)
[10:21:44.245]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.245]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.245]                 }
[10:21:44.245]                 ...future.workdir <- getwd()
[10:21:44.245]             }
[10:21:44.245]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.245]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.245]         }
[10:21:44.245]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.245]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.245]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.245]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.245]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.245]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.245]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.245]             base::names(...future.oldOptions))
[10:21:44.245]     }
[10:21:44.245]     if (FALSE) {
[10:21:44.245]     }
[10:21:44.245]     else {
[10:21:44.245]         if (TRUE) {
[10:21:44.245]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.245]                 open = "w")
[10:21:44.245]         }
[10:21:44.245]         else {
[10:21:44.245]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.245]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.245]         }
[10:21:44.245]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.245]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.245]             base::sink(type = "output", split = FALSE)
[10:21:44.245]             base::close(...future.stdout)
[10:21:44.245]         }, add = TRUE)
[10:21:44.245]     }
[10:21:44.245]     ...future.frame <- base::sys.nframe()
[10:21:44.245]     ...future.conditions <- base::list()
[10:21:44.245]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.245]     if (FALSE) {
[10:21:44.245]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.245]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.245]     }
[10:21:44.245]     ...future.result <- base::tryCatch({
[10:21:44.245]         base::withCallingHandlers({
[10:21:44.245]             ...future.value <- base::withVisible(base::local({
[10:21:44.245]                 withCallingHandlers({
[10:21:44.245]                   {
[10:21:44.245]                     b <- a * ii
[10:21:44.245]                     a <- 0
[10:21:44.245]                     b
[10:21:44.245]                   }
[10:21:44.245]                 }, immediateCondition = function(cond) {
[10:21:44.245]                   save_rds <- function (object, pathname, ...) 
[10:21:44.245]                   {
[10:21:44.245]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.245]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.245]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.245]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.245]                         fi_tmp[["mtime"]])
[10:21:44.245]                     }
[10:21:44.245]                     tryCatch({
[10:21:44.245]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.245]                     }, error = function(ex) {
[10:21:44.245]                       msg <- conditionMessage(ex)
[10:21:44.245]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.245]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.245]                         fi_tmp[["mtime"]], msg)
[10:21:44.245]                       ex$message <- msg
[10:21:44.245]                       stop(ex)
[10:21:44.245]                     })
[10:21:44.245]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.245]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.245]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.245]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.245]                       fi <- file.info(pathname)
[10:21:44.245]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.245]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.245]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.245]                         fi[["size"]], fi[["mtime"]])
[10:21:44.245]                       stop(msg)
[10:21:44.245]                     }
[10:21:44.245]                     invisible(pathname)
[10:21:44.245]                   }
[10:21:44.245]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.245]                     rootPath = tempdir()) 
[10:21:44.245]                   {
[10:21:44.245]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.245]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.245]                       tmpdir = path, fileext = ".rds")
[10:21:44.245]                     save_rds(obj, file)
[10:21:44.245]                   }
[10:21:44.245]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.245]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.245]                   {
[10:21:44.245]                     inherits <- base::inherits
[10:21:44.245]                     invokeRestart <- base::invokeRestart
[10:21:44.245]                     is.null <- base::is.null
[10:21:44.245]                     muffled <- FALSE
[10:21:44.245]                     if (inherits(cond, "message")) {
[10:21:44.245]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.245]                       if (muffled) 
[10:21:44.245]                         invokeRestart("muffleMessage")
[10:21:44.245]                     }
[10:21:44.245]                     else if (inherits(cond, "warning")) {
[10:21:44.245]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.245]                       if (muffled) 
[10:21:44.245]                         invokeRestart("muffleWarning")
[10:21:44.245]                     }
[10:21:44.245]                     else if (inherits(cond, "condition")) {
[10:21:44.245]                       if (!is.null(pattern)) {
[10:21:44.245]                         computeRestarts <- base::computeRestarts
[10:21:44.245]                         grepl <- base::grepl
[10:21:44.245]                         restarts <- computeRestarts(cond)
[10:21:44.245]                         for (restart in restarts) {
[10:21:44.245]                           name <- restart$name
[10:21:44.245]                           if (is.null(name)) 
[10:21:44.245]                             next
[10:21:44.245]                           if (!grepl(pattern, name)) 
[10:21:44.245]                             next
[10:21:44.245]                           invokeRestart(restart)
[10:21:44.245]                           muffled <- TRUE
[10:21:44.245]                           break
[10:21:44.245]                         }
[10:21:44.245]                       }
[10:21:44.245]                     }
[10:21:44.245]                     invisible(muffled)
[10:21:44.245]                   }
[10:21:44.245]                   muffleCondition(cond)
[10:21:44.245]                 })
[10:21:44.245]             }))
[10:21:44.245]             future::FutureResult(value = ...future.value$value, 
[10:21:44.245]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.245]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.245]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.245]                     ...future.globalenv.names))
[10:21:44.245]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.245]         }, condition = base::local({
[10:21:44.245]             c <- base::c
[10:21:44.245]             inherits <- base::inherits
[10:21:44.245]             invokeRestart <- base::invokeRestart
[10:21:44.245]             length <- base::length
[10:21:44.245]             list <- base::list
[10:21:44.245]             seq.int <- base::seq.int
[10:21:44.245]             signalCondition <- base::signalCondition
[10:21:44.245]             sys.calls <- base::sys.calls
[10:21:44.245]             `[[` <- base::`[[`
[10:21:44.245]             `+` <- base::`+`
[10:21:44.245]             `<<-` <- base::`<<-`
[10:21:44.245]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.245]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.245]                   3L)]
[10:21:44.245]             }
[10:21:44.245]             function(cond) {
[10:21:44.245]                 is_error <- inherits(cond, "error")
[10:21:44.245]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.245]                   NULL)
[10:21:44.245]                 if (is_error) {
[10:21:44.245]                   sessionInformation <- function() {
[10:21:44.245]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.245]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.245]                       search = base::search(), system = base::Sys.info())
[10:21:44.245]                   }
[10:21:44.245]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.245]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.245]                     cond$call), session = sessionInformation(), 
[10:21:44.245]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.245]                   signalCondition(cond)
[10:21:44.245]                 }
[10:21:44.245]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.245]                 "immediateCondition"))) {
[10:21:44.245]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.245]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.245]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.245]                   if (TRUE && !signal) {
[10:21:44.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.245]                     {
[10:21:44.245]                       inherits <- base::inherits
[10:21:44.245]                       invokeRestart <- base::invokeRestart
[10:21:44.245]                       is.null <- base::is.null
[10:21:44.245]                       muffled <- FALSE
[10:21:44.245]                       if (inherits(cond, "message")) {
[10:21:44.245]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.245]                         if (muffled) 
[10:21:44.245]                           invokeRestart("muffleMessage")
[10:21:44.245]                       }
[10:21:44.245]                       else if (inherits(cond, "warning")) {
[10:21:44.245]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.245]                         if (muffled) 
[10:21:44.245]                           invokeRestart("muffleWarning")
[10:21:44.245]                       }
[10:21:44.245]                       else if (inherits(cond, "condition")) {
[10:21:44.245]                         if (!is.null(pattern)) {
[10:21:44.245]                           computeRestarts <- base::computeRestarts
[10:21:44.245]                           grepl <- base::grepl
[10:21:44.245]                           restarts <- computeRestarts(cond)
[10:21:44.245]                           for (restart in restarts) {
[10:21:44.245]                             name <- restart$name
[10:21:44.245]                             if (is.null(name)) 
[10:21:44.245]                               next
[10:21:44.245]                             if (!grepl(pattern, name)) 
[10:21:44.245]                               next
[10:21:44.245]                             invokeRestart(restart)
[10:21:44.245]                             muffled <- TRUE
[10:21:44.245]                             break
[10:21:44.245]                           }
[10:21:44.245]                         }
[10:21:44.245]                       }
[10:21:44.245]                       invisible(muffled)
[10:21:44.245]                     }
[10:21:44.245]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.245]                   }
[10:21:44.245]                 }
[10:21:44.245]                 else {
[10:21:44.245]                   if (TRUE) {
[10:21:44.245]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.245]                     {
[10:21:44.245]                       inherits <- base::inherits
[10:21:44.245]                       invokeRestart <- base::invokeRestart
[10:21:44.245]                       is.null <- base::is.null
[10:21:44.245]                       muffled <- FALSE
[10:21:44.245]                       if (inherits(cond, "message")) {
[10:21:44.245]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.245]                         if (muffled) 
[10:21:44.245]                           invokeRestart("muffleMessage")
[10:21:44.245]                       }
[10:21:44.245]                       else if (inherits(cond, "warning")) {
[10:21:44.245]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.245]                         if (muffled) 
[10:21:44.245]                           invokeRestart("muffleWarning")
[10:21:44.245]                       }
[10:21:44.245]                       else if (inherits(cond, "condition")) {
[10:21:44.245]                         if (!is.null(pattern)) {
[10:21:44.245]                           computeRestarts <- base::computeRestarts
[10:21:44.245]                           grepl <- base::grepl
[10:21:44.245]                           restarts <- computeRestarts(cond)
[10:21:44.245]                           for (restart in restarts) {
[10:21:44.245]                             name <- restart$name
[10:21:44.245]                             if (is.null(name)) 
[10:21:44.245]                               next
[10:21:44.245]                             if (!grepl(pattern, name)) 
[10:21:44.245]                               next
[10:21:44.245]                             invokeRestart(restart)
[10:21:44.245]                             muffled <- TRUE
[10:21:44.245]                             break
[10:21:44.245]                           }
[10:21:44.245]                         }
[10:21:44.245]                       }
[10:21:44.245]                       invisible(muffled)
[10:21:44.245]                     }
[10:21:44.245]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.245]                   }
[10:21:44.245]                 }
[10:21:44.245]             }
[10:21:44.245]         }))
[10:21:44.245]     }, error = function(ex) {
[10:21:44.245]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.245]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.245]                 ...future.rng), started = ...future.startTime, 
[10:21:44.245]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.245]             version = "1.8"), class = "FutureResult")
[10:21:44.245]     }, finally = {
[10:21:44.245]         if (!identical(...future.workdir, getwd())) 
[10:21:44.245]             setwd(...future.workdir)
[10:21:44.245]         {
[10:21:44.245]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.245]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.245]             }
[10:21:44.245]             base::options(...future.oldOptions)
[10:21:44.245]             if (.Platform$OS.type == "windows") {
[10:21:44.245]                 old_names <- names(...future.oldEnvVars)
[10:21:44.245]                 envs <- base::Sys.getenv()
[10:21:44.245]                 names <- names(envs)
[10:21:44.245]                 common <- intersect(names, old_names)
[10:21:44.245]                 added <- setdiff(names, old_names)
[10:21:44.245]                 removed <- setdiff(old_names, names)
[10:21:44.245]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.245]                   envs[common]]
[10:21:44.245]                 NAMES <- toupper(changed)
[10:21:44.245]                 args <- list()
[10:21:44.245]                 for (kk in seq_along(NAMES)) {
[10:21:44.245]                   name <- changed[[kk]]
[10:21:44.245]                   NAME <- NAMES[[kk]]
[10:21:44.245]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.245]                     next
[10:21:44.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.245]                 }
[10:21:44.245]                 NAMES <- toupper(added)
[10:21:44.245]                 for (kk in seq_along(NAMES)) {
[10:21:44.245]                   name <- added[[kk]]
[10:21:44.245]                   NAME <- NAMES[[kk]]
[10:21:44.245]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.245]                     next
[10:21:44.245]                   args[[name]] <- ""
[10:21:44.245]                 }
[10:21:44.245]                 NAMES <- toupper(removed)
[10:21:44.245]                 for (kk in seq_along(NAMES)) {
[10:21:44.245]                   name <- removed[[kk]]
[10:21:44.245]                   NAME <- NAMES[[kk]]
[10:21:44.245]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.245]                     next
[10:21:44.245]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.245]                 }
[10:21:44.245]                 if (length(args) > 0) 
[10:21:44.245]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.245]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.245]             }
[10:21:44.245]             else {
[10:21:44.245]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.245]             }
[10:21:44.245]             {
[10:21:44.245]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.245]                   0L) {
[10:21:44.245]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.245]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.245]                   base::options(opts)
[10:21:44.245]                 }
[10:21:44.245]                 {
[10:21:44.245]                   {
[10:21:44.245]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.245]                     NULL
[10:21:44.245]                   }
[10:21:44.245]                   options(future.plan = NULL)
[10:21:44.245]                   if (is.na(NA_character_)) 
[10:21:44.245]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.245]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.245]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.245]                     .init = FALSE)
[10:21:44.245]                 }
[10:21:44.245]             }
[10:21:44.245]         }
[10:21:44.245]     })
[10:21:44.245]     if (TRUE) {
[10:21:44.245]         base::sink(type = "output", split = FALSE)
[10:21:44.245]         if (TRUE) {
[10:21:44.245]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.245]         }
[10:21:44.245]         else {
[10:21:44.245]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.245]         }
[10:21:44.245]         base::close(...future.stdout)
[10:21:44.245]         ...future.stdout <- NULL
[10:21:44.245]     }
[10:21:44.245]     ...future.result$conditions <- ...future.conditions
[10:21:44.245]     ...future.result$finished <- base::Sys.time()
[10:21:44.245]     ...future.result
[10:21:44.245] }
[10:21:44.248] assign_globals() ...
[10:21:44.248] List of 2
[10:21:44.248]  $ a : num 1
[10:21:44.248]  $ ii: int 3
[10:21:44.248]  - attr(*, "where")=List of 2
[10:21:44.248]   ..$ a :<environment: R_EmptyEnv> 
[10:21:44.248]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:44.248]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.248]  - attr(*, "resolved")= logi TRUE
[10:21:44.248]  - attr(*, "total_size")= num 74
[10:21:44.248]  - attr(*, "already-done")= logi TRUE
[10:21:44.257] - copied ‘a’ to environment
[10:21:44.258] - copied ‘ii’ to environment
[10:21:44.258] assign_globals() ... done
[10:21:44.258] requestCore(): workers = 2
[10:21:44.259] Poll #1 (0): usedCores() = 2, workers = 2
[10:21:44.280] result() for MulticoreFuture ...
[10:21:44.281] result() for MulticoreFuture ...
[10:21:44.281] result() for MulticoreFuture ... done
[10:21:44.281] result() for MulticoreFuture ... done
[10:21:44.281] result() for MulticoreFuture ...
[10:21:44.281] result() for MulticoreFuture ... done
[10:21:44.284] MulticoreFuture started
[10:21:44.284] - Launch lazy future ... done
[10:21:44.285] run() for ‘MulticoreFuture’ ... done
[10:21:44.285] plan(): Setting new future strategy stack:
[10:21:44.285] result() for MulticoreFuture ...
[10:21:44.286] result() for MulticoreFuture ... done
[10:21:44.286] result() for MulticoreFuture ...
[10:21:44.286] result() for MulticoreFuture ... done
[10:21:44.286] result() for MulticoreFuture ...
[10:21:44.286] List of future strategies:
[10:21:44.286] 1. sequential:
[10:21:44.286]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.286]    - tweaked: FALSE
[10:21:44.286]    - call: NULL
[10:21:44.287] plan(): nbrOfWorkers() = 1
[10:21:44.288] result() for MulticoreFuture ...
[10:21:44.288] result() for MulticoreFuture ... done
[10:21:44.288] result() for MulticoreFuture ... done
[10:21:44.289] result() for MulticoreFuture ...
[10:21:44.289] result() for MulticoreFuture ... done
[10:21:44.289] result() for MulticoreFuture ...
[10:21:44.290] plan(): Setting new future strategy stack:
[10:21:44.290] List of future strategies:
[10:21:44.290] 1. multicore:
[10:21:44.290]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.290]    - tweaked: FALSE
[10:21:44.290]    - call: plan(strategy)
[10:21:44.293] plan(): nbrOfWorkers() = 2
[10:21:44.294] result() for MulticoreFuture ...
[10:21:44.294] result() for MulticoreFuture ... done
[10:21:44.294] result() for MulticoreFuture ... done
[10:21:44.294] result() for MulticoreFuture ...
[10:21:44.294] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.296] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.296] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.303] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.303] Searching for globals ... DONE
[10:21:44.303] Resolving globals: TRUE
[10:21:44.303] Resolving any globals that are futures ...
[10:21:44.303] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.304] Resolving any globals that are futures ... DONE
[10:21:44.304] Resolving futures part of globals (recursively) ...
[10:21:44.304] resolve() on list ...
[10:21:44.305]  recursive: 99
[10:21:44.305]  length: 2
[10:21:44.305]  elements: ‘a’, ‘ii’
[10:21:44.305]  length: 1 (resolved future 1)
[10:21:44.305]  length: 0 (resolved future 2)
[10:21:44.305] resolve() on list ... DONE
[10:21:44.306] - globals: [2] ‘a’, ‘ii’
[10:21:44.306] Resolving futures part of globals (recursively) ... DONE
[10:21:44.306] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:44.306] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:44.307] - globals: [2] ‘a’, ‘ii’
[10:21:44.307] 
[10:21:44.307] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.308] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.308] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.311] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.311] Searching for globals ... DONE
[10:21:44.311] Resolving globals: TRUE
[10:21:44.311] Resolving any globals that are futures ...
[10:21:44.311] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.311] Resolving any globals that are futures ... DONE
[10:21:44.312] Resolving futures part of globals (recursively) ...
[10:21:44.312] resolve() on list ...
[10:21:44.312]  recursive: 99
[10:21:44.312]  length: 2
[10:21:44.312]  elements: ‘a’, ‘ii’
[10:21:44.312]  length: 1 (resolved future 1)
[10:21:44.313]  length: 0 (resolved future 2)
[10:21:44.313] resolve() on list ... DONE
[10:21:44.313] - globals: [2] ‘a’, ‘ii’
[10:21:44.313] Resolving futures part of globals (recursively) ... DONE
[10:21:44.313] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:44.313] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:44.314] - globals: [2] ‘a’, ‘ii’
[10:21:44.314] 
[10:21:44.314] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.315] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.315] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.317] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.317] Searching for globals ... DONE
[10:21:44.317] Resolving globals: TRUE
[10:21:44.317] Resolving any globals that are futures ...
[10:21:44.317] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:44.317] Resolving any globals that are futures ... DONE
[10:21:44.318] Resolving futures part of globals (recursively) ...
[10:21:44.318] resolve() on list ...
[10:21:44.318]  recursive: 99
[10:21:44.318]  length: 2
[10:21:44.318]  elements: ‘a’, ‘ii’
[10:21:44.318]  length: 1 (resolved future 1)
[10:21:44.319]  length: 0 (resolved future 2)
[10:21:44.319] resolve() on list ... DONE
[10:21:44.319] - globals: [2] ‘a’, ‘ii’
[10:21:44.319] Resolving futures part of globals (recursively) ... DONE
[10:21:44.319] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:44.319] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:44.319] - globals: [2] ‘a’, ‘ii’
[10:21:44.320] 
[10:21:44.320] getGlobalsAndPackages() ... DONE
[10:21:44.320] run() for ‘Future’ ...
[10:21:44.320] - state: ‘created’
[10:21:44.320] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.322] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.322] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.322]   - Field: ‘label’
[10:21:44.322]   - Field: ‘local’
[10:21:44.323]   - Field: ‘owner’
[10:21:44.323]   - Field: ‘envir’
[10:21:44.323]   - Field: ‘workers’
[10:21:44.323]   - Field: ‘packages’
[10:21:44.323]   - Field: ‘gc’
[10:21:44.323]   - Field: ‘job’
[10:21:44.323]   - Field: ‘conditions’
[10:21:44.323]   - Field: ‘expr’
[10:21:44.323]   - Field: ‘uuid’
[10:21:44.323]   - Field: ‘seed’
[10:21:44.323]   - Field: ‘version’
[10:21:44.324]   - Field: ‘result’
[10:21:44.324]   - Field: ‘asynchronous’
[10:21:44.324]   - Field: ‘calls’
[10:21:44.324]   - Field: ‘globals’
[10:21:44.324]   - Field: ‘stdout’
[10:21:44.324]   - Field: ‘earlySignal’
[10:21:44.324]   - Field: ‘lazy’
[10:21:44.324]   - Field: ‘state’
[10:21:44.324] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.324] - Launch lazy future ...
[10:21:44.325] Packages needed by the future expression (n = 0): <none>
[10:21:44.325] Packages needed by future strategies (n = 0): <none>
[10:21:44.327] {
[10:21:44.327]     {
[10:21:44.327]         {
[10:21:44.327]             ...future.startTime <- base::Sys.time()
[10:21:44.327]             {
[10:21:44.327]                 {
[10:21:44.327]                   {
[10:21:44.327]                     {
[10:21:44.327]                       base::local({
[10:21:44.327]                         has_future <- base::requireNamespace("future", 
[10:21:44.327]                           quietly = TRUE)
[10:21:44.327]                         if (has_future) {
[10:21:44.327]                           ns <- base::getNamespace("future")
[10:21:44.327]                           version <- ns[[".package"]][["version"]]
[10:21:44.327]                           if (is.null(version)) 
[10:21:44.327]                             version <- utils::packageVersion("future")
[10:21:44.327]                         }
[10:21:44.327]                         else {
[10:21:44.327]                           version <- NULL
[10:21:44.327]                         }
[10:21:44.327]                         if (!has_future || version < "1.8.0") {
[10:21:44.327]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.327]                             "", base::R.version$version.string), 
[10:21:44.327]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.327]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.327]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.327]                               "release", "version")], collapse = " "), 
[10:21:44.327]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.327]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.327]                             info)
[10:21:44.327]                           info <- base::paste(info, collapse = "; ")
[10:21:44.327]                           if (!has_future) {
[10:21:44.327]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.327]                               info)
[10:21:44.327]                           }
[10:21:44.327]                           else {
[10:21:44.327]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.327]                               info, version)
[10:21:44.327]                           }
[10:21:44.327]                           base::stop(msg)
[10:21:44.327]                         }
[10:21:44.327]                       })
[10:21:44.327]                     }
[10:21:44.327]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.327]                     base::options(mc.cores = 1L)
[10:21:44.327]                   }
[10:21:44.327]                   ...future.strategy.old <- future::plan("list")
[10:21:44.327]                   options(future.plan = NULL)
[10:21:44.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.327]                 }
[10:21:44.327]                 ...future.workdir <- getwd()
[10:21:44.327]             }
[10:21:44.327]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.327]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.327]         }
[10:21:44.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.327]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.327]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.327]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.327]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.327]             base::names(...future.oldOptions))
[10:21:44.327]     }
[10:21:44.327]     if (FALSE) {
[10:21:44.327]     }
[10:21:44.327]     else {
[10:21:44.327]         if (TRUE) {
[10:21:44.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.327]                 open = "w")
[10:21:44.327]         }
[10:21:44.327]         else {
[10:21:44.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.327]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.327]         }
[10:21:44.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.327]             base::sink(type = "output", split = FALSE)
[10:21:44.327]             base::close(...future.stdout)
[10:21:44.327]         }, add = TRUE)
[10:21:44.327]     }
[10:21:44.327]     ...future.frame <- base::sys.nframe()
[10:21:44.327]     ...future.conditions <- base::list()
[10:21:44.327]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.327]     if (FALSE) {
[10:21:44.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.327]     }
[10:21:44.327]     ...future.result <- base::tryCatch({
[10:21:44.327]         base::withCallingHandlers({
[10:21:44.327]             ...future.value <- base::withVisible(base::local({
[10:21:44.327]                 withCallingHandlers({
[10:21:44.327]                   {
[10:21:44.327]                     b <- a * ii
[10:21:44.327]                     a <- 0
[10:21:44.327]                     b
[10:21:44.327]                   }
[10:21:44.327]                 }, immediateCondition = function(cond) {
[10:21:44.327]                   save_rds <- function (object, pathname, ...) 
[10:21:44.327]                   {
[10:21:44.327]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.327]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.327]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.327]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.327]                         fi_tmp[["mtime"]])
[10:21:44.327]                     }
[10:21:44.327]                     tryCatch({
[10:21:44.327]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.327]                     }, error = function(ex) {
[10:21:44.327]                       msg <- conditionMessage(ex)
[10:21:44.327]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.327]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.327]                         fi_tmp[["mtime"]], msg)
[10:21:44.327]                       ex$message <- msg
[10:21:44.327]                       stop(ex)
[10:21:44.327]                     })
[10:21:44.327]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.327]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.327]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.327]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.327]                       fi <- file.info(pathname)
[10:21:44.327]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.327]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.327]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.327]                         fi[["size"]], fi[["mtime"]])
[10:21:44.327]                       stop(msg)
[10:21:44.327]                     }
[10:21:44.327]                     invisible(pathname)
[10:21:44.327]                   }
[10:21:44.327]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.327]                     rootPath = tempdir()) 
[10:21:44.327]                   {
[10:21:44.327]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.327]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.327]                       tmpdir = path, fileext = ".rds")
[10:21:44.327]                     save_rds(obj, file)
[10:21:44.327]                   }
[10:21:44.327]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.327]                   {
[10:21:44.327]                     inherits <- base::inherits
[10:21:44.327]                     invokeRestart <- base::invokeRestart
[10:21:44.327]                     is.null <- base::is.null
[10:21:44.327]                     muffled <- FALSE
[10:21:44.327]                     if (inherits(cond, "message")) {
[10:21:44.327]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.327]                       if (muffled) 
[10:21:44.327]                         invokeRestart("muffleMessage")
[10:21:44.327]                     }
[10:21:44.327]                     else if (inherits(cond, "warning")) {
[10:21:44.327]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.327]                       if (muffled) 
[10:21:44.327]                         invokeRestart("muffleWarning")
[10:21:44.327]                     }
[10:21:44.327]                     else if (inherits(cond, "condition")) {
[10:21:44.327]                       if (!is.null(pattern)) {
[10:21:44.327]                         computeRestarts <- base::computeRestarts
[10:21:44.327]                         grepl <- base::grepl
[10:21:44.327]                         restarts <- computeRestarts(cond)
[10:21:44.327]                         for (restart in restarts) {
[10:21:44.327]                           name <- restart$name
[10:21:44.327]                           if (is.null(name)) 
[10:21:44.327]                             next
[10:21:44.327]                           if (!grepl(pattern, name)) 
[10:21:44.327]                             next
[10:21:44.327]                           invokeRestart(restart)
[10:21:44.327]                           muffled <- TRUE
[10:21:44.327]                           break
[10:21:44.327]                         }
[10:21:44.327]                       }
[10:21:44.327]                     }
[10:21:44.327]                     invisible(muffled)
[10:21:44.327]                   }
[10:21:44.327]                   muffleCondition(cond)
[10:21:44.327]                 })
[10:21:44.327]             }))
[10:21:44.327]             future::FutureResult(value = ...future.value$value, 
[10:21:44.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.327]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.327]                     ...future.globalenv.names))
[10:21:44.327]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.327]         }, condition = base::local({
[10:21:44.327]             c <- base::c
[10:21:44.327]             inherits <- base::inherits
[10:21:44.327]             invokeRestart <- base::invokeRestart
[10:21:44.327]             length <- base::length
[10:21:44.327]             list <- base::list
[10:21:44.327]             seq.int <- base::seq.int
[10:21:44.327]             signalCondition <- base::signalCondition
[10:21:44.327]             sys.calls <- base::sys.calls
[10:21:44.327]             `[[` <- base::`[[`
[10:21:44.327]             `+` <- base::`+`
[10:21:44.327]             `<<-` <- base::`<<-`
[10:21:44.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.327]                   3L)]
[10:21:44.327]             }
[10:21:44.327]             function(cond) {
[10:21:44.327]                 is_error <- inherits(cond, "error")
[10:21:44.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.327]                   NULL)
[10:21:44.327]                 if (is_error) {
[10:21:44.327]                   sessionInformation <- function() {
[10:21:44.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.327]                       search = base::search(), system = base::Sys.info())
[10:21:44.327]                   }
[10:21:44.327]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.327]                     cond$call), session = sessionInformation(), 
[10:21:44.327]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.327]                   signalCondition(cond)
[10:21:44.327]                 }
[10:21:44.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.327]                 "immediateCondition"))) {
[10:21:44.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.327]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.327]                   if (TRUE && !signal) {
[10:21:44.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.327]                     {
[10:21:44.327]                       inherits <- base::inherits
[10:21:44.327]                       invokeRestart <- base::invokeRestart
[10:21:44.327]                       is.null <- base::is.null
[10:21:44.327]                       muffled <- FALSE
[10:21:44.327]                       if (inherits(cond, "message")) {
[10:21:44.327]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.327]                         if (muffled) 
[10:21:44.327]                           invokeRestart("muffleMessage")
[10:21:44.327]                       }
[10:21:44.327]                       else if (inherits(cond, "warning")) {
[10:21:44.327]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.327]                         if (muffled) 
[10:21:44.327]                           invokeRestart("muffleWarning")
[10:21:44.327]                       }
[10:21:44.327]                       else if (inherits(cond, "condition")) {
[10:21:44.327]                         if (!is.null(pattern)) {
[10:21:44.327]                           computeRestarts <- base::computeRestarts
[10:21:44.327]                           grepl <- base::grepl
[10:21:44.327]                           restarts <- computeRestarts(cond)
[10:21:44.327]                           for (restart in restarts) {
[10:21:44.327]                             name <- restart$name
[10:21:44.327]                             if (is.null(name)) 
[10:21:44.327]                               next
[10:21:44.327]                             if (!grepl(pattern, name)) 
[10:21:44.327]                               next
[10:21:44.327]                             invokeRestart(restart)
[10:21:44.327]                             muffled <- TRUE
[10:21:44.327]                             break
[10:21:44.327]                           }
[10:21:44.327]                         }
[10:21:44.327]                       }
[10:21:44.327]                       invisible(muffled)
[10:21:44.327]                     }
[10:21:44.327]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.327]                   }
[10:21:44.327]                 }
[10:21:44.327]                 else {
[10:21:44.327]                   if (TRUE) {
[10:21:44.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.327]                     {
[10:21:44.327]                       inherits <- base::inherits
[10:21:44.327]                       invokeRestart <- base::invokeRestart
[10:21:44.327]                       is.null <- base::is.null
[10:21:44.327]                       muffled <- FALSE
[10:21:44.327]                       if (inherits(cond, "message")) {
[10:21:44.327]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.327]                         if (muffled) 
[10:21:44.327]                           invokeRestart("muffleMessage")
[10:21:44.327]                       }
[10:21:44.327]                       else if (inherits(cond, "warning")) {
[10:21:44.327]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.327]                         if (muffled) 
[10:21:44.327]                           invokeRestart("muffleWarning")
[10:21:44.327]                       }
[10:21:44.327]                       else if (inherits(cond, "condition")) {
[10:21:44.327]                         if (!is.null(pattern)) {
[10:21:44.327]                           computeRestarts <- base::computeRestarts
[10:21:44.327]                           grepl <- base::grepl
[10:21:44.327]                           restarts <- computeRestarts(cond)
[10:21:44.327]                           for (restart in restarts) {
[10:21:44.327]                             name <- restart$name
[10:21:44.327]                             if (is.null(name)) 
[10:21:44.327]                               next
[10:21:44.327]                             if (!grepl(pattern, name)) 
[10:21:44.327]                               next
[10:21:44.327]                             invokeRestart(restart)
[10:21:44.327]                             muffled <- TRUE
[10:21:44.327]                             break
[10:21:44.327]                           }
[10:21:44.327]                         }
[10:21:44.327]                       }
[10:21:44.327]                       invisible(muffled)
[10:21:44.327]                     }
[10:21:44.327]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.327]                   }
[10:21:44.327]                 }
[10:21:44.327]             }
[10:21:44.327]         }))
[10:21:44.327]     }, error = function(ex) {
[10:21:44.327]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.327]                 ...future.rng), started = ...future.startTime, 
[10:21:44.327]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.327]             version = "1.8"), class = "FutureResult")
[10:21:44.327]     }, finally = {
[10:21:44.327]         if (!identical(...future.workdir, getwd())) 
[10:21:44.327]             setwd(...future.workdir)
[10:21:44.327]         {
[10:21:44.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.327]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.327]             }
[10:21:44.327]             base::options(...future.oldOptions)
[10:21:44.327]             if (.Platform$OS.type == "windows") {
[10:21:44.327]                 old_names <- names(...future.oldEnvVars)
[10:21:44.327]                 envs <- base::Sys.getenv()
[10:21:44.327]                 names <- names(envs)
[10:21:44.327]                 common <- intersect(names, old_names)
[10:21:44.327]                 added <- setdiff(names, old_names)
[10:21:44.327]                 removed <- setdiff(old_names, names)
[10:21:44.327]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.327]                   envs[common]]
[10:21:44.327]                 NAMES <- toupper(changed)
[10:21:44.327]                 args <- list()
[10:21:44.327]                 for (kk in seq_along(NAMES)) {
[10:21:44.327]                   name <- changed[[kk]]
[10:21:44.327]                   NAME <- NAMES[[kk]]
[10:21:44.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.327]                     next
[10:21:44.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.327]                 }
[10:21:44.327]                 NAMES <- toupper(added)
[10:21:44.327]                 for (kk in seq_along(NAMES)) {
[10:21:44.327]                   name <- added[[kk]]
[10:21:44.327]                   NAME <- NAMES[[kk]]
[10:21:44.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.327]                     next
[10:21:44.327]                   args[[name]] <- ""
[10:21:44.327]                 }
[10:21:44.327]                 NAMES <- toupper(removed)
[10:21:44.327]                 for (kk in seq_along(NAMES)) {
[10:21:44.327]                   name <- removed[[kk]]
[10:21:44.327]                   NAME <- NAMES[[kk]]
[10:21:44.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.327]                     next
[10:21:44.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.327]                 }
[10:21:44.327]                 if (length(args) > 0) 
[10:21:44.327]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.327]             }
[10:21:44.327]             else {
[10:21:44.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.327]             }
[10:21:44.327]             {
[10:21:44.327]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.327]                   0L) {
[10:21:44.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.327]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.327]                   base::options(opts)
[10:21:44.327]                 }
[10:21:44.327]                 {
[10:21:44.327]                   {
[10:21:44.327]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.327]                     NULL
[10:21:44.327]                   }
[10:21:44.327]                   options(future.plan = NULL)
[10:21:44.327]                   if (is.na(NA_character_)) 
[10:21:44.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.327]                     .init = FALSE)
[10:21:44.327]                 }
[10:21:44.327]             }
[10:21:44.327]         }
[10:21:44.327]     })
[10:21:44.327]     if (TRUE) {
[10:21:44.327]         base::sink(type = "output", split = FALSE)
[10:21:44.327]         if (TRUE) {
[10:21:44.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.327]         }
[10:21:44.327]         else {
[10:21:44.327]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.327]         }
[10:21:44.327]         base::close(...future.stdout)
[10:21:44.327]         ...future.stdout <- NULL
[10:21:44.327]     }
[10:21:44.327]     ...future.result$conditions <- ...future.conditions
[10:21:44.327]     ...future.result$finished <- base::Sys.time()
[10:21:44.327]     ...future.result
[10:21:44.327] }
[10:21:44.329] assign_globals() ...
[10:21:44.329] List of 2
[10:21:44.329]  $ a : num 1
[10:21:44.329]  $ ii: int 1
[10:21:44.329]  - attr(*, "where")=List of 2
[10:21:44.329]   ..$ a :<environment: R_EmptyEnv> 
[10:21:44.329]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:44.329]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.329]  - attr(*, "resolved")= logi TRUE
[10:21:44.329]  - attr(*, "total_size")= num 74
[10:21:44.329]  - attr(*, "already-done")= logi TRUE
[10:21:44.333] - copied ‘a’ to environment
[10:21:44.333] - copied ‘ii’ to environment
[10:21:44.333] assign_globals() ... done
[10:21:44.333] requestCore(): workers = 2
[10:21:44.336] MulticoreFuture started
[10:21:44.336] - Launch lazy future ... done
[10:21:44.337] plan(): Setting new future strategy stack:
[10:21:44.337] run() for ‘MulticoreFuture’ ... done
[10:21:44.337] result() for MulticoreFuture ...
[10:21:44.337] List of future strategies:
[10:21:44.337] 1. sequential:
[10:21:44.337]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.337]    - tweaked: FALSE
[10:21:44.337]    - call: NULL
[10:21:44.339] plan(): nbrOfWorkers() = 1
[10:21:44.341] plan(): Setting new future strategy stack:
[10:21:44.341] List of future strategies:
[10:21:44.341] 1. multicore:
[10:21:44.341]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.341]    - tweaked: FALSE
[10:21:44.341]    - call: plan(strategy)
[10:21:44.345] plan(): nbrOfWorkers() = 2
[10:21:44.346] result() for MulticoreFuture ...
[10:21:44.346] result() for MulticoreFuture ... done
[10:21:44.346] result() for MulticoreFuture ... done
[10:21:44.346] result() for MulticoreFuture ...
[10:21:44.346] result() for MulticoreFuture ... done
[10:21:44.347] run() for ‘Future’ ...
[10:21:44.347] - state: ‘created’
[10:21:44.347] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.350] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.350] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.350]   - Field: ‘label’
[10:21:44.350]   - Field: ‘local’
[10:21:44.350]   - Field: ‘owner’
[10:21:44.350]   - Field: ‘envir’
[10:21:44.351]   - Field: ‘workers’
[10:21:44.351]   - Field: ‘packages’
[10:21:44.351]   - Field: ‘gc’
[10:21:44.351]   - Field: ‘job’
[10:21:44.351]   - Field: ‘conditions’
[10:21:44.351]   - Field: ‘expr’
[10:21:44.351]   - Field: ‘uuid’
[10:21:44.351]   - Field: ‘seed’
[10:21:44.352]   - Field: ‘version’
[10:21:44.352]   - Field: ‘result’
[10:21:44.352]   - Field: ‘asynchronous’
[10:21:44.352]   - Field: ‘calls’
[10:21:44.352]   - Field: ‘globals’
[10:21:44.352]   - Field: ‘stdout’
[10:21:44.352]   - Field: ‘earlySignal’
[10:21:44.352]   - Field: ‘lazy’
[10:21:44.352]   - Field: ‘state’
[10:21:44.353] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.353] - Launch lazy future ...
[10:21:44.353] Packages needed by the future expression (n = 0): <none>
[10:21:44.353] Packages needed by future strategies (n = 0): <none>
[10:21:44.354] {
[10:21:44.354]     {
[10:21:44.354]         {
[10:21:44.354]             ...future.startTime <- base::Sys.time()
[10:21:44.354]             {
[10:21:44.354]                 {
[10:21:44.354]                   {
[10:21:44.354]                     {
[10:21:44.354]                       base::local({
[10:21:44.354]                         has_future <- base::requireNamespace("future", 
[10:21:44.354]                           quietly = TRUE)
[10:21:44.354]                         if (has_future) {
[10:21:44.354]                           ns <- base::getNamespace("future")
[10:21:44.354]                           version <- ns[[".package"]][["version"]]
[10:21:44.354]                           if (is.null(version)) 
[10:21:44.354]                             version <- utils::packageVersion("future")
[10:21:44.354]                         }
[10:21:44.354]                         else {
[10:21:44.354]                           version <- NULL
[10:21:44.354]                         }
[10:21:44.354]                         if (!has_future || version < "1.8.0") {
[10:21:44.354]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.354]                             "", base::R.version$version.string), 
[10:21:44.354]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.354]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.354]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.354]                               "release", "version")], collapse = " "), 
[10:21:44.354]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.354]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.354]                             info)
[10:21:44.354]                           info <- base::paste(info, collapse = "; ")
[10:21:44.354]                           if (!has_future) {
[10:21:44.354]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.354]                               info)
[10:21:44.354]                           }
[10:21:44.354]                           else {
[10:21:44.354]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.354]                               info, version)
[10:21:44.354]                           }
[10:21:44.354]                           base::stop(msg)
[10:21:44.354]                         }
[10:21:44.354]                       })
[10:21:44.354]                     }
[10:21:44.354]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.354]                     base::options(mc.cores = 1L)
[10:21:44.354]                   }
[10:21:44.354]                   ...future.strategy.old <- future::plan("list")
[10:21:44.354]                   options(future.plan = NULL)
[10:21:44.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.354]                 }
[10:21:44.354]                 ...future.workdir <- getwd()
[10:21:44.354]             }
[10:21:44.354]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.354]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.354]         }
[10:21:44.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.354]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.354]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.354]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.354]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.354]             base::names(...future.oldOptions))
[10:21:44.354]     }
[10:21:44.354]     if (FALSE) {
[10:21:44.354]     }
[10:21:44.354]     else {
[10:21:44.354]         if (TRUE) {
[10:21:44.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.354]                 open = "w")
[10:21:44.354]         }
[10:21:44.354]         else {
[10:21:44.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.354]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.354]         }
[10:21:44.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.354]             base::sink(type = "output", split = FALSE)
[10:21:44.354]             base::close(...future.stdout)
[10:21:44.354]         }, add = TRUE)
[10:21:44.354]     }
[10:21:44.354]     ...future.frame <- base::sys.nframe()
[10:21:44.354]     ...future.conditions <- base::list()
[10:21:44.354]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.354]     if (FALSE) {
[10:21:44.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.354]     }
[10:21:44.354]     ...future.result <- base::tryCatch({
[10:21:44.354]         base::withCallingHandlers({
[10:21:44.354]             ...future.value <- base::withVisible(base::local({
[10:21:44.354]                 withCallingHandlers({
[10:21:44.354]                   {
[10:21:44.354]                     b <- a * ii
[10:21:44.354]                     a <- 0
[10:21:44.354]                     b
[10:21:44.354]                   }
[10:21:44.354]                 }, immediateCondition = function(cond) {
[10:21:44.354]                   save_rds <- function (object, pathname, ...) 
[10:21:44.354]                   {
[10:21:44.354]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.354]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.354]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.354]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.354]                         fi_tmp[["mtime"]])
[10:21:44.354]                     }
[10:21:44.354]                     tryCatch({
[10:21:44.354]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.354]                     }, error = function(ex) {
[10:21:44.354]                       msg <- conditionMessage(ex)
[10:21:44.354]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.354]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.354]                         fi_tmp[["mtime"]], msg)
[10:21:44.354]                       ex$message <- msg
[10:21:44.354]                       stop(ex)
[10:21:44.354]                     })
[10:21:44.354]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.354]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.354]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.354]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.354]                       fi <- file.info(pathname)
[10:21:44.354]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.354]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.354]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.354]                         fi[["size"]], fi[["mtime"]])
[10:21:44.354]                       stop(msg)
[10:21:44.354]                     }
[10:21:44.354]                     invisible(pathname)
[10:21:44.354]                   }
[10:21:44.354]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.354]                     rootPath = tempdir()) 
[10:21:44.354]                   {
[10:21:44.354]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.354]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.354]                       tmpdir = path, fileext = ".rds")
[10:21:44.354]                     save_rds(obj, file)
[10:21:44.354]                   }
[10:21:44.354]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.354]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.354]                   {
[10:21:44.354]                     inherits <- base::inherits
[10:21:44.354]                     invokeRestart <- base::invokeRestart
[10:21:44.354]                     is.null <- base::is.null
[10:21:44.354]                     muffled <- FALSE
[10:21:44.354]                     if (inherits(cond, "message")) {
[10:21:44.354]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.354]                       if (muffled) 
[10:21:44.354]                         invokeRestart("muffleMessage")
[10:21:44.354]                     }
[10:21:44.354]                     else if (inherits(cond, "warning")) {
[10:21:44.354]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.354]                       if (muffled) 
[10:21:44.354]                         invokeRestart("muffleWarning")
[10:21:44.354]                     }
[10:21:44.354]                     else if (inherits(cond, "condition")) {
[10:21:44.354]                       if (!is.null(pattern)) {
[10:21:44.354]                         computeRestarts <- base::computeRestarts
[10:21:44.354]                         grepl <- base::grepl
[10:21:44.354]                         restarts <- computeRestarts(cond)
[10:21:44.354]                         for (restart in restarts) {
[10:21:44.354]                           name <- restart$name
[10:21:44.354]                           if (is.null(name)) 
[10:21:44.354]                             next
[10:21:44.354]                           if (!grepl(pattern, name)) 
[10:21:44.354]                             next
[10:21:44.354]                           invokeRestart(restart)
[10:21:44.354]                           muffled <- TRUE
[10:21:44.354]                           break
[10:21:44.354]                         }
[10:21:44.354]                       }
[10:21:44.354]                     }
[10:21:44.354]                     invisible(muffled)
[10:21:44.354]                   }
[10:21:44.354]                   muffleCondition(cond)
[10:21:44.354]                 })
[10:21:44.354]             }))
[10:21:44.354]             future::FutureResult(value = ...future.value$value, 
[10:21:44.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.354]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.354]                     ...future.globalenv.names))
[10:21:44.354]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.354]         }, condition = base::local({
[10:21:44.354]             c <- base::c
[10:21:44.354]             inherits <- base::inherits
[10:21:44.354]             invokeRestart <- base::invokeRestart
[10:21:44.354]             length <- base::length
[10:21:44.354]             list <- base::list
[10:21:44.354]             seq.int <- base::seq.int
[10:21:44.354]             signalCondition <- base::signalCondition
[10:21:44.354]             sys.calls <- base::sys.calls
[10:21:44.354]             `[[` <- base::`[[`
[10:21:44.354]             `+` <- base::`+`
[10:21:44.354]             `<<-` <- base::`<<-`
[10:21:44.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.354]                   3L)]
[10:21:44.354]             }
[10:21:44.354]             function(cond) {
[10:21:44.354]                 is_error <- inherits(cond, "error")
[10:21:44.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.354]                   NULL)
[10:21:44.354]                 if (is_error) {
[10:21:44.354]                   sessionInformation <- function() {
[10:21:44.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.354]                       search = base::search(), system = base::Sys.info())
[10:21:44.354]                   }
[10:21:44.354]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.354]                     cond$call), session = sessionInformation(), 
[10:21:44.354]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.354]                   signalCondition(cond)
[10:21:44.354]                 }
[10:21:44.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.354]                 "immediateCondition"))) {
[10:21:44.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.354]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.354]                   if (TRUE && !signal) {
[10:21:44.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.354]                     {
[10:21:44.354]                       inherits <- base::inherits
[10:21:44.354]                       invokeRestart <- base::invokeRestart
[10:21:44.354]                       is.null <- base::is.null
[10:21:44.354]                       muffled <- FALSE
[10:21:44.354]                       if (inherits(cond, "message")) {
[10:21:44.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.354]                         if (muffled) 
[10:21:44.354]                           invokeRestart("muffleMessage")
[10:21:44.354]                       }
[10:21:44.354]                       else if (inherits(cond, "warning")) {
[10:21:44.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.354]                         if (muffled) 
[10:21:44.354]                           invokeRestart("muffleWarning")
[10:21:44.354]                       }
[10:21:44.354]                       else if (inherits(cond, "condition")) {
[10:21:44.354]                         if (!is.null(pattern)) {
[10:21:44.354]                           computeRestarts <- base::computeRestarts
[10:21:44.354]                           grepl <- base::grepl
[10:21:44.354]                           restarts <- computeRestarts(cond)
[10:21:44.354]                           for (restart in restarts) {
[10:21:44.354]                             name <- restart$name
[10:21:44.354]                             if (is.null(name)) 
[10:21:44.354]                               next
[10:21:44.354]                             if (!grepl(pattern, name)) 
[10:21:44.354]                               next
[10:21:44.354]                             invokeRestart(restart)
[10:21:44.354]                             muffled <- TRUE
[10:21:44.354]                             break
[10:21:44.354]                           }
[10:21:44.354]                         }
[10:21:44.354]                       }
[10:21:44.354]                       invisible(muffled)
[10:21:44.354]                     }
[10:21:44.354]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.354]                   }
[10:21:44.354]                 }
[10:21:44.354]                 else {
[10:21:44.354]                   if (TRUE) {
[10:21:44.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.354]                     {
[10:21:44.354]                       inherits <- base::inherits
[10:21:44.354]                       invokeRestart <- base::invokeRestart
[10:21:44.354]                       is.null <- base::is.null
[10:21:44.354]                       muffled <- FALSE
[10:21:44.354]                       if (inherits(cond, "message")) {
[10:21:44.354]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.354]                         if (muffled) 
[10:21:44.354]                           invokeRestart("muffleMessage")
[10:21:44.354]                       }
[10:21:44.354]                       else if (inherits(cond, "warning")) {
[10:21:44.354]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.354]                         if (muffled) 
[10:21:44.354]                           invokeRestart("muffleWarning")
[10:21:44.354]                       }
[10:21:44.354]                       else if (inherits(cond, "condition")) {
[10:21:44.354]                         if (!is.null(pattern)) {
[10:21:44.354]                           computeRestarts <- base::computeRestarts
[10:21:44.354]                           grepl <- base::grepl
[10:21:44.354]                           restarts <- computeRestarts(cond)
[10:21:44.354]                           for (restart in restarts) {
[10:21:44.354]                             name <- restart$name
[10:21:44.354]                             if (is.null(name)) 
[10:21:44.354]                               next
[10:21:44.354]                             if (!grepl(pattern, name)) 
[10:21:44.354]                               next
[10:21:44.354]                             invokeRestart(restart)
[10:21:44.354]                             muffled <- TRUE
[10:21:44.354]                             break
[10:21:44.354]                           }
[10:21:44.354]                         }
[10:21:44.354]                       }
[10:21:44.354]                       invisible(muffled)
[10:21:44.354]                     }
[10:21:44.354]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.354]                   }
[10:21:44.354]                 }
[10:21:44.354]             }
[10:21:44.354]         }))
[10:21:44.354]     }, error = function(ex) {
[10:21:44.354]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.354]                 ...future.rng), started = ...future.startTime, 
[10:21:44.354]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.354]             version = "1.8"), class = "FutureResult")
[10:21:44.354]     }, finally = {
[10:21:44.354]         if (!identical(...future.workdir, getwd())) 
[10:21:44.354]             setwd(...future.workdir)
[10:21:44.354]         {
[10:21:44.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.354]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.354]             }
[10:21:44.354]             base::options(...future.oldOptions)
[10:21:44.354]             if (.Platform$OS.type == "windows") {
[10:21:44.354]                 old_names <- names(...future.oldEnvVars)
[10:21:44.354]                 envs <- base::Sys.getenv()
[10:21:44.354]                 names <- names(envs)
[10:21:44.354]                 common <- intersect(names, old_names)
[10:21:44.354]                 added <- setdiff(names, old_names)
[10:21:44.354]                 removed <- setdiff(old_names, names)
[10:21:44.354]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.354]                   envs[common]]
[10:21:44.354]                 NAMES <- toupper(changed)
[10:21:44.354]                 args <- list()
[10:21:44.354]                 for (kk in seq_along(NAMES)) {
[10:21:44.354]                   name <- changed[[kk]]
[10:21:44.354]                   NAME <- NAMES[[kk]]
[10:21:44.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.354]                     next
[10:21:44.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.354]                 }
[10:21:44.354]                 NAMES <- toupper(added)
[10:21:44.354]                 for (kk in seq_along(NAMES)) {
[10:21:44.354]                   name <- added[[kk]]
[10:21:44.354]                   NAME <- NAMES[[kk]]
[10:21:44.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.354]                     next
[10:21:44.354]                   args[[name]] <- ""
[10:21:44.354]                 }
[10:21:44.354]                 NAMES <- toupper(removed)
[10:21:44.354]                 for (kk in seq_along(NAMES)) {
[10:21:44.354]                   name <- removed[[kk]]
[10:21:44.354]                   NAME <- NAMES[[kk]]
[10:21:44.354]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.354]                     next
[10:21:44.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.354]                 }
[10:21:44.354]                 if (length(args) > 0) 
[10:21:44.354]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.354]             }
[10:21:44.354]             else {
[10:21:44.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.354]             }
[10:21:44.354]             {
[10:21:44.354]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.354]                   0L) {
[10:21:44.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.354]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.354]                   base::options(opts)
[10:21:44.354]                 }
[10:21:44.354]                 {
[10:21:44.354]                   {
[10:21:44.354]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.354]                     NULL
[10:21:44.354]                   }
[10:21:44.354]                   options(future.plan = NULL)
[10:21:44.354]                   if (is.na(NA_character_)) 
[10:21:44.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.354]                     .init = FALSE)
[10:21:44.354]                 }
[10:21:44.354]             }
[10:21:44.354]         }
[10:21:44.354]     })
[10:21:44.354]     if (TRUE) {
[10:21:44.354]         base::sink(type = "output", split = FALSE)
[10:21:44.354]         if (TRUE) {
[10:21:44.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.354]         }
[10:21:44.354]         else {
[10:21:44.354]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.354]         }
[10:21:44.354]         base::close(...future.stdout)
[10:21:44.354]         ...future.stdout <- NULL
[10:21:44.354]     }
[10:21:44.354]     ...future.result$conditions <- ...future.conditions
[10:21:44.354]     ...future.result$finished <- base::Sys.time()
[10:21:44.354]     ...future.result
[10:21:44.354] }
[10:21:44.356] assign_globals() ...
[10:21:44.357] List of 2
[10:21:44.357]  $ a : num 1
[10:21:44.357]  $ ii: int 2
[10:21:44.357]  - attr(*, "where")=List of 2
[10:21:44.357]   ..$ a :<environment: R_EmptyEnv> 
[10:21:44.357]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:44.357]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.357]  - attr(*, "resolved")= logi TRUE
[10:21:44.357]  - attr(*, "total_size")= num 74
[10:21:44.357]  - attr(*, "already-done")= logi TRUE
[10:21:44.360] - copied ‘a’ to environment
[10:21:44.361] - copied ‘ii’ to environment
[10:21:44.361] assign_globals() ... done
[10:21:44.361] requestCore(): workers = 2
[10:21:44.363] MulticoreFuture started
[10:21:44.363] - Launch lazy future ... done
[10:21:44.363] run() for ‘MulticoreFuture’ ... done
[10:21:44.363] plan(): Setting new future strategy stack:
[10:21:44.364] result() for MulticoreFuture ...
[10:21:44.364] List of future strategies:
[10:21:44.364] 1. sequential:
[10:21:44.364]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.364]    - tweaked: FALSE
[10:21:44.364]    - call: NULL
[10:21:44.365] plan(): nbrOfWorkers() = 1
[10:21:44.367] plan(): Setting new future strategy stack:
[10:21:44.367] List of future strategies:
[10:21:44.367] 1. multicore:
[10:21:44.367]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.367]    - tweaked: FALSE
[10:21:44.367]    - call: plan(strategy)
[10:21:44.370] plan(): nbrOfWorkers() = 2
[10:21:44.371] result() for MulticoreFuture ...
[10:21:44.371] result() for MulticoreFuture ... done
[10:21:44.371] result() for MulticoreFuture ... done
[10:21:44.371] result() for MulticoreFuture ...
[10:21:44.371] result() for MulticoreFuture ... done
[10:21:44.372] run() for ‘Future’ ...
[10:21:44.372] - state: ‘created’
[10:21:44.372] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.374] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.375] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.375]   - Field: ‘label’
[10:21:44.375]   - Field: ‘local’
[10:21:44.375]   - Field: ‘owner’
[10:21:44.375]   - Field: ‘envir’
[10:21:44.375]   - Field: ‘workers’
[10:21:44.375]   - Field: ‘packages’
[10:21:44.375]   - Field: ‘gc’
[10:21:44.376]   - Field: ‘job’
[10:21:44.376]   - Field: ‘conditions’
[10:21:44.376]   - Field: ‘expr’
[10:21:44.376]   - Field: ‘uuid’
[10:21:44.376]   - Field: ‘seed’
[10:21:44.376]   - Field: ‘version’
[10:21:44.376]   - Field: ‘result’
[10:21:44.376]   - Field: ‘asynchronous’
[10:21:44.376]   - Field: ‘calls’
[10:21:44.377]   - Field: ‘globals’
[10:21:44.377]   - Field: ‘stdout’
[10:21:44.377]   - Field: ‘earlySignal’
[10:21:44.377]   - Field: ‘lazy’
[10:21:44.377]   - Field: ‘state’
[10:21:44.377] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.377] - Launch lazy future ...
[10:21:44.378] Packages needed by the future expression (n = 0): <none>
[10:21:44.378] Packages needed by future strategies (n = 0): <none>
[10:21:44.381] {
[10:21:44.381]     {
[10:21:44.381]         {
[10:21:44.381]             ...future.startTime <- base::Sys.time()
[10:21:44.381]             {
[10:21:44.381]                 {
[10:21:44.381]                   {
[10:21:44.381]                     {
[10:21:44.381]                       base::local({
[10:21:44.381]                         has_future <- base::requireNamespace("future", 
[10:21:44.381]                           quietly = TRUE)
[10:21:44.381]                         if (has_future) {
[10:21:44.381]                           ns <- base::getNamespace("future")
[10:21:44.381]                           version <- ns[[".package"]][["version"]]
[10:21:44.381]                           if (is.null(version)) 
[10:21:44.381]                             version <- utils::packageVersion("future")
[10:21:44.381]                         }
[10:21:44.381]                         else {
[10:21:44.381]                           version <- NULL
[10:21:44.381]                         }
[10:21:44.381]                         if (!has_future || version < "1.8.0") {
[10:21:44.381]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.381]                             "", base::R.version$version.string), 
[10:21:44.381]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.381]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.381]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.381]                               "release", "version")], collapse = " "), 
[10:21:44.381]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.381]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.381]                             info)
[10:21:44.381]                           info <- base::paste(info, collapse = "; ")
[10:21:44.381]                           if (!has_future) {
[10:21:44.381]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.381]                               info)
[10:21:44.381]                           }
[10:21:44.381]                           else {
[10:21:44.381]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.381]                               info, version)
[10:21:44.381]                           }
[10:21:44.381]                           base::stop(msg)
[10:21:44.381]                         }
[10:21:44.381]                       })
[10:21:44.381]                     }
[10:21:44.381]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.381]                     base::options(mc.cores = 1L)
[10:21:44.381]                   }
[10:21:44.381]                   ...future.strategy.old <- future::plan("list")
[10:21:44.381]                   options(future.plan = NULL)
[10:21:44.381]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.381]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.381]                 }
[10:21:44.381]                 ...future.workdir <- getwd()
[10:21:44.381]             }
[10:21:44.381]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.381]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.381]         }
[10:21:44.381]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.381]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.381]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.381]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.381]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.381]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.381]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.381]             base::names(...future.oldOptions))
[10:21:44.381]     }
[10:21:44.381]     if (FALSE) {
[10:21:44.381]     }
[10:21:44.381]     else {
[10:21:44.381]         if (TRUE) {
[10:21:44.381]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.381]                 open = "w")
[10:21:44.381]         }
[10:21:44.381]         else {
[10:21:44.381]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.381]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.381]         }
[10:21:44.381]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.381]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.381]             base::sink(type = "output", split = FALSE)
[10:21:44.381]             base::close(...future.stdout)
[10:21:44.381]         }, add = TRUE)
[10:21:44.381]     }
[10:21:44.381]     ...future.frame <- base::sys.nframe()
[10:21:44.381]     ...future.conditions <- base::list()
[10:21:44.381]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.381]     if (FALSE) {
[10:21:44.381]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.381]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.381]     }
[10:21:44.381]     ...future.result <- base::tryCatch({
[10:21:44.381]         base::withCallingHandlers({
[10:21:44.381]             ...future.value <- base::withVisible(base::local({
[10:21:44.381]                 withCallingHandlers({
[10:21:44.381]                   {
[10:21:44.381]                     b <- a * ii
[10:21:44.381]                     a <- 0
[10:21:44.381]                     b
[10:21:44.381]                   }
[10:21:44.381]                 }, immediateCondition = function(cond) {
[10:21:44.381]                   save_rds <- function (object, pathname, ...) 
[10:21:44.381]                   {
[10:21:44.381]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.381]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.381]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.381]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.381]                         fi_tmp[["mtime"]])
[10:21:44.381]                     }
[10:21:44.381]                     tryCatch({
[10:21:44.381]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.381]                     }, error = function(ex) {
[10:21:44.381]                       msg <- conditionMessage(ex)
[10:21:44.381]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.381]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.381]                         fi_tmp[["mtime"]], msg)
[10:21:44.381]                       ex$message <- msg
[10:21:44.381]                       stop(ex)
[10:21:44.381]                     })
[10:21:44.381]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.381]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.381]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.381]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.381]                       fi <- file.info(pathname)
[10:21:44.381]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.381]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.381]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.381]                         fi[["size"]], fi[["mtime"]])
[10:21:44.381]                       stop(msg)
[10:21:44.381]                     }
[10:21:44.381]                     invisible(pathname)
[10:21:44.381]                   }
[10:21:44.381]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.381]                     rootPath = tempdir()) 
[10:21:44.381]                   {
[10:21:44.381]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.381]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.381]                       tmpdir = path, fileext = ".rds")
[10:21:44.381]                     save_rds(obj, file)
[10:21:44.381]                   }
[10:21:44.381]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.381]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.381]                   {
[10:21:44.381]                     inherits <- base::inherits
[10:21:44.381]                     invokeRestart <- base::invokeRestart
[10:21:44.381]                     is.null <- base::is.null
[10:21:44.381]                     muffled <- FALSE
[10:21:44.381]                     if (inherits(cond, "message")) {
[10:21:44.381]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.381]                       if (muffled) 
[10:21:44.381]                         invokeRestart("muffleMessage")
[10:21:44.381]                     }
[10:21:44.381]                     else if (inherits(cond, "warning")) {
[10:21:44.381]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.381]                       if (muffled) 
[10:21:44.381]                         invokeRestart("muffleWarning")
[10:21:44.381]                     }
[10:21:44.381]                     else if (inherits(cond, "condition")) {
[10:21:44.381]                       if (!is.null(pattern)) {
[10:21:44.381]                         computeRestarts <- base::computeRestarts
[10:21:44.381]                         grepl <- base::grepl
[10:21:44.381]                         restarts <- computeRestarts(cond)
[10:21:44.381]                         for (restart in restarts) {
[10:21:44.381]                           name <- restart$name
[10:21:44.381]                           if (is.null(name)) 
[10:21:44.381]                             next
[10:21:44.381]                           if (!grepl(pattern, name)) 
[10:21:44.381]                             next
[10:21:44.381]                           invokeRestart(restart)
[10:21:44.381]                           muffled <- TRUE
[10:21:44.381]                           break
[10:21:44.381]                         }
[10:21:44.381]                       }
[10:21:44.381]                     }
[10:21:44.381]                     invisible(muffled)
[10:21:44.381]                   }
[10:21:44.381]                   muffleCondition(cond)
[10:21:44.381]                 })
[10:21:44.381]             }))
[10:21:44.381]             future::FutureResult(value = ...future.value$value, 
[10:21:44.381]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.381]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.381]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.381]                     ...future.globalenv.names))
[10:21:44.381]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.381]         }, condition = base::local({
[10:21:44.381]             c <- base::c
[10:21:44.381]             inherits <- base::inherits
[10:21:44.381]             invokeRestart <- base::invokeRestart
[10:21:44.381]             length <- base::length
[10:21:44.381]             list <- base::list
[10:21:44.381]             seq.int <- base::seq.int
[10:21:44.381]             signalCondition <- base::signalCondition
[10:21:44.381]             sys.calls <- base::sys.calls
[10:21:44.381]             `[[` <- base::`[[`
[10:21:44.381]             `+` <- base::`+`
[10:21:44.381]             `<<-` <- base::`<<-`
[10:21:44.381]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.381]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.381]                   3L)]
[10:21:44.381]             }
[10:21:44.381]             function(cond) {
[10:21:44.381]                 is_error <- inherits(cond, "error")
[10:21:44.381]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.381]                   NULL)
[10:21:44.381]                 if (is_error) {
[10:21:44.381]                   sessionInformation <- function() {
[10:21:44.381]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.381]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.381]                       search = base::search(), system = base::Sys.info())
[10:21:44.381]                   }
[10:21:44.381]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.381]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.381]                     cond$call), session = sessionInformation(), 
[10:21:44.381]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.381]                   signalCondition(cond)
[10:21:44.381]                 }
[10:21:44.381]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.381]                 "immediateCondition"))) {
[10:21:44.381]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.381]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.381]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.381]                   if (TRUE && !signal) {
[10:21:44.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.381]                     {
[10:21:44.381]                       inherits <- base::inherits
[10:21:44.381]                       invokeRestart <- base::invokeRestart
[10:21:44.381]                       is.null <- base::is.null
[10:21:44.381]                       muffled <- FALSE
[10:21:44.381]                       if (inherits(cond, "message")) {
[10:21:44.381]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.381]                         if (muffled) 
[10:21:44.381]                           invokeRestart("muffleMessage")
[10:21:44.381]                       }
[10:21:44.381]                       else if (inherits(cond, "warning")) {
[10:21:44.381]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.381]                         if (muffled) 
[10:21:44.381]                           invokeRestart("muffleWarning")
[10:21:44.381]                       }
[10:21:44.381]                       else if (inherits(cond, "condition")) {
[10:21:44.381]                         if (!is.null(pattern)) {
[10:21:44.381]                           computeRestarts <- base::computeRestarts
[10:21:44.381]                           grepl <- base::grepl
[10:21:44.381]                           restarts <- computeRestarts(cond)
[10:21:44.381]                           for (restart in restarts) {
[10:21:44.381]                             name <- restart$name
[10:21:44.381]                             if (is.null(name)) 
[10:21:44.381]                               next
[10:21:44.381]                             if (!grepl(pattern, name)) 
[10:21:44.381]                               next
[10:21:44.381]                             invokeRestart(restart)
[10:21:44.381]                             muffled <- TRUE
[10:21:44.381]                             break
[10:21:44.381]                           }
[10:21:44.381]                         }
[10:21:44.381]                       }
[10:21:44.381]                       invisible(muffled)
[10:21:44.381]                     }
[10:21:44.381]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.381]                   }
[10:21:44.381]                 }
[10:21:44.381]                 else {
[10:21:44.381]                   if (TRUE) {
[10:21:44.381]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.381]                     {
[10:21:44.381]                       inherits <- base::inherits
[10:21:44.381]                       invokeRestart <- base::invokeRestart
[10:21:44.381]                       is.null <- base::is.null
[10:21:44.381]                       muffled <- FALSE
[10:21:44.381]                       if (inherits(cond, "message")) {
[10:21:44.381]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.381]                         if (muffled) 
[10:21:44.381]                           invokeRestart("muffleMessage")
[10:21:44.381]                       }
[10:21:44.381]                       else if (inherits(cond, "warning")) {
[10:21:44.381]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.381]                         if (muffled) 
[10:21:44.381]                           invokeRestart("muffleWarning")
[10:21:44.381]                       }
[10:21:44.381]                       else if (inherits(cond, "condition")) {
[10:21:44.381]                         if (!is.null(pattern)) {
[10:21:44.381]                           computeRestarts <- base::computeRestarts
[10:21:44.381]                           grepl <- base::grepl
[10:21:44.381]                           restarts <- computeRestarts(cond)
[10:21:44.381]                           for (restart in restarts) {
[10:21:44.381]                             name <- restart$name
[10:21:44.381]                             if (is.null(name)) 
[10:21:44.381]                               next
[10:21:44.381]                             if (!grepl(pattern, name)) 
[10:21:44.381]                               next
[10:21:44.381]                             invokeRestart(restart)
[10:21:44.381]                             muffled <- TRUE
[10:21:44.381]                             break
[10:21:44.381]                           }
[10:21:44.381]                         }
[10:21:44.381]                       }
[10:21:44.381]                       invisible(muffled)
[10:21:44.381]                     }
[10:21:44.381]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.381]                   }
[10:21:44.381]                 }
[10:21:44.381]             }
[10:21:44.381]         }))
[10:21:44.381]     }, error = function(ex) {
[10:21:44.381]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.381]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.381]                 ...future.rng), started = ...future.startTime, 
[10:21:44.381]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.381]             version = "1.8"), class = "FutureResult")
[10:21:44.381]     }, finally = {
[10:21:44.381]         if (!identical(...future.workdir, getwd())) 
[10:21:44.381]             setwd(...future.workdir)
[10:21:44.381]         {
[10:21:44.381]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.381]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.381]             }
[10:21:44.381]             base::options(...future.oldOptions)
[10:21:44.381]             if (.Platform$OS.type == "windows") {
[10:21:44.381]                 old_names <- names(...future.oldEnvVars)
[10:21:44.381]                 envs <- base::Sys.getenv()
[10:21:44.381]                 names <- names(envs)
[10:21:44.381]                 common <- intersect(names, old_names)
[10:21:44.381]                 added <- setdiff(names, old_names)
[10:21:44.381]                 removed <- setdiff(old_names, names)
[10:21:44.381]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.381]                   envs[common]]
[10:21:44.381]                 NAMES <- toupper(changed)
[10:21:44.381]                 args <- list()
[10:21:44.381]                 for (kk in seq_along(NAMES)) {
[10:21:44.381]                   name <- changed[[kk]]
[10:21:44.381]                   NAME <- NAMES[[kk]]
[10:21:44.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.381]                     next
[10:21:44.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.381]                 }
[10:21:44.381]                 NAMES <- toupper(added)
[10:21:44.381]                 for (kk in seq_along(NAMES)) {
[10:21:44.381]                   name <- added[[kk]]
[10:21:44.381]                   NAME <- NAMES[[kk]]
[10:21:44.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.381]                     next
[10:21:44.381]                   args[[name]] <- ""
[10:21:44.381]                 }
[10:21:44.381]                 NAMES <- toupper(removed)
[10:21:44.381]                 for (kk in seq_along(NAMES)) {
[10:21:44.381]                   name <- removed[[kk]]
[10:21:44.381]                   NAME <- NAMES[[kk]]
[10:21:44.381]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.381]                     next
[10:21:44.381]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.381]                 }
[10:21:44.381]                 if (length(args) > 0) 
[10:21:44.381]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.381]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.381]             }
[10:21:44.381]             else {
[10:21:44.381]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.381]             }
[10:21:44.381]             {
[10:21:44.381]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.381]                   0L) {
[10:21:44.381]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.381]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.381]                   base::options(opts)
[10:21:44.381]                 }
[10:21:44.381]                 {
[10:21:44.381]                   {
[10:21:44.381]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.381]                     NULL
[10:21:44.381]                   }
[10:21:44.381]                   options(future.plan = NULL)
[10:21:44.381]                   if (is.na(NA_character_)) 
[10:21:44.381]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.381]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.381]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.381]                     .init = FALSE)
[10:21:44.381]                 }
[10:21:44.381]             }
[10:21:44.381]         }
[10:21:44.381]     })
[10:21:44.381]     if (TRUE) {
[10:21:44.381]         base::sink(type = "output", split = FALSE)
[10:21:44.381]         if (TRUE) {
[10:21:44.381]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.381]         }
[10:21:44.381]         else {
[10:21:44.381]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.381]         }
[10:21:44.381]         base::close(...future.stdout)
[10:21:44.381]         ...future.stdout <- NULL
[10:21:44.381]     }
[10:21:44.381]     ...future.result$conditions <- ...future.conditions
[10:21:44.381]     ...future.result$finished <- base::Sys.time()
[10:21:44.381]     ...future.result
[10:21:44.381] }
[10:21:44.384] assign_globals() ...
[10:21:44.384] List of 2
[10:21:44.384]  $ a : num 1
[10:21:44.384]  $ ii: int 3
[10:21:44.384]  - attr(*, "where")=List of 2
[10:21:44.384]   ..$ a :<environment: R_EmptyEnv> 
[10:21:44.384]   ..$ ii:<environment: R_EmptyEnv> 
[10:21:44.384]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.384]  - attr(*, "resolved")= logi TRUE
[10:21:44.384]  - attr(*, "total_size")= num 74
[10:21:44.384]  - attr(*, "already-done")= logi TRUE
[10:21:44.389] - copied ‘a’ to environment
[10:21:44.389] - copied ‘ii’ to environment
[10:21:44.389] assign_globals() ... done
[10:21:44.389] requestCore(): workers = 2
[10:21:44.391] MulticoreFuture started
[10:21:44.392] - Launch lazy future ... done
[10:21:44.392] plan(): Setting new future strategy stack:
[10:21:44.392] run() for ‘MulticoreFuture’ ... done
[10:21:44.393] result() for MulticoreFuture ...
[10:21:44.393] List of future strategies:
[10:21:44.393] 1. sequential:
[10:21:44.393]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.393]    - tweaked: FALSE
[10:21:44.393]    - call: NULL
[10:21:44.394] plan(): nbrOfWorkers() = 1
[10:21:44.396] plan(): Setting new future strategy stack:
[10:21:44.397] List of future strategies:
[10:21:44.397] 1. multicore:
[10:21:44.397]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.397]    - tweaked: FALSE
[10:21:44.397]    - call: plan(strategy)
[10:21:44.400] plan(): nbrOfWorkers() = 2
[10:21:44.401] result() for MulticoreFuture ...
[10:21:44.401] result() for MulticoreFuture ... done
[10:21:44.401] result() for MulticoreFuture ... done
[10:21:44.401] result() for MulticoreFuture ...
[10:21:44.401] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.402] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.403] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.403] 
[10:21:44.403] Searching for globals ... DONE
[10:21:44.404] - globals: [0] <none>
[10:21:44.404] getGlobalsAndPackages() ... DONE
[10:21:44.404] run() for ‘Future’ ...
[10:21:44.404] - state: ‘created’
[10:21:44.404] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.407] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.407] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.407]   - Field: ‘label’
[10:21:44.407]   - Field: ‘local’
[10:21:44.407]   - Field: ‘owner’
[10:21:44.407]   - Field: ‘envir’
[10:21:44.407]   - Field: ‘workers’
[10:21:44.407]   - Field: ‘packages’
[10:21:44.408]   - Field: ‘gc’
[10:21:44.408]   - Field: ‘job’
[10:21:44.408]   - Field: ‘conditions’
[10:21:44.408]   - Field: ‘expr’
[10:21:44.408]   - Field: ‘uuid’
[10:21:44.408]   - Field: ‘seed’
[10:21:44.408]   - Field: ‘version’
[10:21:44.408]   - Field: ‘result’
[10:21:44.408]   - Field: ‘asynchronous’
[10:21:44.409]   - Field: ‘calls’
[10:21:44.409]   - Field: ‘globals’
[10:21:44.409]   - Field: ‘stdout’
[10:21:44.409]   - Field: ‘earlySignal’
[10:21:44.409]   - Field: ‘lazy’
[10:21:44.409]   - Field: ‘state’
[10:21:44.409] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.409] - Launch lazy future ...
[10:21:44.410] Packages needed by the future expression (n = 0): <none>
[10:21:44.410] Packages needed by future strategies (n = 0): <none>
[10:21:44.410] {
[10:21:44.410]     {
[10:21:44.410]         {
[10:21:44.410]             ...future.startTime <- base::Sys.time()
[10:21:44.410]             {
[10:21:44.410]                 {
[10:21:44.410]                   {
[10:21:44.410]                     {
[10:21:44.410]                       base::local({
[10:21:44.410]                         has_future <- base::requireNamespace("future", 
[10:21:44.410]                           quietly = TRUE)
[10:21:44.410]                         if (has_future) {
[10:21:44.410]                           ns <- base::getNamespace("future")
[10:21:44.410]                           version <- ns[[".package"]][["version"]]
[10:21:44.410]                           if (is.null(version)) 
[10:21:44.410]                             version <- utils::packageVersion("future")
[10:21:44.410]                         }
[10:21:44.410]                         else {
[10:21:44.410]                           version <- NULL
[10:21:44.410]                         }
[10:21:44.410]                         if (!has_future || version < "1.8.0") {
[10:21:44.410]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.410]                             "", base::R.version$version.string), 
[10:21:44.410]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.410]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.410]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.410]                               "release", "version")], collapse = " "), 
[10:21:44.410]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.410]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.410]                             info)
[10:21:44.410]                           info <- base::paste(info, collapse = "; ")
[10:21:44.410]                           if (!has_future) {
[10:21:44.410]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.410]                               info)
[10:21:44.410]                           }
[10:21:44.410]                           else {
[10:21:44.410]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.410]                               info, version)
[10:21:44.410]                           }
[10:21:44.410]                           base::stop(msg)
[10:21:44.410]                         }
[10:21:44.410]                       })
[10:21:44.410]                     }
[10:21:44.410]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.410]                     base::options(mc.cores = 1L)
[10:21:44.410]                   }
[10:21:44.410]                   ...future.strategy.old <- future::plan("list")
[10:21:44.410]                   options(future.plan = NULL)
[10:21:44.410]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.410]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.410]                 }
[10:21:44.410]                 ...future.workdir <- getwd()
[10:21:44.410]             }
[10:21:44.410]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.410]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.410]         }
[10:21:44.410]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.410]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.410]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.410]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.410]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.410]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.410]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.410]             base::names(...future.oldOptions))
[10:21:44.410]     }
[10:21:44.410]     if (FALSE) {
[10:21:44.410]     }
[10:21:44.410]     else {
[10:21:44.410]         if (TRUE) {
[10:21:44.410]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.410]                 open = "w")
[10:21:44.410]         }
[10:21:44.410]         else {
[10:21:44.410]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.410]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.410]         }
[10:21:44.410]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.410]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.410]             base::sink(type = "output", split = FALSE)
[10:21:44.410]             base::close(...future.stdout)
[10:21:44.410]         }, add = TRUE)
[10:21:44.410]     }
[10:21:44.410]     ...future.frame <- base::sys.nframe()
[10:21:44.410]     ...future.conditions <- base::list()
[10:21:44.410]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.410]     if (FALSE) {
[10:21:44.410]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.410]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.410]     }
[10:21:44.410]     ...future.result <- base::tryCatch({
[10:21:44.410]         base::withCallingHandlers({
[10:21:44.410]             ...future.value <- base::withVisible(base::local({
[10:21:44.410]                 withCallingHandlers({
[10:21:44.410]                   1
[10:21:44.410]                 }, immediateCondition = function(cond) {
[10:21:44.410]                   save_rds <- function (object, pathname, ...) 
[10:21:44.410]                   {
[10:21:44.410]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.410]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.410]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.410]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.410]                         fi_tmp[["mtime"]])
[10:21:44.410]                     }
[10:21:44.410]                     tryCatch({
[10:21:44.410]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.410]                     }, error = function(ex) {
[10:21:44.410]                       msg <- conditionMessage(ex)
[10:21:44.410]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.410]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.410]                         fi_tmp[["mtime"]], msg)
[10:21:44.410]                       ex$message <- msg
[10:21:44.410]                       stop(ex)
[10:21:44.410]                     })
[10:21:44.410]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.410]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.410]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.410]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.410]                       fi <- file.info(pathname)
[10:21:44.410]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.410]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.410]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.410]                         fi[["size"]], fi[["mtime"]])
[10:21:44.410]                       stop(msg)
[10:21:44.410]                     }
[10:21:44.410]                     invisible(pathname)
[10:21:44.410]                   }
[10:21:44.410]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.410]                     rootPath = tempdir()) 
[10:21:44.410]                   {
[10:21:44.410]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.410]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.410]                       tmpdir = path, fileext = ".rds")
[10:21:44.410]                     save_rds(obj, file)
[10:21:44.410]                   }
[10:21:44.410]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.410]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.410]                   {
[10:21:44.410]                     inherits <- base::inherits
[10:21:44.410]                     invokeRestart <- base::invokeRestart
[10:21:44.410]                     is.null <- base::is.null
[10:21:44.410]                     muffled <- FALSE
[10:21:44.410]                     if (inherits(cond, "message")) {
[10:21:44.410]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.410]                       if (muffled) 
[10:21:44.410]                         invokeRestart("muffleMessage")
[10:21:44.410]                     }
[10:21:44.410]                     else if (inherits(cond, "warning")) {
[10:21:44.410]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.410]                       if (muffled) 
[10:21:44.410]                         invokeRestart("muffleWarning")
[10:21:44.410]                     }
[10:21:44.410]                     else if (inherits(cond, "condition")) {
[10:21:44.410]                       if (!is.null(pattern)) {
[10:21:44.410]                         computeRestarts <- base::computeRestarts
[10:21:44.410]                         grepl <- base::grepl
[10:21:44.410]                         restarts <- computeRestarts(cond)
[10:21:44.410]                         for (restart in restarts) {
[10:21:44.410]                           name <- restart$name
[10:21:44.410]                           if (is.null(name)) 
[10:21:44.410]                             next
[10:21:44.410]                           if (!grepl(pattern, name)) 
[10:21:44.410]                             next
[10:21:44.410]                           invokeRestart(restart)
[10:21:44.410]                           muffled <- TRUE
[10:21:44.410]                           break
[10:21:44.410]                         }
[10:21:44.410]                       }
[10:21:44.410]                     }
[10:21:44.410]                     invisible(muffled)
[10:21:44.410]                   }
[10:21:44.410]                   muffleCondition(cond)
[10:21:44.410]                 })
[10:21:44.410]             }))
[10:21:44.410]             future::FutureResult(value = ...future.value$value, 
[10:21:44.410]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.410]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.410]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.410]                     ...future.globalenv.names))
[10:21:44.410]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.410]         }, condition = base::local({
[10:21:44.410]             c <- base::c
[10:21:44.410]             inherits <- base::inherits
[10:21:44.410]             invokeRestart <- base::invokeRestart
[10:21:44.410]             length <- base::length
[10:21:44.410]             list <- base::list
[10:21:44.410]             seq.int <- base::seq.int
[10:21:44.410]             signalCondition <- base::signalCondition
[10:21:44.410]             sys.calls <- base::sys.calls
[10:21:44.410]             `[[` <- base::`[[`
[10:21:44.410]             `+` <- base::`+`
[10:21:44.410]             `<<-` <- base::`<<-`
[10:21:44.410]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.410]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.410]                   3L)]
[10:21:44.410]             }
[10:21:44.410]             function(cond) {
[10:21:44.410]                 is_error <- inherits(cond, "error")
[10:21:44.410]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.410]                   NULL)
[10:21:44.410]                 if (is_error) {
[10:21:44.410]                   sessionInformation <- function() {
[10:21:44.410]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.410]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.410]                       search = base::search(), system = base::Sys.info())
[10:21:44.410]                   }
[10:21:44.410]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.410]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.410]                     cond$call), session = sessionInformation(), 
[10:21:44.410]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.410]                   signalCondition(cond)
[10:21:44.410]                 }
[10:21:44.410]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.410]                 "immediateCondition"))) {
[10:21:44.410]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.410]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.410]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.410]                   if (TRUE && !signal) {
[10:21:44.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.410]                     {
[10:21:44.410]                       inherits <- base::inherits
[10:21:44.410]                       invokeRestart <- base::invokeRestart
[10:21:44.410]                       is.null <- base::is.null
[10:21:44.410]                       muffled <- FALSE
[10:21:44.410]                       if (inherits(cond, "message")) {
[10:21:44.410]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.410]                         if (muffled) 
[10:21:44.410]                           invokeRestart("muffleMessage")
[10:21:44.410]                       }
[10:21:44.410]                       else if (inherits(cond, "warning")) {
[10:21:44.410]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.410]                         if (muffled) 
[10:21:44.410]                           invokeRestart("muffleWarning")
[10:21:44.410]                       }
[10:21:44.410]                       else if (inherits(cond, "condition")) {
[10:21:44.410]                         if (!is.null(pattern)) {
[10:21:44.410]                           computeRestarts <- base::computeRestarts
[10:21:44.410]                           grepl <- base::grepl
[10:21:44.410]                           restarts <- computeRestarts(cond)
[10:21:44.410]                           for (restart in restarts) {
[10:21:44.410]                             name <- restart$name
[10:21:44.410]                             if (is.null(name)) 
[10:21:44.410]                               next
[10:21:44.410]                             if (!grepl(pattern, name)) 
[10:21:44.410]                               next
[10:21:44.410]                             invokeRestart(restart)
[10:21:44.410]                             muffled <- TRUE
[10:21:44.410]                             break
[10:21:44.410]                           }
[10:21:44.410]                         }
[10:21:44.410]                       }
[10:21:44.410]                       invisible(muffled)
[10:21:44.410]                     }
[10:21:44.410]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.410]                   }
[10:21:44.410]                 }
[10:21:44.410]                 else {
[10:21:44.410]                   if (TRUE) {
[10:21:44.410]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.410]                     {
[10:21:44.410]                       inherits <- base::inherits
[10:21:44.410]                       invokeRestart <- base::invokeRestart
[10:21:44.410]                       is.null <- base::is.null
[10:21:44.410]                       muffled <- FALSE
[10:21:44.410]                       if (inherits(cond, "message")) {
[10:21:44.410]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.410]                         if (muffled) 
[10:21:44.410]                           invokeRestart("muffleMessage")
[10:21:44.410]                       }
[10:21:44.410]                       else if (inherits(cond, "warning")) {
[10:21:44.410]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.410]                         if (muffled) 
[10:21:44.410]                           invokeRestart("muffleWarning")
[10:21:44.410]                       }
[10:21:44.410]                       else if (inherits(cond, "condition")) {
[10:21:44.410]                         if (!is.null(pattern)) {
[10:21:44.410]                           computeRestarts <- base::computeRestarts
[10:21:44.410]                           grepl <- base::grepl
[10:21:44.410]                           restarts <- computeRestarts(cond)
[10:21:44.410]                           for (restart in restarts) {
[10:21:44.410]                             name <- restart$name
[10:21:44.410]                             if (is.null(name)) 
[10:21:44.410]                               next
[10:21:44.410]                             if (!grepl(pattern, name)) 
[10:21:44.410]                               next
[10:21:44.410]                             invokeRestart(restart)
[10:21:44.410]                             muffled <- TRUE
[10:21:44.410]                             break
[10:21:44.410]                           }
[10:21:44.410]                         }
[10:21:44.410]                       }
[10:21:44.410]                       invisible(muffled)
[10:21:44.410]                     }
[10:21:44.410]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.410]                   }
[10:21:44.410]                 }
[10:21:44.410]             }
[10:21:44.410]         }))
[10:21:44.410]     }, error = function(ex) {
[10:21:44.410]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.410]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.410]                 ...future.rng), started = ...future.startTime, 
[10:21:44.410]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.410]             version = "1.8"), class = "FutureResult")
[10:21:44.410]     }, finally = {
[10:21:44.410]         if (!identical(...future.workdir, getwd())) 
[10:21:44.410]             setwd(...future.workdir)
[10:21:44.410]         {
[10:21:44.410]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.410]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.410]             }
[10:21:44.410]             base::options(...future.oldOptions)
[10:21:44.410]             if (.Platform$OS.type == "windows") {
[10:21:44.410]                 old_names <- names(...future.oldEnvVars)
[10:21:44.410]                 envs <- base::Sys.getenv()
[10:21:44.410]                 names <- names(envs)
[10:21:44.410]                 common <- intersect(names, old_names)
[10:21:44.410]                 added <- setdiff(names, old_names)
[10:21:44.410]                 removed <- setdiff(old_names, names)
[10:21:44.410]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.410]                   envs[common]]
[10:21:44.410]                 NAMES <- toupper(changed)
[10:21:44.410]                 args <- list()
[10:21:44.410]                 for (kk in seq_along(NAMES)) {
[10:21:44.410]                   name <- changed[[kk]]
[10:21:44.410]                   NAME <- NAMES[[kk]]
[10:21:44.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.410]                     next
[10:21:44.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.410]                 }
[10:21:44.410]                 NAMES <- toupper(added)
[10:21:44.410]                 for (kk in seq_along(NAMES)) {
[10:21:44.410]                   name <- added[[kk]]
[10:21:44.410]                   NAME <- NAMES[[kk]]
[10:21:44.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.410]                     next
[10:21:44.410]                   args[[name]] <- ""
[10:21:44.410]                 }
[10:21:44.410]                 NAMES <- toupper(removed)
[10:21:44.410]                 for (kk in seq_along(NAMES)) {
[10:21:44.410]                   name <- removed[[kk]]
[10:21:44.410]                   NAME <- NAMES[[kk]]
[10:21:44.410]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.410]                     next
[10:21:44.410]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.410]                 }
[10:21:44.410]                 if (length(args) > 0) 
[10:21:44.410]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.410]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.410]             }
[10:21:44.410]             else {
[10:21:44.410]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.410]             }
[10:21:44.410]             {
[10:21:44.410]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.410]                   0L) {
[10:21:44.410]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.410]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.410]                   base::options(opts)
[10:21:44.410]                 }
[10:21:44.410]                 {
[10:21:44.410]                   {
[10:21:44.410]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.410]                     NULL
[10:21:44.410]                   }
[10:21:44.410]                   options(future.plan = NULL)
[10:21:44.410]                   if (is.na(NA_character_)) 
[10:21:44.410]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.410]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.410]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.410]                     .init = FALSE)
[10:21:44.410]                 }
[10:21:44.410]             }
[10:21:44.410]         }
[10:21:44.410]     })
[10:21:44.410]     if (TRUE) {
[10:21:44.410]         base::sink(type = "output", split = FALSE)
[10:21:44.410]         if (TRUE) {
[10:21:44.410]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.410]         }
[10:21:44.410]         else {
[10:21:44.410]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.410]         }
[10:21:44.410]         base::close(...future.stdout)
[10:21:44.410]         ...future.stdout <- NULL
[10:21:44.410]     }
[10:21:44.410]     ...future.result$conditions <- ...future.conditions
[10:21:44.410]     ...future.result$finished <- base::Sys.time()
[10:21:44.410]     ...future.result
[10:21:44.410] }
[10:21:44.414] requestCore(): workers = 2
[10:21:44.416] MulticoreFuture started
[10:21:44.416] - Launch lazy future ... done
[10:21:44.416] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.416] plan(): Setting new future strategy stack:
[10:21:44.417] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.417] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.417] List of future strategies:
[10:21:44.417] 1. sequential:
[10:21:44.417]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.417]    - tweaked: FALSE
[10:21:44.417]    - call: NULL
[10:21:44.418] plan(): nbrOfWorkers() = 1
[10:21:44.419] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:44.419] Searching for globals ... DONE
[10:21:44.419] Resolving globals: TRUE
[10:21:44.419] Resolving any globals that are futures ...
[10:21:44.419] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:44.419] Resolving any globals that are futures ... DONE
[10:21:44.420] plan(): Setting new future strategy stack:
[10:21:44.420] Resolving futures part of globals (recursively) ...
[10:21:44.420] List of future strategies:
[10:21:44.420] 1. multicore:
[10:21:44.420]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.420]    - tweaked: FALSE
[10:21:44.420]    - call: plan(strategy)
[10:21:44.421] resolve() on list ...
[10:21:44.421]  recursive: 99
[10:21:44.421]  length: 1
[10:21:44.421]  elements: ‘a’
[10:21:44.423] plan(): nbrOfWorkers() = 2
[10:21:44.423] Future #1
[10:21:44.423] result() for MulticoreFuture ...
[10:21:44.424] result() for MulticoreFuture ...
[10:21:44.424] result() for MulticoreFuture ... done
[10:21:44.424] result() for MulticoreFuture ... done
[10:21:44.425] result() for MulticoreFuture ...
[10:21:44.425] result() for MulticoreFuture ... done
[10:21:44.425] A MulticoreFuture was resolved
[10:21:44.425]  length: 0 (resolved future 1)
[10:21:44.425] resolve() on list ... DONE
[10:21:44.425] - globals: [1] ‘a’
[10:21:44.426] Resolving futures part of globals (recursively) ... DONE
[10:21:44.426] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[10:21:44.426] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[10:21:44.426] - globals: [1] ‘a’
[10:21:44.427] - packages: [1] ‘future’
[10:21:44.427] getGlobalsAndPackages() ... DONE
[10:21:44.427] run() for ‘Future’ ...
[10:21:44.427] - state: ‘created’
[10:21:44.427] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.429] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.430] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.430]   - Field: ‘label’
[10:21:44.430]   - Field: ‘local’
[10:21:44.430]   - Field: ‘owner’
[10:21:44.430]   - Field: ‘envir’
[10:21:44.430]   - Field: ‘workers’
[10:21:44.430]   - Field: ‘packages’
[10:21:44.433]   - Field: ‘gc’
[10:21:44.433]   - Field: ‘job’
[10:21:44.433]   - Field: ‘conditions’
[10:21:44.434]   - Field: ‘expr’
[10:21:44.434]   - Field: ‘uuid’
[10:21:44.434]   - Field: ‘seed’
[10:21:44.434]   - Field: ‘version’
[10:21:44.434]   - Field: ‘result’
[10:21:44.434]   - Field: ‘asynchronous’
[10:21:44.435]   - Field: ‘calls’
[10:21:44.435]   - Field: ‘globals’
[10:21:44.435]   - Field: ‘stdout’
[10:21:44.435]   - Field: ‘earlySignal’
[10:21:44.435]   - Field: ‘lazy’
[10:21:44.435]   - Field: ‘state’
[10:21:44.436] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.436] - Launch lazy future ...
[10:21:44.436] Packages needed by the future expression (n = 1): ‘future’
[10:21:44.436] Packages needed by future strategies (n = 0): <none>
[10:21:44.437] {
[10:21:44.437]     {
[10:21:44.437]         {
[10:21:44.437]             ...future.startTime <- base::Sys.time()
[10:21:44.437]             {
[10:21:44.437]                 {
[10:21:44.437]                   {
[10:21:44.437]                     {
[10:21:44.437]                       {
[10:21:44.437]                         base::local({
[10:21:44.437]                           has_future <- base::requireNamespace("future", 
[10:21:44.437]                             quietly = TRUE)
[10:21:44.437]                           if (has_future) {
[10:21:44.437]                             ns <- base::getNamespace("future")
[10:21:44.437]                             version <- ns[[".package"]][["version"]]
[10:21:44.437]                             if (is.null(version)) 
[10:21:44.437]                               version <- utils::packageVersion("future")
[10:21:44.437]                           }
[10:21:44.437]                           else {
[10:21:44.437]                             version <- NULL
[10:21:44.437]                           }
[10:21:44.437]                           if (!has_future || version < "1.8.0") {
[10:21:44.437]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.437]                               "", base::R.version$version.string), 
[10:21:44.437]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:44.437]                                 base::R.version$platform, 8 * 
[10:21:44.437]                                   base::.Machine$sizeof.pointer), 
[10:21:44.437]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.437]                                 "release", "version")], collapse = " "), 
[10:21:44.437]                               hostname = base::Sys.info()[["nodename"]])
[10:21:44.437]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.437]                               info)
[10:21:44.437]                             info <- base::paste(info, collapse = "; ")
[10:21:44.437]                             if (!has_future) {
[10:21:44.437]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.437]                                 info)
[10:21:44.437]                             }
[10:21:44.437]                             else {
[10:21:44.437]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.437]                                 info, version)
[10:21:44.437]                             }
[10:21:44.437]                             base::stop(msg)
[10:21:44.437]                           }
[10:21:44.437]                         })
[10:21:44.437]                       }
[10:21:44.437]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.437]                       base::options(mc.cores = 1L)
[10:21:44.437]                     }
[10:21:44.437]                     base::local({
[10:21:44.437]                       for (pkg in "future") {
[10:21:44.437]                         base::loadNamespace(pkg)
[10:21:44.437]                         base::library(pkg, character.only = TRUE)
[10:21:44.437]                       }
[10:21:44.437]                     })
[10:21:44.437]                   }
[10:21:44.437]                   ...future.strategy.old <- future::plan("list")
[10:21:44.437]                   options(future.plan = NULL)
[10:21:44.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.437]                 }
[10:21:44.437]                 ...future.workdir <- getwd()
[10:21:44.437]             }
[10:21:44.437]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.437]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.437]         }
[10:21:44.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.437]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.437]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.437]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.437]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.437]             base::names(...future.oldOptions))
[10:21:44.437]     }
[10:21:44.437]     if (FALSE) {
[10:21:44.437]     }
[10:21:44.437]     else {
[10:21:44.437]         if (TRUE) {
[10:21:44.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.437]                 open = "w")
[10:21:44.437]         }
[10:21:44.437]         else {
[10:21:44.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.437]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.437]         }
[10:21:44.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.437]             base::sink(type = "output", split = FALSE)
[10:21:44.437]             base::close(...future.stdout)
[10:21:44.437]         }, add = TRUE)
[10:21:44.437]     }
[10:21:44.437]     ...future.frame <- base::sys.nframe()
[10:21:44.437]     ...future.conditions <- base::list()
[10:21:44.437]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.437]     if (FALSE) {
[10:21:44.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.437]     }
[10:21:44.437]     ...future.result <- base::tryCatch({
[10:21:44.437]         base::withCallingHandlers({
[10:21:44.437]             ...future.value <- base::withVisible(base::local({
[10:21:44.437]                 withCallingHandlers({
[10:21:44.437]                   value(a) + 1
[10:21:44.437]                 }, immediateCondition = function(cond) {
[10:21:44.437]                   save_rds <- function (object, pathname, ...) 
[10:21:44.437]                   {
[10:21:44.437]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.437]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.437]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.437]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.437]                         fi_tmp[["mtime"]])
[10:21:44.437]                     }
[10:21:44.437]                     tryCatch({
[10:21:44.437]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.437]                     }, error = function(ex) {
[10:21:44.437]                       msg <- conditionMessage(ex)
[10:21:44.437]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.437]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.437]                         fi_tmp[["mtime"]], msg)
[10:21:44.437]                       ex$message <- msg
[10:21:44.437]                       stop(ex)
[10:21:44.437]                     })
[10:21:44.437]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.437]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.437]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.437]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.437]                       fi <- file.info(pathname)
[10:21:44.437]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.437]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.437]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.437]                         fi[["size"]], fi[["mtime"]])
[10:21:44.437]                       stop(msg)
[10:21:44.437]                     }
[10:21:44.437]                     invisible(pathname)
[10:21:44.437]                   }
[10:21:44.437]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.437]                     rootPath = tempdir()) 
[10:21:44.437]                   {
[10:21:44.437]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.437]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.437]                       tmpdir = path, fileext = ".rds")
[10:21:44.437]                     save_rds(obj, file)
[10:21:44.437]                   }
[10:21:44.437]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.437]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.437]                   {
[10:21:44.437]                     inherits <- base::inherits
[10:21:44.437]                     invokeRestart <- base::invokeRestart
[10:21:44.437]                     is.null <- base::is.null
[10:21:44.437]                     muffled <- FALSE
[10:21:44.437]                     if (inherits(cond, "message")) {
[10:21:44.437]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.437]                       if (muffled) 
[10:21:44.437]                         invokeRestart("muffleMessage")
[10:21:44.437]                     }
[10:21:44.437]                     else if (inherits(cond, "warning")) {
[10:21:44.437]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.437]                       if (muffled) 
[10:21:44.437]                         invokeRestart("muffleWarning")
[10:21:44.437]                     }
[10:21:44.437]                     else if (inherits(cond, "condition")) {
[10:21:44.437]                       if (!is.null(pattern)) {
[10:21:44.437]                         computeRestarts <- base::computeRestarts
[10:21:44.437]                         grepl <- base::grepl
[10:21:44.437]                         restarts <- computeRestarts(cond)
[10:21:44.437]                         for (restart in restarts) {
[10:21:44.437]                           name <- restart$name
[10:21:44.437]                           if (is.null(name)) 
[10:21:44.437]                             next
[10:21:44.437]                           if (!grepl(pattern, name)) 
[10:21:44.437]                             next
[10:21:44.437]                           invokeRestart(restart)
[10:21:44.437]                           muffled <- TRUE
[10:21:44.437]                           break
[10:21:44.437]                         }
[10:21:44.437]                       }
[10:21:44.437]                     }
[10:21:44.437]                     invisible(muffled)
[10:21:44.437]                   }
[10:21:44.437]                   muffleCondition(cond)
[10:21:44.437]                 })
[10:21:44.437]             }))
[10:21:44.437]             future::FutureResult(value = ...future.value$value, 
[10:21:44.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.437]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.437]                     ...future.globalenv.names))
[10:21:44.437]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.437]         }, condition = base::local({
[10:21:44.437]             c <- base::c
[10:21:44.437]             inherits <- base::inherits
[10:21:44.437]             invokeRestart <- base::invokeRestart
[10:21:44.437]             length <- base::length
[10:21:44.437]             list <- base::list
[10:21:44.437]             seq.int <- base::seq.int
[10:21:44.437]             signalCondition <- base::signalCondition
[10:21:44.437]             sys.calls <- base::sys.calls
[10:21:44.437]             `[[` <- base::`[[`
[10:21:44.437]             `+` <- base::`+`
[10:21:44.437]             `<<-` <- base::`<<-`
[10:21:44.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.437]                   3L)]
[10:21:44.437]             }
[10:21:44.437]             function(cond) {
[10:21:44.437]                 is_error <- inherits(cond, "error")
[10:21:44.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.437]                   NULL)
[10:21:44.437]                 if (is_error) {
[10:21:44.437]                   sessionInformation <- function() {
[10:21:44.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.437]                       search = base::search(), system = base::Sys.info())
[10:21:44.437]                   }
[10:21:44.437]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.437]                     cond$call), session = sessionInformation(), 
[10:21:44.437]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.437]                   signalCondition(cond)
[10:21:44.437]                 }
[10:21:44.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.437]                 "immediateCondition"))) {
[10:21:44.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.437]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.437]                   if (TRUE && !signal) {
[10:21:44.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.437]                     {
[10:21:44.437]                       inherits <- base::inherits
[10:21:44.437]                       invokeRestart <- base::invokeRestart
[10:21:44.437]                       is.null <- base::is.null
[10:21:44.437]                       muffled <- FALSE
[10:21:44.437]                       if (inherits(cond, "message")) {
[10:21:44.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.437]                         if (muffled) 
[10:21:44.437]                           invokeRestart("muffleMessage")
[10:21:44.437]                       }
[10:21:44.437]                       else if (inherits(cond, "warning")) {
[10:21:44.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.437]                         if (muffled) 
[10:21:44.437]                           invokeRestart("muffleWarning")
[10:21:44.437]                       }
[10:21:44.437]                       else if (inherits(cond, "condition")) {
[10:21:44.437]                         if (!is.null(pattern)) {
[10:21:44.437]                           computeRestarts <- base::computeRestarts
[10:21:44.437]                           grepl <- base::grepl
[10:21:44.437]                           restarts <- computeRestarts(cond)
[10:21:44.437]                           for (restart in restarts) {
[10:21:44.437]                             name <- restart$name
[10:21:44.437]                             if (is.null(name)) 
[10:21:44.437]                               next
[10:21:44.437]                             if (!grepl(pattern, name)) 
[10:21:44.437]                               next
[10:21:44.437]                             invokeRestart(restart)
[10:21:44.437]                             muffled <- TRUE
[10:21:44.437]                             break
[10:21:44.437]                           }
[10:21:44.437]                         }
[10:21:44.437]                       }
[10:21:44.437]                       invisible(muffled)
[10:21:44.437]                     }
[10:21:44.437]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.437]                   }
[10:21:44.437]                 }
[10:21:44.437]                 else {
[10:21:44.437]                   if (TRUE) {
[10:21:44.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.437]                     {
[10:21:44.437]                       inherits <- base::inherits
[10:21:44.437]                       invokeRestart <- base::invokeRestart
[10:21:44.437]                       is.null <- base::is.null
[10:21:44.437]                       muffled <- FALSE
[10:21:44.437]                       if (inherits(cond, "message")) {
[10:21:44.437]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.437]                         if (muffled) 
[10:21:44.437]                           invokeRestart("muffleMessage")
[10:21:44.437]                       }
[10:21:44.437]                       else if (inherits(cond, "warning")) {
[10:21:44.437]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.437]                         if (muffled) 
[10:21:44.437]                           invokeRestart("muffleWarning")
[10:21:44.437]                       }
[10:21:44.437]                       else if (inherits(cond, "condition")) {
[10:21:44.437]                         if (!is.null(pattern)) {
[10:21:44.437]                           computeRestarts <- base::computeRestarts
[10:21:44.437]                           grepl <- base::grepl
[10:21:44.437]                           restarts <- computeRestarts(cond)
[10:21:44.437]                           for (restart in restarts) {
[10:21:44.437]                             name <- restart$name
[10:21:44.437]                             if (is.null(name)) 
[10:21:44.437]                               next
[10:21:44.437]                             if (!grepl(pattern, name)) 
[10:21:44.437]                               next
[10:21:44.437]                             invokeRestart(restart)
[10:21:44.437]                             muffled <- TRUE
[10:21:44.437]                             break
[10:21:44.437]                           }
[10:21:44.437]                         }
[10:21:44.437]                       }
[10:21:44.437]                       invisible(muffled)
[10:21:44.437]                     }
[10:21:44.437]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.437]                   }
[10:21:44.437]                 }
[10:21:44.437]             }
[10:21:44.437]         }))
[10:21:44.437]     }, error = function(ex) {
[10:21:44.437]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.437]                 ...future.rng), started = ...future.startTime, 
[10:21:44.437]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.437]             version = "1.8"), class = "FutureResult")
[10:21:44.437]     }, finally = {
[10:21:44.437]         if (!identical(...future.workdir, getwd())) 
[10:21:44.437]             setwd(...future.workdir)
[10:21:44.437]         {
[10:21:44.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.437]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.437]             }
[10:21:44.437]             base::options(...future.oldOptions)
[10:21:44.437]             if (.Platform$OS.type == "windows") {
[10:21:44.437]                 old_names <- names(...future.oldEnvVars)
[10:21:44.437]                 envs <- base::Sys.getenv()
[10:21:44.437]                 names <- names(envs)
[10:21:44.437]                 common <- intersect(names, old_names)
[10:21:44.437]                 added <- setdiff(names, old_names)
[10:21:44.437]                 removed <- setdiff(old_names, names)
[10:21:44.437]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.437]                   envs[common]]
[10:21:44.437]                 NAMES <- toupper(changed)
[10:21:44.437]                 args <- list()
[10:21:44.437]                 for (kk in seq_along(NAMES)) {
[10:21:44.437]                   name <- changed[[kk]]
[10:21:44.437]                   NAME <- NAMES[[kk]]
[10:21:44.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.437]                     next
[10:21:44.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.437]                 }
[10:21:44.437]                 NAMES <- toupper(added)
[10:21:44.437]                 for (kk in seq_along(NAMES)) {
[10:21:44.437]                   name <- added[[kk]]
[10:21:44.437]                   NAME <- NAMES[[kk]]
[10:21:44.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.437]                     next
[10:21:44.437]                   args[[name]] <- ""
[10:21:44.437]                 }
[10:21:44.437]                 NAMES <- toupper(removed)
[10:21:44.437]                 for (kk in seq_along(NAMES)) {
[10:21:44.437]                   name <- removed[[kk]]
[10:21:44.437]                   NAME <- NAMES[[kk]]
[10:21:44.437]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.437]                     next
[10:21:44.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.437]                 }
[10:21:44.437]                 if (length(args) > 0) 
[10:21:44.437]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.437]             }
[10:21:44.437]             else {
[10:21:44.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.437]             }
[10:21:44.437]             {
[10:21:44.437]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.437]                   0L) {
[10:21:44.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.437]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.437]                   base::options(opts)
[10:21:44.437]                 }
[10:21:44.437]                 {
[10:21:44.437]                   {
[10:21:44.437]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.437]                     NULL
[10:21:44.437]                   }
[10:21:44.437]                   options(future.plan = NULL)
[10:21:44.437]                   if (is.na(NA_character_)) 
[10:21:44.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.437]                     .init = FALSE)
[10:21:44.437]                 }
[10:21:44.437]             }
[10:21:44.437]         }
[10:21:44.437]     })
[10:21:44.437]     if (TRUE) {
[10:21:44.437]         base::sink(type = "output", split = FALSE)
[10:21:44.437]         if (TRUE) {
[10:21:44.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.437]         }
[10:21:44.437]         else {
[10:21:44.437]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.437]         }
[10:21:44.437]         base::close(...future.stdout)
[10:21:44.437]         ...future.stdout <- NULL
[10:21:44.437]     }
[10:21:44.437]     ...future.result$conditions <- ...future.conditions
[10:21:44.437]     ...future.result$finished <- base::Sys.time()
[10:21:44.437]     ...future.result
[10:21:44.437] }
[10:21:44.439] assign_globals() ...
[10:21:44.440] List of 1
[10:21:44.440]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18c618b70> 
[10:21:44.440]  - attr(*, "where")=List of 1
[10:21:44.440]   ..$ a:<environment: R_EmptyEnv> 
[10:21:44.440]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.440]  - attr(*, "resolved")= logi TRUE
[10:21:44.440]  - attr(*, "total_size")= num 3815
[10:21:44.440]  - attr(*, "already-done")= logi TRUE
[10:21:44.443] - copied ‘a’ to environment
[10:21:44.443] assign_globals() ... done
[10:21:44.443] requestCore(): workers = 2
[10:21:44.445] MulticoreFuture started
[10:21:44.445] - Launch lazy future ... done
[10:21:44.446] run() for ‘MulticoreFuture’ ... done
[10:21:44.446] result() for MulticoreFuture ...
[10:21:44.447] plan(): Setting new future strategy stack:
[10:21:44.447] List of future strategies:
[10:21:44.447] 1. sequential:
[10:21:44.447]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.447]    - tweaked: FALSE
[10:21:44.447]    - call: NULL
[10:21:44.448] plan(): nbrOfWorkers() = 1
[10:21:44.451] plan(): Setting new future strategy stack:
[10:21:44.451] List of future strategies:
[10:21:44.451] 1. multicore:
[10:21:44.451]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.451]    - tweaked: FALSE
[10:21:44.451]    - call: plan(strategy)
[10:21:44.455] plan(): nbrOfWorkers() = 2
[10:21:44.456] result() for MulticoreFuture ...
[10:21:44.456] result() for MulticoreFuture ... done
[10:21:44.456] signalConditions() ...
[10:21:44.456]  - include = ‘immediateCondition’
[10:21:44.456]  - exclude = 
[10:21:44.456]  - resignal = FALSE
[10:21:44.456]  - Number of conditions: 4
[10:21:44.457] signalConditions() ... done
[10:21:44.457] result() for MulticoreFuture ... done
[10:21:44.457] result() for MulticoreFuture ...
[10:21:44.457] result() for MulticoreFuture ... done
[10:21:44.457] signalConditions() ...
[10:21:44.457]  - include = ‘immediateCondition’
[10:21:44.457]  - exclude = 
[10:21:44.457]  - resignal = FALSE
[10:21:44.458]  - Number of conditions: 4
[10:21:44.458] signalConditions() ... done
[10:21:44.458] Future state: ‘finished’
[10:21:44.458] result() for MulticoreFuture ...
[10:21:44.458] result() for MulticoreFuture ... done
[10:21:44.458] signalConditions() ...
[10:21:44.458]  - include = ‘condition’
[10:21:44.459]  - exclude = ‘immediateCondition’
[10:21:44.459]  - resignal = TRUE
[10:21:44.459]  - Number of conditions: 4
[10:21:44.459]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.449] result() for MulticoreFuture ...
[10:21:44.459]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.449] result() for MulticoreFuture ... done
[10:21:44.459]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.450] result() for MulticoreFuture ...
[10:21:44.459]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.450] result() for MulticoreFuture ... done
[10:21:44.460] signalConditions() ... done
value(b) = 2
[10:21:44.460] result() for MulticoreFuture ...
[10:21:44.460] result() for MulticoreFuture ... done
[10:21:44.460] result() for MulticoreFuture ...
[10:21:44.460] result() for MulticoreFuture ... done
[10:21:44.460] signalConditions() ...
[10:21:44.460]  - include = ‘immediateCondition’
[10:21:44.460]  - exclude = 
[10:21:44.460]  - resignal = FALSE
[10:21:44.461]  - Number of conditions: 4
[10:21:44.461] signalConditions() ... done
[10:21:44.461] Future state: ‘finished’
[10:21:44.461] result() for MulticoreFuture ...
[10:21:44.461] result() for MulticoreFuture ... done
[10:21:44.461] signalConditions() ...
[10:21:44.461]  - include = ‘condition’
[10:21:44.461]  - exclude = ‘immediateCondition’
[10:21:44.462]  - resignal = TRUE
[10:21:44.462]  - Number of conditions: 4
[10:21:44.462]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.449] result() for MulticoreFuture ...
[10:21:44.462]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.449] result() for MulticoreFuture ... done
[10:21:44.462]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.450] result() for MulticoreFuture ...
[10:21:44.462]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.450] result() for MulticoreFuture ... done
[10:21:44.462] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.463] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.463] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.464] 
[10:21:44.464] Searching for globals ... DONE
[10:21:44.464] - globals: [0] <none>
[10:21:44.464] getGlobalsAndPackages() ... DONE
[10:21:44.464] run() for ‘Future’ ...
[10:21:44.464] - state: ‘created’
[10:21:44.465] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.467] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.467] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.467]   - Field: ‘label’
[10:21:44.467]   - Field: ‘local’
[10:21:44.467]   - Field: ‘owner’
[10:21:44.467]   - Field: ‘envir’
[10:21:44.467]   - Field: ‘workers’
[10:21:44.468]   - Field: ‘packages’
[10:21:44.468]   - Field: ‘gc’
[10:21:44.468]   - Field: ‘job’
[10:21:44.468]   - Field: ‘conditions’
[10:21:44.468]   - Field: ‘expr’
[10:21:44.468]   - Field: ‘uuid’
[10:21:44.468]   - Field: ‘seed’
[10:21:44.468]   - Field: ‘version’
[10:21:44.468]   - Field: ‘result’
[10:21:44.469]   - Field: ‘asynchronous’
[10:21:44.469]   - Field: ‘calls’
[10:21:44.469]   - Field: ‘globals’
[10:21:44.469]   - Field: ‘stdout’
[10:21:44.469]   - Field: ‘earlySignal’
[10:21:44.469]   - Field: ‘lazy’
[10:21:44.469]   - Field: ‘state’
[10:21:44.469] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.469] - Launch lazy future ...
[10:21:44.470] Packages needed by the future expression (n = 0): <none>
[10:21:44.470] Packages needed by future strategies (n = 0): <none>
[10:21:44.470] {
[10:21:44.470]     {
[10:21:44.470]         {
[10:21:44.470]             ...future.startTime <- base::Sys.time()
[10:21:44.470]             {
[10:21:44.470]                 {
[10:21:44.470]                   {
[10:21:44.470]                     {
[10:21:44.470]                       base::local({
[10:21:44.470]                         has_future <- base::requireNamespace("future", 
[10:21:44.470]                           quietly = TRUE)
[10:21:44.470]                         if (has_future) {
[10:21:44.470]                           ns <- base::getNamespace("future")
[10:21:44.470]                           version <- ns[[".package"]][["version"]]
[10:21:44.470]                           if (is.null(version)) 
[10:21:44.470]                             version <- utils::packageVersion("future")
[10:21:44.470]                         }
[10:21:44.470]                         else {
[10:21:44.470]                           version <- NULL
[10:21:44.470]                         }
[10:21:44.470]                         if (!has_future || version < "1.8.0") {
[10:21:44.470]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.470]                             "", base::R.version$version.string), 
[10:21:44.470]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.470]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.470]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.470]                               "release", "version")], collapse = " "), 
[10:21:44.470]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.470]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.470]                             info)
[10:21:44.470]                           info <- base::paste(info, collapse = "; ")
[10:21:44.470]                           if (!has_future) {
[10:21:44.470]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.470]                               info)
[10:21:44.470]                           }
[10:21:44.470]                           else {
[10:21:44.470]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.470]                               info, version)
[10:21:44.470]                           }
[10:21:44.470]                           base::stop(msg)
[10:21:44.470]                         }
[10:21:44.470]                       })
[10:21:44.470]                     }
[10:21:44.470]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.470]                     base::options(mc.cores = 1L)
[10:21:44.470]                   }
[10:21:44.470]                   ...future.strategy.old <- future::plan("list")
[10:21:44.470]                   options(future.plan = NULL)
[10:21:44.470]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.470]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.470]                 }
[10:21:44.470]                 ...future.workdir <- getwd()
[10:21:44.470]             }
[10:21:44.470]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.470]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.470]         }
[10:21:44.470]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.470]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.470]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.470]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.470]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.470]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.470]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.470]             base::names(...future.oldOptions))
[10:21:44.470]     }
[10:21:44.470]     if (FALSE) {
[10:21:44.470]     }
[10:21:44.470]     else {
[10:21:44.470]         if (TRUE) {
[10:21:44.470]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.470]                 open = "w")
[10:21:44.470]         }
[10:21:44.470]         else {
[10:21:44.470]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.470]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.470]         }
[10:21:44.470]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.470]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.470]             base::sink(type = "output", split = FALSE)
[10:21:44.470]             base::close(...future.stdout)
[10:21:44.470]         }, add = TRUE)
[10:21:44.470]     }
[10:21:44.470]     ...future.frame <- base::sys.nframe()
[10:21:44.470]     ...future.conditions <- base::list()
[10:21:44.470]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.470]     if (FALSE) {
[10:21:44.470]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.470]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.470]     }
[10:21:44.470]     ...future.result <- base::tryCatch({
[10:21:44.470]         base::withCallingHandlers({
[10:21:44.470]             ...future.value <- base::withVisible(base::local({
[10:21:44.470]                 withCallingHandlers({
[10:21:44.470]                   1
[10:21:44.470]                 }, immediateCondition = function(cond) {
[10:21:44.470]                   save_rds <- function (object, pathname, ...) 
[10:21:44.470]                   {
[10:21:44.470]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.470]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.470]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.470]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.470]                         fi_tmp[["mtime"]])
[10:21:44.470]                     }
[10:21:44.470]                     tryCatch({
[10:21:44.470]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.470]                     }, error = function(ex) {
[10:21:44.470]                       msg <- conditionMessage(ex)
[10:21:44.470]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.470]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.470]                         fi_tmp[["mtime"]], msg)
[10:21:44.470]                       ex$message <- msg
[10:21:44.470]                       stop(ex)
[10:21:44.470]                     })
[10:21:44.470]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.470]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.470]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.470]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.470]                       fi <- file.info(pathname)
[10:21:44.470]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.470]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.470]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.470]                         fi[["size"]], fi[["mtime"]])
[10:21:44.470]                       stop(msg)
[10:21:44.470]                     }
[10:21:44.470]                     invisible(pathname)
[10:21:44.470]                   }
[10:21:44.470]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.470]                     rootPath = tempdir()) 
[10:21:44.470]                   {
[10:21:44.470]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.470]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.470]                       tmpdir = path, fileext = ".rds")
[10:21:44.470]                     save_rds(obj, file)
[10:21:44.470]                   }
[10:21:44.470]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.470]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.470]                   {
[10:21:44.470]                     inherits <- base::inherits
[10:21:44.470]                     invokeRestart <- base::invokeRestart
[10:21:44.470]                     is.null <- base::is.null
[10:21:44.470]                     muffled <- FALSE
[10:21:44.470]                     if (inherits(cond, "message")) {
[10:21:44.470]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.470]                       if (muffled) 
[10:21:44.470]                         invokeRestart("muffleMessage")
[10:21:44.470]                     }
[10:21:44.470]                     else if (inherits(cond, "warning")) {
[10:21:44.470]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.470]                       if (muffled) 
[10:21:44.470]                         invokeRestart("muffleWarning")
[10:21:44.470]                     }
[10:21:44.470]                     else if (inherits(cond, "condition")) {
[10:21:44.470]                       if (!is.null(pattern)) {
[10:21:44.470]                         computeRestarts <- base::computeRestarts
[10:21:44.470]                         grepl <- base::grepl
[10:21:44.470]                         restarts <- computeRestarts(cond)
[10:21:44.470]                         for (restart in restarts) {
[10:21:44.470]                           name <- restart$name
[10:21:44.470]                           if (is.null(name)) 
[10:21:44.470]                             next
[10:21:44.470]                           if (!grepl(pattern, name)) 
[10:21:44.470]                             next
[10:21:44.470]                           invokeRestart(restart)
[10:21:44.470]                           muffled <- TRUE
[10:21:44.470]                           break
[10:21:44.470]                         }
[10:21:44.470]                       }
[10:21:44.470]                     }
[10:21:44.470]                     invisible(muffled)
[10:21:44.470]                   }
[10:21:44.470]                   muffleCondition(cond)
[10:21:44.470]                 })
[10:21:44.470]             }))
[10:21:44.470]             future::FutureResult(value = ...future.value$value, 
[10:21:44.470]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.470]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.470]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.470]                     ...future.globalenv.names))
[10:21:44.470]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.470]         }, condition = base::local({
[10:21:44.470]             c <- base::c
[10:21:44.470]             inherits <- base::inherits
[10:21:44.470]             invokeRestart <- base::invokeRestart
[10:21:44.470]             length <- base::length
[10:21:44.470]             list <- base::list
[10:21:44.470]             seq.int <- base::seq.int
[10:21:44.470]             signalCondition <- base::signalCondition
[10:21:44.470]             sys.calls <- base::sys.calls
[10:21:44.470]             `[[` <- base::`[[`
[10:21:44.470]             `+` <- base::`+`
[10:21:44.470]             `<<-` <- base::`<<-`
[10:21:44.470]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.470]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.470]                   3L)]
[10:21:44.470]             }
[10:21:44.470]             function(cond) {
[10:21:44.470]                 is_error <- inherits(cond, "error")
[10:21:44.470]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.470]                   NULL)
[10:21:44.470]                 if (is_error) {
[10:21:44.470]                   sessionInformation <- function() {
[10:21:44.470]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.470]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.470]                       search = base::search(), system = base::Sys.info())
[10:21:44.470]                   }
[10:21:44.470]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.470]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.470]                     cond$call), session = sessionInformation(), 
[10:21:44.470]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.470]                   signalCondition(cond)
[10:21:44.470]                 }
[10:21:44.470]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.470]                 "immediateCondition"))) {
[10:21:44.470]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.470]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.470]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.470]                   if (TRUE && !signal) {
[10:21:44.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.470]                     {
[10:21:44.470]                       inherits <- base::inherits
[10:21:44.470]                       invokeRestart <- base::invokeRestart
[10:21:44.470]                       is.null <- base::is.null
[10:21:44.470]                       muffled <- FALSE
[10:21:44.470]                       if (inherits(cond, "message")) {
[10:21:44.470]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.470]                         if (muffled) 
[10:21:44.470]                           invokeRestart("muffleMessage")
[10:21:44.470]                       }
[10:21:44.470]                       else if (inherits(cond, "warning")) {
[10:21:44.470]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.470]                         if (muffled) 
[10:21:44.470]                           invokeRestart("muffleWarning")
[10:21:44.470]                       }
[10:21:44.470]                       else if (inherits(cond, "condition")) {
[10:21:44.470]                         if (!is.null(pattern)) {
[10:21:44.470]                           computeRestarts <- base::computeRestarts
[10:21:44.470]                           grepl <- base::grepl
[10:21:44.470]                           restarts <- computeRestarts(cond)
[10:21:44.470]                           for (restart in restarts) {
[10:21:44.470]                             name <- restart$name
[10:21:44.470]                             if (is.null(name)) 
[10:21:44.470]                               next
[10:21:44.470]                             if (!grepl(pattern, name)) 
[10:21:44.470]                               next
[10:21:44.470]                             invokeRestart(restart)
[10:21:44.470]                             muffled <- TRUE
[10:21:44.470]                             break
[10:21:44.470]                           }
[10:21:44.470]                         }
[10:21:44.470]                       }
[10:21:44.470]                       invisible(muffled)
[10:21:44.470]                     }
[10:21:44.470]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.470]                   }
[10:21:44.470]                 }
[10:21:44.470]                 else {
[10:21:44.470]                   if (TRUE) {
[10:21:44.470]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.470]                     {
[10:21:44.470]                       inherits <- base::inherits
[10:21:44.470]                       invokeRestart <- base::invokeRestart
[10:21:44.470]                       is.null <- base::is.null
[10:21:44.470]                       muffled <- FALSE
[10:21:44.470]                       if (inherits(cond, "message")) {
[10:21:44.470]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.470]                         if (muffled) 
[10:21:44.470]                           invokeRestart("muffleMessage")
[10:21:44.470]                       }
[10:21:44.470]                       else if (inherits(cond, "warning")) {
[10:21:44.470]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.470]                         if (muffled) 
[10:21:44.470]                           invokeRestart("muffleWarning")
[10:21:44.470]                       }
[10:21:44.470]                       else if (inherits(cond, "condition")) {
[10:21:44.470]                         if (!is.null(pattern)) {
[10:21:44.470]                           computeRestarts <- base::computeRestarts
[10:21:44.470]                           grepl <- base::grepl
[10:21:44.470]                           restarts <- computeRestarts(cond)
[10:21:44.470]                           for (restart in restarts) {
[10:21:44.470]                             name <- restart$name
[10:21:44.470]                             if (is.null(name)) 
[10:21:44.470]                               next
[10:21:44.470]                             if (!grepl(pattern, name)) 
[10:21:44.470]                               next
[10:21:44.470]                             invokeRestart(restart)
[10:21:44.470]                             muffled <- TRUE
[10:21:44.470]                             break
[10:21:44.470]                           }
[10:21:44.470]                         }
[10:21:44.470]                       }
[10:21:44.470]                       invisible(muffled)
[10:21:44.470]                     }
[10:21:44.470]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.470]                   }
[10:21:44.470]                 }
[10:21:44.470]             }
[10:21:44.470]         }))
[10:21:44.470]     }, error = function(ex) {
[10:21:44.470]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.470]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.470]                 ...future.rng), started = ...future.startTime, 
[10:21:44.470]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.470]             version = "1.8"), class = "FutureResult")
[10:21:44.470]     }, finally = {
[10:21:44.470]         if (!identical(...future.workdir, getwd())) 
[10:21:44.470]             setwd(...future.workdir)
[10:21:44.470]         {
[10:21:44.470]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.470]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.470]             }
[10:21:44.470]             base::options(...future.oldOptions)
[10:21:44.470]             if (.Platform$OS.type == "windows") {
[10:21:44.470]                 old_names <- names(...future.oldEnvVars)
[10:21:44.470]                 envs <- base::Sys.getenv()
[10:21:44.470]                 names <- names(envs)
[10:21:44.470]                 common <- intersect(names, old_names)
[10:21:44.470]                 added <- setdiff(names, old_names)
[10:21:44.470]                 removed <- setdiff(old_names, names)
[10:21:44.470]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.470]                   envs[common]]
[10:21:44.470]                 NAMES <- toupper(changed)
[10:21:44.470]                 args <- list()
[10:21:44.470]                 for (kk in seq_along(NAMES)) {
[10:21:44.470]                   name <- changed[[kk]]
[10:21:44.470]                   NAME <- NAMES[[kk]]
[10:21:44.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.470]                     next
[10:21:44.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.470]                 }
[10:21:44.470]                 NAMES <- toupper(added)
[10:21:44.470]                 for (kk in seq_along(NAMES)) {
[10:21:44.470]                   name <- added[[kk]]
[10:21:44.470]                   NAME <- NAMES[[kk]]
[10:21:44.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.470]                     next
[10:21:44.470]                   args[[name]] <- ""
[10:21:44.470]                 }
[10:21:44.470]                 NAMES <- toupper(removed)
[10:21:44.470]                 for (kk in seq_along(NAMES)) {
[10:21:44.470]                   name <- removed[[kk]]
[10:21:44.470]                   NAME <- NAMES[[kk]]
[10:21:44.470]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.470]                     next
[10:21:44.470]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.470]                 }
[10:21:44.470]                 if (length(args) > 0) 
[10:21:44.470]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.470]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.470]             }
[10:21:44.470]             else {
[10:21:44.470]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.470]             }
[10:21:44.470]             {
[10:21:44.470]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.470]                   0L) {
[10:21:44.470]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.470]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.470]                   base::options(opts)
[10:21:44.470]                 }
[10:21:44.470]                 {
[10:21:44.470]                   {
[10:21:44.470]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.470]                     NULL
[10:21:44.470]                   }
[10:21:44.470]                   options(future.plan = NULL)
[10:21:44.470]                   if (is.na(NA_character_)) 
[10:21:44.470]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.470]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.470]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.470]                     .init = FALSE)
[10:21:44.470]                 }
[10:21:44.470]             }
[10:21:44.470]         }
[10:21:44.470]     })
[10:21:44.470]     if (TRUE) {
[10:21:44.470]         base::sink(type = "output", split = FALSE)
[10:21:44.470]         if (TRUE) {
[10:21:44.470]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.470]         }
[10:21:44.470]         else {
[10:21:44.470]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.470]         }
[10:21:44.470]         base::close(...future.stdout)
[10:21:44.470]         ...future.stdout <- NULL
[10:21:44.470]     }
[10:21:44.470]     ...future.result$conditions <- ...future.conditions
[10:21:44.470]     ...future.result$finished <- base::Sys.time()
[10:21:44.470]     ...future.result
[10:21:44.470] }
[10:21:44.473] requestCore(): workers = 2
[10:21:44.475] MulticoreFuture started
[10:21:44.475] - Launch lazy future ... done
[10:21:44.476] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.476] plan(): Setting new future strategy stack:
[10:21:44.476] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.476] Searching for globals...
[10:21:44.476] List of future strategies:
[10:21:44.476] 1. sequential:
[10:21:44.476]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.476]    - tweaked: FALSE
[10:21:44.476]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :[10:21:44.477] plan(): nbrOfWorkers() = 1

  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.483] plan(): Setting new future strategy stack:
[10:21:44.484] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:44.483] List of future strategies:
[10:21:44.483] 1. multicore:
[10:21:44.483]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.483]    - tweaked: FALSE
[10:21:44.483]    - call: plan(strategy)
[10:21:44.484] Searching for globals ... DONE
[10:21:44.484] Resolving globals: TRUE
[10:21:44.485] Resolving any globals that are futures ...
[10:21:44.485] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:44.485] Resolving any globals that are futures ... DONE
[10:21:44.486] Resolving futures part of globals (recursively) ...
[10:21:44.486] resolve() on list ...
[10:21:44.486]  recursive: 99
[10:21:44.487] plan(): nbrOfWorkers() = 2
[10:21:44.487]  length: 1
[10:21:44.487]  elements: ‘a’
[10:21:44.487] Future #1
[10:21:44.488] result() for MulticoreFuture ...
[10:21:44.489] result() for MulticoreFuture ...
[10:21:44.489] result() for MulticoreFuture ... done
[10:21:44.489] result() for MulticoreFuture ... done
[10:21:44.489] result() for MulticoreFuture ...
[10:21:44.489] result() for MulticoreFuture ... done
[10:21:44.490] A MulticoreFuture was resolved
[10:21:44.490]  length: 0 (resolved future 1)
[10:21:44.490] resolve() on list ... DONE
[10:21:44.490] - globals: [1] ‘a’
[10:21:44.491] Resolving futures part of globals (recursively) ... DONE
[10:21:44.491] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[10:21:44.491] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[10:21:44.492] - globals: [1] ‘a’
[10:21:44.492] - packages: [1] ‘future’
[10:21:44.492] getGlobalsAndPackages() ... DONE
[10:21:44.492] run() for ‘Future’ ...
[10:21:44.492] - state: ‘created’
[10:21:44.493] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.495] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.495] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.495]   - Field: ‘label’
[10:21:44.495]   - Field: ‘local’
[10:21:44.495]   - Field: ‘owner’
[10:21:44.495]   - Field: ‘envir’
[10:21:44.495]   - Field: ‘workers’
[10:21:44.496]   - Field: ‘packages’
[10:21:44.496]   - Field: ‘gc’
[10:21:44.496]   - Field: ‘job’
[10:21:44.496]   - Field: ‘conditions’
[10:21:44.496]   - Field: ‘expr’
[10:21:44.496]   - Field: ‘uuid’
[10:21:44.496]   - Field: ‘seed’
[10:21:44.496]   - Field: ‘version’
[10:21:44.496]   - Field: ‘result’
[10:21:44.496]   - Field: ‘asynchronous’
[10:21:44.497]   - Field: ‘calls’
[10:21:44.497]   - Field: ‘globals’
[10:21:44.497]   - Field: ‘stdout’
[10:21:44.497]   - Field: ‘earlySignal’
[10:21:44.497]   - Field: ‘lazy’
[10:21:44.497]   - Field: ‘state’
[10:21:44.497] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.497] - Launch lazy future ...
[10:21:44.498] Packages needed by the future expression (n = 1): ‘future’
[10:21:44.498] Packages needed by future strategies (n = 0): <none>
[10:21:44.498] {
[10:21:44.498]     {
[10:21:44.498]         {
[10:21:44.498]             ...future.startTime <- base::Sys.time()
[10:21:44.498]             {
[10:21:44.498]                 {
[10:21:44.498]                   {
[10:21:44.498]                     {
[10:21:44.498]                       {
[10:21:44.498]                         base::local({
[10:21:44.498]                           has_future <- base::requireNamespace("future", 
[10:21:44.498]                             quietly = TRUE)
[10:21:44.498]                           if (has_future) {
[10:21:44.498]                             ns <- base::getNamespace("future")
[10:21:44.498]                             version <- ns[[".package"]][["version"]]
[10:21:44.498]                             if (is.null(version)) 
[10:21:44.498]                               version <- utils::packageVersion("future")
[10:21:44.498]                           }
[10:21:44.498]                           else {
[10:21:44.498]                             version <- NULL
[10:21:44.498]                           }
[10:21:44.498]                           if (!has_future || version < "1.8.0") {
[10:21:44.498]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.498]                               "", base::R.version$version.string), 
[10:21:44.498]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:44.498]                                 base::R.version$platform, 8 * 
[10:21:44.498]                                   base::.Machine$sizeof.pointer), 
[10:21:44.498]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.498]                                 "release", "version")], collapse = " "), 
[10:21:44.498]                               hostname = base::Sys.info()[["nodename"]])
[10:21:44.498]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.498]                               info)
[10:21:44.498]                             info <- base::paste(info, collapse = "; ")
[10:21:44.498]                             if (!has_future) {
[10:21:44.498]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.498]                                 info)
[10:21:44.498]                             }
[10:21:44.498]                             else {
[10:21:44.498]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.498]                                 info, version)
[10:21:44.498]                             }
[10:21:44.498]                             base::stop(msg)
[10:21:44.498]                           }
[10:21:44.498]                         })
[10:21:44.498]                       }
[10:21:44.498]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.498]                       base::options(mc.cores = 1L)
[10:21:44.498]                     }
[10:21:44.498]                     base::local({
[10:21:44.498]                       for (pkg in "future") {
[10:21:44.498]                         base::loadNamespace(pkg)
[10:21:44.498]                         base::library(pkg, character.only = TRUE)
[10:21:44.498]                       }
[10:21:44.498]                     })
[10:21:44.498]                   }
[10:21:44.498]                   ...future.strategy.old <- future::plan("list")
[10:21:44.498]                   options(future.plan = NULL)
[10:21:44.498]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.498]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.498]                 }
[10:21:44.498]                 ...future.workdir <- getwd()
[10:21:44.498]             }
[10:21:44.498]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.498]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.498]         }
[10:21:44.498]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.498]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.498]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.498]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.498]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.498]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.498]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.498]             base::names(...future.oldOptions))
[10:21:44.498]     }
[10:21:44.498]     if (FALSE) {
[10:21:44.498]     }
[10:21:44.498]     else {
[10:21:44.498]         if (TRUE) {
[10:21:44.498]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.498]                 open = "w")
[10:21:44.498]         }
[10:21:44.498]         else {
[10:21:44.498]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.498]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.498]         }
[10:21:44.498]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.498]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.498]             base::sink(type = "output", split = FALSE)
[10:21:44.498]             base::close(...future.stdout)
[10:21:44.498]         }, add = TRUE)
[10:21:44.498]     }
[10:21:44.498]     ...future.frame <- base::sys.nframe()
[10:21:44.498]     ...future.conditions <- base::list()
[10:21:44.498]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.498]     if (FALSE) {
[10:21:44.498]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.498]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.498]     }
[10:21:44.498]     ...future.result <- base::tryCatch({
[10:21:44.498]         base::withCallingHandlers({
[10:21:44.498]             ...future.value <- base::withVisible(base::local({
[10:21:44.498]                 withCallingHandlers({
[10:21:44.498]                   value(a) + 1
[10:21:44.498]                 }, immediateCondition = function(cond) {
[10:21:44.498]                   save_rds <- function (object, pathname, ...) 
[10:21:44.498]                   {
[10:21:44.498]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.498]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.498]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.498]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.498]                         fi_tmp[["mtime"]])
[10:21:44.498]                     }
[10:21:44.498]                     tryCatch({
[10:21:44.498]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.498]                     }, error = function(ex) {
[10:21:44.498]                       msg <- conditionMessage(ex)
[10:21:44.498]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.498]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.498]                         fi_tmp[["mtime"]], msg)
[10:21:44.498]                       ex$message <- msg
[10:21:44.498]                       stop(ex)
[10:21:44.498]                     })
[10:21:44.498]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.498]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.498]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.498]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.498]                       fi <- file.info(pathname)
[10:21:44.498]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.498]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.498]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.498]                         fi[["size"]], fi[["mtime"]])
[10:21:44.498]                       stop(msg)
[10:21:44.498]                     }
[10:21:44.498]                     invisible(pathname)
[10:21:44.498]                   }
[10:21:44.498]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.498]                     rootPath = tempdir()) 
[10:21:44.498]                   {
[10:21:44.498]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.498]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.498]                       tmpdir = path, fileext = ".rds")
[10:21:44.498]                     save_rds(obj, file)
[10:21:44.498]                   }
[10:21:44.498]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.498]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.498]                   {
[10:21:44.498]                     inherits <- base::inherits
[10:21:44.498]                     invokeRestart <- base::invokeRestart
[10:21:44.498]                     is.null <- base::is.null
[10:21:44.498]                     muffled <- FALSE
[10:21:44.498]                     if (inherits(cond, "message")) {
[10:21:44.498]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.498]                       if (muffled) 
[10:21:44.498]                         invokeRestart("muffleMessage")
[10:21:44.498]                     }
[10:21:44.498]                     else if (inherits(cond, "warning")) {
[10:21:44.498]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.498]                       if (muffled) 
[10:21:44.498]                         invokeRestart("muffleWarning")
[10:21:44.498]                     }
[10:21:44.498]                     else if (inherits(cond, "condition")) {
[10:21:44.498]                       if (!is.null(pattern)) {
[10:21:44.498]                         computeRestarts <- base::computeRestarts
[10:21:44.498]                         grepl <- base::grepl
[10:21:44.498]                         restarts <- computeRestarts(cond)
[10:21:44.498]                         for (restart in restarts) {
[10:21:44.498]                           name <- restart$name
[10:21:44.498]                           if (is.null(name)) 
[10:21:44.498]                             next
[10:21:44.498]                           if (!grepl(pattern, name)) 
[10:21:44.498]                             next
[10:21:44.498]                           invokeRestart(restart)
[10:21:44.498]                           muffled <- TRUE
[10:21:44.498]                           break
[10:21:44.498]                         }
[10:21:44.498]                       }
[10:21:44.498]                     }
[10:21:44.498]                     invisible(muffled)
[10:21:44.498]                   }
[10:21:44.498]                   muffleCondition(cond)
[10:21:44.498]                 })
[10:21:44.498]             }))
[10:21:44.498]             future::FutureResult(value = ...future.value$value, 
[10:21:44.498]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.498]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.498]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.498]                     ...future.globalenv.names))
[10:21:44.498]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.498]         }, condition = base::local({
[10:21:44.498]             c <- base::c
[10:21:44.498]             inherits <- base::inherits
[10:21:44.498]             invokeRestart <- base::invokeRestart
[10:21:44.498]             length <- base::length
[10:21:44.498]             list <- base::list
[10:21:44.498]             seq.int <- base::seq.int
[10:21:44.498]             signalCondition <- base::signalCondition
[10:21:44.498]             sys.calls <- base::sys.calls
[10:21:44.498]             `[[` <- base::`[[`
[10:21:44.498]             `+` <- base::`+`
[10:21:44.498]             `<<-` <- base::`<<-`
[10:21:44.498]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.498]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.498]                   3L)]
[10:21:44.498]             }
[10:21:44.498]             function(cond) {
[10:21:44.498]                 is_error <- inherits(cond, "error")
[10:21:44.498]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.498]                   NULL)
[10:21:44.498]                 if (is_error) {
[10:21:44.498]                   sessionInformation <- function() {
[10:21:44.498]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.498]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.498]                       search = base::search(), system = base::Sys.info())
[10:21:44.498]                   }
[10:21:44.498]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.498]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.498]                     cond$call), session = sessionInformation(), 
[10:21:44.498]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.498]                   signalCondition(cond)
[10:21:44.498]                 }
[10:21:44.498]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.498]                 "immediateCondition"))) {
[10:21:44.498]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.498]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.498]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.498]                   if (TRUE && !signal) {
[10:21:44.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.498]                     {
[10:21:44.498]                       inherits <- base::inherits
[10:21:44.498]                       invokeRestart <- base::invokeRestart
[10:21:44.498]                       is.null <- base::is.null
[10:21:44.498]                       muffled <- FALSE
[10:21:44.498]                       if (inherits(cond, "message")) {
[10:21:44.498]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.498]                         if (muffled) 
[10:21:44.498]                           invokeRestart("muffleMessage")
[10:21:44.498]                       }
[10:21:44.498]                       else if (inherits(cond, "warning")) {
[10:21:44.498]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.498]                         if (muffled) 
[10:21:44.498]                           invokeRestart("muffleWarning")
[10:21:44.498]                       }
[10:21:44.498]                       else if (inherits(cond, "condition")) {
[10:21:44.498]                         if (!is.null(pattern)) {
[10:21:44.498]                           computeRestarts <- base::computeRestarts
[10:21:44.498]                           grepl <- base::grepl
[10:21:44.498]                           restarts <- computeRestarts(cond)
[10:21:44.498]                           for (restart in restarts) {
[10:21:44.498]                             name <- restart$name
[10:21:44.498]                             if (is.null(name)) 
[10:21:44.498]                               next
[10:21:44.498]                             if (!grepl(pattern, name)) 
[10:21:44.498]                               next
[10:21:44.498]                             invokeRestart(restart)
[10:21:44.498]                             muffled <- TRUE
[10:21:44.498]                             break
[10:21:44.498]                           }
[10:21:44.498]                         }
[10:21:44.498]                       }
[10:21:44.498]                       invisible(muffled)
[10:21:44.498]                     }
[10:21:44.498]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.498]                   }
[10:21:44.498]                 }
[10:21:44.498]                 else {
[10:21:44.498]                   if (TRUE) {
[10:21:44.498]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.498]                     {
[10:21:44.498]                       inherits <- base::inherits
[10:21:44.498]                       invokeRestart <- base::invokeRestart
[10:21:44.498]                       is.null <- base::is.null
[10:21:44.498]                       muffled <- FALSE
[10:21:44.498]                       if (inherits(cond, "message")) {
[10:21:44.498]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.498]                         if (muffled) 
[10:21:44.498]                           invokeRestart("muffleMessage")
[10:21:44.498]                       }
[10:21:44.498]                       else if (inherits(cond, "warning")) {
[10:21:44.498]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.498]                         if (muffled) 
[10:21:44.498]                           invokeRestart("muffleWarning")
[10:21:44.498]                       }
[10:21:44.498]                       else if (inherits(cond, "condition")) {
[10:21:44.498]                         if (!is.null(pattern)) {
[10:21:44.498]                           computeRestarts <- base::computeRestarts
[10:21:44.498]                           grepl <- base::grepl
[10:21:44.498]                           restarts <- computeRestarts(cond)
[10:21:44.498]                           for (restart in restarts) {
[10:21:44.498]                             name <- restart$name
[10:21:44.498]                             if (is.null(name)) 
[10:21:44.498]                               next
[10:21:44.498]                             if (!grepl(pattern, name)) 
[10:21:44.498]                               next
[10:21:44.498]                             invokeRestart(restart)
[10:21:44.498]                             muffled <- TRUE
[10:21:44.498]                             break
[10:21:44.498]                           }
[10:21:44.498]                         }
[10:21:44.498]                       }
[10:21:44.498]                       invisible(muffled)
[10:21:44.498]                     }
[10:21:44.498]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.498]                   }
[10:21:44.498]                 }
[10:21:44.498]             }
[10:21:44.498]         }))
[10:21:44.498]     }, error = function(ex) {
[10:21:44.498]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.498]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.498]                 ...future.rng), started = ...future.startTime, 
[10:21:44.498]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.498]             version = "1.8"), class = "FutureResult")
[10:21:44.498]     }, finally = {
[10:21:44.498]         if (!identical(...future.workdir, getwd())) 
[10:21:44.498]             setwd(...future.workdir)
[10:21:44.498]         {
[10:21:44.498]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.498]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.498]             }
[10:21:44.498]             base::options(...future.oldOptions)
[10:21:44.498]             if (.Platform$OS.type == "windows") {
[10:21:44.498]                 old_names <- names(...future.oldEnvVars)
[10:21:44.498]                 envs <- base::Sys.getenv()
[10:21:44.498]                 names <- names(envs)
[10:21:44.498]                 common <- intersect(names, old_names)
[10:21:44.498]                 added <- setdiff(names, old_names)
[10:21:44.498]                 removed <- setdiff(old_names, names)
[10:21:44.498]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.498]                   envs[common]]
[10:21:44.498]                 NAMES <- toupper(changed)
[10:21:44.498]                 args <- list()
[10:21:44.498]                 for (kk in seq_along(NAMES)) {
[10:21:44.498]                   name <- changed[[kk]]
[10:21:44.498]                   NAME <- NAMES[[kk]]
[10:21:44.498]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.498]                     next
[10:21:44.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.498]                 }
[10:21:44.498]                 NAMES <- toupper(added)
[10:21:44.498]                 for (kk in seq_along(NAMES)) {
[10:21:44.498]                   name <- added[[kk]]
[10:21:44.498]                   NAME <- NAMES[[kk]]
[10:21:44.498]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.498]                     next
[10:21:44.498]                   args[[name]] <- ""
[10:21:44.498]                 }
[10:21:44.498]                 NAMES <- toupper(removed)
[10:21:44.498]                 for (kk in seq_along(NAMES)) {
[10:21:44.498]                   name <- removed[[kk]]
[10:21:44.498]                   NAME <- NAMES[[kk]]
[10:21:44.498]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.498]                     next
[10:21:44.498]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.498]                 }
[10:21:44.498]                 if (length(args) > 0) 
[10:21:44.498]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.498]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.498]             }
[10:21:44.498]             else {
[10:21:44.498]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.498]             }
[10:21:44.498]             {
[10:21:44.498]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.498]                   0L) {
[10:21:44.498]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.498]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.498]                   base::options(opts)
[10:21:44.498]                 }
[10:21:44.498]                 {
[10:21:44.498]                   {
[10:21:44.498]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.498]                     NULL
[10:21:44.498]                   }
[10:21:44.498]                   options(future.plan = NULL)
[10:21:44.498]                   if (is.na(NA_character_)) 
[10:21:44.498]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.498]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.498]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.498]                     .init = FALSE)
[10:21:44.498]                 }
[10:21:44.498]             }
[10:21:44.498]         }
[10:21:44.498]     })
[10:21:44.498]     if (TRUE) {
[10:21:44.498]         base::sink(type = "output", split = FALSE)
[10:21:44.498]         if (TRUE) {
[10:21:44.498]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.498]         }
[10:21:44.498]         else {
[10:21:44.498]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.498]         }
[10:21:44.498]         base::close(...future.stdout)
[10:21:44.498]         ...future.stdout <- NULL
[10:21:44.498]     }
[10:21:44.498]     ...future.result$conditions <- ...future.conditions
[10:21:44.498]     ...future.result$finished <- base::Sys.time()
[10:21:44.498]     ...future.result
[10:21:44.498] }
[10:21:44.501] assign_globals() ...
[10:21:44.501] List of 1
[10:21:44.501]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18e458d90> 
[10:21:44.501]  - attr(*, "where")=List of 1
[10:21:44.501]   ..$ a:<environment: R_EmptyEnv> 
[10:21:44.501]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.501]  - attr(*, "resolved")= logi TRUE
[10:21:44.501]  - attr(*, "total_size")= num 3815
[10:21:44.501]  - attr(*, "already-done")= logi TRUE
[10:21:44.504] - copied ‘a’ to environment
[10:21:44.504] assign_globals() ... done
[10:21:44.504] requestCore(): workers = 2
[10:21:44.506] MulticoreFuture started
[10:21:44.506] - Launch lazy future ... done
[10:21:44.506] run() for ‘MulticoreFuture’ ... done
[10:21:44.507] result() for MulticoreFuture ...
[10:21:44.507] plan(): Setting new future strategy stack:
[10:21:44.507] List of future strategies:
[10:21:44.507] 1. sequential:
[10:21:44.507]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.507]    - tweaked: FALSE
[10:21:44.507]    - call: NULL
[10:21:44.508] plan(): nbrOfWorkers() = 1
[10:21:44.512] plan(): Setting new future strategy stack:
[10:21:44.512] List of future strategies:
[10:21:44.512] 1. multicore:
[10:21:44.512]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.512]    - tweaked: FALSE
[10:21:44.512]    - call: plan(strategy)
[10:21:44.515] plan(): nbrOfWorkers() = 2
[10:21:44.516] result() for MulticoreFuture ...
[10:21:44.516] result() for MulticoreFuture ... done
[10:21:44.516] signalConditions() ...
[10:21:44.516]  - include = ‘immediateCondition’
[10:21:44.516]  - exclude = 
[10:21:44.516]  - resignal = FALSE
[10:21:44.516]  - Number of conditions: 4
[10:21:44.517] signalConditions() ... done
[10:21:44.517] result() for MulticoreFuture ... done
[10:21:44.517] result() for MulticoreFuture ...
[10:21:44.517] result() for MulticoreFuture ... done
[10:21:44.517] signalConditions() ...
[10:21:44.517]  - include = ‘immediateCondition’
[10:21:44.517]  - exclude = 
[10:21:44.517]  - resignal = FALSE
[10:21:44.517]  - Number of conditions: 4
[10:21:44.518] signalConditions() ... done
[10:21:44.518] Future state: ‘finished’
[10:21:44.518] result() for MulticoreFuture ...
[10:21:44.518] result() for MulticoreFuture ... done
[10:21:44.518] signalConditions() ...
[10:21:44.518]  - include = ‘condition’
[10:21:44.518]  - exclude = ‘immediateCondition’
[10:21:44.518]  - resignal = TRUE
[10:21:44.519]  - Number of conditions: 4
[10:21:44.519]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ...
[10:21:44.519]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ... done
[10:21:44.519]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ...
[10:21:44.519]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ... done
[10:21:44.519] signalConditions() ... done
value(b) = 2
[10:21:44.519] result() for MulticoreFuture ...
[10:21:44.520] result() for MulticoreFuture ... done
[10:21:44.520] result() for MulticoreFuture ...
[10:21:44.520] result() for MulticoreFuture ... done
[10:21:44.520] signalConditions() ...
[10:21:44.520]  - include = ‘immediateCondition’
[10:21:44.520]  - exclude = 
[10:21:44.520]  - resignal = FALSE
[10:21:44.520]  - Number of conditions: 4
[10:21:44.520] signalConditions() ... done
[10:21:44.521] Future state: ‘finished’
[10:21:44.521] result() for MulticoreFuture ...
[10:21:44.521] result() for MulticoreFuture ... done
[10:21:44.521] signalConditions() ...
[10:21:44.521]  - include = ‘condition’
[10:21:44.521]  - exclude = ‘immediateCondition’
[10:21:44.521]  - resignal = TRUE
[10:21:44.521]  - Number of conditions: 4
[10:21:44.521]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ...
[10:21:44.522]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ... done
[10:21:44.522]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ...
[10:21:44.522]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.510] result() for MulticoreFuture ... done
[10:21:44.522] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.522] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.525] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.526] 
[10:21:44.526] Searching for globals ... DONE
[10:21:44.527] - globals: [0] <none>
[10:21:44.527] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.527] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.528] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.529] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:44.529] Searching for globals ... DONE
[10:21:44.529] Resolving globals: TRUE
[10:21:44.529] Resolving any globals that are futures ...
[10:21:44.529] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:44.530] Resolving any globals that are futures ... DONE
[10:21:44.530] Resolving futures part of globals (recursively) ...
[10:21:44.530] resolve() on list ...
[10:21:44.530]  recursive: 99
[10:21:44.531]  length: 1
[10:21:44.531]  elements: ‘a’
[10:21:44.531] run() for ‘Future’ ...
[10:21:44.531] - state: ‘created’
[10:21:44.531] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.533] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.534] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.534]   - Field: ‘label’
[10:21:44.534]   - Field: ‘local’
[10:21:44.534]   - Field: ‘owner’
[10:21:44.534]   - Field: ‘envir’
[10:21:44.534]   - Field: ‘workers’
[10:21:44.534]   - Field: ‘packages’
[10:21:44.534]   - Field: ‘gc’
[10:21:44.535]   - Field: ‘job’
[10:21:44.535]   - Field: ‘conditions’
[10:21:44.535]   - Field: ‘expr’
[10:21:44.535]   - Field: ‘uuid’
[10:21:44.535]   - Field: ‘seed’
[10:21:44.535]   - Field: ‘version’
[10:21:44.535]   - Field: ‘result’
[10:21:44.535]   - Field: ‘asynchronous’
[10:21:44.535]   - Field: ‘calls’
[10:21:44.535]   - Field: ‘globals’
[10:21:44.536]   - Field: ‘stdout’
[10:21:44.536]   - Field: ‘earlySignal’
[10:21:44.536]   - Field: ‘lazy’
[10:21:44.536]   - Field: ‘state’
[10:21:44.536] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.536] - Launch lazy future ...
[10:21:44.536] Packages needed by the future expression (n = 0): <none>
[10:21:44.537] Packages needed by future strategies (n = 0): <none>
[10:21:44.537] {
[10:21:44.537]     {
[10:21:44.537]         {
[10:21:44.537]             ...future.startTime <- base::Sys.time()
[10:21:44.537]             {
[10:21:44.537]                 {
[10:21:44.537]                   {
[10:21:44.537]                     {
[10:21:44.537]                       base::local({
[10:21:44.537]                         has_future <- base::requireNamespace("future", 
[10:21:44.537]                           quietly = TRUE)
[10:21:44.537]                         if (has_future) {
[10:21:44.537]                           ns <- base::getNamespace("future")
[10:21:44.537]                           version <- ns[[".package"]][["version"]]
[10:21:44.537]                           if (is.null(version)) 
[10:21:44.537]                             version <- utils::packageVersion("future")
[10:21:44.537]                         }
[10:21:44.537]                         else {
[10:21:44.537]                           version <- NULL
[10:21:44.537]                         }
[10:21:44.537]                         if (!has_future || version < "1.8.0") {
[10:21:44.537]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.537]                             "", base::R.version$version.string), 
[10:21:44.537]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.537]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.537]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.537]                               "release", "version")], collapse = " "), 
[10:21:44.537]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.537]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.537]                             info)
[10:21:44.537]                           info <- base::paste(info, collapse = "; ")
[10:21:44.537]                           if (!has_future) {
[10:21:44.537]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.537]                               info)
[10:21:44.537]                           }
[10:21:44.537]                           else {
[10:21:44.537]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.537]                               info, version)
[10:21:44.537]                           }
[10:21:44.537]                           base::stop(msg)
[10:21:44.537]                         }
[10:21:44.537]                       })
[10:21:44.537]                     }
[10:21:44.537]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.537]                     base::options(mc.cores = 1L)
[10:21:44.537]                   }
[10:21:44.537]                   ...future.strategy.old <- future::plan("list")
[10:21:44.537]                   options(future.plan = NULL)
[10:21:44.537]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.537]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.537]                 }
[10:21:44.537]                 ...future.workdir <- getwd()
[10:21:44.537]             }
[10:21:44.537]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.537]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.537]         }
[10:21:44.537]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.537]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.537]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.537]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.537]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.537]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.537]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.537]             base::names(...future.oldOptions))
[10:21:44.537]     }
[10:21:44.537]     if (FALSE) {
[10:21:44.537]     }
[10:21:44.537]     else {
[10:21:44.537]         if (TRUE) {
[10:21:44.537]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.537]                 open = "w")
[10:21:44.537]         }
[10:21:44.537]         else {
[10:21:44.537]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.537]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.537]         }
[10:21:44.537]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.537]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.537]             base::sink(type = "output", split = FALSE)
[10:21:44.537]             base::close(...future.stdout)
[10:21:44.537]         }, add = TRUE)
[10:21:44.537]     }
[10:21:44.537]     ...future.frame <- base::sys.nframe()
[10:21:44.537]     ...future.conditions <- base::list()
[10:21:44.537]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.537]     if (FALSE) {
[10:21:44.537]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.537]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.537]     }
[10:21:44.537]     ...future.result <- base::tryCatch({
[10:21:44.537]         base::withCallingHandlers({
[10:21:44.537]             ...future.value <- base::withVisible(base::local({
[10:21:44.537]                 withCallingHandlers({
[10:21:44.537]                   1
[10:21:44.537]                 }, immediateCondition = function(cond) {
[10:21:44.537]                   save_rds <- function (object, pathname, ...) 
[10:21:44.537]                   {
[10:21:44.537]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.537]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.537]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.537]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.537]                         fi_tmp[["mtime"]])
[10:21:44.537]                     }
[10:21:44.537]                     tryCatch({
[10:21:44.537]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.537]                     }, error = function(ex) {
[10:21:44.537]                       msg <- conditionMessage(ex)
[10:21:44.537]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.537]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.537]                         fi_tmp[["mtime"]], msg)
[10:21:44.537]                       ex$message <- msg
[10:21:44.537]                       stop(ex)
[10:21:44.537]                     })
[10:21:44.537]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.537]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.537]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.537]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.537]                       fi <- file.info(pathname)
[10:21:44.537]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.537]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.537]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.537]                         fi[["size"]], fi[["mtime"]])
[10:21:44.537]                       stop(msg)
[10:21:44.537]                     }
[10:21:44.537]                     invisible(pathname)
[10:21:44.537]                   }
[10:21:44.537]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.537]                     rootPath = tempdir()) 
[10:21:44.537]                   {
[10:21:44.537]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.537]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.537]                       tmpdir = path, fileext = ".rds")
[10:21:44.537]                     save_rds(obj, file)
[10:21:44.537]                   }
[10:21:44.537]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.537]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.537]                   {
[10:21:44.537]                     inherits <- base::inherits
[10:21:44.537]                     invokeRestart <- base::invokeRestart
[10:21:44.537]                     is.null <- base::is.null
[10:21:44.537]                     muffled <- FALSE
[10:21:44.537]                     if (inherits(cond, "message")) {
[10:21:44.537]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.537]                       if (muffled) 
[10:21:44.537]                         invokeRestart("muffleMessage")
[10:21:44.537]                     }
[10:21:44.537]                     else if (inherits(cond, "warning")) {
[10:21:44.537]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.537]                       if (muffled) 
[10:21:44.537]                         invokeRestart("muffleWarning")
[10:21:44.537]                     }
[10:21:44.537]                     else if (inherits(cond, "condition")) {
[10:21:44.537]                       if (!is.null(pattern)) {
[10:21:44.537]                         computeRestarts <- base::computeRestarts
[10:21:44.537]                         grepl <- base::grepl
[10:21:44.537]                         restarts <- computeRestarts(cond)
[10:21:44.537]                         for (restart in restarts) {
[10:21:44.537]                           name <- restart$name
[10:21:44.537]                           if (is.null(name)) 
[10:21:44.537]                             next
[10:21:44.537]                           if (!grepl(pattern, name)) 
[10:21:44.537]                             next
[10:21:44.537]                           invokeRestart(restart)
[10:21:44.537]                           muffled <- TRUE
[10:21:44.537]                           break
[10:21:44.537]                         }
[10:21:44.537]                       }
[10:21:44.537]                     }
[10:21:44.537]                     invisible(muffled)
[10:21:44.537]                   }
[10:21:44.537]                   muffleCondition(cond)
[10:21:44.537]                 })
[10:21:44.537]             }))
[10:21:44.537]             future::FutureResult(value = ...future.value$value, 
[10:21:44.537]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.537]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.537]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.537]                     ...future.globalenv.names))
[10:21:44.537]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.537]         }, condition = base::local({
[10:21:44.537]             c <- base::c
[10:21:44.537]             inherits <- base::inherits
[10:21:44.537]             invokeRestart <- base::invokeRestart
[10:21:44.537]             length <- base::length
[10:21:44.537]             list <- base::list
[10:21:44.537]             seq.int <- base::seq.int
[10:21:44.537]             signalCondition <- base::signalCondition
[10:21:44.537]             sys.calls <- base::sys.calls
[10:21:44.537]             `[[` <- base::`[[`
[10:21:44.537]             `+` <- base::`+`
[10:21:44.537]             `<<-` <- base::`<<-`
[10:21:44.537]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.537]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.537]                   3L)]
[10:21:44.537]             }
[10:21:44.537]             function(cond) {
[10:21:44.537]                 is_error <- inherits(cond, "error")
[10:21:44.537]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.537]                   NULL)
[10:21:44.537]                 if (is_error) {
[10:21:44.537]                   sessionInformation <- function() {
[10:21:44.537]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.537]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.537]                       search = base::search(), system = base::Sys.info())
[10:21:44.537]                   }
[10:21:44.537]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.537]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.537]                     cond$call), session = sessionInformation(), 
[10:21:44.537]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.537]                   signalCondition(cond)
[10:21:44.537]                 }
[10:21:44.537]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.537]                 "immediateCondition"))) {
[10:21:44.537]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.537]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.537]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.537]                   if (TRUE && !signal) {
[10:21:44.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.537]                     {
[10:21:44.537]                       inherits <- base::inherits
[10:21:44.537]                       invokeRestart <- base::invokeRestart
[10:21:44.537]                       is.null <- base::is.null
[10:21:44.537]                       muffled <- FALSE
[10:21:44.537]                       if (inherits(cond, "message")) {
[10:21:44.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.537]                         if (muffled) 
[10:21:44.537]                           invokeRestart("muffleMessage")
[10:21:44.537]                       }
[10:21:44.537]                       else if (inherits(cond, "warning")) {
[10:21:44.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.537]                         if (muffled) 
[10:21:44.537]                           invokeRestart("muffleWarning")
[10:21:44.537]                       }
[10:21:44.537]                       else if (inherits(cond, "condition")) {
[10:21:44.537]                         if (!is.null(pattern)) {
[10:21:44.537]                           computeRestarts <- base::computeRestarts
[10:21:44.537]                           grepl <- base::grepl
[10:21:44.537]                           restarts <- computeRestarts(cond)
[10:21:44.537]                           for (restart in restarts) {
[10:21:44.537]                             name <- restart$name
[10:21:44.537]                             if (is.null(name)) 
[10:21:44.537]                               next
[10:21:44.537]                             if (!grepl(pattern, name)) 
[10:21:44.537]                               next
[10:21:44.537]                             invokeRestart(restart)
[10:21:44.537]                             muffled <- TRUE
[10:21:44.537]                             break
[10:21:44.537]                           }
[10:21:44.537]                         }
[10:21:44.537]                       }
[10:21:44.537]                       invisible(muffled)
[10:21:44.537]                     }
[10:21:44.537]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.537]                   }
[10:21:44.537]                 }
[10:21:44.537]                 else {
[10:21:44.537]                   if (TRUE) {
[10:21:44.537]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.537]                     {
[10:21:44.537]                       inherits <- base::inherits
[10:21:44.537]                       invokeRestart <- base::invokeRestart
[10:21:44.537]                       is.null <- base::is.null
[10:21:44.537]                       muffled <- FALSE
[10:21:44.537]                       if (inherits(cond, "message")) {
[10:21:44.537]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.537]                         if (muffled) 
[10:21:44.537]                           invokeRestart("muffleMessage")
[10:21:44.537]                       }
[10:21:44.537]                       else if (inherits(cond, "warning")) {
[10:21:44.537]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.537]                         if (muffled) 
[10:21:44.537]                           invokeRestart("muffleWarning")
[10:21:44.537]                       }
[10:21:44.537]                       else if (inherits(cond, "condition")) {
[10:21:44.537]                         if (!is.null(pattern)) {
[10:21:44.537]                           computeRestarts <- base::computeRestarts
[10:21:44.537]                           grepl <- base::grepl
[10:21:44.537]                           restarts <- computeRestarts(cond)
[10:21:44.537]                           for (restart in restarts) {
[10:21:44.537]                             name <- restart$name
[10:21:44.537]                             if (is.null(name)) 
[10:21:44.537]                               next
[10:21:44.537]                             if (!grepl(pattern, name)) 
[10:21:44.537]                               next
[10:21:44.537]                             invokeRestart(restart)
[10:21:44.537]                             muffled <- TRUE
[10:21:44.537]                             break
[10:21:44.537]                           }
[10:21:44.537]                         }
[10:21:44.537]                       }
[10:21:44.537]                       invisible(muffled)
[10:21:44.537]                     }
[10:21:44.537]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.537]                   }
[10:21:44.537]                 }
[10:21:44.537]             }
[10:21:44.537]         }))
[10:21:44.537]     }, error = function(ex) {
[10:21:44.537]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.537]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.537]                 ...future.rng), started = ...future.startTime, 
[10:21:44.537]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.537]             version = "1.8"), class = "FutureResult")
[10:21:44.537]     }, finally = {
[10:21:44.537]         if (!identical(...future.workdir, getwd())) 
[10:21:44.537]             setwd(...future.workdir)
[10:21:44.537]         {
[10:21:44.537]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.537]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.537]             }
[10:21:44.537]             base::options(...future.oldOptions)
[10:21:44.537]             if (.Platform$OS.type == "windows") {
[10:21:44.537]                 old_names <- names(...future.oldEnvVars)
[10:21:44.537]                 envs <- base::Sys.getenv()
[10:21:44.537]                 names <- names(envs)
[10:21:44.537]                 common <- intersect(names, old_names)
[10:21:44.537]                 added <- setdiff(names, old_names)
[10:21:44.537]                 removed <- setdiff(old_names, names)
[10:21:44.537]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.537]                   envs[common]]
[10:21:44.537]                 NAMES <- toupper(changed)
[10:21:44.537]                 args <- list()
[10:21:44.537]                 for (kk in seq_along(NAMES)) {
[10:21:44.537]                   name <- changed[[kk]]
[10:21:44.537]                   NAME <- NAMES[[kk]]
[10:21:44.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.537]                     next
[10:21:44.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.537]                 }
[10:21:44.537]                 NAMES <- toupper(added)
[10:21:44.537]                 for (kk in seq_along(NAMES)) {
[10:21:44.537]                   name <- added[[kk]]
[10:21:44.537]                   NAME <- NAMES[[kk]]
[10:21:44.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.537]                     next
[10:21:44.537]                   args[[name]] <- ""
[10:21:44.537]                 }
[10:21:44.537]                 NAMES <- toupper(removed)
[10:21:44.537]                 for (kk in seq_along(NAMES)) {
[10:21:44.537]                   name <- removed[[kk]]
[10:21:44.537]                   NAME <- NAMES[[kk]]
[10:21:44.537]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.537]                     next
[10:21:44.537]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.537]                 }
[10:21:44.537]                 if (length(args) > 0) 
[10:21:44.537]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.537]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.537]             }
[10:21:44.537]             else {
[10:21:44.537]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.537]             }
[10:21:44.537]             {
[10:21:44.537]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.537]                   0L) {
[10:21:44.537]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.537]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.537]                   base::options(opts)
[10:21:44.537]                 }
[10:21:44.537]                 {
[10:21:44.537]                   {
[10:21:44.537]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.537]                     NULL
[10:21:44.537]                   }
[10:21:44.537]                   options(future.plan = NULL)
[10:21:44.537]                   if (is.na(NA_character_)) 
[10:21:44.537]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.537]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.537]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.537]                     .init = FALSE)
[10:21:44.537]                 }
[10:21:44.537]             }
[10:21:44.537]         }
[10:21:44.537]     })
[10:21:44.537]     if (TRUE) {
[10:21:44.537]         base::sink(type = "output", split = FALSE)
[10:21:44.537]         if (TRUE) {
[10:21:44.537]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.537]         }
[10:21:44.537]         else {
[10:21:44.537]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.537]         }
[10:21:44.537]         base::close(...future.stdout)
[10:21:44.537]         ...future.stdout <- NULL
[10:21:44.537]     }
[10:21:44.537]     ...future.result$conditions <- ...future.conditions
[10:21:44.537]     ...future.result$finished <- base::Sys.time()
[10:21:44.537]     ...future.result
[10:21:44.537] }
[10:21:44.539] requestCore(): workers = 2
[10:21:44.541] MulticoreFuture started
[10:21:44.542] - Launch lazy future ... done
[10:21:44.542] run() for ‘MulticoreFuture’ ... done
[10:21:44.542] plan(): Setting new future strategy stack:
[10:21:44.543] List of future strategies:
[10:21:44.543] 1. sequential:
[10:21:44.543]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.543]    - tweaked: FALSE
[10:21:44.543]    - call: NULL
[10:21:44.544] plan(): nbrOfWorkers() = 1
[10:21:44.546] plan(): Setting new future strategy stack:
[10:21:44.546] List of future strategies:
[10:21:44.546] 1. multicore:
[10:21:44.546]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.546]    - tweaked: FALSE
[10:21:44.546]    - call: plan(strategy)
[10:21:44.549] plan(): nbrOfWorkers() = 2
[10:21:44.550] Future #1
[10:21:44.550] result() for MulticoreFuture ...
[10:21:44.551] result() for MulticoreFuture ...
[10:21:44.551] result() for MulticoreFuture ... done
[10:21:44.551] result() for MulticoreFuture ... done
[10:21:44.551] result() for MulticoreFuture ...
[10:21:44.551] result() for MulticoreFuture ... done
[10:21:44.552] A MulticoreFuture was resolved
[10:21:44.552]  length: 0 (resolved future 1)
[10:21:44.552] resolve() on list ... DONE
[10:21:44.552] - globals: [1] ‘a’
[10:21:44.552] Resolving futures part of globals (recursively) ... DONE
[10:21:44.552] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[10:21:44.553] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[10:21:44.553] - globals: [1] ‘a’
[10:21:44.553] - packages: [1] ‘future’
[10:21:44.554] getGlobalsAndPackages() ... DONE
[10:21:44.554] run() for ‘Future’ ...
[10:21:44.554] - state: ‘created’
[10:21:44.554] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.556] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.557] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.557]   - Field: ‘label’
[10:21:44.557]   - Field: ‘local’
[10:21:44.557]   - Field: ‘owner’
[10:21:44.557]   - Field: ‘envir’
[10:21:44.557]   - Field: ‘workers’
[10:21:44.557]   - Field: ‘packages’
[10:21:44.557]   - Field: ‘gc’
[10:21:44.557]   - Field: ‘job’
[10:21:44.558]   - Field: ‘conditions’
[10:21:44.558]   - Field: ‘expr’
[10:21:44.558]   - Field: ‘uuid’
[10:21:44.558]   - Field: ‘seed’
[10:21:44.558]   - Field: ‘version’
[10:21:44.558]   - Field: ‘result’
[10:21:44.558]   - Field: ‘asynchronous’
[10:21:44.558]   - Field: ‘calls’
[10:21:44.559]   - Field: ‘globals’
[10:21:44.559]   - Field: ‘stdout’
[10:21:44.559]   - Field: ‘earlySignal’
[10:21:44.559]   - Field: ‘lazy’
[10:21:44.559]   - Field: ‘state’
[10:21:44.559] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.559] - Launch lazy future ...
[10:21:44.560] Packages needed by the future expression (n = 1): ‘future’
[10:21:44.560] Packages needed by future strategies (n = 0): <none>
[10:21:44.560] {
[10:21:44.560]     {
[10:21:44.560]         {
[10:21:44.560]             ...future.startTime <- base::Sys.time()
[10:21:44.560]             {
[10:21:44.560]                 {
[10:21:44.560]                   {
[10:21:44.560]                     {
[10:21:44.560]                       {
[10:21:44.560]                         base::local({
[10:21:44.560]                           has_future <- base::requireNamespace("future", 
[10:21:44.560]                             quietly = TRUE)
[10:21:44.560]                           if (has_future) {
[10:21:44.560]                             ns <- base::getNamespace("future")
[10:21:44.560]                             version <- ns[[".package"]][["version"]]
[10:21:44.560]                             if (is.null(version)) 
[10:21:44.560]                               version <- utils::packageVersion("future")
[10:21:44.560]                           }
[10:21:44.560]                           else {
[10:21:44.560]                             version <- NULL
[10:21:44.560]                           }
[10:21:44.560]                           if (!has_future || version < "1.8.0") {
[10:21:44.560]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.560]                               "", base::R.version$version.string), 
[10:21:44.560]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:44.560]                                 base::R.version$platform, 8 * 
[10:21:44.560]                                   base::.Machine$sizeof.pointer), 
[10:21:44.560]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.560]                                 "release", "version")], collapse = " "), 
[10:21:44.560]                               hostname = base::Sys.info()[["nodename"]])
[10:21:44.560]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.560]                               info)
[10:21:44.560]                             info <- base::paste(info, collapse = "; ")
[10:21:44.560]                             if (!has_future) {
[10:21:44.560]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.560]                                 info)
[10:21:44.560]                             }
[10:21:44.560]                             else {
[10:21:44.560]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.560]                                 info, version)
[10:21:44.560]                             }
[10:21:44.560]                             base::stop(msg)
[10:21:44.560]                           }
[10:21:44.560]                         })
[10:21:44.560]                       }
[10:21:44.560]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.560]                       base::options(mc.cores = 1L)
[10:21:44.560]                     }
[10:21:44.560]                     base::local({
[10:21:44.560]                       for (pkg in "future") {
[10:21:44.560]                         base::loadNamespace(pkg)
[10:21:44.560]                         base::library(pkg, character.only = TRUE)
[10:21:44.560]                       }
[10:21:44.560]                     })
[10:21:44.560]                   }
[10:21:44.560]                   ...future.strategy.old <- future::plan("list")
[10:21:44.560]                   options(future.plan = NULL)
[10:21:44.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.560]                 }
[10:21:44.560]                 ...future.workdir <- getwd()
[10:21:44.560]             }
[10:21:44.560]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.560]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.560]         }
[10:21:44.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.560]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.560]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.560]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.560]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.560]             base::names(...future.oldOptions))
[10:21:44.560]     }
[10:21:44.560]     if (FALSE) {
[10:21:44.560]     }
[10:21:44.560]     else {
[10:21:44.560]         if (TRUE) {
[10:21:44.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.560]                 open = "w")
[10:21:44.560]         }
[10:21:44.560]         else {
[10:21:44.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.560]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.560]         }
[10:21:44.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.560]             base::sink(type = "output", split = FALSE)
[10:21:44.560]             base::close(...future.stdout)
[10:21:44.560]         }, add = TRUE)
[10:21:44.560]     }
[10:21:44.560]     ...future.frame <- base::sys.nframe()
[10:21:44.560]     ...future.conditions <- base::list()
[10:21:44.560]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.560]     if (FALSE) {
[10:21:44.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.560]     }
[10:21:44.560]     ...future.result <- base::tryCatch({
[10:21:44.560]         base::withCallingHandlers({
[10:21:44.560]             ...future.value <- base::withVisible(base::local({
[10:21:44.560]                 withCallingHandlers({
[10:21:44.560]                   value(a) + 1
[10:21:44.560]                 }, immediateCondition = function(cond) {
[10:21:44.560]                   save_rds <- function (object, pathname, ...) 
[10:21:44.560]                   {
[10:21:44.560]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.560]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.560]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.560]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.560]                         fi_tmp[["mtime"]])
[10:21:44.560]                     }
[10:21:44.560]                     tryCatch({
[10:21:44.560]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.560]                     }, error = function(ex) {
[10:21:44.560]                       msg <- conditionMessage(ex)
[10:21:44.560]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.560]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.560]                         fi_tmp[["mtime"]], msg)
[10:21:44.560]                       ex$message <- msg
[10:21:44.560]                       stop(ex)
[10:21:44.560]                     })
[10:21:44.560]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.560]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.560]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.560]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.560]                       fi <- file.info(pathname)
[10:21:44.560]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.560]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.560]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.560]                         fi[["size"]], fi[["mtime"]])
[10:21:44.560]                       stop(msg)
[10:21:44.560]                     }
[10:21:44.560]                     invisible(pathname)
[10:21:44.560]                   }
[10:21:44.560]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.560]                     rootPath = tempdir()) 
[10:21:44.560]                   {
[10:21:44.560]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.560]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.560]                       tmpdir = path, fileext = ".rds")
[10:21:44.560]                     save_rds(obj, file)
[10:21:44.560]                   }
[10:21:44.560]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.560]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.560]                   {
[10:21:44.560]                     inherits <- base::inherits
[10:21:44.560]                     invokeRestart <- base::invokeRestart
[10:21:44.560]                     is.null <- base::is.null
[10:21:44.560]                     muffled <- FALSE
[10:21:44.560]                     if (inherits(cond, "message")) {
[10:21:44.560]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.560]                       if (muffled) 
[10:21:44.560]                         invokeRestart("muffleMessage")
[10:21:44.560]                     }
[10:21:44.560]                     else if (inherits(cond, "warning")) {
[10:21:44.560]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.560]                       if (muffled) 
[10:21:44.560]                         invokeRestart("muffleWarning")
[10:21:44.560]                     }
[10:21:44.560]                     else if (inherits(cond, "condition")) {
[10:21:44.560]                       if (!is.null(pattern)) {
[10:21:44.560]                         computeRestarts <- base::computeRestarts
[10:21:44.560]                         grepl <- base::grepl
[10:21:44.560]                         restarts <- computeRestarts(cond)
[10:21:44.560]                         for (restart in restarts) {
[10:21:44.560]                           name <- restart$name
[10:21:44.560]                           if (is.null(name)) 
[10:21:44.560]                             next
[10:21:44.560]                           if (!grepl(pattern, name)) 
[10:21:44.560]                             next
[10:21:44.560]                           invokeRestart(restart)
[10:21:44.560]                           muffled <- TRUE
[10:21:44.560]                           break
[10:21:44.560]                         }
[10:21:44.560]                       }
[10:21:44.560]                     }
[10:21:44.560]                     invisible(muffled)
[10:21:44.560]                   }
[10:21:44.560]                   muffleCondition(cond)
[10:21:44.560]                 })
[10:21:44.560]             }))
[10:21:44.560]             future::FutureResult(value = ...future.value$value, 
[10:21:44.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.560]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.560]                     ...future.globalenv.names))
[10:21:44.560]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.560]         }, condition = base::local({
[10:21:44.560]             c <- base::c
[10:21:44.560]             inherits <- base::inherits
[10:21:44.560]             invokeRestart <- base::invokeRestart
[10:21:44.560]             length <- base::length
[10:21:44.560]             list <- base::list
[10:21:44.560]             seq.int <- base::seq.int
[10:21:44.560]             signalCondition <- base::signalCondition
[10:21:44.560]             sys.calls <- base::sys.calls
[10:21:44.560]             `[[` <- base::`[[`
[10:21:44.560]             `+` <- base::`+`
[10:21:44.560]             `<<-` <- base::`<<-`
[10:21:44.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.560]                   3L)]
[10:21:44.560]             }
[10:21:44.560]             function(cond) {
[10:21:44.560]                 is_error <- inherits(cond, "error")
[10:21:44.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.560]                   NULL)
[10:21:44.560]                 if (is_error) {
[10:21:44.560]                   sessionInformation <- function() {
[10:21:44.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.560]                       search = base::search(), system = base::Sys.info())
[10:21:44.560]                   }
[10:21:44.560]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.560]                     cond$call), session = sessionInformation(), 
[10:21:44.560]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.560]                   signalCondition(cond)
[10:21:44.560]                 }
[10:21:44.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.560]                 "immediateCondition"))) {
[10:21:44.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.560]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.560]                   if (TRUE && !signal) {
[10:21:44.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.560]                     {
[10:21:44.560]                       inherits <- base::inherits
[10:21:44.560]                       invokeRestart <- base::invokeRestart
[10:21:44.560]                       is.null <- base::is.null
[10:21:44.560]                       muffled <- FALSE
[10:21:44.560]                       if (inherits(cond, "message")) {
[10:21:44.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.560]                         if (muffled) 
[10:21:44.560]                           invokeRestart("muffleMessage")
[10:21:44.560]                       }
[10:21:44.560]                       else if (inherits(cond, "warning")) {
[10:21:44.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.560]                         if (muffled) 
[10:21:44.560]                           invokeRestart("muffleWarning")
[10:21:44.560]                       }
[10:21:44.560]                       else if (inherits(cond, "condition")) {
[10:21:44.560]                         if (!is.null(pattern)) {
[10:21:44.560]                           computeRestarts <- base::computeRestarts
[10:21:44.560]                           grepl <- base::grepl
[10:21:44.560]                           restarts <- computeRestarts(cond)
[10:21:44.560]                           for (restart in restarts) {
[10:21:44.560]                             name <- restart$name
[10:21:44.560]                             if (is.null(name)) 
[10:21:44.560]                               next
[10:21:44.560]                             if (!grepl(pattern, name)) 
[10:21:44.560]                               next
[10:21:44.560]                             invokeRestart(restart)
[10:21:44.560]                             muffled <- TRUE
[10:21:44.560]                             break
[10:21:44.560]                           }
[10:21:44.560]                         }
[10:21:44.560]                       }
[10:21:44.560]                       invisible(muffled)
[10:21:44.560]                     }
[10:21:44.560]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.560]                   }
[10:21:44.560]                 }
[10:21:44.560]                 else {
[10:21:44.560]                   if (TRUE) {
[10:21:44.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.560]                     {
[10:21:44.560]                       inherits <- base::inherits
[10:21:44.560]                       invokeRestart <- base::invokeRestart
[10:21:44.560]                       is.null <- base::is.null
[10:21:44.560]                       muffled <- FALSE
[10:21:44.560]                       if (inherits(cond, "message")) {
[10:21:44.560]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.560]                         if (muffled) 
[10:21:44.560]                           invokeRestart("muffleMessage")
[10:21:44.560]                       }
[10:21:44.560]                       else if (inherits(cond, "warning")) {
[10:21:44.560]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.560]                         if (muffled) 
[10:21:44.560]                           invokeRestart("muffleWarning")
[10:21:44.560]                       }
[10:21:44.560]                       else if (inherits(cond, "condition")) {
[10:21:44.560]                         if (!is.null(pattern)) {
[10:21:44.560]                           computeRestarts <- base::computeRestarts
[10:21:44.560]                           grepl <- base::grepl
[10:21:44.560]                           restarts <- computeRestarts(cond)
[10:21:44.560]                           for (restart in restarts) {
[10:21:44.560]                             name <- restart$name
[10:21:44.560]                             if (is.null(name)) 
[10:21:44.560]                               next
[10:21:44.560]                             if (!grepl(pattern, name)) 
[10:21:44.560]                               next
[10:21:44.560]                             invokeRestart(restart)
[10:21:44.560]                             muffled <- TRUE
[10:21:44.560]                             break
[10:21:44.560]                           }
[10:21:44.560]                         }
[10:21:44.560]                       }
[10:21:44.560]                       invisible(muffled)
[10:21:44.560]                     }
[10:21:44.560]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.560]                   }
[10:21:44.560]                 }
[10:21:44.560]             }
[10:21:44.560]         }))
[10:21:44.560]     }, error = function(ex) {
[10:21:44.560]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.560]                 ...future.rng), started = ...future.startTime, 
[10:21:44.560]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.560]             version = "1.8"), class = "FutureResult")
[10:21:44.560]     }, finally = {
[10:21:44.560]         if (!identical(...future.workdir, getwd())) 
[10:21:44.560]             setwd(...future.workdir)
[10:21:44.560]         {
[10:21:44.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.560]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.560]             }
[10:21:44.560]             base::options(...future.oldOptions)
[10:21:44.560]             if (.Platform$OS.type == "windows") {
[10:21:44.560]                 old_names <- names(...future.oldEnvVars)
[10:21:44.560]                 envs <- base::Sys.getenv()
[10:21:44.560]                 names <- names(envs)
[10:21:44.560]                 common <- intersect(names, old_names)
[10:21:44.560]                 added <- setdiff(names, old_names)
[10:21:44.560]                 removed <- setdiff(old_names, names)
[10:21:44.560]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.560]                   envs[common]]
[10:21:44.560]                 NAMES <- toupper(changed)
[10:21:44.560]                 args <- list()
[10:21:44.560]                 for (kk in seq_along(NAMES)) {
[10:21:44.560]                   name <- changed[[kk]]
[10:21:44.560]                   NAME <- NAMES[[kk]]
[10:21:44.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.560]                     next
[10:21:44.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.560]                 }
[10:21:44.560]                 NAMES <- toupper(added)
[10:21:44.560]                 for (kk in seq_along(NAMES)) {
[10:21:44.560]                   name <- added[[kk]]
[10:21:44.560]                   NAME <- NAMES[[kk]]
[10:21:44.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.560]                     next
[10:21:44.560]                   args[[name]] <- ""
[10:21:44.560]                 }
[10:21:44.560]                 NAMES <- toupper(removed)
[10:21:44.560]                 for (kk in seq_along(NAMES)) {
[10:21:44.560]                   name <- removed[[kk]]
[10:21:44.560]                   NAME <- NAMES[[kk]]
[10:21:44.560]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.560]                     next
[10:21:44.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.560]                 }
[10:21:44.560]                 if (length(args) > 0) 
[10:21:44.560]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.560]             }
[10:21:44.560]             else {
[10:21:44.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.560]             }
[10:21:44.560]             {
[10:21:44.560]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.560]                   0L) {
[10:21:44.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.560]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.560]                   base::options(opts)
[10:21:44.560]                 }
[10:21:44.560]                 {
[10:21:44.560]                   {
[10:21:44.560]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.560]                     NULL
[10:21:44.560]                   }
[10:21:44.560]                   options(future.plan = NULL)
[10:21:44.560]                   if (is.na(NA_character_)) 
[10:21:44.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.560]                     .init = FALSE)
[10:21:44.560]                 }
[10:21:44.560]             }
[10:21:44.560]         }
[10:21:44.560]     })
[10:21:44.560]     if (TRUE) {
[10:21:44.560]         base::sink(type = "output", split = FALSE)
[10:21:44.560]         if (TRUE) {
[10:21:44.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.560]         }
[10:21:44.560]         else {
[10:21:44.560]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.560]         }
[10:21:44.560]         base::close(...future.stdout)
[10:21:44.560]         ...future.stdout <- NULL
[10:21:44.560]     }
[10:21:44.560]     ...future.result$conditions <- ...future.conditions
[10:21:44.560]     ...future.result$finished <- base::Sys.time()
[10:21:44.560]     ...future.result
[10:21:44.560] }
[10:21:44.563] assign_globals() ...
[10:21:44.563] List of 1
[10:21:44.563]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18e758100> 
[10:21:44.563]  - attr(*, "where")=List of 1
[10:21:44.563]   ..$ a:<environment: R_EmptyEnv> 
[10:21:44.563]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.563]  - attr(*, "resolved")= logi TRUE
[10:21:44.563]  - attr(*, "total_size")= num 3835
[10:21:44.563]  - attr(*, "already-done")= logi TRUE
[10:21:44.569] - copied ‘a’ to environment
[10:21:44.569] assign_globals() ... done
[10:21:44.569] requestCore(): workers = 2
[10:21:44.571] MulticoreFuture started
[10:21:44.572] - Launch lazy future ... done
[10:21:44.572] run() for ‘MulticoreFuture’ ... done
[10:21:44.573] result() for MulticoreFuture ...
[10:21:44.573] plan(): Setting new future strategy stack:
[10:21:44.573] List of future strategies:
[10:21:44.573] 1. sequential:
[10:21:44.573]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.573]    - tweaked: FALSE
[10:21:44.573]    - call: NULL
[10:21:44.575] plan(): nbrOfWorkers() = 1
[10:21:44.579] plan(): Setting new future strategy stack:
[10:21:44.579] List of future strategies:
[10:21:44.579] 1. multicore:
[10:21:44.579]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.579]    - tweaked: FALSE
[10:21:44.579]    - call: plan(strategy)
[10:21:44.583] plan(): nbrOfWorkers() = 2
[10:21:44.584] result() for MulticoreFuture ...
[10:21:44.584] result() for MulticoreFuture ... done
[10:21:44.584] signalConditions() ...
[10:21:44.585]  - include = ‘immediateCondition’
[10:21:44.585]  - exclude = 
[10:21:44.585]  - resignal = FALSE
[10:21:44.585]  - Number of conditions: 4
[10:21:44.585] signalConditions() ... done
[10:21:44.585] result() for MulticoreFuture ... done
[10:21:44.586] result() for MulticoreFuture ...
[10:21:44.586] result() for MulticoreFuture ... done
[10:21:44.586] signalConditions() ...
[10:21:44.586]  - include = ‘immediateCondition’
[10:21:44.586]  - exclude = 
[10:21:44.586]  - resignal = FALSE
[10:21:44.586]  - Number of conditions: 4
[10:21:44.587] signalConditions() ... done
[10:21:44.587] Future state: ‘finished’
[10:21:44.587] result() for MulticoreFuture ...
[10:21:44.587] result() for MulticoreFuture ... done
[10:21:44.587] signalConditions() ...
[10:21:44.587]  - include = ‘condition’
[10:21:44.588]  - exclude = ‘immediateCondition’
[10:21:44.588]  - resignal = TRUE
[10:21:44.588]  - Number of conditions: 4
[10:21:44.588]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.576] result() for MulticoreFuture ...
[10:21:44.588]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.576] result() for MulticoreFuture ... done
[10:21:44.589]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.577] result() for MulticoreFuture ...
[10:21:44.589]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.577] result() for MulticoreFuture ... done
[10:21:44.589] signalConditions() ... done
value(b) = 2
[10:21:44.589] result() for MulticoreFuture ...
[10:21:44.589] result() for MulticoreFuture ... done
[10:21:44.589] result() for MulticoreFuture ...
[10:21:44.590] result() for MulticoreFuture ... done
[10:21:44.590] signalConditions() ...
[10:21:44.590]  - include = ‘immediateCondition’
[10:21:44.590]  - exclude = 
[10:21:44.590]  - resignal = FALSE
[10:21:44.590]  - Number of conditions: 4
[10:21:44.590] signalConditions() ... done
[10:21:44.590] Future state: ‘finished’
[10:21:44.590] result() for MulticoreFuture ...
[10:21:44.591] result() for MulticoreFuture ... done
[10:21:44.591] signalConditions() ...
[10:21:44.591]  - include = ‘condition’
[10:21:44.591]  - exclude = ‘immediateCondition’
[10:21:44.591]  - resignal = TRUE
[10:21:44.591]  - Number of conditions: 4
[10:21:44.591]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.576] result() for MulticoreFuture ...
[10:21:44.591]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.576] result() for MulticoreFuture ... done
[10:21:44.592]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.577] result() for MulticoreFuture ...
[10:21:44.592]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.577] result() for MulticoreFuture ... done
[10:21:44.592] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.592] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.592] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.593] 
[10:21:44.593] Searching for globals ... DONE
[10:21:44.593] - globals: [0] <none>
[10:21:44.593] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.594] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.594] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.595] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:44.595] Searching for globals ... DONE
[10:21:44.595] Resolving globals: TRUE
[10:21:44.595] Resolving any globals that are futures ...
[10:21:44.595] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:44.596] Resolving any globals that are futures ... DONE
[10:21:44.596] Resolving futures part of globals (recursively) ...
[10:21:44.596] resolve() on list ...
[10:21:44.596]  recursive: 99
[10:21:44.596]  length: 1
[10:21:44.597]  elements: ‘a’
[10:21:44.597] run() for ‘Future’ ...
[10:21:44.597] - state: ‘created’
[10:21:44.597] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.599] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.599] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.599]   - Field: ‘label’
[10:21:44.599]   - Field: ‘local’
[10:21:44.599]   - Field: ‘owner’
[10:21:44.600]   - Field: ‘envir’
[10:21:44.600]   - Field: ‘workers’
[10:21:44.600]   - Field: ‘packages’
[10:21:44.600]   - Field: ‘gc’
[10:21:44.600]   - Field: ‘job’
[10:21:44.600]   - Field: ‘conditions’
[10:21:44.600]   - Field: ‘expr’
[10:21:44.600]   - Field: ‘uuid’
[10:21:44.600]   - Field: ‘seed’
[10:21:44.600]   - Field: ‘version’
[10:21:44.601]   - Field: ‘result’
[10:21:44.601]   - Field: ‘asynchronous’
[10:21:44.601]   - Field: ‘calls’
[10:21:44.601]   - Field: ‘globals’
[10:21:44.601]   - Field: ‘stdout’
[10:21:44.601]   - Field: ‘earlySignal’
[10:21:44.601]   - Field: ‘lazy’
[10:21:44.601]   - Field: ‘state’
[10:21:44.601] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.601] - Launch lazy future ...
[10:21:44.602] Packages needed by the future expression (n = 0): <none>
[10:21:44.602] Packages needed by future strategies (n = 0): <none>
[10:21:44.602] {
[10:21:44.602]     {
[10:21:44.602]         {
[10:21:44.602]             ...future.startTime <- base::Sys.time()
[10:21:44.602]             {
[10:21:44.602]                 {
[10:21:44.602]                   {
[10:21:44.602]                     {
[10:21:44.602]                       base::local({
[10:21:44.602]                         has_future <- base::requireNamespace("future", 
[10:21:44.602]                           quietly = TRUE)
[10:21:44.602]                         if (has_future) {
[10:21:44.602]                           ns <- base::getNamespace("future")
[10:21:44.602]                           version <- ns[[".package"]][["version"]]
[10:21:44.602]                           if (is.null(version)) 
[10:21:44.602]                             version <- utils::packageVersion("future")
[10:21:44.602]                         }
[10:21:44.602]                         else {
[10:21:44.602]                           version <- NULL
[10:21:44.602]                         }
[10:21:44.602]                         if (!has_future || version < "1.8.0") {
[10:21:44.602]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.602]                             "", base::R.version$version.string), 
[10:21:44.602]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.602]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.602]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.602]                               "release", "version")], collapse = " "), 
[10:21:44.602]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.602]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.602]                             info)
[10:21:44.602]                           info <- base::paste(info, collapse = "; ")
[10:21:44.602]                           if (!has_future) {
[10:21:44.602]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.602]                               info)
[10:21:44.602]                           }
[10:21:44.602]                           else {
[10:21:44.602]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.602]                               info, version)
[10:21:44.602]                           }
[10:21:44.602]                           base::stop(msg)
[10:21:44.602]                         }
[10:21:44.602]                       })
[10:21:44.602]                     }
[10:21:44.602]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.602]                     base::options(mc.cores = 1L)
[10:21:44.602]                   }
[10:21:44.602]                   ...future.strategy.old <- future::plan("list")
[10:21:44.602]                   options(future.plan = NULL)
[10:21:44.602]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.602]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.602]                 }
[10:21:44.602]                 ...future.workdir <- getwd()
[10:21:44.602]             }
[10:21:44.602]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.602]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.602]         }
[10:21:44.602]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.602]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.602]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.602]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.602]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.602]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.602]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.602]             base::names(...future.oldOptions))
[10:21:44.602]     }
[10:21:44.602]     if (FALSE) {
[10:21:44.602]     }
[10:21:44.602]     else {
[10:21:44.602]         if (TRUE) {
[10:21:44.602]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.602]                 open = "w")
[10:21:44.602]         }
[10:21:44.602]         else {
[10:21:44.602]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.602]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.602]         }
[10:21:44.602]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.602]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.602]             base::sink(type = "output", split = FALSE)
[10:21:44.602]             base::close(...future.stdout)
[10:21:44.602]         }, add = TRUE)
[10:21:44.602]     }
[10:21:44.602]     ...future.frame <- base::sys.nframe()
[10:21:44.602]     ...future.conditions <- base::list()
[10:21:44.602]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.602]     if (FALSE) {
[10:21:44.602]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.602]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.602]     }
[10:21:44.602]     ...future.result <- base::tryCatch({
[10:21:44.602]         base::withCallingHandlers({
[10:21:44.602]             ...future.value <- base::withVisible(base::local({
[10:21:44.602]                 withCallingHandlers({
[10:21:44.602]                   1
[10:21:44.602]                 }, immediateCondition = function(cond) {
[10:21:44.602]                   save_rds <- function (object, pathname, ...) 
[10:21:44.602]                   {
[10:21:44.602]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.602]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.602]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.602]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.602]                         fi_tmp[["mtime"]])
[10:21:44.602]                     }
[10:21:44.602]                     tryCatch({
[10:21:44.602]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.602]                     }, error = function(ex) {
[10:21:44.602]                       msg <- conditionMessage(ex)
[10:21:44.602]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.602]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.602]                         fi_tmp[["mtime"]], msg)
[10:21:44.602]                       ex$message <- msg
[10:21:44.602]                       stop(ex)
[10:21:44.602]                     })
[10:21:44.602]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.602]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.602]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.602]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.602]                       fi <- file.info(pathname)
[10:21:44.602]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.602]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.602]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.602]                         fi[["size"]], fi[["mtime"]])
[10:21:44.602]                       stop(msg)
[10:21:44.602]                     }
[10:21:44.602]                     invisible(pathname)
[10:21:44.602]                   }
[10:21:44.602]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.602]                     rootPath = tempdir()) 
[10:21:44.602]                   {
[10:21:44.602]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.602]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.602]                       tmpdir = path, fileext = ".rds")
[10:21:44.602]                     save_rds(obj, file)
[10:21:44.602]                   }
[10:21:44.602]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.602]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.602]                   {
[10:21:44.602]                     inherits <- base::inherits
[10:21:44.602]                     invokeRestart <- base::invokeRestart
[10:21:44.602]                     is.null <- base::is.null
[10:21:44.602]                     muffled <- FALSE
[10:21:44.602]                     if (inherits(cond, "message")) {
[10:21:44.602]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.602]                       if (muffled) 
[10:21:44.602]                         invokeRestart("muffleMessage")
[10:21:44.602]                     }
[10:21:44.602]                     else if (inherits(cond, "warning")) {
[10:21:44.602]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.602]                       if (muffled) 
[10:21:44.602]                         invokeRestart("muffleWarning")
[10:21:44.602]                     }
[10:21:44.602]                     else if (inherits(cond, "condition")) {
[10:21:44.602]                       if (!is.null(pattern)) {
[10:21:44.602]                         computeRestarts <- base::computeRestarts
[10:21:44.602]                         grepl <- base::grepl
[10:21:44.602]                         restarts <- computeRestarts(cond)
[10:21:44.602]                         for (restart in restarts) {
[10:21:44.602]                           name <- restart$name
[10:21:44.602]                           if (is.null(name)) 
[10:21:44.602]                             next
[10:21:44.602]                           if (!grepl(pattern, name)) 
[10:21:44.602]                             next
[10:21:44.602]                           invokeRestart(restart)
[10:21:44.602]                           muffled <- TRUE
[10:21:44.602]                           break
[10:21:44.602]                         }
[10:21:44.602]                       }
[10:21:44.602]                     }
[10:21:44.602]                     invisible(muffled)
[10:21:44.602]                   }
[10:21:44.602]                   muffleCondition(cond)
[10:21:44.602]                 })
[10:21:44.602]             }))
[10:21:44.602]             future::FutureResult(value = ...future.value$value, 
[10:21:44.602]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.602]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.602]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.602]                     ...future.globalenv.names))
[10:21:44.602]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.602]         }, condition = base::local({
[10:21:44.602]             c <- base::c
[10:21:44.602]             inherits <- base::inherits
[10:21:44.602]             invokeRestart <- base::invokeRestart
[10:21:44.602]             length <- base::length
[10:21:44.602]             list <- base::list
[10:21:44.602]             seq.int <- base::seq.int
[10:21:44.602]             signalCondition <- base::signalCondition
[10:21:44.602]             sys.calls <- base::sys.calls
[10:21:44.602]             `[[` <- base::`[[`
[10:21:44.602]             `+` <- base::`+`
[10:21:44.602]             `<<-` <- base::`<<-`
[10:21:44.602]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.602]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.602]                   3L)]
[10:21:44.602]             }
[10:21:44.602]             function(cond) {
[10:21:44.602]                 is_error <- inherits(cond, "error")
[10:21:44.602]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.602]                   NULL)
[10:21:44.602]                 if (is_error) {
[10:21:44.602]                   sessionInformation <- function() {
[10:21:44.602]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.602]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.602]                       search = base::search(), system = base::Sys.info())
[10:21:44.602]                   }
[10:21:44.602]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.602]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.602]                     cond$call), session = sessionInformation(), 
[10:21:44.602]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.602]                   signalCondition(cond)
[10:21:44.602]                 }
[10:21:44.602]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.602]                 "immediateCondition"))) {
[10:21:44.602]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.602]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.602]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.602]                   if (TRUE && !signal) {
[10:21:44.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.602]                     {
[10:21:44.602]                       inherits <- base::inherits
[10:21:44.602]                       invokeRestart <- base::invokeRestart
[10:21:44.602]                       is.null <- base::is.null
[10:21:44.602]                       muffled <- FALSE
[10:21:44.602]                       if (inherits(cond, "message")) {
[10:21:44.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.602]                         if (muffled) 
[10:21:44.602]                           invokeRestart("muffleMessage")
[10:21:44.602]                       }
[10:21:44.602]                       else if (inherits(cond, "warning")) {
[10:21:44.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.602]                         if (muffled) 
[10:21:44.602]                           invokeRestart("muffleWarning")
[10:21:44.602]                       }
[10:21:44.602]                       else if (inherits(cond, "condition")) {
[10:21:44.602]                         if (!is.null(pattern)) {
[10:21:44.602]                           computeRestarts <- base::computeRestarts
[10:21:44.602]                           grepl <- base::grepl
[10:21:44.602]                           restarts <- computeRestarts(cond)
[10:21:44.602]                           for (restart in restarts) {
[10:21:44.602]                             name <- restart$name
[10:21:44.602]                             if (is.null(name)) 
[10:21:44.602]                               next
[10:21:44.602]                             if (!grepl(pattern, name)) 
[10:21:44.602]                               next
[10:21:44.602]                             invokeRestart(restart)
[10:21:44.602]                             muffled <- TRUE
[10:21:44.602]                             break
[10:21:44.602]                           }
[10:21:44.602]                         }
[10:21:44.602]                       }
[10:21:44.602]                       invisible(muffled)
[10:21:44.602]                     }
[10:21:44.602]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.602]                   }
[10:21:44.602]                 }
[10:21:44.602]                 else {
[10:21:44.602]                   if (TRUE) {
[10:21:44.602]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.602]                     {
[10:21:44.602]                       inherits <- base::inherits
[10:21:44.602]                       invokeRestart <- base::invokeRestart
[10:21:44.602]                       is.null <- base::is.null
[10:21:44.602]                       muffled <- FALSE
[10:21:44.602]                       if (inherits(cond, "message")) {
[10:21:44.602]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.602]                         if (muffled) 
[10:21:44.602]                           invokeRestart("muffleMessage")
[10:21:44.602]                       }
[10:21:44.602]                       else if (inherits(cond, "warning")) {
[10:21:44.602]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.602]                         if (muffled) 
[10:21:44.602]                           invokeRestart("muffleWarning")
[10:21:44.602]                       }
[10:21:44.602]                       else if (inherits(cond, "condition")) {
[10:21:44.602]                         if (!is.null(pattern)) {
[10:21:44.602]                           computeRestarts <- base::computeRestarts
[10:21:44.602]                           grepl <- base::grepl
[10:21:44.602]                           restarts <- computeRestarts(cond)
[10:21:44.602]                           for (restart in restarts) {
[10:21:44.602]                             name <- restart$name
[10:21:44.602]                             if (is.null(name)) 
[10:21:44.602]                               next
[10:21:44.602]                             if (!grepl(pattern, name)) 
[10:21:44.602]                               next
[10:21:44.602]                             invokeRestart(restart)
[10:21:44.602]                             muffled <- TRUE
[10:21:44.602]                             break
[10:21:44.602]                           }
[10:21:44.602]                         }
[10:21:44.602]                       }
[10:21:44.602]                       invisible(muffled)
[10:21:44.602]                     }
[10:21:44.602]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.602]                   }
[10:21:44.602]                 }
[10:21:44.602]             }
[10:21:44.602]         }))
[10:21:44.602]     }, error = function(ex) {
[10:21:44.602]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.602]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.602]                 ...future.rng), started = ...future.startTime, 
[10:21:44.602]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.602]             version = "1.8"), class = "FutureResult")
[10:21:44.602]     }, finally = {
[10:21:44.602]         if (!identical(...future.workdir, getwd())) 
[10:21:44.602]             setwd(...future.workdir)
[10:21:44.602]         {
[10:21:44.602]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.602]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.602]             }
[10:21:44.602]             base::options(...future.oldOptions)
[10:21:44.602]             if (.Platform$OS.type == "windows") {
[10:21:44.602]                 old_names <- names(...future.oldEnvVars)
[10:21:44.602]                 envs <- base::Sys.getenv()
[10:21:44.602]                 names <- names(envs)
[10:21:44.602]                 common <- intersect(names, old_names)
[10:21:44.602]                 added <- setdiff(names, old_names)
[10:21:44.602]                 removed <- setdiff(old_names, names)
[10:21:44.602]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.602]                   envs[common]]
[10:21:44.602]                 NAMES <- toupper(changed)
[10:21:44.602]                 args <- list()
[10:21:44.602]                 for (kk in seq_along(NAMES)) {
[10:21:44.602]                   name <- changed[[kk]]
[10:21:44.602]                   NAME <- NAMES[[kk]]
[10:21:44.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.602]                     next
[10:21:44.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.602]                 }
[10:21:44.602]                 NAMES <- toupper(added)
[10:21:44.602]                 for (kk in seq_along(NAMES)) {
[10:21:44.602]                   name <- added[[kk]]
[10:21:44.602]                   NAME <- NAMES[[kk]]
[10:21:44.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.602]                     next
[10:21:44.602]                   args[[name]] <- ""
[10:21:44.602]                 }
[10:21:44.602]                 NAMES <- toupper(removed)
[10:21:44.602]                 for (kk in seq_along(NAMES)) {
[10:21:44.602]                   name <- removed[[kk]]
[10:21:44.602]                   NAME <- NAMES[[kk]]
[10:21:44.602]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.602]                     next
[10:21:44.602]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.602]                 }
[10:21:44.602]                 if (length(args) > 0) 
[10:21:44.602]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.602]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.602]             }
[10:21:44.602]             else {
[10:21:44.602]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.602]             }
[10:21:44.602]             {
[10:21:44.602]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.602]                   0L) {
[10:21:44.602]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.602]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.602]                   base::options(opts)
[10:21:44.602]                 }
[10:21:44.602]                 {
[10:21:44.602]                   {
[10:21:44.602]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.602]                     NULL
[10:21:44.602]                   }
[10:21:44.602]                   options(future.plan = NULL)
[10:21:44.602]                   if (is.na(NA_character_)) 
[10:21:44.602]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.602]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.602]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.602]                     .init = FALSE)
[10:21:44.602]                 }
[10:21:44.602]             }
[10:21:44.602]         }
[10:21:44.602]     })
[10:21:44.602]     if (TRUE) {
[10:21:44.602]         base::sink(type = "output", split = FALSE)
[10:21:44.602]         if (TRUE) {
[10:21:44.602]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.602]         }
[10:21:44.602]         else {
[10:21:44.602]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.602]         }
[10:21:44.602]         base::close(...future.stdout)
[10:21:44.602]         ...future.stdout <- NULL
[10:21:44.602]     }
[10:21:44.602]     ...future.result$conditions <- ...future.conditions
[10:21:44.602]     ...future.result$finished <- base::Sys.time()
[10:21:44.602]     ...future.result
[10:21:44.602] }
[10:21:44.605] requestCore(): workers = 2
[10:21:44.607] MulticoreFuture started
[10:21:44.607] - Launch lazy future ... done
[10:21:44.607] run() for ‘MulticoreFuture’ ... done
[10:21:44.608] plan(): Setting new future strategy stack:
[10:21:44.608] List of future strategies:
[10:21:44.608] 1. sequential:
[10:21:44.608]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.608]    - tweaked: FALSE
[10:21:44.608]    - call: NULL
[10:21:44.609] plan(): nbrOfWorkers() = 1
[10:21:44.611] plan(): Setting new future strategy stack:
[10:21:44.611] List of future strategies:
[10:21:44.611] 1. multicore:
[10:21:44.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.611]    - tweaked: FALSE
[10:21:44.611]    - call: plan(strategy)
[10:21:44.615] plan(): nbrOfWorkers() = 2
[10:21:44.615] Future #1
[10:21:44.615] result() for MulticoreFuture ...
[10:21:44.616] result() for MulticoreFuture ...
[10:21:44.616] result() for MulticoreFuture ... done
[10:21:44.616] result() for MulticoreFuture ... done
[10:21:44.617] result() for MulticoreFuture ...
[10:21:44.617] result() for MulticoreFuture ... done
[10:21:44.617] A MulticoreFuture was resolved
[10:21:44.617]  length: 0 (resolved future 1)
[10:21:44.617] resolve() on list ... DONE
[10:21:44.617] - globals: [1] ‘a’
[10:21:44.617] Resolving futures part of globals (recursively) ... DONE
[10:21:44.618] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[10:21:44.618] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[10:21:44.618] - globals: [1] ‘a’
[10:21:44.619] - packages: [1] ‘future’
[10:21:44.619] getGlobalsAndPackages() ... DONE
[10:21:44.619] run() for ‘Future’ ...
[10:21:44.619] - state: ‘created’
[10:21:44.619] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.625] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.625] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.625]   - Field: ‘label’
[10:21:44.625]   - Field: ‘local’
[10:21:44.626]   - Field: ‘owner’
[10:21:44.626]   - Field: ‘envir’
[10:21:44.626]   - Field: ‘workers’
[10:21:44.626]   - Field: ‘packages’
[10:21:44.626]   - Field: ‘gc’
[10:21:44.626]   - Field: ‘job’
[10:21:44.626]   - Field: ‘conditions’
[10:21:44.627]   - Field: ‘expr’
[10:21:44.627]   - Field: ‘uuid’
[10:21:44.627]   - Field: ‘seed’
[10:21:44.627]   - Field: ‘version’
[10:21:44.627]   - Field: ‘result’
[10:21:44.627]   - Field: ‘asynchronous’
[10:21:44.627]   - Field: ‘calls’
[10:21:44.627]   - Field: ‘globals’
[10:21:44.628]   - Field: ‘stdout’
[10:21:44.628]   - Field: ‘earlySignal’
[10:21:44.628]   - Field: ‘lazy’
[10:21:44.628]   - Field: ‘state’
[10:21:44.628] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.628] - Launch lazy future ...
[10:21:44.629] Packages needed by the future expression (n = 1): ‘future’
[10:21:44.629] Packages needed by future strategies (n = 0): <none>
[10:21:44.630] {
[10:21:44.630]     {
[10:21:44.630]         {
[10:21:44.630]             ...future.startTime <- base::Sys.time()
[10:21:44.630]             {
[10:21:44.630]                 {
[10:21:44.630]                   {
[10:21:44.630]                     {
[10:21:44.630]                       {
[10:21:44.630]                         base::local({
[10:21:44.630]                           has_future <- base::requireNamespace("future", 
[10:21:44.630]                             quietly = TRUE)
[10:21:44.630]                           if (has_future) {
[10:21:44.630]                             ns <- base::getNamespace("future")
[10:21:44.630]                             version <- ns[[".package"]][["version"]]
[10:21:44.630]                             if (is.null(version)) 
[10:21:44.630]                               version <- utils::packageVersion("future")
[10:21:44.630]                           }
[10:21:44.630]                           else {
[10:21:44.630]                             version <- NULL
[10:21:44.630]                           }
[10:21:44.630]                           if (!has_future || version < "1.8.0") {
[10:21:44.630]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.630]                               "", base::R.version$version.string), 
[10:21:44.630]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:44.630]                                 base::R.version$platform, 8 * 
[10:21:44.630]                                   base::.Machine$sizeof.pointer), 
[10:21:44.630]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.630]                                 "release", "version")], collapse = " "), 
[10:21:44.630]                               hostname = base::Sys.info()[["nodename"]])
[10:21:44.630]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.630]                               info)
[10:21:44.630]                             info <- base::paste(info, collapse = "; ")
[10:21:44.630]                             if (!has_future) {
[10:21:44.630]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.630]                                 info)
[10:21:44.630]                             }
[10:21:44.630]                             else {
[10:21:44.630]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.630]                                 info, version)
[10:21:44.630]                             }
[10:21:44.630]                             base::stop(msg)
[10:21:44.630]                           }
[10:21:44.630]                         })
[10:21:44.630]                       }
[10:21:44.630]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.630]                       base::options(mc.cores = 1L)
[10:21:44.630]                     }
[10:21:44.630]                     base::local({
[10:21:44.630]                       for (pkg in "future") {
[10:21:44.630]                         base::loadNamespace(pkg)
[10:21:44.630]                         base::library(pkg, character.only = TRUE)
[10:21:44.630]                       }
[10:21:44.630]                     })
[10:21:44.630]                   }
[10:21:44.630]                   ...future.strategy.old <- future::plan("list")
[10:21:44.630]                   options(future.plan = NULL)
[10:21:44.630]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.630]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.630]                 }
[10:21:44.630]                 ...future.workdir <- getwd()
[10:21:44.630]             }
[10:21:44.630]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.630]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.630]         }
[10:21:44.630]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.630]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.630]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.630]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.630]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.630]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.630]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.630]             base::names(...future.oldOptions))
[10:21:44.630]     }
[10:21:44.630]     if (FALSE) {
[10:21:44.630]     }
[10:21:44.630]     else {
[10:21:44.630]         if (TRUE) {
[10:21:44.630]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.630]                 open = "w")
[10:21:44.630]         }
[10:21:44.630]         else {
[10:21:44.630]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.630]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.630]         }
[10:21:44.630]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.630]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.630]             base::sink(type = "output", split = FALSE)
[10:21:44.630]             base::close(...future.stdout)
[10:21:44.630]         }, add = TRUE)
[10:21:44.630]     }
[10:21:44.630]     ...future.frame <- base::sys.nframe()
[10:21:44.630]     ...future.conditions <- base::list()
[10:21:44.630]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.630]     if (FALSE) {
[10:21:44.630]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.630]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.630]     }
[10:21:44.630]     ...future.result <- base::tryCatch({
[10:21:44.630]         base::withCallingHandlers({
[10:21:44.630]             ...future.value <- base::withVisible(base::local({
[10:21:44.630]                 withCallingHandlers({
[10:21:44.630]                   value(a) + 1
[10:21:44.630]                 }, immediateCondition = function(cond) {
[10:21:44.630]                   save_rds <- function (object, pathname, ...) 
[10:21:44.630]                   {
[10:21:44.630]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.630]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.630]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.630]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.630]                         fi_tmp[["mtime"]])
[10:21:44.630]                     }
[10:21:44.630]                     tryCatch({
[10:21:44.630]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.630]                     }, error = function(ex) {
[10:21:44.630]                       msg <- conditionMessage(ex)
[10:21:44.630]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.630]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.630]                         fi_tmp[["mtime"]], msg)
[10:21:44.630]                       ex$message <- msg
[10:21:44.630]                       stop(ex)
[10:21:44.630]                     })
[10:21:44.630]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.630]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.630]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.630]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.630]                       fi <- file.info(pathname)
[10:21:44.630]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.630]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.630]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.630]                         fi[["size"]], fi[["mtime"]])
[10:21:44.630]                       stop(msg)
[10:21:44.630]                     }
[10:21:44.630]                     invisible(pathname)
[10:21:44.630]                   }
[10:21:44.630]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.630]                     rootPath = tempdir()) 
[10:21:44.630]                   {
[10:21:44.630]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.630]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.630]                       tmpdir = path, fileext = ".rds")
[10:21:44.630]                     save_rds(obj, file)
[10:21:44.630]                   }
[10:21:44.630]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.630]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.630]                   {
[10:21:44.630]                     inherits <- base::inherits
[10:21:44.630]                     invokeRestart <- base::invokeRestart
[10:21:44.630]                     is.null <- base::is.null
[10:21:44.630]                     muffled <- FALSE
[10:21:44.630]                     if (inherits(cond, "message")) {
[10:21:44.630]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.630]                       if (muffled) 
[10:21:44.630]                         invokeRestart("muffleMessage")
[10:21:44.630]                     }
[10:21:44.630]                     else if (inherits(cond, "warning")) {
[10:21:44.630]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.630]                       if (muffled) 
[10:21:44.630]                         invokeRestart("muffleWarning")
[10:21:44.630]                     }
[10:21:44.630]                     else if (inherits(cond, "condition")) {
[10:21:44.630]                       if (!is.null(pattern)) {
[10:21:44.630]                         computeRestarts <- base::computeRestarts
[10:21:44.630]                         grepl <- base::grepl
[10:21:44.630]                         restarts <- computeRestarts(cond)
[10:21:44.630]                         for (restart in restarts) {
[10:21:44.630]                           name <- restart$name
[10:21:44.630]                           if (is.null(name)) 
[10:21:44.630]                             next
[10:21:44.630]                           if (!grepl(pattern, name)) 
[10:21:44.630]                             next
[10:21:44.630]                           invokeRestart(restart)
[10:21:44.630]                           muffled <- TRUE
[10:21:44.630]                           break
[10:21:44.630]                         }
[10:21:44.630]                       }
[10:21:44.630]                     }
[10:21:44.630]                     invisible(muffled)
[10:21:44.630]                   }
[10:21:44.630]                   muffleCondition(cond)
[10:21:44.630]                 })
[10:21:44.630]             }))
[10:21:44.630]             future::FutureResult(value = ...future.value$value, 
[10:21:44.630]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.630]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.630]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.630]                     ...future.globalenv.names))
[10:21:44.630]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.630]         }, condition = base::local({
[10:21:44.630]             c <- base::c
[10:21:44.630]             inherits <- base::inherits
[10:21:44.630]             invokeRestart <- base::invokeRestart
[10:21:44.630]             length <- base::length
[10:21:44.630]             list <- base::list
[10:21:44.630]             seq.int <- base::seq.int
[10:21:44.630]             signalCondition <- base::signalCondition
[10:21:44.630]             sys.calls <- base::sys.calls
[10:21:44.630]             `[[` <- base::`[[`
[10:21:44.630]             `+` <- base::`+`
[10:21:44.630]             `<<-` <- base::`<<-`
[10:21:44.630]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.630]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.630]                   3L)]
[10:21:44.630]             }
[10:21:44.630]             function(cond) {
[10:21:44.630]                 is_error <- inherits(cond, "error")
[10:21:44.630]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.630]                   NULL)
[10:21:44.630]                 if (is_error) {
[10:21:44.630]                   sessionInformation <- function() {
[10:21:44.630]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.630]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.630]                       search = base::search(), system = base::Sys.info())
[10:21:44.630]                   }
[10:21:44.630]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.630]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.630]                     cond$call), session = sessionInformation(), 
[10:21:44.630]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.630]                   signalCondition(cond)
[10:21:44.630]                 }
[10:21:44.630]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.630]                 "immediateCondition"))) {
[10:21:44.630]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.630]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.630]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.630]                   if (TRUE && !signal) {
[10:21:44.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.630]                     {
[10:21:44.630]                       inherits <- base::inherits
[10:21:44.630]                       invokeRestart <- base::invokeRestart
[10:21:44.630]                       is.null <- base::is.null
[10:21:44.630]                       muffled <- FALSE
[10:21:44.630]                       if (inherits(cond, "message")) {
[10:21:44.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.630]                         if (muffled) 
[10:21:44.630]                           invokeRestart("muffleMessage")
[10:21:44.630]                       }
[10:21:44.630]                       else if (inherits(cond, "warning")) {
[10:21:44.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.630]                         if (muffled) 
[10:21:44.630]                           invokeRestart("muffleWarning")
[10:21:44.630]                       }
[10:21:44.630]                       else if (inherits(cond, "condition")) {
[10:21:44.630]                         if (!is.null(pattern)) {
[10:21:44.630]                           computeRestarts <- base::computeRestarts
[10:21:44.630]                           grepl <- base::grepl
[10:21:44.630]                           restarts <- computeRestarts(cond)
[10:21:44.630]                           for (restart in restarts) {
[10:21:44.630]                             name <- restart$name
[10:21:44.630]                             if (is.null(name)) 
[10:21:44.630]                               next
[10:21:44.630]                             if (!grepl(pattern, name)) 
[10:21:44.630]                               next
[10:21:44.630]                             invokeRestart(restart)
[10:21:44.630]                             muffled <- TRUE
[10:21:44.630]                             break
[10:21:44.630]                           }
[10:21:44.630]                         }
[10:21:44.630]                       }
[10:21:44.630]                       invisible(muffled)
[10:21:44.630]                     }
[10:21:44.630]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.630]                   }
[10:21:44.630]                 }
[10:21:44.630]                 else {
[10:21:44.630]                   if (TRUE) {
[10:21:44.630]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.630]                     {
[10:21:44.630]                       inherits <- base::inherits
[10:21:44.630]                       invokeRestart <- base::invokeRestart
[10:21:44.630]                       is.null <- base::is.null
[10:21:44.630]                       muffled <- FALSE
[10:21:44.630]                       if (inherits(cond, "message")) {
[10:21:44.630]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.630]                         if (muffled) 
[10:21:44.630]                           invokeRestart("muffleMessage")
[10:21:44.630]                       }
[10:21:44.630]                       else if (inherits(cond, "warning")) {
[10:21:44.630]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.630]                         if (muffled) 
[10:21:44.630]                           invokeRestart("muffleWarning")
[10:21:44.630]                       }
[10:21:44.630]                       else if (inherits(cond, "condition")) {
[10:21:44.630]                         if (!is.null(pattern)) {
[10:21:44.630]                           computeRestarts <- base::computeRestarts
[10:21:44.630]                           grepl <- base::grepl
[10:21:44.630]                           restarts <- computeRestarts(cond)
[10:21:44.630]                           for (restart in restarts) {
[10:21:44.630]                             name <- restart$name
[10:21:44.630]                             if (is.null(name)) 
[10:21:44.630]                               next
[10:21:44.630]                             if (!grepl(pattern, name)) 
[10:21:44.630]                               next
[10:21:44.630]                             invokeRestart(restart)
[10:21:44.630]                             muffled <- TRUE
[10:21:44.630]                             break
[10:21:44.630]                           }
[10:21:44.630]                         }
[10:21:44.630]                       }
[10:21:44.630]                       invisible(muffled)
[10:21:44.630]                     }
[10:21:44.630]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.630]                   }
[10:21:44.630]                 }
[10:21:44.630]             }
[10:21:44.630]         }))
[10:21:44.630]     }, error = function(ex) {
[10:21:44.630]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.630]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.630]                 ...future.rng), started = ...future.startTime, 
[10:21:44.630]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.630]             version = "1.8"), class = "FutureResult")
[10:21:44.630]     }, finally = {
[10:21:44.630]         if (!identical(...future.workdir, getwd())) 
[10:21:44.630]             setwd(...future.workdir)
[10:21:44.630]         {
[10:21:44.630]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.630]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.630]             }
[10:21:44.630]             base::options(...future.oldOptions)
[10:21:44.630]             if (.Platform$OS.type == "windows") {
[10:21:44.630]                 old_names <- names(...future.oldEnvVars)
[10:21:44.630]                 envs <- base::Sys.getenv()
[10:21:44.630]                 names <- names(envs)
[10:21:44.630]                 common <- intersect(names, old_names)
[10:21:44.630]                 added <- setdiff(names, old_names)
[10:21:44.630]                 removed <- setdiff(old_names, names)
[10:21:44.630]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.630]                   envs[common]]
[10:21:44.630]                 NAMES <- toupper(changed)
[10:21:44.630]                 args <- list()
[10:21:44.630]                 for (kk in seq_along(NAMES)) {
[10:21:44.630]                   name <- changed[[kk]]
[10:21:44.630]                   NAME <- NAMES[[kk]]
[10:21:44.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.630]                     next
[10:21:44.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.630]                 }
[10:21:44.630]                 NAMES <- toupper(added)
[10:21:44.630]                 for (kk in seq_along(NAMES)) {
[10:21:44.630]                   name <- added[[kk]]
[10:21:44.630]                   NAME <- NAMES[[kk]]
[10:21:44.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.630]                     next
[10:21:44.630]                   args[[name]] <- ""
[10:21:44.630]                 }
[10:21:44.630]                 NAMES <- toupper(removed)
[10:21:44.630]                 for (kk in seq_along(NAMES)) {
[10:21:44.630]                   name <- removed[[kk]]
[10:21:44.630]                   NAME <- NAMES[[kk]]
[10:21:44.630]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.630]                     next
[10:21:44.630]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.630]                 }
[10:21:44.630]                 if (length(args) > 0) 
[10:21:44.630]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.630]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.630]             }
[10:21:44.630]             else {
[10:21:44.630]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.630]             }
[10:21:44.630]             {
[10:21:44.630]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.630]                   0L) {
[10:21:44.630]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.630]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.630]                   base::options(opts)
[10:21:44.630]                 }
[10:21:44.630]                 {
[10:21:44.630]                   {
[10:21:44.630]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.630]                     NULL
[10:21:44.630]                   }
[10:21:44.630]                   options(future.plan = NULL)
[10:21:44.630]                   if (is.na(NA_character_)) 
[10:21:44.630]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.630]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.630]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.630]                     .init = FALSE)
[10:21:44.630]                 }
[10:21:44.630]             }
[10:21:44.630]         }
[10:21:44.630]     })
[10:21:44.630]     if (TRUE) {
[10:21:44.630]         base::sink(type = "output", split = FALSE)
[10:21:44.630]         if (TRUE) {
[10:21:44.630]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.630]         }
[10:21:44.630]         else {
[10:21:44.630]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.630]         }
[10:21:44.630]         base::close(...future.stdout)
[10:21:44.630]         ...future.stdout <- NULL
[10:21:44.630]     }
[10:21:44.630]     ...future.result$conditions <- ...future.conditions
[10:21:44.630]     ...future.result$finished <- base::Sys.time()
[10:21:44.630]     ...future.result
[10:21:44.630] }
[10:21:44.632] assign_globals() ...
[10:21:44.632] List of 1
[10:21:44.632]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55f18c1e9f38> 
[10:21:44.632]  - attr(*, "where")=List of 1
[10:21:44.632]   ..$ a:<environment: R_EmptyEnv> 
[10:21:44.632]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.632]  - attr(*, "resolved")= logi TRUE
[10:21:44.632]  - attr(*, "total_size")= num 3835
[10:21:44.632]  - attr(*, "already-done")= logi TRUE
[10:21:44.635] - copied ‘a’ to environment
[10:21:44.635] assign_globals() ... done
[10:21:44.636] requestCore(): workers = 2
[10:21:44.637] MulticoreFuture started
[10:21:44.638] - Launch lazy future ... done
[10:21:44.638] run() for ‘MulticoreFuture’ ... done
[10:21:44.638] result() for MulticoreFuture ...
[10:21:44.639] plan(): Setting new future strategy stack:
[10:21:44.639] List of future strategies:
[10:21:44.639] 1. sequential:
[10:21:44.639]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.639]    - tweaked: FALSE
[10:21:44.639]    - call: NULL
[10:21:44.640] plan(): nbrOfWorkers() = 1
[10:21:44.643] plan(): Setting new future strategy stack:
[10:21:44.643] List of future strategies:
[10:21:44.643] 1. multicore:
[10:21:44.643]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.643]    - tweaked: FALSE
[10:21:44.643]    - call: plan(strategy)
[10:21:44.646] plan(): nbrOfWorkers() = 2
[10:21:44.647] result() for MulticoreFuture ...
[10:21:44.647] result() for MulticoreFuture ... done
[10:21:44.647] signalConditions() ...
[10:21:44.648]  - include = ‘immediateCondition’
[10:21:44.648]  - exclude = 
[10:21:44.648]  - resignal = FALSE
[10:21:44.648]  - Number of conditions: 4
[10:21:44.648] signalConditions() ... done
[10:21:44.648] result() for MulticoreFuture ... done
[10:21:44.648] result() for MulticoreFuture ...
[10:21:44.648] result() for MulticoreFuture ... done
[10:21:44.649] signalConditions() ...
[10:21:44.649]  - include = ‘immediateCondition’
[10:21:44.649]  - exclude = 
[10:21:44.649]  - resignal = FALSE
[10:21:44.649]  - Number of conditions: 4
[10:21:44.649] signalConditions() ... done
[10:21:44.649] Future state: ‘finished’
[10:21:44.649] result() for MulticoreFuture ...
[10:21:44.650] result() for MulticoreFuture ... done
[10:21:44.650] signalConditions() ...
[10:21:44.650]  - include = ‘condition’
[10:21:44.650]  - exclude = ‘immediateCondition’
[10:21:44.650]  - resignal = TRUE
[10:21:44.650]  - Number of conditions: 4
[10:21:44.650]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.641] result() for MulticoreFuture ...
[10:21:44.650]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.642] result() for MulticoreFuture ... done
[10:21:44.651]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.642] result() for MulticoreFuture ...
[10:21:44.651]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.642] result() for MulticoreFuture ... done
[10:21:44.651] signalConditions() ... done
value(b) = 2
[10:21:44.651] result() for MulticoreFuture ...
[10:21:44.651] result() for MulticoreFuture ... done
[10:21:44.651] result() for MulticoreFuture ...
[10:21:44.651] result() for MulticoreFuture ... done
[10:21:44.652] signalConditions() ...
[10:21:44.652]  - include = ‘immediateCondition’
[10:21:44.652]  - exclude = 
[10:21:44.652]  - resignal = FALSE
[10:21:44.652]  - Number of conditions: 4
[10:21:44.652] signalConditions() ... done
[10:21:44.652] Future state: ‘finished’
[10:21:44.652] result() for MulticoreFuture ...
[10:21:44.652] result() for MulticoreFuture ... done
[10:21:44.653] signalConditions() ...
[10:21:44.653]  - include = ‘condition’
[10:21:44.653]  - exclude = ‘immediateCondition’
[10:21:44.653]  - resignal = TRUE
[10:21:44.653]  - Number of conditions: 4
[10:21:44.653]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.641] result() for MulticoreFuture ...
[10:21:44.653]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.642] result() for MulticoreFuture ... done
[10:21:44.653]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.642] result() for MulticoreFuture ...
[10:21:44.654]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[10:21:44.642] result() for MulticoreFuture ... done
[10:21:44.654] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.654] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.654] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.656] - globals found: [2] ‘{’, ‘pkg’
[10:21:44.656] Searching for globals ... DONE
[10:21:44.656] Resolving globals: TRUE
[10:21:44.656] Resolving any globals that are futures ...
[10:21:44.656] - globals: [2] ‘{’, ‘pkg’
[10:21:44.656] Resolving any globals that are futures ... DONE
[10:21:44.657] Resolving futures part of globals (recursively) ...
[10:21:44.657] resolve() on list ...
[10:21:44.657]  recursive: 99
[10:21:44.657]  length: 1
[10:21:44.657]  elements: ‘pkg’
[10:21:44.657]  length: 0 (resolved future 1)
[10:21:44.658] resolve() on list ... DONE
[10:21:44.658] - globals: [1] ‘pkg’
[10:21:44.658] Resolving futures part of globals (recursively) ... DONE
[10:21:44.658] The total size of the 1 globals is 42 bytes (42 bytes)
[10:21:44.658] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[10:21:44.658] - globals: [1] ‘pkg’
[10:21:44.659] 
[10:21:44.659] getGlobalsAndPackages() ... DONE
[10:21:44.659] Packages needed by the future expression (n = 0): <none>
[10:21:44.659] Packages needed by future strategies (n = 0): <none>
[10:21:44.660] {
[10:21:44.660]     {
[10:21:44.660]         {
[10:21:44.660]             ...future.startTime <- base::Sys.time()
[10:21:44.660]             {
[10:21:44.660]                 {
[10:21:44.660]                   {
[10:21:44.660]                     base::local({
[10:21:44.660]                       has_future <- base::requireNamespace("future", 
[10:21:44.660]                         quietly = TRUE)
[10:21:44.660]                       if (has_future) {
[10:21:44.660]                         ns <- base::getNamespace("future")
[10:21:44.660]                         version <- ns[[".package"]][["version"]]
[10:21:44.660]                         if (is.null(version)) 
[10:21:44.660]                           version <- utils::packageVersion("future")
[10:21:44.660]                       }
[10:21:44.660]                       else {
[10:21:44.660]                         version <- NULL
[10:21:44.660]                       }
[10:21:44.660]                       if (!has_future || version < "1.8.0") {
[10:21:44.660]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.660]                           "", base::R.version$version.string), 
[10:21:44.660]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:44.660]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.660]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.660]                             "release", "version")], collapse = " "), 
[10:21:44.660]                           hostname = base::Sys.info()[["nodename"]])
[10:21:44.660]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.660]                           info)
[10:21:44.660]                         info <- base::paste(info, collapse = "; ")
[10:21:44.660]                         if (!has_future) {
[10:21:44.660]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.660]                             info)
[10:21:44.660]                         }
[10:21:44.660]                         else {
[10:21:44.660]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.660]                             info, version)
[10:21:44.660]                         }
[10:21:44.660]                         base::stop(msg)
[10:21:44.660]                       }
[10:21:44.660]                     })
[10:21:44.660]                   }
[10:21:44.660]                   ...future.strategy.old <- future::plan("list")
[10:21:44.660]                   options(future.plan = NULL)
[10:21:44.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.660]                 }
[10:21:44.660]                 ...future.workdir <- getwd()
[10:21:44.660]             }
[10:21:44.660]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.660]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.660]         }
[10:21:44.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.660]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.660]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.660]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.660]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.660]             base::names(...future.oldOptions))
[10:21:44.660]     }
[10:21:44.660]     if (FALSE) {
[10:21:44.660]     }
[10:21:44.660]     else {
[10:21:44.660]         if (TRUE) {
[10:21:44.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.660]                 open = "w")
[10:21:44.660]         }
[10:21:44.660]         else {
[10:21:44.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.660]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.660]         }
[10:21:44.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.660]             base::sink(type = "output", split = FALSE)
[10:21:44.660]             base::close(...future.stdout)
[10:21:44.660]         }, add = TRUE)
[10:21:44.660]     }
[10:21:44.660]     ...future.frame <- base::sys.nframe()
[10:21:44.660]     ...future.conditions <- base::list()
[10:21:44.660]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.660]     if (FALSE) {
[10:21:44.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.660]     }
[10:21:44.660]     ...future.result <- base::tryCatch({
[10:21:44.660]         base::withCallingHandlers({
[10:21:44.660]             ...future.value <- base::withVisible(base::local({
[10:21:44.660]                 pkg
[10:21:44.660]             }))
[10:21:44.660]             future::FutureResult(value = ...future.value$value, 
[10:21:44.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.660]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.660]                     ...future.globalenv.names))
[10:21:44.660]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.660]         }, condition = base::local({
[10:21:44.660]             c <- base::c
[10:21:44.660]             inherits <- base::inherits
[10:21:44.660]             invokeRestart <- base::invokeRestart
[10:21:44.660]             length <- base::length
[10:21:44.660]             list <- base::list
[10:21:44.660]             seq.int <- base::seq.int
[10:21:44.660]             signalCondition <- base::signalCondition
[10:21:44.660]             sys.calls <- base::sys.calls
[10:21:44.660]             `[[` <- base::`[[`
[10:21:44.660]             `+` <- base::`+`
[10:21:44.660]             `<<-` <- base::`<<-`
[10:21:44.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.660]                   3L)]
[10:21:44.660]             }
[10:21:44.660]             function(cond) {
[10:21:44.660]                 is_error <- inherits(cond, "error")
[10:21:44.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.660]                   NULL)
[10:21:44.660]                 if (is_error) {
[10:21:44.660]                   sessionInformation <- function() {
[10:21:44.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.660]                       search = base::search(), system = base::Sys.info())
[10:21:44.660]                   }
[10:21:44.660]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.660]                     cond$call), session = sessionInformation(), 
[10:21:44.660]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.660]                   signalCondition(cond)
[10:21:44.660]                 }
[10:21:44.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.660]                 "immediateCondition"))) {
[10:21:44.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.660]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.660]                   if (TRUE && !signal) {
[10:21:44.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.660]                     {
[10:21:44.660]                       inherits <- base::inherits
[10:21:44.660]                       invokeRestart <- base::invokeRestart
[10:21:44.660]                       is.null <- base::is.null
[10:21:44.660]                       muffled <- FALSE
[10:21:44.660]                       if (inherits(cond, "message")) {
[10:21:44.660]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.660]                         if (muffled) 
[10:21:44.660]                           invokeRestart("muffleMessage")
[10:21:44.660]                       }
[10:21:44.660]                       else if (inherits(cond, "warning")) {
[10:21:44.660]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.660]                         if (muffled) 
[10:21:44.660]                           invokeRestart("muffleWarning")
[10:21:44.660]                       }
[10:21:44.660]                       else if (inherits(cond, "condition")) {
[10:21:44.660]                         if (!is.null(pattern)) {
[10:21:44.660]                           computeRestarts <- base::computeRestarts
[10:21:44.660]                           grepl <- base::grepl
[10:21:44.660]                           restarts <- computeRestarts(cond)
[10:21:44.660]                           for (restart in restarts) {
[10:21:44.660]                             name <- restart$name
[10:21:44.660]                             if (is.null(name)) 
[10:21:44.660]                               next
[10:21:44.660]                             if (!grepl(pattern, name)) 
[10:21:44.660]                               next
[10:21:44.660]                             invokeRestart(restart)
[10:21:44.660]                             muffled <- TRUE
[10:21:44.660]                             break
[10:21:44.660]                           }
[10:21:44.660]                         }
[10:21:44.660]                       }
[10:21:44.660]                       invisible(muffled)
[10:21:44.660]                     }
[10:21:44.660]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.660]                   }
[10:21:44.660]                 }
[10:21:44.660]                 else {
[10:21:44.660]                   if (TRUE) {
[10:21:44.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.660]                     {
[10:21:44.660]                       inherits <- base::inherits
[10:21:44.660]                       invokeRestart <- base::invokeRestart
[10:21:44.660]                       is.null <- base::is.null
[10:21:44.660]                       muffled <- FALSE
[10:21:44.660]                       if (inherits(cond, "message")) {
[10:21:44.660]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.660]                         if (muffled) 
[10:21:44.660]                           invokeRestart("muffleMessage")
[10:21:44.660]                       }
[10:21:44.660]                       else if (inherits(cond, "warning")) {
[10:21:44.660]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.660]                         if (muffled) 
[10:21:44.660]                           invokeRestart("muffleWarning")
[10:21:44.660]                       }
[10:21:44.660]                       else if (inherits(cond, "condition")) {
[10:21:44.660]                         if (!is.null(pattern)) {
[10:21:44.660]                           computeRestarts <- base::computeRestarts
[10:21:44.660]                           grepl <- base::grepl
[10:21:44.660]                           restarts <- computeRestarts(cond)
[10:21:44.660]                           for (restart in restarts) {
[10:21:44.660]                             name <- restart$name
[10:21:44.660]                             if (is.null(name)) 
[10:21:44.660]                               next
[10:21:44.660]                             if (!grepl(pattern, name)) 
[10:21:44.660]                               next
[10:21:44.660]                             invokeRestart(restart)
[10:21:44.660]                             muffled <- TRUE
[10:21:44.660]                             break
[10:21:44.660]                           }
[10:21:44.660]                         }
[10:21:44.660]                       }
[10:21:44.660]                       invisible(muffled)
[10:21:44.660]                     }
[10:21:44.660]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.660]                   }
[10:21:44.660]                 }
[10:21:44.660]             }
[10:21:44.660]         }))
[10:21:44.660]     }, error = function(ex) {
[10:21:44.660]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.660]                 ...future.rng), started = ...future.startTime, 
[10:21:44.660]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.660]             version = "1.8"), class = "FutureResult")
[10:21:44.660]     }, finally = {
[10:21:44.660]         if (!identical(...future.workdir, getwd())) 
[10:21:44.660]             setwd(...future.workdir)
[10:21:44.660]         {
[10:21:44.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.660]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.660]             }
[10:21:44.660]             base::options(...future.oldOptions)
[10:21:44.660]             if (.Platform$OS.type == "windows") {
[10:21:44.660]                 old_names <- names(...future.oldEnvVars)
[10:21:44.660]                 envs <- base::Sys.getenv()
[10:21:44.660]                 names <- names(envs)
[10:21:44.660]                 common <- intersect(names, old_names)
[10:21:44.660]                 added <- setdiff(names, old_names)
[10:21:44.660]                 removed <- setdiff(old_names, names)
[10:21:44.660]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.660]                   envs[common]]
[10:21:44.660]                 NAMES <- toupper(changed)
[10:21:44.660]                 args <- list()
[10:21:44.660]                 for (kk in seq_along(NAMES)) {
[10:21:44.660]                   name <- changed[[kk]]
[10:21:44.660]                   NAME <- NAMES[[kk]]
[10:21:44.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.660]                     next
[10:21:44.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.660]                 }
[10:21:44.660]                 NAMES <- toupper(added)
[10:21:44.660]                 for (kk in seq_along(NAMES)) {
[10:21:44.660]                   name <- added[[kk]]
[10:21:44.660]                   NAME <- NAMES[[kk]]
[10:21:44.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.660]                     next
[10:21:44.660]                   args[[name]] <- ""
[10:21:44.660]                 }
[10:21:44.660]                 NAMES <- toupper(removed)
[10:21:44.660]                 for (kk in seq_along(NAMES)) {
[10:21:44.660]                   name <- removed[[kk]]
[10:21:44.660]                   NAME <- NAMES[[kk]]
[10:21:44.660]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.660]                     next
[10:21:44.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.660]                 }
[10:21:44.660]                 if (length(args) > 0) 
[10:21:44.660]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.660]             }
[10:21:44.660]             else {
[10:21:44.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.660]             }
[10:21:44.660]             {
[10:21:44.660]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.660]                   0L) {
[10:21:44.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.660]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.660]                   base::options(opts)
[10:21:44.660]                 }
[10:21:44.660]                 {
[10:21:44.660]                   {
[10:21:44.660]                     NULL
[10:21:44.660]                     RNGkind("Mersenne-Twister")
[10:21:44.660]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:44.660]                       inherits = FALSE)
[10:21:44.660]                   }
[10:21:44.660]                   options(future.plan = NULL)
[10:21:44.660]                   if (is.na(NA_character_)) 
[10:21:44.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.660]                     .init = FALSE)
[10:21:44.660]                 }
[10:21:44.660]             }
[10:21:44.660]         }
[10:21:44.660]     })
[10:21:44.660]     if (TRUE) {
[10:21:44.660]         base::sink(type = "output", split = FALSE)
[10:21:44.660]         if (TRUE) {
[10:21:44.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.660]         }
[10:21:44.660]         else {
[10:21:44.660]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.660]         }
[10:21:44.660]         base::close(...future.stdout)
[10:21:44.660]         ...future.stdout <- NULL
[10:21:44.660]     }
[10:21:44.660]     ...future.result$conditions <- ...future.conditions
[10:21:44.660]     ...future.result$finished <- base::Sys.time()
[10:21:44.660]     ...future.result
[10:21:44.660] }
[10:21:44.664] assign_globals() ...
[10:21:44.664] List of 1
[10:21:44.664]  $ pkg: chr "foo"
[10:21:44.664]  - attr(*, "where")=List of 1
[10:21:44.664]   ..$ pkg:<environment: R_EmptyEnv> 
[10:21:44.664]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.664]  - attr(*, "resolved")= logi TRUE
[10:21:44.664]  - attr(*, "total_size")= num 42
[10:21:44.668] - copied ‘pkg’ to environment
[10:21:44.668] assign_globals() ... done
[10:21:44.668] plan(): Setting new future strategy stack:
[10:21:44.668] List of future strategies:
[10:21:44.668] 1. sequential:
[10:21:44.668]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.668]    - tweaked: FALSE
[10:21:44.668]    - call: NULL
[10:21:44.669] plan(): nbrOfWorkers() = 1
[10:21:44.670] plan(): Setting new future strategy stack:
[10:21:44.670] List of future strategies:
[10:21:44.670] 1. multicore:
[10:21:44.670]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.670]    - tweaked: FALSE
[10:21:44.670]    - call: plan(strategy)
[10:21:44.672] plan(): nbrOfWorkers() = 2
[10:21:44.672] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.673] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.673] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.675] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:21:44.675] Searching for globals ... DONE
[10:21:44.675] Resolving globals: TRUE
[10:21:44.675] Resolving any globals that are futures ...
[10:21:44.676] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:21:44.676] Resolving any globals that are futures ... DONE
[10:21:44.676] 
[10:21:44.676] 
[10:21:44.676] getGlobalsAndPackages() ... DONE
[10:21:44.676] run() for ‘Future’ ...
[10:21:44.676] - state: ‘created’
[10:21:44.677] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.678] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.678] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.678]   - Field: ‘label’
[10:21:44.678]   - Field: ‘local’
[10:21:44.679]   - Field: ‘owner’
[10:21:44.679]   - Field: ‘envir’
[10:21:44.679]   - Field: ‘workers’
[10:21:44.679]   - Field: ‘packages’
[10:21:44.679]   - Field: ‘gc’
[10:21:44.679]   - Field: ‘job’
[10:21:44.679]   - Field: ‘conditions’
[10:21:44.679]   - Field: ‘expr’
[10:21:44.679]   - Field: ‘uuid’
[10:21:44.679]   - Field: ‘seed’
[10:21:44.679]   - Field: ‘version’
[10:21:44.679]   - Field: ‘result’
[10:21:44.680]   - Field: ‘asynchronous’
[10:21:44.680]   - Field: ‘calls’
[10:21:44.680]   - Field: ‘globals’
[10:21:44.680]   - Field: ‘stdout’
[10:21:44.680]   - Field: ‘earlySignal’
[10:21:44.680]   - Field: ‘lazy’
[10:21:44.680]   - Field: ‘state’
[10:21:44.680] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.680] - Launch lazy future ...
[10:21:44.681] Packages needed by the future expression (n = 0): <none>
[10:21:44.681] Packages needed by future strategies (n = 0): <none>
[10:21:44.681] {
[10:21:44.681]     {
[10:21:44.681]         {
[10:21:44.681]             ...future.startTime <- base::Sys.time()
[10:21:44.681]             {
[10:21:44.681]                 {
[10:21:44.681]                   {
[10:21:44.681]                     {
[10:21:44.681]                       base::local({
[10:21:44.681]                         has_future <- base::requireNamespace("future", 
[10:21:44.681]                           quietly = TRUE)
[10:21:44.681]                         if (has_future) {
[10:21:44.681]                           ns <- base::getNamespace("future")
[10:21:44.681]                           version <- ns[[".package"]][["version"]]
[10:21:44.681]                           if (is.null(version)) 
[10:21:44.681]                             version <- utils::packageVersion("future")
[10:21:44.681]                         }
[10:21:44.681]                         else {
[10:21:44.681]                           version <- NULL
[10:21:44.681]                         }
[10:21:44.681]                         if (!has_future || version < "1.8.0") {
[10:21:44.681]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.681]                             "", base::R.version$version.string), 
[10:21:44.681]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.681]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.681]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.681]                               "release", "version")], collapse = " "), 
[10:21:44.681]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.681]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.681]                             info)
[10:21:44.681]                           info <- base::paste(info, collapse = "; ")
[10:21:44.681]                           if (!has_future) {
[10:21:44.681]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.681]                               info)
[10:21:44.681]                           }
[10:21:44.681]                           else {
[10:21:44.681]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.681]                               info, version)
[10:21:44.681]                           }
[10:21:44.681]                           base::stop(msg)
[10:21:44.681]                         }
[10:21:44.681]                       })
[10:21:44.681]                     }
[10:21:44.681]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.681]                     base::options(mc.cores = 1L)
[10:21:44.681]                   }
[10:21:44.681]                   ...future.strategy.old <- future::plan("list")
[10:21:44.681]                   options(future.plan = NULL)
[10:21:44.681]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.681]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.681]                 }
[10:21:44.681]                 ...future.workdir <- getwd()
[10:21:44.681]             }
[10:21:44.681]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.681]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.681]         }
[10:21:44.681]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.681]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.681]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.681]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.681]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.681]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.681]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.681]             base::names(...future.oldOptions))
[10:21:44.681]     }
[10:21:44.681]     if (FALSE) {
[10:21:44.681]     }
[10:21:44.681]     else {
[10:21:44.681]         if (TRUE) {
[10:21:44.681]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.681]                 open = "w")
[10:21:44.681]         }
[10:21:44.681]         else {
[10:21:44.681]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.681]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.681]         }
[10:21:44.681]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.681]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.681]             base::sink(type = "output", split = FALSE)
[10:21:44.681]             base::close(...future.stdout)
[10:21:44.681]         }, add = TRUE)
[10:21:44.681]     }
[10:21:44.681]     ...future.frame <- base::sys.nframe()
[10:21:44.681]     ...future.conditions <- base::list()
[10:21:44.681]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.681]     if (FALSE) {
[10:21:44.681]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.681]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.681]     }
[10:21:44.681]     ...future.result <- base::tryCatch({
[10:21:44.681]         base::withCallingHandlers({
[10:21:44.681]             ...future.value <- base::withVisible(base::local({
[10:21:44.681]                 withCallingHandlers({
[10:21:44.681]                   {
[10:21:44.681]                     x <- 0
[10:21:44.681]                     x <- x + 1
[10:21:44.681]                     x
[10:21:44.681]                   }
[10:21:44.681]                 }, immediateCondition = function(cond) {
[10:21:44.681]                   save_rds <- function (object, pathname, ...) 
[10:21:44.681]                   {
[10:21:44.681]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.681]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.681]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.681]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.681]                         fi_tmp[["mtime"]])
[10:21:44.681]                     }
[10:21:44.681]                     tryCatch({
[10:21:44.681]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.681]                     }, error = function(ex) {
[10:21:44.681]                       msg <- conditionMessage(ex)
[10:21:44.681]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.681]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.681]                         fi_tmp[["mtime"]], msg)
[10:21:44.681]                       ex$message <- msg
[10:21:44.681]                       stop(ex)
[10:21:44.681]                     })
[10:21:44.681]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.681]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.681]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.681]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.681]                       fi <- file.info(pathname)
[10:21:44.681]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.681]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.681]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.681]                         fi[["size"]], fi[["mtime"]])
[10:21:44.681]                       stop(msg)
[10:21:44.681]                     }
[10:21:44.681]                     invisible(pathname)
[10:21:44.681]                   }
[10:21:44.681]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.681]                     rootPath = tempdir()) 
[10:21:44.681]                   {
[10:21:44.681]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.681]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.681]                       tmpdir = path, fileext = ".rds")
[10:21:44.681]                     save_rds(obj, file)
[10:21:44.681]                   }
[10:21:44.681]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.681]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.681]                   {
[10:21:44.681]                     inherits <- base::inherits
[10:21:44.681]                     invokeRestart <- base::invokeRestart
[10:21:44.681]                     is.null <- base::is.null
[10:21:44.681]                     muffled <- FALSE
[10:21:44.681]                     if (inherits(cond, "message")) {
[10:21:44.681]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.681]                       if (muffled) 
[10:21:44.681]                         invokeRestart("muffleMessage")
[10:21:44.681]                     }
[10:21:44.681]                     else if (inherits(cond, "warning")) {
[10:21:44.681]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.681]                       if (muffled) 
[10:21:44.681]                         invokeRestart("muffleWarning")
[10:21:44.681]                     }
[10:21:44.681]                     else if (inherits(cond, "condition")) {
[10:21:44.681]                       if (!is.null(pattern)) {
[10:21:44.681]                         computeRestarts <- base::computeRestarts
[10:21:44.681]                         grepl <- base::grepl
[10:21:44.681]                         restarts <- computeRestarts(cond)
[10:21:44.681]                         for (restart in restarts) {
[10:21:44.681]                           name <- restart$name
[10:21:44.681]                           if (is.null(name)) 
[10:21:44.681]                             next
[10:21:44.681]                           if (!grepl(pattern, name)) 
[10:21:44.681]                             next
[10:21:44.681]                           invokeRestart(restart)
[10:21:44.681]                           muffled <- TRUE
[10:21:44.681]                           break
[10:21:44.681]                         }
[10:21:44.681]                       }
[10:21:44.681]                     }
[10:21:44.681]                     invisible(muffled)
[10:21:44.681]                   }
[10:21:44.681]                   muffleCondition(cond)
[10:21:44.681]                 })
[10:21:44.681]             }))
[10:21:44.681]             future::FutureResult(value = ...future.value$value, 
[10:21:44.681]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.681]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.681]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.681]                     ...future.globalenv.names))
[10:21:44.681]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.681]         }, condition = base::local({
[10:21:44.681]             c <- base::c
[10:21:44.681]             inherits <- base::inherits
[10:21:44.681]             invokeRestart <- base::invokeRestart
[10:21:44.681]             length <- base::length
[10:21:44.681]             list <- base::list
[10:21:44.681]             seq.int <- base::seq.int
[10:21:44.681]             signalCondition <- base::signalCondition
[10:21:44.681]             sys.calls <- base::sys.calls
[10:21:44.681]             `[[` <- base::`[[`
[10:21:44.681]             `+` <- base::`+`
[10:21:44.681]             `<<-` <- base::`<<-`
[10:21:44.681]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.681]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.681]                   3L)]
[10:21:44.681]             }
[10:21:44.681]             function(cond) {
[10:21:44.681]                 is_error <- inherits(cond, "error")
[10:21:44.681]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.681]                   NULL)
[10:21:44.681]                 if (is_error) {
[10:21:44.681]                   sessionInformation <- function() {
[10:21:44.681]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.681]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.681]                       search = base::search(), system = base::Sys.info())
[10:21:44.681]                   }
[10:21:44.681]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.681]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.681]                     cond$call), session = sessionInformation(), 
[10:21:44.681]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.681]                   signalCondition(cond)
[10:21:44.681]                 }
[10:21:44.681]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.681]                 "immediateCondition"))) {
[10:21:44.681]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.681]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.681]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.681]                   if (TRUE && !signal) {
[10:21:44.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.681]                     {
[10:21:44.681]                       inherits <- base::inherits
[10:21:44.681]                       invokeRestart <- base::invokeRestart
[10:21:44.681]                       is.null <- base::is.null
[10:21:44.681]                       muffled <- FALSE
[10:21:44.681]                       if (inherits(cond, "message")) {
[10:21:44.681]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.681]                         if (muffled) 
[10:21:44.681]                           invokeRestart("muffleMessage")
[10:21:44.681]                       }
[10:21:44.681]                       else if (inherits(cond, "warning")) {
[10:21:44.681]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.681]                         if (muffled) 
[10:21:44.681]                           invokeRestart("muffleWarning")
[10:21:44.681]                       }
[10:21:44.681]                       else if (inherits(cond, "condition")) {
[10:21:44.681]                         if (!is.null(pattern)) {
[10:21:44.681]                           computeRestarts <- base::computeRestarts
[10:21:44.681]                           grepl <- base::grepl
[10:21:44.681]                           restarts <- computeRestarts(cond)
[10:21:44.681]                           for (restart in restarts) {
[10:21:44.681]                             name <- restart$name
[10:21:44.681]                             if (is.null(name)) 
[10:21:44.681]                               next
[10:21:44.681]                             if (!grepl(pattern, name)) 
[10:21:44.681]                               next
[10:21:44.681]                             invokeRestart(restart)
[10:21:44.681]                             muffled <- TRUE
[10:21:44.681]                             break
[10:21:44.681]                           }
[10:21:44.681]                         }
[10:21:44.681]                       }
[10:21:44.681]                       invisible(muffled)
[10:21:44.681]                     }
[10:21:44.681]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.681]                   }
[10:21:44.681]                 }
[10:21:44.681]                 else {
[10:21:44.681]                   if (TRUE) {
[10:21:44.681]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.681]                     {
[10:21:44.681]                       inherits <- base::inherits
[10:21:44.681]                       invokeRestart <- base::invokeRestart
[10:21:44.681]                       is.null <- base::is.null
[10:21:44.681]                       muffled <- FALSE
[10:21:44.681]                       if (inherits(cond, "message")) {
[10:21:44.681]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.681]                         if (muffled) 
[10:21:44.681]                           invokeRestart("muffleMessage")
[10:21:44.681]                       }
[10:21:44.681]                       else if (inherits(cond, "warning")) {
[10:21:44.681]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.681]                         if (muffled) 
[10:21:44.681]                           invokeRestart("muffleWarning")
[10:21:44.681]                       }
[10:21:44.681]                       else if (inherits(cond, "condition")) {
[10:21:44.681]                         if (!is.null(pattern)) {
[10:21:44.681]                           computeRestarts <- base::computeRestarts
[10:21:44.681]                           grepl <- base::grepl
[10:21:44.681]                           restarts <- computeRestarts(cond)
[10:21:44.681]                           for (restart in restarts) {
[10:21:44.681]                             name <- restart$name
[10:21:44.681]                             if (is.null(name)) 
[10:21:44.681]                               next
[10:21:44.681]                             if (!grepl(pattern, name)) 
[10:21:44.681]                               next
[10:21:44.681]                             invokeRestart(restart)
[10:21:44.681]                             muffled <- TRUE
[10:21:44.681]                             break
[10:21:44.681]                           }
[10:21:44.681]                         }
[10:21:44.681]                       }
[10:21:44.681]                       invisible(muffled)
[10:21:44.681]                     }
[10:21:44.681]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.681]                   }
[10:21:44.681]                 }
[10:21:44.681]             }
[10:21:44.681]         }))
[10:21:44.681]     }, error = function(ex) {
[10:21:44.681]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.681]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.681]                 ...future.rng), started = ...future.startTime, 
[10:21:44.681]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.681]             version = "1.8"), class = "FutureResult")
[10:21:44.681]     }, finally = {
[10:21:44.681]         if (!identical(...future.workdir, getwd())) 
[10:21:44.681]             setwd(...future.workdir)
[10:21:44.681]         {
[10:21:44.681]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.681]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.681]             }
[10:21:44.681]             base::options(...future.oldOptions)
[10:21:44.681]             if (.Platform$OS.type == "windows") {
[10:21:44.681]                 old_names <- names(...future.oldEnvVars)
[10:21:44.681]                 envs <- base::Sys.getenv()
[10:21:44.681]                 names <- names(envs)
[10:21:44.681]                 common <- intersect(names, old_names)
[10:21:44.681]                 added <- setdiff(names, old_names)
[10:21:44.681]                 removed <- setdiff(old_names, names)
[10:21:44.681]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.681]                   envs[common]]
[10:21:44.681]                 NAMES <- toupper(changed)
[10:21:44.681]                 args <- list()
[10:21:44.681]                 for (kk in seq_along(NAMES)) {
[10:21:44.681]                   name <- changed[[kk]]
[10:21:44.681]                   NAME <- NAMES[[kk]]
[10:21:44.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.681]                     next
[10:21:44.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.681]                 }
[10:21:44.681]                 NAMES <- toupper(added)
[10:21:44.681]                 for (kk in seq_along(NAMES)) {
[10:21:44.681]                   name <- added[[kk]]
[10:21:44.681]                   NAME <- NAMES[[kk]]
[10:21:44.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.681]                     next
[10:21:44.681]                   args[[name]] <- ""
[10:21:44.681]                 }
[10:21:44.681]                 NAMES <- toupper(removed)
[10:21:44.681]                 for (kk in seq_along(NAMES)) {
[10:21:44.681]                   name <- removed[[kk]]
[10:21:44.681]                   NAME <- NAMES[[kk]]
[10:21:44.681]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.681]                     next
[10:21:44.681]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.681]                 }
[10:21:44.681]                 if (length(args) > 0) 
[10:21:44.681]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.681]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.681]             }
[10:21:44.681]             else {
[10:21:44.681]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.681]             }
[10:21:44.681]             {
[10:21:44.681]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.681]                   0L) {
[10:21:44.681]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.681]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.681]                   base::options(opts)
[10:21:44.681]                 }
[10:21:44.681]                 {
[10:21:44.681]                   {
[10:21:44.681]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.681]                     NULL
[10:21:44.681]                   }
[10:21:44.681]                   options(future.plan = NULL)
[10:21:44.681]                   if (is.na(NA_character_)) 
[10:21:44.681]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.681]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.681]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.681]                     .init = FALSE)
[10:21:44.681]                 }
[10:21:44.681]             }
[10:21:44.681]         }
[10:21:44.681]     })
[10:21:44.681]     if (TRUE) {
[10:21:44.681]         base::sink(type = "output", split = FALSE)
[10:21:44.681]         if (TRUE) {
[10:21:44.681]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.681]         }
[10:21:44.681]         else {
[10:21:44.681]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.681]         }
[10:21:44.681]         base::close(...future.stdout)
[10:21:44.681]         ...future.stdout <- NULL
[10:21:44.681]     }
[10:21:44.681]     ...future.result$conditions <- ...future.conditions
[10:21:44.681]     ...future.result$finished <- base::Sys.time()
[10:21:44.681]     ...future.result
[10:21:44.681] }
[10:21:44.683] requestCore(): workers = 2
[10:21:44.685] MulticoreFuture started
[10:21:44.685] - Launch lazy future ... done
[10:21:44.686] run() for ‘MulticoreFuture’ ... done
[10:21:44.686] result() for MulticoreFuture ...
[10:21:44.686] plan(): Setting new future strategy stack:
[10:21:44.686] List of future strategies:
[10:21:44.686] 1. sequential:
[10:21:44.686]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.686]    - tweaked: FALSE
[10:21:44.686]    - call: NULL
[10:21:44.687] plan(): nbrOfWorkers() = 1
[10:21:44.689] plan(): Setting new future strategy stack:
[10:21:44.689] List of future strategies:
[10:21:44.689] 1. multicore:
[10:21:44.689]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.689]    - tweaked: FALSE
[10:21:44.689]    - call: plan(strategy)
[10:21:44.692] plan(): nbrOfWorkers() = 2
[10:21:44.693] result() for MulticoreFuture ...
[10:21:44.693] result() for MulticoreFuture ... done
[10:21:44.693] result() for MulticoreFuture ... done
[10:21:44.694] result() for MulticoreFuture ...
[10:21:44.694] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.694] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.694] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.696] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:21:44.697] Searching for globals ... DONE
[10:21:44.697] Resolving globals: TRUE
[10:21:44.697] Resolving any globals that are futures ...
[10:21:44.697] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:21:44.697] Resolving any globals that are futures ... DONE
[10:21:44.698] Resolving futures part of globals (recursively) ...
[10:21:44.700] resolve() on list ...
[10:21:44.701]  recursive: 99
[10:21:44.701]  length: 1
[10:21:44.701]  elements: ‘x’
[10:21:44.701]  length: 0 (resolved future 1)
[10:21:44.702] resolve() on list ... DONE
[10:21:44.702] - globals: [1] ‘x’
[10:21:44.702] Resolving futures part of globals (recursively) ... DONE
[10:21:44.702] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:44.703] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[10:21:44.703] - globals: [1] ‘x’
[10:21:44.703] 
[10:21:44.703] getGlobalsAndPackages() ... DONE
[10:21:44.704] run() for ‘Future’ ...
[10:21:44.704] - state: ‘created’
[10:21:44.704] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.706] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.706] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.707]   - Field: ‘label’
[10:21:44.707]   - Field: ‘local’
[10:21:44.707]   - Field: ‘owner’
[10:21:44.707]   - Field: ‘envir’
[10:21:44.707]   - Field: ‘workers’
[10:21:44.707]   - Field: ‘packages’
[10:21:44.707]   - Field: ‘gc’
[10:21:44.707]   - Field: ‘job’
[10:21:44.708]   - Field: ‘conditions’
[10:21:44.708]   - Field: ‘expr’
[10:21:44.708]   - Field: ‘uuid’
[10:21:44.708]   - Field: ‘seed’
[10:21:44.708]   - Field: ‘version’
[10:21:44.708]   - Field: ‘result’
[10:21:44.708]   - Field: ‘asynchronous’
[10:21:44.708]   - Field: ‘calls’
[10:21:44.709]   - Field: ‘globals’
[10:21:44.709]   - Field: ‘stdout’
[10:21:44.709]   - Field: ‘earlySignal’
[10:21:44.709]   - Field: ‘lazy’
[10:21:44.709]   - Field: ‘state’
[10:21:44.709] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.709] - Launch lazy future ...
[10:21:44.710] Packages needed by the future expression (n = 0): <none>
[10:21:44.710] Packages needed by future strategies (n = 0): <none>
[10:21:44.710] {
[10:21:44.710]     {
[10:21:44.710]         {
[10:21:44.710]             ...future.startTime <- base::Sys.time()
[10:21:44.710]             {
[10:21:44.710]                 {
[10:21:44.710]                   {
[10:21:44.710]                     {
[10:21:44.710]                       base::local({
[10:21:44.710]                         has_future <- base::requireNamespace("future", 
[10:21:44.710]                           quietly = TRUE)
[10:21:44.710]                         if (has_future) {
[10:21:44.710]                           ns <- base::getNamespace("future")
[10:21:44.710]                           version <- ns[[".package"]][["version"]]
[10:21:44.710]                           if (is.null(version)) 
[10:21:44.710]                             version <- utils::packageVersion("future")
[10:21:44.710]                         }
[10:21:44.710]                         else {
[10:21:44.710]                           version <- NULL
[10:21:44.710]                         }
[10:21:44.710]                         if (!has_future || version < "1.8.0") {
[10:21:44.710]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.710]                             "", base::R.version$version.string), 
[10:21:44.710]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.710]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.710]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.710]                               "release", "version")], collapse = " "), 
[10:21:44.710]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.710]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.710]                             info)
[10:21:44.710]                           info <- base::paste(info, collapse = "; ")
[10:21:44.710]                           if (!has_future) {
[10:21:44.710]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.710]                               info)
[10:21:44.710]                           }
[10:21:44.710]                           else {
[10:21:44.710]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.710]                               info, version)
[10:21:44.710]                           }
[10:21:44.710]                           base::stop(msg)
[10:21:44.710]                         }
[10:21:44.710]                       })
[10:21:44.710]                     }
[10:21:44.710]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.710]                     base::options(mc.cores = 1L)
[10:21:44.710]                   }
[10:21:44.710]                   ...future.strategy.old <- future::plan("list")
[10:21:44.710]                   options(future.plan = NULL)
[10:21:44.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.710]                 }
[10:21:44.710]                 ...future.workdir <- getwd()
[10:21:44.710]             }
[10:21:44.710]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.710]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.710]         }
[10:21:44.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.710]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.710]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.710]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.710]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.710]             base::names(...future.oldOptions))
[10:21:44.710]     }
[10:21:44.710]     if (FALSE) {
[10:21:44.710]     }
[10:21:44.710]     else {
[10:21:44.710]         if (TRUE) {
[10:21:44.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.710]                 open = "w")
[10:21:44.710]         }
[10:21:44.710]         else {
[10:21:44.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.710]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.710]         }
[10:21:44.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.710]             base::sink(type = "output", split = FALSE)
[10:21:44.710]             base::close(...future.stdout)
[10:21:44.710]         }, add = TRUE)
[10:21:44.710]     }
[10:21:44.710]     ...future.frame <- base::sys.nframe()
[10:21:44.710]     ...future.conditions <- base::list()
[10:21:44.710]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.710]     if (FALSE) {
[10:21:44.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.710]     }
[10:21:44.710]     ...future.result <- base::tryCatch({
[10:21:44.710]         base::withCallingHandlers({
[10:21:44.710]             ...future.value <- base::withVisible(base::local({
[10:21:44.710]                 withCallingHandlers({
[10:21:44.710]                   {
[10:21:44.710]                     x <- x + 1
[10:21:44.710]                     x
[10:21:44.710]                   }
[10:21:44.710]                 }, immediateCondition = function(cond) {
[10:21:44.710]                   save_rds <- function (object, pathname, ...) 
[10:21:44.710]                   {
[10:21:44.710]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.710]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.710]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.710]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.710]                         fi_tmp[["mtime"]])
[10:21:44.710]                     }
[10:21:44.710]                     tryCatch({
[10:21:44.710]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.710]                     }, error = function(ex) {
[10:21:44.710]                       msg <- conditionMessage(ex)
[10:21:44.710]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.710]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.710]                         fi_tmp[["mtime"]], msg)
[10:21:44.710]                       ex$message <- msg
[10:21:44.710]                       stop(ex)
[10:21:44.710]                     })
[10:21:44.710]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.710]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.710]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.710]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.710]                       fi <- file.info(pathname)
[10:21:44.710]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.710]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.710]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.710]                         fi[["size"]], fi[["mtime"]])
[10:21:44.710]                       stop(msg)
[10:21:44.710]                     }
[10:21:44.710]                     invisible(pathname)
[10:21:44.710]                   }
[10:21:44.710]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.710]                     rootPath = tempdir()) 
[10:21:44.710]                   {
[10:21:44.710]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.710]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.710]                       tmpdir = path, fileext = ".rds")
[10:21:44.710]                     save_rds(obj, file)
[10:21:44.710]                   }
[10:21:44.710]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.710]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.710]                   {
[10:21:44.710]                     inherits <- base::inherits
[10:21:44.710]                     invokeRestart <- base::invokeRestart
[10:21:44.710]                     is.null <- base::is.null
[10:21:44.710]                     muffled <- FALSE
[10:21:44.710]                     if (inherits(cond, "message")) {
[10:21:44.710]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.710]                       if (muffled) 
[10:21:44.710]                         invokeRestart("muffleMessage")
[10:21:44.710]                     }
[10:21:44.710]                     else if (inherits(cond, "warning")) {
[10:21:44.710]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.710]                       if (muffled) 
[10:21:44.710]                         invokeRestart("muffleWarning")
[10:21:44.710]                     }
[10:21:44.710]                     else if (inherits(cond, "condition")) {
[10:21:44.710]                       if (!is.null(pattern)) {
[10:21:44.710]                         computeRestarts <- base::computeRestarts
[10:21:44.710]                         grepl <- base::grepl
[10:21:44.710]                         restarts <- computeRestarts(cond)
[10:21:44.710]                         for (restart in restarts) {
[10:21:44.710]                           name <- restart$name
[10:21:44.710]                           if (is.null(name)) 
[10:21:44.710]                             next
[10:21:44.710]                           if (!grepl(pattern, name)) 
[10:21:44.710]                             next
[10:21:44.710]                           invokeRestart(restart)
[10:21:44.710]                           muffled <- TRUE
[10:21:44.710]                           break
[10:21:44.710]                         }
[10:21:44.710]                       }
[10:21:44.710]                     }
[10:21:44.710]                     invisible(muffled)
[10:21:44.710]                   }
[10:21:44.710]                   muffleCondition(cond)
[10:21:44.710]                 })
[10:21:44.710]             }))
[10:21:44.710]             future::FutureResult(value = ...future.value$value, 
[10:21:44.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.710]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.710]                     ...future.globalenv.names))
[10:21:44.710]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.710]         }, condition = base::local({
[10:21:44.710]             c <- base::c
[10:21:44.710]             inherits <- base::inherits
[10:21:44.710]             invokeRestart <- base::invokeRestart
[10:21:44.710]             length <- base::length
[10:21:44.710]             list <- base::list
[10:21:44.710]             seq.int <- base::seq.int
[10:21:44.710]             signalCondition <- base::signalCondition
[10:21:44.710]             sys.calls <- base::sys.calls
[10:21:44.710]             `[[` <- base::`[[`
[10:21:44.710]             `+` <- base::`+`
[10:21:44.710]             `<<-` <- base::`<<-`
[10:21:44.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.710]                   3L)]
[10:21:44.710]             }
[10:21:44.710]             function(cond) {
[10:21:44.710]                 is_error <- inherits(cond, "error")
[10:21:44.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.710]                   NULL)
[10:21:44.710]                 if (is_error) {
[10:21:44.710]                   sessionInformation <- function() {
[10:21:44.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.710]                       search = base::search(), system = base::Sys.info())
[10:21:44.710]                   }
[10:21:44.710]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.710]                     cond$call), session = sessionInformation(), 
[10:21:44.710]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.710]                   signalCondition(cond)
[10:21:44.710]                 }
[10:21:44.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.710]                 "immediateCondition"))) {
[10:21:44.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.710]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.710]                   if (TRUE && !signal) {
[10:21:44.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.710]                     {
[10:21:44.710]                       inherits <- base::inherits
[10:21:44.710]                       invokeRestart <- base::invokeRestart
[10:21:44.710]                       is.null <- base::is.null
[10:21:44.710]                       muffled <- FALSE
[10:21:44.710]                       if (inherits(cond, "message")) {
[10:21:44.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.710]                         if (muffled) 
[10:21:44.710]                           invokeRestart("muffleMessage")
[10:21:44.710]                       }
[10:21:44.710]                       else if (inherits(cond, "warning")) {
[10:21:44.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.710]                         if (muffled) 
[10:21:44.710]                           invokeRestart("muffleWarning")
[10:21:44.710]                       }
[10:21:44.710]                       else if (inherits(cond, "condition")) {
[10:21:44.710]                         if (!is.null(pattern)) {
[10:21:44.710]                           computeRestarts <- base::computeRestarts
[10:21:44.710]                           grepl <- base::grepl
[10:21:44.710]                           restarts <- computeRestarts(cond)
[10:21:44.710]                           for (restart in restarts) {
[10:21:44.710]                             name <- restart$name
[10:21:44.710]                             if (is.null(name)) 
[10:21:44.710]                               next
[10:21:44.710]                             if (!grepl(pattern, name)) 
[10:21:44.710]                               next
[10:21:44.710]                             invokeRestart(restart)
[10:21:44.710]                             muffled <- TRUE
[10:21:44.710]                             break
[10:21:44.710]                           }
[10:21:44.710]                         }
[10:21:44.710]                       }
[10:21:44.710]                       invisible(muffled)
[10:21:44.710]                     }
[10:21:44.710]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.710]                   }
[10:21:44.710]                 }
[10:21:44.710]                 else {
[10:21:44.710]                   if (TRUE) {
[10:21:44.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.710]                     {
[10:21:44.710]                       inherits <- base::inherits
[10:21:44.710]                       invokeRestart <- base::invokeRestart
[10:21:44.710]                       is.null <- base::is.null
[10:21:44.710]                       muffled <- FALSE
[10:21:44.710]                       if (inherits(cond, "message")) {
[10:21:44.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.710]                         if (muffled) 
[10:21:44.710]                           invokeRestart("muffleMessage")
[10:21:44.710]                       }
[10:21:44.710]                       else if (inherits(cond, "warning")) {
[10:21:44.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.710]                         if (muffled) 
[10:21:44.710]                           invokeRestart("muffleWarning")
[10:21:44.710]                       }
[10:21:44.710]                       else if (inherits(cond, "condition")) {
[10:21:44.710]                         if (!is.null(pattern)) {
[10:21:44.710]                           computeRestarts <- base::computeRestarts
[10:21:44.710]                           grepl <- base::grepl
[10:21:44.710]                           restarts <- computeRestarts(cond)
[10:21:44.710]                           for (restart in restarts) {
[10:21:44.710]                             name <- restart$name
[10:21:44.710]                             if (is.null(name)) 
[10:21:44.710]                               next
[10:21:44.710]                             if (!grepl(pattern, name)) 
[10:21:44.710]                               next
[10:21:44.710]                             invokeRestart(restart)
[10:21:44.710]                             muffled <- TRUE
[10:21:44.710]                             break
[10:21:44.710]                           }
[10:21:44.710]                         }
[10:21:44.710]                       }
[10:21:44.710]                       invisible(muffled)
[10:21:44.710]                     }
[10:21:44.710]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.710]                   }
[10:21:44.710]                 }
[10:21:44.710]             }
[10:21:44.710]         }))
[10:21:44.710]     }, error = function(ex) {
[10:21:44.710]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.710]                 ...future.rng), started = ...future.startTime, 
[10:21:44.710]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.710]             version = "1.8"), class = "FutureResult")
[10:21:44.710]     }, finally = {
[10:21:44.710]         if (!identical(...future.workdir, getwd())) 
[10:21:44.710]             setwd(...future.workdir)
[10:21:44.710]         {
[10:21:44.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.710]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.710]             }
[10:21:44.710]             base::options(...future.oldOptions)
[10:21:44.710]             if (.Platform$OS.type == "windows") {
[10:21:44.710]                 old_names <- names(...future.oldEnvVars)
[10:21:44.710]                 envs <- base::Sys.getenv()
[10:21:44.710]                 names <- names(envs)
[10:21:44.710]                 common <- intersect(names, old_names)
[10:21:44.710]                 added <- setdiff(names, old_names)
[10:21:44.710]                 removed <- setdiff(old_names, names)
[10:21:44.710]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.710]                   envs[common]]
[10:21:44.710]                 NAMES <- toupper(changed)
[10:21:44.710]                 args <- list()
[10:21:44.710]                 for (kk in seq_along(NAMES)) {
[10:21:44.710]                   name <- changed[[kk]]
[10:21:44.710]                   NAME <- NAMES[[kk]]
[10:21:44.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.710]                     next
[10:21:44.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.710]                 }
[10:21:44.710]                 NAMES <- toupper(added)
[10:21:44.710]                 for (kk in seq_along(NAMES)) {
[10:21:44.710]                   name <- added[[kk]]
[10:21:44.710]                   NAME <- NAMES[[kk]]
[10:21:44.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.710]                     next
[10:21:44.710]                   args[[name]] <- ""
[10:21:44.710]                 }
[10:21:44.710]                 NAMES <- toupper(removed)
[10:21:44.710]                 for (kk in seq_along(NAMES)) {
[10:21:44.710]                   name <- removed[[kk]]
[10:21:44.710]                   NAME <- NAMES[[kk]]
[10:21:44.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.710]                     next
[10:21:44.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.710]                 }
[10:21:44.710]                 if (length(args) > 0) 
[10:21:44.710]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.710]             }
[10:21:44.710]             else {
[10:21:44.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.710]             }
[10:21:44.710]             {
[10:21:44.710]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.710]                   0L) {
[10:21:44.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.710]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.710]                   base::options(opts)
[10:21:44.710]                 }
[10:21:44.710]                 {
[10:21:44.710]                   {
[10:21:44.710]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.710]                     NULL
[10:21:44.710]                   }
[10:21:44.710]                   options(future.plan = NULL)
[10:21:44.710]                   if (is.na(NA_character_)) 
[10:21:44.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.710]                     .init = FALSE)
[10:21:44.710]                 }
[10:21:44.710]             }
[10:21:44.710]         }
[10:21:44.710]     })
[10:21:44.710]     if (TRUE) {
[10:21:44.710]         base::sink(type = "output", split = FALSE)
[10:21:44.710]         if (TRUE) {
[10:21:44.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.710]         }
[10:21:44.710]         else {
[10:21:44.710]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.710]         }
[10:21:44.710]         base::close(...future.stdout)
[10:21:44.710]         ...future.stdout <- NULL
[10:21:44.710]     }
[10:21:44.710]     ...future.result$conditions <- ...future.conditions
[10:21:44.710]     ...future.result$finished <- base::Sys.time()
[10:21:44.710]     ...future.result
[10:21:44.710] }
[10:21:44.713] assign_globals() ...
[10:21:44.713] List of 1
[10:21:44.713]  $ x: num 1
[10:21:44.713]  - attr(*, "where")=List of 1
[10:21:44.713]   ..$ x:<environment: R_EmptyEnv> 
[10:21:44.713]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.713]  - attr(*, "resolved")= logi TRUE
[10:21:44.713]  - attr(*, "total_size")= num 39
[10:21:44.713]  - attr(*, "already-done")= logi TRUE
[10:21:44.716] - copied ‘x’ to environment
[10:21:44.716] assign_globals() ... done
[10:21:44.716] requestCore(): workers = 2
[10:21:44.718] MulticoreFuture started
[10:21:44.718] - Launch lazy future ... done
[10:21:44.718] run() for ‘MulticoreFuture’ ... done
[10:21:44.719] result() for MulticoreFuture ...
[10:21:44.719] plan(): Setting new future strategy stack:
[10:21:44.719] List of future strategies:
[10:21:44.719] 1. sequential:
[10:21:44.719]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.719]    - tweaked: FALSE
[10:21:44.719]    - call: NULL
[10:21:44.720] plan(): nbrOfWorkers() = 1
[10:21:44.722] plan(): Setting new future strategy stack:
[10:21:44.722] List of future strategies:
[10:21:44.722] 1. multicore:
[10:21:44.722]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.722]    - tweaked: FALSE
[10:21:44.722]    - call: plan(strategy)
[10:21:44.726] plan(): nbrOfWorkers() = 2
[10:21:44.726] result() for MulticoreFuture ...
[10:21:44.727] result() for MulticoreFuture ... done
[10:21:44.727] result() for MulticoreFuture ... done
[10:21:44.727] result() for MulticoreFuture ...
[10:21:44.727] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.728] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.728] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:44.730] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:21:44.730] Searching for globals ... DONE
[10:21:44.731] Resolving globals: TRUE
[10:21:44.731] Resolving any globals that are futures ...
[10:21:44.731] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:21:44.731] Resolving any globals that are futures ... DONE
[10:21:44.731] Resolving futures part of globals (recursively) ...
[10:21:44.732] resolve() on list ...
[10:21:44.732]  recursive: 99
[10:21:44.732]  length: 1
[10:21:44.732]  elements: ‘x’
[10:21:44.732]  length: 0 (resolved future 1)
[10:21:44.732] resolve() on list ... DONE
[10:21:44.732] - globals: [1] ‘x’
[10:21:44.733] Resolving futures part of globals (recursively) ... DONE
[10:21:44.733] The total size of the 1 globals is 260 bytes (260 bytes)
[10:21:44.733] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[10:21:44.733] - globals: [1] ‘x’
[10:21:44.733] 
[10:21:44.734] getGlobalsAndPackages() ... DONE
[10:21:44.734] run() for ‘Future’ ...
[10:21:44.734] - state: ‘created’
[10:21:44.734] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[10:21:44.736] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:44.736] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[10:21:44.737]   - Field: ‘label’
[10:21:44.737]   - Field: ‘local’
[10:21:44.737]   - Field: ‘owner’
[10:21:44.737]   - Field: ‘envir’
[10:21:44.737]   - Field: ‘workers’
[10:21:44.737]   - Field: ‘packages’
[10:21:44.737]   - Field: ‘gc’
[10:21:44.737]   - Field: ‘job’
[10:21:44.740]   - Field: ‘conditions’
[10:21:44.740]   - Field: ‘expr’
[10:21:44.740]   - Field: ‘uuid’
[10:21:44.741]   - Field: ‘seed’
[10:21:44.741]   - Field: ‘version’
[10:21:44.741]   - Field: ‘result’
[10:21:44.741]   - Field: ‘asynchronous’
[10:21:44.741]   - Field: ‘calls’
[10:21:44.741]   - Field: ‘globals’
[10:21:44.742]   - Field: ‘stdout’
[10:21:44.742]   - Field: ‘earlySignal’
[10:21:44.742]   - Field: ‘lazy’
[10:21:44.742]   - Field: ‘state’
[10:21:44.742] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[10:21:44.742] - Launch lazy future ...
[10:21:44.743] Packages needed by the future expression (n = 0): <none>
[10:21:44.743] Packages needed by future strategies (n = 0): <none>
[10:21:44.744] {
[10:21:44.744]     {
[10:21:44.744]         {
[10:21:44.744]             ...future.startTime <- base::Sys.time()
[10:21:44.744]             {
[10:21:44.744]                 {
[10:21:44.744]                   {
[10:21:44.744]                     {
[10:21:44.744]                       base::local({
[10:21:44.744]                         has_future <- base::requireNamespace("future", 
[10:21:44.744]                           quietly = TRUE)
[10:21:44.744]                         if (has_future) {
[10:21:44.744]                           ns <- base::getNamespace("future")
[10:21:44.744]                           version <- ns[[".package"]][["version"]]
[10:21:44.744]                           if (is.null(version)) 
[10:21:44.744]                             version <- utils::packageVersion("future")
[10:21:44.744]                         }
[10:21:44.744]                         else {
[10:21:44.744]                           version <- NULL
[10:21:44.744]                         }
[10:21:44.744]                         if (!has_future || version < "1.8.0") {
[10:21:44.744]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:44.744]                             "", base::R.version$version.string), 
[10:21:44.744]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:44.744]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:44.744]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:44.744]                               "release", "version")], collapse = " "), 
[10:21:44.744]                             hostname = base::Sys.info()[["nodename"]])
[10:21:44.744]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:44.744]                             info)
[10:21:44.744]                           info <- base::paste(info, collapse = "; ")
[10:21:44.744]                           if (!has_future) {
[10:21:44.744]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:44.744]                               info)
[10:21:44.744]                           }
[10:21:44.744]                           else {
[10:21:44.744]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:44.744]                               info, version)
[10:21:44.744]                           }
[10:21:44.744]                           base::stop(msg)
[10:21:44.744]                         }
[10:21:44.744]                       })
[10:21:44.744]                     }
[10:21:44.744]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:44.744]                     base::options(mc.cores = 1L)
[10:21:44.744]                   }
[10:21:44.744]                   ...future.strategy.old <- future::plan("list")
[10:21:44.744]                   options(future.plan = NULL)
[10:21:44.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:44.744]                 }
[10:21:44.744]                 ...future.workdir <- getwd()
[10:21:44.744]             }
[10:21:44.744]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:44.744]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:44.744]         }
[10:21:44.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:44.744]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:44.744]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:44.744]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:44.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:44.744]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:44.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:44.744]             base::names(...future.oldOptions))
[10:21:44.744]     }
[10:21:44.744]     if (FALSE) {
[10:21:44.744]     }
[10:21:44.744]     else {
[10:21:44.744]         if (TRUE) {
[10:21:44.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:44.744]                 open = "w")
[10:21:44.744]         }
[10:21:44.744]         else {
[10:21:44.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:44.744]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:44.744]         }
[10:21:44.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:44.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:44.744]             base::sink(type = "output", split = FALSE)
[10:21:44.744]             base::close(...future.stdout)
[10:21:44.744]         }, add = TRUE)
[10:21:44.744]     }
[10:21:44.744]     ...future.frame <- base::sys.nframe()
[10:21:44.744]     ...future.conditions <- base::list()
[10:21:44.744]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:44.744]     if (FALSE) {
[10:21:44.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:44.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:44.744]     }
[10:21:44.744]     ...future.result <- base::tryCatch({
[10:21:44.744]         base::withCallingHandlers({
[10:21:44.744]             ...future.value <- base::withVisible(base::local({
[10:21:44.744]                 withCallingHandlers({
[10:21:44.744]                   {
[10:21:44.744]                     x <- x()
[10:21:44.744]                     x
[10:21:44.744]                   }
[10:21:44.744]                 }, immediateCondition = function(cond) {
[10:21:44.744]                   save_rds <- function (object, pathname, ...) 
[10:21:44.744]                   {
[10:21:44.744]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[10:21:44.744]                     if (file_test("-f", pathname_tmp)) {
[10:21:44.744]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.744]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[10:21:44.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.744]                         fi_tmp[["mtime"]])
[10:21:44.744]                     }
[10:21:44.744]                     tryCatch({
[10:21:44.744]                       saveRDS(object, file = pathname_tmp, ...)
[10:21:44.744]                     }, error = function(ex) {
[10:21:44.744]                       msg <- conditionMessage(ex)
[10:21:44.744]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.744]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[10:21:44.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.744]                         fi_tmp[["mtime"]], msg)
[10:21:44.744]                       ex$message <- msg
[10:21:44.744]                       stop(ex)
[10:21:44.744]                     })
[10:21:44.744]                     stopifnot(file_test("-f", pathname_tmp))
[10:21:44.744]                     res <- file.rename(from = pathname_tmp, to = pathname)
[10:21:44.744]                     if (!res || file_test("-f", pathname_tmp)) {
[10:21:44.744]                       fi_tmp <- file.info(pathname_tmp)
[10:21:44.744]                       fi <- file.info(pathname)
[10:21:44.744]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[10:21:44.744]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[10:21:44.744]                         fi_tmp[["mtime"]], sQuote(pathname), 
[10:21:44.744]                         fi[["size"]], fi[["mtime"]])
[10:21:44.744]                       stop(msg)
[10:21:44.744]                     }
[10:21:44.744]                     invisible(pathname)
[10:21:44.744]                   }
[10:21:44.744]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[10:21:44.744]                     rootPath = tempdir()) 
[10:21:44.744]                   {
[10:21:44.744]                     obj <- list(time = Sys.time(), condition = cond)
[10:21:44.744]                     file <- tempfile(pattern = class(cond)[1], 
[10:21:44.744]                       tmpdir = path, fileext = ".rds")
[10:21:44.744]                     save_rds(obj, file)
[10:21:44.744]                   }
[10:21:44.744]                   saveImmediateCondition(cond, path = "/tmp/RtmpKDEUCG/.future/immediateConditions")
[10:21:44.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.744]                   {
[10:21:44.744]                     inherits <- base::inherits
[10:21:44.744]                     invokeRestart <- base::invokeRestart
[10:21:44.744]                     is.null <- base::is.null
[10:21:44.744]                     muffled <- FALSE
[10:21:44.744]                     if (inherits(cond, "message")) {
[10:21:44.744]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:44.744]                       if (muffled) 
[10:21:44.744]                         invokeRestart("muffleMessage")
[10:21:44.744]                     }
[10:21:44.744]                     else if (inherits(cond, "warning")) {
[10:21:44.744]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:44.744]                       if (muffled) 
[10:21:44.744]                         invokeRestart("muffleWarning")
[10:21:44.744]                     }
[10:21:44.744]                     else if (inherits(cond, "condition")) {
[10:21:44.744]                       if (!is.null(pattern)) {
[10:21:44.744]                         computeRestarts <- base::computeRestarts
[10:21:44.744]                         grepl <- base::grepl
[10:21:44.744]                         restarts <- computeRestarts(cond)
[10:21:44.744]                         for (restart in restarts) {
[10:21:44.744]                           name <- restart$name
[10:21:44.744]                           if (is.null(name)) 
[10:21:44.744]                             next
[10:21:44.744]                           if (!grepl(pattern, name)) 
[10:21:44.744]                             next
[10:21:44.744]                           invokeRestart(restart)
[10:21:44.744]                           muffled <- TRUE
[10:21:44.744]                           break
[10:21:44.744]                         }
[10:21:44.744]                       }
[10:21:44.744]                     }
[10:21:44.744]                     invisible(muffled)
[10:21:44.744]                   }
[10:21:44.744]                   muffleCondition(cond)
[10:21:44.744]                 })
[10:21:44.744]             }))
[10:21:44.744]             future::FutureResult(value = ...future.value$value, 
[10:21:44.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.744]                   ...future.rng), globalenv = if (FALSE) 
[10:21:44.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:44.744]                     ...future.globalenv.names))
[10:21:44.744]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:44.744]         }, condition = base::local({
[10:21:44.744]             c <- base::c
[10:21:44.744]             inherits <- base::inherits
[10:21:44.744]             invokeRestart <- base::invokeRestart
[10:21:44.744]             length <- base::length
[10:21:44.744]             list <- base::list
[10:21:44.744]             seq.int <- base::seq.int
[10:21:44.744]             signalCondition <- base::signalCondition
[10:21:44.744]             sys.calls <- base::sys.calls
[10:21:44.744]             `[[` <- base::`[[`
[10:21:44.744]             `+` <- base::`+`
[10:21:44.744]             `<<-` <- base::`<<-`
[10:21:44.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:44.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:44.744]                   3L)]
[10:21:44.744]             }
[10:21:44.744]             function(cond) {
[10:21:44.744]                 is_error <- inherits(cond, "error")
[10:21:44.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:44.744]                   NULL)
[10:21:44.744]                 if (is_error) {
[10:21:44.744]                   sessionInformation <- function() {
[10:21:44.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:44.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:44.744]                       search = base::search(), system = base::Sys.info())
[10:21:44.744]                   }
[10:21:44.744]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:44.744]                     cond$call), session = sessionInformation(), 
[10:21:44.744]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:44.744]                   signalCondition(cond)
[10:21:44.744]                 }
[10:21:44.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:44.744]                 "immediateCondition"))) {
[10:21:44.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:44.744]                   ...future.conditions[[length(...future.conditions) + 
[10:21:44.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:44.744]                   if (TRUE && !signal) {
[10:21:44.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.744]                     {
[10:21:44.744]                       inherits <- base::inherits
[10:21:44.744]                       invokeRestart <- base::invokeRestart
[10:21:44.744]                       is.null <- base::is.null
[10:21:44.744]                       muffled <- FALSE
[10:21:44.744]                       if (inherits(cond, "message")) {
[10:21:44.744]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.744]                         if (muffled) 
[10:21:44.744]                           invokeRestart("muffleMessage")
[10:21:44.744]                       }
[10:21:44.744]                       else if (inherits(cond, "warning")) {
[10:21:44.744]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.744]                         if (muffled) 
[10:21:44.744]                           invokeRestart("muffleWarning")
[10:21:44.744]                       }
[10:21:44.744]                       else if (inherits(cond, "condition")) {
[10:21:44.744]                         if (!is.null(pattern)) {
[10:21:44.744]                           computeRestarts <- base::computeRestarts
[10:21:44.744]                           grepl <- base::grepl
[10:21:44.744]                           restarts <- computeRestarts(cond)
[10:21:44.744]                           for (restart in restarts) {
[10:21:44.744]                             name <- restart$name
[10:21:44.744]                             if (is.null(name)) 
[10:21:44.744]                               next
[10:21:44.744]                             if (!grepl(pattern, name)) 
[10:21:44.744]                               next
[10:21:44.744]                             invokeRestart(restart)
[10:21:44.744]                             muffled <- TRUE
[10:21:44.744]                             break
[10:21:44.744]                           }
[10:21:44.744]                         }
[10:21:44.744]                       }
[10:21:44.744]                       invisible(muffled)
[10:21:44.744]                     }
[10:21:44.744]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.744]                   }
[10:21:44.744]                 }
[10:21:44.744]                 else {
[10:21:44.744]                   if (TRUE) {
[10:21:44.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:44.744]                     {
[10:21:44.744]                       inherits <- base::inherits
[10:21:44.744]                       invokeRestart <- base::invokeRestart
[10:21:44.744]                       is.null <- base::is.null
[10:21:44.744]                       muffled <- FALSE
[10:21:44.744]                       if (inherits(cond, "message")) {
[10:21:44.744]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:44.744]                         if (muffled) 
[10:21:44.744]                           invokeRestart("muffleMessage")
[10:21:44.744]                       }
[10:21:44.744]                       else if (inherits(cond, "warning")) {
[10:21:44.744]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:44.744]                         if (muffled) 
[10:21:44.744]                           invokeRestart("muffleWarning")
[10:21:44.744]                       }
[10:21:44.744]                       else if (inherits(cond, "condition")) {
[10:21:44.744]                         if (!is.null(pattern)) {
[10:21:44.744]                           computeRestarts <- base::computeRestarts
[10:21:44.744]                           grepl <- base::grepl
[10:21:44.744]                           restarts <- computeRestarts(cond)
[10:21:44.744]                           for (restart in restarts) {
[10:21:44.744]                             name <- restart$name
[10:21:44.744]                             if (is.null(name)) 
[10:21:44.744]                               next
[10:21:44.744]                             if (!grepl(pattern, name)) 
[10:21:44.744]                               next
[10:21:44.744]                             invokeRestart(restart)
[10:21:44.744]                             muffled <- TRUE
[10:21:44.744]                             break
[10:21:44.744]                           }
[10:21:44.744]                         }
[10:21:44.744]                       }
[10:21:44.744]                       invisible(muffled)
[10:21:44.744]                     }
[10:21:44.744]                     muffleCondition(cond, pattern = "^muffle")
[10:21:44.744]                   }
[10:21:44.744]                 }
[10:21:44.744]             }
[10:21:44.744]         }))
[10:21:44.744]     }, error = function(ex) {
[10:21:44.744]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:44.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:44.744]                 ...future.rng), started = ...future.startTime, 
[10:21:44.744]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:44.744]             version = "1.8"), class = "FutureResult")
[10:21:44.744]     }, finally = {
[10:21:44.744]         if (!identical(...future.workdir, getwd())) 
[10:21:44.744]             setwd(...future.workdir)
[10:21:44.744]         {
[10:21:44.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:44.744]                 ...future.oldOptions$nwarnings <- NULL
[10:21:44.744]             }
[10:21:44.744]             base::options(...future.oldOptions)
[10:21:44.744]             if (.Platform$OS.type == "windows") {
[10:21:44.744]                 old_names <- names(...future.oldEnvVars)
[10:21:44.744]                 envs <- base::Sys.getenv()
[10:21:44.744]                 names <- names(envs)
[10:21:44.744]                 common <- intersect(names, old_names)
[10:21:44.744]                 added <- setdiff(names, old_names)
[10:21:44.744]                 removed <- setdiff(old_names, names)
[10:21:44.744]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:44.744]                   envs[common]]
[10:21:44.744]                 NAMES <- toupper(changed)
[10:21:44.744]                 args <- list()
[10:21:44.744]                 for (kk in seq_along(NAMES)) {
[10:21:44.744]                   name <- changed[[kk]]
[10:21:44.744]                   NAME <- NAMES[[kk]]
[10:21:44.744]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.744]                     next
[10:21:44.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.744]                 }
[10:21:44.744]                 NAMES <- toupper(added)
[10:21:44.744]                 for (kk in seq_along(NAMES)) {
[10:21:44.744]                   name <- added[[kk]]
[10:21:44.744]                   NAME <- NAMES[[kk]]
[10:21:44.744]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.744]                     next
[10:21:44.744]                   args[[name]] <- ""
[10:21:44.744]                 }
[10:21:44.744]                 NAMES <- toupper(removed)
[10:21:44.744]                 for (kk in seq_along(NAMES)) {
[10:21:44.744]                   name <- removed[[kk]]
[10:21:44.744]                   NAME <- NAMES[[kk]]
[10:21:44.744]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:44.744]                     next
[10:21:44.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:44.744]                 }
[10:21:44.744]                 if (length(args) > 0) 
[10:21:44.744]                   base::do.call(base::Sys.setenv, args = args)
[10:21:44.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:44.744]             }
[10:21:44.744]             else {
[10:21:44.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:44.744]             }
[10:21:44.744]             {
[10:21:44.744]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:44.744]                   0L) {
[10:21:44.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:44.744]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:44.744]                   base::options(opts)
[10:21:44.744]                 }
[10:21:44.744]                 {
[10:21:44.744]                   {
[10:21:44.744]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:44.744]                     NULL
[10:21:44.744]                   }
[10:21:44.744]                   options(future.plan = NULL)
[10:21:44.744]                   if (is.na(NA_character_)) 
[10:21:44.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:44.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:44.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:44.744]                     .init = FALSE)
[10:21:44.744]                 }
[10:21:44.744]             }
[10:21:44.744]         }
[10:21:44.744]     })
[10:21:44.744]     if (TRUE) {
[10:21:44.744]         base::sink(type = "output", split = FALSE)
[10:21:44.744]         if (TRUE) {
[10:21:44.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:44.744]         }
[10:21:44.744]         else {
[10:21:44.744]             ...future.result["stdout"] <- base::list(NULL)
[10:21:44.744]         }
[10:21:44.744]         base::close(...future.stdout)
[10:21:44.744]         ...future.stdout <- NULL
[10:21:44.744]     }
[10:21:44.744]     ...future.result$conditions <- ...future.conditions
[10:21:44.744]     ...future.result$finished <- base::Sys.time()
[10:21:44.744]     ...future.result
[10:21:44.744] }
[10:21:44.746] assign_globals() ...
[10:21:44.746] List of 1
[10:21:44.746]  $ x:function ()  
[10:21:44.746]  - attr(*, "where")=List of 1
[10:21:44.746]   ..$ x:<environment: R_EmptyEnv> 
[10:21:44.746]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:44.746]  - attr(*, "resolved")= logi TRUE
[10:21:44.746]  - attr(*, "total_size")= num 260
[10:21:44.746]  - attr(*, "already-done")= logi TRUE
[10:21:44.750] - reassign environment for ‘x’
[10:21:44.750] - copied ‘x’ to environment
[10:21:44.750] assign_globals() ... done
[10:21:44.750] requestCore(): workers = 2
[10:21:44.753] MulticoreFuture started
[10:21:44.753] - Launch lazy future ... done
[10:21:44.753] run() for ‘MulticoreFuture’ ... done
[10:21:44.754] result() for MulticoreFuture ...
[10:21:44.754] plan(): Setting new future strategy stack:
[10:21:44.754] List of future strategies:
[10:21:44.754] 1. sequential:
[10:21:44.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:44.754]    - tweaked: FALSE
[10:21:44.754]    - call: NULL
[10:21:44.755] plan(): nbrOfWorkers() = 1
[10:21:44.757] plan(): Setting new future strategy stack:
[10:21:44.758] List of future strategies:
[10:21:44.758] 1. multicore:
[10:21:44.758]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[10:21:44.758]    - tweaked: FALSE
[10:21:44.758]    - call: plan(strategy)
[10:21:44.761] plan(): nbrOfWorkers() = 2
[10:21:44.762] result() for MulticoreFuture ...
[10:21:44.762] result() for MulticoreFuture ... done
[10:21:44.762] result() for MulticoreFuture ... done
[10:21:44.762] result() for MulticoreFuture ...
[10:21:44.763] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[10:21:44.763] plan(): Setting new future strategy stack:
[10:21:44.763] List of future strategies:
[10:21:44.763] 1. multisession:
[10:21:44.763]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:44.763]    - tweaked: FALSE
[10:21:44.763]    - call: plan(strategy)
[10:21:44.764] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:44.764] multisession:
[10:21:44.764] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:44.764] - tweaked: FALSE
[10:21:44.764] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:44.770] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:44.770] Not searching for globals
[10:21:44.770] - globals: [0] <none>
[10:21:44.770] getGlobalsAndPackages() ... DONE
[10:21:45.264] Packages needed by the future expression (n = 0): <none>
[10:21:45.264] Packages needed by future strategies (n = 0): <none>
[10:21:45.265] {
[10:21:45.265]     {
[10:21:45.265]         {
[10:21:45.265]             ...future.startTime <- base::Sys.time()
[10:21:45.265]             {
[10:21:45.265]                 {
[10:21:45.265]                   {
[10:21:45.265]                     {
[10:21:45.265]                       base::local({
[10:21:45.265]                         has_future <- base::requireNamespace("future", 
[10:21:45.265]                           quietly = TRUE)
[10:21:45.265]                         if (has_future) {
[10:21:45.265]                           ns <- base::getNamespace("future")
[10:21:45.265]                           version <- ns[[".package"]][["version"]]
[10:21:45.265]                           if (is.null(version)) 
[10:21:45.265]                             version <- utils::packageVersion("future")
[10:21:45.265]                         }
[10:21:45.265]                         else {
[10:21:45.265]                           version <- NULL
[10:21:45.265]                         }
[10:21:45.265]                         if (!has_future || version < "1.8.0") {
[10:21:45.265]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.265]                             "", base::R.version$version.string), 
[10:21:45.265]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.265]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.265]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.265]                               "release", "version")], collapse = " "), 
[10:21:45.265]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.265]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.265]                             info)
[10:21:45.265]                           info <- base::paste(info, collapse = "; ")
[10:21:45.265]                           if (!has_future) {
[10:21:45.265]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.265]                               info)
[10:21:45.265]                           }
[10:21:45.265]                           else {
[10:21:45.265]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.265]                               info, version)
[10:21:45.265]                           }
[10:21:45.265]                           base::stop(msg)
[10:21:45.265]                         }
[10:21:45.265]                       })
[10:21:45.265]                     }
[10:21:45.265]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.265]                     base::options(mc.cores = 1L)
[10:21:45.265]                   }
[10:21:45.265]                   ...future.strategy.old <- future::plan("list")
[10:21:45.265]                   options(future.plan = NULL)
[10:21:45.265]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.265]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.265]                 }
[10:21:45.265]                 ...future.workdir <- getwd()
[10:21:45.265]             }
[10:21:45.265]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.265]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.265]         }
[10:21:45.265]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.265]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:45.265]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.265]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.265]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.265]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.265]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.265]             base::names(...future.oldOptions))
[10:21:45.265]     }
[10:21:45.265]     if (FALSE) {
[10:21:45.265]     }
[10:21:45.265]     else {
[10:21:45.265]         if (TRUE) {
[10:21:45.265]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.265]                 open = "w")
[10:21:45.265]         }
[10:21:45.265]         else {
[10:21:45.265]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.265]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.265]         }
[10:21:45.265]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.265]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.265]             base::sink(type = "output", split = FALSE)
[10:21:45.265]             base::close(...future.stdout)
[10:21:45.265]         }, add = TRUE)
[10:21:45.265]     }
[10:21:45.265]     ...future.frame <- base::sys.nframe()
[10:21:45.265]     ...future.conditions <- base::list()
[10:21:45.265]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.265]     if (FALSE) {
[10:21:45.265]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.265]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.265]     }
[10:21:45.265]     ...future.result <- base::tryCatch({
[10:21:45.265]         base::withCallingHandlers({
[10:21:45.265]             ...future.value <- base::withVisible(base::local({
[10:21:45.265]                 ...future.makeSendCondition <- base::local({
[10:21:45.265]                   sendCondition <- NULL
[10:21:45.265]                   function(frame = 1L) {
[10:21:45.265]                     if (is.function(sendCondition)) 
[10:21:45.265]                       return(sendCondition)
[10:21:45.265]                     ns <- getNamespace("parallel")
[10:21:45.265]                     if (exists("sendData", mode = "function", 
[10:21:45.265]                       envir = ns)) {
[10:21:45.265]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.265]                         envir = ns)
[10:21:45.265]                       envir <- sys.frame(frame)
[10:21:45.265]                       master <- NULL
[10:21:45.265]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.265]                         !identical(envir, emptyenv())) {
[10:21:45.265]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.265]                           inherits = FALSE)) {
[10:21:45.265]                           master <- get("master", mode = "list", 
[10:21:45.265]                             envir = envir, inherits = FALSE)
[10:21:45.265]                           if (inherits(master, c("SOCKnode", 
[10:21:45.265]                             "SOCK0node"))) {
[10:21:45.265]                             sendCondition <<- function(cond) {
[10:21:45.265]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.265]                                 success = TRUE)
[10:21:45.265]                               parallel_sendData(master, data)
[10:21:45.265]                             }
[10:21:45.265]                             return(sendCondition)
[10:21:45.265]                           }
[10:21:45.265]                         }
[10:21:45.265]                         frame <- frame + 1L
[10:21:45.265]                         envir <- sys.frame(frame)
[10:21:45.265]                       }
[10:21:45.265]                     }
[10:21:45.265]                     sendCondition <<- function(cond) NULL
[10:21:45.265]                   }
[10:21:45.265]                 })
[10:21:45.265]                 withCallingHandlers({
[10:21:45.265]                   NA
[10:21:45.265]                 }, immediateCondition = function(cond) {
[10:21:45.265]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.265]                   sendCondition(cond)
[10:21:45.265]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.265]                   {
[10:21:45.265]                     inherits <- base::inherits
[10:21:45.265]                     invokeRestart <- base::invokeRestart
[10:21:45.265]                     is.null <- base::is.null
[10:21:45.265]                     muffled <- FALSE
[10:21:45.265]                     if (inherits(cond, "message")) {
[10:21:45.265]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.265]                       if (muffled) 
[10:21:45.265]                         invokeRestart("muffleMessage")
[10:21:45.265]                     }
[10:21:45.265]                     else if (inherits(cond, "warning")) {
[10:21:45.265]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.265]                       if (muffled) 
[10:21:45.265]                         invokeRestart("muffleWarning")
[10:21:45.265]                     }
[10:21:45.265]                     else if (inherits(cond, "condition")) {
[10:21:45.265]                       if (!is.null(pattern)) {
[10:21:45.265]                         computeRestarts <- base::computeRestarts
[10:21:45.265]                         grepl <- base::grepl
[10:21:45.265]                         restarts <- computeRestarts(cond)
[10:21:45.265]                         for (restart in restarts) {
[10:21:45.265]                           name <- restart$name
[10:21:45.265]                           if (is.null(name)) 
[10:21:45.265]                             next
[10:21:45.265]                           if (!grepl(pattern, name)) 
[10:21:45.265]                             next
[10:21:45.265]                           invokeRestart(restart)
[10:21:45.265]                           muffled <- TRUE
[10:21:45.265]                           break
[10:21:45.265]                         }
[10:21:45.265]                       }
[10:21:45.265]                     }
[10:21:45.265]                     invisible(muffled)
[10:21:45.265]                   }
[10:21:45.265]                   muffleCondition(cond)
[10:21:45.265]                 })
[10:21:45.265]             }))
[10:21:45.265]             future::FutureResult(value = ...future.value$value, 
[10:21:45.265]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.265]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.265]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.265]                     ...future.globalenv.names))
[10:21:45.265]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.265]         }, condition = base::local({
[10:21:45.265]             c <- base::c
[10:21:45.265]             inherits <- base::inherits
[10:21:45.265]             invokeRestart <- base::invokeRestart
[10:21:45.265]             length <- base::length
[10:21:45.265]             list <- base::list
[10:21:45.265]             seq.int <- base::seq.int
[10:21:45.265]             signalCondition <- base::signalCondition
[10:21:45.265]             sys.calls <- base::sys.calls
[10:21:45.265]             `[[` <- base::`[[`
[10:21:45.265]             `+` <- base::`+`
[10:21:45.265]             `<<-` <- base::`<<-`
[10:21:45.265]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.265]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.265]                   3L)]
[10:21:45.265]             }
[10:21:45.265]             function(cond) {
[10:21:45.265]                 is_error <- inherits(cond, "error")
[10:21:45.265]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.265]                   NULL)
[10:21:45.265]                 if (is_error) {
[10:21:45.265]                   sessionInformation <- function() {
[10:21:45.265]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.265]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.265]                       search = base::search(), system = base::Sys.info())
[10:21:45.265]                   }
[10:21:45.265]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.265]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.265]                     cond$call), session = sessionInformation(), 
[10:21:45.265]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.265]                   signalCondition(cond)
[10:21:45.265]                 }
[10:21:45.265]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.265]                 "immediateCondition"))) {
[10:21:45.265]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.265]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.265]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.265]                   if (TRUE && !signal) {
[10:21:45.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.265]                     {
[10:21:45.265]                       inherits <- base::inherits
[10:21:45.265]                       invokeRestart <- base::invokeRestart
[10:21:45.265]                       is.null <- base::is.null
[10:21:45.265]                       muffled <- FALSE
[10:21:45.265]                       if (inherits(cond, "message")) {
[10:21:45.265]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.265]                         if (muffled) 
[10:21:45.265]                           invokeRestart("muffleMessage")
[10:21:45.265]                       }
[10:21:45.265]                       else if (inherits(cond, "warning")) {
[10:21:45.265]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.265]                         if (muffled) 
[10:21:45.265]                           invokeRestart("muffleWarning")
[10:21:45.265]                       }
[10:21:45.265]                       else if (inherits(cond, "condition")) {
[10:21:45.265]                         if (!is.null(pattern)) {
[10:21:45.265]                           computeRestarts <- base::computeRestarts
[10:21:45.265]                           grepl <- base::grepl
[10:21:45.265]                           restarts <- computeRestarts(cond)
[10:21:45.265]                           for (restart in restarts) {
[10:21:45.265]                             name <- restart$name
[10:21:45.265]                             if (is.null(name)) 
[10:21:45.265]                               next
[10:21:45.265]                             if (!grepl(pattern, name)) 
[10:21:45.265]                               next
[10:21:45.265]                             invokeRestart(restart)
[10:21:45.265]                             muffled <- TRUE
[10:21:45.265]                             break
[10:21:45.265]                           }
[10:21:45.265]                         }
[10:21:45.265]                       }
[10:21:45.265]                       invisible(muffled)
[10:21:45.265]                     }
[10:21:45.265]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.265]                   }
[10:21:45.265]                 }
[10:21:45.265]                 else {
[10:21:45.265]                   if (TRUE) {
[10:21:45.265]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.265]                     {
[10:21:45.265]                       inherits <- base::inherits
[10:21:45.265]                       invokeRestart <- base::invokeRestart
[10:21:45.265]                       is.null <- base::is.null
[10:21:45.265]                       muffled <- FALSE
[10:21:45.265]                       if (inherits(cond, "message")) {
[10:21:45.265]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.265]                         if (muffled) 
[10:21:45.265]                           invokeRestart("muffleMessage")
[10:21:45.265]                       }
[10:21:45.265]                       else if (inherits(cond, "warning")) {
[10:21:45.265]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.265]                         if (muffled) 
[10:21:45.265]                           invokeRestart("muffleWarning")
[10:21:45.265]                       }
[10:21:45.265]                       else if (inherits(cond, "condition")) {
[10:21:45.265]                         if (!is.null(pattern)) {
[10:21:45.265]                           computeRestarts <- base::computeRestarts
[10:21:45.265]                           grepl <- base::grepl
[10:21:45.265]                           restarts <- computeRestarts(cond)
[10:21:45.265]                           for (restart in restarts) {
[10:21:45.265]                             name <- restart$name
[10:21:45.265]                             if (is.null(name)) 
[10:21:45.265]                               next
[10:21:45.265]                             if (!grepl(pattern, name)) 
[10:21:45.265]                               next
[10:21:45.265]                             invokeRestart(restart)
[10:21:45.265]                             muffled <- TRUE
[10:21:45.265]                             break
[10:21:45.265]                           }
[10:21:45.265]                         }
[10:21:45.265]                       }
[10:21:45.265]                       invisible(muffled)
[10:21:45.265]                     }
[10:21:45.265]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.265]                   }
[10:21:45.265]                 }
[10:21:45.265]             }
[10:21:45.265]         }))
[10:21:45.265]     }, error = function(ex) {
[10:21:45.265]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.265]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.265]                 ...future.rng), started = ...future.startTime, 
[10:21:45.265]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.265]             version = "1.8"), class = "FutureResult")
[10:21:45.265]     }, finally = {
[10:21:45.265]         if (!identical(...future.workdir, getwd())) 
[10:21:45.265]             setwd(...future.workdir)
[10:21:45.265]         {
[10:21:45.265]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.265]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.265]             }
[10:21:45.265]             base::options(...future.oldOptions)
[10:21:45.265]             if (.Platform$OS.type == "windows") {
[10:21:45.265]                 old_names <- names(...future.oldEnvVars)
[10:21:45.265]                 envs <- base::Sys.getenv()
[10:21:45.265]                 names <- names(envs)
[10:21:45.265]                 common <- intersect(names, old_names)
[10:21:45.265]                 added <- setdiff(names, old_names)
[10:21:45.265]                 removed <- setdiff(old_names, names)
[10:21:45.265]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.265]                   envs[common]]
[10:21:45.265]                 NAMES <- toupper(changed)
[10:21:45.265]                 args <- list()
[10:21:45.265]                 for (kk in seq_along(NAMES)) {
[10:21:45.265]                   name <- changed[[kk]]
[10:21:45.265]                   NAME <- NAMES[[kk]]
[10:21:45.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.265]                     next
[10:21:45.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.265]                 }
[10:21:45.265]                 NAMES <- toupper(added)
[10:21:45.265]                 for (kk in seq_along(NAMES)) {
[10:21:45.265]                   name <- added[[kk]]
[10:21:45.265]                   NAME <- NAMES[[kk]]
[10:21:45.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.265]                     next
[10:21:45.265]                   args[[name]] <- ""
[10:21:45.265]                 }
[10:21:45.265]                 NAMES <- toupper(removed)
[10:21:45.265]                 for (kk in seq_along(NAMES)) {
[10:21:45.265]                   name <- removed[[kk]]
[10:21:45.265]                   NAME <- NAMES[[kk]]
[10:21:45.265]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.265]                     next
[10:21:45.265]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.265]                 }
[10:21:45.265]                 if (length(args) > 0) 
[10:21:45.265]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.265]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.265]             }
[10:21:45.265]             else {
[10:21:45.265]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.265]             }
[10:21:45.265]             {
[10:21:45.265]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.265]                   0L) {
[10:21:45.265]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.265]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.265]                   base::options(opts)
[10:21:45.265]                 }
[10:21:45.265]                 {
[10:21:45.265]                   {
[10:21:45.265]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.265]                     NULL
[10:21:45.265]                   }
[10:21:45.265]                   options(future.plan = NULL)
[10:21:45.265]                   if (is.na(NA_character_)) 
[10:21:45.265]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.265]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.265]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.265]                     .init = FALSE)
[10:21:45.265]                 }
[10:21:45.265]             }
[10:21:45.265]         }
[10:21:45.265]     })
[10:21:45.265]     if (TRUE) {
[10:21:45.265]         base::sink(type = "output", split = FALSE)
[10:21:45.265]         if (TRUE) {
[10:21:45.265]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.265]         }
[10:21:45.265]         else {
[10:21:45.265]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.265]         }
[10:21:45.265]         base::close(...future.stdout)
[10:21:45.265]         ...future.stdout <- NULL
[10:21:45.265]     }
[10:21:45.265]     ...future.result$conditions <- ...future.conditions
[10:21:45.265]     ...future.result$finished <- base::Sys.time()
[10:21:45.265]     ...future.result
[10:21:45.265] }
[10:21:45.320] MultisessionFuture started
[10:21:45.320] result() for ClusterFuture ...
[10:21:45.321] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.321] - Validating connection of MultisessionFuture
[10:21:45.352] - received message: FutureResult
[10:21:45.352] - Received FutureResult
[10:21:45.352] - Erased future from FutureRegistry
[10:21:45.352] result() for ClusterFuture ...
[10:21:45.352] - result already collected: FutureResult
[10:21:45.352] result() for ClusterFuture ... done
[10:21:45.353] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:45.353] result() for ClusterFuture ... done
[10:21:45.353] result() for ClusterFuture ...
[10:21:45.353] - result already collected: FutureResult
[10:21:45.353] result() for ClusterFuture ... done
[10:21:45.353] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:45.355] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.355] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.355] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.357] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:21:45.357] Searching for globals ... DONE
[10:21:45.357] Resolving globals: TRUE
[10:21:45.357] Resolving any globals that are futures ...
[10:21:45.357] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:21:45.357] Resolving any globals that are futures ... DONE
[10:21:45.357] 
[10:21:45.358] 
[10:21:45.358] getGlobalsAndPackages() ... DONE
[10:21:45.358] run() for ‘Future’ ...
[10:21:45.358] - state: ‘created’
[10:21:45.358] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.372] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.372] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.372]   - Field: ‘node’
[10:21:45.373]   - Field: ‘label’
[10:21:45.373]   - Field: ‘local’
[10:21:45.373]   - Field: ‘owner’
[10:21:45.373]   - Field: ‘envir’
[10:21:45.373]   - Field: ‘workers’
[10:21:45.373]   - Field: ‘packages’
[10:21:45.373]   - Field: ‘gc’
[10:21:45.373]   - Field: ‘conditions’
[10:21:45.373]   - Field: ‘persistent’
[10:21:45.373]   - Field: ‘expr’
[10:21:45.373]   - Field: ‘uuid’
[10:21:45.373]   - Field: ‘seed’
[10:21:45.374]   - Field: ‘version’
[10:21:45.374]   - Field: ‘result’
[10:21:45.374]   - Field: ‘asynchronous’
[10:21:45.374]   - Field: ‘calls’
[10:21:45.374]   - Field: ‘globals’
[10:21:45.374]   - Field: ‘stdout’
[10:21:45.374]   - Field: ‘earlySignal’
[10:21:45.374]   - Field: ‘lazy’
[10:21:45.374]   - Field: ‘state’
[10:21:45.374] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.374] - Launch lazy future ...
[10:21:45.375] Packages needed by the future expression (n = 0): <none>
[10:21:45.375] Packages needed by future strategies (n = 0): <none>
[10:21:45.375] {
[10:21:45.375]     {
[10:21:45.375]         {
[10:21:45.375]             ...future.startTime <- base::Sys.time()
[10:21:45.375]             {
[10:21:45.375]                 {
[10:21:45.375]                   {
[10:21:45.375]                     {
[10:21:45.375]                       base::local({
[10:21:45.375]                         has_future <- base::requireNamespace("future", 
[10:21:45.375]                           quietly = TRUE)
[10:21:45.375]                         if (has_future) {
[10:21:45.375]                           ns <- base::getNamespace("future")
[10:21:45.375]                           version <- ns[[".package"]][["version"]]
[10:21:45.375]                           if (is.null(version)) 
[10:21:45.375]                             version <- utils::packageVersion("future")
[10:21:45.375]                         }
[10:21:45.375]                         else {
[10:21:45.375]                           version <- NULL
[10:21:45.375]                         }
[10:21:45.375]                         if (!has_future || version < "1.8.0") {
[10:21:45.375]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.375]                             "", base::R.version$version.string), 
[10:21:45.375]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.375]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.375]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.375]                               "release", "version")], collapse = " "), 
[10:21:45.375]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.375]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.375]                             info)
[10:21:45.375]                           info <- base::paste(info, collapse = "; ")
[10:21:45.375]                           if (!has_future) {
[10:21:45.375]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.375]                               info)
[10:21:45.375]                           }
[10:21:45.375]                           else {
[10:21:45.375]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.375]                               info, version)
[10:21:45.375]                           }
[10:21:45.375]                           base::stop(msg)
[10:21:45.375]                         }
[10:21:45.375]                       })
[10:21:45.375]                     }
[10:21:45.375]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.375]                     base::options(mc.cores = 1L)
[10:21:45.375]                   }
[10:21:45.375]                   ...future.strategy.old <- future::plan("list")
[10:21:45.375]                   options(future.plan = NULL)
[10:21:45.375]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.375]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.375]                 }
[10:21:45.375]                 ...future.workdir <- getwd()
[10:21:45.375]             }
[10:21:45.375]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.375]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.375]         }
[10:21:45.375]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.375]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.375]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.375]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.375]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.375]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.375]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.375]             base::names(...future.oldOptions))
[10:21:45.375]     }
[10:21:45.375]     if (FALSE) {
[10:21:45.375]     }
[10:21:45.375]     else {
[10:21:45.375]         if (TRUE) {
[10:21:45.375]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.375]                 open = "w")
[10:21:45.375]         }
[10:21:45.375]         else {
[10:21:45.375]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.375]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.375]         }
[10:21:45.375]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.375]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.375]             base::sink(type = "output", split = FALSE)
[10:21:45.375]             base::close(...future.stdout)
[10:21:45.375]         }, add = TRUE)
[10:21:45.375]     }
[10:21:45.375]     ...future.frame <- base::sys.nframe()
[10:21:45.375]     ...future.conditions <- base::list()
[10:21:45.375]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.375]     if (FALSE) {
[10:21:45.375]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.375]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.375]     }
[10:21:45.375]     ...future.result <- base::tryCatch({
[10:21:45.375]         base::withCallingHandlers({
[10:21:45.375]             ...future.value <- base::withVisible(base::local({
[10:21:45.375]                 ...future.makeSendCondition <- base::local({
[10:21:45.375]                   sendCondition <- NULL
[10:21:45.375]                   function(frame = 1L) {
[10:21:45.375]                     if (is.function(sendCondition)) 
[10:21:45.375]                       return(sendCondition)
[10:21:45.375]                     ns <- getNamespace("parallel")
[10:21:45.375]                     if (exists("sendData", mode = "function", 
[10:21:45.375]                       envir = ns)) {
[10:21:45.375]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.375]                         envir = ns)
[10:21:45.375]                       envir <- sys.frame(frame)
[10:21:45.375]                       master <- NULL
[10:21:45.375]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.375]                         !identical(envir, emptyenv())) {
[10:21:45.375]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.375]                           inherits = FALSE)) {
[10:21:45.375]                           master <- get("master", mode = "list", 
[10:21:45.375]                             envir = envir, inherits = FALSE)
[10:21:45.375]                           if (inherits(master, c("SOCKnode", 
[10:21:45.375]                             "SOCK0node"))) {
[10:21:45.375]                             sendCondition <<- function(cond) {
[10:21:45.375]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.375]                                 success = TRUE)
[10:21:45.375]                               parallel_sendData(master, data)
[10:21:45.375]                             }
[10:21:45.375]                             return(sendCondition)
[10:21:45.375]                           }
[10:21:45.375]                         }
[10:21:45.375]                         frame <- frame + 1L
[10:21:45.375]                         envir <- sys.frame(frame)
[10:21:45.375]                       }
[10:21:45.375]                     }
[10:21:45.375]                     sendCondition <<- function(cond) NULL
[10:21:45.375]                   }
[10:21:45.375]                 })
[10:21:45.375]                 withCallingHandlers({
[10:21:45.375]                   {
[10:21:45.375]                     b <- a
[10:21:45.375]                     a <- 2
[10:21:45.375]                     a * b
[10:21:45.375]                   }
[10:21:45.375]                 }, immediateCondition = function(cond) {
[10:21:45.375]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.375]                   sendCondition(cond)
[10:21:45.375]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.375]                   {
[10:21:45.375]                     inherits <- base::inherits
[10:21:45.375]                     invokeRestart <- base::invokeRestart
[10:21:45.375]                     is.null <- base::is.null
[10:21:45.375]                     muffled <- FALSE
[10:21:45.375]                     if (inherits(cond, "message")) {
[10:21:45.375]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.375]                       if (muffled) 
[10:21:45.375]                         invokeRestart("muffleMessage")
[10:21:45.375]                     }
[10:21:45.375]                     else if (inherits(cond, "warning")) {
[10:21:45.375]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.375]                       if (muffled) 
[10:21:45.375]                         invokeRestart("muffleWarning")
[10:21:45.375]                     }
[10:21:45.375]                     else if (inherits(cond, "condition")) {
[10:21:45.375]                       if (!is.null(pattern)) {
[10:21:45.375]                         computeRestarts <- base::computeRestarts
[10:21:45.375]                         grepl <- base::grepl
[10:21:45.375]                         restarts <- computeRestarts(cond)
[10:21:45.375]                         for (restart in restarts) {
[10:21:45.375]                           name <- restart$name
[10:21:45.375]                           if (is.null(name)) 
[10:21:45.375]                             next
[10:21:45.375]                           if (!grepl(pattern, name)) 
[10:21:45.375]                             next
[10:21:45.375]                           invokeRestart(restart)
[10:21:45.375]                           muffled <- TRUE
[10:21:45.375]                           break
[10:21:45.375]                         }
[10:21:45.375]                       }
[10:21:45.375]                     }
[10:21:45.375]                     invisible(muffled)
[10:21:45.375]                   }
[10:21:45.375]                   muffleCondition(cond)
[10:21:45.375]                 })
[10:21:45.375]             }))
[10:21:45.375]             future::FutureResult(value = ...future.value$value, 
[10:21:45.375]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.375]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.375]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.375]                     ...future.globalenv.names))
[10:21:45.375]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.375]         }, condition = base::local({
[10:21:45.375]             c <- base::c
[10:21:45.375]             inherits <- base::inherits
[10:21:45.375]             invokeRestart <- base::invokeRestart
[10:21:45.375]             length <- base::length
[10:21:45.375]             list <- base::list
[10:21:45.375]             seq.int <- base::seq.int
[10:21:45.375]             signalCondition <- base::signalCondition
[10:21:45.375]             sys.calls <- base::sys.calls
[10:21:45.375]             `[[` <- base::`[[`
[10:21:45.375]             `+` <- base::`+`
[10:21:45.375]             `<<-` <- base::`<<-`
[10:21:45.375]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.375]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.375]                   3L)]
[10:21:45.375]             }
[10:21:45.375]             function(cond) {
[10:21:45.375]                 is_error <- inherits(cond, "error")
[10:21:45.375]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.375]                   NULL)
[10:21:45.375]                 if (is_error) {
[10:21:45.375]                   sessionInformation <- function() {
[10:21:45.375]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.375]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.375]                       search = base::search(), system = base::Sys.info())
[10:21:45.375]                   }
[10:21:45.375]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.375]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.375]                     cond$call), session = sessionInformation(), 
[10:21:45.375]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.375]                   signalCondition(cond)
[10:21:45.375]                 }
[10:21:45.375]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.375]                 "immediateCondition"))) {
[10:21:45.375]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.375]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.375]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.375]                   if (TRUE && !signal) {
[10:21:45.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.375]                     {
[10:21:45.375]                       inherits <- base::inherits
[10:21:45.375]                       invokeRestart <- base::invokeRestart
[10:21:45.375]                       is.null <- base::is.null
[10:21:45.375]                       muffled <- FALSE
[10:21:45.375]                       if (inherits(cond, "message")) {
[10:21:45.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.375]                         if (muffled) 
[10:21:45.375]                           invokeRestart("muffleMessage")
[10:21:45.375]                       }
[10:21:45.375]                       else if (inherits(cond, "warning")) {
[10:21:45.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.375]                         if (muffled) 
[10:21:45.375]                           invokeRestart("muffleWarning")
[10:21:45.375]                       }
[10:21:45.375]                       else if (inherits(cond, "condition")) {
[10:21:45.375]                         if (!is.null(pattern)) {
[10:21:45.375]                           computeRestarts <- base::computeRestarts
[10:21:45.375]                           grepl <- base::grepl
[10:21:45.375]                           restarts <- computeRestarts(cond)
[10:21:45.375]                           for (restart in restarts) {
[10:21:45.375]                             name <- restart$name
[10:21:45.375]                             if (is.null(name)) 
[10:21:45.375]                               next
[10:21:45.375]                             if (!grepl(pattern, name)) 
[10:21:45.375]                               next
[10:21:45.375]                             invokeRestart(restart)
[10:21:45.375]                             muffled <- TRUE
[10:21:45.375]                             break
[10:21:45.375]                           }
[10:21:45.375]                         }
[10:21:45.375]                       }
[10:21:45.375]                       invisible(muffled)
[10:21:45.375]                     }
[10:21:45.375]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.375]                   }
[10:21:45.375]                 }
[10:21:45.375]                 else {
[10:21:45.375]                   if (TRUE) {
[10:21:45.375]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.375]                     {
[10:21:45.375]                       inherits <- base::inherits
[10:21:45.375]                       invokeRestart <- base::invokeRestart
[10:21:45.375]                       is.null <- base::is.null
[10:21:45.375]                       muffled <- FALSE
[10:21:45.375]                       if (inherits(cond, "message")) {
[10:21:45.375]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.375]                         if (muffled) 
[10:21:45.375]                           invokeRestart("muffleMessage")
[10:21:45.375]                       }
[10:21:45.375]                       else if (inherits(cond, "warning")) {
[10:21:45.375]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.375]                         if (muffled) 
[10:21:45.375]                           invokeRestart("muffleWarning")
[10:21:45.375]                       }
[10:21:45.375]                       else if (inherits(cond, "condition")) {
[10:21:45.375]                         if (!is.null(pattern)) {
[10:21:45.375]                           computeRestarts <- base::computeRestarts
[10:21:45.375]                           grepl <- base::grepl
[10:21:45.375]                           restarts <- computeRestarts(cond)
[10:21:45.375]                           for (restart in restarts) {
[10:21:45.375]                             name <- restart$name
[10:21:45.375]                             if (is.null(name)) 
[10:21:45.375]                               next
[10:21:45.375]                             if (!grepl(pattern, name)) 
[10:21:45.375]                               next
[10:21:45.375]                             invokeRestart(restart)
[10:21:45.375]                             muffled <- TRUE
[10:21:45.375]                             break
[10:21:45.375]                           }
[10:21:45.375]                         }
[10:21:45.375]                       }
[10:21:45.375]                       invisible(muffled)
[10:21:45.375]                     }
[10:21:45.375]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.375]                   }
[10:21:45.375]                 }
[10:21:45.375]             }
[10:21:45.375]         }))
[10:21:45.375]     }, error = function(ex) {
[10:21:45.375]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.375]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.375]                 ...future.rng), started = ...future.startTime, 
[10:21:45.375]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.375]             version = "1.8"), class = "FutureResult")
[10:21:45.375]     }, finally = {
[10:21:45.375]         if (!identical(...future.workdir, getwd())) 
[10:21:45.375]             setwd(...future.workdir)
[10:21:45.375]         {
[10:21:45.375]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.375]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.375]             }
[10:21:45.375]             base::options(...future.oldOptions)
[10:21:45.375]             if (.Platform$OS.type == "windows") {
[10:21:45.375]                 old_names <- names(...future.oldEnvVars)
[10:21:45.375]                 envs <- base::Sys.getenv()
[10:21:45.375]                 names <- names(envs)
[10:21:45.375]                 common <- intersect(names, old_names)
[10:21:45.375]                 added <- setdiff(names, old_names)
[10:21:45.375]                 removed <- setdiff(old_names, names)
[10:21:45.375]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.375]                   envs[common]]
[10:21:45.375]                 NAMES <- toupper(changed)
[10:21:45.375]                 args <- list()
[10:21:45.375]                 for (kk in seq_along(NAMES)) {
[10:21:45.375]                   name <- changed[[kk]]
[10:21:45.375]                   NAME <- NAMES[[kk]]
[10:21:45.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.375]                     next
[10:21:45.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.375]                 }
[10:21:45.375]                 NAMES <- toupper(added)
[10:21:45.375]                 for (kk in seq_along(NAMES)) {
[10:21:45.375]                   name <- added[[kk]]
[10:21:45.375]                   NAME <- NAMES[[kk]]
[10:21:45.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.375]                     next
[10:21:45.375]                   args[[name]] <- ""
[10:21:45.375]                 }
[10:21:45.375]                 NAMES <- toupper(removed)
[10:21:45.375]                 for (kk in seq_along(NAMES)) {
[10:21:45.375]                   name <- removed[[kk]]
[10:21:45.375]                   NAME <- NAMES[[kk]]
[10:21:45.375]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.375]                     next
[10:21:45.375]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.375]                 }
[10:21:45.375]                 if (length(args) > 0) 
[10:21:45.375]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.375]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.375]             }
[10:21:45.375]             else {
[10:21:45.375]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.375]             }
[10:21:45.375]             {
[10:21:45.375]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.375]                   0L) {
[10:21:45.375]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.375]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.375]                   base::options(opts)
[10:21:45.375]                 }
[10:21:45.375]                 {
[10:21:45.375]                   {
[10:21:45.375]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.375]                     NULL
[10:21:45.375]                   }
[10:21:45.375]                   options(future.plan = NULL)
[10:21:45.375]                   if (is.na(NA_character_)) 
[10:21:45.375]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.375]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.375]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.375]                     .init = FALSE)
[10:21:45.375]                 }
[10:21:45.375]             }
[10:21:45.375]         }
[10:21:45.375]     })
[10:21:45.375]     if (TRUE) {
[10:21:45.375]         base::sink(type = "output", split = FALSE)
[10:21:45.375]         if (TRUE) {
[10:21:45.375]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.375]         }
[10:21:45.375]         else {
[10:21:45.375]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.375]         }
[10:21:45.375]         base::close(...future.stdout)
[10:21:45.375]         ...future.stdout <- NULL
[10:21:45.375]     }
[10:21:45.375]     ...future.result$conditions <- ...future.conditions
[10:21:45.375]     ...future.result$finished <- base::Sys.time()
[10:21:45.375]     ...future.result
[10:21:45.375] }
[10:21:45.378] MultisessionFuture started
[10:21:45.378] - Launch lazy future ... done
[10:21:45.378] run() for ‘MultisessionFuture’ ... done
[10:21:45.379] result() for ClusterFuture ...
[10:21:45.379] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.379] - Validating connection of MultisessionFuture
[10:21:45.424] - received message: FutureResult
[10:21:45.424] - Received FutureResult
[10:21:45.424] - Erased future from FutureRegistry
[10:21:45.424] result() for ClusterFuture ...
[10:21:45.425] - result already collected: FutureResult
[10:21:45.425] result() for ClusterFuture ... done
[10:21:45.425] signalConditions() ...
[10:21:45.425]  - include = ‘immediateCondition’
[10:21:45.425]  - exclude = 
[10:21:45.425]  - resignal = FALSE
[10:21:45.425]  - Number of conditions: 1
[10:21:45.425] signalConditions() ... done
[10:21:45.425] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:45.425] result() for ClusterFuture ... done
[10:21:45.426] result() for ClusterFuture ...
[10:21:45.426] - result already collected: FutureResult
[10:21:45.426] result() for ClusterFuture ... done
[10:21:45.426] signalConditions() ...
[10:21:45.426]  - include = ‘immediateCondition’
[10:21:45.426]  - exclude = 
[10:21:45.426]  - resignal = FALSE
[10:21:45.426]  - Number of conditions: 1
[10:21:45.426] signalConditions() ... done
[10:21:45.426] Future state: ‘finished’
[10:21:45.426] result() for ClusterFuture ...
[10:21:45.427] - result already collected: FutureResult
[10:21:45.427] result() for ClusterFuture ... done
[10:21:45.427] signalConditions() ...
[10:21:45.427]  - include = ‘condition’
[10:21:45.427]  - exclude = ‘immediateCondition’
[10:21:45.427]  - resignal = TRUE
[10:21:45.427]  - Number of conditions: 1
[10:21:45.427]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:45.427] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:45"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.442] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.442] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.443] - globals found: [3] ‘{’, ‘<-’, ‘*’
[10:21:45.444] Searching for globals ... DONE
[10:21:45.444] Resolving globals: TRUE
[10:21:45.444] Resolving any globals that are futures ...
[10:21:45.444] - globals: [3] ‘{’, ‘<-’, ‘*’
[10:21:45.444] Resolving any globals that are futures ... DONE
[10:21:45.445] 
[10:21:45.445] 
[10:21:45.445] getGlobalsAndPackages() ... DONE
[10:21:45.445] run() for ‘Future’ ...
[10:21:45.445] - state: ‘created’
[10:21:45.445] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.460] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.461]   - Field: ‘node’
[10:21:45.461]   - Field: ‘label’
[10:21:45.461]   - Field: ‘local’
[10:21:45.461]   - Field: ‘owner’
[10:21:45.461]   - Field: ‘envir’
[10:21:45.461]   - Field: ‘workers’
[10:21:45.461]   - Field: ‘packages’
[10:21:45.461]   - Field: ‘gc’
[10:21:45.461]   - Field: ‘conditions’
[10:21:45.461]   - Field: ‘persistent’
[10:21:45.461]   - Field: ‘expr’
[10:21:45.462]   - Field: ‘uuid’
[10:21:45.462]   - Field: ‘seed’
[10:21:45.462]   - Field: ‘version’
[10:21:45.462]   - Field: ‘result’
[10:21:45.462]   - Field: ‘asynchronous’
[10:21:45.462]   - Field: ‘calls’
[10:21:45.462]   - Field: ‘globals’
[10:21:45.462]   - Field: ‘stdout’
[10:21:45.462]   - Field: ‘earlySignal’
[10:21:45.463]   - Field: ‘lazy’
[10:21:45.463]   - Field: ‘state’
[10:21:45.463] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.463] - Launch lazy future ...
[10:21:45.463] Packages needed by the future expression (n = 0): <none>
[10:21:45.463] Packages needed by future strategies (n = 0): <none>
[10:21:45.464] {
[10:21:45.464]     {
[10:21:45.464]         {
[10:21:45.464]             ...future.startTime <- base::Sys.time()
[10:21:45.464]             {
[10:21:45.464]                 {
[10:21:45.464]                   {
[10:21:45.464]                     {
[10:21:45.464]                       base::local({
[10:21:45.464]                         has_future <- base::requireNamespace("future", 
[10:21:45.464]                           quietly = TRUE)
[10:21:45.464]                         if (has_future) {
[10:21:45.464]                           ns <- base::getNamespace("future")
[10:21:45.464]                           version <- ns[[".package"]][["version"]]
[10:21:45.464]                           if (is.null(version)) 
[10:21:45.464]                             version <- utils::packageVersion("future")
[10:21:45.464]                         }
[10:21:45.464]                         else {
[10:21:45.464]                           version <- NULL
[10:21:45.464]                         }
[10:21:45.464]                         if (!has_future || version < "1.8.0") {
[10:21:45.464]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.464]                             "", base::R.version$version.string), 
[10:21:45.464]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.464]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.464]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.464]                               "release", "version")], collapse = " "), 
[10:21:45.464]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.464]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.464]                             info)
[10:21:45.464]                           info <- base::paste(info, collapse = "; ")
[10:21:45.464]                           if (!has_future) {
[10:21:45.464]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.464]                               info)
[10:21:45.464]                           }
[10:21:45.464]                           else {
[10:21:45.464]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.464]                               info, version)
[10:21:45.464]                           }
[10:21:45.464]                           base::stop(msg)
[10:21:45.464]                         }
[10:21:45.464]                       })
[10:21:45.464]                     }
[10:21:45.464]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.464]                     base::options(mc.cores = 1L)
[10:21:45.464]                   }
[10:21:45.464]                   ...future.strategy.old <- future::plan("list")
[10:21:45.464]                   options(future.plan = NULL)
[10:21:45.464]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.464]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.464]                 }
[10:21:45.464]                 ...future.workdir <- getwd()
[10:21:45.464]             }
[10:21:45.464]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.464]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.464]         }
[10:21:45.464]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.464]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.464]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.464]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.464]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.464]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.464]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.464]             base::names(...future.oldOptions))
[10:21:45.464]     }
[10:21:45.464]     if (FALSE) {
[10:21:45.464]     }
[10:21:45.464]     else {
[10:21:45.464]         if (TRUE) {
[10:21:45.464]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.464]                 open = "w")
[10:21:45.464]         }
[10:21:45.464]         else {
[10:21:45.464]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.464]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.464]         }
[10:21:45.464]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.464]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.464]             base::sink(type = "output", split = FALSE)
[10:21:45.464]             base::close(...future.stdout)
[10:21:45.464]         }, add = TRUE)
[10:21:45.464]     }
[10:21:45.464]     ...future.frame <- base::sys.nframe()
[10:21:45.464]     ...future.conditions <- base::list()
[10:21:45.464]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.464]     if (FALSE) {
[10:21:45.464]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.464]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.464]     }
[10:21:45.464]     ...future.result <- base::tryCatch({
[10:21:45.464]         base::withCallingHandlers({
[10:21:45.464]             ...future.value <- base::withVisible(base::local({
[10:21:45.464]                 ...future.makeSendCondition <- base::local({
[10:21:45.464]                   sendCondition <- NULL
[10:21:45.464]                   function(frame = 1L) {
[10:21:45.464]                     if (is.function(sendCondition)) 
[10:21:45.464]                       return(sendCondition)
[10:21:45.464]                     ns <- getNamespace("parallel")
[10:21:45.464]                     if (exists("sendData", mode = "function", 
[10:21:45.464]                       envir = ns)) {
[10:21:45.464]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.464]                         envir = ns)
[10:21:45.464]                       envir <- sys.frame(frame)
[10:21:45.464]                       master <- NULL
[10:21:45.464]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.464]                         !identical(envir, emptyenv())) {
[10:21:45.464]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.464]                           inherits = FALSE)) {
[10:21:45.464]                           master <- get("master", mode = "list", 
[10:21:45.464]                             envir = envir, inherits = FALSE)
[10:21:45.464]                           if (inherits(master, c("SOCKnode", 
[10:21:45.464]                             "SOCK0node"))) {
[10:21:45.464]                             sendCondition <<- function(cond) {
[10:21:45.464]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.464]                                 success = TRUE)
[10:21:45.464]                               parallel_sendData(master, data)
[10:21:45.464]                             }
[10:21:45.464]                             return(sendCondition)
[10:21:45.464]                           }
[10:21:45.464]                         }
[10:21:45.464]                         frame <- frame + 1L
[10:21:45.464]                         envir <- sys.frame(frame)
[10:21:45.464]                       }
[10:21:45.464]                     }
[10:21:45.464]                     sendCondition <<- function(cond) NULL
[10:21:45.464]                   }
[10:21:45.464]                 })
[10:21:45.464]                 withCallingHandlers({
[10:21:45.464]                   {
[10:21:45.464]                     b <- a
[10:21:45.464]                     a <- 2
[10:21:45.464]                     a * b
[10:21:45.464]                   }
[10:21:45.464]                 }, immediateCondition = function(cond) {
[10:21:45.464]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.464]                   sendCondition(cond)
[10:21:45.464]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.464]                   {
[10:21:45.464]                     inherits <- base::inherits
[10:21:45.464]                     invokeRestart <- base::invokeRestart
[10:21:45.464]                     is.null <- base::is.null
[10:21:45.464]                     muffled <- FALSE
[10:21:45.464]                     if (inherits(cond, "message")) {
[10:21:45.464]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.464]                       if (muffled) 
[10:21:45.464]                         invokeRestart("muffleMessage")
[10:21:45.464]                     }
[10:21:45.464]                     else if (inherits(cond, "warning")) {
[10:21:45.464]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.464]                       if (muffled) 
[10:21:45.464]                         invokeRestart("muffleWarning")
[10:21:45.464]                     }
[10:21:45.464]                     else if (inherits(cond, "condition")) {
[10:21:45.464]                       if (!is.null(pattern)) {
[10:21:45.464]                         computeRestarts <- base::computeRestarts
[10:21:45.464]                         grepl <- base::grepl
[10:21:45.464]                         restarts <- computeRestarts(cond)
[10:21:45.464]                         for (restart in restarts) {
[10:21:45.464]                           name <- restart$name
[10:21:45.464]                           if (is.null(name)) 
[10:21:45.464]                             next
[10:21:45.464]                           if (!grepl(pattern, name)) 
[10:21:45.464]                             next
[10:21:45.464]                           invokeRestart(restart)
[10:21:45.464]                           muffled <- TRUE
[10:21:45.464]                           break
[10:21:45.464]                         }
[10:21:45.464]                       }
[10:21:45.464]                     }
[10:21:45.464]                     invisible(muffled)
[10:21:45.464]                   }
[10:21:45.464]                   muffleCondition(cond)
[10:21:45.464]                 })
[10:21:45.464]             }))
[10:21:45.464]             future::FutureResult(value = ...future.value$value, 
[10:21:45.464]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.464]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.464]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.464]                     ...future.globalenv.names))
[10:21:45.464]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.464]         }, condition = base::local({
[10:21:45.464]             c <- base::c
[10:21:45.464]             inherits <- base::inherits
[10:21:45.464]             invokeRestart <- base::invokeRestart
[10:21:45.464]             length <- base::length
[10:21:45.464]             list <- base::list
[10:21:45.464]             seq.int <- base::seq.int
[10:21:45.464]             signalCondition <- base::signalCondition
[10:21:45.464]             sys.calls <- base::sys.calls
[10:21:45.464]             `[[` <- base::`[[`
[10:21:45.464]             `+` <- base::`+`
[10:21:45.464]             `<<-` <- base::`<<-`
[10:21:45.464]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.464]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.464]                   3L)]
[10:21:45.464]             }
[10:21:45.464]             function(cond) {
[10:21:45.464]                 is_error <- inherits(cond, "error")
[10:21:45.464]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.464]                   NULL)
[10:21:45.464]                 if (is_error) {
[10:21:45.464]                   sessionInformation <- function() {
[10:21:45.464]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.464]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.464]                       search = base::search(), system = base::Sys.info())
[10:21:45.464]                   }
[10:21:45.464]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.464]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.464]                     cond$call), session = sessionInformation(), 
[10:21:45.464]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.464]                   signalCondition(cond)
[10:21:45.464]                 }
[10:21:45.464]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.464]                 "immediateCondition"))) {
[10:21:45.464]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.464]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.464]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.464]                   if (TRUE && !signal) {
[10:21:45.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.464]                     {
[10:21:45.464]                       inherits <- base::inherits
[10:21:45.464]                       invokeRestart <- base::invokeRestart
[10:21:45.464]                       is.null <- base::is.null
[10:21:45.464]                       muffled <- FALSE
[10:21:45.464]                       if (inherits(cond, "message")) {
[10:21:45.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.464]                         if (muffled) 
[10:21:45.464]                           invokeRestart("muffleMessage")
[10:21:45.464]                       }
[10:21:45.464]                       else if (inherits(cond, "warning")) {
[10:21:45.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.464]                         if (muffled) 
[10:21:45.464]                           invokeRestart("muffleWarning")
[10:21:45.464]                       }
[10:21:45.464]                       else if (inherits(cond, "condition")) {
[10:21:45.464]                         if (!is.null(pattern)) {
[10:21:45.464]                           computeRestarts <- base::computeRestarts
[10:21:45.464]                           grepl <- base::grepl
[10:21:45.464]                           restarts <- computeRestarts(cond)
[10:21:45.464]                           for (restart in restarts) {
[10:21:45.464]                             name <- restart$name
[10:21:45.464]                             if (is.null(name)) 
[10:21:45.464]                               next
[10:21:45.464]                             if (!grepl(pattern, name)) 
[10:21:45.464]                               next
[10:21:45.464]                             invokeRestart(restart)
[10:21:45.464]                             muffled <- TRUE
[10:21:45.464]                             break
[10:21:45.464]                           }
[10:21:45.464]                         }
[10:21:45.464]                       }
[10:21:45.464]                       invisible(muffled)
[10:21:45.464]                     }
[10:21:45.464]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.464]                   }
[10:21:45.464]                 }
[10:21:45.464]                 else {
[10:21:45.464]                   if (TRUE) {
[10:21:45.464]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.464]                     {
[10:21:45.464]                       inherits <- base::inherits
[10:21:45.464]                       invokeRestart <- base::invokeRestart
[10:21:45.464]                       is.null <- base::is.null
[10:21:45.464]                       muffled <- FALSE
[10:21:45.464]                       if (inherits(cond, "message")) {
[10:21:45.464]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.464]                         if (muffled) 
[10:21:45.464]                           invokeRestart("muffleMessage")
[10:21:45.464]                       }
[10:21:45.464]                       else if (inherits(cond, "warning")) {
[10:21:45.464]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.464]                         if (muffled) 
[10:21:45.464]                           invokeRestart("muffleWarning")
[10:21:45.464]                       }
[10:21:45.464]                       else if (inherits(cond, "condition")) {
[10:21:45.464]                         if (!is.null(pattern)) {
[10:21:45.464]                           computeRestarts <- base::computeRestarts
[10:21:45.464]                           grepl <- base::grepl
[10:21:45.464]                           restarts <- computeRestarts(cond)
[10:21:45.464]                           for (restart in restarts) {
[10:21:45.464]                             name <- restart$name
[10:21:45.464]                             if (is.null(name)) 
[10:21:45.464]                               next
[10:21:45.464]                             if (!grepl(pattern, name)) 
[10:21:45.464]                               next
[10:21:45.464]                             invokeRestart(restart)
[10:21:45.464]                             muffled <- TRUE
[10:21:45.464]                             break
[10:21:45.464]                           }
[10:21:45.464]                         }
[10:21:45.464]                       }
[10:21:45.464]                       invisible(muffled)
[10:21:45.464]                     }
[10:21:45.464]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.464]                   }
[10:21:45.464]                 }
[10:21:45.464]             }
[10:21:45.464]         }))
[10:21:45.464]     }, error = function(ex) {
[10:21:45.464]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.464]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.464]                 ...future.rng), started = ...future.startTime, 
[10:21:45.464]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.464]             version = "1.8"), class = "FutureResult")
[10:21:45.464]     }, finally = {
[10:21:45.464]         if (!identical(...future.workdir, getwd())) 
[10:21:45.464]             setwd(...future.workdir)
[10:21:45.464]         {
[10:21:45.464]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.464]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.464]             }
[10:21:45.464]             base::options(...future.oldOptions)
[10:21:45.464]             if (.Platform$OS.type == "windows") {
[10:21:45.464]                 old_names <- names(...future.oldEnvVars)
[10:21:45.464]                 envs <- base::Sys.getenv()
[10:21:45.464]                 names <- names(envs)
[10:21:45.464]                 common <- intersect(names, old_names)
[10:21:45.464]                 added <- setdiff(names, old_names)
[10:21:45.464]                 removed <- setdiff(old_names, names)
[10:21:45.464]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.464]                   envs[common]]
[10:21:45.464]                 NAMES <- toupper(changed)
[10:21:45.464]                 args <- list()
[10:21:45.464]                 for (kk in seq_along(NAMES)) {
[10:21:45.464]                   name <- changed[[kk]]
[10:21:45.464]                   NAME <- NAMES[[kk]]
[10:21:45.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.464]                     next
[10:21:45.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.464]                 }
[10:21:45.464]                 NAMES <- toupper(added)
[10:21:45.464]                 for (kk in seq_along(NAMES)) {
[10:21:45.464]                   name <- added[[kk]]
[10:21:45.464]                   NAME <- NAMES[[kk]]
[10:21:45.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.464]                     next
[10:21:45.464]                   args[[name]] <- ""
[10:21:45.464]                 }
[10:21:45.464]                 NAMES <- toupper(removed)
[10:21:45.464]                 for (kk in seq_along(NAMES)) {
[10:21:45.464]                   name <- removed[[kk]]
[10:21:45.464]                   NAME <- NAMES[[kk]]
[10:21:45.464]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.464]                     next
[10:21:45.464]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.464]                 }
[10:21:45.464]                 if (length(args) > 0) 
[10:21:45.464]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.464]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.464]             }
[10:21:45.464]             else {
[10:21:45.464]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.464]             }
[10:21:45.464]             {
[10:21:45.464]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.464]                   0L) {
[10:21:45.464]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.464]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.464]                   base::options(opts)
[10:21:45.464]                 }
[10:21:45.464]                 {
[10:21:45.464]                   {
[10:21:45.464]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.464]                     NULL
[10:21:45.464]                   }
[10:21:45.464]                   options(future.plan = NULL)
[10:21:45.464]                   if (is.na(NA_character_)) 
[10:21:45.464]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.464]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.464]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.464]                     .init = FALSE)
[10:21:45.464]                 }
[10:21:45.464]             }
[10:21:45.464]         }
[10:21:45.464]     })
[10:21:45.464]     if (TRUE) {
[10:21:45.464]         base::sink(type = "output", split = FALSE)
[10:21:45.464]         if (TRUE) {
[10:21:45.464]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.464]         }
[10:21:45.464]         else {
[10:21:45.464]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.464]         }
[10:21:45.464]         base::close(...future.stdout)
[10:21:45.464]         ...future.stdout <- NULL
[10:21:45.464]     }
[10:21:45.464]     ...future.result$conditions <- ...future.conditions
[10:21:45.464]     ...future.result$finished <- base::Sys.time()
[10:21:45.464]     ...future.result
[10:21:45.464] }
[10:21:45.467] MultisessionFuture started
[10:21:45.467] - Launch lazy future ... done
[10:21:45.467] run() for ‘MultisessionFuture’ ... done
[10:21:45.468] result() for ClusterFuture ...
[10:21:45.468] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.468] - Validating connection of MultisessionFuture
[10:21:45.510] - received message: FutureResult
[10:21:45.510] - Received FutureResult
[10:21:45.510] - Erased future from FutureRegistry
[10:21:45.510] result() for ClusterFuture ...
[10:21:45.510] - result already collected: FutureResult
[10:21:45.510] result() for ClusterFuture ... done
[10:21:45.510] signalConditions() ...
[10:21:45.510]  - include = ‘immediateCondition’
[10:21:45.511]  - exclude = 
[10:21:45.511]  - resignal = FALSE
[10:21:45.511]  - Number of conditions: 1
[10:21:45.511] signalConditions() ... done
[10:21:45.511] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:45.511] result() for ClusterFuture ... done
[10:21:45.511] result() for ClusterFuture ...
[10:21:45.511] - result already collected: FutureResult
[10:21:45.511] result() for ClusterFuture ... done
[10:21:45.512] signalConditions() ...
[10:21:45.512]  - include = ‘immediateCondition’
[10:21:45.512]  - exclude = 
[10:21:45.512]  - resignal = FALSE
[10:21:45.512]  - Number of conditions: 1
[10:21:45.512] signalConditions() ... done
[10:21:45.512] Future state: ‘finished’
[10:21:45.512] result() for ClusterFuture ...
[10:21:45.512] - result already collected: FutureResult
[10:21:45.513] result() for ClusterFuture ... done
[10:21:45.513] signalConditions() ...
[10:21:45.513]  - include = ‘condition’
[10:21:45.513]  - exclude = ‘immediateCondition’
[10:21:45.513]  - resignal = TRUE
[10:21:45.513]  - Number of conditions: 1
[10:21:45.513]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:45.513] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:45"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.530] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.530] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.532] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.532] Searching for globals ... DONE
[10:21:45.532] Resolving globals: TRUE
[10:21:45.532] Resolving any globals that are futures ...
[10:21:45.532] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.533] Resolving any globals that are futures ... DONE
[10:21:45.533] Resolving futures part of globals (recursively) ...
[10:21:45.533] resolve() on list ...
[10:21:45.533]  recursive: 99
[10:21:45.534]  length: 1
[10:21:45.534]  elements: ‘ii’
[10:21:45.534]  length: 0 (resolved future 1)
[10:21:45.534] resolve() on list ... DONE
[10:21:45.534] - globals: [1] ‘ii’
[10:21:45.534] Resolving futures part of globals (recursively) ... DONE
[10:21:45.534] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:45.535] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:45.535] - globals: [1] ‘ii’
[10:21:45.535] 
[10:21:45.535] getGlobalsAndPackages() ... DONE
[10:21:45.535] run() for ‘Future’ ...
[10:21:45.535] - state: ‘created’
[10:21:45.536] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.552] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.552]   - Field: ‘node’
[10:21:45.552]   - Field: ‘label’
[10:21:45.552]   - Field: ‘local’
[10:21:45.552]   - Field: ‘owner’
[10:21:45.552]   - Field: ‘envir’
[10:21:45.553]   - Field: ‘workers’
[10:21:45.553]   - Field: ‘packages’
[10:21:45.553]   - Field: ‘gc’
[10:21:45.553]   - Field: ‘conditions’
[10:21:45.553]   - Field: ‘persistent’
[10:21:45.553]   - Field: ‘expr’
[10:21:45.553]   - Field: ‘uuid’
[10:21:45.553]   - Field: ‘seed’
[10:21:45.553]   - Field: ‘version’
[10:21:45.553]   - Field: ‘result’
[10:21:45.553]   - Field: ‘asynchronous’
[10:21:45.553]   - Field: ‘calls’
[10:21:45.554]   - Field: ‘globals’
[10:21:45.554]   - Field: ‘stdout’
[10:21:45.554]   - Field: ‘earlySignal’
[10:21:45.554]   - Field: ‘lazy’
[10:21:45.554]   - Field: ‘state’
[10:21:45.554] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.554] - Launch lazy future ...
[10:21:45.554] Packages needed by the future expression (n = 0): <none>
[10:21:45.554] Packages needed by future strategies (n = 0): <none>
[10:21:45.555] {
[10:21:45.555]     {
[10:21:45.555]         {
[10:21:45.555]             ...future.startTime <- base::Sys.time()
[10:21:45.555]             {
[10:21:45.555]                 {
[10:21:45.555]                   {
[10:21:45.555]                     {
[10:21:45.555]                       base::local({
[10:21:45.555]                         has_future <- base::requireNamespace("future", 
[10:21:45.555]                           quietly = TRUE)
[10:21:45.555]                         if (has_future) {
[10:21:45.555]                           ns <- base::getNamespace("future")
[10:21:45.555]                           version <- ns[[".package"]][["version"]]
[10:21:45.555]                           if (is.null(version)) 
[10:21:45.555]                             version <- utils::packageVersion("future")
[10:21:45.555]                         }
[10:21:45.555]                         else {
[10:21:45.555]                           version <- NULL
[10:21:45.555]                         }
[10:21:45.555]                         if (!has_future || version < "1.8.0") {
[10:21:45.555]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.555]                             "", base::R.version$version.string), 
[10:21:45.555]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.555]                               "release", "version")], collapse = " "), 
[10:21:45.555]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.555]                             info)
[10:21:45.555]                           info <- base::paste(info, collapse = "; ")
[10:21:45.555]                           if (!has_future) {
[10:21:45.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.555]                               info)
[10:21:45.555]                           }
[10:21:45.555]                           else {
[10:21:45.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.555]                               info, version)
[10:21:45.555]                           }
[10:21:45.555]                           base::stop(msg)
[10:21:45.555]                         }
[10:21:45.555]                       })
[10:21:45.555]                     }
[10:21:45.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.555]                     base::options(mc.cores = 1L)
[10:21:45.555]                   }
[10:21:45.555]                   ...future.strategy.old <- future::plan("list")
[10:21:45.555]                   options(future.plan = NULL)
[10:21:45.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.555]                 }
[10:21:45.555]                 ...future.workdir <- getwd()
[10:21:45.555]             }
[10:21:45.555]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.555]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.555]         }
[10:21:45.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.555]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.555]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.555]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.555]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.555]             base::names(...future.oldOptions))
[10:21:45.555]     }
[10:21:45.555]     if (FALSE) {
[10:21:45.555]     }
[10:21:45.555]     else {
[10:21:45.555]         if (TRUE) {
[10:21:45.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.555]                 open = "w")
[10:21:45.555]         }
[10:21:45.555]         else {
[10:21:45.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.555]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.555]         }
[10:21:45.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.555]             base::sink(type = "output", split = FALSE)
[10:21:45.555]             base::close(...future.stdout)
[10:21:45.555]         }, add = TRUE)
[10:21:45.555]     }
[10:21:45.555]     ...future.frame <- base::sys.nframe()
[10:21:45.555]     ...future.conditions <- base::list()
[10:21:45.555]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.555]     if (FALSE) {
[10:21:45.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.555]     }
[10:21:45.555]     ...future.result <- base::tryCatch({
[10:21:45.555]         base::withCallingHandlers({
[10:21:45.555]             ...future.value <- base::withVisible(base::local({
[10:21:45.555]                 ...future.makeSendCondition <- base::local({
[10:21:45.555]                   sendCondition <- NULL
[10:21:45.555]                   function(frame = 1L) {
[10:21:45.555]                     if (is.function(sendCondition)) 
[10:21:45.555]                       return(sendCondition)
[10:21:45.555]                     ns <- getNamespace("parallel")
[10:21:45.555]                     if (exists("sendData", mode = "function", 
[10:21:45.555]                       envir = ns)) {
[10:21:45.555]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.555]                         envir = ns)
[10:21:45.555]                       envir <- sys.frame(frame)
[10:21:45.555]                       master <- NULL
[10:21:45.555]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.555]                         !identical(envir, emptyenv())) {
[10:21:45.555]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.555]                           inherits = FALSE)) {
[10:21:45.555]                           master <- get("master", mode = "list", 
[10:21:45.555]                             envir = envir, inherits = FALSE)
[10:21:45.555]                           if (inherits(master, c("SOCKnode", 
[10:21:45.555]                             "SOCK0node"))) {
[10:21:45.555]                             sendCondition <<- function(cond) {
[10:21:45.555]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.555]                                 success = TRUE)
[10:21:45.555]                               parallel_sendData(master, data)
[10:21:45.555]                             }
[10:21:45.555]                             return(sendCondition)
[10:21:45.555]                           }
[10:21:45.555]                         }
[10:21:45.555]                         frame <- frame + 1L
[10:21:45.555]                         envir <- sys.frame(frame)
[10:21:45.555]                       }
[10:21:45.555]                     }
[10:21:45.555]                     sendCondition <<- function(cond) NULL
[10:21:45.555]                   }
[10:21:45.555]                 })
[10:21:45.555]                 withCallingHandlers({
[10:21:45.555]                   {
[10:21:45.555]                     b <- a * ii
[10:21:45.555]                     a <- 0
[10:21:45.555]                     b
[10:21:45.555]                   }
[10:21:45.555]                 }, immediateCondition = function(cond) {
[10:21:45.555]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.555]                   sendCondition(cond)
[10:21:45.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.555]                   {
[10:21:45.555]                     inherits <- base::inherits
[10:21:45.555]                     invokeRestart <- base::invokeRestart
[10:21:45.555]                     is.null <- base::is.null
[10:21:45.555]                     muffled <- FALSE
[10:21:45.555]                     if (inherits(cond, "message")) {
[10:21:45.555]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.555]                       if (muffled) 
[10:21:45.555]                         invokeRestart("muffleMessage")
[10:21:45.555]                     }
[10:21:45.555]                     else if (inherits(cond, "warning")) {
[10:21:45.555]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.555]                       if (muffled) 
[10:21:45.555]                         invokeRestart("muffleWarning")
[10:21:45.555]                     }
[10:21:45.555]                     else if (inherits(cond, "condition")) {
[10:21:45.555]                       if (!is.null(pattern)) {
[10:21:45.555]                         computeRestarts <- base::computeRestarts
[10:21:45.555]                         grepl <- base::grepl
[10:21:45.555]                         restarts <- computeRestarts(cond)
[10:21:45.555]                         for (restart in restarts) {
[10:21:45.555]                           name <- restart$name
[10:21:45.555]                           if (is.null(name)) 
[10:21:45.555]                             next
[10:21:45.555]                           if (!grepl(pattern, name)) 
[10:21:45.555]                             next
[10:21:45.555]                           invokeRestart(restart)
[10:21:45.555]                           muffled <- TRUE
[10:21:45.555]                           break
[10:21:45.555]                         }
[10:21:45.555]                       }
[10:21:45.555]                     }
[10:21:45.555]                     invisible(muffled)
[10:21:45.555]                   }
[10:21:45.555]                   muffleCondition(cond)
[10:21:45.555]                 })
[10:21:45.555]             }))
[10:21:45.555]             future::FutureResult(value = ...future.value$value, 
[10:21:45.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.555]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.555]                     ...future.globalenv.names))
[10:21:45.555]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.555]         }, condition = base::local({
[10:21:45.555]             c <- base::c
[10:21:45.555]             inherits <- base::inherits
[10:21:45.555]             invokeRestart <- base::invokeRestart
[10:21:45.555]             length <- base::length
[10:21:45.555]             list <- base::list
[10:21:45.555]             seq.int <- base::seq.int
[10:21:45.555]             signalCondition <- base::signalCondition
[10:21:45.555]             sys.calls <- base::sys.calls
[10:21:45.555]             `[[` <- base::`[[`
[10:21:45.555]             `+` <- base::`+`
[10:21:45.555]             `<<-` <- base::`<<-`
[10:21:45.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.555]                   3L)]
[10:21:45.555]             }
[10:21:45.555]             function(cond) {
[10:21:45.555]                 is_error <- inherits(cond, "error")
[10:21:45.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.555]                   NULL)
[10:21:45.555]                 if (is_error) {
[10:21:45.555]                   sessionInformation <- function() {
[10:21:45.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.555]                       search = base::search(), system = base::Sys.info())
[10:21:45.555]                   }
[10:21:45.555]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.555]                     cond$call), session = sessionInformation(), 
[10:21:45.555]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.555]                   signalCondition(cond)
[10:21:45.555]                 }
[10:21:45.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.555]                 "immediateCondition"))) {
[10:21:45.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.555]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.555]                   if (TRUE && !signal) {
[10:21:45.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.555]                     {
[10:21:45.555]                       inherits <- base::inherits
[10:21:45.555]                       invokeRestart <- base::invokeRestart
[10:21:45.555]                       is.null <- base::is.null
[10:21:45.555]                       muffled <- FALSE
[10:21:45.555]                       if (inherits(cond, "message")) {
[10:21:45.555]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.555]                         if (muffled) 
[10:21:45.555]                           invokeRestart("muffleMessage")
[10:21:45.555]                       }
[10:21:45.555]                       else if (inherits(cond, "warning")) {
[10:21:45.555]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.555]                         if (muffled) 
[10:21:45.555]                           invokeRestart("muffleWarning")
[10:21:45.555]                       }
[10:21:45.555]                       else if (inherits(cond, "condition")) {
[10:21:45.555]                         if (!is.null(pattern)) {
[10:21:45.555]                           computeRestarts <- base::computeRestarts
[10:21:45.555]                           grepl <- base::grepl
[10:21:45.555]                           restarts <- computeRestarts(cond)
[10:21:45.555]                           for (restart in restarts) {
[10:21:45.555]                             name <- restart$name
[10:21:45.555]                             if (is.null(name)) 
[10:21:45.555]                               next
[10:21:45.555]                             if (!grepl(pattern, name)) 
[10:21:45.555]                               next
[10:21:45.555]                             invokeRestart(restart)
[10:21:45.555]                             muffled <- TRUE
[10:21:45.555]                             break
[10:21:45.555]                           }
[10:21:45.555]                         }
[10:21:45.555]                       }
[10:21:45.555]                       invisible(muffled)
[10:21:45.555]                     }
[10:21:45.555]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.555]                   }
[10:21:45.555]                 }
[10:21:45.555]                 else {
[10:21:45.555]                   if (TRUE) {
[10:21:45.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.555]                     {
[10:21:45.555]                       inherits <- base::inherits
[10:21:45.555]                       invokeRestart <- base::invokeRestart
[10:21:45.555]                       is.null <- base::is.null
[10:21:45.555]                       muffled <- FALSE
[10:21:45.555]                       if (inherits(cond, "message")) {
[10:21:45.555]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.555]                         if (muffled) 
[10:21:45.555]                           invokeRestart("muffleMessage")
[10:21:45.555]                       }
[10:21:45.555]                       else if (inherits(cond, "warning")) {
[10:21:45.555]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.555]                         if (muffled) 
[10:21:45.555]                           invokeRestart("muffleWarning")
[10:21:45.555]                       }
[10:21:45.555]                       else if (inherits(cond, "condition")) {
[10:21:45.555]                         if (!is.null(pattern)) {
[10:21:45.555]                           computeRestarts <- base::computeRestarts
[10:21:45.555]                           grepl <- base::grepl
[10:21:45.555]                           restarts <- computeRestarts(cond)
[10:21:45.555]                           for (restart in restarts) {
[10:21:45.555]                             name <- restart$name
[10:21:45.555]                             if (is.null(name)) 
[10:21:45.555]                               next
[10:21:45.555]                             if (!grepl(pattern, name)) 
[10:21:45.555]                               next
[10:21:45.555]                             invokeRestart(restart)
[10:21:45.555]                             muffled <- TRUE
[10:21:45.555]                             break
[10:21:45.555]                           }
[10:21:45.555]                         }
[10:21:45.555]                       }
[10:21:45.555]                       invisible(muffled)
[10:21:45.555]                     }
[10:21:45.555]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.555]                   }
[10:21:45.555]                 }
[10:21:45.555]             }
[10:21:45.555]         }))
[10:21:45.555]     }, error = function(ex) {
[10:21:45.555]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.555]                 ...future.rng), started = ...future.startTime, 
[10:21:45.555]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.555]             version = "1.8"), class = "FutureResult")
[10:21:45.555]     }, finally = {
[10:21:45.555]         if (!identical(...future.workdir, getwd())) 
[10:21:45.555]             setwd(...future.workdir)
[10:21:45.555]         {
[10:21:45.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.555]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.555]             }
[10:21:45.555]             base::options(...future.oldOptions)
[10:21:45.555]             if (.Platform$OS.type == "windows") {
[10:21:45.555]                 old_names <- names(...future.oldEnvVars)
[10:21:45.555]                 envs <- base::Sys.getenv()
[10:21:45.555]                 names <- names(envs)
[10:21:45.555]                 common <- intersect(names, old_names)
[10:21:45.555]                 added <- setdiff(names, old_names)
[10:21:45.555]                 removed <- setdiff(old_names, names)
[10:21:45.555]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.555]                   envs[common]]
[10:21:45.555]                 NAMES <- toupper(changed)
[10:21:45.555]                 args <- list()
[10:21:45.555]                 for (kk in seq_along(NAMES)) {
[10:21:45.555]                   name <- changed[[kk]]
[10:21:45.555]                   NAME <- NAMES[[kk]]
[10:21:45.555]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.555]                     next
[10:21:45.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.555]                 }
[10:21:45.555]                 NAMES <- toupper(added)
[10:21:45.555]                 for (kk in seq_along(NAMES)) {
[10:21:45.555]                   name <- added[[kk]]
[10:21:45.555]                   NAME <- NAMES[[kk]]
[10:21:45.555]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.555]                     next
[10:21:45.555]                   args[[name]] <- ""
[10:21:45.555]                 }
[10:21:45.555]                 NAMES <- toupper(removed)
[10:21:45.555]                 for (kk in seq_along(NAMES)) {
[10:21:45.555]                   name <- removed[[kk]]
[10:21:45.555]                   NAME <- NAMES[[kk]]
[10:21:45.555]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.555]                     next
[10:21:45.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.555]                 }
[10:21:45.555]                 if (length(args) > 0) 
[10:21:45.555]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.555]             }
[10:21:45.555]             else {
[10:21:45.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.555]             }
[10:21:45.555]             {
[10:21:45.555]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.555]                   0L) {
[10:21:45.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.555]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.555]                   base::options(opts)
[10:21:45.555]                 }
[10:21:45.555]                 {
[10:21:45.555]                   {
[10:21:45.555]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.555]                     NULL
[10:21:45.555]                   }
[10:21:45.555]                   options(future.plan = NULL)
[10:21:45.555]                   if (is.na(NA_character_)) 
[10:21:45.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.555]                     .init = FALSE)
[10:21:45.555]                 }
[10:21:45.555]             }
[10:21:45.555]         }
[10:21:45.555]     })
[10:21:45.555]     if (TRUE) {
[10:21:45.555]         base::sink(type = "output", split = FALSE)
[10:21:45.555]         if (TRUE) {
[10:21:45.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.555]         }
[10:21:45.555]         else {
[10:21:45.555]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.555]         }
[10:21:45.555]         base::close(...future.stdout)
[10:21:45.555]         ...future.stdout <- NULL
[10:21:45.555]     }
[10:21:45.555]     ...future.result$conditions <- ...future.conditions
[10:21:45.555]     ...future.result$finished <- base::Sys.time()
[10:21:45.555]     ...future.result
[10:21:45.555] }
[10:21:45.557] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:21:45.557] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:45.558] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:45.558] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:21:45.558] MultisessionFuture started
[10:21:45.558] - Launch lazy future ... done
[10:21:45.559] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.559] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.559] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.560] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.561] Searching for globals ... DONE
[10:21:45.561] Resolving globals: TRUE
[10:21:45.561] Resolving any globals that are futures ...
[10:21:45.561] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.561] Resolving any globals that are futures ... DONE
[10:21:45.561] Resolving futures part of globals (recursively) ...
[10:21:45.562] resolve() on list ...
[10:21:45.562]  recursive: 99
[10:21:45.562]  length: 1
[10:21:45.562]  elements: ‘ii’
[10:21:45.562]  length: 0 (resolved future 1)
[10:21:45.562] resolve() on list ... DONE
[10:21:45.562] - globals: [1] ‘ii’
[10:21:45.562] Resolving futures part of globals (recursively) ... DONE
[10:21:45.562] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:45.563] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:45.563] - globals: [1] ‘ii’
[10:21:45.563] 
[10:21:45.563] getGlobalsAndPackages() ... DONE
[10:21:45.563] run() for ‘Future’ ...
[10:21:45.563] - state: ‘created’
[10:21:45.563] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.577]   - Field: ‘node’
[10:21:45.577]   - Field: ‘label’
[10:21:45.578]   - Field: ‘local’
[10:21:45.578]   - Field: ‘owner’
[10:21:45.578]   - Field: ‘envir’
[10:21:45.578]   - Field: ‘workers’
[10:21:45.578]   - Field: ‘packages’
[10:21:45.578]   - Field: ‘gc’
[10:21:45.578]   - Field: ‘conditions’
[10:21:45.578]   - Field: ‘persistent’
[10:21:45.578]   - Field: ‘expr’
[10:21:45.578]   - Field: ‘uuid’
[10:21:45.578]   - Field: ‘seed’
[10:21:45.579]   - Field: ‘version’
[10:21:45.579]   - Field: ‘result’
[10:21:45.579]   - Field: ‘asynchronous’
[10:21:45.579]   - Field: ‘calls’
[10:21:45.579]   - Field: ‘globals’
[10:21:45.579]   - Field: ‘stdout’
[10:21:45.579]   - Field: ‘earlySignal’
[10:21:45.579]   - Field: ‘lazy’
[10:21:45.579]   - Field: ‘state’
[10:21:45.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.579] - Launch lazy future ...
[10:21:45.580] Packages needed by the future expression (n = 0): <none>
[10:21:45.580] Packages needed by future strategies (n = 0): <none>
[10:21:45.580] {
[10:21:45.580]     {
[10:21:45.580]         {
[10:21:45.580]             ...future.startTime <- base::Sys.time()
[10:21:45.580]             {
[10:21:45.580]                 {
[10:21:45.580]                   {
[10:21:45.580]                     {
[10:21:45.580]                       base::local({
[10:21:45.580]                         has_future <- base::requireNamespace("future", 
[10:21:45.580]                           quietly = TRUE)
[10:21:45.580]                         if (has_future) {
[10:21:45.580]                           ns <- base::getNamespace("future")
[10:21:45.580]                           version <- ns[[".package"]][["version"]]
[10:21:45.580]                           if (is.null(version)) 
[10:21:45.580]                             version <- utils::packageVersion("future")
[10:21:45.580]                         }
[10:21:45.580]                         else {
[10:21:45.580]                           version <- NULL
[10:21:45.580]                         }
[10:21:45.580]                         if (!has_future || version < "1.8.0") {
[10:21:45.580]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.580]                             "", base::R.version$version.string), 
[10:21:45.580]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.580]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.580]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.580]                               "release", "version")], collapse = " "), 
[10:21:45.580]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.580]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.580]                             info)
[10:21:45.580]                           info <- base::paste(info, collapse = "; ")
[10:21:45.580]                           if (!has_future) {
[10:21:45.580]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.580]                               info)
[10:21:45.580]                           }
[10:21:45.580]                           else {
[10:21:45.580]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.580]                               info, version)
[10:21:45.580]                           }
[10:21:45.580]                           base::stop(msg)
[10:21:45.580]                         }
[10:21:45.580]                       })
[10:21:45.580]                     }
[10:21:45.580]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.580]                     base::options(mc.cores = 1L)
[10:21:45.580]                   }
[10:21:45.580]                   ...future.strategy.old <- future::plan("list")
[10:21:45.580]                   options(future.plan = NULL)
[10:21:45.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.580]                 }
[10:21:45.580]                 ...future.workdir <- getwd()
[10:21:45.580]             }
[10:21:45.580]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.580]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.580]         }
[10:21:45.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.580]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.580]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.580]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.580]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.580]             base::names(...future.oldOptions))
[10:21:45.580]     }
[10:21:45.580]     if (FALSE) {
[10:21:45.580]     }
[10:21:45.580]     else {
[10:21:45.580]         if (TRUE) {
[10:21:45.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.580]                 open = "w")
[10:21:45.580]         }
[10:21:45.580]         else {
[10:21:45.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.580]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.580]         }
[10:21:45.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.580]             base::sink(type = "output", split = FALSE)
[10:21:45.580]             base::close(...future.stdout)
[10:21:45.580]         }, add = TRUE)
[10:21:45.580]     }
[10:21:45.580]     ...future.frame <- base::sys.nframe()
[10:21:45.580]     ...future.conditions <- base::list()
[10:21:45.580]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.580]     if (FALSE) {
[10:21:45.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.580]     }
[10:21:45.580]     ...future.result <- base::tryCatch({
[10:21:45.580]         base::withCallingHandlers({
[10:21:45.580]             ...future.value <- base::withVisible(base::local({
[10:21:45.580]                 ...future.makeSendCondition <- base::local({
[10:21:45.580]                   sendCondition <- NULL
[10:21:45.580]                   function(frame = 1L) {
[10:21:45.580]                     if (is.function(sendCondition)) 
[10:21:45.580]                       return(sendCondition)
[10:21:45.580]                     ns <- getNamespace("parallel")
[10:21:45.580]                     if (exists("sendData", mode = "function", 
[10:21:45.580]                       envir = ns)) {
[10:21:45.580]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.580]                         envir = ns)
[10:21:45.580]                       envir <- sys.frame(frame)
[10:21:45.580]                       master <- NULL
[10:21:45.580]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.580]                         !identical(envir, emptyenv())) {
[10:21:45.580]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.580]                           inherits = FALSE)) {
[10:21:45.580]                           master <- get("master", mode = "list", 
[10:21:45.580]                             envir = envir, inherits = FALSE)
[10:21:45.580]                           if (inherits(master, c("SOCKnode", 
[10:21:45.580]                             "SOCK0node"))) {
[10:21:45.580]                             sendCondition <<- function(cond) {
[10:21:45.580]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.580]                                 success = TRUE)
[10:21:45.580]                               parallel_sendData(master, data)
[10:21:45.580]                             }
[10:21:45.580]                             return(sendCondition)
[10:21:45.580]                           }
[10:21:45.580]                         }
[10:21:45.580]                         frame <- frame + 1L
[10:21:45.580]                         envir <- sys.frame(frame)
[10:21:45.580]                       }
[10:21:45.580]                     }
[10:21:45.580]                     sendCondition <<- function(cond) NULL
[10:21:45.580]                   }
[10:21:45.580]                 })
[10:21:45.580]                 withCallingHandlers({
[10:21:45.580]                   {
[10:21:45.580]                     b <- a * ii
[10:21:45.580]                     a <- 0
[10:21:45.580]                     b
[10:21:45.580]                   }
[10:21:45.580]                 }, immediateCondition = function(cond) {
[10:21:45.580]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.580]                   sendCondition(cond)
[10:21:45.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.580]                   {
[10:21:45.580]                     inherits <- base::inherits
[10:21:45.580]                     invokeRestart <- base::invokeRestart
[10:21:45.580]                     is.null <- base::is.null
[10:21:45.580]                     muffled <- FALSE
[10:21:45.580]                     if (inherits(cond, "message")) {
[10:21:45.580]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.580]                       if (muffled) 
[10:21:45.580]                         invokeRestart("muffleMessage")
[10:21:45.580]                     }
[10:21:45.580]                     else if (inherits(cond, "warning")) {
[10:21:45.580]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.580]                       if (muffled) 
[10:21:45.580]                         invokeRestart("muffleWarning")
[10:21:45.580]                     }
[10:21:45.580]                     else if (inherits(cond, "condition")) {
[10:21:45.580]                       if (!is.null(pattern)) {
[10:21:45.580]                         computeRestarts <- base::computeRestarts
[10:21:45.580]                         grepl <- base::grepl
[10:21:45.580]                         restarts <- computeRestarts(cond)
[10:21:45.580]                         for (restart in restarts) {
[10:21:45.580]                           name <- restart$name
[10:21:45.580]                           if (is.null(name)) 
[10:21:45.580]                             next
[10:21:45.580]                           if (!grepl(pattern, name)) 
[10:21:45.580]                             next
[10:21:45.580]                           invokeRestart(restart)
[10:21:45.580]                           muffled <- TRUE
[10:21:45.580]                           break
[10:21:45.580]                         }
[10:21:45.580]                       }
[10:21:45.580]                     }
[10:21:45.580]                     invisible(muffled)
[10:21:45.580]                   }
[10:21:45.580]                   muffleCondition(cond)
[10:21:45.580]                 })
[10:21:45.580]             }))
[10:21:45.580]             future::FutureResult(value = ...future.value$value, 
[10:21:45.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.580]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.580]                     ...future.globalenv.names))
[10:21:45.580]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.580]         }, condition = base::local({
[10:21:45.580]             c <- base::c
[10:21:45.580]             inherits <- base::inherits
[10:21:45.580]             invokeRestart <- base::invokeRestart
[10:21:45.580]             length <- base::length
[10:21:45.580]             list <- base::list
[10:21:45.580]             seq.int <- base::seq.int
[10:21:45.580]             signalCondition <- base::signalCondition
[10:21:45.580]             sys.calls <- base::sys.calls
[10:21:45.580]             `[[` <- base::`[[`
[10:21:45.580]             `+` <- base::`+`
[10:21:45.580]             `<<-` <- base::`<<-`
[10:21:45.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.580]                   3L)]
[10:21:45.580]             }
[10:21:45.580]             function(cond) {
[10:21:45.580]                 is_error <- inherits(cond, "error")
[10:21:45.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.580]                   NULL)
[10:21:45.580]                 if (is_error) {
[10:21:45.580]                   sessionInformation <- function() {
[10:21:45.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.580]                       search = base::search(), system = base::Sys.info())
[10:21:45.580]                   }
[10:21:45.580]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.580]                     cond$call), session = sessionInformation(), 
[10:21:45.580]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.580]                   signalCondition(cond)
[10:21:45.580]                 }
[10:21:45.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.580]                 "immediateCondition"))) {
[10:21:45.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.580]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.580]                   if (TRUE && !signal) {
[10:21:45.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.580]                     {
[10:21:45.580]                       inherits <- base::inherits
[10:21:45.580]                       invokeRestart <- base::invokeRestart
[10:21:45.580]                       is.null <- base::is.null
[10:21:45.580]                       muffled <- FALSE
[10:21:45.580]                       if (inherits(cond, "message")) {
[10:21:45.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.580]                         if (muffled) 
[10:21:45.580]                           invokeRestart("muffleMessage")
[10:21:45.580]                       }
[10:21:45.580]                       else if (inherits(cond, "warning")) {
[10:21:45.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.580]                         if (muffled) 
[10:21:45.580]                           invokeRestart("muffleWarning")
[10:21:45.580]                       }
[10:21:45.580]                       else if (inherits(cond, "condition")) {
[10:21:45.580]                         if (!is.null(pattern)) {
[10:21:45.580]                           computeRestarts <- base::computeRestarts
[10:21:45.580]                           grepl <- base::grepl
[10:21:45.580]                           restarts <- computeRestarts(cond)
[10:21:45.580]                           for (restart in restarts) {
[10:21:45.580]                             name <- restart$name
[10:21:45.580]                             if (is.null(name)) 
[10:21:45.580]                               next
[10:21:45.580]                             if (!grepl(pattern, name)) 
[10:21:45.580]                               next
[10:21:45.580]                             invokeRestart(restart)
[10:21:45.580]                             muffled <- TRUE
[10:21:45.580]                             break
[10:21:45.580]                           }
[10:21:45.580]                         }
[10:21:45.580]                       }
[10:21:45.580]                       invisible(muffled)
[10:21:45.580]                     }
[10:21:45.580]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.580]                   }
[10:21:45.580]                 }
[10:21:45.580]                 else {
[10:21:45.580]                   if (TRUE) {
[10:21:45.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.580]                     {
[10:21:45.580]                       inherits <- base::inherits
[10:21:45.580]                       invokeRestart <- base::invokeRestart
[10:21:45.580]                       is.null <- base::is.null
[10:21:45.580]                       muffled <- FALSE
[10:21:45.580]                       if (inherits(cond, "message")) {
[10:21:45.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.580]                         if (muffled) 
[10:21:45.580]                           invokeRestart("muffleMessage")
[10:21:45.580]                       }
[10:21:45.580]                       else if (inherits(cond, "warning")) {
[10:21:45.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.580]                         if (muffled) 
[10:21:45.580]                           invokeRestart("muffleWarning")
[10:21:45.580]                       }
[10:21:45.580]                       else if (inherits(cond, "condition")) {
[10:21:45.580]                         if (!is.null(pattern)) {
[10:21:45.580]                           computeRestarts <- base::computeRestarts
[10:21:45.580]                           grepl <- base::grepl
[10:21:45.580]                           restarts <- computeRestarts(cond)
[10:21:45.580]                           for (restart in restarts) {
[10:21:45.580]                             name <- restart$name
[10:21:45.580]                             if (is.null(name)) 
[10:21:45.580]                               next
[10:21:45.580]                             if (!grepl(pattern, name)) 
[10:21:45.580]                               next
[10:21:45.580]                             invokeRestart(restart)
[10:21:45.580]                             muffled <- TRUE
[10:21:45.580]                             break
[10:21:45.580]                           }
[10:21:45.580]                         }
[10:21:45.580]                       }
[10:21:45.580]                       invisible(muffled)
[10:21:45.580]                     }
[10:21:45.580]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.580]                   }
[10:21:45.580]                 }
[10:21:45.580]             }
[10:21:45.580]         }))
[10:21:45.580]     }, error = function(ex) {
[10:21:45.580]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.580]                 ...future.rng), started = ...future.startTime, 
[10:21:45.580]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.580]             version = "1.8"), class = "FutureResult")
[10:21:45.580]     }, finally = {
[10:21:45.580]         if (!identical(...future.workdir, getwd())) 
[10:21:45.580]             setwd(...future.workdir)
[10:21:45.580]         {
[10:21:45.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.580]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.580]             }
[10:21:45.580]             base::options(...future.oldOptions)
[10:21:45.580]             if (.Platform$OS.type == "windows") {
[10:21:45.580]                 old_names <- names(...future.oldEnvVars)
[10:21:45.580]                 envs <- base::Sys.getenv()
[10:21:45.580]                 names <- names(envs)
[10:21:45.580]                 common <- intersect(names, old_names)
[10:21:45.580]                 added <- setdiff(names, old_names)
[10:21:45.580]                 removed <- setdiff(old_names, names)
[10:21:45.580]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.580]                   envs[common]]
[10:21:45.580]                 NAMES <- toupper(changed)
[10:21:45.580]                 args <- list()
[10:21:45.580]                 for (kk in seq_along(NAMES)) {
[10:21:45.580]                   name <- changed[[kk]]
[10:21:45.580]                   NAME <- NAMES[[kk]]
[10:21:45.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.580]                     next
[10:21:45.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.580]                 }
[10:21:45.580]                 NAMES <- toupper(added)
[10:21:45.580]                 for (kk in seq_along(NAMES)) {
[10:21:45.580]                   name <- added[[kk]]
[10:21:45.580]                   NAME <- NAMES[[kk]]
[10:21:45.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.580]                     next
[10:21:45.580]                   args[[name]] <- ""
[10:21:45.580]                 }
[10:21:45.580]                 NAMES <- toupper(removed)
[10:21:45.580]                 for (kk in seq_along(NAMES)) {
[10:21:45.580]                   name <- removed[[kk]]
[10:21:45.580]                   NAME <- NAMES[[kk]]
[10:21:45.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.580]                     next
[10:21:45.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.580]                 }
[10:21:45.580]                 if (length(args) > 0) 
[10:21:45.580]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.580]             }
[10:21:45.580]             else {
[10:21:45.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.580]             }
[10:21:45.580]             {
[10:21:45.580]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.580]                   0L) {
[10:21:45.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.580]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.580]                   base::options(opts)
[10:21:45.580]                 }
[10:21:45.580]                 {
[10:21:45.580]                   {
[10:21:45.580]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.580]                     NULL
[10:21:45.580]                   }
[10:21:45.580]                   options(future.plan = NULL)
[10:21:45.580]                   if (is.na(NA_character_)) 
[10:21:45.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.580]                     .init = FALSE)
[10:21:45.580]                 }
[10:21:45.580]             }
[10:21:45.580]         }
[10:21:45.580]     })
[10:21:45.580]     if (TRUE) {
[10:21:45.580]         base::sink(type = "output", split = FALSE)
[10:21:45.580]         if (TRUE) {
[10:21:45.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.580]         }
[10:21:45.580]         else {
[10:21:45.580]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.580]         }
[10:21:45.580]         base::close(...future.stdout)
[10:21:45.580]         ...future.stdout <- NULL
[10:21:45.580]     }
[10:21:45.580]     ...future.result$conditions <- ...future.conditions
[10:21:45.580]     ...future.result$finished <- base::Sys.time()
[10:21:45.580]     ...future.result
[10:21:45.580] }
[10:21:45.632] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[10:21:45.632] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[10:21:45.633] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[10:21:45.633] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[10:21:45.633] MultisessionFuture started
[10:21:45.633] - Launch lazy future ... done
[10:21:45.633] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.634] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.634] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.636] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.636] Searching for globals ... DONE
[10:21:45.636] Resolving globals: TRUE
[10:21:45.636] Resolving any globals that are futures ...
[10:21:45.636] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.636] Resolving any globals that are futures ... DONE
[10:21:45.636] Resolving futures part of globals (recursively) ...
[10:21:45.637] resolve() on list ...
[10:21:45.637]  recursive: 99
[10:21:45.637]  length: 1
[10:21:45.637]  elements: ‘ii’
[10:21:45.637]  length: 0 (resolved future 1)
[10:21:45.637] resolve() on list ... DONE
[10:21:45.637] - globals: [1] ‘ii’
[10:21:45.637] Resolving futures part of globals (recursively) ... DONE
[10:21:45.638] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:45.638] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:45.638] - globals: [1] ‘ii’
[10:21:45.638] 
[10:21:45.638] getGlobalsAndPackages() ... DONE
[10:21:45.639] run() for ‘Future’ ...
[10:21:45.639] - state: ‘created’
[10:21:45.639] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.655] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.656] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.656]   - Field: ‘node’
[10:21:45.656]   - Field: ‘label’
[10:21:45.656]   - Field: ‘local’
[10:21:45.656]   - Field: ‘owner’
[10:21:45.656]   - Field: ‘envir’
[10:21:45.656]   - Field: ‘workers’
[10:21:45.656]   - Field: ‘packages’
[10:21:45.656]   - Field: ‘gc’
[10:21:45.656]   - Field: ‘conditions’
[10:21:45.657]   - Field: ‘persistent’
[10:21:45.657]   - Field: ‘expr’
[10:21:45.657]   - Field: ‘uuid’
[10:21:45.657]   - Field: ‘seed’
[10:21:45.657]   - Field: ‘version’
[10:21:45.657]   - Field: ‘result’
[10:21:45.657]   - Field: ‘asynchronous’
[10:21:45.657]   - Field: ‘calls’
[10:21:45.657]   - Field: ‘globals’
[10:21:45.657]   - Field: ‘stdout’
[10:21:45.657]   - Field: ‘earlySignal’
[10:21:45.657]   - Field: ‘lazy’
[10:21:45.658]   - Field: ‘state’
[10:21:45.658] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.658] - Launch lazy future ...
[10:21:45.658] Packages needed by the future expression (n = 0): <none>
[10:21:45.658] Packages needed by future strategies (n = 0): <none>
[10:21:45.659] {
[10:21:45.659]     {
[10:21:45.659]         {
[10:21:45.659]             ...future.startTime <- base::Sys.time()
[10:21:45.659]             {
[10:21:45.659]                 {
[10:21:45.659]                   {
[10:21:45.659]                     {
[10:21:45.659]                       base::local({
[10:21:45.659]                         has_future <- base::requireNamespace("future", 
[10:21:45.659]                           quietly = TRUE)
[10:21:45.659]                         if (has_future) {
[10:21:45.659]                           ns <- base::getNamespace("future")
[10:21:45.659]                           version <- ns[[".package"]][["version"]]
[10:21:45.659]                           if (is.null(version)) 
[10:21:45.659]                             version <- utils::packageVersion("future")
[10:21:45.659]                         }
[10:21:45.659]                         else {
[10:21:45.659]                           version <- NULL
[10:21:45.659]                         }
[10:21:45.659]                         if (!has_future || version < "1.8.0") {
[10:21:45.659]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.659]                             "", base::R.version$version.string), 
[10:21:45.659]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.659]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.659]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.659]                               "release", "version")], collapse = " "), 
[10:21:45.659]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.659]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.659]                             info)
[10:21:45.659]                           info <- base::paste(info, collapse = "; ")
[10:21:45.659]                           if (!has_future) {
[10:21:45.659]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.659]                               info)
[10:21:45.659]                           }
[10:21:45.659]                           else {
[10:21:45.659]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.659]                               info, version)
[10:21:45.659]                           }
[10:21:45.659]                           base::stop(msg)
[10:21:45.659]                         }
[10:21:45.659]                       })
[10:21:45.659]                     }
[10:21:45.659]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.659]                     base::options(mc.cores = 1L)
[10:21:45.659]                   }
[10:21:45.659]                   ...future.strategy.old <- future::plan("list")
[10:21:45.659]                   options(future.plan = NULL)
[10:21:45.659]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.659]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.659]                 }
[10:21:45.659]                 ...future.workdir <- getwd()
[10:21:45.659]             }
[10:21:45.659]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.659]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.659]         }
[10:21:45.659]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.659]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.659]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.659]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.659]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.659]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.659]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.659]             base::names(...future.oldOptions))
[10:21:45.659]     }
[10:21:45.659]     if (FALSE) {
[10:21:45.659]     }
[10:21:45.659]     else {
[10:21:45.659]         if (TRUE) {
[10:21:45.659]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.659]                 open = "w")
[10:21:45.659]         }
[10:21:45.659]         else {
[10:21:45.659]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.659]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.659]         }
[10:21:45.659]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.659]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.659]             base::sink(type = "output", split = FALSE)
[10:21:45.659]             base::close(...future.stdout)
[10:21:45.659]         }, add = TRUE)
[10:21:45.659]     }
[10:21:45.659]     ...future.frame <- base::sys.nframe()
[10:21:45.659]     ...future.conditions <- base::list()
[10:21:45.659]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.659]     if (FALSE) {
[10:21:45.659]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.659]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.659]     }
[10:21:45.659]     ...future.result <- base::tryCatch({
[10:21:45.659]         base::withCallingHandlers({
[10:21:45.659]             ...future.value <- base::withVisible(base::local({
[10:21:45.659]                 ...future.makeSendCondition <- base::local({
[10:21:45.659]                   sendCondition <- NULL
[10:21:45.659]                   function(frame = 1L) {
[10:21:45.659]                     if (is.function(sendCondition)) 
[10:21:45.659]                       return(sendCondition)
[10:21:45.659]                     ns <- getNamespace("parallel")
[10:21:45.659]                     if (exists("sendData", mode = "function", 
[10:21:45.659]                       envir = ns)) {
[10:21:45.659]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.659]                         envir = ns)
[10:21:45.659]                       envir <- sys.frame(frame)
[10:21:45.659]                       master <- NULL
[10:21:45.659]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.659]                         !identical(envir, emptyenv())) {
[10:21:45.659]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.659]                           inherits = FALSE)) {
[10:21:45.659]                           master <- get("master", mode = "list", 
[10:21:45.659]                             envir = envir, inherits = FALSE)
[10:21:45.659]                           if (inherits(master, c("SOCKnode", 
[10:21:45.659]                             "SOCK0node"))) {
[10:21:45.659]                             sendCondition <<- function(cond) {
[10:21:45.659]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.659]                                 success = TRUE)
[10:21:45.659]                               parallel_sendData(master, data)
[10:21:45.659]                             }
[10:21:45.659]                             return(sendCondition)
[10:21:45.659]                           }
[10:21:45.659]                         }
[10:21:45.659]                         frame <- frame + 1L
[10:21:45.659]                         envir <- sys.frame(frame)
[10:21:45.659]                       }
[10:21:45.659]                     }
[10:21:45.659]                     sendCondition <<- function(cond) NULL
[10:21:45.659]                   }
[10:21:45.659]                 })
[10:21:45.659]                 withCallingHandlers({
[10:21:45.659]                   {
[10:21:45.659]                     b <- a * ii
[10:21:45.659]                     a <- 0
[10:21:45.659]                     b
[10:21:45.659]                   }
[10:21:45.659]                 }, immediateCondition = function(cond) {
[10:21:45.659]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.659]                   sendCondition(cond)
[10:21:45.659]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.659]                   {
[10:21:45.659]                     inherits <- base::inherits
[10:21:45.659]                     invokeRestart <- base::invokeRestart
[10:21:45.659]                     is.null <- base::is.null
[10:21:45.659]                     muffled <- FALSE
[10:21:45.659]                     if (inherits(cond, "message")) {
[10:21:45.659]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.659]                       if (muffled) 
[10:21:45.659]                         invokeRestart("muffleMessage")
[10:21:45.659]                     }
[10:21:45.659]                     else if (inherits(cond, "warning")) {
[10:21:45.659]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.659]                       if (muffled) 
[10:21:45.659]                         invokeRestart("muffleWarning")
[10:21:45.659]                     }
[10:21:45.659]                     else if (inherits(cond, "condition")) {
[10:21:45.659]                       if (!is.null(pattern)) {
[10:21:45.659]                         computeRestarts <- base::computeRestarts
[10:21:45.659]                         grepl <- base::grepl
[10:21:45.659]                         restarts <- computeRestarts(cond)
[10:21:45.659]                         for (restart in restarts) {
[10:21:45.659]                           name <- restart$name
[10:21:45.659]                           if (is.null(name)) 
[10:21:45.659]                             next
[10:21:45.659]                           if (!grepl(pattern, name)) 
[10:21:45.659]                             next
[10:21:45.659]                           invokeRestart(restart)
[10:21:45.659]                           muffled <- TRUE
[10:21:45.659]                           break
[10:21:45.659]                         }
[10:21:45.659]                       }
[10:21:45.659]                     }
[10:21:45.659]                     invisible(muffled)
[10:21:45.659]                   }
[10:21:45.659]                   muffleCondition(cond)
[10:21:45.659]                 })
[10:21:45.659]             }))
[10:21:45.659]             future::FutureResult(value = ...future.value$value, 
[10:21:45.659]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.659]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.659]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.659]                     ...future.globalenv.names))
[10:21:45.659]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.659]         }, condition = base::local({
[10:21:45.659]             c <- base::c
[10:21:45.659]             inherits <- base::inherits
[10:21:45.659]             invokeRestart <- base::invokeRestart
[10:21:45.659]             length <- base::length
[10:21:45.659]             list <- base::list
[10:21:45.659]             seq.int <- base::seq.int
[10:21:45.659]             signalCondition <- base::signalCondition
[10:21:45.659]             sys.calls <- base::sys.calls
[10:21:45.659]             `[[` <- base::`[[`
[10:21:45.659]             `+` <- base::`+`
[10:21:45.659]             `<<-` <- base::`<<-`
[10:21:45.659]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.659]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.659]                   3L)]
[10:21:45.659]             }
[10:21:45.659]             function(cond) {
[10:21:45.659]                 is_error <- inherits(cond, "error")
[10:21:45.659]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.659]                   NULL)
[10:21:45.659]                 if (is_error) {
[10:21:45.659]                   sessionInformation <- function() {
[10:21:45.659]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.659]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.659]                       search = base::search(), system = base::Sys.info())
[10:21:45.659]                   }
[10:21:45.659]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.659]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.659]                     cond$call), session = sessionInformation(), 
[10:21:45.659]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.659]                   signalCondition(cond)
[10:21:45.659]                 }
[10:21:45.659]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.659]                 "immediateCondition"))) {
[10:21:45.659]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.659]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.659]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.659]                   if (TRUE && !signal) {
[10:21:45.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.659]                     {
[10:21:45.659]                       inherits <- base::inherits
[10:21:45.659]                       invokeRestart <- base::invokeRestart
[10:21:45.659]                       is.null <- base::is.null
[10:21:45.659]                       muffled <- FALSE
[10:21:45.659]                       if (inherits(cond, "message")) {
[10:21:45.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.659]                         if (muffled) 
[10:21:45.659]                           invokeRestart("muffleMessage")
[10:21:45.659]                       }
[10:21:45.659]                       else if (inherits(cond, "warning")) {
[10:21:45.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.659]                         if (muffled) 
[10:21:45.659]                           invokeRestart("muffleWarning")
[10:21:45.659]                       }
[10:21:45.659]                       else if (inherits(cond, "condition")) {
[10:21:45.659]                         if (!is.null(pattern)) {
[10:21:45.659]                           computeRestarts <- base::computeRestarts
[10:21:45.659]                           grepl <- base::grepl
[10:21:45.659]                           restarts <- computeRestarts(cond)
[10:21:45.659]                           for (restart in restarts) {
[10:21:45.659]                             name <- restart$name
[10:21:45.659]                             if (is.null(name)) 
[10:21:45.659]                               next
[10:21:45.659]                             if (!grepl(pattern, name)) 
[10:21:45.659]                               next
[10:21:45.659]                             invokeRestart(restart)
[10:21:45.659]                             muffled <- TRUE
[10:21:45.659]                             break
[10:21:45.659]                           }
[10:21:45.659]                         }
[10:21:45.659]                       }
[10:21:45.659]                       invisible(muffled)
[10:21:45.659]                     }
[10:21:45.659]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.659]                   }
[10:21:45.659]                 }
[10:21:45.659]                 else {
[10:21:45.659]                   if (TRUE) {
[10:21:45.659]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.659]                     {
[10:21:45.659]                       inherits <- base::inherits
[10:21:45.659]                       invokeRestart <- base::invokeRestart
[10:21:45.659]                       is.null <- base::is.null
[10:21:45.659]                       muffled <- FALSE
[10:21:45.659]                       if (inherits(cond, "message")) {
[10:21:45.659]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.659]                         if (muffled) 
[10:21:45.659]                           invokeRestart("muffleMessage")
[10:21:45.659]                       }
[10:21:45.659]                       else if (inherits(cond, "warning")) {
[10:21:45.659]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.659]                         if (muffled) 
[10:21:45.659]                           invokeRestart("muffleWarning")
[10:21:45.659]                       }
[10:21:45.659]                       else if (inherits(cond, "condition")) {
[10:21:45.659]                         if (!is.null(pattern)) {
[10:21:45.659]                           computeRestarts <- base::computeRestarts
[10:21:45.659]                           grepl <- base::grepl
[10:21:45.659]                           restarts <- computeRestarts(cond)
[10:21:45.659]                           for (restart in restarts) {
[10:21:45.659]                             name <- restart$name
[10:21:45.659]                             if (is.null(name)) 
[10:21:45.659]                               next
[10:21:45.659]                             if (!grepl(pattern, name)) 
[10:21:45.659]                               next
[10:21:45.659]                             invokeRestart(restart)
[10:21:45.659]                             muffled <- TRUE
[10:21:45.659]                             break
[10:21:45.659]                           }
[10:21:45.659]                         }
[10:21:45.659]                       }
[10:21:45.659]                       invisible(muffled)
[10:21:45.659]                     }
[10:21:45.659]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.659]                   }
[10:21:45.659]                 }
[10:21:45.659]             }
[10:21:45.659]         }))
[10:21:45.659]     }, error = function(ex) {
[10:21:45.659]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.659]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.659]                 ...future.rng), started = ...future.startTime, 
[10:21:45.659]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.659]             version = "1.8"), class = "FutureResult")
[10:21:45.659]     }, finally = {
[10:21:45.659]         if (!identical(...future.workdir, getwd())) 
[10:21:45.659]             setwd(...future.workdir)
[10:21:45.659]         {
[10:21:45.659]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.659]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.659]             }
[10:21:45.659]             base::options(...future.oldOptions)
[10:21:45.659]             if (.Platform$OS.type == "windows") {
[10:21:45.659]                 old_names <- names(...future.oldEnvVars)
[10:21:45.659]                 envs <- base::Sys.getenv()
[10:21:45.659]                 names <- names(envs)
[10:21:45.659]                 common <- intersect(names, old_names)
[10:21:45.659]                 added <- setdiff(names, old_names)
[10:21:45.659]                 removed <- setdiff(old_names, names)
[10:21:45.659]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.659]                   envs[common]]
[10:21:45.659]                 NAMES <- toupper(changed)
[10:21:45.659]                 args <- list()
[10:21:45.659]                 for (kk in seq_along(NAMES)) {
[10:21:45.659]                   name <- changed[[kk]]
[10:21:45.659]                   NAME <- NAMES[[kk]]
[10:21:45.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.659]                     next
[10:21:45.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.659]                 }
[10:21:45.659]                 NAMES <- toupper(added)
[10:21:45.659]                 for (kk in seq_along(NAMES)) {
[10:21:45.659]                   name <- added[[kk]]
[10:21:45.659]                   NAME <- NAMES[[kk]]
[10:21:45.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.659]                     next
[10:21:45.659]                   args[[name]] <- ""
[10:21:45.659]                 }
[10:21:45.659]                 NAMES <- toupper(removed)
[10:21:45.659]                 for (kk in seq_along(NAMES)) {
[10:21:45.659]                   name <- removed[[kk]]
[10:21:45.659]                   NAME <- NAMES[[kk]]
[10:21:45.659]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.659]                     next
[10:21:45.659]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.659]                 }
[10:21:45.659]                 if (length(args) > 0) 
[10:21:45.659]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.659]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.659]             }
[10:21:45.659]             else {
[10:21:45.659]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.659]             }
[10:21:45.659]             {
[10:21:45.659]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.659]                   0L) {
[10:21:45.659]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.659]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.659]                   base::options(opts)
[10:21:45.659]                 }
[10:21:45.659]                 {
[10:21:45.659]                   {
[10:21:45.659]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.659]                     NULL
[10:21:45.659]                   }
[10:21:45.659]                   options(future.plan = NULL)
[10:21:45.659]                   if (is.na(NA_character_)) 
[10:21:45.659]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.659]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.659]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.659]                     .init = FALSE)
[10:21:45.659]                 }
[10:21:45.659]             }
[10:21:45.659]         }
[10:21:45.659]     })
[10:21:45.659]     if (TRUE) {
[10:21:45.659]         base::sink(type = "output", split = FALSE)
[10:21:45.659]         if (TRUE) {
[10:21:45.659]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.659]         }
[10:21:45.659]         else {
[10:21:45.659]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.659]         }
[10:21:45.659]         base::close(...future.stdout)
[10:21:45.659]         ...future.stdout <- NULL
[10:21:45.659]     }
[10:21:45.659]     ...future.result$conditions <- ...future.conditions
[10:21:45.659]     ...future.result$finished <- base::Sys.time()
[10:21:45.659]     ...future.result
[10:21:45.659] }
[10:21:45.661] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:45.672] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.672] - Validating connection of MultisessionFuture
[10:21:45.672] - received message: FutureResult
[10:21:45.672] - Received FutureResult
[10:21:45.673] - Erased future from FutureRegistry
[10:21:45.673] result() for ClusterFuture ...
[10:21:45.673] - result already collected: FutureResult
[10:21:45.673] result() for ClusterFuture ... done
[10:21:45.673] signalConditions() ...
[10:21:45.673]  - include = ‘immediateCondition’
[10:21:45.673]  - exclude = 
[10:21:45.673]  - resignal = FALSE
[10:21:45.673]  - Number of conditions: 1
[10:21:45.674] signalConditions() ... done
[10:21:45.674] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:45.674] result() for ClusterFuture ...
[10:21:45.674] - result already collected: FutureResult
[10:21:45.674] result() for ClusterFuture ... done
[10:21:45.674] result() for ClusterFuture ...
[10:21:45.674] - result already collected: FutureResult
[10:21:45.675] result() for ClusterFuture ... done
[10:21:45.675] signalConditions() ...
[10:21:45.675]  - include = ‘immediateCondition’
[10:21:45.675]  - exclude = 
[10:21:45.675]  - resignal = FALSE
[10:21:45.675]  - Number of conditions: 1
[10:21:45.675] signalConditions() ... done
[10:21:45.676] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[10:21:45.677] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:45.677] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:45.677] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[10:21:45.678] MultisessionFuture started
[10:21:45.678] - Launch lazy future ... done
[10:21:45.678] run() for ‘MultisessionFuture’ ... done
[10:21:45.679] result() for ClusterFuture ...
[10:21:45.679] - result already collected: FutureResult
[10:21:45.679] result() for ClusterFuture ... done
[10:21:45.679] result() for ClusterFuture ...
[10:21:45.679] - result already collected: FutureResult
[10:21:45.679] result() for ClusterFuture ... done
[10:21:45.679] signalConditions() ...
[10:21:45.680]  - include = ‘immediateCondition’
[10:21:45.680]  - exclude = 
[10:21:45.680]  - resignal = FALSE
[10:21:45.680]  - Number of conditions: 1
[10:21:45.680] signalConditions() ... done
[10:21:45.680] Future state: ‘finished’
[10:21:45.681] result() for ClusterFuture ...
[10:21:45.681] - result already collected: FutureResult
[10:21:45.681] result() for ClusterFuture ... done
[10:21:45.681] signalConditions() ...
[10:21:45.681]  - include = ‘condition’
[10:21:45.681]  - exclude = ‘immediateCondition’
[10:21:45.681]  - resignal = TRUE
[10:21:45.681]  - Number of conditions: 1
[10:21:45.682]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:45.682] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:45"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.696] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.696] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.698] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.698] Searching for globals ... DONE
[10:21:45.698] Resolving globals: TRUE
[10:21:45.698] Resolving any globals that are futures ...
[10:21:45.698] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.698] Resolving any globals that are futures ... DONE
[10:21:45.699] Resolving futures part of globals (recursively) ...
[10:21:45.699] resolve() on list ...
[10:21:45.699]  recursive: 99
[10:21:45.699]  length: 1
[10:21:45.699]  elements: ‘ii’
[10:21:45.699]  length: 0 (resolved future 1)
[10:21:45.699] resolve() on list ... DONE
[10:21:45.699] - globals: [1] ‘ii’
[10:21:45.699] Resolving futures part of globals (recursively) ... DONE
[10:21:45.700] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:45.700] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:45.700] - globals: [1] ‘ii’
[10:21:45.700] 
[10:21:45.700] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.701] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.701] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.702] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.702] Searching for globals ... DONE
[10:21:45.702] Resolving globals: TRUE
[10:21:45.703] Resolving any globals that are futures ...
[10:21:45.703] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.703] Resolving any globals that are futures ... DONE
[10:21:45.703] Resolving futures part of globals (recursively) ...
[10:21:45.703] resolve() on list ...
[10:21:45.703]  recursive: 99
[10:21:45.704]  length: 1
[10:21:45.704]  elements: ‘ii’
[10:21:45.704]  length: 0 (resolved future 1)
[10:21:45.704] resolve() on list ... DONE
[10:21:45.704] - globals: [1] ‘ii’
[10:21:45.704] Resolving futures part of globals (recursively) ... DONE
[10:21:45.704] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:45.704] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:45.705] - globals: [1] ‘ii’
[10:21:45.705] 
[10:21:45.705] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.705] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.705] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.707] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.707] Searching for globals ... DONE
[10:21:45.707] Resolving globals: TRUE
[10:21:45.707] Resolving any globals that are futures ...
[10:21:45.707] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[10:21:45.707] Resolving any globals that are futures ... DONE
[10:21:45.708] Resolving futures part of globals (recursively) ...
[10:21:45.708] resolve() on list ...
[10:21:45.708]  recursive: 99
[10:21:45.708]  length: 1
[10:21:45.708]  elements: ‘ii’
[10:21:45.708]  length: 0 (resolved future 1)
[10:21:45.708] resolve() on list ... DONE
[10:21:45.708] - globals: [1] ‘ii’
[10:21:45.708] Resolving futures part of globals (recursively) ... DONE
[10:21:45.709] The total size of the 1 globals is 35 bytes (35 bytes)
[10:21:45.709] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[10:21:45.709] - globals: [1] ‘ii’
[10:21:45.709] 
[10:21:45.709] getGlobalsAndPackages() ... DONE
[10:21:45.709] run() for ‘Future’ ...
[10:21:45.710] - state: ‘created’
[10:21:45.710] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.725] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.725] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.725]   - Field: ‘node’
[10:21:45.725]   - Field: ‘label’
[10:21:45.725]   - Field: ‘local’
[10:21:45.725]   - Field: ‘owner’
[10:21:45.725]   - Field: ‘envir’
[10:21:45.725]   - Field: ‘workers’
[10:21:45.725]   - Field: ‘packages’
[10:21:45.725]   - Field: ‘gc’
[10:21:45.726]   - Field: ‘conditions’
[10:21:45.726]   - Field: ‘persistent’
[10:21:45.726]   - Field: ‘expr’
[10:21:45.726]   - Field: ‘uuid’
[10:21:45.726]   - Field: ‘seed’
[10:21:45.726]   - Field: ‘version’
[10:21:45.726]   - Field: ‘result’
[10:21:45.726]   - Field: ‘asynchronous’
[10:21:45.726]   - Field: ‘calls’
[10:21:45.726]   - Field: ‘globals’
[10:21:45.726]   - Field: ‘stdout’
[10:21:45.726]   - Field: ‘earlySignal’
[10:21:45.727]   - Field: ‘lazy’
[10:21:45.727]   - Field: ‘state’
[10:21:45.727] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.727] - Launch lazy future ...
[10:21:45.727] Packages needed by the future expression (n = 0): <none>
[10:21:45.727] Packages needed by future strategies (n = 0): <none>
[10:21:45.728] {
[10:21:45.728]     {
[10:21:45.728]         {
[10:21:45.728]             ...future.startTime <- base::Sys.time()
[10:21:45.728]             {
[10:21:45.728]                 {
[10:21:45.728]                   {
[10:21:45.728]                     {
[10:21:45.728]                       base::local({
[10:21:45.728]                         has_future <- base::requireNamespace("future", 
[10:21:45.728]                           quietly = TRUE)
[10:21:45.728]                         if (has_future) {
[10:21:45.728]                           ns <- base::getNamespace("future")
[10:21:45.728]                           version <- ns[[".package"]][["version"]]
[10:21:45.728]                           if (is.null(version)) 
[10:21:45.728]                             version <- utils::packageVersion("future")
[10:21:45.728]                         }
[10:21:45.728]                         else {
[10:21:45.728]                           version <- NULL
[10:21:45.728]                         }
[10:21:45.728]                         if (!has_future || version < "1.8.0") {
[10:21:45.728]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.728]                             "", base::R.version$version.string), 
[10:21:45.728]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.728]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.728]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.728]                               "release", "version")], collapse = " "), 
[10:21:45.728]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.728]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.728]                             info)
[10:21:45.728]                           info <- base::paste(info, collapse = "; ")
[10:21:45.728]                           if (!has_future) {
[10:21:45.728]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.728]                               info)
[10:21:45.728]                           }
[10:21:45.728]                           else {
[10:21:45.728]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.728]                               info, version)
[10:21:45.728]                           }
[10:21:45.728]                           base::stop(msg)
[10:21:45.728]                         }
[10:21:45.728]                       })
[10:21:45.728]                     }
[10:21:45.728]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.728]                     base::options(mc.cores = 1L)
[10:21:45.728]                   }
[10:21:45.728]                   ...future.strategy.old <- future::plan("list")
[10:21:45.728]                   options(future.plan = NULL)
[10:21:45.728]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.728]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.728]                 }
[10:21:45.728]                 ...future.workdir <- getwd()
[10:21:45.728]             }
[10:21:45.728]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.728]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.728]         }
[10:21:45.728]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.728]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.728]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.728]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.728]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.728]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.728]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.728]             base::names(...future.oldOptions))
[10:21:45.728]     }
[10:21:45.728]     if (FALSE) {
[10:21:45.728]     }
[10:21:45.728]     else {
[10:21:45.728]         if (TRUE) {
[10:21:45.728]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.728]                 open = "w")
[10:21:45.728]         }
[10:21:45.728]         else {
[10:21:45.728]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.728]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.728]         }
[10:21:45.728]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.728]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.728]             base::sink(type = "output", split = FALSE)
[10:21:45.728]             base::close(...future.stdout)
[10:21:45.728]         }, add = TRUE)
[10:21:45.728]     }
[10:21:45.728]     ...future.frame <- base::sys.nframe()
[10:21:45.728]     ...future.conditions <- base::list()
[10:21:45.728]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.728]     if (FALSE) {
[10:21:45.728]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.728]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.728]     }
[10:21:45.728]     ...future.result <- base::tryCatch({
[10:21:45.728]         base::withCallingHandlers({
[10:21:45.728]             ...future.value <- base::withVisible(base::local({
[10:21:45.728]                 ...future.makeSendCondition <- base::local({
[10:21:45.728]                   sendCondition <- NULL
[10:21:45.728]                   function(frame = 1L) {
[10:21:45.728]                     if (is.function(sendCondition)) 
[10:21:45.728]                       return(sendCondition)
[10:21:45.728]                     ns <- getNamespace("parallel")
[10:21:45.728]                     if (exists("sendData", mode = "function", 
[10:21:45.728]                       envir = ns)) {
[10:21:45.728]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.728]                         envir = ns)
[10:21:45.728]                       envir <- sys.frame(frame)
[10:21:45.728]                       master <- NULL
[10:21:45.728]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.728]                         !identical(envir, emptyenv())) {
[10:21:45.728]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.728]                           inherits = FALSE)) {
[10:21:45.728]                           master <- get("master", mode = "list", 
[10:21:45.728]                             envir = envir, inherits = FALSE)
[10:21:45.728]                           if (inherits(master, c("SOCKnode", 
[10:21:45.728]                             "SOCK0node"))) {
[10:21:45.728]                             sendCondition <<- function(cond) {
[10:21:45.728]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.728]                                 success = TRUE)
[10:21:45.728]                               parallel_sendData(master, data)
[10:21:45.728]                             }
[10:21:45.728]                             return(sendCondition)
[10:21:45.728]                           }
[10:21:45.728]                         }
[10:21:45.728]                         frame <- frame + 1L
[10:21:45.728]                         envir <- sys.frame(frame)
[10:21:45.728]                       }
[10:21:45.728]                     }
[10:21:45.728]                     sendCondition <<- function(cond) NULL
[10:21:45.728]                   }
[10:21:45.728]                 })
[10:21:45.728]                 withCallingHandlers({
[10:21:45.728]                   {
[10:21:45.728]                     b <- a * ii
[10:21:45.728]                     a <- 0
[10:21:45.728]                     b
[10:21:45.728]                   }
[10:21:45.728]                 }, immediateCondition = function(cond) {
[10:21:45.728]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.728]                   sendCondition(cond)
[10:21:45.728]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.728]                   {
[10:21:45.728]                     inherits <- base::inherits
[10:21:45.728]                     invokeRestart <- base::invokeRestart
[10:21:45.728]                     is.null <- base::is.null
[10:21:45.728]                     muffled <- FALSE
[10:21:45.728]                     if (inherits(cond, "message")) {
[10:21:45.728]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.728]                       if (muffled) 
[10:21:45.728]                         invokeRestart("muffleMessage")
[10:21:45.728]                     }
[10:21:45.728]                     else if (inherits(cond, "warning")) {
[10:21:45.728]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.728]                       if (muffled) 
[10:21:45.728]                         invokeRestart("muffleWarning")
[10:21:45.728]                     }
[10:21:45.728]                     else if (inherits(cond, "condition")) {
[10:21:45.728]                       if (!is.null(pattern)) {
[10:21:45.728]                         computeRestarts <- base::computeRestarts
[10:21:45.728]                         grepl <- base::grepl
[10:21:45.728]                         restarts <- computeRestarts(cond)
[10:21:45.728]                         for (restart in restarts) {
[10:21:45.728]                           name <- restart$name
[10:21:45.728]                           if (is.null(name)) 
[10:21:45.728]                             next
[10:21:45.728]                           if (!grepl(pattern, name)) 
[10:21:45.728]                             next
[10:21:45.728]                           invokeRestart(restart)
[10:21:45.728]                           muffled <- TRUE
[10:21:45.728]                           break
[10:21:45.728]                         }
[10:21:45.728]                       }
[10:21:45.728]                     }
[10:21:45.728]                     invisible(muffled)
[10:21:45.728]                   }
[10:21:45.728]                   muffleCondition(cond)
[10:21:45.728]                 })
[10:21:45.728]             }))
[10:21:45.728]             future::FutureResult(value = ...future.value$value, 
[10:21:45.728]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.728]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.728]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.728]                     ...future.globalenv.names))
[10:21:45.728]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.728]         }, condition = base::local({
[10:21:45.728]             c <- base::c
[10:21:45.728]             inherits <- base::inherits
[10:21:45.728]             invokeRestart <- base::invokeRestart
[10:21:45.728]             length <- base::length
[10:21:45.728]             list <- base::list
[10:21:45.728]             seq.int <- base::seq.int
[10:21:45.728]             signalCondition <- base::signalCondition
[10:21:45.728]             sys.calls <- base::sys.calls
[10:21:45.728]             `[[` <- base::`[[`
[10:21:45.728]             `+` <- base::`+`
[10:21:45.728]             `<<-` <- base::`<<-`
[10:21:45.728]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.728]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.728]                   3L)]
[10:21:45.728]             }
[10:21:45.728]             function(cond) {
[10:21:45.728]                 is_error <- inherits(cond, "error")
[10:21:45.728]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.728]                   NULL)
[10:21:45.728]                 if (is_error) {
[10:21:45.728]                   sessionInformation <- function() {
[10:21:45.728]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.728]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.728]                       search = base::search(), system = base::Sys.info())
[10:21:45.728]                   }
[10:21:45.728]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.728]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.728]                     cond$call), session = sessionInformation(), 
[10:21:45.728]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.728]                   signalCondition(cond)
[10:21:45.728]                 }
[10:21:45.728]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.728]                 "immediateCondition"))) {
[10:21:45.728]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.728]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.728]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.728]                   if (TRUE && !signal) {
[10:21:45.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.728]                     {
[10:21:45.728]                       inherits <- base::inherits
[10:21:45.728]                       invokeRestart <- base::invokeRestart
[10:21:45.728]                       is.null <- base::is.null
[10:21:45.728]                       muffled <- FALSE
[10:21:45.728]                       if (inherits(cond, "message")) {
[10:21:45.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.728]                         if (muffled) 
[10:21:45.728]                           invokeRestart("muffleMessage")
[10:21:45.728]                       }
[10:21:45.728]                       else if (inherits(cond, "warning")) {
[10:21:45.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.728]                         if (muffled) 
[10:21:45.728]                           invokeRestart("muffleWarning")
[10:21:45.728]                       }
[10:21:45.728]                       else if (inherits(cond, "condition")) {
[10:21:45.728]                         if (!is.null(pattern)) {
[10:21:45.728]                           computeRestarts <- base::computeRestarts
[10:21:45.728]                           grepl <- base::grepl
[10:21:45.728]                           restarts <- computeRestarts(cond)
[10:21:45.728]                           for (restart in restarts) {
[10:21:45.728]                             name <- restart$name
[10:21:45.728]                             if (is.null(name)) 
[10:21:45.728]                               next
[10:21:45.728]                             if (!grepl(pattern, name)) 
[10:21:45.728]                               next
[10:21:45.728]                             invokeRestart(restart)
[10:21:45.728]                             muffled <- TRUE
[10:21:45.728]                             break
[10:21:45.728]                           }
[10:21:45.728]                         }
[10:21:45.728]                       }
[10:21:45.728]                       invisible(muffled)
[10:21:45.728]                     }
[10:21:45.728]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.728]                   }
[10:21:45.728]                 }
[10:21:45.728]                 else {
[10:21:45.728]                   if (TRUE) {
[10:21:45.728]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.728]                     {
[10:21:45.728]                       inherits <- base::inherits
[10:21:45.728]                       invokeRestart <- base::invokeRestart
[10:21:45.728]                       is.null <- base::is.null
[10:21:45.728]                       muffled <- FALSE
[10:21:45.728]                       if (inherits(cond, "message")) {
[10:21:45.728]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.728]                         if (muffled) 
[10:21:45.728]                           invokeRestart("muffleMessage")
[10:21:45.728]                       }
[10:21:45.728]                       else if (inherits(cond, "warning")) {
[10:21:45.728]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.728]                         if (muffled) 
[10:21:45.728]                           invokeRestart("muffleWarning")
[10:21:45.728]                       }
[10:21:45.728]                       else if (inherits(cond, "condition")) {
[10:21:45.728]                         if (!is.null(pattern)) {
[10:21:45.728]                           computeRestarts <- base::computeRestarts
[10:21:45.728]                           grepl <- base::grepl
[10:21:45.728]                           restarts <- computeRestarts(cond)
[10:21:45.728]                           for (restart in restarts) {
[10:21:45.728]                             name <- restart$name
[10:21:45.728]                             if (is.null(name)) 
[10:21:45.728]                               next
[10:21:45.728]                             if (!grepl(pattern, name)) 
[10:21:45.728]                               next
[10:21:45.728]                             invokeRestart(restart)
[10:21:45.728]                             muffled <- TRUE
[10:21:45.728]                             break
[10:21:45.728]                           }
[10:21:45.728]                         }
[10:21:45.728]                       }
[10:21:45.728]                       invisible(muffled)
[10:21:45.728]                     }
[10:21:45.728]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.728]                   }
[10:21:45.728]                 }
[10:21:45.728]             }
[10:21:45.728]         }))
[10:21:45.728]     }, error = function(ex) {
[10:21:45.728]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.728]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.728]                 ...future.rng), started = ...future.startTime, 
[10:21:45.728]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.728]             version = "1.8"), class = "FutureResult")
[10:21:45.728]     }, finally = {
[10:21:45.728]         if (!identical(...future.workdir, getwd())) 
[10:21:45.728]             setwd(...future.workdir)
[10:21:45.728]         {
[10:21:45.728]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.728]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.728]             }
[10:21:45.728]             base::options(...future.oldOptions)
[10:21:45.728]             if (.Platform$OS.type == "windows") {
[10:21:45.728]                 old_names <- names(...future.oldEnvVars)
[10:21:45.728]                 envs <- base::Sys.getenv()
[10:21:45.728]                 names <- names(envs)
[10:21:45.728]                 common <- intersect(names, old_names)
[10:21:45.728]                 added <- setdiff(names, old_names)
[10:21:45.728]                 removed <- setdiff(old_names, names)
[10:21:45.728]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.728]                   envs[common]]
[10:21:45.728]                 NAMES <- toupper(changed)
[10:21:45.728]                 args <- list()
[10:21:45.728]                 for (kk in seq_along(NAMES)) {
[10:21:45.728]                   name <- changed[[kk]]
[10:21:45.728]                   NAME <- NAMES[[kk]]
[10:21:45.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.728]                     next
[10:21:45.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.728]                 }
[10:21:45.728]                 NAMES <- toupper(added)
[10:21:45.728]                 for (kk in seq_along(NAMES)) {
[10:21:45.728]                   name <- added[[kk]]
[10:21:45.728]                   NAME <- NAMES[[kk]]
[10:21:45.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.728]                     next
[10:21:45.728]                   args[[name]] <- ""
[10:21:45.728]                 }
[10:21:45.728]                 NAMES <- toupper(removed)
[10:21:45.728]                 for (kk in seq_along(NAMES)) {
[10:21:45.728]                   name <- removed[[kk]]
[10:21:45.728]                   NAME <- NAMES[[kk]]
[10:21:45.728]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.728]                     next
[10:21:45.728]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.728]                 }
[10:21:45.728]                 if (length(args) > 0) 
[10:21:45.728]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.728]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.728]             }
[10:21:45.728]             else {
[10:21:45.728]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.728]             }
[10:21:45.728]             {
[10:21:45.728]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.728]                   0L) {
[10:21:45.728]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.728]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.728]                   base::options(opts)
[10:21:45.728]                 }
[10:21:45.728]                 {
[10:21:45.728]                   {
[10:21:45.728]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.728]                     NULL
[10:21:45.728]                   }
[10:21:45.728]                   options(future.plan = NULL)
[10:21:45.728]                   if (is.na(NA_character_)) 
[10:21:45.728]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.728]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.728]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.728]                     .init = FALSE)
[10:21:45.728]                 }
[10:21:45.728]             }
[10:21:45.728]         }
[10:21:45.728]     })
[10:21:45.728]     if (TRUE) {
[10:21:45.728]         base::sink(type = "output", split = FALSE)
[10:21:45.728]         if (TRUE) {
[10:21:45.728]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.728]         }
[10:21:45.728]         else {
[10:21:45.728]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.728]         }
[10:21:45.728]         base::close(...future.stdout)
[10:21:45.728]         ...future.stdout <- NULL
[10:21:45.728]     }
[10:21:45.728]     ...future.result$conditions <- ...future.conditions
[10:21:45.728]     ...future.result$finished <- base::Sys.time()
[10:21:45.728]     ...future.result
[10:21:45.728] }
[10:21:45.730] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:45.741] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.741] - Validating connection of MultisessionFuture
[10:21:45.741] - received message: FutureResult
[10:21:45.742] - Received FutureResult
[10:21:45.742] - Erased future from FutureRegistry
[10:21:45.742] result() for ClusterFuture ...
[10:21:45.742] - result already collected: FutureResult
[10:21:45.742] result() for ClusterFuture ... done
[10:21:45.742] signalConditions() ...
[10:21:45.742]  - include = ‘immediateCondition’
[10:21:45.742]  - exclude = 
[10:21:45.742]  - resignal = FALSE
[10:21:45.744]  - Number of conditions: 1
[10:21:45.744] signalConditions() ... done
[10:21:45.745] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:45.745] result() for ClusterFuture ...
[10:21:45.745] - result already collected: FutureResult
[10:21:45.745] result() for ClusterFuture ... done
[10:21:45.745] result() for ClusterFuture ...
[10:21:45.745] - result already collected: FutureResult
[10:21:45.745] result() for ClusterFuture ... done
[10:21:45.745] signalConditions() ...
[10:21:45.745]  - include = ‘immediateCondition’
[10:21:45.745]  - exclude = 
[10:21:45.745]  - resignal = FALSE
[10:21:45.745]  - Number of conditions: 1
[10:21:45.745] signalConditions() ... done
[10:21:45.746] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[10:21:45.746] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[10:21:45.747] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[10:21:45.747] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[10:21:45.747] MultisessionFuture started
[10:21:45.747] - Launch lazy future ... done
[10:21:45.747] run() for ‘MultisessionFuture’ ... done
[10:21:45.747] result() for ClusterFuture ...
[10:21:45.747] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.748] - Validating connection of MultisessionFuture
[10:21:45.793] - received message: FutureResult
[10:21:45.793] - Received FutureResult
[10:21:45.793] - Erased future from FutureRegistry
[10:21:45.794] result() for ClusterFuture ...
[10:21:45.794] - result already collected: FutureResult
[10:21:45.794] result() for ClusterFuture ... done
[10:21:45.794] signalConditions() ...
[10:21:45.794]  - include = ‘immediateCondition’
[10:21:45.794]  - exclude = 
[10:21:45.794]  - resignal = FALSE
[10:21:45.794]  - Number of conditions: 1
[10:21:45.794] signalConditions() ... done
[10:21:45.794] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:45.794] result() for ClusterFuture ... done
[10:21:45.795] result() for ClusterFuture ...
[10:21:45.795] - result already collected: FutureResult
[10:21:45.795] result() for ClusterFuture ... done
[10:21:45.795] signalConditions() ...
[10:21:45.795]  - include = ‘immediateCondition’
[10:21:45.795]  - exclude = 
[10:21:45.795]  - resignal = FALSE
[10:21:45.795]  - Number of conditions: 1
[10:21:45.795] signalConditions() ... done
[10:21:45.795] Future state: ‘finished’
[10:21:45.795] result() for ClusterFuture ...
[10:21:45.795] - result already collected: FutureResult
[10:21:45.796] result() for ClusterFuture ... done
[10:21:45.796] signalConditions() ...
[10:21:45.796]  - include = ‘condition’
[10:21:45.796]  - exclude = ‘immediateCondition’
[10:21:45.796]  - resignal = TRUE
[10:21:45.796]  - Number of conditions: 1
[10:21:45.796]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[10:21:45.796] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1018-azure" "#18~24.04.1-Ubuntu SMP Sat Jun 28 04:46:03 UTC 2025" "eec1919a6b51" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-11-19 10:21:45"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.809] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.809] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.810] 
[10:21:45.810] Searching for globals ... DONE
[10:21:45.810] - globals: [0] <none>
[10:21:45.810] getGlobalsAndPackages() ... DONE
[10:21:45.810] run() for ‘Future’ ...
[10:21:45.811] - state: ‘created’
[10:21:45.811] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.828] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.828] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.828]   - Field: ‘node’
[10:21:45.828]   - Field: ‘label’
[10:21:45.828]   - Field: ‘local’
[10:21:45.828]   - Field: ‘owner’
[10:21:45.828]   - Field: ‘envir’
[10:21:45.828]   - Field: ‘workers’
[10:21:45.828]   - Field: ‘packages’
[10:21:45.829]   - Field: ‘gc’
[10:21:45.829]   - Field: ‘conditions’
[10:21:45.829]   - Field: ‘persistent’
[10:21:45.829]   - Field: ‘expr’
[10:21:45.829]   - Field: ‘uuid’
[10:21:45.829]   - Field: ‘seed’
[10:21:45.829]   - Field: ‘version’
[10:21:45.829]   - Field: ‘result’
[10:21:45.829]   - Field: ‘asynchronous’
[10:21:45.829]   - Field: ‘calls’
[10:21:45.829]   - Field: ‘globals’
[10:21:45.829]   - Field: ‘stdout’
[10:21:45.830]   - Field: ‘earlySignal’
[10:21:45.830]   - Field: ‘lazy’
[10:21:45.830]   - Field: ‘state’
[10:21:45.830] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.830] - Launch lazy future ...
[10:21:45.830] Packages needed by the future expression (n = 0): <none>
[10:21:45.830] Packages needed by future strategies (n = 0): <none>
[10:21:45.831] {
[10:21:45.831]     {
[10:21:45.831]         {
[10:21:45.831]             ...future.startTime <- base::Sys.time()
[10:21:45.831]             {
[10:21:45.831]                 {
[10:21:45.831]                   {
[10:21:45.831]                     {
[10:21:45.831]                       base::local({
[10:21:45.831]                         has_future <- base::requireNamespace("future", 
[10:21:45.831]                           quietly = TRUE)
[10:21:45.831]                         if (has_future) {
[10:21:45.831]                           ns <- base::getNamespace("future")
[10:21:45.831]                           version <- ns[[".package"]][["version"]]
[10:21:45.831]                           if (is.null(version)) 
[10:21:45.831]                             version <- utils::packageVersion("future")
[10:21:45.831]                         }
[10:21:45.831]                         else {
[10:21:45.831]                           version <- NULL
[10:21:45.831]                         }
[10:21:45.831]                         if (!has_future || version < "1.8.0") {
[10:21:45.831]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.831]                             "", base::R.version$version.string), 
[10:21:45.831]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:45.831]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:45.831]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.831]                               "release", "version")], collapse = " "), 
[10:21:45.831]                             hostname = base::Sys.info()[["nodename"]])
[10:21:45.831]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.831]                             info)
[10:21:45.831]                           info <- base::paste(info, collapse = "; ")
[10:21:45.831]                           if (!has_future) {
[10:21:45.831]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.831]                               info)
[10:21:45.831]                           }
[10:21:45.831]                           else {
[10:21:45.831]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.831]                               info, version)
[10:21:45.831]                           }
[10:21:45.831]                           base::stop(msg)
[10:21:45.831]                         }
[10:21:45.831]                       })
[10:21:45.831]                     }
[10:21:45.831]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.831]                     base::options(mc.cores = 1L)
[10:21:45.831]                   }
[10:21:45.831]                   ...future.strategy.old <- future::plan("list")
[10:21:45.831]                   options(future.plan = NULL)
[10:21:45.831]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.831]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.831]                 }
[10:21:45.831]                 ...future.workdir <- getwd()
[10:21:45.831]             }
[10:21:45.831]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.831]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.831]         }
[10:21:45.831]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.831]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.831]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.831]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.831]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.831]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.831]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.831]             base::names(...future.oldOptions))
[10:21:45.831]     }
[10:21:45.831]     if (FALSE) {
[10:21:45.831]     }
[10:21:45.831]     else {
[10:21:45.831]         if (TRUE) {
[10:21:45.831]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.831]                 open = "w")
[10:21:45.831]         }
[10:21:45.831]         else {
[10:21:45.831]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.831]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.831]         }
[10:21:45.831]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.831]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.831]             base::sink(type = "output", split = FALSE)
[10:21:45.831]             base::close(...future.stdout)
[10:21:45.831]         }, add = TRUE)
[10:21:45.831]     }
[10:21:45.831]     ...future.frame <- base::sys.nframe()
[10:21:45.831]     ...future.conditions <- base::list()
[10:21:45.831]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.831]     if (FALSE) {
[10:21:45.831]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.831]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.831]     }
[10:21:45.831]     ...future.result <- base::tryCatch({
[10:21:45.831]         base::withCallingHandlers({
[10:21:45.831]             ...future.value <- base::withVisible(base::local({
[10:21:45.831]                 ...future.makeSendCondition <- base::local({
[10:21:45.831]                   sendCondition <- NULL
[10:21:45.831]                   function(frame = 1L) {
[10:21:45.831]                     if (is.function(sendCondition)) 
[10:21:45.831]                       return(sendCondition)
[10:21:45.831]                     ns <- getNamespace("parallel")
[10:21:45.831]                     if (exists("sendData", mode = "function", 
[10:21:45.831]                       envir = ns)) {
[10:21:45.831]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.831]                         envir = ns)
[10:21:45.831]                       envir <- sys.frame(frame)
[10:21:45.831]                       master <- NULL
[10:21:45.831]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.831]                         !identical(envir, emptyenv())) {
[10:21:45.831]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.831]                           inherits = FALSE)) {
[10:21:45.831]                           master <- get("master", mode = "list", 
[10:21:45.831]                             envir = envir, inherits = FALSE)
[10:21:45.831]                           if (inherits(master, c("SOCKnode", 
[10:21:45.831]                             "SOCK0node"))) {
[10:21:45.831]                             sendCondition <<- function(cond) {
[10:21:45.831]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.831]                                 success = TRUE)
[10:21:45.831]                               parallel_sendData(master, data)
[10:21:45.831]                             }
[10:21:45.831]                             return(sendCondition)
[10:21:45.831]                           }
[10:21:45.831]                         }
[10:21:45.831]                         frame <- frame + 1L
[10:21:45.831]                         envir <- sys.frame(frame)
[10:21:45.831]                       }
[10:21:45.831]                     }
[10:21:45.831]                     sendCondition <<- function(cond) NULL
[10:21:45.831]                   }
[10:21:45.831]                 })
[10:21:45.831]                 withCallingHandlers({
[10:21:45.831]                   1
[10:21:45.831]                 }, immediateCondition = function(cond) {
[10:21:45.831]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.831]                   sendCondition(cond)
[10:21:45.831]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.831]                   {
[10:21:45.831]                     inherits <- base::inherits
[10:21:45.831]                     invokeRestart <- base::invokeRestart
[10:21:45.831]                     is.null <- base::is.null
[10:21:45.831]                     muffled <- FALSE
[10:21:45.831]                     if (inherits(cond, "message")) {
[10:21:45.831]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.831]                       if (muffled) 
[10:21:45.831]                         invokeRestart("muffleMessage")
[10:21:45.831]                     }
[10:21:45.831]                     else if (inherits(cond, "warning")) {
[10:21:45.831]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.831]                       if (muffled) 
[10:21:45.831]                         invokeRestart("muffleWarning")
[10:21:45.831]                     }
[10:21:45.831]                     else if (inherits(cond, "condition")) {
[10:21:45.831]                       if (!is.null(pattern)) {
[10:21:45.831]                         computeRestarts <- base::computeRestarts
[10:21:45.831]                         grepl <- base::grepl
[10:21:45.831]                         restarts <- computeRestarts(cond)
[10:21:45.831]                         for (restart in restarts) {
[10:21:45.831]                           name <- restart$name
[10:21:45.831]                           if (is.null(name)) 
[10:21:45.831]                             next
[10:21:45.831]                           if (!grepl(pattern, name)) 
[10:21:45.831]                             next
[10:21:45.831]                           invokeRestart(restart)
[10:21:45.831]                           muffled <- TRUE
[10:21:45.831]                           break
[10:21:45.831]                         }
[10:21:45.831]                       }
[10:21:45.831]                     }
[10:21:45.831]                     invisible(muffled)
[10:21:45.831]                   }
[10:21:45.831]                   muffleCondition(cond)
[10:21:45.831]                 })
[10:21:45.831]             }))
[10:21:45.831]             future::FutureResult(value = ...future.value$value, 
[10:21:45.831]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.831]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.831]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.831]                     ...future.globalenv.names))
[10:21:45.831]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.831]         }, condition = base::local({
[10:21:45.831]             c <- base::c
[10:21:45.831]             inherits <- base::inherits
[10:21:45.831]             invokeRestart <- base::invokeRestart
[10:21:45.831]             length <- base::length
[10:21:45.831]             list <- base::list
[10:21:45.831]             seq.int <- base::seq.int
[10:21:45.831]             signalCondition <- base::signalCondition
[10:21:45.831]             sys.calls <- base::sys.calls
[10:21:45.831]             `[[` <- base::`[[`
[10:21:45.831]             `+` <- base::`+`
[10:21:45.831]             `<<-` <- base::`<<-`
[10:21:45.831]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.831]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.831]                   3L)]
[10:21:45.831]             }
[10:21:45.831]             function(cond) {
[10:21:45.831]                 is_error <- inherits(cond, "error")
[10:21:45.831]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.831]                   NULL)
[10:21:45.831]                 if (is_error) {
[10:21:45.831]                   sessionInformation <- function() {
[10:21:45.831]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.831]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.831]                       search = base::search(), system = base::Sys.info())
[10:21:45.831]                   }
[10:21:45.831]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.831]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.831]                     cond$call), session = sessionInformation(), 
[10:21:45.831]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.831]                   signalCondition(cond)
[10:21:45.831]                 }
[10:21:45.831]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.831]                 "immediateCondition"))) {
[10:21:45.831]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.831]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.831]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.831]                   if (TRUE && !signal) {
[10:21:45.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.831]                     {
[10:21:45.831]                       inherits <- base::inherits
[10:21:45.831]                       invokeRestart <- base::invokeRestart
[10:21:45.831]                       is.null <- base::is.null
[10:21:45.831]                       muffled <- FALSE
[10:21:45.831]                       if (inherits(cond, "message")) {
[10:21:45.831]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.831]                         if (muffled) 
[10:21:45.831]                           invokeRestart("muffleMessage")
[10:21:45.831]                       }
[10:21:45.831]                       else if (inherits(cond, "warning")) {
[10:21:45.831]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.831]                         if (muffled) 
[10:21:45.831]                           invokeRestart("muffleWarning")
[10:21:45.831]                       }
[10:21:45.831]                       else if (inherits(cond, "condition")) {
[10:21:45.831]                         if (!is.null(pattern)) {
[10:21:45.831]                           computeRestarts <- base::computeRestarts
[10:21:45.831]                           grepl <- base::grepl
[10:21:45.831]                           restarts <- computeRestarts(cond)
[10:21:45.831]                           for (restart in restarts) {
[10:21:45.831]                             name <- restart$name
[10:21:45.831]                             if (is.null(name)) 
[10:21:45.831]                               next
[10:21:45.831]                             if (!grepl(pattern, name)) 
[10:21:45.831]                               next
[10:21:45.831]                             invokeRestart(restart)
[10:21:45.831]                             muffled <- TRUE
[10:21:45.831]                             break
[10:21:45.831]                           }
[10:21:45.831]                         }
[10:21:45.831]                       }
[10:21:45.831]                       invisible(muffled)
[10:21:45.831]                     }
[10:21:45.831]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.831]                   }
[10:21:45.831]                 }
[10:21:45.831]                 else {
[10:21:45.831]                   if (TRUE) {
[10:21:45.831]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.831]                     {
[10:21:45.831]                       inherits <- base::inherits
[10:21:45.831]                       invokeRestart <- base::invokeRestart
[10:21:45.831]                       is.null <- base::is.null
[10:21:45.831]                       muffled <- FALSE
[10:21:45.831]                       if (inherits(cond, "message")) {
[10:21:45.831]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.831]                         if (muffled) 
[10:21:45.831]                           invokeRestart("muffleMessage")
[10:21:45.831]                       }
[10:21:45.831]                       else if (inherits(cond, "warning")) {
[10:21:45.831]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.831]                         if (muffled) 
[10:21:45.831]                           invokeRestart("muffleWarning")
[10:21:45.831]                       }
[10:21:45.831]                       else if (inherits(cond, "condition")) {
[10:21:45.831]                         if (!is.null(pattern)) {
[10:21:45.831]                           computeRestarts <- base::computeRestarts
[10:21:45.831]                           grepl <- base::grepl
[10:21:45.831]                           restarts <- computeRestarts(cond)
[10:21:45.831]                           for (restart in restarts) {
[10:21:45.831]                             name <- restart$name
[10:21:45.831]                             if (is.null(name)) 
[10:21:45.831]                               next
[10:21:45.831]                             if (!grepl(pattern, name)) 
[10:21:45.831]                               next
[10:21:45.831]                             invokeRestart(restart)
[10:21:45.831]                             muffled <- TRUE
[10:21:45.831]                             break
[10:21:45.831]                           }
[10:21:45.831]                         }
[10:21:45.831]                       }
[10:21:45.831]                       invisible(muffled)
[10:21:45.831]                     }
[10:21:45.831]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.831]                   }
[10:21:45.831]                 }
[10:21:45.831]             }
[10:21:45.831]         }))
[10:21:45.831]     }, error = function(ex) {
[10:21:45.831]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.831]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.831]                 ...future.rng), started = ...future.startTime, 
[10:21:45.831]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.831]             version = "1.8"), class = "FutureResult")
[10:21:45.831]     }, finally = {
[10:21:45.831]         if (!identical(...future.workdir, getwd())) 
[10:21:45.831]             setwd(...future.workdir)
[10:21:45.831]         {
[10:21:45.831]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.831]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.831]             }
[10:21:45.831]             base::options(...future.oldOptions)
[10:21:45.831]             if (.Platform$OS.type == "windows") {
[10:21:45.831]                 old_names <- names(...future.oldEnvVars)
[10:21:45.831]                 envs <- base::Sys.getenv()
[10:21:45.831]                 names <- names(envs)
[10:21:45.831]                 common <- intersect(names, old_names)
[10:21:45.831]                 added <- setdiff(names, old_names)
[10:21:45.831]                 removed <- setdiff(old_names, names)
[10:21:45.831]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.831]                   envs[common]]
[10:21:45.831]                 NAMES <- toupper(changed)
[10:21:45.831]                 args <- list()
[10:21:45.831]                 for (kk in seq_along(NAMES)) {
[10:21:45.831]                   name <- changed[[kk]]
[10:21:45.831]                   NAME <- NAMES[[kk]]
[10:21:45.831]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.831]                     next
[10:21:45.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.831]                 }
[10:21:45.831]                 NAMES <- toupper(added)
[10:21:45.831]                 for (kk in seq_along(NAMES)) {
[10:21:45.831]                   name <- added[[kk]]
[10:21:45.831]                   NAME <- NAMES[[kk]]
[10:21:45.831]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.831]                     next
[10:21:45.831]                   args[[name]] <- ""
[10:21:45.831]                 }
[10:21:45.831]                 NAMES <- toupper(removed)
[10:21:45.831]                 for (kk in seq_along(NAMES)) {
[10:21:45.831]                   name <- removed[[kk]]
[10:21:45.831]                   NAME <- NAMES[[kk]]
[10:21:45.831]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.831]                     next
[10:21:45.831]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.831]                 }
[10:21:45.831]                 if (length(args) > 0) 
[10:21:45.831]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.831]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.831]             }
[10:21:45.831]             else {
[10:21:45.831]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.831]             }
[10:21:45.831]             {
[10:21:45.831]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.831]                   0L) {
[10:21:45.831]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.831]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.831]                   base::options(opts)
[10:21:45.831]                 }
[10:21:45.831]                 {
[10:21:45.831]                   {
[10:21:45.831]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.831]                     NULL
[10:21:45.831]                   }
[10:21:45.831]                   options(future.plan = NULL)
[10:21:45.831]                   if (is.na(NA_character_)) 
[10:21:45.831]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.831]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.831]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.831]                     .init = FALSE)
[10:21:45.831]                 }
[10:21:45.831]             }
[10:21:45.831]         }
[10:21:45.831]     })
[10:21:45.831]     if (TRUE) {
[10:21:45.831]         base::sink(type = "output", split = FALSE)
[10:21:45.831]         if (TRUE) {
[10:21:45.831]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.831]         }
[10:21:45.831]         else {
[10:21:45.831]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.831]         }
[10:21:45.831]         base::close(...future.stdout)
[10:21:45.831]         ...future.stdout <- NULL
[10:21:45.831]     }
[10:21:45.831]     ...future.result$conditions <- ...future.conditions
[10:21:45.831]     ...future.result$finished <- base::Sys.time()
[10:21:45.831]     ...future.result
[10:21:45.831] }
[10:21:45.834] MultisessionFuture started
[10:21:45.834] - Launch lazy future ... done
[10:21:45.834] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:45.834] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:45.835] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:45.836] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:45.836] Searching for globals ... DONE
[10:21:45.836] Resolving globals: TRUE
[10:21:45.836] Resolving any globals that are futures ...
[10:21:45.836] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:45.836] Resolving any globals that are futures ... DONE
[10:21:45.836] Resolving futures part of globals (recursively) ...
[10:21:45.837] resolve() on list ...
[10:21:45.837]  recursive: 99
[10:21:45.837]  length: 1
[10:21:45.837]  elements: ‘a’
[10:21:45.879] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.879] - Validating connection of MultisessionFuture
[10:21:45.879] - received message: FutureResult
[10:21:45.879] - Received FutureResult
[10:21:45.879] - Erased future from FutureRegistry
[10:21:45.879] result() for ClusterFuture ...
[10:21:45.880] - result already collected: FutureResult
[10:21:45.880] result() for ClusterFuture ... done
[10:21:45.880] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:45.880] Future #1
[10:21:45.880] result() for ClusterFuture ...
[10:21:45.880] - result already collected: FutureResult
[10:21:45.880] result() for ClusterFuture ... done
[10:21:45.880] result() for ClusterFuture ...
[10:21:45.880] - result already collected: FutureResult
[10:21:45.880] result() for ClusterFuture ... done
[10:21:45.880] A MultisessionFuture was resolved
[10:21:45.881]  length: 0 (resolved future 1)
[10:21:45.881] resolve() on list ... DONE
[10:21:45.881] - globals: [1] ‘a’
[10:21:45.881] Resolving futures part of globals (recursively) ... DONE
[10:21:45.892] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[10:21:45.892] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[10:21:45.892] - globals: [1] ‘a’
[10:21:45.892] - packages: [1] ‘future’
[10:21:45.893] getGlobalsAndPackages() ... DONE
[10:21:45.893] run() for ‘Future’ ...
[10:21:45.893] - state: ‘created’
[10:21:45.893] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:45.907] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:45.907] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:45.907]   - Field: ‘node’
[10:21:45.907]   - Field: ‘label’
[10:21:45.907]   - Field: ‘local’
[10:21:45.907]   - Field: ‘owner’
[10:21:45.907]   - Field: ‘envir’
[10:21:45.907]   - Field: ‘workers’
[10:21:45.908]   - Field: ‘packages’
[10:21:45.908]   - Field: ‘gc’
[10:21:45.908]   - Field: ‘conditions’
[10:21:45.908]   - Field: ‘persistent’
[10:21:45.908]   - Field: ‘expr’
[10:21:45.908]   - Field: ‘uuid’
[10:21:45.908]   - Field: ‘seed’
[10:21:45.908]   - Field: ‘version’
[10:21:45.908]   - Field: ‘result’
[10:21:45.908]   - Field: ‘asynchronous’
[10:21:45.908]   - Field: ‘calls’
[10:21:45.909]   - Field: ‘globals’
[10:21:45.909]   - Field: ‘stdout’
[10:21:45.909]   - Field: ‘earlySignal’
[10:21:45.909]   - Field: ‘lazy’
[10:21:45.909]   - Field: ‘state’
[10:21:45.909] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:45.909] - Launch lazy future ...
[10:21:45.909] Packages needed by the future expression (n = 1): ‘future’
[10:21:45.909] Packages needed by future strategies (n = 0): <none>
[10:21:45.910] {
[10:21:45.910]     {
[10:21:45.910]         {
[10:21:45.910]             ...future.startTime <- base::Sys.time()
[10:21:45.910]             {
[10:21:45.910]                 {
[10:21:45.910]                   {
[10:21:45.910]                     {
[10:21:45.910]                       {
[10:21:45.910]                         base::local({
[10:21:45.910]                           has_future <- base::requireNamespace("future", 
[10:21:45.910]                             quietly = TRUE)
[10:21:45.910]                           if (has_future) {
[10:21:45.910]                             ns <- base::getNamespace("future")
[10:21:45.910]                             version <- ns[[".package"]][["version"]]
[10:21:45.910]                             if (is.null(version)) 
[10:21:45.910]                               version <- utils::packageVersion("future")
[10:21:45.910]                           }
[10:21:45.910]                           else {
[10:21:45.910]                             version <- NULL
[10:21:45.910]                           }
[10:21:45.910]                           if (!has_future || version < "1.8.0") {
[10:21:45.910]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:45.910]                               "", base::R.version$version.string), 
[10:21:45.910]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:45.910]                                 base::R.version$platform, 8 * 
[10:21:45.910]                                   base::.Machine$sizeof.pointer), 
[10:21:45.910]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:45.910]                                 "release", "version")], collapse = " "), 
[10:21:45.910]                               hostname = base::Sys.info()[["nodename"]])
[10:21:45.910]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:45.910]                               info)
[10:21:45.910]                             info <- base::paste(info, collapse = "; ")
[10:21:45.910]                             if (!has_future) {
[10:21:45.910]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:45.910]                                 info)
[10:21:45.910]                             }
[10:21:45.910]                             else {
[10:21:45.910]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:45.910]                                 info, version)
[10:21:45.910]                             }
[10:21:45.910]                             base::stop(msg)
[10:21:45.910]                           }
[10:21:45.910]                         })
[10:21:45.910]                       }
[10:21:45.910]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:45.910]                       base::options(mc.cores = 1L)
[10:21:45.910]                     }
[10:21:45.910]                     base::local({
[10:21:45.910]                       for (pkg in "future") {
[10:21:45.910]                         base::loadNamespace(pkg)
[10:21:45.910]                         base::library(pkg, character.only = TRUE)
[10:21:45.910]                       }
[10:21:45.910]                     })
[10:21:45.910]                   }
[10:21:45.910]                   ...future.strategy.old <- future::plan("list")
[10:21:45.910]                   options(future.plan = NULL)
[10:21:45.910]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.910]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:45.910]                 }
[10:21:45.910]                 ...future.workdir <- getwd()
[10:21:45.910]             }
[10:21:45.910]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:45.910]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:45.910]         }
[10:21:45.910]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:45.910]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:45.910]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:45.910]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:45.910]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:45.910]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:45.910]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:45.910]             base::names(...future.oldOptions))
[10:21:45.910]     }
[10:21:45.910]     if (FALSE) {
[10:21:45.910]     }
[10:21:45.910]     else {
[10:21:45.910]         if (TRUE) {
[10:21:45.910]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:45.910]                 open = "w")
[10:21:45.910]         }
[10:21:45.910]         else {
[10:21:45.910]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:45.910]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:45.910]         }
[10:21:45.910]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:45.910]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:45.910]             base::sink(type = "output", split = FALSE)
[10:21:45.910]             base::close(...future.stdout)
[10:21:45.910]         }, add = TRUE)
[10:21:45.910]     }
[10:21:45.910]     ...future.frame <- base::sys.nframe()
[10:21:45.910]     ...future.conditions <- base::list()
[10:21:45.910]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:45.910]     if (FALSE) {
[10:21:45.910]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:45.910]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:45.910]     }
[10:21:45.910]     ...future.result <- base::tryCatch({
[10:21:45.910]         base::withCallingHandlers({
[10:21:45.910]             ...future.value <- base::withVisible(base::local({
[10:21:45.910]                 ...future.makeSendCondition <- base::local({
[10:21:45.910]                   sendCondition <- NULL
[10:21:45.910]                   function(frame = 1L) {
[10:21:45.910]                     if (is.function(sendCondition)) 
[10:21:45.910]                       return(sendCondition)
[10:21:45.910]                     ns <- getNamespace("parallel")
[10:21:45.910]                     if (exists("sendData", mode = "function", 
[10:21:45.910]                       envir = ns)) {
[10:21:45.910]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:45.910]                         envir = ns)
[10:21:45.910]                       envir <- sys.frame(frame)
[10:21:45.910]                       master <- NULL
[10:21:45.910]                       while (!identical(envir, .GlobalEnv) && 
[10:21:45.910]                         !identical(envir, emptyenv())) {
[10:21:45.910]                         if (exists("master", mode = "list", envir = envir, 
[10:21:45.910]                           inherits = FALSE)) {
[10:21:45.910]                           master <- get("master", mode = "list", 
[10:21:45.910]                             envir = envir, inherits = FALSE)
[10:21:45.910]                           if (inherits(master, c("SOCKnode", 
[10:21:45.910]                             "SOCK0node"))) {
[10:21:45.910]                             sendCondition <<- function(cond) {
[10:21:45.910]                               data <- list(type = "VALUE", value = cond, 
[10:21:45.910]                                 success = TRUE)
[10:21:45.910]                               parallel_sendData(master, data)
[10:21:45.910]                             }
[10:21:45.910]                             return(sendCondition)
[10:21:45.910]                           }
[10:21:45.910]                         }
[10:21:45.910]                         frame <- frame + 1L
[10:21:45.910]                         envir <- sys.frame(frame)
[10:21:45.910]                       }
[10:21:45.910]                     }
[10:21:45.910]                     sendCondition <<- function(cond) NULL
[10:21:45.910]                   }
[10:21:45.910]                 })
[10:21:45.910]                 withCallingHandlers({
[10:21:45.910]                   value(a) + 1
[10:21:45.910]                 }, immediateCondition = function(cond) {
[10:21:45.910]                   sendCondition <- ...future.makeSendCondition()
[10:21:45.910]                   sendCondition(cond)
[10:21:45.910]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.910]                   {
[10:21:45.910]                     inherits <- base::inherits
[10:21:45.910]                     invokeRestart <- base::invokeRestart
[10:21:45.910]                     is.null <- base::is.null
[10:21:45.910]                     muffled <- FALSE
[10:21:45.910]                     if (inherits(cond, "message")) {
[10:21:45.910]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:45.910]                       if (muffled) 
[10:21:45.910]                         invokeRestart("muffleMessage")
[10:21:45.910]                     }
[10:21:45.910]                     else if (inherits(cond, "warning")) {
[10:21:45.910]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:45.910]                       if (muffled) 
[10:21:45.910]                         invokeRestart("muffleWarning")
[10:21:45.910]                     }
[10:21:45.910]                     else if (inherits(cond, "condition")) {
[10:21:45.910]                       if (!is.null(pattern)) {
[10:21:45.910]                         computeRestarts <- base::computeRestarts
[10:21:45.910]                         grepl <- base::grepl
[10:21:45.910]                         restarts <- computeRestarts(cond)
[10:21:45.910]                         for (restart in restarts) {
[10:21:45.910]                           name <- restart$name
[10:21:45.910]                           if (is.null(name)) 
[10:21:45.910]                             next
[10:21:45.910]                           if (!grepl(pattern, name)) 
[10:21:45.910]                             next
[10:21:45.910]                           invokeRestart(restart)
[10:21:45.910]                           muffled <- TRUE
[10:21:45.910]                           break
[10:21:45.910]                         }
[10:21:45.910]                       }
[10:21:45.910]                     }
[10:21:45.910]                     invisible(muffled)
[10:21:45.910]                   }
[10:21:45.910]                   muffleCondition(cond)
[10:21:45.910]                 })
[10:21:45.910]             }))
[10:21:45.910]             future::FutureResult(value = ...future.value$value, 
[10:21:45.910]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.910]                   ...future.rng), globalenv = if (FALSE) 
[10:21:45.910]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:45.910]                     ...future.globalenv.names))
[10:21:45.910]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:45.910]         }, condition = base::local({
[10:21:45.910]             c <- base::c
[10:21:45.910]             inherits <- base::inherits
[10:21:45.910]             invokeRestart <- base::invokeRestart
[10:21:45.910]             length <- base::length
[10:21:45.910]             list <- base::list
[10:21:45.910]             seq.int <- base::seq.int
[10:21:45.910]             signalCondition <- base::signalCondition
[10:21:45.910]             sys.calls <- base::sys.calls
[10:21:45.910]             `[[` <- base::`[[`
[10:21:45.910]             `+` <- base::`+`
[10:21:45.910]             `<<-` <- base::`<<-`
[10:21:45.910]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:45.910]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:45.910]                   3L)]
[10:21:45.910]             }
[10:21:45.910]             function(cond) {
[10:21:45.910]                 is_error <- inherits(cond, "error")
[10:21:45.910]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:45.910]                   NULL)
[10:21:45.910]                 if (is_error) {
[10:21:45.910]                   sessionInformation <- function() {
[10:21:45.910]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:45.910]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:45.910]                       search = base::search(), system = base::Sys.info())
[10:21:45.910]                   }
[10:21:45.910]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.910]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:45.910]                     cond$call), session = sessionInformation(), 
[10:21:45.910]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:45.910]                   signalCondition(cond)
[10:21:45.910]                 }
[10:21:45.910]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:45.910]                 "immediateCondition"))) {
[10:21:45.910]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:45.910]                   ...future.conditions[[length(...future.conditions) + 
[10:21:45.910]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:45.910]                   if (TRUE && !signal) {
[10:21:45.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.910]                     {
[10:21:45.910]                       inherits <- base::inherits
[10:21:45.910]                       invokeRestart <- base::invokeRestart
[10:21:45.910]                       is.null <- base::is.null
[10:21:45.910]                       muffled <- FALSE
[10:21:45.910]                       if (inherits(cond, "message")) {
[10:21:45.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.910]                         if (muffled) 
[10:21:45.910]                           invokeRestart("muffleMessage")
[10:21:45.910]                       }
[10:21:45.910]                       else if (inherits(cond, "warning")) {
[10:21:45.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.910]                         if (muffled) 
[10:21:45.910]                           invokeRestart("muffleWarning")
[10:21:45.910]                       }
[10:21:45.910]                       else if (inherits(cond, "condition")) {
[10:21:45.910]                         if (!is.null(pattern)) {
[10:21:45.910]                           computeRestarts <- base::computeRestarts
[10:21:45.910]                           grepl <- base::grepl
[10:21:45.910]                           restarts <- computeRestarts(cond)
[10:21:45.910]                           for (restart in restarts) {
[10:21:45.910]                             name <- restart$name
[10:21:45.910]                             if (is.null(name)) 
[10:21:45.910]                               next
[10:21:45.910]                             if (!grepl(pattern, name)) 
[10:21:45.910]                               next
[10:21:45.910]                             invokeRestart(restart)
[10:21:45.910]                             muffled <- TRUE
[10:21:45.910]                             break
[10:21:45.910]                           }
[10:21:45.910]                         }
[10:21:45.910]                       }
[10:21:45.910]                       invisible(muffled)
[10:21:45.910]                     }
[10:21:45.910]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.910]                   }
[10:21:45.910]                 }
[10:21:45.910]                 else {
[10:21:45.910]                   if (TRUE) {
[10:21:45.910]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:45.910]                     {
[10:21:45.910]                       inherits <- base::inherits
[10:21:45.910]                       invokeRestart <- base::invokeRestart
[10:21:45.910]                       is.null <- base::is.null
[10:21:45.910]                       muffled <- FALSE
[10:21:45.910]                       if (inherits(cond, "message")) {
[10:21:45.910]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:45.910]                         if (muffled) 
[10:21:45.910]                           invokeRestart("muffleMessage")
[10:21:45.910]                       }
[10:21:45.910]                       else if (inherits(cond, "warning")) {
[10:21:45.910]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:45.910]                         if (muffled) 
[10:21:45.910]                           invokeRestart("muffleWarning")
[10:21:45.910]                       }
[10:21:45.910]                       else if (inherits(cond, "condition")) {
[10:21:45.910]                         if (!is.null(pattern)) {
[10:21:45.910]                           computeRestarts <- base::computeRestarts
[10:21:45.910]                           grepl <- base::grepl
[10:21:45.910]                           restarts <- computeRestarts(cond)
[10:21:45.910]                           for (restart in restarts) {
[10:21:45.910]                             name <- restart$name
[10:21:45.910]                             if (is.null(name)) 
[10:21:45.910]                               next
[10:21:45.910]                             if (!grepl(pattern, name)) 
[10:21:45.910]                               next
[10:21:45.910]                             invokeRestart(restart)
[10:21:45.910]                             muffled <- TRUE
[10:21:45.910]                             break
[10:21:45.910]                           }
[10:21:45.910]                         }
[10:21:45.910]                       }
[10:21:45.910]                       invisible(muffled)
[10:21:45.910]                     }
[10:21:45.910]                     muffleCondition(cond, pattern = "^muffle")
[10:21:45.910]                   }
[10:21:45.910]                 }
[10:21:45.910]             }
[10:21:45.910]         }))
[10:21:45.910]     }, error = function(ex) {
[10:21:45.910]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:45.910]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:45.910]                 ...future.rng), started = ...future.startTime, 
[10:21:45.910]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:45.910]             version = "1.8"), class = "FutureResult")
[10:21:45.910]     }, finally = {
[10:21:45.910]         if (!identical(...future.workdir, getwd())) 
[10:21:45.910]             setwd(...future.workdir)
[10:21:45.910]         {
[10:21:45.910]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:45.910]                 ...future.oldOptions$nwarnings <- NULL
[10:21:45.910]             }
[10:21:45.910]             base::options(...future.oldOptions)
[10:21:45.910]             if (.Platform$OS.type == "windows") {
[10:21:45.910]                 old_names <- names(...future.oldEnvVars)
[10:21:45.910]                 envs <- base::Sys.getenv()
[10:21:45.910]                 names <- names(envs)
[10:21:45.910]                 common <- intersect(names, old_names)
[10:21:45.910]                 added <- setdiff(names, old_names)
[10:21:45.910]                 removed <- setdiff(old_names, names)
[10:21:45.910]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:45.910]                   envs[common]]
[10:21:45.910]                 NAMES <- toupper(changed)
[10:21:45.910]                 args <- list()
[10:21:45.910]                 for (kk in seq_along(NAMES)) {
[10:21:45.910]                   name <- changed[[kk]]
[10:21:45.910]                   NAME <- NAMES[[kk]]
[10:21:45.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.910]                     next
[10:21:45.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.910]                 }
[10:21:45.910]                 NAMES <- toupper(added)
[10:21:45.910]                 for (kk in seq_along(NAMES)) {
[10:21:45.910]                   name <- added[[kk]]
[10:21:45.910]                   NAME <- NAMES[[kk]]
[10:21:45.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.910]                     next
[10:21:45.910]                   args[[name]] <- ""
[10:21:45.910]                 }
[10:21:45.910]                 NAMES <- toupper(removed)
[10:21:45.910]                 for (kk in seq_along(NAMES)) {
[10:21:45.910]                   name <- removed[[kk]]
[10:21:45.910]                   NAME <- NAMES[[kk]]
[10:21:45.910]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:45.910]                     next
[10:21:45.910]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:45.910]                 }
[10:21:45.910]                 if (length(args) > 0) 
[10:21:45.910]                   base::do.call(base::Sys.setenv, args = args)
[10:21:45.910]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:45.910]             }
[10:21:45.910]             else {
[10:21:45.910]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:45.910]             }
[10:21:45.910]             {
[10:21:45.910]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:45.910]                   0L) {
[10:21:45.910]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:45.910]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:45.910]                   base::options(opts)
[10:21:45.910]                 }
[10:21:45.910]                 {
[10:21:45.910]                   {
[10:21:45.910]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:45.910]                     NULL
[10:21:45.910]                   }
[10:21:45.910]                   options(future.plan = NULL)
[10:21:45.910]                   if (is.na(NA_character_)) 
[10:21:45.910]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:45.910]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:45.910]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:45.910]                     .init = FALSE)
[10:21:45.910]                 }
[10:21:45.910]             }
[10:21:45.910]         }
[10:21:45.910]     })
[10:21:45.910]     if (TRUE) {
[10:21:45.910]         base::sink(type = "output", split = FALSE)
[10:21:45.910]         if (TRUE) {
[10:21:45.910]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:45.910]         }
[10:21:45.910]         else {
[10:21:45.910]             ...future.result["stdout"] <- base::list(NULL)
[10:21:45.910]         }
[10:21:45.910]         base::close(...future.stdout)
[10:21:45.910]         ...future.stdout <- NULL
[10:21:45.910]     }
[10:21:45.910]     ...future.result$conditions <- ...future.conditions
[10:21:45.910]     ...future.result$finished <- base::Sys.time()
[10:21:45.910]     ...future.result
[10:21:45.910] }
[10:21:45.923] Exporting 1 global objects (313.44 KiB) to cluster node #2 ...
[10:21:45.934] Exporting ‘a’ (313.23 KiB) to cluster node #2 ...
[10:21:45.987] Exporting ‘a’ (313.23 KiB) to cluster node #2 ... DONE
[10:21:45.987] Exporting 1 global objects (313.44 KiB) to cluster node #2 ... DONE
[10:21:45.988] MultisessionFuture started
[10:21:45.988] - Launch lazy future ... done
[10:21:45.988] run() for ‘MultisessionFuture’ ... done
[10:21:45.988] result() for ClusterFuture ...
[10:21:45.988] receiveMessageFromWorker() for ClusterFuture ...
[10:21:45.988] - Validating connection of MultisessionFuture
[10:21:46.034] - received message: FutureResult
[10:21:46.034] - Received FutureResult
[10:21:46.034] - Erased future from FutureRegistry
[10:21:46.034] result() for ClusterFuture ...
[10:21:46.034] - result already collected: FutureResult
[10:21:46.034] result() for ClusterFuture ... done
[10:21:46.034] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.034] result() for ClusterFuture ... done
[10:21:46.035] result() for ClusterFuture ...
[10:21:46.035] - result already collected: FutureResult
[10:21:46.035] result() for ClusterFuture ... done
value(b) = 2
[10:21:46.035] result() for ClusterFuture ...
[10:21:46.035] - result already collected: FutureResult
[10:21:46.035] result() for ClusterFuture ... done
[10:21:46.035] result() for ClusterFuture ...
[10:21:46.035] - result already collected: FutureResult
[10:21:46.035] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.036] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.036] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:46.036] 
[10:21:46.037] Searching for globals ... DONE
[10:21:46.037] - globals: [0] <none>
[10:21:46.037] getGlobalsAndPackages() ... DONE
[10:21:46.037] run() for ‘Future’ ...
[10:21:46.037] - state: ‘created’
[10:21:46.037] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.051] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.051] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.051]   - Field: ‘node’
[10:21:46.051]   - Field: ‘label’
[10:21:46.051]   - Field: ‘local’
[10:21:46.052]   - Field: ‘owner’
[10:21:46.052]   - Field: ‘envir’
[10:21:46.052]   - Field: ‘workers’
[10:21:46.052]   - Field: ‘packages’
[10:21:46.052]   - Field: ‘gc’
[10:21:46.052]   - Field: ‘conditions’
[10:21:46.052]   - Field: ‘persistent’
[10:21:46.052]   - Field: ‘expr’
[10:21:46.052]   - Field: ‘uuid’
[10:21:46.052]   - Field: ‘seed’
[10:21:46.052]   - Field: ‘version’
[10:21:46.053]   - Field: ‘result’
[10:21:46.053]   - Field: ‘asynchronous’
[10:21:46.053]   - Field: ‘calls’
[10:21:46.053]   - Field: ‘globals’
[10:21:46.053]   - Field: ‘stdout’
[10:21:46.053]   - Field: ‘earlySignal’
[10:21:46.053]   - Field: ‘lazy’
[10:21:46.053]   - Field: ‘state’
[10:21:46.053] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.053] - Launch lazy future ...
[10:21:46.054] Packages needed by the future expression (n = 0): <none>
[10:21:46.054] Packages needed by future strategies (n = 0): <none>
[10:21:46.054] {
[10:21:46.054]     {
[10:21:46.054]         {
[10:21:46.054]             ...future.startTime <- base::Sys.time()
[10:21:46.054]             {
[10:21:46.054]                 {
[10:21:46.054]                   {
[10:21:46.054]                     {
[10:21:46.054]                       base::local({
[10:21:46.054]                         has_future <- base::requireNamespace("future", 
[10:21:46.054]                           quietly = TRUE)
[10:21:46.054]                         if (has_future) {
[10:21:46.054]                           ns <- base::getNamespace("future")
[10:21:46.054]                           version <- ns[[".package"]][["version"]]
[10:21:46.054]                           if (is.null(version)) 
[10:21:46.054]                             version <- utils::packageVersion("future")
[10:21:46.054]                         }
[10:21:46.054]                         else {
[10:21:46.054]                           version <- NULL
[10:21:46.054]                         }
[10:21:46.054]                         if (!has_future || version < "1.8.0") {
[10:21:46.054]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.054]                             "", base::R.version$version.string), 
[10:21:46.054]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.054]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.054]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.054]                               "release", "version")], collapse = " "), 
[10:21:46.054]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.054]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.054]                             info)
[10:21:46.054]                           info <- base::paste(info, collapse = "; ")
[10:21:46.054]                           if (!has_future) {
[10:21:46.054]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.054]                               info)
[10:21:46.054]                           }
[10:21:46.054]                           else {
[10:21:46.054]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.054]                               info, version)
[10:21:46.054]                           }
[10:21:46.054]                           base::stop(msg)
[10:21:46.054]                         }
[10:21:46.054]                       })
[10:21:46.054]                     }
[10:21:46.054]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.054]                     base::options(mc.cores = 1L)
[10:21:46.054]                   }
[10:21:46.054]                   ...future.strategy.old <- future::plan("list")
[10:21:46.054]                   options(future.plan = NULL)
[10:21:46.054]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.054]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.054]                 }
[10:21:46.054]                 ...future.workdir <- getwd()
[10:21:46.054]             }
[10:21:46.054]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.054]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.054]         }
[10:21:46.054]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.054]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:46.054]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.054]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.054]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.054]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.054]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.054]             base::names(...future.oldOptions))
[10:21:46.054]     }
[10:21:46.054]     if (FALSE) {
[10:21:46.054]     }
[10:21:46.054]     else {
[10:21:46.054]         if (TRUE) {
[10:21:46.054]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.054]                 open = "w")
[10:21:46.054]         }
[10:21:46.054]         else {
[10:21:46.054]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.054]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.054]         }
[10:21:46.054]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.054]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.054]             base::sink(type = "output", split = FALSE)
[10:21:46.054]             base::close(...future.stdout)
[10:21:46.054]         }, add = TRUE)
[10:21:46.054]     }
[10:21:46.054]     ...future.frame <- base::sys.nframe()
[10:21:46.054]     ...future.conditions <- base::list()
[10:21:46.054]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.054]     if (FALSE) {
[10:21:46.054]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.054]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.054]     }
[10:21:46.054]     ...future.result <- base::tryCatch({
[10:21:46.054]         base::withCallingHandlers({
[10:21:46.054]             ...future.value <- base::withVisible(base::local({
[10:21:46.054]                 ...future.makeSendCondition <- base::local({
[10:21:46.054]                   sendCondition <- NULL
[10:21:46.054]                   function(frame = 1L) {
[10:21:46.054]                     if (is.function(sendCondition)) 
[10:21:46.054]                       return(sendCondition)
[10:21:46.054]                     ns <- getNamespace("parallel")
[10:21:46.054]                     if (exists("sendData", mode = "function", 
[10:21:46.054]                       envir = ns)) {
[10:21:46.054]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.054]                         envir = ns)
[10:21:46.054]                       envir <- sys.frame(frame)
[10:21:46.054]                       master <- NULL
[10:21:46.054]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.054]                         !identical(envir, emptyenv())) {
[10:21:46.054]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.054]                           inherits = FALSE)) {
[10:21:46.054]                           master <- get("master", mode = "list", 
[10:21:46.054]                             envir = envir, inherits = FALSE)
[10:21:46.054]                           if (inherits(master, c("SOCKnode", 
[10:21:46.054]                             "SOCK0node"))) {
[10:21:46.054]                             sendCondition <<- function(cond) {
[10:21:46.054]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.054]                                 success = TRUE)
[10:21:46.054]                               parallel_sendData(master, data)
[10:21:46.054]                             }
[10:21:46.054]                             return(sendCondition)
[10:21:46.054]                           }
[10:21:46.054]                         }
[10:21:46.054]                         frame <- frame + 1L
[10:21:46.054]                         envir <- sys.frame(frame)
[10:21:46.054]                       }
[10:21:46.054]                     }
[10:21:46.054]                     sendCondition <<- function(cond) NULL
[10:21:46.054]                   }
[10:21:46.054]                 })
[10:21:46.054]                 withCallingHandlers({
[10:21:46.054]                   1
[10:21:46.054]                 }, immediateCondition = function(cond) {
[10:21:46.054]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.054]                   sendCondition(cond)
[10:21:46.054]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.054]                   {
[10:21:46.054]                     inherits <- base::inherits
[10:21:46.054]                     invokeRestart <- base::invokeRestart
[10:21:46.054]                     is.null <- base::is.null
[10:21:46.054]                     muffled <- FALSE
[10:21:46.054]                     if (inherits(cond, "message")) {
[10:21:46.054]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.054]                       if (muffled) 
[10:21:46.054]                         invokeRestart("muffleMessage")
[10:21:46.054]                     }
[10:21:46.054]                     else if (inherits(cond, "warning")) {
[10:21:46.054]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.054]                       if (muffled) 
[10:21:46.054]                         invokeRestart("muffleWarning")
[10:21:46.054]                     }
[10:21:46.054]                     else if (inherits(cond, "condition")) {
[10:21:46.054]                       if (!is.null(pattern)) {
[10:21:46.054]                         computeRestarts <- base::computeRestarts
[10:21:46.054]                         grepl <- base::grepl
[10:21:46.054]                         restarts <- computeRestarts(cond)
[10:21:46.054]                         for (restart in restarts) {
[10:21:46.054]                           name <- restart$name
[10:21:46.054]                           if (is.null(name)) 
[10:21:46.054]                             next
[10:21:46.054]                           if (!grepl(pattern, name)) 
[10:21:46.054]                             next
[10:21:46.054]                           invokeRestart(restart)
[10:21:46.054]                           muffled <- TRUE
[10:21:46.054]                           break
[10:21:46.054]                         }
[10:21:46.054]                       }
[10:21:46.054]                     }
[10:21:46.054]                     invisible(muffled)
[10:21:46.054]                   }
[10:21:46.054]                   muffleCondition(cond)
[10:21:46.054]                 })
[10:21:46.054]             }))
[10:21:46.054]             future::FutureResult(value = ...future.value$value, 
[10:21:46.054]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.054]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.054]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.054]                     ...future.globalenv.names))
[10:21:46.054]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.054]         }, condition = base::local({
[10:21:46.054]             c <- base::c
[10:21:46.054]             inherits <- base::inherits
[10:21:46.054]             invokeRestart <- base::invokeRestart
[10:21:46.054]             length <- base::length
[10:21:46.054]             list <- base::list
[10:21:46.054]             seq.int <- base::seq.int
[10:21:46.054]             signalCondition <- base::signalCondition
[10:21:46.054]             sys.calls <- base::sys.calls
[10:21:46.054]             `[[` <- base::`[[`
[10:21:46.054]             `+` <- base::`+`
[10:21:46.054]             `<<-` <- base::`<<-`
[10:21:46.054]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.054]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.054]                   3L)]
[10:21:46.054]             }
[10:21:46.054]             function(cond) {
[10:21:46.054]                 is_error <- inherits(cond, "error")
[10:21:46.054]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.054]                   NULL)
[10:21:46.054]                 if (is_error) {
[10:21:46.054]                   sessionInformation <- function() {
[10:21:46.054]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.054]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.054]                       search = base::search(), system = base::Sys.info())
[10:21:46.054]                   }
[10:21:46.054]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.054]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.054]                     cond$call), session = sessionInformation(), 
[10:21:46.054]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.054]                   signalCondition(cond)
[10:21:46.054]                 }
[10:21:46.054]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.054]                 "immediateCondition"))) {
[10:21:46.054]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.054]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.054]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.054]                   if (TRUE && !signal) {
[10:21:46.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.054]                     {
[10:21:46.054]                       inherits <- base::inherits
[10:21:46.054]                       invokeRestart <- base::invokeRestart
[10:21:46.054]                       is.null <- base::is.null
[10:21:46.054]                       muffled <- FALSE
[10:21:46.054]                       if (inherits(cond, "message")) {
[10:21:46.054]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.054]                         if (muffled) 
[10:21:46.054]                           invokeRestart("muffleMessage")
[10:21:46.054]                       }
[10:21:46.054]                       else if (inherits(cond, "warning")) {
[10:21:46.054]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.054]                         if (muffled) 
[10:21:46.054]                           invokeRestart("muffleWarning")
[10:21:46.054]                       }
[10:21:46.054]                       else if (inherits(cond, "condition")) {
[10:21:46.054]                         if (!is.null(pattern)) {
[10:21:46.054]                           computeRestarts <- base::computeRestarts
[10:21:46.054]                           grepl <- base::grepl
[10:21:46.054]                           restarts <- computeRestarts(cond)
[10:21:46.054]                           for (restart in restarts) {
[10:21:46.054]                             name <- restart$name
[10:21:46.054]                             if (is.null(name)) 
[10:21:46.054]                               next
[10:21:46.054]                             if (!grepl(pattern, name)) 
[10:21:46.054]                               next
[10:21:46.054]                             invokeRestart(restart)
[10:21:46.054]                             muffled <- TRUE
[10:21:46.054]                             break
[10:21:46.054]                           }
[10:21:46.054]                         }
[10:21:46.054]                       }
[10:21:46.054]                       invisible(muffled)
[10:21:46.054]                     }
[10:21:46.054]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.054]                   }
[10:21:46.054]                 }
[10:21:46.054]                 else {
[10:21:46.054]                   if (TRUE) {
[10:21:46.054]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.054]                     {
[10:21:46.054]                       inherits <- base::inherits
[10:21:46.054]                       invokeRestart <- base::invokeRestart
[10:21:46.054]                       is.null <- base::is.null
[10:21:46.054]                       muffled <- FALSE
[10:21:46.054]                       if (inherits(cond, "message")) {
[10:21:46.054]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.054]                         if (muffled) 
[10:21:46.054]                           invokeRestart("muffleMessage")
[10:21:46.054]                       }
[10:21:46.054]                       else if (inherits(cond, "warning")) {
[10:21:46.054]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.054]                         if (muffled) 
[10:21:46.054]                           invokeRestart("muffleWarning")
[10:21:46.054]                       }
[10:21:46.054]                       else if (inherits(cond, "condition")) {
[10:21:46.054]                         if (!is.null(pattern)) {
[10:21:46.054]                           computeRestarts <- base::computeRestarts
[10:21:46.054]                           grepl <- base::grepl
[10:21:46.054]                           restarts <- computeRestarts(cond)
[10:21:46.054]                           for (restart in restarts) {
[10:21:46.054]                             name <- restart$name
[10:21:46.054]                             if (is.null(name)) 
[10:21:46.054]                               next
[10:21:46.054]                             if (!grepl(pattern, name)) 
[10:21:46.054]                               next
[10:21:46.054]                             invokeRestart(restart)
[10:21:46.054]                             muffled <- TRUE
[10:21:46.054]                             break
[10:21:46.054]                           }
[10:21:46.054]                         }
[10:21:46.054]                       }
[10:21:46.054]                       invisible(muffled)
[10:21:46.054]                     }
[10:21:46.054]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.054]                   }
[10:21:46.054]                 }
[10:21:46.054]             }
[10:21:46.054]         }))
[10:21:46.054]     }, error = function(ex) {
[10:21:46.054]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.054]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.054]                 ...future.rng), started = ...future.startTime, 
[10:21:46.054]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.054]             version = "1.8"), class = "FutureResult")
[10:21:46.054]     }, finally = {
[10:21:46.054]         if (!identical(...future.workdir, getwd())) 
[10:21:46.054]             setwd(...future.workdir)
[10:21:46.054]         {
[10:21:46.054]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.054]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.054]             }
[10:21:46.054]             base::options(...future.oldOptions)
[10:21:46.054]             if (.Platform$OS.type == "windows") {
[10:21:46.054]                 old_names <- names(...future.oldEnvVars)
[10:21:46.054]                 envs <- base::Sys.getenv()
[10:21:46.054]                 names <- names(envs)
[10:21:46.054]                 common <- intersect(names, old_names)
[10:21:46.054]                 added <- setdiff(names, old_names)
[10:21:46.054]                 removed <- setdiff(old_names, names)
[10:21:46.054]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.054]                   envs[common]]
[10:21:46.054]                 NAMES <- toupper(changed)
[10:21:46.054]                 args <- list()
[10:21:46.054]                 for (kk in seq_along(NAMES)) {
[10:21:46.054]                   name <- changed[[kk]]
[10:21:46.054]                   NAME <- NAMES[[kk]]
[10:21:46.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.054]                     next
[10:21:46.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.054]                 }
[10:21:46.054]                 NAMES <- toupper(added)
[10:21:46.054]                 for (kk in seq_along(NAMES)) {
[10:21:46.054]                   name <- added[[kk]]
[10:21:46.054]                   NAME <- NAMES[[kk]]
[10:21:46.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.054]                     next
[10:21:46.054]                   args[[name]] <- ""
[10:21:46.054]                 }
[10:21:46.054]                 NAMES <- toupper(removed)
[10:21:46.054]                 for (kk in seq_along(NAMES)) {
[10:21:46.054]                   name <- removed[[kk]]
[10:21:46.054]                   NAME <- NAMES[[kk]]
[10:21:46.054]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.054]                     next
[10:21:46.054]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.054]                 }
[10:21:46.054]                 if (length(args) > 0) 
[10:21:46.054]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.054]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.054]             }
[10:21:46.054]             else {
[10:21:46.054]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.054]             }
[10:21:46.054]             {
[10:21:46.054]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.054]                   0L) {
[10:21:46.054]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.054]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.054]                   base::options(opts)
[10:21:46.054]                 }
[10:21:46.054]                 {
[10:21:46.054]                   {
[10:21:46.054]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.054]                     NULL
[10:21:46.054]                   }
[10:21:46.054]                   options(future.plan = NULL)
[10:21:46.054]                   if (is.na(NA_character_)) 
[10:21:46.054]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.054]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.054]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.054]                     .init = FALSE)
[10:21:46.054]                 }
[10:21:46.054]             }
[10:21:46.054]         }
[10:21:46.054]     })
[10:21:46.054]     if (TRUE) {
[10:21:46.054]         base::sink(type = "output", split = FALSE)
[10:21:46.054]         if (TRUE) {
[10:21:46.054]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.054]         }
[10:21:46.054]         else {
[10:21:46.054]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.054]         }
[10:21:46.054]         base::close(...future.stdout)
[10:21:46.054]         ...future.stdout <- NULL
[10:21:46.054]     }
[10:21:46.054]     ...future.result$conditions <- ...future.conditions
[10:21:46.054]     ...future.result$finished <- base::Sys.time()
[10:21:46.054]     ...future.result
[10:21:46.054] }
[10:21:46.057] MultisessionFuture started
[10:21:46.057] - Launch lazy future ... done
[10:21:46.057] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.058] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.058] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:46.059] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:46.059] Searching for globals ... DONE
[10:21:46.059] Resolving globals: TRUE
[10:21:46.059] Resolving any globals that are futures ...
[10:21:46.059] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:46.059] Resolving any globals that are futures ... DONE
[10:21:46.059] Resolving futures part of globals (recursively) ...
[10:21:46.060] resolve() on list ...
[10:21:46.060]  recursive: 99
[10:21:46.060]  length: 1
[10:21:46.060]  elements: ‘a’
[10:21:46.102] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.102] - Validating connection of MultisessionFuture
[10:21:46.102] - received message: FutureResult
[10:21:46.102] - Received FutureResult
[10:21:46.102] - Erased future from FutureRegistry
[10:21:46.102] result() for ClusterFuture ...
[10:21:46.102] - result already collected: FutureResult
[10:21:46.102] result() for ClusterFuture ... done
[10:21:46.103] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.103] Future #1
[10:21:46.103] result() for ClusterFuture ...
[10:21:46.103] - result already collected: FutureResult
[10:21:46.103] result() for ClusterFuture ... done
[10:21:46.103] result() for ClusterFuture ...
[10:21:46.103] - result already collected: FutureResult
[10:21:46.103] result() for ClusterFuture ... done
[10:21:46.103] A MultisessionFuture was resolved
[10:21:46.103]  length: 0 (resolved future 1)
[10:21:46.103] resolve() on list ... DONE
[10:21:46.104] - globals: [1] ‘a’
[10:21:46.104] Resolving futures part of globals (recursively) ... DONE
[10:21:46.114] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[10:21:46.115] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[10:21:46.115] - globals: [1] ‘a’
[10:21:46.115] - packages: [1] ‘future’
[10:21:46.115] getGlobalsAndPackages() ... DONE
[10:21:46.115] run() for ‘Future’ ...
[10:21:46.116] - state: ‘created’
[10:21:46.116] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.130] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.130] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.130]   - Field: ‘node’
[10:21:46.130]   - Field: ‘label’
[10:21:46.130]   - Field: ‘local’
[10:21:46.130]   - Field: ‘owner’
[10:21:46.130]   - Field: ‘envir’
[10:21:46.130]   - Field: ‘workers’
[10:21:46.131]   - Field: ‘packages’
[10:21:46.131]   - Field: ‘gc’
[10:21:46.131]   - Field: ‘conditions’
[10:21:46.131]   - Field: ‘persistent’
[10:21:46.131]   - Field: ‘expr’
[10:21:46.131]   - Field: ‘uuid’
[10:21:46.131]   - Field: ‘seed’
[10:21:46.131]   - Field: ‘version’
[10:21:46.131]   - Field: ‘result’
[10:21:46.131]   - Field: ‘asynchronous’
[10:21:46.131]   - Field: ‘calls’
[10:21:46.131]   - Field: ‘globals’
[10:21:46.132]   - Field: ‘stdout’
[10:21:46.134]   - Field: ‘earlySignal’
[10:21:46.134]   - Field: ‘lazy’
[10:21:46.134]   - Field: ‘state’
[10:21:46.134] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.134] - Launch lazy future ...
[10:21:46.134] Packages needed by the future expression (n = 1): ‘future’
[10:21:46.134] Packages needed by future strategies (n = 0): <none>
[10:21:46.135] {
[10:21:46.135]     {
[10:21:46.135]         {
[10:21:46.135]             ...future.startTime <- base::Sys.time()
[10:21:46.135]             {
[10:21:46.135]                 {
[10:21:46.135]                   {
[10:21:46.135]                     {
[10:21:46.135]                       {
[10:21:46.135]                         base::local({
[10:21:46.135]                           has_future <- base::requireNamespace("future", 
[10:21:46.135]                             quietly = TRUE)
[10:21:46.135]                           if (has_future) {
[10:21:46.135]                             ns <- base::getNamespace("future")
[10:21:46.135]                             version <- ns[[".package"]][["version"]]
[10:21:46.135]                             if (is.null(version)) 
[10:21:46.135]                               version <- utils::packageVersion("future")
[10:21:46.135]                           }
[10:21:46.135]                           else {
[10:21:46.135]                             version <- NULL
[10:21:46.135]                           }
[10:21:46.135]                           if (!has_future || version < "1.8.0") {
[10:21:46.135]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.135]                               "", base::R.version$version.string), 
[10:21:46.135]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:46.135]                                 base::R.version$platform, 8 * 
[10:21:46.135]                                   base::.Machine$sizeof.pointer), 
[10:21:46.135]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.135]                                 "release", "version")], collapse = " "), 
[10:21:46.135]                               hostname = base::Sys.info()[["nodename"]])
[10:21:46.135]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.135]                               info)
[10:21:46.135]                             info <- base::paste(info, collapse = "; ")
[10:21:46.135]                             if (!has_future) {
[10:21:46.135]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.135]                                 info)
[10:21:46.135]                             }
[10:21:46.135]                             else {
[10:21:46.135]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.135]                                 info, version)
[10:21:46.135]                             }
[10:21:46.135]                             base::stop(msg)
[10:21:46.135]                           }
[10:21:46.135]                         })
[10:21:46.135]                       }
[10:21:46.135]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.135]                       base::options(mc.cores = 1L)
[10:21:46.135]                     }
[10:21:46.135]                     base::local({
[10:21:46.135]                       for (pkg in "future") {
[10:21:46.135]                         base::loadNamespace(pkg)
[10:21:46.135]                         base::library(pkg, character.only = TRUE)
[10:21:46.135]                       }
[10:21:46.135]                     })
[10:21:46.135]                   }
[10:21:46.135]                   ...future.strategy.old <- future::plan("list")
[10:21:46.135]                   options(future.plan = NULL)
[10:21:46.135]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.135]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.135]                 }
[10:21:46.135]                 ...future.workdir <- getwd()
[10:21:46.135]             }
[10:21:46.135]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.135]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.135]         }
[10:21:46.135]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.135]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:46.135]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.135]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.135]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.135]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.135]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.135]             base::names(...future.oldOptions))
[10:21:46.135]     }
[10:21:46.135]     if (FALSE) {
[10:21:46.135]     }
[10:21:46.135]     else {
[10:21:46.135]         if (TRUE) {
[10:21:46.135]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.135]                 open = "w")
[10:21:46.135]         }
[10:21:46.135]         else {
[10:21:46.135]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.135]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.135]         }
[10:21:46.135]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.135]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.135]             base::sink(type = "output", split = FALSE)
[10:21:46.135]             base::close(...future.stdout)
[10:21:46.135]         }, add = TRUE)
[10:21:46.135]     }
[10:21:46.135]     ...future.frame <- base::sys.nframe()
[10:21:46.135]     ...future.conditions <- base::list()
[10:21:46.135]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.135]     if (FALSE) {
[10:21:46.135]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.135]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.135]     }
[10:21:46.135]     ...future.result <- base::tryCatch({
[10:21:46.135]         base::withCallingHandlers({
[10:21:46.135]             ...future.value <- base::withVisible(base::local({
[10:21:46.135]                 ...future.makeSendCondition <- base::local({
[10:21:46.135]                   sendCondition <- NULL
[10:21:46.135]                   function(frame = 1L) {
[10:21:46.135]                     if (is.function(sendCondition)) 
[10:21:46.135]                       return(sendCondition)
[10:21:46.135]                     ns <- getNamespace("parallel")
[10:21:46.135]                     if (exists("sendData", mode = "function", 
[10:21:46.135]                       envir = ns)) {
[10:21:46.135]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.135]                         envir = ns)
[10:21:46.135]                       envir <- sys.frame(frame)
[10:21:46.135]                       master <- NULL
[10:21:46.135]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.135]                         !identical(envir, emptyenv())) {
[10:21:46.135]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.135]                           inherits = FALSE)) {
[10:21:46.135]                           master <- get("master", mode = "list", 
[10:21:46.135]                             envir = envir, inherits = FALSE)
[10:21:46.135]                           if (inherits(master, c("SOCKnode", 
[10:21:46.135]                             "SOCK0node"))) {
[10:21:46.135]                             sendCondition <<- function(cond) {
[10:21:46.135]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.135]                                 success = TRUE)
[10:21:46.135]                               parallel_sendData(master, data)
[10:21:46.135]                             }
[10:21:46.135]                             return(sendCondition)
[10:21:46.135]                           }
[10:21:46.135]                         }
[10:21:46.135]                         frame <- frame + 1L
[10:21:46.135]                         envir <- sys.frame(frame)
[10:21:46.135]                       }
[10:21:46.135]                     }
[10:21:46.135]                     sendCondition <<- function(cond) NULL
[10:21:46.135]                   }
[10:21:46.135]                 })
[10:21:46.135]                 withCallingHandlers({
[10:21:46.135]                   value(a) + 1
[10:21:46.135]                 }, immediateCondition = function(cond) {
[10:21:46.135]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.135]                   sendCondition(cond)
[10:21:46.135]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.135]                   {
[10:21:46.135]                     inherits <- base::inherits
[10:21:46.135]                     invokeRestart <- base::invokeRestart
[10:21:46.135]                     is.null <- base::is.null
[10:21:46.135]                     muffled <- FALSE
[10:21:46.135]                     if (inherits(cond, "message")) {
[10:21:46.135]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.135]                       if (muffled) 
[10:21:46.135]                         invokeRestart("muffleMessage")
[10:21:46.135]                     }
[10:21:46.135]                     else if (inherits(cond, "warning")) {
[10:21:46.135]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.135]                       if (muffled) 
[10:21:46.135]                         invokeRestart("muffleWarning")
[10:21:46.135]                     }
[10:21:46.135]                     else if (inherits(cond, "condition")) {
[10:21:46.135]                       if (!is.null(pattern)) {
[10:21:46.135]                         computeRestarts <- base::computeRestarts
[10:21:46.135]                         grepl <- base::grepl
[10:21:46.135]                         restarts <- computeRestarts(cond)
[10:21:46.135]                         for (restart in restarts) {
[10:21:46.135]                           name <- restart$name
[10:21:46.135]                           if (is.null(name)) 
[10:21:46.135]                             next
[10:21:46.135]                           if (!grepl(pattern, name)) 
[10:21:46.135]                             next
[10:21:46.135]                           invokeRestart(restart)
[10:21:46.135]                           muffled <- TRUE
[10:21:46.135]                           break
[10:21:46.135]                         }
[10:21:46.135]                       }
[10:21:46.135]                     }
[10:21:46.135]                     invisible(muffled)
[10:21:46.135]                   }
[10:21:46.135]                   muffleCondition(cond)
[10:21:46.135]                 })
[10:21:46.135]             }))
[10:21:46.135]             future::FutureResult(value = ...future.value$value, 
[10:21:46.135]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.135]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.135]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.135]                     ...future.globalenv.names))
[10:21:46.135]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.135]         }, condition = base::local({
[10:21:46.135]             c <- base::c
[10:21:46.135]             inherits <- base::inherits
[10:21:46.135]             invokeRestart <- base::invokeRestart
[10:21:46.135]             length <- base::length
[10:21:46.135]             list <- base::list
[10:21:46.135]             seq.int <- base::seq.int
[10:21:46.135]             signalCondition <- base::signalCondition
[10:21:46.135]             sys.calls <- base::sys.calls
[10:21:46.135]             `[[` <- base::`[[`
[10:21:46.135]             `+` <- base::`+`
[10:21:46.135]             `<<-` <- base::`<<-`
[10:21:46.135]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.135]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.135]                   3L)]
[10:21:46.135]             }
[10:21:46.135]             function(cond) {
[10:21:46.135]                 is_error <- inherits(cond, "error")
[10:21:46.135]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.135]                   NULL)
[10:21:46.135]                 if (is_error) {
[10:21:46.135]                   sessionInformation <- function() {
[10:21:46.135]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.135]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.135]                       search = base::search(), system = base::Sys.info())
[10:21:46.135]                   }
[10:21:46.135]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.135]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.135]                     cond$call), session = sessionInformation(), 
[10:21:46.135]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.135]                   signalCondition(cond)
[10:21:46.135]                 }
[10:21:46.135]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.135]                 "immediateCondition"))) {
[10:21:46.135]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.135]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.135]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.135]                   if (TRUE && !signal) {
[10:21:46.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.135]                     {
[10:21:46.135]                       inherits <- base::inherits
[10:21:46.135]                       invokeRestart <- base::invokeRestart
[10:21:46.135]                       is.null <- base::is.null
[10:21:46.135]                       muffled <- FALSE
[10:21:46.135]                       if (inherits(cond, "message")) {
[10:21:46.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.135]                         if (muffled) 
[10:21:46.135]                           invokeRestart("muffleMessage")
[10:21:46.135]                       }
[10:21:46.135]                       else if (inherits(cond, "warning")) {
[10:21:46.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.135]                         if (muffled) 
[10:21:46.135]                           invokeRestart("muffleWarning")
[10:21:46.135]                       }
[10:21:46.135]                       else if (inherits(cond, "condition")) {
[10:21:46.135]                         if (!is.null(pattern)) {
[10:21:46.135]                           computeRestarts <- base::computeRestarts
[10:21:46.135]                           grepl <- base::grepl
[10:21:46.135]                           restarts <- computeRestarts(cond)
[10:21:46.135]                           for (restart in restarts) {
[10:21:46.135]                             name <- restart$name
[10:21:46.135]                             if (is.null(name)) 
[10:21:46.135]                               next
[10:21:46.135]                             if (!grepl(pattern, name)) 
[10:21:46.135]                               next
[10:21:46.135]                             invokeRestart(restart)
[10:21:46.135]                             muffled <- TRUE
[10:21:46.135]                             break
[10:21:46.135]                           }
[10:21:46.135]                         }
[10:21:46.135]                       }
[10:21:46.135]                       invisible(muffled)
[10:21:46.135]                     }
[10:21:46.135]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.135]                   }
[10:21:46.135]                 }
[10:21:46.135]                 else {
[10:21:46.135]                   if (TRUE) {
[10:21:46.135]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.135]                     {
[10:21:46.135]                       inherits <- base::inherits
[10:21:46.135]                       invokeRestart <- base::invokeRestart
[10:21:46.135]                       is.null <- base::is.null
[10:21:46.135]                       muffled <- FALSE
[10:21:46.135]                       if (inherits(cond, "message")) {
[10:21:46.135]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.135]                         if (muffled) 
[10:21:46.135]                           invokeRestart("muffleMessage")
[10:21:46.135]                       }
[10:21:46.135]                       else if (inherits(cond, "warning")) {
[10:21:46.135]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.135]                         if (muffled) 
[10:21:46.135]                           invokeRestart("muffleWarning")
[10:21:46.135]                       }
[10:21:46.135]                       else if (inherits(cond, "condition")) {
[10:21:46.135]                         if (!is.null(pattern)) {
[10:21:46.135]                           computeRestarts <- base::computeRestarts
[10:21:46.135]                           grepl <- base::grepl
[10:21:46.135]                           restarts <- computeRestarts(cond)
[10:21:46.135]                           for (restart in restarts) {
[10:21:46.135]                             name <- restart$name
[10:21:46.135]                             if (is.null(name)) 
[10:21:46.135]                               next
[10:21:46.135]                             if (!grepl(pattern, name)) 
[10:21:46.135]                               next
[10:21:46.135]                             invokeRestart(restart)
[10:21:46.135]                             muffled <- TRUE
[10:21:46.135]                             break
[10:21:46.135]                           }
[10:21:46.135]                         }
[10:21:46.135]                       }
[10:21:46.135]                       invisible(muffled)
[10:21:46.135]                     }
[10:21:46.135]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.135]                   }
[10:21:46.135]                 }
[10:21:46.135]             }
[10:21:46.135]         }))
[10:21:46.135]     }, error = function(ex) {
[10:21:46.135]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.135]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.135]                 ...future.rng), started = ...future.startTime, 
[10:21:46.135]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.135]             version = "1.8"), class = "FutureResult")
[10:21:46.135]     }, finally = {
[10:21:46.135]         if (!identical(...future.workdir, getwd())) 
[10:21:46.135]             setwd(...future.workdir)
[10:21:46.135]         {
[10:21:46.135]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.135]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.135]             }
[10:21:46.135]             base::options(...future.oldOptions)
[10:21:46.135]             if (.Platform$OS.type == "windows") {
[10:21:46.135]                 old_names <- names(...future.oldEnvVars)
[10:21:46.135]                 envs <- base::Sys.getenv()
[10:21:46.135]                 names <- names(envs)
[10:21:46.135]                 common <- intersect(names, old_names)
[10:21:46.135]                 added <- setdiff(names, old_names)
[10:21:46.135]                 removed <- setdiff(old_names, names)
[10:21:46.135]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.135]                   envs[common]]
[10:21:46.135]                 NAMES <- toupper(changed)
[10:21:46.135]                 args <- list()
[10:21:46.135]                 for (kk in seq_along(NAMES)) {
[10:21:46.135]                   name <- changed[[kk]]
[10:21:46.135]                   NAME <- NAMES[[kk]]
[10:21:46.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.135]                     next
[10:21:46.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.135]                 }
[10:21:46.135]                 NAMES <- toupper(added)
[10:21:46.135]                 for (kk in seq_along(NAMES)) {
[10:21:46.135]                   name <- added[[kk]]
[10:21:46.135]                   NAME <- NAMES[[kk]]
[10:21:46.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.135]                     next
[10:21:46.135]                   args[[name]] <- ""
[10:21:46.135]                 }
[10:21:46.135]                 NAMES <- toupper(removed)
[10:21:46.135]                 for (kk in seq_along(NAMES)) {
[10:21:46.135]                   name <- removed[[kk]]
[10:21:46.135]                   NAME <- NAMES[[kk]]
[10:21:46.135]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.135]                     next
[10:21:46.135]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.135]                 }
[10:21:46.135]                 if (length(args) > 0) 
[10:21:46.135]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.135]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.135]             }
[10:21:46.135]             else {
[10:21:46.135]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.135]             }
[10:21:46.135]             {
[10:21:46.135]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.135]                   0L) {
[10:21:46.135]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.135]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.135]                   base::options(opts)
[10:21:46.135]                 }
[10:21:46.135]                 {
[10:21:46.135]                   {
[10:21:46.135]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.135]                     NULL
[10:21:46.135]                   }
[10:21:46.135]                   options(future.plan = NULL)
[10:21:46.135]                   if (is.na(NA_character_)) 
[10:21:46.135]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.135]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.135]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.135]                     .init = FALSE)
[10:21:46.135]                 }
[10:21:46.135]             }
[10:21:46.135]         }
[10:21:46.135]     })
[10:21:46.135]     if (TRUE) {
[10:21:46.135]         base::sink(type = "output", split = FALSE)
[10:21:46.135]         if (TRUE) {
[10:21:46.135]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.135]         }
[10:21:46.135]         else {
[10:21:46.135]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.135]         }
[10:21:46.135]         base::close(...future.stdout)
[10:21:46.135]         ...future.stdout <- NULL
[10:21:46.135]     }
[10:21:46.135]     ...future.result$conditions <- ...future.conditions
[10:21:46.135]     ...future.result$finished <- base::Sys.time()
[10:21:46.135]     ...future.result
[10:21:46.135] }
[10:21:46.148] Exporting 1 global objects (313.44 KiB) to cluster node #2 ...
[10:21:46.159] Exporting ‘a’ (313.23 KiB) to cluster node #2 ...
[10:21:46.212] Exporting ‘a’ (313.23 KiB) to cluster node #2 ... DONE
[10:21:46.212] Exporting 1 global objects (313.44 KiB) to cluster node #2 ... DONE
[10:21:46.213] MultisessionFuture started
[10:21:46.213] - Launch lazy future ... done
[10:21:46.213] run() for ‘MultisessionFuture’ ... done
[10:21:46.213] result() for ClusterFuture ...
[10:21:46.213] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.213] - Validating connection of MultisessionFuture
[10:21:46.256] - received message: FutureResult
[10:21:46.256] - Received FutureResult
[10:21:46.256] - Erased future from FutureRegistry
[10:21:46.256] result() for ClusterFuture ...
[10:21:46.256] - result already collected: FutureResult
[10:21:46.256] result() for ClusterFuture ... done
[10:21:46.257] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.257] result() for ClusterFuture ... done
[10:21:46.257] result() for ClusterFuture ...
[10:21:46.257] - result already collected: FutureResult
[10:21:46.257] result() for ClusterFuture ... done
value(b) = 2
[10:21:46.257] result() for ClusterFuture ...
[10:21:46.257] - result already collected: FutureResult
[10:21:46.257] result() for ClusterFuture ... done
[10:21:46.257] result() for ClusterFuture ...
[10:21:46.257] - result already collected: FutureResult
[10:21:46.258] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.258] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.258] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:46.259] 
[10:21:46.259] Searching for globals ... DONE
[10:21:46.259] - globals: [0] <none>
[10:21:46.259] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.259] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.259] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:46.260] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:46.260] Searching for globals ... DONE
[10:21:46.261] Resolving globals: TRUE
[10:21:46.261] Resolving any globals that are futures ...
[10:21:46.261] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:46.261] Resolving any globals that are futures ... DONE
[10:21:46.261] Resolving futures part of globals (recursively) ...
[10:21:46.261] resolve() on list ...
[10:21:46.261]  recursive: 99
[10:21:46.262]  length: 1
[10:21:46.262]  elements: ‘a’
[10:21:46.262] run() for ‘Future’ ...
[10:21:46.262] - state: ‘created’
[10:21:46.262] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.276] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.276] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.276]   - Field: ‘node’
[10:21:46.276]   - Field: ‘label’
[10:21:46.276]   - Field: ‘local’
[10:21:46.276]   - Field: ‘owner’
[10:21:46.276]   - Field: ‘envir’
[10:21:46.277]   - Field: ‘workers’
[10:21:46.277]   - Field: ‘packages’
[10:21:46.277]   - Field: ‘gc’
[10:21:46.277]   - Field: ‘conditions’
[10:21:46.277]   - Field: ‘persistent’
[10:21:46.277]   - Field: ‘expr’
[10:21:46.277]   - Field: ‘uuid’
[10:21:46.277]   - Field: ‘seed’
[10:21:46.277]   - Field: ‘version’
[10:21:46.277]   - Field: ‘result’
[10:21:46.277]   - Field: ‘asynchronous’
[10:21:46.277]   - Field: ‘calls’
[10:21:46.278]   - Field: ‘globals’
[10:21:46.278]   - Field: ‘stdout’
[10:21:46.278]   - Field: ‘earlySignal’
[10:21:46.278]   - Field: ‘lazy’
[10:21:46.278]   - Field: ‘state’
[10:21:46.278] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.278] - Launch lazy future ...
[10:21:46.278] Packages needed by the future expression (n = 0): <none>
[10:21:46.278] Packages needed by future strategies (n = 0): <none>
[10:21:46.279] {
[10:21:46.279]     {
[10:21:46.279]         {
[10:21:46.279]             ...future.startTime <- base::Sys.time()
[10:21:46.279]             {
[10:21:46.279]                 {
[10:21:46.279]                   {
[10:21:46.279]                     {
[10:21:46.279]                       base::local({
[10:21:46.279]                         has_future <- base::requireNamespace("future", 
[10:21:46.279]                           quietly = TRUE)
[10:21:46.279]                         if (has_future) {
[10:21:46.279]                           ns <- base::getNamespace("future")
[10:21:46.279]                           version <- ns[[".package"]][["version"]]
[10:21:46.279]                           if (is.null(version)) 
[10:21:46.279]                             version <- utils::packageVersion("future")
[10:21:46.279]                         }
[10:21:46.279]                         else {
[10:21:46.279]                           version <- NULL
[10:21:46.279]                         }
[10:21:46.279]                         if (!has_future || version < "1.8.0") {
[10:21:46.279]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.279]                             "", base::R.version$version.string), 
[10:21:46.279]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.279]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.279]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.279]                               "release", "version")], collapse = " "), 
[10:21:46.279]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.279]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.279]                             info)
[10:21:46.279]                           info <- base::paste(info, collapse = "; ")
[10:21:46.279]                           if (!has_future) {
[10:21:46.279]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.279]                               info)
[10:21:46.279]                           }
[10:21:46.279]                           else {
[10:21:46.279]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.279]                               info, version)
[10:21:46.279]                           }
[10:21:46.279]                           base::stop(msg)
[10:21:46.279]                         }
[10:21:46.279]                       })
[10:21:46.279]                     }
[10:21:46.279]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.279]                     base::options(mc.cores = 1L)
[10:21:46.279]                   }
[10:21:46.279]                   ...future.strategy.old <- future::plan("list")
[10:21:46.279]                   options(future.plan = NULL)
[10:21:46.279]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.279]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.279]                 }
[10:21:46.279]                 ...future.workdir <- getwd()
[10:21:46.279]             }
[10:21:46.279]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.279]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.279]         }
[10:21:46.279]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.279]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:46.279]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.279]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.279]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.279]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.279]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.279]             base::names(...future.oldOptions))
[10:21:46.279]     }
[10:21:46.279]     if (FALSE) {
[10:21:46.279]     }
[10:21:46.279]     else {
[10:21:46.279]         if (TRUE) {
[10:21:46.279]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.279]                 open = "w")
[10:21:46.279]         }
[10:21:46.279]         else {
[10:21:46.279]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.279]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.279]         }
[10:21:46.279]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.279]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.279]             base::sink(type = "output", split = FALSE)
[10:21:46.279]             base::close(...future.stdout)
[10:21:46.279]         }, add = TRUE)
[10:21:46.279]     }
[10:21:46.279]     ...future.frame <- base::sys.nframe()
[10:21:46.279]     ...future.conditions <- base::list()
[10:21:46.279]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.279]     if (FALSE) {
[10:21:46.279]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.279]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.279]     }
[10:21:46.279]     ...future.result <- base::tryCatch({
[10:21:46.279]         base::withCallingHandlers({
[10:21:46.279]             ...future.value <- base::withVisible(base::local({
[10:21:46.279]                 ...future.makeSendCondition <- base::local({
[10:21:46.279]                   sendCondition <- NULL
[10:21:46.279]                   function(frame = 1L) {
[10:21:46.279]                     if (is.function(sendCondition)) 
[10:21:46.279]                       return(sendCondition)
[10:21:46.279]                     ns <- getNamespace("parallel")
[10:21:46.279]                     if (exists("sendData", mode = "function", 
[10:21:46.279]                       envir = ns)) {
[10:21:46.279]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.279]                         envir = ns)
[10:21:46.279]                       envir <- sys.frame(frame)
[10:21:46.279]                       master <- NULL
[10:21:46.279]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.279]                         !identical(envir, emptyenv())) {
[10:21:46.279]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.279]                           inherits = FALSE)) {
[10:21:46.279]                           master <- get("master", mode = "list", 
[10:21:46.279]                             envir = envir, inherits = FALSE)
[10:21:46.279]                           if (inherits(master, c("SOCKnode", 
[10:21:46.279]                             "SOCK0node"))) {
[10:21:46.279]                             sendCondition <<- function(cond) {
[10:21:46.279]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.279]                                 success = TRUE)
[10:21:46.279]                               parallel_sendData(master, data)
[10:21:46.279]                             }
[10:21:46.279]                             return(sendCondition)
[10:21:46.279]                           }
[10:21:46.279]                         }
[10:21:46.279]                         frame <- frame + 1L
[10:21:46.279]                         envir <- sys.frame(frame)
[10:21:46.279]                       }
[10:21:46.279]                     }
[10:21:46.279]                     sendCondition <<- function(cond) NULL
[10:21:46.279]                   }
[10:21:46.279]                 })
[10:21:46.279]                 withCallingHandlers({
[10:21:46.279]                   1
[10:21:46.279]                 }, immediateCondition = function(cond) {
[10:21:46.279]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.279]                   sendCondition(cond)
[10:21:46.279]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.279]                   {
[10:21:46.279]                     inherits <- base::inherits
[10:21:46.279]                     invokeRestart <- base::invokeRestart
[10:21:46.279]                     is.null <- base::is.null
[10:21:46.279]                     muffled <- FALSE
[10:21:46.279]                     if (inherits(cond, "message")) {
[10:21:46.279]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.279]                       if (muffled) 
[10:21:46.279]                         invokeRestart("muffleMessage")
[10:21:46.279]                     }
[10:21:46.279]                     else if (inherits(cond, "warning")) {
[10:21:46.279]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.279]                       if (muffled) 
[10:21:46.279]                         invokeRestart("muffleWarning")
[10:21:46.279]                     }
[10:21:46.279]                     else if (inherits(cond, "condition")) {
[10:21:46.279]                       if (!is.null(pattern)) {
[10:21:46.279]                         computeRestarts <- base::computeRestarts
[10:21:46.279]                         grepl <- base::grepl
[10:21:46.279]                         restarts <- computeRestarts(cond)
[10:21:46.279]                         for (restart in restarts) {
[10:21:46.279]                           name <- restart$name
[10:21:46.279]                           if (is.null(name)) 
[10:21:46.279]                             next
[10:21:46.279]                           if (!grepl(pattern, name)) 
[10:21:46.279]                             next
[10:21:46.279]                           invokeRestart(restart)
[10:21:46.279]                           muffled <- TRUE
[10:21:46.279]                           break
[10:21:46.279]                         }
[10:21:46.279]                       }
[10:21:46.279]                     }
[10:21:46.279]                     invisible(muffled)
[10:21:46.279]                   }
[10:21:46.279]                   muffleCondition(cond)
[10:21:46.279]                 })
[10:21:46.279]             }))
[10:21:46.279]             future::FutureResult(value = ...future.value$value, 
[10:21:46.279]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.279]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.279]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.279]                     ...future.globalenv.names))
[10:21:46.279]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.279]         }, condition = base::local({
[10:21:46.279]             c <- base::c
[10:21:46.279]             inherits <- base::inherits
[10:21:46.279]             invokeRestart <- base::invokeRestart
[10:21:46.279]             length <- base::length
[10:21:46.279]             list <- base::list
[10:21:46.279]             seq.int <- base::seq.int
[10:21:46.279]             signalCondition <- base::signalCondition
[10:21:46.279]             sys.calls <- base::sys.calls
[10:21:46.279]             `[[` <- base::`[[`
[10:21:46.279]             `+` <- base::`+`
[10:21:46.279]             `<<-` <- base::`<<-`
[10:21:46.279]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.279]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.279]                   3L)]
[10:21:46.279]             }
[10:21:46.279]             function(cond) {
[10:21:46.279]                 is_error <- inherits(cond, "error")
[10:21:46.279]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.279]                   NULL)
[10:21:46.279]                 if (is_error) {
[10:21:46.279]                   sessionInformation <- function() {
[10:21:46.279]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.279]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.279]                       search = base::search(), system = base::Sys.info())
[10:21:46.279]                   }
[10:21:46.279]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.279]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.279]                     cond$call), session = sessionInformation(), 
[10:21:46.279]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.279]                   signalCondition(cond)
[10:21:46.279]                 }
[10:21:46.279]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.279]                 "immediateCondition"))) {
[10:21:46.279]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.279]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.279]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.279]                   if (TRUE && !signal) {
[10:21:46.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.279]                     {
[10:21:46.279]                       inherits <- base::inherits
[10:21:46.279]                       invokeRestart <- base::invokeRestart
[10:21:46.279]                       is.null <- base::is.null
[10:21:46.279]                       muffled <- FALSE
[10:21:46.279]                       if (inherits(cond, "message")) {
[10:21:46.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.279]                         if (muffled) 
[10:21:46.279]                           invokeRestart("muffleMessage")
[10:21:46.279]                       }
[10:21:46.279]                       else if (inherits(cond, "warning")) {
[10:21:46.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.279]                         if (muffled) 
[10:21:46.279]                           invokeRestart("muffleWarning")
[10:21:46.279]                       }
[10:21:46.279]                       else if (inherits(cond, "condition")) {
[10:21:46.279]                         if (!is.null(pattern)) {
[10:21:46.279]                           computeRestarts <- base::computeRestarts
[10:21:46.279]                           grepl <- base::grepl
[10:21:46.279]                           restarts <- computeRestarts(cond)
[10:21:46.279]                           for (restart in restarts) {
[10:21:46.279]                             name <- restart$name
[10:21:46.279]                             if (is.null(name)) 
[10:21:46.279]                               next
[10:21:46.279]                             if (!grepl(pattern, name)) 
[10:21:46.279]                               next
[10:21:46.279]                             invokeRestart(restart)
[10:21:46.279]                             muffled <- TRUE
[10:21:46.279]                             break
[10:21:46.279]                           }
[10:21:46.279]                         }
[10:21:46.279]                       }
[10:21:46.279]                       invisible(muffled)
[10:21:46.279]                     }
[10:21:46.279]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.279]                   }
[10:21:46.279]                 }
[10:21:46.279]                 else {
[10:21:46.279]                   if (TRUE) {
[10:21:46.279]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.279]                     {
[10:21:46.279]                       inherits <- base::inherits
[10:21:46.279]                       invokeRestart <- base::invokeRestart
[10:21:46.279]                       is.null <- base::is.null
[10:21:46.279]                       muffled <- FALSE
[10:21:46.279]                       if (inherits(cond, "message")) {
[10:21:46.279]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.279]                         if (muffled) 
[10:21:46.279]                           invokeRestart("muffleMessage")
[10:21:46.279]                       }
[10:21:46.279]                       else if (inherits(cond, "warning")) {
[10:21:46.279]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.279]                         if (muffled) 
[10:21:46.279]                           invokeRestart("muffleWarning")
[10:21:46.279]                       }
[10:21:46.279]                       else if (inherits(cond, "condition")) {
[10:21:46.279]                         if (!is.null(pattern)) {
[10:21:46.279]                           computeRestarts <- base::computeRestarts
[10:21:46.279]                           grepl <- base::grepl
[10:21:46.279]                           restarts <- computeRestarts(cond)
[10:21:46.279]                           for (restart in restarts) {
[10:21:46.279]                             name <- restart$name
[10:21:46.279]                             if (is.null(name)) 
[10:21:46.279]                               next
[10:21:46.279]                             if (!grepl(pattern, name)) 
[10:21:46.279]                               next
[10:21:46.279]                             invokeRestart(restart)
[10:21:46.279]                             muffled <- TRUE
[10:21:46.279]                             break
[10:21:46.279]                           }
[10:21:46.279]                         }
[10:21:46.279]                       }
[10:21:46.279]                       invisible(muffled)
[10:21:46.279]                     }
[10:21:46.279]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.279]                   }
[10:21:46.279]                 }
[10:21:46.279]             }
[10:21:46.279]         }))
[10:21:46.279]     }, error = function(ex) {
[10:21:46.279]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.279]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.279]                 ...future.rng), started = ...future.startTime, 
[10:21:46.279]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.279]             version = "1.8"), class = "FutureResult")
[10:21:46.279]     }, finally = {
[10:21:46.279]         if (!identical(...future.workdir, getwd())) 
[10:21:46.279]             setwd(...future.workdir)
[10:21:46.279]         {
[10:21:46.279]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.279]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.279]             }
[10:21:46.279]             base::options(...future.oldOptions)
[10:21:46.279]             if (.Platform$OS.type == "windows") {
[10:21:46.279]                 old_names <- names(...future.oldEnvVars)
[10:21:46.279]                 envs <- base::Sys.getenv()
[10:21:46.279]                 names <- names(envs)
[10:21:46.279]                 common <- intersect(names, old_names)
[10:21:46.279]                 added <- setdiff(names, old_names)
[10:21:46.279]                 removed <- setdiff(old_names, names)
[10:21:46.279]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.279]                   envs[common]]
[10:21:46.279]                 NAMES <- toupper(changed)
[10:21:46.279]                 args <- list()
[10:21:46.279]                 for (kk in seq_along(NAMES)) {
[10:21:46.279]                   name <- changed[[kk]]
[10:21:46.279]                   NAME <- NAMES[[kk]]
[10:21:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.279]                     next
[10:21:46.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.279]                 }
[10:21:46.279]                 NAMES <- toupper(added)
[10:21:46.279]                 for (kk in seq_along(NAMES)) {
[10:21:46.279]                   name <- added[[kk]]
[10:21:46.279]                   NAME <- NAMES[[kk]]
[10:21:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.279]                     next
[10:21:46.279]                   args[[name]] <- ""
[10:21:46.279]                 }
[10:21:46.279]                 NAMES <- toupper(removed)
[10:21:46.279]                 for (kk in seq_along(NAMES)) {
[10:21:46.279]                   name <- removed[[kk]]
[10:21:46.279]                   NAME <- NAMES[[kk]]
[10:21:46.279]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.279]                     next
[10:21:46.279]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.279]                 }
[10:21:46.279]                 if (length(args) > 0) 
[10:21:46.279]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.279]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.279]             }
[10:21:46.279]             else {
[10:21:46.279]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.279]             }
[10:21:46.279]             {
[10:21:46.279]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.279]                   0L) {
[10:21:46.279]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.279]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.279]                   base::options(opts)
[10:21:46.279]                 }
[10:21:46.279]                 {
[10:21:46.279]                   {
[10:21:46.279]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.279]                     NULL
[10:21:46.279]                   }
[10:21:46.279]                   options(future.plan = NULL)
[10:21:46.279]                   if (is.na(NA_character_)) 
[10:21:46.279]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.279]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.279]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.279]                     .init = FALSE)
[10:21:46.279]                 }
[10:21:46.279]             }
[10:21:46.279]         }
[10:21:46.279]     })
[10:21:46.279]     if (TRUE) {
[10:21:46.279]         base::sink(type = "output", split = FALSE)
[10:21:46.279]         if (TRUE) {
[10:21:46.279]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.279]         }
[10:21:46.279]         else {
[10:21:46.279]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.279]         }
[10:21:46.279]         base::close(...future.stdout)
[10:21:46.279]         ...future.stdout <- NULL
[10:21:46.279]     }
[10:21:46.279]     ...future.result$conditions <- ...future.conditions
[10:21:46.279]     ...future.result$finished <- base::Sys.time()
[10:21:46.279]     ...future.result
[10:21:46.279] }
[10:21:46.282] MultisessionFuture started
[10:21:46.282] - Launch lazy future ... done
[10:21:46.282] run() for ‘MultisessionFuture’ ... done
[10:21:46.324] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.324] - Validating connection of MultisessionFuture
[10:21:46.324] - received message: FutureResult
[10:21:46.325] - Received FutureResult
[10:21:46.325] - Erased future from FutureRegistry
[10:21:46.325] result() for ClusterFuture ...
[10:21:46.325] - result already collected: FutureResult
[10:21:46.325] result() for ClusterFuture ... done
[10:21:46.325] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.325] Future #1
[10:21:46.325] result() for ClusterFuture ...
[10:21:46.325] - result already collected: FutureResult
[10:21:46.325] result() for ClusterFuture ... done
[10:21:46.325] result() for ClusterFuture ...
[10:21:46.326] - result already collected: FutureResult
[10:21:46.326] result() for ClusterFuture ... done
[10:21:46.326] A MultisessionFuture was resolved
[10:21:46.326]  length: 0 (resolved future 1)
[10:21:46.326] resolve() on list ... DONE
[10:21:46.326] - globals: [1] ‘a’
[10:21:46.326] Resolving futures part of globals (recursively) ... DONE
[10:21:46.339] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[10:21:46.340] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[10:21:46.340] - globals: [1] ‘a’
[10:21:46.340] - packages: [1] ‘future’
[10:21:46.340] getGlobalsAndPackages() ... DONE
[10:21:46.341] run() for ‘Future’ ...
[10:21:46.341] - state: ‘created’
[10:21:46.341] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.355] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.355] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.355]   - Field: ‘node’
[10:21:46.355]   - Field: ‘label’
[10:21:46.355]   - Field: ‘local’
[10:21:46.355]   - Field: ‘owner’
[10:21:46.355]   - Field: ‘envir’
[10:21:46.356]   - Field: ‘workers’
[10:21:46.356]   - Field: ‘packages’
[10:21:46.356]   - Field: ‘gc’
[10:21:46.356]   - Field: ‘conditions’
[10:21:46.356]   - Field: ‘persistent’
[10:21:46.356]   - Field: ‘expr’
[10:21:46.356]   - Field: ‘uuid’
[10:21:46.356]   - Field: ‘seed’
[10:21:46.356]   - Field: ‘version’
[10:21:46.356]   - Field: ‘result’
[10:21:46.356]   - Field: ‘asynchronous’
[10:21:46.356]   - Field: ‘calls’
[10:21:46.357]   - Field: ‘globals’
[10:21:46.357]   - Field: ‘stdout’
[10:21:46.357]   - Field: ‘earlySignal’
[10:21:46.357]   - Field: ‘lazy’
[10:21:46.357]   - Field: ‘state’
[10:21:46.357] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.357] - Launch lazy future ...
[10:21:46.357] Packages needed by the future expression (n = 1): ‘future’
[10:21:46.358] Packages needed by future strategies (n = 0): <none>
[10:21:46.358] {
[10:21:46.358]     {
[10:21:46.358]         {
[10:21:46.358]             ...future.startTime <- base::Sys.time()
[10:21:46.358]             {
[10:21:46.358]                 {
[10:21:46.358]                   {
[10:21:46.358]                     {
[10:21:46.358]                       {
[10:21:46.358]                         base::local({
[10:21:46.358]                           has_future <- base::requireNamespace("future", 
[10:21:46.358]                             quietly = TRUE)
[10:21:46.358]                           if (has_future) {
[10:21:46.358]                             ns <- base::getNamespace("future")
[10:21:46.358]                             version <- ns[[".package"]][["version"]]
[10:21:46.358]                             if (is.null(version)) 
[10:21:46.358]                               version <- utils::packageVersion("future")
[10:21:46.358]                           }
[10:21:46.358]                           else {
[10:21:46.358]                             version <- NULL
[10:21:46.358]                           }
[10:21:46.358]                           if (!has_future || version < "1.8.0") {
[10:21:46.358]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.358]                               "", base::R.version$version.string), 
[10:21:46.358]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:46.358]                                 base::R.version$platform, 8 * 
[10:21:46.358]                                   base::.Machine$sizeof.pointer), 
[10:21:46.358]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.358]                                 "release", "version")], collapse = " "), 
[10:21:46.358]                               hostname = base::Sys.info()[["nodename"]])
[10:21:46.358]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.358]                               info)
[10:21:46.358]                             info <- base::paste(info, collapse = "; ")
[10:21:46.358]                             if (!has_future) {
[10:21:46.358]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.358]                                 info)
[10:21:46.358]                             }
[10:21:46.358]                             else {
[10:21:46.358]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.358]                                 info, version)
[10:21:46.358]                             }
[10:21:46.358]                             base::stop(msg)
[10:21:46.358]                           }
[10:21:46.358]                         })
[10:21:46.358]                       }
[10:21:46.358]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.358]                       base::options(mc.cores = 1L)
[10:21:46.358]                     }
[10:21:46.358]                     base::local({
[10:21:46.358]                       for (pkg in "future") {
[10:21:46.358]                         base::loadNamespace(pkg)
[10:21:46.358]                         base::library(pkg, character.only = TRUE)
[10:21:46.358]                       }
[10:21:46.358]                     })
[10:21:46.358]                   }
[10:21:46.358]                   ...future.strategy.old <- future::plan("list")
[10:21:46.358]                   options(future.plan = NULL)
[10:21:46.358]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.358]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.358]                 }
[10:21:46.358]                 ...future.workdir <- getwd()
[10:21:46.358]             }
[10:21:46.358]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.358]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.358]         }
[10:21:46.358]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.358]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:46.358]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.358]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.358]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.358]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.358]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.358]             base::names(...future.oldOptions))
[10:21:46.358]     }
[10:21:46.358]     if (FALSE) {
[10:21:46.358]     }
[10:21:46.358]     else {
[10:21:46.358]         if (TRUE) {
[10:21:46.358]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.358]                 open = "w")
[10:21:46.358]         }
[10:21:46.358]         else {
[10:21:46.358]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.358]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.358]         }
[10:21:46.358]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.358]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.358]             base::sink(type = "output", split = FALSE)
[10:21:46.358]             base::close(...future.stdout)
[10:21:46.358]         }, add = TRUE)
[10:21:46.358]     }
[10:21:46.358]     ...future.frame <- base::sys.nframe()
[10:21:46.358]     ...future.conditions <- base::list()
[10:21:46.358]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.358]     if (FALSE) {
[10:21:46.358]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.358]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.358]     }
[10:21:46.358]     ...future.result <- base::tryCatch({
[10:21:46.358]         base::withCallingHandlers({
[10:21:46.358]             ...future.value <- base::withVisible(base::local({
[10:21:46.358]                 ...future.makeSendCondition <- base::local({
[10:21:46.358]                   sendCondition <- NULL
[10:21:46.358]                   function(frame = 1L) {
[10:21:46.358]                     if (is.function(sendCondition)) 
[10:21:46.358]                       return(sendCondition)
[10:21:46.358]                     ns <- getNamespace("parallel")
[10:21:46.358]                     if (exists("sendData", mode = "function", 
[10:21:46.358]                       envir = ns)) {
[10:21:46.358]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.358]                         envir = ns)
[10:21:46.358]                       envir <- sys.frame(frame)
[10:21:46.358]                       master <- NULL
[10:21:46.358]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.358]                         !identical(envir, emptyenv())) {
[10:21:46.358]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.358]                           inherits = FALSE)) {
[10:21:46.358]                           master <- get("master", mode = "list", 
[10:21:46.358]                             envir = envir, inherits = FALSE)
[10:21:46.358]                           if (inherits(master, c("SOCKnode", 
[10:21:46.358]                             "SOCK0node"))) {
[10:21:46.358]                             sendCondition <<- function(cond) {
[10:21:46.358]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.358]                                 success = TRUE)
[10:21:46.358]                               parallel_sendData(master, data)
[10:21:46.358]                             }
[10:21:46.358]                             return(sendCondition)
[10:21:46.358]                           }
[10:21:46.358]                         }
[10:21:46.358]                         frame <- frame + 1L
[10:21:46.358]                         envir <- sys.frame(frame)
[10:21:46.358]                       }
[10:21:46.358]                     }
[10:21:46.358]                     sendCondition <<- function(cond) NULL
[10:21:46.358]                   }
[10:21:46.358]                 })
[10:21:46.358]                 withCallingHandlers({
[10:21:46.358]                   value(a) + 1
[10:21:46.358]                 }, immediateCondition = function(cond) {
[10:21:46.358]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.358]                   sendCondition(cond)
[10:21:46.358]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.358]                   {
[10:21:46.358]                     inherits <- base::inherits
[10:21:46.358]                     invokeRestart <- base::invokeRestart
[10:21:46.358]                     is.null <- base::is.null
[10:21:46.358]                     muffled <- FALSE
[10:21:46.358]                     if (inherits(cond, "message")) {
[10:21:46.358]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.358]                       if (muffled) 
[10:21:46.358]                         invokeRestart("muffleMessage")
[10:21:46.358]                     }
[10:21:46.358]                     else if (inherits(cond, "warning")) {
[10:21:46.358]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.358]                       if (muffled) 
[10:21:46.358]                         invokeRestart("muffleWarning")
[10:21:46.358]                     }
[10:21:46.358]                     else if (inherits(cond, "condition")) {
[10:21:46.358]                       if (!is.null(pattern)) {
[10:21:46.358]                         computeRestarts <- base::computeRestarts
[10:21:46.358]                         grepl <- base::grepl
[10:21:46.358]                         restarts <- computeRestarts(cond)
[10:21:46.358]                         for (restart in restarts) {
[10:21:46.358]                           name <- restart$name
[10:21:46.358]                           if (is.null(name)) 
[10:21:46.358]                             next
[10:21:46.358]                           if (!grepl(pattern, name)) 
[10:21:46.358]                             next
[10:21:46.358]                           invokeRestart(restart)
[10:21:46.358]                           muffled <- TRUE
[10:21:46.358]                           break
[10:21:46.358]                         }
[10:21:46.358]                       }
[10:21:46.358]                     }
[10:21:46.358]                     invisible(muffled)
[10:21:46.358]                   }
[10:21:46.358]                   muffleCondition(cond)
[10:21:46.358]                 })
[10:21:46.358]             }))
[10:21:46.358]             future::FutureResult(value = ...future.value$value, 
[10:21:46.358]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.358]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.358]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.358]                     ...future.globalenv.names))
[10:21:46.358]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.358]         }, condition = base::local({
[10:21:46.358]             c <- base::c
[10:21:46.358]             inherits <- base::inherits
[10:21:46.358]             invokeRestart <- base::invokeRestart
[10:21:46.358]             length <- base::length
[10:21:46.358]             list <- base::list
[10:21:46.358]             seq.int <- base::seq.int
[10:21:46.358]             signalCondition <- base::signalCondition
[10:21:46.358]             sys.calls <- base::sys.calls
[10:21:46.358]             `[[` <- base::`[[`
[10:21:46.358]             `+` <- base::`+`
[10:21:46.358]             `<<-` <- base::`<<-`
[10:21:46.358]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.358]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.358]                   3L)]
[10:21:46.358]             }
[10:21:46.358]             function(cond) {
[10:21:46.358]                 is_error <- inherits(cond, "error")
[10:21:46.358]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.358]                   NULL)
[10:21:46.358]                 if (is_error) {
[10:21:46.358]                   sessionInformation <- function() {
[10:21:46.358]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.358]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.358]                       search = base::search(), system = base::Sys.info())
[10:21:46.358]                   }
[10:21:46.358]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.358]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.358]                     cond$call), session = sessionInformation(), 
[10:21:46.358]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.358]                   signalCondition(cond)
[10:21:46.358]                 }
[10:21:46.358]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.358]                 "immediateCondition"))) {
[10:21:46.358]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.358]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.358]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.358]                   if (TRUE && !signal) {
[10:21:46.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.358]                     {
[10:21:46.358]                       inherits <- base::inherits
[10:21:46.358]                       invokeRestart <- base::invokeRestart
[10:21:46.358]                       is.null <- base::is.null
[10:21:46.358]                       muffled <- FALSE
[10:21:46.358]                       if (inherits(cond, "message")) {
[10:21:46.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.358]                         if (muffled) 
[10:21:46.358]                           invokeRestart("muffleMessage")
[10:21:46.358]                       }
[10:21:46.358]                       else if (inherits(cond, "warning")) {
[10:21:46.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.358]                         if (muffled) 
[10:21:46.358]                           invokeRestart("muffleWarning")
[10:21:46.358]                       }
[10:21:46.358]                       else if (inherits(cond, "condition")) {
[10:21:46.358]                         if (!is.null(pattern)) {
[10:21:46.358]                           computeRestarts <- base::computeRestarts
[10:21:46.358]                           grepl <- base::grepl
[10:21:46.358]                           restarts <- computeRestarts(cond)
[10:21:46.358]                           for (restart in restarts) {
[10:21:46.358]                             name <- restart$name
[10:21:46.358]                             if (is.null(name)) 
[10:21:46.358]                               next
[10:21:46.358]                             if (!grepl(pattern, name)) 
[10:21:46.358]                               next
[10:21:46.358]                             invokeRestart(restart)
[10:21:46.358]                             muffled <- TRUE
[10:21:46.358]                             break
[10:21:46.358]                           }
[10:21:46.358]                         }
[10:21:46.358]                       }
[10:21:46.358]                       invisible(muffled)
[10:21:46.358]                     }
[10:21:46.358]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.358]                   }
[10:21:46.358]                 }
[10:21:46.358]                 else {
[10:21:46.358]                   if (TRUE) {
[10:21:46.358]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.358]                     {
[10:21:46.358]                       inherits <- base::inherits
[10:21:46.358]                       invokeRestart <- base::invokeRestart
[10:21:46.358]                       is.null <- base::is.null
[10:21:46.358]                       muffled <- FALSE
[10:21:46.358]                       if (inherits(cond, "message")) {
[10:21:46.358]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.358]                         if (muffled) 
[10:21:46.358]                           invokeRestart("muffleMessage")
[10:21:46.358]                       }
[10:21:46.358]                       else if (inherits(cond, "warning")) {
[10:21:46.358]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.358]                         if (muffled) 
[10:21:46.358]                           invokeRestart("muffleWarning")
[10:21:46.358]                       }
[10:21:46.358]                       else if (inherits(cond, "condition")) {
[10:21:46.358]                         if (!is.null(pattern)) {
[10:21:46.358]                           computeRestarts <- base::computeRestarts
[10:21:46.358]                           grepl <- base::grepl
[10:21:46.358]                           restarts <- computeRestarts(cond)
[10:21:46.358]                           for (restart in restarts) {
[10:21:46.358]                             name <- restart$name
[10:21:46.358]                             if (is.null(name)) 
[10:21:46.358]                               next
[10:21:46.358]                             if (!grepl(pattern, name)) 
[10:21:46.358]                               next
[10:21:46.358]                             invokeRestart(restart)
[10:21:46.358]                             muffled <- TRUE
[10:21:46.358]                             break
[10:21:46.358]                           }
[10:21:46.358]                         }
[10:21:46.358]                       }
[10:21:46.358]                       invisible(muffled)
[10:21:46.358]                     }
[10:21:46.358]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.358]                   }
[10:21:46.358]                 }
[10:21:46.358]             }
[10:21:46.358]         }))
[10:21:46.358]     }, error = function(ex) {
[10:21:46.358]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.358]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.358]                 ...future.rng), started = ...future.startTime, 
[10:21:46.358]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.358]             version = "1.8"), class = "FutureResult")
[10:21:46.358]     }, finally = {
[10:21:46.358]         if (!identical(...future.workdir, getwd())) 
[10:21:46.358]             setwd(...future.workdir)
[10:21:46.358]         {
[10:21:46.358]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.358]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.358]             }
[10:21:46.358]             base::options(...future.oldOptions)
[10:21:46.358]             if (.Platform$OS.type == "windows") {
[10:21:46.358]                 old_names <- names(...future.oldEnvVars)
[10:21:46.358]                 envs <- base::Sys.getenv()
[10:21:46.358]                 names <- names(envs)
[10:21:46.358]                 common <- intersect(names, old_names)
[10:21:46.358]                 added <- setdiff(names, old_names)
[10:21:46.358]                 removed <- setdiff(old_names, names)
[10:21:46.358]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.358]                   envs[common]]
[10:21:46.358]                 NAMES <- toupper(changed)
[10:21:46.358]                 args <- list()
[10:21:46.358]                 for (kk in seq_along(NAMES)) {
[10:21:46.358]                   name <- changed[[kk]]
[10:21:46.358]                   NAME <- NAMES[[kk]]
[10:21:46.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.358]                     next
[10:21:46.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.358]                 }
[10:21:46.358]                 NAMES <- toupper(added)
[10:21:46.358]                 for (kk in seq_along(NAMES)) {
[10:21:46.358]                   name <- added[[kk]]
[10:21:46.358]                   NAME <- NAMES[[kk]]
[10:21:46.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.358]                     next
[10:21:46.358]                   args[[name]] <- ""
[10:21:46.358]                 }
[10:21:46.358]                 NAMES <- toupper(removed)
[10:21:46.358]                 for (kk in seq_along(NAMES)) {
[10:21:46.358]                   name <- removed[[kk]]
[10:21:46.358]                   NAME <- NAMES[[kk]]
[10:21:46.358]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.358]                     next
[10:21:46.358]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.358]                 }
[10:21:46.358]                 if (length(args) > 0) 
[10:21:46.358]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.358]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.358]             }
[10:21:46.358]             else {
[10:21:46.358]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.358]             }
[10:21:46.358]             {
[10:21:46.358]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.358]                   0L) {
[10:21:46.358]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.358]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.358]                   base::options(opts)
[10:21:46.358]                 }
[10:21:46.358]                 {
[10:21:46.358]                   {
[10:21:46.358]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.358]                     NULL
[10:21:46.358]                   }
[10:21:46.358]                   options(future.plan = NULL)
[10:21:46.358]                   if (is.na(NA_character_)) 
[10:21:46.358]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.358]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.358]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.358]                     .init = FALSE)
[10:21:46.358]                 }
[10:21:46.358]             }
[10:21:46.358]         }
[10:21:46.358]     })
[10:21:46.358]     if (TRUE) {
[10:21:46.358]         base::sink(type = "output", split = FALSE)
[10:21:46.358]         if (TRUE) {
[10:21:46.358]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.358]         }
[10:21:46.358]         else {
[10:21:46.358]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.358]         }
[10:21:46.358]         base::close(...future.stdout)
[10:21:46.358]         ...future.stdout <- NULL
[10:21:46.358]     }
[10:21:46.358]     ...future.result$conditions <- ...future.conditions
[10:21:46.358]     ...future.result$finished <- base::Sys.time()
[10:21:46.358]     ...future.result
[10:21:46.358] }
[10:21:46.372] Exporting 1 global objects (313.46 KiB) to cluster node #2 ...
[10:21:46.382] Exporting ‘a’ (313.25 KiB) to cluster node #2 ...
[10:21:46.435] Exporting ‘a’ (313.25 KiB) to cluster node #2 ... DONE
[10:21:46.435] Exporting 1 global objects (313.46 KiB) to cluster node #2 ... DONE
[10:21:46.436] MultisessionFuture started
[10:21:46.436] - Launch lazy future ... done
[10:21:46.436] run() for ‘MultisessionFuture’ ... done
[10:21:46.436] result() for ClusterFuture ...
[10:21:46.436] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.436] - Validating connection of MultisessionFuture
[10:21:46.479] - received message: FutureResult
[10:21:46.479] - Received FutureResult
[10:21:46.479] - Erased future from FutureRegistry
[10:21:46.479] result() for ClusterFuture ...
[10:21:46.479] - result already collected: FutureResult
[10:21:46.479] result() for ClusterFuture ... done
[10:21:46.479] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.480] result() for ClusterFuture ... done
[10:21:46.480] result() for ClusterFuture ...
[10:21:46.480] - result already collected: FutureResult
[10:21:46.480] result() for ClusterFuture ... done
value(b) = 2
[10:21:46.480] result() for ClusterFuture ...
[10:21:46.480] - result already collected: FutureResult
[10:21:46.480] result() for ClusterFuture ... done
[10:21:46.480] result() for ClusterFuture ...
[10:21:46.480] - result already collected: FutureResult
[10:21:46.480] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.481] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.481] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:46.482] 
[10:21:46.482] Searching for globals ... DONE
[10:21:46.482] - globals: [0] <none>
[10:21:46.482] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.482] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.482] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:46.483] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:46.483] Searching for globals ... DONE
[10:21:46.483] Resolving globals: TRUE
[10:21:46.484] Resolving any globals that are futures ...
[10:21:46.484] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:46.484] Resolving any globals that are futures ... DONE
[10:21:46.484] Resolving futures part of globals (recursively) ...
[10:21:46.484] resolve() on list ...
[10:21:46.484]  recursive: 99
[10:21:46.484]  length: 1
[10:21:46.485]  elements: ‘a’
[10:21:46.485] run() for ‘Future’ ...
[10:21:46.485] - state: ‘created’
[10:21:46.485] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.499] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.499] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.499]   - Field: ‘node’
[10:21:46.499]   - Field: ‘label’
[10:21:46.499]   - Field: ‘local’
[10:21:46.500]   - Field: ‘owner’
[10:21:46.500]   - Field: ‘envir’
[10:21:46.500]   - Field: ‘workers’
[10:21:46.500]   - Field: ‘packages’
[10:21:46.500]   - Field: ‘gc’
[10:21:46.500]   - Field: ‘conditions’
[10:21:46.500]   - Field: ‘persistent’
[10:21:46.500]   - Field: ‘expr’
[10:21:46.500]   - Field: ‘uuid’
[10:21:46.500]   - Field: ‘seed’
[10:21:46.500]   - Field: ‘version’
[10:21:46.501]   - Field: ‘result’
[10:21:46.501]   - Field: ‘asynchronous’
[10:21:46.501]   - Field: ‘calls’
[10:21:46.501]   - Field: ‘globals’
[10:21:46.501]   - Field: ‘stdout’
[10:21:46.501]   - Field: ‘earlySignal’
[10:21:46.501]   - Field: ‘lazy’
[10:21:46.501]   - Field: ‘state’
[10:21:46.501] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.501] - Launch lazy future ...
[10:21:46.502] Packages needed by the future expression (n = 0): <none>
[10:21:46.502] Packages needed by future strategies (n = 0): <none>
[10:21:46.502] {
[10:21:46.502]     {
[10:21:46.502]         {
[10:21:46.502]             ...future.startTime <- base::Sys.time()
[10:21:46.502]             {
[10:21:46.502]                 {
[10:21:46.502]                   {
[10:21:46.502]                     {
[10:21:46.502]                       base::local({
[10:21:46.502]                         has_future <- base::requireNamespace("future", 
[10:21:46.502]                           quietly = TRUE)
[10:21:46.502]                         if (has_future) {
[10:21:46.502]                           ns <- base::getNamespace("future")
[10:21:46.502]                           version <- ns[[".package"]][["version"]]
[10:21:46.502]                           if (is.null(version)) 
[10:21:46.502]                             version <- utils::packageVersion("future")
[10:21:46.502]                         }
[10:21:46.502]                         else {
[10:21:46.502]                           version <- NULL
[10:21:46.502]                         }
[10:21:46.502]                         if (!has_future || version < "1.8.0") {
[10:21:46.502]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.502]                             "", base::R.version$version.string), 
[10:21:46.502]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.502]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.502]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.502]                               "release", "version")], collapse = " "), 
[10:21:46.502]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.502]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.502]                             info)
[10:21:46.502]                           info <- base::paste(info, collapse = "; ")
[10:21:46.502]                           if (!has_future) {
[10:21:46.502]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.502]                               info)
[10:21:46.502]                           }
[10:21:46.502]                           else {
[10:21:46.502]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.502]                               info, version)
[10:21:46.502]                           }
[10:21:46.502]                           base::stop(msg)
[10:21:46.502]                         }
[10:21:46.502]                       })
[10:21:46.502]                     }
[10:21:46.502]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.502]                     base::options(mc.cores = 1L)
[10:21:46.502]                   }
[10:21:46.502]                   ...future.strategy.old <- future::plan("list")
[10:21:46.502]                   options(future.plan = NULL)
[10:21:46.502]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.502]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.502]                 }
[10:21:46.502]                 ...future.workdir <- getwd()
[10:21:46.502]             }
[10:21:46.502]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.502]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.502]         }
[10:21:46.502]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.502]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:46.502]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.502]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.502]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.502]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.502]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.502]             base::names(...future.oldOptions))
[10:21:46.502]     }
[10:21:46.502]     if (FALSE) {
[10:21:46.502]     }
[10:21:46.502]     else {
[10:21:46.502]         if (TRUE) {
[10:21:46.502]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.502]                 open = "w")
[10:21:46.502]         }
[10:21:46.502]         else {
[10:21:46.502]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.502]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.502]         }
[10:21:46.502]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.502]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.502]             base::sink(type = "output", split = FALSE)
[10:21:46.502]             base::close(...future.stdout)
[10:21:46.502]         }, add = TRUE)
[10:21:46.502]     }
[10:21:46.502]     ...future.frame <- base::sys.nframe()
[10:21:46.502]     ...future.conditions <- base::list()
[10:21:46.502]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.502]     if (FALSE) {
[10:21:46.502]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.502]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.502]     }
[10:21:46.502]     ...future.result <- base::tryCatch({
[10:21:46.502]         base::withCallingHandlers({
[10:21:46.502]             ...future.value <- base::withVisible(base::local({
[10:21:46.502]                 ...future.makeSendCondition <- base::local({
[10:21:46.502]                   sendCondition <- NULL
[10:21:46.502]                   function(frame = 1L) {
[10:21:46.502]                     if (is.function(sendCondition)) 
[10:21:46.502]                       return(sendCondition)
[10:21:46.502]                     ns <- getNamespace("parallel")
[10:21:46.502]                     if (exists("sendData", mode = "function", 
[10:21:46.502]                       envir = ns)) {
[10:21:46.502]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.502]                         envir = ns)
[10:21:46.502]                       envir <- sys.frame(frame)
[10:21:46.502]                       master <- NULL
[10:21:46.502]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.502]                         !identical(envir, emptyenv())) {
[10:21:46.502]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.502]                           inherits = FALSE)) {
[10:21:46.502]                           master <- get("master", mode = "list", 
[10:21:46.502]                             envir = envir, inherits = FALSE)
[10:21:46.502]                           if (inherits(master, c("SOCKnode", 
[10:21:46.502]                             "SOCK0node"))) {
[10:21:46.502]                             sendCondition <<- function(cond) {
[10:21:46.502]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.502]                                 success = TRUE)
[10:21:46.502]                               parallel_sendData(master, data)
[10:21:46.502]                             }
[10:21:46.502]                             return(sendCondition)
[10:21:46.502]                           }
[10:21:46.502]                         }
[10:21:46.502]                         frame <- frame + 1L
[10:21:46.502]                         envir <- sys.frame(frame)
[10:21:46.502]                       }
[10:21:46.502]                     }
[10:21:46.502]                     sendCondition <<- function(cond) NULL
[10:21:46.502]                   }
[10:21:46.502]                 })
[10:21:46.502]                 withCallingHandlers({
[10:21:46.502]                   1
[10:21:46.502]                 }, immediateCondition = function(cond) {
[10:21:46.502]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.502]                   sendCondition(cond)
[10:21:46.502]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.502]                   {
[10:21:46.502]                     inherits <- base::inherits
[10:21:46.502]                     invokeRestart <- base::invokeRestart
[10:21:46.502]                     is.null <- base::is.null
[10:21:46.502]                     muffled <- FALSE
[10:21:46.502]                     if (inherits(cond, "message")) {
[10:21:46.502]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.502]                       if (muffled) 
[10:21:46.502]                         invokeRestart("muffleMessage")
[10:21:46.502]                     }
[10:21:46.502]                     else if (inherits(cond, "warning")) {
[10:21:46.502]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.502]                       if (muffled) 
[10:21:46.502]                         invokeRestart("muffleWarning")
[10:21:46.502]                     }
[10:21:46.502]                     else if (inherits(cond, "condition")) {
[10:21:46.502]                       if (!is.null(pattern)) {
[10:21:46.502]                         computeRestarts <- base::computeRestarts
[10:21:46.502]                         grepl <- base::grepl
[10:21:46.502]                         restarts <- computeRestarts(cond)
[10:21:46.502]                         for (restart in restarts) {
[10:21:46.502]                           name <- restart$name
[10:21:46.502]                           if (is.null(name)) 
[10:21:46.502]                             next
[10:21:46.502]                           if (!grepl(pattern, name)) 
[10:21:46.502]                             next
[10:21:46.502]                           invokeRestart(restart)
[10:21:46.502]                           muffled <- TRUE
[10:21:46.502]                           break
[10:21:46.502]                         }
[10:21:46.502]                       }
[10:21:46.502]                     }
[10:21:46.502]                     invisible(muffled)
[10:21:46.502]                   }
[10:21:46.502]                   muffleCondition(cond)
[10:21:46.502]                 })
[10:21:46.502]             }))
[10:21:46.502]             future::FutureResult(value = ...future.value$value, 
[10:21:46.502]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.502]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.502]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.502]                     ...future.globalenv.names))
[10:21:46.502]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.502]         }, condition = base::local({
[10:21:46.502]             c <- base::c
[10:21:46.502]             inherits <- base::inherits
[10:21:46.502]             invokeRestart <- base::invokeRestart
[10:21:46.502]             length <- base::length
[10:21:46.502]             list <- base::list
[10:21:46.502]             seq.int <- base::seq.int
[10:21:46.502]             signalCondition <- base::signalCondition
[10:21:46.502]             sys.calls <- base::sys.calls
[10:21:46.502]             `[[` <- base::`[[`
[10:21:46.502]             `+` <- base::`+`
[10:21:46.502]             `<<-` <- base::`<<-`
[10:21:46.502]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.502]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.502]                   3L)]
[10:21:46.502]             }
[10:21:46.502]             function(cond) {
[10:21:46.502]                 is_error <- inherits(cond, "error")
[10:21:46.502]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.502]                   NULL)
[10:21:46.502]                 if (is_error) {
[10:21:46.502]                   sessionInformation <- function() {
[10:21:46.502]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.502]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.502]                       search = base::search(), system = base::Sys.info())
[10:21:46.502]                   }
[10:21:46.502]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.502]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.502]                     cond$call), session = sessionInformation(), 
[10:21:46.502]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.502]                   signalCondition(cond)
[10:21:46.502]                 }
[10:21:46.502]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.502]                 "immediateCondition"))) {
[10:21:46.502]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.502]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.502]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.502]                   if (TRUE && !signal) {
[10:21:46.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.502]                     {
[10:21:46.502]                       inherits <- base::inherits
[10:21:46.502]                       invokeRestart <- base::invokeRestart
[10:21:46.502]                       is.null <- base::is.null
[10:21:46.502]                       muffled <- FALSE
[10:21:46.502]                       if (inherits(cond, "message")) {
[10:21:46.502]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.502]                         if (muffled) 
[10:21:46.502]                           invokeRestart("muffleMessage")
[10:21:46.502]                       }
[10:21:46.502]                       else if (inherits(cond, "warning")) {
[10:21:46.502]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.502]                         if (muffled) 
[10:21:46.502]                           invokeRestart("muffleWarning")
[10:21:46.502]                       }
[10:21:46.502]                       else if (inherits(cond, "condition")) {
[10:21:46.502]                         if (!is.null(pattern)) {
[10:21:46.502]                           computeRestarts <- base::computeRestarts
[10:21:46.502]                           grepl <- base::grepl
[10:21:46.502]                           restarts <- computeRestarts(cond)
[10:21:46.502]                           for (restart in restarts) {
[10:21:46.502]                             name <- restart$name
[10:21:46.502]                             if (is.null(name)) 
[10:21:46.502]                               next
[10:21:46.502]                             if (!grepl(pattern, name)) 
[10:21:46.502]                               next
[10:21:46.502]                             invokeRestart(restart)
[10:21:46.502]                             muffled <- TRUE
[10:21:46.502]                             break
[10:21:46.502]                           }
[10:21:46.502]                         }
[10:21:46.502]                       }
[10:21:46.502]                       invisible(muffled)
[10:21:46.502]                     }
[10:21:46.502]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.502]                   }
[10:21:46.502]                 }
[10:21:46.502]                 else {
[10:21:46.502]                   if (TRUE) {
[10:21:46.502]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.502]                     {
[10:21:46.502]                       inherits <- base::inherits
[10:21:46.502]                       invokeRestart <- base::invokeRestart
[10:21:46.502]                       is.null <- base::is.null
[10:21:46.502]                       muffled <- FALSE
[10:21:46.502]                       if (inherits(cond, "message")) {
[10:21:46.502]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.502]                         if (muffled) 
[10:21:46.502]                           invokeRestart("muffleMessage")
[10:21:46.502]                       }
[10:21:46.502]                       else if (inherits(cond, "warning")) {
[10:21:46.502]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.502]                         if (muffled) 
[10:21:46.502]                           invokeRestart("muffleWarning")
[10:21:46.502]                       }
[10:21:46.502]                       else if (inherits(cond, "condition")) {
[10:21:46.502]                         if (!is.null(pattern)) {
[10:21:46.502]                           computeRestarts <- base::computeRestarts
[10:21:46.502]                           grepl <- base::grepl
[10:21:46.502]                           restarts <- computeRestarts(cond)
[10:21:46.502]                           for (restart in restarts) {
[10:21:46.502]                             name <- restart$name
[10:21:46.502]                             if (is.null(name)) 
[10:21:46.502]                               next
[10:21:46.502]                             if (!grepl(pattern, name)) 
[10:21:46.502]                               next
[10:21:46.502]                             invokeRestart(restart)
[10:21:46.502]                             muffled <- TRUE
[10:21:46.502]                             break
[10:21:46.502]                           }
[10:21:46.502]                         }
[10:21:46.502]                       }
[10:21:46.502]                       invisible(muffled)
[10:21:46.502]                     }
[10:21:46.502]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.502]                   }
[10:21:46.502]                 }
[10:21:46.502]             }
[10:21:46.502]         }))
[10:21:46.502]     }, error = function(ex) {
[10:21:46.502]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.502]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.502]                 ...future.rng), started = ...future.startTime, 
[10:21:46.502]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.502]             version = "1.8"), class = "FutureResult")
[10:21:46.502]     }, finally = {
[10:21:46.502]         if (!identical(...future.workdir, getwd())) 
[10:21:46.502]             setwd(...future.workdir)
[10:21:46.502]         {
[10:21:46.502]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.502]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.502]             }
[10:21:46.502]             base::options(...future.oldOptions)
[10:21:46.502]             if (.Platform$OS.type == "windows") {
[10:21:46.502]                 old_names <- names(...future.oldEnvVars)
[10:21:46.502]                 envs <- base::Sys.getenv()
[10:21:46.502]                 names <- names(envs)
[10:21:46.502]                 common <- intersect(names, old_names)
[10:21:46.502]                 added <- setdiff(names, old_names)
[10:21:46.502]                 removed <- setdiff(old_names, names)
[10:21:46.502]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.502]                   envs[common]]
[10:21:46.502]                 NAMES <- toupper(changed)
[10:21:46.502]                 args <- list()
[10:21:46.502]                 for (kk in seq_along(NAMES)) {
[10:21:46.502]                   name <- changed[[kk]]
[10:21:46.502]                   NAME <- NAMES[[kk]]
[10:21:46.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.502]                     next
[10:21:46.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.502]                 }
[10:21:46.502]                 NAMES <- toupper(added)
[10:21:46.502]                 for (kk in seq_along(NAMES)) {
[10:21:46.502]                   name <- added[[kk]]
[10:21:46.502]                   NAME <- NAMES[[kk]]
[10:21:46.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.502]                     next
[10:21:46.502]                   args[[name]] <- ""
[10:21:46.502]                 }
[10:21:46.502]                 NAMES <- toupper(removed)
[10:21:46.502]                 for (kk in seq_along(NAMES)) {
[10:21:46.502]                   name <- removed[[kk]]
[10:21:46.502]                   NAME <- NAMES[[kk]]
[10:21:46.502]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.502]                     next
[10:21:46.502]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.502]                 }
[10:21:46.502]                 if (length(args) > 0) 
[10:21:46.502]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.502]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.502]             }
[10:21:46.502]             else {
[10:21:46.502]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.502]             }
[10:21:46.502]             {
[10:21:46.502]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.502]                   0L) {
[10:21:46.502]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.502]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.502]                   base::options(opts)
[10:21:46.502]                 }
[10:21:46.502]                 {
[10:21:46.502]                   {
[10:21:46.502]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.502]                     NULL
[10:21:46.502]                   }
[10:21:46.502]                   options(future.plan = NULL)
[10:21:46.502]                   if (is.na(NA_character_)) 
[10:21:46.502]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.502]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.502]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.502]                     .init = FALSE)
[10:21:46.502]                 }
[10:21:46.502]             }
[10:21:46.502]         }
[10:21:46.502]     })
[10:21:46.502]     if (TRUE) {
[10:21:46.502]         base::sink(type = "output", split = FALSE)
[10:21:46.502]         if (TRUE) {
[10:21:46.502]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.502]         }
[10:21:46.502]         else {
[10:21:46.502]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.502]         }
[10:21:46.502]         base::close(...future.stdout)
[10:21:46.502]         ...future.stdout <- NULL
[10:21:46.502]     }
[10:21:46.502]     ...future.result$conditions <- ...future.conditions
[10:21:46.502]     ...future.result$finished <- base::Sys.time()
[10:21:46.502]     ...future.result
[10:21:46.502] }
[10:21:46.505] MultisessionFuture started
[10:21:46.505] - Launch lazy future ... done
[10:21:46.506] run() for ‘MultisessionFuture’ ... done
[10:21:46.548] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.548] - Validating connection of MultisessionFuture
[10:21:46.548] - received message: FutureResult
[10:21:46.549] - Received FutureResult
[10:21:46.549] - Erased future from FutureRegistry
[10:21:46.549] result() for ClusterFuture ...
[10:21:46.549] - result already collected: FutureResult
[10:21:46.549] result() for ClusterFuture ... done
[10:21:46.549] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.549] Future #1
[10:21:46.549] result() for ClusterFuture ...
[10:21:46.549] - result already collected: FutureResult
[10:21:46.549] result() for ClusterFuture ... done
[10:21:46.549] result() for ClusterFuture ...
[10:21:46.550] - result already collected: FutureResult
[10:21:46.550] result() for ClusterFuture ... done
[10:21:46.550] A MultisessionFuture was resolved
[10:21:46.550]  length: 0 (resolved future 1)
[10:21:46.550] resolve() on list ... DONE
[10:21:46.550] - globals: [1] ‘a’
[10:21:46.550] Resolving futures part of globals (recursively) ... DONE
[10:21:46.561] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[10:21:46.562] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[10:21:46.562] - globals: [1] ‘a’
[10:21:46.562] - packages: [1] ‘future’
[10:21:46.562] getGlobalsAndPackages() ... DONE
[10:21:46.562] run() for ‘Future’ ...
[10:21:46.563] - state: ‘created’
[10:21:46.563] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.577] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.577] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.577]   - Field: ‘node’
[10:21:46.577]   - Field: ‘label’
[10:21:46.577]   - Field: ‘local’
[10:21:46.577]   - Field: ‘owner’
[10:21:46.577]   - Field: ‘envir’
[10:21:46.577]   - Field: ‘workers’
[10:21:46.578]   - Field: ‘packages’
[10:21:46.578]   - Field: ‘gc’
[10:21:46.578]   - Field: ‘conditions’
[10:21:46.578]   - Field: ‘persistent’
[10:21:46.578]   - Field: ‘expr’
[10:21:46.578]   - Field: ‘uuid’
[10:21:46.578]   - Field: ‘seed’
[10:21:46.578]   - Field: ‘version’
[10:21:46.578]   - Field: ‘result’
[10:21:46.578]   - Field: ‘asynchronous’
[10:21:46.578]   - Field: ‘calls’
[10:21:46.579]   - Field: ‘globals’
[10:21:46.579]   - Field: ‘stdout’
[10:21:46.579]   - Field: ‘earlySignal’
[10:21:46.579]   - Field: ‘lazy’
[10:21:46.579]   - Field: ‘state’
[10:21:46.579] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.579] - Launch lazy future ...
[10:21:46.579] Packages needed by the future expression (n = 1): ‘future’
[10:21:46.579] Packages needed by future strategies (n = 0): <none>
[10:21:46.580] {
[10:21:46.580]     {
[10:21:46.580]         {
[10:21:46.580]             ...future.startTime <- base::Sys.time()
[10:21:46.580]             {
[10:21:46.580]                 {
[10:21:46.580]                   {
[10:21:46.580]                     {
[10:21:46.580]                       {
[10:21:46.580]                         base::local({
[10:21:46.580]                           has_future <- base::requireNamespace("future", 
[10:21:46.580]                             quietly = TRUE)
[10:21:46.580]                           if (has_future) {
[10:21:46.580]                             ns <- base::getNamespace("future")
[10:21:46.580]                             version <- ns[[".package"]][["version"]]
[10:21:46.580]                             if (is.null(version)) 
[10:21:46.580]                               version <- utils::packageVersion("future")
[10:21:46.580]                           }
[10:21:46.580]                           else {
[10:21:46.580]                             version <- NULL
[10:21:46.580]                           }
[10:21:46.580]                           if (!has_future || version < "1.8.0") {
[10:21:46.580]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.580]                               "", base::R.version$version.string), 
[10:21:46.580]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:46.580]                                 base::R.version$platform, 8 * 
[10:21:46.580]                                   base::.Machine$sizeof.pointer), 
[10:21:46.580]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.580]                                 "release", "version")], collapse = " "), 
[10:21:46.580]                               hostname = base::Sys.info()[["nodename"]])
[10:21:46.580]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.580]                               info)
[10:21:46.580]                             info <- base::paste(info, collapse = "; ")
[10:21:46.580]                             if (!has_future) {
[10:21:46.580]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.580]                                 info)
[10:21:46.580]                             }
[10:21:46.580]                             else {
[10:21:46.580]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.580]                                 info, version)
[10:21:46.580]                             }
[10:21:46.580]                             base::stop(msg)
[10:21:46.580]                           }
[10:21:46.580]                         })
[10:21:46.580]                       }
[10:21:46.580]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.580]                       base::options(mc.cores = 1L)
[10:21:46.580]                     }
[10:21:46.580]                     base::local({
[10:21:46.580]                       for (pkg in "future") {
[10:21:46.580]                         base::loadNamespace(pkg)
[10:21:46.580]                         base::library(pkg, character.only = TRUE)
[10:21:46.580]                       }
[10:21:46.580]                     })
[10:21:46.580]                   }
[10:21:46.580]                   ...future.strategy.old <- future::plan("list")
[10:21:46.580]                   options(future.plan = NULL)
[10:21:46.580]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.580]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.580]                 }
[10:21:46.580]                 ...future.workdir <- getwd()
[10:21:46.580]             }
[10:21:46.580]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.580]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.580]         }
[10:21:46.580]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.580]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:46.580]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.580]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.580]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.580]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.580]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.580]             base::names(...future.oldOptions))
[10:21:46.580]     }
[10:21:46.580]     if (FALSE) {
[10:21:46.580]     }
[10:21:46.580]     else {
[10:21:46.580]         if (TRUE) {
[10:21:46.580]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.580]                 open = "w")
[10:21:46.580]         }
[10:21:46.580]         else {
[10:21:46.580]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.580]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.580]         }
[10:21:46.580]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.580]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.580]             base::sink(type = "output", split = FALSE)
[10:21:46.580]             base::close(...future.stdout)
[10:21:46.580]         }, add = TRUE)
[10:21:46.580]     }
[10:21:46.580]     ...future.frame <- base::sys.nframe()
[10:21:46.580]     ...future.conditions <- base::list()
[10:21:46.580]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.580]     if (FALSE) {
[10:21:46.580]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.580]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.580]     }
[10:21:46.580]     ...future.result <- base::tryCatch({
[10:21:46.580]         base::withCallingHandlers({
[10:21:46.580]             ...future.value <- base::withVisible(base::local({
[10:21:46.580]                 ...future.makeSendCondition <- base::local({
[10:21:46.580]                   sendCondition <- NULL
[10:21:46.580]                   function(frame = 1L) {
[10:21:46.580]                     if (is.function(sendCondition)) 
[10:21:46.580]                       return(sendCondition)
[10:21:46.580]                     ns <- getNamespace("parallel")
[10:21:46.580]                     if (exists("sendData", mode = "function", 
[10:21:46.580]                       envir = ns)) {
[10:21:46.580]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.580]                         envir = ns)
[10:21:46.580]                       envir <- sys.frame(frame)
[10:21:46.580]                       master <- NULL
[10:21:46.580]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.580]                         !identical(envir, emptyenv())) {
[10:21:46.580]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.580]                           inherits = FALSE)) {
[10:21:46.580]                           master <- get("master", mode = "list", 
[10:21:46.580]                             envir = envir, inherits = FALSE)
[10:21:46.580]                           if (inherits(master, c("SOCKnode", 
[10:21:46.580]                             "SOCK0node"))) {
[10:21:46.580]                             sendCondition <<- function(cond) {
[10:21:46.580]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.580]                                 success = TRUE)
[10:21:46.580]                               parallel_sendData(master, data)
[10:21:46.580]                             }
[10:21:46.580]                             return(sendCondition)
[10:21:46.580]                           }
[10:21:46.580]                         }
[10:21:46.580]                         frame <- frame + 1L
[10:21:46.580]                         envir <- sys.frame(frame)
[10:21:46.580]                       }
[10:21:46.580]                     }
[10:21:46.580]                     sendCondition <<- function(cond) NULL
[10:21:46.580]                   }
[10:21:46.580]                 })
[10:21:46.580]                 withCallingHandlers({
[10:21:46.580]                   value(a) + 1
[10:21:46.580]                 }, immediateCondition = function(cond) {
[10:21:46.580]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.580]                   sendCondition(cond)
[10:21:46.580]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.580]                   {
[10:21:46.580]                     inherits <- base::inherits
[10:21:46.580]                     invokeRestart <- base::invokeRestart
[10:21:46.580]                     is.null <- base::is.null
[10:21:46.580]                     muffled <- FALSE
[10:21:46.580]                     if (inherits(cond, "message")) {
[10:21:46.580]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.580]                       if (muffled) 
[10:21:46.580]                         invokeRestart("muffleMessage")
[10:21:46.580]                     }
[10:21:46.580]                     else if (inherits(cond, "warning")) {
[10:21:46.580]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.580]                       if (muffled) 
[10:21:46.580]                         invokeRestart("muffleWarning")
[10:21:46.580]                     }
[10:21:46.580]                     else if (inherits(cond, "condition")) {
[10:21:46.580]                       if (!is.null(pattern)) {
[10:21:46.580]                         computeRestarts <- base::computeRestarts
[10:21:46.580]                         grepl <- base::grepl
[10:21:46.580]                         restarts <- computeRestarts(cond)
[10:21:46.580]                         for (restart in restarts) {
[10:21:46.580]                           name <- restart$name
[10:21:46.580]                           if (is.null(name)) 
[10:21:46.580]                             next
[10:21:46.580]                           if (!grepl(pattern, name)) 
[10:21:46.580]                             next
[10:21:46.580]                           invokeRestart(restart)
[10:21:46.580]                           muffled <- TRUE
[10:21:46.580]                           break
[10:21:46.580]                         }
[10:21:46.580]                       }
[10:21:46.580]                     }
[10:21:46.580]                     invisible(muffled)
[10:21:46.580]                   }
[10:21:46.580]                   muffleCondition(cond)
[10:21:46.580]                 })
[10:21:46.580]             }))
[10:21:46.580]             future::FutureResult(value = ...future.value$value, 
[10:21:46.580]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.580]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.580]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.580]                     ...future.globalenv.names))
[10:21:46.580]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.580]         }, condition = base::local({
[10:21:46.580]             c <- base::c
[10:21:46.580]             inherits <- base::inherits
[10:21:46.580]             invokeRestart <- base::invokeRestart
[10:21:46.580]             length <- base::length
[10:21:46.580]             list <- base::list
[10:21:46.580]             seq.int <- base::seq.int
[10:21:46.580]             signalCondition <- base::signalCondition
[10:21:46.580]             sys.calls <- base::sys.calls
[10:21:46.580]             `[[` <- base::`[[`
[10:21:46.580]             `+` <- base::`+`
[10:21:46.580]             `<<-` <- base::`<<-`
[10:21:46.580]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.580]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.580]                   3L)]
[10:21:46.580]             }
[10:21:46.580]             function(cond) {
[10:21:46.580]                 is_error <- inherits(cond, "error")
[10:21:46.580]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.580]                   NULL)
[10:21:46.580]                 if (is_error) {
[10:21:46.580]                   sessionInformation <- function() {
[10:21:46.580]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.580]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.580]                       search = base::search(), system = base::Sys.info())
[10:21:46.580]                   }
[10:21:46.580]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.580]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.580]                     cond$call), session = sessionInformation(), 
[10:21:46.580]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.580]                   signalCondition(cond)
[10:21:46.580]                 }
[10:21:46.580]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.580]                 "immediateCondition"))) {
[10:21:46.580]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.580]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.580]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.580]                   if (TRUE && !signal) {
[10:21:46.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.580]                     {
[10:21:46.580]                       inherits <- base::inherits
[10:21:46.580]                       invokeRestart <- base::invokeRestart
[10:21:46.580]                       is.null <- base::is.null
[10:21:46.580]                       muffled <- FALSE
[10:21:46.580]                       if (inherits(cond, "message")) {
[10:21:46.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.580]                         if (muffled) 
[10:21:46.580]                           invokeRestart("muffleMessage")
[10:21:46.580]                       }
[10:21:46.580]                       else if (inherits(cond, "warning")) {
[10:21:46.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.580]                         if (muffled) 
[10:21:46.580]                           invokeRestart("muffleWarning")
[10:21:46.580]                       }
[10:21:46.580]                       else if (inherits(cond, "condition")) {
[10:21:46.580]                         if (!is.null(pattern)) {
[10:21:46.580]                           computeRestarts <- base::computeRestarts
[10:21:46.580]                           grepl <- base::grepl
[10:21:46.580]                           restarts <- computeRestarts(cond)
[10:21:46.580]                           for (restart in restarts) {
[10:21:46.580]                             name <- restart$name
[10:21:46.580]                             if (is.null(name)) 
[10:21:46.580]                               next
[10:21:46.580]                             if (!grepl(pattern, name)) 
[10:21:46.580]                               next
[10:21:46.580]                             invokeRestart(restart)
[10:21:46.580]                             muffled <- TRUE
[10:21:46.580]                             break
[10:21:46.580]                           }
[10:21:46.580]                         }
[10:21:46.580]                       }
[10:21:46.580]                       invisible(muffled)
[10:21:46.580]                     }
[10:21:46.580]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.580]                   }
[10:21:46.580]                 }
[10:21:46.580]                 else {
[10:21:46.580]                   if (TRUE) {
[10:21:46.580]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.580]                     {
[10:21:46.580]                       inherits <- base::inherits
[10:21:46.580]                       invokeRestart <- base::invokeRestart
[10:21:46.580]                       is.null <- base::is.null
[10:21:46.580]                       muffled <- FALSE
[10:21:46.580]                       if (inherits(cond, "message")) {
[10:21:46.580]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.580]                         if (muffled) 
[10:21:46.580]                           invokeRestart("muffleMessage")
[10:21:46.580]                       }
[10:21:46.580]                       else if (inherits(cond, "warning")) {
[10:21:46.580]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.580]                         if (muffled) 
[10:21:46.580]                           invokeRestart("muffleWarning")
[10:21:46.580]                       }
[10:21:46.580]                       else if (inherits(cond, "condition")) {
[10:21:46.580]                         if (!is.null(pattern)) {
[10:21:46.580]                           computeRestarts <- base::computeRestarts
[10:21:46.580]                           grepl <- base::grepl
[10:21:46.580]                           restarts <- computeRestarts(cond)
[10:21:46.580]                           for (restart in restarts) {
[10:21:46.580]                             name <- restart$name
[10:21:46.580]                             if (is.null(name)) 
[10:21:46.580]                               next
[10:21:46.580]                             if (!grepl(pattern, name)) 
[10:21:46.580]                               next
[10:21:46.580]                             invokeRestart(restart)
[10:21:46.580]                             muffled <- TRUE
[10:21:46.580]                             break
[10:21:46.580]                           }
[10:21:46.580]                         }
[10:21:46.580]                       }
[10:21:46.580]                       invisible(muffled)
[10:21:46.580]                     }
[10:21:46.580]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.580]                   }
[10:21:46.580]                 }
[10:21:46.580]             }
[10:21:46.580]         }))
[10:21:46.580]     }, error = function(ex) {
[10:21:46.580]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.580]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.580]                 ...future.rng), started = ...future.startTime, 
[10:21:46.580]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.580]             version = "1.8"), class = "FutureResult")
[10:21:46.580]     }, finally = {
[10:21:46.580]         if (!identical(...future.workdir, getwd())) 
[10:21:46.580]             setwd(...future.workdir)
[10:21:46.580]         {
[10:21:46.580]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.580]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.580]             }
[10:21:46.580]             base::options(...future.oldOptions)
[10:21:46.580]             if (.Platform$OS.type == "windows") {
[10:21:46.580]                 old_names <- names(...future.oldEnvVars)
[10:21:46.580]                 envs <- base::Sys.getenv()
[10:21:46.580]                 names <- names(envs)
[10:21:46.580]                 common <- intersect(names, old_names)
[10:21:46.580]                 added <- setdiff(names, old_names)
[10:21:46.580]                 removed <- setdiff(old_names, names)
[10:21:46.580]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.580]                   envs[common]]
[10:21:46.580]                 NAMES <- toupper(changed)
[10:21:46.580]                 args <- list()
[10:21:46.580]                 for (kk in seq_along(NAMES)) {
[10:21:46.580]                   name <- changed[[kk]]
[10:21:46.580]                   NAME <- NAMES[[kk]]
[10:21:46.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.580]                     next
[10:21:46.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.580]                 }
[10:21:46.580]                 NAMES <- toupper(added)
[10:21:46.580]                 for (kk in seq_along(NAMES)) {
[10:21:46.580]                   name <- added[[kk]]
[10:21:46.580]                   NAME <- NAMES[[kk]]
[10:21:46.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.580]                     next
[10:21:46.580]                   args[[name]] <- ""
[10:21:46.580]                 }
[10:21:46.580]                 NAMES <- toupper(removed)
[10:21:46.580]                 for (kk in seq_along(NAMES)) {
[10:21:46.580]                   name <- removed[[kk]]
[10:21:46.580]                   NAME <- NAMES[[kk]]
[10:21:46.580]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.580]                     next
[10:21:46.580]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.580]                 }
[10:21:46.580]                 if (length(args) > 0) 
[10:21:46.580]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.580]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.580]             }
[10:21:46.580]             else {
[10:21:46.580]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.580]             }
[10:21:46.580]             {
[10:21:46.580]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.580]                   0L) {
[10:21:46.580]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.580]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.580]                   base::options(opts)
[10:21:46.580]                 }
[10:21:46.580]                 {
[10:21:46.580]                   {
[10:21:46.580]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.580]                     NULL
[10:21:46.580]                   }
[10:21:46.580]                   options(future.plan = NULL)
[10:21:46.580]                   if (is.na(NA_character_)) 
[10:21:46.580]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.580]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.580]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.580]                     .init = FALSE)
[10:21:46.580]                 }
[10:21:46.580]             }
[10:21:46.580]         }
[10:21:46.580]     })
[10:21:46.580]     if (TRUE) {
[10:21:46.580]         base::sink(type = "output", split = FALSE)
[10:21:46.580]         if (TRUE) {
[10:21:46.580]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.580]         }
[10:21:46.580]         else {
[10:21:46.580]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.580]         }
[10:21:46.580]         base::close(...future.stdout)
[10:21:46.580]         ...future.stdout <- NULL
[10:21:46.580]     }
[10:21:46.580]     ...future.result$conditions <- ...future.conditions
[10:21:46.580]     ...future.result$finished <- base::Sys.time()
[10:21:46.580]     ...future.result
[10:21:46.580] }
[10:21:46.594] Exporting 1 global objects (313.46 KiB) to cluster node #2 ...
[10:21:46.604] Exporting ‘a’ (313.25 KiB) to cluster node #2 ...
[10:21:46.658] Exporting ‘a’ (313.25 KiB) to cluster node #2 ... DONE
[10:21:46.658] Exporting 1 global objects (313.46 KiB) to cluster node #2 ... DONE
[10:21:46.659] MultisessionFuture started
[10:21:46.659] - Launch lazy future ... done
[10:21:46.659] run() for ‘MultisessionFuture’ ... done
[10:21:46.659] result() for ClusterFuture ...
[10:21:46.659] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.659] - Validating connection of MultisessionFuture
[10:21:46.701] - received message: FutureResult
[10:21:46.701] - Received FutureResult
[10:21:46.702] - Erased future from FutureRegistry
[10:21:46.702] result() for ClusterFuture ...
[10:21:46.702] - result already collected: FutureResult
[10:21:46.702] result() for ClusterFuture ... done
[10:21:46.702] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.702] result() for ClusterFuture ... done
[10:21:46.702] result() for ClusterFuture ...
[10:21:46.702] - result already collected: FutureResult
[10:21:46.702] result() for ClusterFuture ... done
value(b) = 2
[10:21:46.703] result() for ClusterFuture ...
[10:21:46.703] - result already collected: FutureResult
[10:21:46.703] result() for ClusterFuture ... done
[10:21:46.703] result() for ClusterFuture ...
[10:21:46.703] - result already collected: FutureResult
[10:21:46.703] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.703] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.704] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[10:21:46.705] - globals found: [2] ‘{’, ‘pkg’
[10:21:46.705] Searching for globals ... DONE
[10:21:46.705] Resolving globals: TRUE
[10:21:46.705] Resolving any globals that are futures ...
[10:21:46.705] - globals: [2] ‘{’, ‘pkg’
[10:21:46.705] Resolving any globals that are futures ... DONE
[10:21:46.705] Resolving futures part of globals (recursively) ...
[10:21:46.706] resolve() on list ...
[10:21:46.706]  recursive: 99
[10:21:46.706]  length: 1
[10:21:46.706]  elements: ‘pkg’
[10:21:46.708]  length: 0 (resolved future 1)
[10:21:46.708] resolve() on list ... DONE
[10:21:46.708] - globals: [1] ‘pkg’
[10:21:46.709] Resolving futures part of globals (recursively) ... DONE
[10:21:46.709] The total size of the 1 globals is 42 bytes (42 bytes)
[10:21:46.709] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[10:21:46.709] - globals: [1] ‘pkg’
[10:21:46.709] 
[10:21:46.709] getGlobalsAndPackages() ... DONE
[10:21:46.710] Packages needed by the future expression (n = 0): <none>
[10:21:46.710] Packages needed by future strategies (n = 0): <none>
[10:21:46.710] {
[10:21:46.710]     {
[10:21:46.710]         {
[10:21:46.710]             ...future.startTime <- base::Sys.time()
[10:21:46.710]             {
[10:21:46.710]                 {
[10:21:46.710]                   {
[10:21:46.710]                     base::local({
[10:21:46.710]                       has_future <- base::requireNamespace("future", 
[10:21:46.710]                         quietly = TRUE)
[10:21:46.710]                       if (has_future) {
[10:21:46.710]                         ns <- base::getNamespace("future")
[10:21:46.710]                         version <- ns[[".package"]][["version"]]
[10:21:46.710]                         if (is.null(version)) 
[10:21:46.710]                           version <- utils::packageVersion("future")
[10:21:46.710]                       }
[10:21:46.710]                       else {
[10:21:46.710]                         version <- NULL
[10:21:46.710]                       }
[10:21:46.710]                       if (!has_future || version < "1.8.0") {
[10:21:46.710]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.710]                           "", base::R.version$version.string), 
[10:21:46.710]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:46.710]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.710]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.710]                             "release", "version")], collapse = " "), 
[10:21:46.710]                           hostname = base::Sys.info()[["nodename"]])
[10:21:46.710]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.710]                           info)
[10:21:46.710]                         info <- base::paste(info, collapse = "; ")
[10:21:46.710]                         if (!has_future) {
[10:21:46.710]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.710]                             info)
[10:21:46.710]                         }
[10:21:46.710]                         else {
[10:21:46.710]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.710]                             info, version)
[10:21:46.710]                         }
[10:21:46.710]                         base::stop(msg)
[10:21:46.710]                       }
[10:21:46.710]                     })
[10:21:46.710]                   }
[10:21:46.710]                   ...future.strategy.old <- future::plan("list")
[10:21:46.710]                   options(future.plan = NULL)
[10:21:46.710]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.710]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.710]                 }
[10:21:46.710]                 ...future.workdir <- getwd()
[10:21:46.710]             }
[10:21:46.710]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.710]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.710]         }
[10:21:46.710]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.710]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[10:21:46.710]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.710]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.710]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.710]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.710]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.710]             base::names(...future.oldOptions))
[10:21:46.710]     }
[10:21:46.710]     if (FALSE) {
[10:21:46.710]     }
[10:21:46.710]     else {
[10:21:46.710]         if (TRUE) {
[10:21:46.710]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.710]                 open = "w")
[10:21:46.710]         }
[10:21:46.710]         else {
[10:21:46.710]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.710]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.710]         }
[10:21:46.710]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.710]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.710]             base::sink(type = "output", split = FALSE)
[10:21:46.710]             base::close(...future.stdout)
[10:21:46.710]         }, add = TRUE)
[10:21:46.710]     }
[10:21:46.710]     ...future.frame <- base::sys.nframe()
[10:21:46.710]     ...future.conditions <- base::list()
[10:21:46.710]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.710]     if (FALSE) {
[10:21:46.710]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.710]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.710]     }
[10:21:46.710]     ...future.result <- base::tryCatch({
[10:21:46.710]         base::withCallingHandlers({
[10:21:46.710]             ...future.value <- base::withVisible(base::local({
[10:21:46.710]                 pkg
[10:21:46.710]             }))
[10:21:46.710]             future::FutureResult(value = ...future.value$value, 
[10:21:46.710]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.710]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.710]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.710]                     ...future.globalenv.names))
[10:21:46.710]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.710]         }, condition = base::local({
[10:21:46.710]             c <- base::c
[10:21:46.710]             inherits <- base::inherits
[10:21:46.710]             invokeRestart <- base::invokeRestart
[10:21:46.710]             length <- base::length
[10:21:46.710]             list <- base::list
[10:21:46.710]             seq.int <- base::seq.int
[10:21:46.710]             signalCondition <- base::signalCondition
[10:21:46.710]             sys.calls <- base::sys.calls
[10:21:46.710]             `[[` <- base::`[[`
[10:21:46.710]             `+` <- base::`+`
[10:21:46.710]             `<<-` <- base::`<<-`
[10:21:46.710]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.710]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.710]                   3L)]
[10:21:46.710]             }
[10:21:46.710]             function(cond) {
[10:21:46.710]                 is_error <- inherits(cond, "error")
[10:21:46.710]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.710]                   NULL)
[10:21:46.710]                 if (is_error) {
[10:21:46.710]                   sessionInformation <- function() {
[10:21:46.710]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.710]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.710]                       search = base::search(), system = base::Sys.info())
[10:21:46.710]                   }
[10:21:46.710]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.710]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.710]                     cond$call), session = sessionInformation(), 
[10:21:46.710]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.710]                   signalCondition(cond)
[10:21:46.710]                 }
[10:21:46.710]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.710]                 "immediateCondition"))) {
[10:21:46.710]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.710]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.710]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.710]                   if (TRUE && !signal) {
[10:21:46.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.710]                     {
[10:21:46.710]                       inherits <- base::inherits
[10:21:46.710]                       invokeRestart <- base::invokeRestart
[10:21:46.710]                       is.null <- base::is.null
[10:21:46.710]                       muffled <- FALSE
[10:21:46.710]                       if (inherits(cond, "message")) {
[10:21:46.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.710]                         if (muffled) 
[10:21:46.710]                           invokeRestart("muffleMessage")
[10:21:46.710]                       }
[10:21:46.710]                       else if (inherits(cond, "warning")) {
[10:21:46.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.710]                         if (muffled) 
[10:21:46.710]                           invokeRestart("muffleWarning")
[10:21:46.710]                       }
[10:21:46.710]                       else if (inherits(cond, "condition")) {
[10:21:46.710]                         if (!is.null(pattern)) {
[10:21:46.710]                           computeRestarts <- base::computeRestarts
[10:21:46.710]                           grepl <- base::grepl
[10:21:46.710]                           restarts <- computeRestarts(cond)
[10:21:46.710]                           for (restart in restarts) {
[10:21:46.710]                             name <- restart$name
[10:21:46.710]                             if (is.null(name)) 
[10:21:46.710]                               next
[10:21:46.710]                             if (!grepl(pattern, name)) 
[10:21:46.710]                               next
[10:21:46.710]                             invokeRestart(restart)
[10:21:46.710]                             muffled <- TRUE
[10:21:46.710]                             break
[10:21:46.710]                           }
[10:21:46.710]                         }
[10:21:46.710]                       }
[10:21:46.710]                       invisible(muffled)
[10:21:46.710]                     }
[10:21:46.710]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.710]                   }
[10:21:46.710]                 }
[10:21:46.710]                 else {
[10:21:46.710]                   if (TRUE) {
[10:21:46.710]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.710]                     {
[10:21:46.710]                       inherits <- base::inherits
[10:21:46.710]                       invokeRestart <- base::invokeRestart
[10:21:46.710]                       is.null <- base::is.null
[10:21:46.710]                       muffled <- FALSE
[10:21:46.710]                       if (inherits(cond, "message")) {
[10:21:46.710]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.710]                         if (muffled) 
[10:21:46.710]                           invokeRestart("muffleMessage")
[10:21:46.710]                       }
[10:21:46.710]                       else if (inherits(cond, "warning")) {
[10:21:46.710]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.710]                         if (muffled) 
[10:21:46.710]                           invokeRestart("muffleWarning")
[10:21:46.710]                       }
[10:21:46.710]                       else if (inherits(cond, "condition")) {
[10:21:46.710]                         if (!is.null(pattern)) {
[10:21:46.710]                           computeRestarts <- base::computeRestarts
[10:21:46.710]                           grepl <- base::grepl
[10:21:46.710]                           restarts <- computeRestarts(cond)
[10:21:46.710]                           for (restart in restarts) {
[10:21:46.710]                             name <- restart$name
[10:21:46.710]                             if (is.null(name)) 
[10:21:46.710]                               next
[10:21:46.710]                             if (!grepl(pattern, name)) 
[10:21:46.710]                               next
[10:21:46.710]                             invokeRestart(restart)
[10:21:46.710]                             muffled <- TRUE
[10:21:46.710]                             break
[10:21:46.710]                           }
[10:21:46.710]                         }
[10:21:46.710]                       }
[10:21:46.710]                       invisible(muffled)
[10:21:46.710]                     }
[10:21:46.710]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.710]                   }
[10:21:46.710]                 }
[10:21:46.710]             }
[10:21:46.710]         }))
[10:21:46.710]     }, error = function(ex) {
[10:21:46.710]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.710]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.710]                 ...future.rng), started = ...future.startTime, 
[10:21:46.710]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.710]             version = "1.8"), class = "FutureResult")
[10:21:46.710]     }, finally = {
[10:21:46.710]         if (!identical(...future.workdir, getwd())) 
[10:21:46.710]             setwd(...future.workdir)
[10:21:46.710]         {
[10:21:46.710]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.710]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.710]             }
[10:21:46.710]             base::options(...future.oldOptions)
[10:21:46.710]             if (.Platform$OS.type == "windows") {
[10:21:46.710]                 old_names <- names(...future.oldEnvVars)
[10:21:46.710]                 envs <- base::Sys.getenv()
[10:21:46.710]                 names <- names(envs)
[10:21:46.710]                 common <- intersect(names, old_names)
[10:21:46.710]                 added <- setdiff(names, old_names)
[10:21:46.710]                 removed <- setdiff(old_names, names)
[10:21:46.710]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.710]                   envs[common]]
[10:21:46.710]                 NAMES <- toupper(changed)
[10:21:46.710]                 args <- list()
[10:21:46.710]                 for (kk in seq_along(NAMES)) {
[10:21:46.710]                   name <- changed[[kk]]
[10:21:46.710]                   NAME <- NAMES[[kk]]
[10:21:46.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.710]                     next
[10:21:46.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.710]                 }
[10:21:46.710]                 NAMES <- toupper(added)
[10:21:46.710]                 for (kk in seq_along(NAMES)) {
[10:21:46.710]                   name <- added[[kk]]
[10:21:46.710]                   NAME <- NAMES[[kk]]
[10:21:46.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.710]                     next
[10:21:46.710]                   args[[name]] <- ""
[10:21:46.710]                 }
[10:21:46.710]                 NAMES <- toupper(removed)
[10:21:46.710]                 for (kk in seq_along(NAMES)) {
[10:21:46.710]                   name <- removed[[kk]]
[10:21:46.710]                   NAME <- NAMES[[kk]]
[10:21:46.710]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.710]                     next
[10:21:46.710]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.710]                 }
[10:21:46.710]                 if (length(args) > 0) 
[10:21:46.710]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.710]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.710]             }
[10:21:46.710]             else {
[10:21:46.710]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.710]             }
[10:21:46.710]             {
[10:21:46.710]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.710]                   0L) {
[10:21:46.710]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.710]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.710]                   base::options(opts)
[10:21:46.710]                 }
[10:21:46.710]                 {
[10:21:46.710]                   {
[10:21:46.710]                     NULL
[10:21:46.710]                     RNGkind("Mersenne-Twister")
[10:21:46.710]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:46.710]                       inherits = FALSE)
[10:21:46.710]                   }
[10:21:46.710]                   options(future.plan = NULL)
[10:21:46.710]                   if (is.na(NA_character_)) 
[10:21:46.710]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.710]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.710]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.710]                     .init = FALSE)
[10:21:46.710]                 }
[10:21:46.710]             }
[10:21:46.710]         }
[10:21:46.710]     })
[10:21:46.710]     if (TRUE) {
[10:21:46.710]         base::sink(type = "output", split = FALSE)
[10:21:46.710]         if (TRUE) {
[10:21:46.710]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.710]         }
[10:21:46.710]         else {
[10:21:46.710]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.710]         }
[10:21:46.710]         base::close(...future.stdout)
[10:21:46.710]         ...future.stdout <- NULL
[10:21:46.710]     }
[10:21:46.710]     ...future.result$conditions <- ...future.conditions
[10:21:46.710]     ...future.result$finished <- base::Sys.time()
[10:21:46.710]     ...future.result
[10:21:46.710] }
[10:21:46.712] assign_globals() ...
[10:21:46.712] List of 1
[10:21:46.712]  $ pkg: chr "foo"
[10:21:46.712]  - attr(*, "where")=List of 1
[10:21:46.712]   ..$ pkg:<environment: R_EmptyEnv> 
[10:21:46.712]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:46.712]  - attr(*, "resolved")= logi TRUE
[10:21:46.712]  - attr(*, "total_size")= num 42
[10:21:46.714] - copied ‘pkg’ to environment
[10:21:46.715] assign_globals() ... done
[10:21:46.715] plan(): Setting new future strategy stack:
[10:21:46.715] List of future strategies:
[10:21:46.715] 1. sequential:
[10:21:46.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:46.715]    - tweaked: FALSE
[10:21:46.715]    - call: NULL
[10:21:46.715] plan(): nbrOfWorkers() = 1
[10:21:46.716] plan(): Setting new future strategy stack:
[10:21:46.716] List of future strategies:
[10:21:46.716] 1. multisession:
[10:21:46.716]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:46.716]    - tweaked: FALSE
[10:21:46.716]    - call: plan(strategy)
[10:21:46.718] plan(): nbrOfWorkers() = 2
[10:21:46.718] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.719] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.719] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:46.721] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:46.721] Searching for globals ... DONE
[10:21:46.721] Resolving globals: TRUE
[10:21:46.721] Resolving any globals that are futures ...
[10:21:46.721] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:46.721] Resolving any globals that are futures ... DONE
[10:21:46.721] Resolving futures part of globals (recursively) ...
[10:21:46.722] resolve() on list ...
[10:21:46.722]  recursive: 99
[10:21:46.722]  length: 1
[10:21:46.722]  elements: ‘a’
[10:21:46.722]  length: 0 (resolved future 1)
[10:21:46.722] resolve() on list ... DONE
[10:21:46.722] - globals: [1] ‘a’
[10:21:46.722] Resolving futures part of globals (recursively) ... DONE
[10:21:46.722] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:46.723] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:46.723] - globals: [1] ‘a’
[10:21:46.723] 
[10:21:46.723] getGlobalsAndPackages() ... DONE
[10:21:46.723] run() for ‘Future’ ...
[10:21:46.723] - state: ‘created’
[10:21:46.723] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.737] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.737] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.737]   - Field: ‘node’
[10:21:46.737]   - Field: ‘label’
[10:21:46.737]   - Field: ‘local’
[10:21:46.737]   - Field: ‘owner’
[10:21:46.737]   - Field: ‘envir’
[10:21:46.738]   - Field: ‘workers’
[10:21:46.738]   - Field: ‘packages’
[10:21:46.738]   - Field: ‘gc’
[10:21:46.738]   - Field: ‘conditions’
[10:21:46.738]   - Field: ‘persistent’
[10:21:46.738]   - Field: ‘expr’
[10:21:46.738]   - Field: ‘uuid’
[10:21:46.738]   - Field: ‘seed’
[10:21:46.738]   - Field: ‘version’
[10:21:46.738]   - Field: ‘result’
[10:21:46.738]   - Field: ‘asynchronous’
[10:21:46.738]   - Field: ‘calls’
[10:21:46.739]   - Field: ‘globals’
[10:21:46.739]   - Field: ‘stdout’
[10:21:46.739]   - Field: ‘earlySignal’
[10:21:46.739]   - Field: ‘lazy’
[10:21:46.739]   - Field: ‘state’
[10:21:46.739] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.739] - Launch lazy future ...
[10:21:46.739] Packages needed by the future expression (n = 0): <none>
[10:21:46.739] Packages needed by future strategies (n = 0): <none>
[10:21:46.740] {
[10:21:46.740]     {
[10:21:46.740]         {
[10:21:46.740]             ...future.startTime <- base::Sys.time()
[10:21:46.740]             {
[10:21:46.740]                 {
[10:21:46.740]                   {
[10:21:46.740]                     {
[10:21:46.740]                       base::local({
[10:21:46.740]                         has_future <- base::requireNamespace("future", 
[10:21:46.740]                           quietly = TRUE)
[10:21:46.740]                         if (has_future) {
[10:21:46.740]                           ns <- base::getNamespace("future")
[10:21:46.740]                           version <- ns[[".package"]][["version"]]
[10:21:46.740]                           if (is.null(version)) 
[10:21:46.740]                             version <- utils::packageVersion("future")
[10:21:46.740]                         }
[10:21:46.740]                         else {
[10:21:46.740]                           version <- NULL
[10:21:46.740]                         }
[10:21:46.740]                         if (!has_future || version < "1.8.0") {
[10:21:46.740]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.740]                             "", base::R.version$version.string), 
[10:21:46.740]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.740]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.740]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.740]                               "release", "version")], collapse = " "), 
[10:21:46.740]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.740]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.740]                             info)
[10:21:46.740]                           info <- base::paste(info, collapse = "; ")
[10:21:46.740]                           if (!has_future) {
[10:21:46.740]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.740]                               info)
[10:21:46.740]                           }
[10:21:46.740]                           else {
[10:21:46.740]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.740]                               info, version)
[10:21:46.740]                           }
[10:21:46.740]                           base::stop(msg)
[10:21:46.740]                         }
[10:21:46.740]                       })
[10:21:46.740]                     }
[10:21:46.740]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.740]                     base::options(mc.cores = 1L)
[10:21:46.740]                   }
[10:21:46.740]                   ...future.strategy.old <- future::plan("list")
[10:21:46.740]                   options(future.plan = NULL)
[10:21:46.740]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.740]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.740]                 }
[10:21:46.740]                 ...future.workdir <- getwd()
[10:21:46.740]             }
[10:21:46.740]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.740]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.740]         }
[10:21:46.740]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.740]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:46.740]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.740]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.740]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.740]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.740]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.740]             base::names(...future.oldOptions))
[10:21:46.740]     }
[10:21:46.740]     if (FALSE) {
[10:21:46.740]     }
[10:21:46.740]     else {
[10:21:46.740]         if (TRUE) {
[10:21:46.740]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.740]                 open = "w")
[10:21:46.740]         }
[10:21:46.740]         else {
[10:21:46.740]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.740]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.740]         }
[10:21:46.740]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.740]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.740]             base::sink(type = "output", split = FALSE)
[10:21:46.740]             base::close(...future.stdout)
[10:21:46.740]         }, add = TRUE)
[10:21:46.740]     }
[10:21:46.740]     ...future.frame <- base::sys.nframe()
[10:21:46.740]     ...future.conditions <- base::list()
[10:21:46.740]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.740]     if (FALSE) {
[10:21:46.740]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.740]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.740]     }
[10:21:46.740]     ...future.result <- base::tryCatch({
[10:21:46.740]         base::withCallingHandlers({
[10:21:46.740]             ...future.value <- base::withVisible(base::local({
[10:21:46.740]                 ...future.makeSendCondition <- base::local({
[10:21:46.740]                   sendCondition <- NULL
[10:21:46.740]                   function(frame = 1L) {
[10:21:46.740]                     if (is.function(sendCondition)) 
[10:21:46.740]                       return(sendCondition)
[10:21:46.740]                     ns <- getNamespace("parallel")
[10:21:46.740]                     if (exists("sendData", mode = "function", 
[10:21:46.740]                       envir = ns)) {
[10:21:46.740]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.740]                         envir = ns)
[10:21:46.740]                       envir <- sys.frame(frame)
[10:21:46.740]                       master <- NULL
[10:21:46.740]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.740]                         !identical(envir, emptyenv())) {
[10:21:46.740]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.740]                           inherits = FALSE)) {
[10:21:46.740]                           master <- get("master", mode = "list", 
[10:21:46.740]                             envir = envir, inherits = FALSE)
[10:21:46.740]                           if (inherits(master, c("SOCKnode", 
[10:21:46.740]                             "SOCK0node"))) {
[10:21:46.740]                             sendCondition <<- function(cond) {
[10:21:46.740]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.740]                                 success = TRUE)
[10:21:46.740]                               parallel_sendData(master, data)
[10:21:46.740]                             }
[10:21:46.740]                             return(sendCondition)
[10:21:46.740]                           }
[10:21:46.740]                         }
[10:21:46.740]                         frame <- frame + 1L
[10:21:46.740]                         envir <- sys.frame(frame)
[10:21:46.740]                       }
[10:21:46.740]                     }
[10:21:46.740]                     sendCondition <<- function(cond) NULL
[10:21:46.740]                   }
[10:21:46.740]                 })
[10:21:46.740]                 withCallingHandlers({
[10:21:46.740]                   {
[10:21:46.740]                     b <- a
[10:21:46.740]                     a <- 2
[10:21:46.740]                     a * b
[10:21:46.740]                   }
[10:21:46.740]                 }, immediateCondition = function(cond) {
[10:21:46.740]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.740]                   sendCondition(cond)
[10:21:46.740]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.740]                   {
[10:21:46.740]                     inherits <- base::inherits
[10:21:46.740]                     invokeRestart <- base::invokeRestart
[10:21:46.740]                     is.null <- base::is.null
[10:21:46.740]                     muffled <- FALSE
[10:21:46.740]                     if (inherits(cond, "message")) {
[10:21:46.740]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.740]                       if (muffled) 
[10:21:46.740]                         invokeRestart("muffleMessage")
[10:21:46.740]                     }
[10:21:46.740]                     else if (inherits(cond, "warning")) {
[10:21:46.740]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.740]                       if (muffled) 
[10:21:46.740]                         invokeRestart("muffleWarning")
[10:21:46.740]                     }
[10:21:46.740]                     else if (inherits(cond, "condition")) {
[10:21:46.740]                       if (!is.null(pattern)) {
[10:21:46.740]                         computeRestarts <- base::computeRestarts
[10:21:46.740]                         grepl <- base::grepl
[10:21:46.740]                         restarts <- computeRestarts(cond)
[10:21:46.740]                         for (restart in restarts) {
[10:21:46.740]                           name <- restart$name
[10:21:46.740]                           if (is.null(name)) 
[10:21:46.740]                             next
[10:21:46.740]                           if (!grepl(pattern, name)) 
[10:21:46.740]                             next
[10:21:46.740]                           invokeRestart(restart)
[10:21:46.740]                           muffled <- TRUE
[10:21:46.740]                           break
[10:21:46.740]                         }
[10:21:46.740]                       }
[10:21:46.740]                     }
[10:21:46.740]                     invisible(muffled)
[10:21:46.740]                   }
[10:21:46.740]                   muffleCondition(cond)
[10:21:46.740]                 })
[10:21:46.740]             }))
[10:21:46.740]             future::FutureResult(value = ...future.value$value, 
[10:21:46.740]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.740]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.740]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.740]                     ...future.globalenv.names))
[10:21:46.740]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.740]         }, condition = base::local({
[10:21:46.740]             c <- base::c
[10:21:46.740]             inherits <- base::inherits
[10:21:46.740]             invokeRestart <- base::invokeRestart
[10:21:46.740]             length <- base::length
[10:21:46.740]             list <- base::list
[10:21:46.740]             seq.int <- base::seq.int
[10:21:46.740]             signalCondition <- base::signalCondition
[10:21:46.740]             sys.calls <- base::sys.calls
[10:21:46.740]             `[[` <- base::`[[`
[10:21:46.740]             `+` <- base::`+`
[10:21:46.740]             `<<-` <- base::`<<-`
[10:21:46.740]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.740]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.740]                   3L)]
[10:21:46.740]             }
[10:21:46.740]             function(cond) {
[10:21:46.740]                 is_error <- inherits(cond, "error")
[10:21:46.740]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.740]                   NULL)
[10:21:46.740]                 if (is_error) {
[10:21:46.740]                   sessionInformation <- function() {
[10:21:46.740]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.740]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.740]                       search = base::search(), system = base::Sys.info())
[10:21:46.740]                   }
[10:21:46.740]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.740]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.740]                     cond$call), session = sessionInformation(), 
[10:21:46.740]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.740]                   signalCondition(cond)
[10:21:46.740]                 }
[10:21:46.740]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.740]                 "immediateCondition"))) {
[10:21:46.740]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.740]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.740]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.740]                   if (TRUE && !signal) {
[10:21:46.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.740]                     {
[10:21:46.740]                       inherits <- base::inherits
[10:21:46.740]                       invokeRestart <- base::invokeRestart
[10:21:46.740]                       is.null <- base::is.null
[10:21:46.740]                       muffled <- FALSE
[10:21:46.740]                       if (inherits(cond, "message")) {
[10:21:46.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.740]                         if (muffled) 
[10:21:46.740]                           invokeRestart("muffleMessage")
[10:21:46.740]                       }
[10:21:46.740]                       else if (inherits(cond, "warning")) {
[10:21:46.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.740]                         if (muffled) 
[10:21:46.740]                           invokeRestart("muffleWarning")
[10:21:46.740]                       }
[10:21:46.740]                       else if (inherits(cond, "condition")) {
[10:21:46.740]                         if (!is.null(pattern)) {
[10:21:46.740]                           computeRestarts <- base::computeRestarts
[10:21:46.740]                           grepl <- base::grepl
[10:21:46.740]                           restarts <- computeRestarts(cond)
[10:21:46.740]                           for (restart in restarts) {
[10:21:46.740]                             name <- restart$name
[10:21:46.740]                             if (is.null(name)) 
[10:21:46.740]                               next
[10:21:46.740]                             if (!grepl(pattern, name)) 
[10:21:46.740]                               next
[10:21:46.740]                             invokeRestart(restart)
[10:21:46.740]                             muffled <- TRUE
[10:21:46.740]                             break
[10:21:46.740]                           }
[10:21:46.740]                         }
[10:21:46.740]                       }
[10:21:46.740]                       invisible(muffled)
[10:21:46.740]                     }
[10:21:46.740]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.740]                   }
[10:21:46.740]                 }
[10:21:46.740]                 else {
[10:21:46.740]                   if (TRUE) {
[10:21:46.740]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.740]                     {
[10:21:46.740]                       inherits <- base::inherits
[10:21:46.740]                       invokeRestart <- base::invokeRestart
[10:21:46.740]                       is.null <- base::is.null
[10:21:46.740]                       muffled <- FALSE
[10:21:46.740]                       if (inherits(cond, "message")) {
[10:21:46.740]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.740]                         if (muffled) 
[10:21:46.740]                           invokeRestart("muffleMessage")
[10:21:46.740]                       }
[10:21:46.740]                       else if (inherits(cond, "warning")) {
[10:21:46.740]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.740]                         if (muffled) 
[10:21:46.740]                           invokeRestart("muffleWarning")
[10:21:46.740]                       }
[10:21:46.740]                       else if (inherits(cond, "condition")) {
[10:21:46.740]                         if (!is.null(pattern)) {
[10:21:46.740]                           computeRestarts <- base::computeRestarts
[10:21:46.740]                           grepl <- base::grepl
[10:21:46.740]                           restarts <- computeRestarts(cond)
[10:21:46.740]                           for (restart in restarts) {
[10:21:46.740]                             name <- restart$name
[10:21:46.740]                             if (is.null(name)) 
[10:21:46.740]                               next
[10:21:46.740]                             if (!grepl(pattern, name)) 
[10:21:46.740]                               next
[10:21:46.740]                             invokeRestart(restart)
[10:21:46.740]                             muffled <- TRUE
[10:21:46.740]                             break
[10:21:46.740]                           }
[10:21:46.740]                         }
[10:21:46.740]                       }
[10:21:46.740]                       invisible(muffled)
[10:21:46.740]                     }
[10:21:46.740]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.740]                   }
[10:21:46.740]                 }
[10:21:46.740]             }
[10:21:46.740]         }))
[10:21:46.740]     }, error = function(ex) {
[10:21:46.740]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.740]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.740]                 ...future.rng), started = ...future.startTime, 
[10:21:46.740]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.740]             version = "1.8"), class = "FutureResult")
[10:21:46.740]     }, finally = {
[10:21:46.740]         if (!identical(...future.workdir, getwd())) 
[10:21:46.740]             setwd(...future.workdir)
[10:21:46.740]         {
[10:21:46.740]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.740]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.740]             }
[10:21:46.740]             base::options(...future.oldOptions)
[10:21:46.740]             if (.Platform$OS.type == "windows") {
[10:21:46.740]                 old_names <- names(...future.oldEnvVars)
[10:21:46.740]                 envs <- base::Sys.getenv()
[10:21:46.740]                 names <- names(envs)
[10:21:46.740]                 common <- intersect(names, old_names)
[10:21:46.740]                 added <- setdiff(names, old_names)
[10:21:46.740]                 removed <- setdiff(old_names, names)
[10:21:46.740]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.740]                   envs[common]]
[10:21:46.740]                 NAMES <- toupper(changed)
[10:21:46.740]                 args <- list()
[10:21:46.740]                 for (kk in seq_along(NAMES)) {
[10:21:46.740]                   name <- changed[[kk]]
[10:21:46.740]                   NAME <- NAMES[[kk]]
[10:21:46.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.740]                     next
[10:21:46.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.740]                 }
[10:21:46.740]                 NAMES <- toupper(added)
[10:21:46.740]                 for (kk in seq_along(NAMES)) {
[10:21:46.740]                   name <- added[[kk]]
[10:21:46.740]                   NAME <- NAMES[[kk]]
[10:21:46.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.740]                     next
[10:21:46.740]                   args[[name]] <- ""
[10:21:46.740]                 }
[10:21:46.740]                 NAMES <- toupper(removed)
[10:21:46.740]                 for (kk in seq_along(NAMES)) {
[10:21:46.740]                   name <- removed[[kk]]
[10:21:46.740]                   NAME <- NAMES[[kk]]
[10:21:46.740]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.740]                     next
[10:21:46.740]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.740]                 }
[10:21:46.740]                 if (length(args) > 0) 
[10:21:46.740]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.740]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.740]             }
[10:21:46.740]             else {
[10:21:46.740]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.740]             }
[10:21:46.740]             {
[10:21:46.740]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.740]                   0L) {
[10:21:46.740]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.740]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.740]                   base::options(opts)
[10:21:46.740]                 }
[10:21:46.740]                 {
[10:21:46.740]                   {
[10:21:46.740]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.740]                     NULL
[10:21:46.740]                   }
[10:21:46.740]                   options(future.plan = NULL)
[10:21:46.740]                   if (is.na(NA_character_)) 
[10:21:46.740]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.740]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.740]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.740]                     .init = FALSE)
[10:21:46.740]                 }
[10:21:46.740]             }
[10:21:46.740]         }
[10:21:46.740]     })
[10:21:46.740]     if (TRUE) {
[10:21:46.740]         base::sink(type = "output", split = FALSE)
[10:21:46.740]         if (TRUE) {
[10:21:46.740]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.740]         }
[10:21:46.740]         else {
[10:21:46.740]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.740]         }
[10:21:46.740]         base::close(...future.stdout)
[10:21:46.740]         ...future.stdout <- NULL
[10:21:46.740]     }
[10:21:46.740]     ...future.result$conditions <- ...future.conditions
[10:21:46.740]     ...future.result$finished <- base::Sys.time()
[10:21:46.740]     ...future.result
[10:21:46.740] }
[10:21:46.742] Exporting 1 global objects (346 bytes) to cluster node #2 ...
[10:21:46.743] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[10:21:46.743] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[10:21:46.743] Exporting 1 global objects (346 bytes) to cluster node #2 ... DONE
[10:21:46.744] MultisessionFuture started
[10:21:46.744] - Launch lazy future ... done
[10:21:46.744] run() for ‘MultisessionFuture’ ... done
[10:21:46.744] result() for ClusterFuture ...
[10:21:46.744] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.744] - Validating connection of MultisessionFuture
[10:21:46.787] - received message: FutureResult
[10:21:46.787] - Received FutureResult
[10:21:46.788] - Erased future from FutureRegistry
[10:21:46.788] result() for ClusterFuture ...
[10:21:46.788] - result already collected: FutureResult
[10:21:46.788] result() for ClusterFuture ... done
[10:21:46.788] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.788] result() for ClusterFuture ... done
[10:21:46.788] result() for ClusterFuture ...
[10:21:46.789] - result already collected: FutureResult
[10:21:46.789] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.790] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.790] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:46.792] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:46.792] Searching for globals ... DONE
[10:21:46.792] Resolving globals: TRUE
[10:21:46.792] Resolving any globals that are futures ...
[10:21:46.792] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[10:21:46.792] Resolving any globals that are futures ... DONE
[10:21:46.793] Resolving futures part of globals (recursively) ...
[10:21:46.793] resolve() on list ...
[10:21:46.793]  recursive: 99
[10:21:46.793]  length: 1
[10:21:46.793]  elements: ‘a’
[10:21:46.793]  length: 0 (resolved future 1)
[10:21:46.793] resolve() on list ... DONE
[10:21:46.794] - globals: [1] ‘a’
[10:21:46.794] Resolving futures part of globals (recursively) ... DONE
[10:21:46.794] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:46.794] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[10:21:46.794] - globals: [1] ‘a’
[10:21:46.794] 
[10:21:46.795] getGlobalsAndPackages() ... DONE
[10:21:46.795] run() for ‘Future’ ...
[10:21:46.795] - state: ‘created’
[10:21:46.795] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.811] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.811] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.811]   - Field: ‘node’
[10:21:46.812]   - Field: ‘label’
[10:21:46.812]   - Field: ‘local’
[10:21:46.812]   - Field: ‘owner’
[10:21:46.812]   - Field: ‘envir’
[10:21:46.812]   - Field: ‘workers’
[10:21:46.812]   - Field: ‘packages’
[10:21:46.812]   - Field: ‘gc’
[10:21:46.812]   - Field: ‘conditions’
[10:21:46.812]   - Field: ‘persistent’
[10:21:46.812]   - Field: ‘expr’
[10:21:46.812]   - Field: ‘uuid’
[10:21:46.813]   - Field: ‘seed’
[10:21:46.813]   - Field: ‘version’
[10:21:46.813]   - Field: ‘result’
[10:21:46.813]   - Field: ‘asynchronous’
[10:21:46.813]   - Field: ‘calls’
[10:21:46.813]   - Field: ‘globals’
[10:21:46.813]   - Field: ‘stdout’
[10:21:46.813]   - Field: ‘earlySignal’
[10:21:46.813]   - Field: ‘lazy’
[10:21:46.813]   - Field: ‘state’
[10:21:46.813] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.813] - Launch lazy future ...
[10:21:46.814] Packages needed by the future expression (n = 0): <none>
[10:21:46.814] Packages needed by future strategies (n = 0): <none>
[10:21:46.814] {
[10:21:46.814]     {
[10:21:46.814]         {
[10:21:46.814]             ...future.startTime <- base::Sys.time()
[10:21:46.814]             {
[10:21:46.814]                 {
[10:21:46.814]                   {
[10:21:46.814]                     {
[10:21:46.814]                       base::local({
[10:21:46.814]                         has_future <- base::requireNamespace("future", 
[10:21:46.814]                           quietly = TRUE)
[10:21:46.814]                         if (has_future) {
[10:21:46.814]                           ns <- base::getNamespace("future")
[10:21:46.814]                           version <- ns[[".package"]][["version"]]
[10:21:46.814]                           if (is.null(version)) 
[10:21:46.814]                             version <- utils::packageVersion("future")
[10:21:46.814]                         }
[10:21:46.814]                         else {
[10:21:46.814]                           version <- NULL
[10:21:46.814]                         }
[10:21:46.814]                         if (!has_future || version < "1.8.0") {
[10:21:46.814]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.814]                             "", base::R.version$version.string), 
[10:21:46.814]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.814]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.814]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.814]                               "release", "version")], collapse = " "), 
[10:21:46.814]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.814]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.814]                             info)
[10:21:46.814]                           info <- base::paste(info, collapse = "; ")
[10:21:46.814]                           if (!has_future) {
[10:21:46.814]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.814]                               info)
[10:21:46.814]                           }
[10:21:46.814]                           else {
[10:21:46.814]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.814]                               info, version)
[10:21:46.814]                           }
[10:21:46.814]                           base::stop(msg)
[10:21:46.814]                         }
[10:21:46.814]                       })
[10:21:46.814]                     }
[10:21:46.814]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.814]                     base::options(mc.cores = 1L)
[10:21:46.814]                   }
[10:21:46.814]                   ...future.strategy.old <- future::plan("list")
[10:21:46.814]                   options(future.plan = NULL)
[10:21:46.814]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.814]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.814]                 }
[10:21:46.814]                 ...future.workdir <- getwd()
[10:21:46.814]             }
[10:21:46.814]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.814]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.814]         }
[10:21:46.814]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.814]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:46.814]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.814]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.814]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.814]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.814]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.814]             base::names(...future.oldOptions))
[10:21:46.814]     }
[10:21:46.814]     if (FALSE) {
[10:21:46.814]     }
[10:21:46.814]     else {
[10:21:46.814]         if (TRUE) {
[10:21:46.814]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.814]                 open = "w")
[10:21:46.814]         }
[10:21:46.814]         else {
[10:21:46.814]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.814]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.814]         }
[10:21:46.814]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.814]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.814]             base::sink(type = "output", split = FALSE)
[10:21:46.814]             base::close(...future.stdout)
[10:21:46.814]         }, add = TRUE)
[10:21:46.814]     }
[10:21:46.814]     ...future.frame <- base::sys.nframe()
[10:21:46.814]     ...future.conditions <- base::list()
[10:21:46.814]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.814]     if (FALSE) {
[10:21:46.814]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.814]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.814]     }
[10:21:46.814]     ...future.result <- base::tryCatch({
[10:21:46.814]         base::withCallingHandlers({
[10:21:46.814]             ...future.value <- base::withVisible(base::local({
[10:21:46.814]                 ...future.makeSendCondition <- base::local({
[10:21:46.814]                   sendCondition <- NULL
[10:21:46.814]                   function(frame = 1L) {
[10:21:46.814]                     if (is.function(sendCondition)) 
[10:21:46.814]                       return(sendCondition)
[10:21:46.814]                     ns <- getNamespace("parallel")
[10:21:46.814]                     if (exists("sendData", mode = "function", 
[10:21:46.814]                       envir = ns)) {
[10:21:46.814]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.814]                         envir = ns)
[10:21:46.814]                       envir <- sys.frame(frame)
[10:21:46.814]                       master <- NULL
[10:21:46.814]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.814]                         !identical(envir, emptyenv())) {
[10:21:46.814]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.814]                           inherits = FALSE)) {
[10:21:46.814]                           master <- get("master", mode = "list", 
[10:21:46.814]                             envir = envir, inherits = FALSE)
[10:21:46.814]                           if (inherits(master, c("SOCKnode", 
[10:21:46.814]                             "SOCK0node"))) {
[10:21:46.814]                             sendCondition <<- function(cond) {
[10:21:46.814]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.814]                                 success = TRUE)
[10:21:46.814]                               parallel_sendData(master, data)
[10:21:46.814]                             }
[10:21:46.814]                             return(sendCondition)
[10:21:46.814]                           }
[10:21:46.814]                         }
[10:21:46.814]                         frame <- frame + 1L
[10:21:46.814]                         envir <- sys.frame(frame)
[10:21:46.814]                       }
[10:21:46.814]                     }
[10:21:46.814]                     sendCondition <<- function(cond) NULL
[10:21:46.814]                   }
[10:21:46.814]                 })
[10:21:46.814]                 withCallingHandlers({
[10:21:46.814]                   {
[10:21:46.814]                     b <- a
[10:21:46.814]                     a <- 2
[10:21:46.814]                     a * b
[10:21:46.814]                   }
[10:21:46.814]                 }, immediateCondition = function(cond) {
[10:21:46.814]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.814]                   sendCondition(cond)
[10:21:46.814]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.814]                   {
[10:21:46.814]                     inherits <- base::inherits
[10:21:46.814]                     invokeRestart <- base::invokeRestart
[10:21:46.814]                     is.null <- base::is.null
[10:21:46.814]                     muffled <- FALSE
[10:21:46.814]                     if (inherits(cond, "message")) {
[10:21:46.814]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.814]                       if (muffled) 
[10:21:46.814]                         invokeRestart("muffleMessage")
[10:21:46.814]                     }
[10:21:46.814]                     else if (inherits(cond, "warning")) {
[10:21:46.814]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.814]                       if (muffled) 
[10:21:46.814]                         invokeRestart("muffleWarning")
[10:21:46.814]                     }
[10:21:46.814]                     else if (inherits(cond, "condition")) {
[10:21:46.814]                       if (!is.null(pattern)) {
[10:21:46.814]                         computeRestarts <- base::computeRestarts
[10:21:46.814]                         grepl <- base::grepl
[10:21:46.814]                         restarts <- computeRestarts(cond)
[10:21:46.814]                         for (restart in restarts) {
[10:21:46.814]                           name <- restart$name
[10:21:46.814]                           if (is.null(name)) 
[10:21:46.814]                             next
[10:21:46.814]                           if (!grepl(pattern, name)) 
[10:21:46.814]                             next
[10:21:46.814]                           invokeRestart(restart)
[10:21:46.814]                           muffled <- TRUE
[10:21:46.814]                           break
[10:21:46.814]                         }
[10:21:46.814]                       }
[10:21:46.814]                     }
[10:21:46.814]                     invisible(muffled)
[10:21:46.814]                   }
[10:21:46.814]                   muffleCondition(cond)
[10:21:46.814]                 })
[10:21:46.814]             }))
[10:21:46.814]             future::FutureResult(value = ...future.value$value, 
[10:21:46.814]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.814]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.814]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.814]                     ...future.globalenv.names))
[10:21:46.814]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.814]         }, condition = base::local({
[10:21:46.814]             c <- base::c
[10:21:46.814]             inherits <- base::inherits
[10:21:46.814]             invokeRestart <- base::invokeRestart
[10:21:46.814]             length <- base::length
[10:21:46.814]             list <- base::list
[10:21:46.814]             seq.int <- base::seq.int
[10:21:46.814]             signalCondition <- base::signalCondition
[10:21:46.814]             sys.calls <- base::sys.calls
[10:21:46.814]             `[[` <- base::`[[`
[10:21:46.814]             `+` <- base::`+`
[10:21:46.814]             `<<-` <- base::`<<-`
[10:21:46.814]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.814]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.814]                   3L)]
[10:21:46.814]             }
[10:21:46.814]             function(cond) {
[10:21:46.814]                 is_error <- inherits(cond, "error")
[10:21:46.814]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.814]                   NULL)
[10:21:46.814]                 if (is_error) {
[10:21:46.814]                   sessionInformation <- function() {
[10:21:46.814]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.814]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.814]                       search = base::search(), system = base::Sys.info())
[10:21:46.814]                   }
[10:21:46.814]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.814]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.814]                     cond$call), session = sessionInformation(), 
[10:21:46.814]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.814]                   signalCondition(cond)
[10:21:46.814]                 }
[10:21:46.814]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.814]                 "immediateCondition"))) {
[10:21:46.814]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.814]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.814]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.814]                   if (TRUE && !signal) {
[10:21:46.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.814]                     {
[10:21:46.814]                       inherits <- base::inherits
[10:21:46.814]                       invokeRestart <- base::invokeRestart
[10:21:46.814]                       is.null <- base::is.null
[10:21:46.814]                       muffled <- FALSE
[10:21:46.814]                       if (inherits(cond, "message")) {
[10:21:46.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.814]                         if (muffled) 
[10:21:46.814]                           invokeRestart("muffleMessage")
[10:21:46.814]                       }
[10:21:46.814]                       else if (inherits(cond, "warning")) {
[10:21:46.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.814]                         if (muffled) 
[10:21:46.814]                           invokeRestart("muffleWarning")
[10:21:46.814]                       }
[10:21:46.814]                       else if (inherits(cond, "condition")) {
[10:21:46.814]                         if (!is.null(pattern)) {
[10:21:46.814]                           computeRestarts <- base::computeRestarts
[10:21:46.814]                           grepl <- base::grepl
[10:21:46.814]                           restarts <- computeRestarts(cond)
[10:21:46.814]                           for (restart in restarts) {
[10:21:46.814]                             name <- restart$name
[10:21:46.814]                             if (is.null(name)) 
[10:21:46.814]                               next
[10:21:46.814]                             if (!grepl(pattern, name)) 
[10:21:46.814]                               next
[10:21:46.814]                             invokeRestart(restart)
[10:21:46.814]                             muffled <- TRUE
[10:21:46.814]                             break
[10:21:46.814]                           }
[10:21:46.814]                         }
[10:21:46.814]                       }
[10:21:46.814]                       invisible(muffled)
[10:21:46.814]                     }
[10:21:46.814]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.814]                   }
[10:21:46.814]                 }
[10:21:46.814]                 else {
[10:21:46.814]                   if (TRUE) {
[10:21:46.814]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.814]                     {
[10:21:46.814]                       inherits <- base::inherits
[10:21:46.814]                       invokeRestart <- base::invokeRestart
[10:21:46.814]                       is.null <- base::is.null
[10:21:46.814]                       muffled <- FALSE
[10:21:46.814]                       if (inherits(cond, "message")) {
[10:21:46.814]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.814]                         if (muffled) 
[10:21:46.814]                           invokeRestart("muffleMessage")
[10:21:46.814]                       }
[10:21:46.814]                       else if (inherits(cond, "warning")) {
[10:21:46.814]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.814]                         if (muffled) 
[10:21:46.814]                           invokeRestart("muffleWarning")
[10:21:46.814]                       }
[10:21:46.814]                       else if (inherits(cond, "condition")) {
[10:21:46.814]                         if (!is.null(pattern)) {
[10:21:46.814]                           computeRestarts <- base::computeRestarts
[10:21:46.814]                           grepl <- base::grepl
[10:21:46.814]                           restarts <- computeRestarts(cond)
[10:21:46.814]                           for (restart in restarts) {
[10:21:46.814]                             name <- restart$name
[10:21:46.814]                             if (is.null(name)) 
[10:21:46.814]                               next
[10:21:46.814]                             if (!grepl(pattern, name)) 
[10:21:46.814]                               next
[10:21:46.814]                             invokeRestart(restart)
[10:21:46.814]                             muffled <- TRUE
[10:21:46.814]                             break
[10:21:46.814]                           }
[10:21:46.814]                         }
[10:21:46.814]                       }
[10:21:46.814]                       invisible(muffled)
[10:21:46.814]                     }
[10:21:46.814]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.814]                   }
[10:21:46.814]                 }
[10:21:46.814]             }
[10:21:46.814]         }))
[10:21:46.814]     }, error = function(ex) {
[10:21:46.814]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.814]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.814]                 ...future.rng), started = ...future.startTime, 
[10:21:46.814]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.814]             version = "1.8"), class = "FutureResult")
[10:21:46.814]     }, finally = {
[10:21:46.814]         if (!identical(...future.workdir, getwd())) 
[10:21:46.814]             setwd(...future.workdir)
[10:21:46.814]         {
[10:21:46.814]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.814]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.814]             }
[10:21:46.814]             base::options(...future.oldOptions)
[10:21:46.814]             if (.Platform$OS.type == "windows") {
[10:21:46.814]                 old_names <- names(...future.oldEnvVars)
[10:21:46.814]                 envs <- base::Sys.getenv()
[10:21:46.814]                 names <- names(envs)
[10:21:46.814]                 common <- intersect(names, old_names)
[10:21:46.814]                 added <- setdiff(names, old_names)
[10:21:46.814]                 removed <- setdiff(old_names, names)
[10:21:46.814]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.814]                   envs[common]]
[10:21:46.814]                 NAMES <- toupper(changed)
[10:21:46.814]                 args <- list()
[10:21:46.814]                 for (kk in seq_along(NAMES)) {
[10:21:46.814]                   name <- changed[[kk]]
[10:21:46.814]                   NAME <- NAMES[[kk]]
[10:21:46.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.814]                     next
[10:21:46.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.814]                 }
[10:21:46.814]                 NAMES <- toupper(added)
[10:21:46.814]                 for (kk in seq_along(NAMES)) {
[10:21:46.814]                   name <- added[[kk]]
[10:21:46.814]                   NAME <- NAMES[[kk]]
[10:21:46.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.814]                     next
[10:21:46.814]                   args[[name]] <- ""
[10:21:46.814]                 }
[10:21:46.814]                 NAMES <- toupper(removed)
[10:21:46.814]                 for (kk in seq_along(NAMES)) {
[10:21:46.814]                   name <- removed[[kk]]
[10:21:46.814]                   NAME <- NAMES[[kk]]
[10:21:46.814]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.814]                     next
[10:21:46.814]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.814]                 }
[10:21:46.814]                 if (length(args) > 0) 
[10:21:46.814]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.814]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.814]             }
[10:21:46.814]             else {
[10:21:46.814]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.814]             }
[10:21:46.814]             {
[10:21:46.814]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.814]                   0L) {
[10:21:46.814]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.814]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.814]                   base::options(opts)
[10:21:46.814]                 }
[10:21:46.814]                 {
[10:21:46.814]                   {
[10:21:46.814]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.814]                     NULL
[10:21:46.814]                   }
[10:21:46.814]                   options(future.plan = NULL)
[10:21:46.814]                   if (is.na(NA_character_)) 
[10:21:46.814]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.814]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.814]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.814]                     .init = FALSE)
[10:21:46.814]                 }
[10:21:46.814]             }
[10:21:46.814]         }
[10:21:46.814]     })
[10:21:46.814]     if (TRUE) {
[10:21:46.814]         base::sink(type = "output", split = FALSE)
[10:21:46.814]         if (TRUE) {
[10:21:46.814]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.814]         }
[10:21:46.814]         else {
[10:21:46.814]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.814]         }
[10:21:46.814]         base::close(...future.stdout)
[10:21:46.814]         ...future.stdout <- NULL
[10:21:46.814]     }
[10:21:46.814]     ...future.result$conditions <- ...future.conditions
[10:21:46.814]     ...future.result$finished <- base::Sys.time()
[10:21:46.814]     ...future.result
[10:21:46.814] }
[10:21:46.819] Exporting 1 global objects (346 bytes) to cluster node #2 ...
[10:21:46.819] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[10:21:46.820] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[10:21:46.820] Exporting 1 global objects (346 bytes) to cluster node #2 ... DONE
[10:21:46.820] MultisessionFuture started
[10:21:46.821] - Launch lazy future ... done
[10:21:46.821] run() for ‘MultisessionFuture’ ... done
[10:21:46.821] result() for ClusterFuture ...
[10:21:46.821] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.821] - Validating connection of MultisessionFuture
[10:21:46.862] - received message: FutureResult
[10:21:46.862] - Received FutureResult
[10:21:46.862] - Erased future from FutureRegistry
[10:21:46.863] result() for ClusterFuture ...
[10:21:46.863] - result already collected: FutureResult
[10:21:46.863] result() for ClusterFuture ... done
[10:21:46.863] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.863] result() for ClusterFuture ... done
[10:21:46.863] result() for ClusterFuture ...
[10:21:46.863] - result already collected: FutureResult
[10:21:46.863] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.864] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.864] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:46.866] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:46.866] Searching for globals ... DONE
[10:21:46.866] Resolving globals: TRUE
[10:21:46.866] Resolving any globals that are futures ...
[10:21:46.866] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:46.866] Resolving any globals that are futures ... DONE
[10:21:46.867] Resolving futures part of globals (recursively) ...
[10:21:46.867] resolve() on list ...
[10:21:46.867]  recursive: 99
[10:21:46.867]  length: 2
[10:21:46.867]  elements: ‘a’, ‘ii’
[10:21:46.867]  length: 1 (resolved future 1)
[10:21:46.868]  length: 0 (resolved future 2)
[10:21:46.868] resolve() on list ... DONE
[10:21:46.868] - globals: [2] ‘a’, ‘ii’
[10:21:46.868] Resolving futures part of globals (recursively) ... DONE
[10:21:46.868] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:46.868] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:46.868] - globals: [2] ‘a’, ‘ii’
[10:21:46.869] 
[10:21:46.869] getGlobalsAndPackages() ... DONE
[10:21:46.869] run() for ‘Future’ ...
[10:21:46.869] - state: ‘created’
[10:21:46.869] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.883] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.883] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.883]   - Field: ‘node’
[10:21:46.883]   - Field: ‘label’
[10:21:46.883]   - Field: ‘local’
[10:21:46.884]   - Field: ‘owner’
[10:21:46.884]   - Field: ‘envir’
[10:21:46.884]   - Field: ‘workers’
[10:21:46.884]   - Field: ‘packages’
[10:21:46.884]   - Field: ‘gc’
[10:21:46.884]   - Field: ‘conditions’
[10:21:46.884]   - Field: ‘persistent’
[10:21:46.884]   - Field: ‘expr’
[10:21:46.884]   - Field: ‘uuid’
[10:21:46.884]   - Field: ‘seed’
[10:21:46.884]   - Field: ‘version’
[10:21:46.885]   - Field: ‘result’
[10:21:46.885]   - Field: ‘asynchronous’
[10:21:46.885]   - Field: ‘calls’
[10:21:46.885]   - Field: ‘globals’
[10:21:46.885]   - Field: ‘stdout’
[10:21:46.885]   - Field: ‘earlySignal’
[10:21:46.885]   - Field: ‘lazy’
[10:21:46.885]   - Field: ‘state’
[10:21:46.885] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.885] - Launch lazy future ...
[10:21:46.886] Packages needed by the future expression (n = 0): <none>
[10:21:46.886] Packages needed by future strategies (n = 0): <none>
[10:21:46.886] {
[10:21:46.886]     {
[10:21:46.886]         {
[10:21:46.886]             ...future.startTime <- base::Sys.time()
[10:21:46.886]             {
[10:21:46.886]                 {
[10:21:46.886]                   {
[10:21:46.886]                     {
[10:21:46.886]                       base::local({
[10:21:46.886]                         has_future <- base::requireNamespace("future", 
[10:21:46.886]                           quietly = TRUE)
[10:21:46.886]                         if (has_future) {
[10:21:46.886]                           ns <- base::getNamespace("future")
[10:21:46.886]                           version <- ns[[".package"]][["version"]]
[10:21:46.886]                           if (is.null(version)) 
[10:21:46.886]                             version <- utils::packageVersion("future")
[10:21:46.886]                         }
[10:21:46.886]                         else {
[10:21:46.886]                           version <- NULL
[10:21:46.886]                         }
[10:21:46.886]                         if (!has_future || version < "1.8.0") {
[10:21:46.886]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.886]                             "", base::R.version$version.string), 
[10:21:46.886]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.886]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.886]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.886]                               "release", "version")], collapse = " "), 
[10:21:46.886]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.886]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.886]                             info)
[10:21:46.886]                           info <- base::paste(info, collapse = "; ")
[10:21:46.886]                           if (!has_future) {
[10:21:46.886]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.886]                               info)
[10:21:46.886]                           }
[10:21:46.886]                           else {
[10:21:46.886]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.886]                               info, version)
[10:21:46.886]                           }
[10:21:46.886]                           base::stop(msg)
[10:21:46.886]                         }
[10:21:46.886]                       })
[10:21:46.886]                     }
[10:21:46.886]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.886]                     base::options(mc.cores = 1L)
[10:21:46.886]                   }
[10:21:46.886]                   ...future.strategy.old <- future::plan("list")
[10:21:46.886]                   options(future.plan = NULL)
[10:21:46.886]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.886]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.886]                 }
[10:21:46.886]                 ...future.workdir <- getwd()
[10:21:46.886]             }
[10:21:46.886]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.886]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.886]         }
[10:21:46.886]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.886]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:46.886]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.886]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.886]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.886]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.886]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.886]             base::names(...future.oldOptions))
[10:21:46.886]     }
[10:21:46.886]     if (FALSE) {
[10:21:46.886]     }
[10:21:46.886]     else {
[10:21:46.886]         if (TRUE) {
[10:21:46.886]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.886]                 open = "w")
[10:21:46.886]         }
[10:21:46.886]         else {
[10:21:46.886]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.886]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.886]         }
[10:21:46.886]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.886]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.886]             base::sink(type = "output", split = FALSE)
[10:21:46.886]             base::close(...future.stdout)
[10:21:46.886]         }, add = TRUE)
[10:21:46.886]     }
[10:21:46.886]     ...future.frame <- base::sys.nframe()
[10:21:46.886]     ...future.conditions <- base::list()
[10:21:46.886]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.886]     if (FALSE) {
[10:21:46.886]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.886]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.886]     }
[10:21:46.886]     ...future.result <- base::tryCatch({
[10:21:46.886]         base::withCallingHandlers({
[10:21:46.886]             ...future.value <- base::withVisible(base::local({
[10:21:46.886]                 ...future.makeSendCondition <- base::local({
[10:21:46.886]                   sendCondition <- NULL
[10:21:46.886]                   function(frame = 1L) {
[10:21:46.886]                     if (is.function(sendCondition)) 
[10:21:46.886]                       return(sendCondition)
[10:21:46.886]                     ns <- getNamespace("parallel")
[10:21:46.886]                     if (exists("sendData", mode = "function", 
[10:21:46.886]                       envir = ns)) {
[10:21:46.886]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.886]                         envir = ns)
[10:21:46.886]                       envir <- sys.frame(frame)
[10:21:46.886]                       master <- NULL
[10:21:46.886]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.886]                         !identical(envir, emptyenv())) {
[10:21:46.886]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.886]                           inherits = FALSE)) {
[10:21:46.886]                           master <- get("master", mode = "list", 
[10:21:46.886]                             envir = envir, inherits = FALSE)
[10:21:46.886]                           if (inherits(master, c("SOCKnode", 
[10:21:46.886]                             "SOCK0node"))) {
[10:21:46.886]                             sendCondition <<- function(cond) {
[10:21:46.886]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.886]                                 success = TRUE)
[10:21:46.886]                               parallel_sendData(master, data)
[10:21:46.886]                             }
[10:21:46.886]                             return(sendCondition)
[10:21:46.886]                           }
[10:21:46.886]                         }
[10:21:46.886]                         frame <- frame + 1L
[10:21:46.886]                         envir <- sys.frame(frame)
[10:21:46.886]                       }
[10:21:46.886]                     }
[10:21:46.886]                     sendCondition <<- function(cond) NULL
[10:21:46.886]                   }
[10:21:46.886]                 })
[10:21:46.886]                 withCallingHandlers({
[10:21:46.886]                   {
[10:21:46.886]                     b <- a * ii
[10:21:46.886]                     a <- 0
[10:21:46.886]                     b
[10:21:46.886]                   }
[10:21:46.886]                 }, immediateCondition = function(cond) {
[10:21:46.886]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.886]                   sendCondition(cond)
[10:21:46.886]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.886]                   {
[10:21:46.886]                     inherits <- base::inherits
[10:21:46.886]                     invokeRestart <- base::invokeRestart
[10:21:46.886]                     is.null <- base::is.null
[10:21:46.886]                     muffled <- FALSE
[10:21:46.886]                     if (inherits(cond, "message")) {
[10:21:46.886]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.886]                       if (muffled) 
[10:21:46.886]                         invokeRestart("muffleMessage")
[10:21:46.886]                     }
[10:21:46.886]                     else if (inherits(cond, "warning")) {
[10:21:46.886]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.886]                       if (muffled) 
[10:21:46.886]                         invokeRestart("muffleWarning")
[10:21:46.886]                     }
[10:21:46.886]                     else if (inherits(cond, "condition")) {
[10:21:46.886]                       if (!is.null(pattern)) {
[10:21:46.886]                         computeRestarts <- base::computeRestarts
[10:21:46.886]                         grepl <- base::grepl
[10:21:46.886]                         restarts <- computeRestarts(cond)
[10:21:46.886]                         for (restart in restarts) {
[10:21:46.886]                           name <- restart$name
[10:21:46.886]                           if (is.null(name)) 
[10:21:46.886]                             next
[10:21:46.886]                           if (!grepl(pattern, name)) 
[10:21:46.886]                             next
[10:21:46.886]                           invokeRestart(restart)
[10:21:46.886]                           muffled <- TRUE
[10:21:46.886]                           break
[10:21:46.886]                         }
[10:21:46.886]                       }
[10:21:46.886]                     }
[10:21:46.886]                     invisible(muffled)
[10:21:46.886]                   }
[10:21:46.886]                   muffleCondition(cond)
[10:21:46.886]                 })
[10:21:46.886]             }))
[10:21:46.886]             future::FutureResult(value = ...future.value$value, 
[10:21:46.886]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.886]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.886]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.886]                     ...future.globalenv.names))
[10:21:46.886]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.886]         }, condition = base::local({
[10:21:46.886]             c <- base::c
[10:21:46.886]             inherits <- base::inherits
[10:21:46.886]             invokeRestart <- base::invokeRestart
[10:21:46.886]             length <- base::length
[10:21:46.886]             list <- base::list
[10:21:46.886]             seq.int <- base::seq.int
[10:21:46.886]             signalCondition <- base::signalCondition
[10:21:46.886]             sys.calls <- base::sys.calls
[10:21:46.886]             `[[` <- base::`[[`
[10:21:46.886]             `+` <- base::`+`
[10:21:46.886]             `<<-` <- base::`<<-`
[10:21:46.886]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.886]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.886]                   3L)]
[10:21:46.886]             }
[10:21:46.886]             function(cond) {
[10:21:46.886]                 is_error <- inherits(cond, "error")
[10:21:46.886]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.886]                   NULL)
[10:21:46.886]                 if (is_error) {
[10:21:46.886]                   sessionInformation <- function() {
[10:21:46.886]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.886]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.886]                       search = base::search(), system = base::Sys.info())
[10:21:46.886]                   }
[10:21:46.886]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.886]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.886]                     cond$call), session = sessionInformation(), 
[10:21:46.886]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.886]                   signalCondition(cond)
[10:21:46.886]                 }
[10:21:46.886]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.886]                 "immediateCondition"))) {
[10:21:46.886]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.886]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.886]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.886]                   if (TRUE && !signal) {
[10:21:46.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.886]                     {
[10:21:46.886]                       inherits <- base::inherits
[10:21:46.886]                       invokeRestart <- base::invokeRestart
[10:21:46.886]                       is.null <- base::is.null
[10:21:46.886]                       muffled <- FALSE
[10:21:46.886]                       if (inherits(cond, "message")) {
[10:21:46.886]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.886]                         if (muffled) 
[10:21:46.886]                           invokeRestart("muffleMessage")
[10:21:46.886]                       }
[10:21:46.886]                       else if (inherits(cond, "warning")) {
[10:21:46.886]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.886]                         if (muffled) 
[10:21:46.886]                           invokeRestart("muffleWarning")
[10:21:46.886]                       }
[10:21:46.886]                       else if (inherits(cond, "condition")) {
[10:21:46.886]                         if (!is.null(pattern)) {
[10:21:46.886]                           computeRestarts <- base::computeRestarts
[10:21:46.886]                           grepl <- base::grepl
[10:21:46.886]                           restarts <- computeRestarts(cond)
[10:21:46.886]                           for (restart in restarts) {
[10:21:46.886]                             name <- restart$name
[10:21:46.886]                             if (is.null(name)) 
[10:21:46.886]                               next
[10:21:46.886]                             if (!grepl(pattern, name)) 
[10:21:46.886]                               next
[10:21:46.886]                             invokeRestart(restart)
[10:21:46.886]                             muffled <- TRUE
[10:21:46.886]                             break
[10:21:46.886]                           }
[10:21:46.886]                         }
[10:21:46.886]                       }
[10:21:46.886]                       invisible(muffled)
[10:21:46.886]                     }
[10:21:46.886]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.886]                   }
[10:21:46.886]                 }
[10:21:46.886]                 else {
[10:21:46.886]                   if (TRUE) {
[10:21:46.886]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.886]                     {
[10:21:46.886]                       inherits <- base::inherits
[10:21:46.886]                       invokeRestart <- base::invokeRestart
[10:21:46.886]                       is.null <- base::is.null
[10:21:46.886]                       muffled <- FALSE
[10:21:46.886]                       if (inherits(cond, "message")) {
[10:21:46.886]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.886]                         if (muffled) 
[10:21:46.886]                           invokeRestart("muffleMessage")
[10:21:46.886]                       }
[10:21:46.886]                       else if (inherits(cond, "warning")) {
[10:21:46.886]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.886]                         if (muffled) 
[10:21:46.886]                           invokeRestart("muffleWarning")
[10:21:46.886]                       }
[10:21:46.886]                       else if (inherits(cond, "condition")) {
[10:21:46.886]                         if (!is.null(pattern)) {
[10:21:46.886]                           computeRestarts <- base::computeRestarts
[10:21:46.886]                           grepl <- base::grepl
[10:21:46.886]                           restarts <- computeRestarts(cond)
[10:21:46.886]                           for (restart in restarts) {
[10:21:46.886]                             name <- restart$name
[10:21:46.886]                             if (is.null(name)) 
[10:21:46.886]                               next
[10:21:46.886]                             if (!grepl(pattern, name)) 
[10:21:46.886]                               next
[10:21:46.886]                             invokeRestart(restart)
[10:21:46.886]                             muffled <- TRUE
[10:21:46.886]                             break
[10:21:46.886]                           }
[10:21:46.886]                         }
[10:21:46.886]                       }
[10:21:46.886]                       invisible(muffled)
[10:21:46.886]                     }
[10:21:46.886]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.886]                   }
[10:21:46.886]                 }
[10:21:46.886]             }
[10:21:46.886]         }))
[10:21:46.886]     }, error = function(ex) {
[10:21:46.886]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.886]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.886]                 ...future.rng), started = ...future.startTime, 
[10:21:46.886]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.886]             version = "1.8"), class = "FutureResult")
[10:21:46.886]     }, finally = {
[10:21:46.886]         if (!identical(...future.workdir, getwd())) 
[10:21:46.886]             setwd(...future.workdir)
[10:21:46.886]         {
[10:21:46.886]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.886]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.886]             }
[10:21:46.886]             base::options(...future.oldOptions)
[10:21:46.886]             if (.Platform$OS.type == "windows") {
[10:21:46.886]                 old_names <- names(...future.oldEnvVars)
[10:21:46.886]                 envs <- base::Sys.getenv()
[10:21:46.886]                 names <- names(envs)
[10:21:46.886]                 common <- intersect(names, old_names)
[10:21:46.886]                 added <- setdiff(names, old_names)
[10:21:46.886]                 removed <- setdiff(old_names, names)
[10:21:46.886]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.886]                   envs[common]]
[10:21:46.886]                 NAMES <- toupper(changed)
[10:21:46.886]                 args <- list()
[10:21:46.886]                 for (kk in seq_along(NAMES)) {
[10:21:46.886]                   name <- changed[[kk]]
[10:21:46.886]                   NAME <- NAMES[[kk]]
[10:21:46.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.886]                     next
[10:21:46.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.886]                 }
[10:21:46.886]                 NAMES <- toupper(added)
[10:21:46.886]                 for (kk in seq_along(NAMES)) {
[10:21:46.886]                   name <- added[[kk]]
[10:21:46.886]                   NAME <- NAMES[[kk]]
[10:21:46.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.886]                     next
[10:21:46.886]                   args[[name]] <- ""
[10:21:46.886]                 }
[10:21:46.886]                 NAMES <- toupper(removed)
[10:21:46.886]                 for (kk in seq_along(NAMES)) {
[10:21:46.886]                   name <- removed[[kk]]
[10:21:46.886]                   NAME <- NAMES[[kk]]
[10:21:46.886]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.886]                     next
[10:21:46.886]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.886]                 }
[10:21:46.886]                 if (length(args) > 0) 
[10:21:46.886]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.886]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.886]             }
[10:21:46.886]             else {
[10:21:46.886]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.886]             }
[10:21:46.886]             {
[10:21:46.886]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.886]                   0L) {
[10:21:46.886]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.886]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.886]                   base::options(opts)
[10:21:46.886]                 }
[10:21:46.886]                 {
[10:21:46.886]                   {
[10:21:46.886]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.886]                     NULL
[10:21:46.886]                   }
[10:21:46.886]                   options(future.plan = NULL)
[10:21:46.886]                   if (is.na(NA_character_)) 
[10:21:46.886]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.886]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.886]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.886]                     .init = FALSE)
[10:21:46.886]                 }
[10:21:46.886]             }
[10:21:46.886]         }
[10:21:46.886]     })
[10:21:46.886]     if (TRUE) {
[10:21:46.886]         base::sink(type = "output", split = FALSE)
[10:21:46.886]         if (TRUE) {
[10:21:46.886]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.886]         }
[10:21:46.886]         else {
[10:21:46.886]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.886]         }
[10:21:46.886]         base::close(...future.stdout)
[10:21:46.886]         ...future.stdout <- NULL
[10:21:46.886]     }
[10:21:46.886]     ...future.result$conditions <- ...future.conditions
[10:21:46.886]     ...future.result$finished <- base::Sys.time()
[10:21:46.886]     ...future.result
[10:21:46.886] }
[10:21:46.889] Exporting 2 global objects (382 bytes) to cluster node #2 ...
[10:21:46.889] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[10:21:46.889] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[10:21:46.889] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[10:21:46.890] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[10:21:46.890] Exporting 2 global objects (382 bytes) to cluster node #2 ... DONE
[10:21:46.890] MultisessionFuture started
[10:21:46.890] - Launch lazy future ... done
[10:21:46.890] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.891] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.891] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:46.893] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:46.893] Searching for globals ... DONE
[10:21:46.893] Resolving globals: TRUE
[10:21:46.893] Resolving any globals that are futures ...
[10:21:46.893] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:46.893] Resolving any globals that are futures ... DONE
[10:21:46.894] Resolving futures part of globals (recursively) ...
[10:21:46.894] resolve() on list ...
[10:21:46.894]  recursive: 99
[10:21:46.894]  length: 2
[10:21:46.894]  elements: ‘a’, ‘ii’
[10:21:46.894]  length: 1 (resolved future 1)
[10:21:46.894]  length: 0 (resolved future 2)
[10:21:46.894] resolve() on list ... DONE
[10:21:46.895] - globals: [2] ‘a’, ‘ii’
[10:21:46.895] Resolving futures part of globals (recursively) ... DONE
[10:21:46.895] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:46.895] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:46.895] - globals: [2] ‘a’, ‘ii’
[10:21:46.895] 
[10:21:46.895] getGlobalsAndPackages() ... DONE
[10:21:46.896] run() for ‘Future’ ...
[10:21:46.896] - state: ‘created’
[10:21:46.896] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.910] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.910] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.910]   - Field: ‘node’
[10:21:46.910]   - Field: ‘label’
[10:21:46.910]   - Field: ‘local’
[10:21:46.910]   - Field: ‘owner’
[10:21:46.910]   - Field: ‘envir’
[10:21:46.910]   - Field: ‘workers’
[10:21:46.910]   - Field: ‘packages’
[10:21:46.910]   - Field: ‘gc’
[10:21:46.911]   - Field: ‘conditions’
[10:21:46.911]   - Field: ‘persistent’
[10:21:46.911]   - Field: ‘expr’
[10:21:46.911]   - Field: ‘uuid’
[10:21:46.911]   - Field: ‘seed’
[10:21:46.911]   - Field: ‘version’
[10:21:46.911]   - Field: ‘result’
[10:21:46.911]   - Field: ‘asynchronous’
[10:21:46.911]   - Field: ‘calls’
[10:21:46.911]   - Field: ‘globals’
[10:21:46.911]   - Field: ‘stdout’
[10:21:46.911]   - Field: ‘earlySignal’
[10:21:46.912]   - Field: ‘lazy’
[10:21:46.912]   - Field: ‘state’
[10:21:46.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.912] - Launch lazy future ...
[10:21:46.912] Packages needed by the future expression (n = 0): <none>
[10:21:46.912] Packages needed by future strategies (n = 0): <none>
[10:21:46.913] {
[10:21:46.913]     {
[10:21:46.913]         {
[10:21:46.913]             ...future.startTime <- base::Sys.time()
[10:21:46.913]             {
[10:21:46.913]                 {
[10:21:46.913]                   {
[10:21:46.913]                     {
[10:21:46.913]                       base::local({
[10:21:46.913]                         has_future <- base::requireNamespace("future", 
[10:21:46.913]                           quietly = TRUE)
[10:21:46.913]                         if (has_future) {
[10:21:46.913]                           ns <- base::getNamespace("future")
[10:21:46.913]                           version <- ns[[".package"]][["version"]]
[10:21:46.913]                           if (is.null(version)) 
[10:21:46.913]                             version <- utils::packageVersion("future")
[10:21:46.913]                         }
[10:21:46.913]                         else {
[10:21:46.913]                           version <- NULL
[10:21:46.913]                         }
[10:21:46.913]                         if (!has_future || version < "1.8.0") {
[10:21:46.913]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.913]                             "", base::R.version$version.string), 
[10:21:46.913]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.913]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.913]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.913]                               "release", "version")], collapse = " "), 
[10:21:46.913]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.913]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.913]                             info)
[10:21:46.913]                           info <- base::paste(info, collapse = "; ")
[10:21:46.913]                           if (!has_future) {
[10:21:46.913]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.913]                               info)
[10:21:46.913]                           }
[10:21:46.913]                           else {
[10:21:46.913]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.913]                               info, version)
[10:21:46.913]                           }
[10:21:46.913]                           base::stop(msg)
[10:21:46.913]                         }
[10:21:46.913]                       })
[10:21:46.913]                     }
[10:21:46.913]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.913]                     base::options(mc.cores = 1L)
[10:21:46.913]                   }
[10:21:46.913]                   ...future.strategy.old <- future::plan("list")
[10:21:46.913]                   options(future.plan = NULL)
[10:21:46.913]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.913]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.913]                 }
[10:21:46.913]                 ...future.workdir <- getwd()
[10:21:46.913]             }
[10:21:46.913]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.913]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.913]         }
[10:21:46.913]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.913]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:46.913]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.913]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.913]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.913]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.913]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.913]             base::names(...future.oldOptions))
[10:21:46.913]     }
[10:21:46.913]     if (FALSE) {
[10:21:46.913]     }
[10:21:46.913]     else {
[10:21:46.913]         if (TRUE) {
[10:21:46.913]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.913]                 open = "w")
[10:21:46.913]         }
[10:21:46.913]         else {
[10:21:46.913]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.913]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.913]         }
[10:21:46.913]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.913]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.913]             base::sink(type = "output", split = FALSE)
[10:21:46.913]             base::close(...future.stdout)
[10:21:46.913]         }, add = TRUE)
[10:21:46.913]     }
[10:21:46.913]     ...future.frame <- base::sys.nframe()
[10:21:46.913]     ...future.conditions <- base::list()
[10:21:46.913]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.913]     if (FALSE) {
[10:21:46.913]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.913]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.913]     }
[10:21:46.913]     ...future.result <- base::tryCatch({
[10:21:46.913]         base::withCallingHandlers({
[10:21:46.913]             ...future.value <- base::withVisible(base::local({
[10:21:46.913]                 ...future.makeSendCondition <- base::local({
[10:21:46.913]                   sendCondition <- NULL
[10:21:46.913]                   function(frame = 1L) {
[10:21:46.913]                     if (is.function(sendCondition)) 
[10:21:46.913]                       return(sendCondition)
[10:21:46.913]                     ns <- getNamespace("parallel")
[10:21:46.913]                     if (exists("sendData", mode = "function", 
[10:21:46.913]                       envir = ns)) {
[10:21:46.913]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.913]                         envir = ns)
[10:21:46.913]                       envir <- sys.frame(frame)
[10:21:46.913]                       master <- NULL
[10:21:46.913]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.913]                         !identical(envir, emptyenv())) {
[10:21:46.913]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.913]                           inherits = FALSE)) {
[10:21:46.913]                           master <- get("master", mode = "list", 
[10:21:46.913]                             envir = envir, inherits = FALSE)
[10:21:46.913]                           if (inherits(master, c("SOCKnode", 
[10:21:46.913]                             "SOCK0node"))) {
[10:21:46.913]                             sendCondition <<- function(cond) {
[10:21:46.913]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.913]                                 success = TRUE)
[10:21:46.913]                               parallel_sendData(master, data)
[10:21:46.913]                             }
[10:21:46.913]                             return(sendCondition)
[10:21:46.913]                           }
[10:21:46.913]                         }
[10:21:46.913]                         frame <- frame + 1L
[10:21:46.913]                         envir <- sys.frame(frame)
[10:21:46.913]                       }
[10:21:46.913]                     }
[10:21:46.913]                     sendCondition <<- function(cond) NULL
[10:21:46.913]                   }
[10:21:46.913]                 })
[10:21:46.913]                 withCallingHandlers({
[10:21:46.913]                   {
[10:21:46.913]                     b <- a * ii
[10:21:46.913]                     a <- 0
[10:21:46.913]                     b
[10:21:46.913]                   }
[10:21:46.913]                 }, immediateCondition = function(cond) {
[10:21:46.913]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.913]                   sendCondition(cond)
[10:21:46.913]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.913]                   {
[10:21:46.913]                     inherits <- base::inherits
[10:21:46.913]                     invokeRestart <- base::invokeRestart
[10:21:46.913]                     is.null <- base::is.null
[10:21:46.913]                     muffled <- FALSE
[10:21:46.913]                     if (inherits(cond, "message")) {
[10:21:46.913]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.913]                       if (muffled) 
[10:21:46.913]                         invokeRestart("muffleMessage")
[10:21:46.913]                     }
[10:21:46.913]                     else if (inherits(cond, "warning")) {
[10:21:46.913]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.913]                       if (muffled) 
[10:21:46.913]                         invokeRestart("muffleWarning")
[10:21:46.913]                     }
[10:21:46.913]                     else if (inherits(cond, "condition")) {
[10:21:46.913]                       if (!is.null(pattern)) {
[10:21:46.913]                         computeRestarts <- base::computeRestarts
[10:21:46.913]                         grepl <- base::grepl
[10:21:46.913]                         restarts <- computeRestarts(cond)
[10:21:46.913]                         for (restart in restarts) {
[10:21:46.913]                           name <- restart$name
[10:21:46.913]                           if (is.null(name)) 
[10:21:46.913]                             next
[10:21:46.913]                           if (!grepl(pattern, name)) 
[10:21:46.913]                             next
[10:21:46.913]                           invokeRestart(restart)
[10:21:46.913]                           muffled <- TRUE
[10:21:46.913]                           break
[10:21:46.913]                         }
[10:21:46.913]                       }
[10:21:46.913]                     }
[10:21:46.913]                     invisible(muffled)
[10:21:46.913]                   }
[10:21:46.913]                   muffleCondition(cond)
[10:21:46.913]                 })
[10:21:46.913]             }))
[10:21:46.913]             future::FutureResult(value = ...future.value$value, 
[10:21:46.913]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.913]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.913]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.913]                     ...future.globalenv.names))
[10:21:46.913]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.913]         }, condition = base::local({
[10:21:46.913]             c <- base::c
[10:21:46.913]             inherits <- base::inherits
[10:21:46.913]             invokeRestart <- base::invokeRestart
[10:21:46.913]             length <- base::length
[10:21:46.913]             list <- base::list
[10:21:46.913]             seq.int <- base::seq.int
[10:21:46.913]             signalCondition <- base::signalCondition
[10:21:46.913]             sys.calls <- base::sys.calls
[10:21:46.913]             `[[` <- base::`[[`
[10:21:46.913]             `+` <- base::`+`
[10:21:46.913]             `<<-` <- base::`<<-`
[10:21:46.913]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.913]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.913]                   3L)]
[10:21:46.913]             }
[10:21:46.913]             function(cond) {
[10:21:46.913]                 is_error <- inherits(cond, "error")
[10:21:46.913]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.913]                   NULL)
[10:21:46.913]                 if (is_error) {
[10:21:46.913]                   sessionInformation <- function() {
[10:21:46.913]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.913]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.913]                       search = base::search(), system = base::Sys.info())
[10:21:46.913]                   }
[10:21:46.913]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.913]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.913]                     cond$call), session = sessionInformation(), 
[10:21:46.913]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.913]                   signalCondition(cond)
[10:21:46.913]                 }
[10:21:46.913]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.913]                 "immediateCondition"))) {
[10:21:46.913]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.913]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.913]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.913]                   if (TRUE && !signal) {
[10:21:46.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.913]                     {
[10:21:46.913]                       inherits <- base::inherits
[10:21:46.913]                       invokeRestart <- base::invokeRestart
[10:21:46.913]                       is.null <- base::is.null
[10:21:46.913]                       muffled <- FALSE
[10:21:46.913]                       if (inherits(cond, "message")) {
[10:21:46.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.913]                         if (muffled) 
[10:21:46.913]                           invokeRestart("muffleMessage")
[10:21:46.913]                       }
[10:21:46.913]                       else if (inherits(cond, "warning")) {
[10:21:46.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.913]                         if (muffled) 
[10:21:46.913]                           invokeRestart("muffleWarning")
[10:21:46.913]                       }
[10:21:46.913]                       else if (inherits(cond, "condition")) {
[10:21:46.913]                         if (!is.null(pattern)) {
[10:21:46.913]                           computeRestarts <- base::computeRestarts
[10:21:46.913]                           grepl <- base::grepl
[10:21:46.913]                           restarts <- computeRestarts(cond)
[10:21:46.913]                           for (restart in restarts) {
[10:21:46.913]                             name <- restart$name
[10:21:46.913]                             if (is.null(name)) 
[10:21:46.913]                               next
[10:21:46.913]                             if (!grepl(pattern, name)) 
[10:21:46.913]                               next
[10:21:46.913]                             invokeRestart(restart)
[10:21:46.913]                             muffled <- TRUE
[10:21:46.913]                             break
[10:21:46.913]                           }
[10:21:46.913]                         }
[10:21:46.913]                       }
[10:21:46.913]                       invisible(muffled)
[10:21:46.913]                     }
[10:21:46.913]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.913]                   }
[10:21:46.913]                 }
[10:21:46.913]                 else {
[10:21:46.913]                   if (TRUE) {
[10:21:46.913]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.913]                     {
[10:21:46.913]                       inherits <- base::inherits
[10:21:46.913]                       invokeRestart <- base::invokeRestart
[10:21:46.913]                       is.null <- base::is.null
[10:21:46.913]                       muffled <- FALSE
[10:21:46.913]                       if (inherits(cond, "message")) {
[10:21:46.913]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.913]                         if (muffled) 
[10:21:46.913]                           invokeRestart("muffleMessage")
[10:21:46.913]                       }
[10:21:46.913]                       else if (inherits(cond, "warning")) {
[10:21:46.913]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.913]                         if (muffled) 
[10:21:46.913]                           invokeRestart("muffleWarning")
[10:21:46.913]                       }
[10:21:46.913]                       else if (inherits(cond, "condition")) {
[10:21:46.913]                         if (!is.null(pattern)) {
[10:21:46.913]                           computeRestarts <- base::computeRestarts
[10:21:46.913]                           grepl <- base::grepl
[10:21:46.913]                           restarts <- computeRestarts(cond)
[10:21:46.913]                           for (restart in restarts) {
[10:21:46.913]                             name <- restart$name
[10:21:46.913]                             if (is.null(name)) 
[10:21:46.913]                               next
[10:21:46.913]                             if (!grepl(pattern, name)) 
[10:21:46.913]                               next
[10:21:46.913]                             invokeRestart(restart)
[10:21:46.913]                             muffled <- TRUE
[10:21:46.913]                             break
[10:21:46.913]                           }
[10:21:46.913]                         }
[10:21:46.913]                       }
[10:21:46.913]                       invisible(muffled)
[10:21:46.913]                     }
[10:21:46.913]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.913]                   }
[10:21:46.913]                 }
[10:21:46.913]             }
[10:21:46.913]         }))
[10:21:46.913]     }, error = function(ex) {
[10:21:46.913]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.913]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.913]                 ...future.rng), started = ...future.startTime, 
[10:21:46.913]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.913]             version = "1.8"), class = "FutureResult")
[10:21:46.913]     }, finally = {
[10:21:46.913]         if (!identical(...future.workdir, getwd())) 
[10:21:46.913]             setwd(...future.workdir)
[10:21:46.913]         {
[10:21:46.913]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.913]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.913]             }
[10:21:46.913]             base::options(...future.oldOptions)
[10:21:46.913]             if (.Platform$OS.type == "windows") {
[10:21:46.913]                 old_names <- names(...future.oldEnvVars)
[10:21:46.913]                 envs <- base::Sys.getenv()
[10:21:46.913]                 names <- names(envs)
[10:21:46.913]                 common <- intersect(names, old_names)
[10:21:46.913]                 added <- setdiff(names, old_names)
[10:21:46.913]                 removed <- setdiff(old_names, names)
[10:21:46.913]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.913]                   envs[common]]
[10:21:46.913]                 NAMES <- toupper(changed)
[10:21:46.913]                 args <- list()
[10:21:46.913]                 for (kk in seq_along(NAMES)) {
[10:21:46.913]                   name <- changed[[kk]]
[10:21:46.913]                   NAME <- NAMES[[kk]]
[10:21:46.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.913]                     next
[10:21:46.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.913]                 }
[10:21:46.913]                 NAMES <- toupper(added)
[10:21:46.913]                 for (kk in seq_along(NAMES)) {
[10:21:46.913]                   name <- added[[kk]]
[10:21:46.913]                   NAME <- NAMES[[kk]]
[10:21:46.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.913]                     next
[10:21:46.913]                   args[[name]] <- ""
[10:21:46.913]                 }
[10:21:46.913]                 NAMES <- toupper(removed)
[10:21:46.913]                 for (kk in seq_along(NAMES)) {
[10:21:46.913]                   name <- removed[[kk]]
[10:21:46.913]                   NAME <- NAMES[[kk]]
[10:21:46.913]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.913]                     next
[10:21:46.913]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.913]                 }
[10:21:46.913]                 if (length(args) > 0) 
[10:21:46.913]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.913]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.913]             }
[10:21:46.913]             else {
[10:21:46.913]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.913]             }
[10:21:46.913]             {
[10:21:46.913]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.913]                   0L) {
[10:21:46.913]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.913]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.913]                   base::options(opts)
[10:21:46.913]                 }
[10:21:46.913]                 {
[10:21:46.913]                   {
[10:21:46.913]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.913]                     NULL
[10:21:46.913]                   }
[10:21:46.913]                   options(future.plan = NULL)
[10:21:46.913]                   if (is.na(NA_character_)) 
[10:21:46.913]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.913]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.913]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.913]                     .init = FALSE)
[10:21:46.913]                 }
[10:21:46.913]             }
[10:21:46.913]         }
[10:21:46.913]     })
[10:21:46.913]     if (TRUE) {
[10:21:46.913]         base::sink(type = "output", split = FALSE)
[10:21:46.913]         if (TRUE) {
[10:21:46.913]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.913]         }
[10:21:46.913]         else {
[10:21:46.913]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.913]         }
[10:21:46.913]         base::close(...future.stdout)
[10:21:46.913]         ...future.stdout <- NULL
[10:21:46.913]     }
[10:21:46.913]     ...future.result$conditions <- ...future.conditions
[10:21:46.913]     ...future.result$finished <- base::Sys.time()
[10:21:46.913]     ...future.result
[10:21:46.913] }
[10:21:46.915] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:46.925] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.926] - Validating connection of MultisessionFuture
[10:21:46.926] - received message: FutureResult
[10:21:46.926] - Received FutureResult
[10:21:46.926] - Erased future from FutureRegistry
[10:21:46.926] result() for ClusterFuture ...
[10:21:46.926] - result already collected: FutureResult
[10:21:46.926] result() for ClusterFuture ... done
[10:21:46.927] signalConditions() ...
[10:21:46.927]  - include = ‘immediateCondition’
[10:21:46.927]  - exclude = 
[10:21:46.927]  - resignal = FALSE
[10:21:46.927]  - Number of conditions: 1
[10:21:46.927] signalConditions() ... done
[10:21:46.927] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.927] result() for ClusterFuture ...
[10:21:46.927] - result already collected: FutureResult
[10:21:46.927] result() for ClusterFuture ... done
[10:21:46.927] result() for ClusterFuture ...
[10:21:46.927] - result already collected: FutureResult
[10:21:46.928] result() for ClusterFuture ... done
[10:21:46.928] signalConditions() ...
[10:21:46.928]  - include = ‘immediateCondition’
[10:21:46.928]  - exclude = 
[10:21:46.928]  - resignal = FALSE
[10:21:46.928]  - Number of conditions: 1
[10:21:46.928] signalConditions() ... done
[10:21:46.929] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[10:21:46.929] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:46.929] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:46.929] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:46.930] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:46.930] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[10:21:46.930] MultisessionFuture started
[10:21:46.930] - Launch lazy future ... done
[10:21:46.931] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:46.931] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:46.931] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:46.933] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:46.933] Searching for globals ... DONE
[10:21:46.933] Resolving globals: TRUE
[10:21:46.934] Resolving any globals that are futures ...
[10:21:46.934] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:46.934] Resolving any globals that are futures ... DONE
[10:21:46.934] Resolving futures part of globals (recursively) ...
[10:21:46.934] resolve() on list ...
[10:21:46.934]  recursive: 99
[10:21:46.937]  length: 2
[10:21:46.937]  elements: ‘a’, ‘ii’
[10:21:46.937]  length: 1 (resolved future 1)
[10:21:46.937]  length: 0 (resolved future 2)
[10:21:46.937] resolve() on list ... DONE
[10:21:46.937] - globals: [2] ‘a’, ‘ii’
[10:21:46.937] Resolving futures part of globals (recursively) ... DONE
[10:21:46.938] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:46.938] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:46.938] - globals: [2] ‘a’, ‘ii’
[10:21:46.938] 
[10:21:46.938] getGlobalsAndPackages() ... DONE
[10:21:46.938] run() for ‘Future’ ...
[10:21:46.939] - state: ‘created’
[10:21:46.939] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:46.953] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:46.953] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:46.953]   - Field: ‘node’
[10:21:46.953]   - Field: ‘label’
[10:21:46.953]   - Field: ‘local’
[10:21:46.953]   - Field: ‘owner’
[10:21:46.953]   - Field: ‘envir’
[10:21:46.953]   - Field: ‘workers’
[10:21:46.953]   - Field: ‘packages’
[10:21:46.953]   - Field: ‘gc’
[10:21:46.953]   - Field: ‘conditions’
[10:21:46.954]   - Field: ‘persistent’
[10:21:46.954]   - Field: ‘expr’
[10:21:46.954]   - Field: ‘uuid’
[10:21:46.954]   - Field: ‘seed’
[10:21:46.954]   - Field: ‘version’
[10:21:46.954]   - Field: ‘result’
[10:21:46.954]   - Field: ‘asynchronous’
[10:21:46.954]   - Field: ‘calls’
[10:21:46.954]   - Field: ‘globals’
[10:21:46.954]   - Field: ‘stdout’
[10:21:46.954]   - Field: ‘earlySignal’
[10:21:46.954]   - Field: ‘lazy’
[10:21:46.955]   - Field: ‘state’
[10:21:46.955] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:46.955] - Launch lazy future ...
[10:21:46.955] Packages needed by the future expression (n = 0): <none>
[10:21:46.955] Packages needed by future strategies (n = 0): <none>
[10:21:46.956] {
[10:21:46.956]     {
[10:21:46.956]         {
[10:21:46.956]             ...future.startTime <- base::Sys.time()
[10:21:46.956]             {
[10:21:46.956]                 {
[10:21:46.956]                   {
[10:21:46.956]                     {
[10:21:46.956]                       base::local({
[10:21:46.956]                         has_future <- base::requireNamespace("future", 
[10:21:46.956]                           quietly = TRUE)
[10:21:46.956]                         if (has_future) {
[10:21:46.956]                           ns <- base::getNamespace("future")
[10:21:46.956]                           version <- ns[[".package"]][["version"]]
[10:21:46.956]                           if (is.null(version)) 
[10:21:46.956]                             version <- utils::packageVersion("future")
[10:21:46.956]                         }
[10:21:46.956]                         else {
[10:21:46.956]                           version <- NULL
[10:21:46.956]                         }
[10:21:46.956]                         if (!has_future || version < "1.8.0") {
[10:21:46.956]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:46.956]                             "", base::R.version$version.string), 
[10:21:46.956]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:46.956]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:46.956]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:46.956]                               "release", "version")], collapse = " "), 
[10:21:46.956]                             hostname = base::Sys.info()[["nodename"]])
[10:21:46.956]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:46.956]                             info)
[10:21:46.956]                           info <- base::paste(info, collapse = "; ")
[10:21:46.956]                           if (!has_future) {
[10:21:46.956]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:46.956]                               info)
[10:21:46.956]                           }
[10:21:46.956]                           else {
[10:21:46.956]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:46.956]                               info, version)
[10:21:46.956]                           }
[10:21:46.956]                           base::stop(msg)
[10:21:46.956]                         }
[10:21:46.956]                       })
[10:21:46.956]                     }
[10:21:46.956]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:46.956]                     base::options(mc.cores = 1L)
[10:21:46.956]                   }
[10:21:46.956]                   ...future.strategy.old <- future::plan("list")
[10:21:46.956]                   options(future.plan = NULL)
[10:21:46.956]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.956]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:46.956]                 }
[10:21:46.956]                 ...future.workdir <- getwd()
[10:21:46.956]             }
[10:21:46.956]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:46.956]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:46.956]         }
[10:21:46.956]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:46.956]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:46.956]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:46.956]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:46.956]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:46.956]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:46.956]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:46.956]             base::names(...future.oldOptions))
[10:21:46.956]     }
[10:21:46.956]     if (FALSE) {
[10:21:46.956]     }
[10:21:46.956]     else {
[10:21:46.956]         if (TRUE) {
[10:21:46.956]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:46.956]                 open = "w")
[10:21:46.956]         }
[10:21:46.956]         else {
[10:21:46.956]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:46.956]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:46.956]         }
[10:21:46.956]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:46.956]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:46.956]             base::sink(type = "output", split = FALSE)
[10:21:46.956]             base::close(...future.stdout)
[10:21:46.956]         }, add = TRUE)
[10:21:46.956]     }
[10:21:46.956]     ...future.frame <- base::sys.nframe()
[10:21:46.956]     ...future.conditions <- base::list()
[10:21:46.956]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:46.956]     if (FALSE) {
[10:21:46.956]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:46.956]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:46.956]     }
[10:21:46.956]     ...future.result <- base::tryCatch({
[10:21:46.956]         base::withCallingHandlers({
[10:21:46.956]             ...future.value <- base::withVisible(base::local({
[10:21:46.956]                 ...future.makeSendCondition <- base::local({
[10:21:46.956]                   sendCondition <- NULL
[10:21:46.956]                   function(frame = 1L) {
[10:21:46.956]                     if (is.function(sendCondition)) 
[10:21:46.956]                       return(sendCondition)
[10:21:46.956]                     ns <- getNamespace("parallel")
[10:21:46.956]                     if (exists("sendData", mode = "function", 
[10:21:46.956]                       envir = ns)) {
[10:21:46.956]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:46.956]                         envir = ns)
[10:21:46.956]                       envir <- sys.frame(frame)
[10:21:46.956]                       master <- NULL
[10:21:46.956]                       while (!identical(envir, .GlobalEnv) && 
[10:21:46.956]                         !identical(envir, emptyenv())) {
[10:21:46.956]                         if (exists("master", mode = "list", envir = envir, 
[10:21:46.956]                           inherits = FALSE)) {
[10:21:46.956]                           master <- get("master", mode = "list", 
[10:21:46.956]                             envir = envir, inherits = FALSE)
[10:21:46.956]                           if (inherits(master, c("SOCKnode", 
[10:21:46.956]                             "SOCK0node"))) {
[10:21:46.956]                             sendCondition <<- function(cond) {
[10:21:46.956]                               data <- list(type = "VALUE", value = cond, 
[10:21:46.956]                                 success = TRUE)
[10:21:46.956]                               parallel_sendData(master, data)
[10:21:46.956]                             }
[10:21:46.956]                             return(sendCondition)
[10:21:46.956]                           }
[10:21:46.956]                         }
[10:21:46.956]                         frame <- frame + 1L
[10:21:46.956]                         envir <- sys.frame(frame)
[10:21:46.956]                       }
[10:21:46.956]                     }
[10:21:46.956]                     sendCondition <<- function(cond) NULL
[10:21:46.956]                   }
[10:21:46.956]                 })
[10:21:46.956]                 withCallingHandlers({
[10:21:46.956]                   {
[10:21:46.956]                     b <- a * ii
[10:21:46.956]                     a <- 0
[10:21:46.956]                     b
[10:21:46.956]                   }
[10:21:46.956]                 }, immediateCondition = function(cond) {
[10:21:46.956]                   sendCondition <- ...future.makeSendCondition()
[10:21:46.956]                   sendCondition(cond)
[10:21:46.956]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.956]                   {
[10:21:46.956]                     inherits <- base::inherits
[10:21:46.956]                     invokeRestart <- base::invokeRestart
[10:21:46.956]                     is.null <- base::is.null
[10:21:46.956]                     muffled <- FALSE
[10:21:46.956]                     if (inherits(cond, "message")) {
[10:21:46.956]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:46.956]                       if (muffled) 
[10:21:46.956]                         invokeRestart("muffleMessage")
[10:21:46.956]                     }
[10:21:46.956]                     else if (inherits(cond, "warning")) {
[10:21:46.956]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:46.956]                       if (muffled) 
[10:21:46.956]                         invokeRestart("muffleWarning")
[10:21:46.956]                     }
[10:21:46.956]                     else if (inherits(cond, "condition")) {
[10:21:46.956]                       if (!is.null(pattern)) {
[10:21:46.956]                         computeRestarts <- base::computeRestarts
[10:21:46.956]                         grepl <- base::grepl
[10:21:46.956]                         restarts <- computeRestarts(cond)
[10:21:46.956]                         for (restart in restarts) {
[10:21:46.956]                           name <- restart$name
[10:21:46.956]                           if (is.null(name)) 
[10:21:46.956]                             next
[10:21:46.956]                           if (!grepl(pattern, name)) 
[10:21:46.956]                             next
[10:21:46.956]                           invokeRestart(restart)
[10:21:46.956]                           muffled <- TRUE
[10:21:46.956]                           break
[10:21:46.956]                         }
[10:21:46.956]                       }
[10:21:46.956]                     }
[10:21:46.956]                     invisible(muffled)
[10:21:46.956]                   }
[10:21:46.956]                   muffleCondition(cond)
[10:21:46.956]                 })
[10:21:46.956]             }))
[10:21:46.956]             future::FutureResult(value = ...future.value$value, 
[10:21:46.956]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.956]                   ...future.rng), globalenv = if (FALSE) 
[10:21:46.956]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:46.956]                     ...future.globalenv.names))
[10:21:46.956]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:46.956]         }, condition = base::local({
[10:21:46.956]             c <- base::c
[10:21:46.956]             inherits <- base::inherits
[10:21:46.956]             invokeRestart <- base::invokeRestart
[10:21:46.956]             length <- base::length
[10:21:46.956]             list <- base::list
[10:21:46.956]             seq.int <- base::seq.int
[10:21:46.956]             signalCondition <- base::signalCondition
[10:21:46.956]             sys.calls <- base::sys.calls
[10:21:46.956]             `[[` <- base::`[[`
[10:21:46.956]             `+` <- base::`+`
[10:21:46.956]             `<<-` <- base::`<<-`
[10:21:46.956]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:46.956]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:46.956]                   3L)]
[10:21:46.956]             }
[10:21:46.956]             function(cond) {
[10:21:46.956]                 is_error <- inherits(cond, "error")
[10:21:46.956]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:46.956]                   NULL)
[10:21:46.956]                 if (is_error) {
[10:21:46.956]                   sessionInformation <- function() {
[10:21:46.956]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:46.956]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:46.956]                       search = base::search(), system = base::Sys.info())
[10:21:46.956]                   }
[10:21:46.956]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.956]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:46.956]                     cond$call), session = sessionInformation(), 
[10:21:46.956]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:46.956]                   signalCondition(cond)
[10:21:46.956]                 }
[10:21:46.956]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:46.956]                 "immediateCondition"))) {
[10:21:46.956]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:46.956]                   ...future.conditions[[length(...future.conditions) + 
[10:21:46.956]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:46.956]                   if (TRUE && !signal) {
[10:21:46.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.956]                     {
[10:21:46.956]                       inherits <- base::inherits
[10:21:46.956]                       invokeRestart <- base::invokeRestart
[10:21:46.956]                       is.null <- base::is.null
[10:21:46.956]                       muffled <- FALSE
[10:21:46.956]                       if (inherits(cond, "message")) {
[10:21:46.956]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.956]                         if (muffled) 
[10:21:46.956]                           invokeRestart("muffleMessage")
[10:21:46.956]                       }
[10:21:46.956]                       else if (inherits(cond, "warning")) {
[10:21:46.956]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.956]                         if (muffled) 
[10:21:46.956]                           invokeRestart("muffleWarning")
[10:21:46.956]                       }
[10:21:46.956]                       else if (inherits(cond, "condition")) {
[10:21:46.956]                         if (!is.null(pattern)) {
[10:21:46.956]                           computeRestarts <- base::computeRestarts
[10:21:46.956]                           grepl <- base::grepl
[10:21:46.956]                           restarts <- computeRestarts(cond)
[10:21:46.956]                           for (restart in restarts) {
[10:21:46.956]                             name <- restart$name
[10:21:46.956]                             if (is.null(name)) 
[10:21:46.956]                               next
[10:21:46.956]                             if (!grepl(pattern, name)) 
[10:21:46.956]                               next
[10:21:46.956]                             invokeRestart(restart)
[10:21:46.956]                             muffled <- TRUE
[10:21:46.956]                             break
[10:21:46.956]                           }
[10:21:46.956]                         }
[10:21:46.956]                       }
[10:21:46.956]                       invisible(muffled)
[10:21:46.956]                     }
[10:21:46.956]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.956]                   }
[10:21:46.956]                 }
[10:21:46.956]                 else {
[10:21:46.956]                   if (TRUE) {
[10:21:46.956]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:46.956]                     {
[10:21:46.956]                       inherits <- base::inherits
[10:21:46.956]                       invokeRestart <- base::invokeRestart
[10:21:46.956]                       is.null <- base::is.null
[10:21:46.956]                       muffled <- FALSE
[10:21:46.956]                       if (inherits(cond, "message")) {
[10:21:46.956]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:46.956]                         if (muffled) 
[10:21:46.956]                           invokeRestart("muffleMessage")
[10:21:46.956]                       }
[10:21:46.956]                       else if (inherits(cond, "warning")) {
[10:21:46.956]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:46.956]                         if (muffled) 
[10:21:46.956]                           invokeRestart("muffleWarning")
[10:21:46.956]                       }
[10:21:46.956]                       else if (inherits(cond, "condition")) {
[10:21:46.956]                         if (!is.null(pattern)) {
[10:21:46.956]                           computeRestarts <- base::computeRestarts
[10:21:46.956]                           grepl <- base::grepl
[10:21:46.956]                           restarts <- computeRestarts(cond)
[10:21:46.956]                           for (restart in restarts) {
[10:21:46.956]                             name <- restart$name
[10:21:46.956]                             if (is.null(name)) 
[10:21:46.956]                               next
[10:21:46.956]                             if (!grepl(pattern, name)) 
[10:21:46.956]                               next
[10:21:46.956]                             invokeRestart(restart)
[10:21:46.956]                             muffled <- TRUE
[10:21:46.956]                             break
[10:21:46.956]                           }
[10:21:46.956]                         }
[10:21:46.956]                       }
[10:21:46.956]                       invisible(muffled)
[10:21:46.956]                     }
[10:21:46.956]                     muffleCondition(cond, pattern = "^muffle")
[10:21:46.956]                   }
[10:21:46.956]                 }
[10:21:46.956]             }
[10:21:46.956]         }))
[10:21:46.956]     }, error = function(ex) {
[10:21:46.956]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:46.956]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:46.956]                 ...future.rng), started = ...future.startTime, 
[10:21:46.956]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:46.956]             version = "1.8"), class = "FutureResult")
[10:21:46.956]     }, finally = {
[10:21:46.956]         if (!identical(...future.workdir, getwd())) 
[10:21:46.956]             setwd(...future.workdir)
[10:21:46.956]         {
[10:21:46.956]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:46.956]                 ...future.oldOptions$nwarnings <- NULL
[10:21:46.956]             }
[10:21:46.956]             base::options(...future.oldOptions)
[10:21:46.956]             if (.Platform$OS.type == "windows") {
[10:21:46.956]                 old_names <- names(...future.oldEnvVars)
[10:21:46.956]                 envs <- base::Sys.getenv()
[10:21:46.956]                 names <- names(envs)
[10:21:46.956]                 common <- intersect(names, old_names)
[10:21:46.956]                 added <- setdiff(names, old_names)
[10:21:46.956]                 removed <- setdiff(old_names, names)
[10:21:46.956]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:46.956]                   envs[common]]
[10:21:46.956]                 NAMES <- toupper(changed)
[10:21:46.956]                 args <- list()
[10:21:46.956]                 for (kk in seq_along(NAMES)) {
[10:21:46.956]                   name <- changed[[kk]]
[10:21:46.956]                   NAME <- NAMES[[kk]]
[10:21:46.956]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.956]                     next
[10:21:46.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.956]                 }
[10:21:46.956]                 NAMES <- toupper(added)
[10:21:46.956]                 for (kk in seq_along(NAMES)) {
[10:21:46.956]                   name <- added[[kk]]
[10:21:46.956]                   NAME <- NAMES[[kk]]
[10:21:46.956]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.956]                     next
[10:21:46.956]                   args[[name]] <- ""
[10:21:46.956]                 }
[10:21:46.956]                 NAMES <- toupper(removed)
[10:21:46.956]                 for (kk in seq_along(NAMES)) {
[10:21:46.956]                   name <- removed[[kk]]
[10:21:46.956]                   NAME <- NAMES[[kk]]
[10:21:46.956]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:46.956]                     next
[10:21:46.956]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:46.956]                 }
[10:21:46.956]                 if (length(args) > 0) 
[10:21:46.956]                   base::do.call(base::Sys.setenv, args = args)
[10:21:46.956]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:46.956]             }
[10:21:46.956]             else {
[10:21:46.956]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:46.956]             }
[10:21:46.956]             {
[10:21:46.956]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:46.956]                   0L) {
[10:21:46.956]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:46.956]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:46.956]                   base::options(opts)
[10:21:46.956]                 }
[10:21:46.956]                 {
[10:21:46.956]                   {
[10:21:46.956]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:46.956]                     NULL
[10:21:46.956]                   }
[10:21:46.956]                   options(future.plan = NULL)
[10:21:46.956]                   if (is.na(NA_character_)) 
[10:21:46.956]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:46.956]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:46.956]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:46.956]                     .init = FALSE)
[10:21:46.956]                 }
[10:21:46.956]             }
[10:21:46.956]         }
[10:21:46.956]     })
[10:21:46.956]     if (TRUE) {
[10:21:46.956]         base::sink(type = "output", split = FALSE)
[10:21:46.956]         if (TRUE) {
[10:21:46.956]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:46.956]         }
[10:21:46.956]         else {
[10:21:46.956]             ...future.result["stdout"] <- base::list(NULL)
[10:21:46.956]         }
[10:21:46.956]         base::close(...future.stdout)
[10:21:46.956]         ...future.stdout <- NULL
[10:21:46.956]     }
[10:21:46.956]     ...future.result$conditions <- ...future.conditions
[10:21:46.956]     ...future.result$finished <- base::Sys.time()
[10:21:46.956]     ...future.result
[10:21:46.956] }
[10:21:46.958] Poll #1 (0): usedNodes() = 2, workers = 2
[10:21:46.968] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.969] - Validating connection of MultisessionFuture
[10:21:46.969] - received message: FutureResult
[10:21:46.969] - Received FutureResult
[10:21:46.969] - Erased future from FutureRegistry
[10:21:46.969] result() for ClusterFuture ...
[10:21:46.969] - result already collected: FutureResult
[10:21:46.969] result() for ClusterFuture ... done
[10:21:46.969] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.969] result() for ClusterFuture ...
[10:21:46.970] - result already collected: FutureResult
[10:21:46.970] result() for ClusterFuture ... done
[10:21:46.970] result() for ClusterFuture ...
[10:21:46.970] - result already collected: FutureResult
[10:21:46.970] result() for ClusterFuture ... done
[10:21:46.971] Exporting 2 global objects (382 bytes) to cluster node #2 ...
[10:21:46.971] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[10:21:46.971] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[10:21:46.971] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[10:21:46.972] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[10:21:46.972] Exporting 2 global objects (382 bytes) to cluster node #2 ... DONE
[10:21:46.972] MultisessionFuture started
[10:21:46.972] - Launch lazy future ... done
[10:21:46.972] run() for ‘MultisessionFuture’ ... done
[10:21:46.973] result() for ClusterFuture ...
[10:21:46.973] - result already collected: FutureResult
[10:21:46.973] result() for ClusterFuture ... done
[10:21:46.973] result() for ClusterFuture ...
[10:21:46.973] - result already collected: FutureResult
[10:21:46.973] result() for ClusterFuture ... done
[10:21:46.973] result() for ClusterFuture ...
[10:21:46.973] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.973] - Validating connection of MultisessionFuture
[10:21:46.973] - received message: FutureResult
[10:21:46.974] - Received FutureResult
[10:21:46.974] - Erased future from FutureRegistry
[10:21:46.974] result() for ClusterFuture ...
[10:21:46.974] - result already collected: FutureResult
[10:21:46.974] result() for ClusterFuture ... done
[10:21:46.974] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:46.974] result() for ClusterFuture ... done
[10:21:46.974] result() for ClusterFuture ...
[10:21:46.974] - result already collected: FutureResult
[10:21:46.974] result() for ClusterFuture ... done
[10:21:46.974] result() for ClusterFuture ...
[10:21:46.975] receiveMessageFromWorker() for ClusterFuture ...
[10:21:46.975] - Validating connection of MultisessionFuture
[10:21:47.014] - received message: FutureResult
[10:21:47.014] - Received FutureResult
[10:21:47.014] - Erased future from FutureRegistry
[10:21:47.015] result() for ClusterFuture ...
[10:21:47.015] - result already collected: FutureResult
[10:21:47.015] result() for ClusterFuture ... done
[10:21:47.015] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.015] result() for ClusterFuture ... done
[10:21:47.015] result() for ClusterFuture ...
[10:21:47.015] - result already collected: FutureResult
[10:21:47.015] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.016] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.016] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.018] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:47.018] Searching for globals ... DONE
[10:21:47.018] Resolving globals: TRUE
[10:21:47.018] Resolving any globals that are futures ...
[10:21:47.019] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:47.019] Resolving any globals that are futures ... DONE
[10:21:47.019] Resolving futures part of globals (recursively) ...
[10:21:47.019] resolve() on list ...
[10:21:47.019]  recursive: 99
[10:21:47.019]  length: 2
[10:21:47.020]  elements: ‘a’, ‘ii’
[10:21:47.020]  length: 1 (resolved future 1)
[10:21:47.020]  length: 0 (resolved future 2)
[10:21:47.020] resolve() on list ... DONE
[10:21:47.020] - globals: [2] ‘a’, ‘ii’
[10:21:47.020] Resolving futures part of globals (recursively) ... DONE
[10:21:47.020] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:47.021] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:47.021] - globals: [2] ‘a’, ‘ii’
[10:21:47.021] 
[10:21:47.021] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.021] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.022] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.023] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:47.024] Searching for globals ... DONE
[10:21:47.024] Resolving globals: TRUE
[10:21:47.024] Resolving any globals that are futures ...
[10:21:47.024] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:47.024] Resolving any globals that are futures ... DONE
[10:21:47.024] Resolving futures part of globals (recursively) ...
[10:21:47.025] resolve() on list ...
[10:21:47.025]  recursive: 99
[10:21:47.025]  length: 2
[10:21:47.025]  elements: ‘a’, ‘ii’
[10:21:47.025]  length: 1 (resolved future 1)
[10:21:47.025]  length: 0 (resolved future 2)
[10:21:47.025] resolve() on list ... DONE
[10:21:47.025] - globals: [2] ‘a’, ‘ii’
[10:21:47.025] Resolving futures part of globals (recursively) ... DONE
[10:21:47.025] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:47.026] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:47.026] - globals: [2] ‘a’, ‘ii’
[10:21:47.026] 
[10:21:47.026] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.027] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.027] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.029] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:47.029] Searching for globals ... DONE
[10:21:47.029] Resolving globals: TRUE
[10:21:47.029] Resolving any globals that are futures ...
[10:21:47.029] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[10:21:47.029] Resolving any globals that are futures ... DONE
[10:21:47.029] Resolving futures part of globals (recursively) ...
[10:21:47.030] resolve() on list ...
[10:21:47.030]  recursive: 99
[10:21:47.030]  length: 2
[10:21:47.030]  elements: ‘a’, ‘ii’
[10:21:47.030]  length: 1 (resolved future 1)
[10:21:47.030]  length: 0 (resolved future 2)
[10:21:47.030] resolve() on list ... DONE
[10:21:47.030] - globals: [2] ‘a’, ‘ii’
[10:21:47.030] Resolving futures part of globals (recursively) ... DONE
[10:21:47.031] The total size of the 2 globals is 74 bytes (74 bytes)
[10:21:47.031] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[10:21:47.031] - globals: [2] ‘a’, ‘ii’
[10:21:47.031] 
[10:21:47.031] getGlobalsAndPackages() ... DONE
[10:21:47.031] run() for ‘Future’ ...
[10:21:47.032] - state: ‘created’
[10:21:47.032] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.045] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.046] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.046]   - Field: ‘node’
[10:21:47.046]   - Field: ‘label’
[10:21:47.046]   - Field: ‘local’
[10:21:47.046]   - Field: ‘owner’
[10:21:47.046]   - Field: ‘envir’
[10:21:47.046]   - Field: ‘workers’
[10:21:47.046]   - Field: ‘packages’
[10:21:47.046]   - Field: ‘gc’
[10:21:47.046]   - Field: ‘conditions’
[10:21:47.047]   - Field: ‘persistent’
[10:21:47.047]   - Field: ‘expr’
[10:21:47.047]   - Field: ‘uuid’
[10:21:47.047]   - Field: ‘seed’
[10:21:47.047]   - Field: ‘version’
[10:21:47.047]   - Field: ‘result’
[10:21:47.047]   - Field: ‘asynchronous’
[10:21:47.047]   - Field: ‘calls’
[10:21:47.047]   - Field: ‘globals’
[10:21:47.047]   - Field: ‘stdout’
[10:21:47.047]   - Field: ‘earlySignal’
[10:21:47.048]   - Field: ‘lazy’
[10:21:47.048]   - Field: ‘state’
[10:21:47.048] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.048] - Launch lazy future ...
[10:21:47.048] Packages needed by the future expression (n = 0): <none>
[10:21:47.048] Packages needed by future strategies (n = 0): <none>
[10:21:47.049] {
[10:21:47.049]     {
[10:21:47.049]         {
[10:21:47.049]             ...future.startTime <- base::Sys.time()
[10:21:47.049]             {
[10:21:47.049]                 {
[10:21:47.049]                   {
[10:21:47.049]                     {
[10:21:47.049]                       base::local({
[10:21:47.049]                         has_future <- base::requireNamespace("future", 
[10:21:47.049]                           quietly = TRUE)
[10:21:47.049]                         if (has_future) {
[10:21:47.049]                           ns <- base::getNamespace("future")
[10:21:47.049]                           version <- ns[[".package"]][["version"]]
[10:21:47.049]                           if (is.null(version)) 
[10:21:47.049]                             version <- utils::packageVersion("future")
[10:21:47.049]                         }
[10:21:47.049]                         else {
[10:21:47.049]                           version <- NULL
[10:21:47.049]                         }
[10:21:47.049]                         if (!has_future || version < "1.8.0") {
[10:21:47.049]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.049]                             "", base::R.version$version.string), 
[10:21:47.049]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:47.049]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:47.049]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.049]                               "release", "version")], collapse = " "), 
[10:21:47.049]                             hostname = base::Sys.info()[["nodename"]])
[10:21:47.049]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.049]                             info)
[10:21:47.049]                           info <- base::paste(info, collapse = "; ")
[10:21:47.049]                           if (!has_future) {
[10:21:47.049]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.049]                               info)
[10:21:47.049]                           }
[10:21:47.049]                           else {
[10:21:47.049]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.049]                               info, version)
[10:21:47.049]                           }
[10:21:47.049]                           base::stop(msg)
[10:21:47.049]                         }
[10:21:47.049]                       })
[10:21:47.049]                     }
[10:21:47.049]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.049]                     base::options(mc.cores = 1L)
[10:21:47.049]                   }
[10:21:47.049]                   ...future.strategy.old <- future::plan("list")
[10:21:47.049]                   options(future.plan = NULL)
[10:21:47.049]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.049]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.049]                 }
[10:21:47.049]                 ...future.workdir <- getwd()
[10:21:47.049]             }
[10:21:47.049]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.049]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.049]         }
[10:21:47.049]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.049]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.049]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.049]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.049]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.049]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.049]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.049]             base::names(...future.oldOptions))
[10:21:47.049]     }
[10:21:47.049]     if (FALSE) {
[10:21:47.049]     }
[10:21:47.049]     else {
[10:21:47.049]         if (TRUE) {
[10:21:47.049]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.049]                 open = "w")
[10:21:47.049]         }
[10:21:47.049]         else {
[10:21:47.049]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.049]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.049]         }
[10:21:47.049]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.049]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.049]             base::sink(type = "output", split = FALSE)
[10:21:47.049]             base::close(...future.stdout)
[10:21:47.049]         }, add = TRUE)
[10:21:47.049]     }
[10:21:47.049]     ...future.frame <- base::sys.nframe()
[10:21:47.049]     ...future.conditions <- base::list()
[10:21:47.049]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.049]     if (FALSE) {
[10:21:47.049]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.049]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.049]     }
[10:21:47.049]     ...future.result <- base::tryCatch({
[10:21:47.049]         base::withCallingHandlers({
[10:21:47.049]             ...future.value <- base::withVisible(base::local({
[10:21:47.049]                 ...future.makeSendCondition <- base::local({
[10:21:47.049]                   sendCondition <- NULL
[10:21:47.049]                   function(frame = 1L) {
[10:21:47.049]                     if (is.function(sendCondition)) 
[10:21:47.049]                       return(sendCondition)
[10:21:47.049]                     ns <- getNamespace("parallel")
[10:21:47.049]                     if (exists("sendData", mode = "function", 
[10:21:47.049]                       envir = ns)) {
[10:21:47.049]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.049]                         envir = ns)
[10:21:47.049]                       envir <- sys.frame(frame)
[10:21:47.049]                       master <- NULL
[10:21:47.049]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.049]                         !identical(envir, emptyenv())) {
[10:21:47.049]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.049]                           inherits = FALSE)) {
[10:21:47.049]                           master <- get("master", mode = "list", 
[10:21:47.049]                             envir = envir, inherits = FALSE)
[10:21:47.049]                           if (inherits(master, c("SOCKnode", 
[10:21:47.049]                             "SOCK0node"))) {
[10:21:47.049]                             sendCondition <<- function(cond) {
[10:21:47.049]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.049]                                 success = TRUE)
[10:21:47.049]                               parallel_sendData(master, data)
[10:21:47.049]                             }
[10:21:47.049]                             return(sendCondition)
[10:21:47.049]                           }
[10:21:47.049]                         }
[10:21:47.049]                         frame <- frame + 1L
[10:21:47.049]                         envir <- sys.frame(frame)
[10:21:47.049]                       }
[10:21:47.049]                     }
[10:21:47.049]                     sendCondition <<- function(cond) NULL
[10:21:47.049]                   }
[10:21:47.049]                 })
[10:21:47.049]                 withCallingHandlers({
[10:21:47.049]                   {
[10:21:47.049]                     b <- a * ii
[10:21:47.049]                     a <- 0
[10:21:47.049]                     b
[10:21:47.049]                   }
[10:21:47.049]                 }, immediateCondition = function(cond) {
[10:21:47.049]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.049]                   sendCondition(cond)
[10:21:47.049]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.049]                   {
[10:21:47.049]                     inherits <- base::inherits
[10:21:47.049]                     invokeRestart <- base::invokeRestart
[10:21:47.049]                     is.null <- base::is.null
[10:21:47.049]                     muffled <- FALSE
[10:21:47.049]                     if (inherits(cond, "message")) {
[10:21:47.049]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.049]                       if (muffled) 
[10:21:47.049]                         invokeRestart("muffleMessage")
[10:21:47.049]                     }
[10:21:47.049]                     else if (inherits(cond, "warning")) {
[10:21:47.049]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.049]                       if (muffled) 
[10:21:47.049]                         invokeRestart("muffleWarning")
[10:21:47.049]                     }
[10:21:47.049]                     else if (inherits(cond, "condition")) {
[10:21:47.049]                       if (!is.null(pattern)) {
[10:21:47.049]                         computeRestarts <- base::computeRestarts
[10:21:47.049]                         grepl <- base::grepl
[10:21:47.049]                         restarts <- computeRestarts(cond)
[10:21:47.049]                         for (restart in restarts) {
[10:21:47.049]                           name <- restart$name
[10:21:47.049]                           if (is.null(name)) 
[10:21:47.049]                             next
[10:21:47.049]                           if (!grepl(pattern, name)) 
[10:21:47.049]                             next
[10:21:47.049]                           invokeRestart(restart)
[10:21:47.049]                           muffled <- TRUE
[10:21:47.049]                           break
[10:21:47.049]                         }
[10:21:47.049]                       }
[10:21:47.049]                     }
[10:21:47.049]                     invisible(muffled)
[10:21:47.049]                   }
[10:21:47.049]                   muffleCondition(cond)
[10:21:47.049]                 })
[10:21:47.049]             }))
[10:21:47.049]             future::FutureResult(value = ...future.value$value, 
[10:21:47.049]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.049]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.049]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.049]                     ...future.globalenv.names))
[10:21:47.049]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.049]         }, condition = base::local({
[10:21:47.049]             c <- base::c
[10:21:47.049]             inherits <- base::inherits
[10:21:47.049]             invokeRestart <- base::invokeRestart
[10:21:47.049]             length <- base::length
[10:21:47.049]             list <- base::list
[10:21:47.049]             seq.int <- base::seq.int
[10:21:47.049]             signalCondition <- base::signalCondition
[10:21:47.049]             sys.calls <- base::sys.calls
[10:21:47.049]             `[[` <- base::`[[`
[10:21:47.049]             `+` <- base::`+`
[10:21:47.049]             `<<-` <- base::`<<-`
[10:21:47.049]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.049]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.049]                   3L)]
[10:21:47.049]             }
[10:21:47.049]             function(cond) {
[10:21:47.049]                 is_error <- inherits(cond, "error")
[10:21:47.049]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.049]                   NULL)
[10:21:47.049]                 if (is_error) {
[10:21:47.049]                   sessionInformation <- function() {
[10:21:47.049]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.049]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.049]                       search = base::search(), system = base::Sys.info())
[10:21:47.049]                   }
[10:21:47.049]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.049]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.049]                     cond$call), session = sessionInformation(), 
[10:21:47.049]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.049]                   signalCondition(cond)
[10:21:47.049]                 }
[10:21:47.049]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.049]                 "immediateCondition"))) {
[10:21:47.049]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.049]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.049]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.049]                   if (TRUE && !signal) {
[10:21:47.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.049]                     {
[10:21:47.049]                       inherits <- base::inherits
[10:21:47.049]                       invokeRestart <- base::invokeRestart
[10:21:47.049]                       is.null <- base::is.null
[10:21:47.049]                       muffled <- FALSE
[10:21:47.049]                       if (inherits(cond, "message")) {
[10:21:47.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.049]                         if (muffled) 
[10:21:47.049]                           invokeRestart("muffleMessage")
[10:21:47.049]                       }
[10:21:47.049]                       else if (inherits(cond, "warning")) {
[10:21:47.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.049]                         if (muffled) 
[10:21:47.049]                           invokeRestart("muffleWarning")
[10:21:47.049]                       }
[10:21:47.049]                       else if (inherits(cond, "condition")) {
[10:21:47.049]                         if (!is.null(pattern)) {
[10:21:47.049]                           computeRestarts <- base::computeRestarts
[10:21:47.049]                           grepl <- base::grepl
[10:21:47.049]                           restarts <- computeRestarts(cond)
[10:21:47.049]                           for (restart in restarts) {
[10:21:47.049]                             name <- restart$name
[10:21:47.049]                             if (is.null(name)) 
[10:21:47.049]                               next
[10:21:47.049]                             if (!grepl(pattern, name)) 
[10:21:47.049]                               next
[10:21:47.049]                             invokeRestart(restart)
[10:21:47.049]                             muffled <- TRUE
[10:21:47.049]                             break
[10:21:47.049]                           }
[10:21:47.049]                         }
[10:21:47.049]                       }
[10:21:47.049]                       invisible(muffled)
[10:21:47.049]                     }
[10:21:47.049]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.049]                   }
[10:21:47.049]                 }
[10:21:47.049]                 else {
[10:21:47.049]                   if (TRUE) {
[10:21:47.049]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.049]                     {
[10:21:47.049]                       inherits <- base::inherits
[10:21:47.049]                       invokeRestart <- base::invokeRestart
[10:21:47.049]                       is.null <- base::is.null
[10:21:47.049]                       muffled <- FALSE
[10:21:47.049]                       if (inherits(cond, "message")) {
[10:21:47.049]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.049]                         if (muffled) 
[10:21:47.049]                           invokeRestart("muffleMessage")
[10:21:47.049]                       }
[10:21:47.049]                       else if (inherits(cond, "warning")) {
[10:21:47.049]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.049]                         if (muffled) 
[10:21:47.049]                           invokeRestart("muffleWarning")
[10:21:47.049]                       }
[10:21:47.049]                       else if (inherits(cond, "condition")) {
[10:21:47.049]                         if (!is.null(pattern)) {
[10:21:47.049]                           computeRestarts <- base::computeRestarts
[10:21:47.049]                           grepl <- base::grepl
[10:21:47.049]                           restarts <- computeRestarts(cond)
[10:21:47.049]                           for (restart in restarts) {
[10:21:47.049]                             name <- restart$name
[10:21:47.049]                             if (is.null(name)) 
[10:21:47.049]                               next
[10:21:47.049]                             if (!grepl(pattern, name)) 
[10:21:47.049]                               next
[10:21:47.049]                             invokeRestart(restart)
[10:21:47.049]                             muffled <- TRUE
[10:21:47.049]                             break
[10:21:47.049]                           }
[10:21:47.049]                         }
[10:21:47.049]                       }
[10:21:47.049]                       invisible(muffled)
[10:21:47.049]                     }
[10:21:47.049]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.049]                   }
[10:21:47.049]                 }
[10:21:47.049]             }
[10:21:47.049]         }))
[10:21:47.049]     }, error = function(ex) {
[10:21:47.049]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.049]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.049]                 ...future.rng), started = ...future.startTime, 
[10:21:47.049]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.049]             version = "1.8"), class = "FutureResult")
[10:21:47.049]     }, finally = {
[10:21:47.049]         if (!identical(...future.workdir, getwd())) 
[10:21:47.049]             setwd(...future.workdir)
[10:21:47.049]         {
[10:21:47.049]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.049]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.049]             }
[10:21:47.049]             base::options(...future.oldOptions)
[10:21:47.049]             if (.Platform$OS.type == "windows") {
[10:21:47.049]                 old_names <- names(...future.oldEnvVars)
[10:21:47.049]                 envs <- base::Sys.getenv()
[10:21:47.049]                 names <- names(envs)
[10:21:47.049]                 common <- intersect(names, old_names)
[10:21:47.049]                 added <- setdiff(names, old_names)
[10:21:47.049]                 removed <- setdiff(old_names, names)
[10:21:47.049]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.049]                   envs[common]]
[10:21:47.049]                 NAMES <- toupper(changed)
[10:21:47.049]                 args <- list()
[10:21:47.049]                 for (kk in seq_along(NAMES)) {
[10:21:47.049]                   name <- changed[[kk]]
[10:21:47.049]                   NAME <- NAMES[[kk]]
[10:21:47.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.049]                     next
[10:21:47.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.049]                 }
[10:21:47.049]                 NAMES <- toupper(added)
[10:21:47.049]                 for (kk in seq_along(NAMES)) {
[10:21:47.049]                   name <- added[[kk]]
[10:21:47.049]                   NAME <- NAMES[[kk]]
[10:21:47.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.049]                     next
[10:21:47.049]                   args[[name]] <- ""
[10:21:47.049]                 }
[10:21:47.049]                 NAMES <- toupper(removed)
[10:21:47.049]                 for (kk in seq_along(NAMES)) {
[10:21:47.049]                   name <- removed[[kk]]
[10:21:47.049]                   NAME <- NAMES[[kk]]
[10:21:47.049]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.049]                     next
[10:21:47.049]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.049]                 }
[10:21:47.049]                 if (length(args) > 0) 
[10:21:47.049]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.049]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.049]             }
[10:21:47.049]             else {
[10:21:47.049]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.049]             }
[10:21:47.049]             {
[10:21:47.049]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.049]                   0L) {
[10:21:47.049]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.049]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.049]                   base::options(opts)
[10:21:47.049]                 }
[10:21:47.049]                 {
[10:21:47.049]                   {
[10:21:47.049]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.049]                     NULL
[10:21:47.049]                   }
[10:21:47.049]                   options(future.plan = NULL)
[10:21:47.049]                   if (is.na(NA_character_)) 
[10:21:47.049]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.049]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.049]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.049]                     .init = FALSE)
[10:21:47.049]                 }
[10:21:47.049]             }
[10:21:47.049]         }
[10:21:47.049]     })
[10:21:47.049]     if (TRUE) {
[10:21:47.049]         base::sink(type = "output", split = FALSE)
[10:21:47.049]         if (TRUE) {
[10:21:47.049]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.049]         }
[10:21:47.049]         else {
[10:21:47.049]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.049]         }
[10:21:47.049]         base::close(...future.stdout)
[10:21:47.049]         ...future.stdout <- NULL
[10:21:47.049]     }
[10:21:47.049]     ...future.result$conditions <- ...future.conditions
[10:21:47.049]     ...future.result$finished <- base::Sys.time()
[10:21:47.049]     ...future.result
[10:21:47.049] }
[10:21:47.051] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[10:21:47.052] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:47.052] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:47.052] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:47.052] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:47.052] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[10:21:47.053] MultisessionFuture started
[10:21:47.053] - Launch lazy future ... done
[10:21:47.053] run() for ‘MultisessionFuture’ ... done
[10:21:47.053] result() for ClusterFuture ...
[10:21:47.053] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.053] - Validating connection of MultisessionFuture
[10:21:47.095] - received message: FutureResult
[10:21:47.095] - Received FutureResult
[10:21:47.095] - Erased future from FutureRegistry
[10:21:47.095] result() for ClusterFuture ...
[10:21:47.096] - result already collected: FutureResult
[10:21:47.096] result() for ClusterFuture ... done
[10:21:47.096] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.096] result() for ClusterFuture ... done
[10:21:47.096] result() for ClusterFuture ...
[10:21:47.096] - result already collected: FutureResult
[10:21:47.096] result() for ClusterFuture ... done
[10:21:47.096] run() for ‘Future’ ...
[10:21:47.096] - state: ‘created’
[10:21:47.096] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.110] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.111] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.111]   - Field: ‘node’
[10:21:47.111]   - Field: ‘label’
[10:21:47.111]   - Field: ‘local’
[10:21:47.111]   - Field: ‘owner’
[10:21:47.111]   - Field: ‘envir’
[10:21:47.111]   - Field: ‘workers’
[10:21:47.111]   - Field: ‘packages’
[10:21:47.111]   - Field: ‘gc’
[10:21:47.111]   - Field: ‘conditions’
[10:21:47.111]   - Field: ‘persistent’
[10:21:47.112]   - Field: ‘expr’
[10:21:47.112]   - Field: ‘uuid’
[10:21:47.112]   - Field: ‘seed’
[10:21:47.112]   - Field: ‘version’
[10:21:47.112]   - Field: ‘result’
[10:21:47.112]   - Field: ‘asynchronous’
[10:21:47.112]   - Field: ‘calls’
[10:21:47.112]   - Field: ‘globals’
[10:21:47.112]   - Field: ‘stdout’
[10:21:47.112]   - Field: ‘earlySignal’
[10:21:47.112]   - Field: ‘lazy’
[10:21:47.112]   - Field: ‘state’
[10:21:47.113] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.113] - Launch lazy future ...
[10:21:47.113] Packages needed by the future expression (n = 0): <none>
[10:21:47.113] Packages needed by future strategies (n = 0): <none>
[10:21:47.113] {
[10:21:47.113]     {
[10:21:47.113]         {
[10:21:47.113]             ...future.startTime <- base::Sys.time()
[10:21:47.113]             {
[10:21:47.113]                 {
[10:21:47.113]                   {
[10:21:47.113]                     {
[10:21:47.113]                       base::local({
[10:21:47.113]                         has_future <- base::requireNamespace("future", 
[10:21:47.113]                           quietly = TRUE)
[10:21:47.113]                         if (has_future) {
[10:21:47.113]                           ns <- base::getNamespace("future")
[10:21:47.113]                           version <- ns[[".package"]][["version"]]
[10:21:47.113]                           if (is.null(version)) 
[10:21:47.113]                             version <- utils::packageVersion("future")
[10:21:47.113]                         }
[10:21:47.113]                         else {
[10:21:47.113]                           version <- NULL
[10:21:47.113]                         }
[10:21:47.113]                         if (!has_future || version < "1.8.0") {
[10:21:47.113]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.113]                             "", base::R.version$version.string), 
[10:21:47.113]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:47.113]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:47.113]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.113]                               "release", "version")], collapse = " "), 
[10:21:47.113]                             hostname = base::Sys.info()[["nodename"]])
[10:21:47.113]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.113]                             info)
[10:21:47.113]                           info <- base::paste(info, collapse = "; ")
[10:21:47.113]                           if (!has_future) {
[10:21:47.113]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.113]                               info)
[10:21:47.113]                           }
[10:21:47.113]                           else {
[10:21:47.113]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.113]                               info, version)
[10:21:47.113]                           }
[10:21:47.113]                           base::stop(msg)
[10:21:47.113]                         }
[10:21:47.113]                       })
[10:21:47.113]                     }
[10:21:47.113]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.113]                     base::options(mc.cores = 1L)
[10:21:47.113]                   }
[10:21:47.113]                   ...future.strategy.old <- future::plan("list")
[10:21:47.113]                   options(future.plan = NULL)
[10:21:47.113]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.113]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.113]                 }
[10:21:47.113]                 ...future.workdir <- getwd()
[10:21:47.113]             }
[10:21:47.113]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.113]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.113]         }
[10:21:47.113]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.113]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.113]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.113]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.113]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.113]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.113]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.113]             base::names(...future.oldOptions))
[10:21:47.113]     }
[10:21:47.113]     if (FALSE) {
[10:21:47.113]     }
[10:21:47.113]     else {
[10:21:47.113]         if (TRUE) {
[10:21:47.113]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.113]                 open = "w")
[10:21:47.113]         }
[10:21:47.113]         else {
[10:21:47.113]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.113]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.113]         }
[10:21:47.113]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.113]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.113]             base::sink(type = "output", split = FALSE)
[10:21:47.113]             base::close(...future.stdout)
[10:21:47.113]         }, add = TRUE)
[10:21:47.113]     }
[10:21:47.113]     ...future.frame <- base::sys.nframe()
[10:21:47.113]     ...future.conditions <- base::list()
[10:21:47.113]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.113]     if (FALSE) {
[10:21:47.113]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.113]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.113]     }
[10:21:47.113]     ...future.result <- base::tryCatch({
[10:21:47.113]         base::withCallingHandlers({
[10:21:47.113]             ...future.value <- base::withVisible(base::local({
[10:21:47.113]                 ...future.makeSendCondition <- base::local({
[10:21:47.113]                   sendCondition <- NULL
[10:21:47.113]                   function(frame = 1L) {
[10:21:47.113]                     if (is.function(sendCondition)) 
[10:21:47.113]                       return(sendCondition)
[10:21:47.113]                     ns <- getNamespace("parallel")
[10:21:47.113]                     if (exists("sendData", mode = "function", 
[10:21:47.113]                       envir = ns)) {
[10:21:47.113]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.113]                         envir = ns)
[10:21:47.113]                       envir <- sys.frame(frame)
[10:21:47.113]                       master <- NULL
[10:21:47.113]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.113]                         !identical(envir, emptyenv())) {
[10:21:47.113]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.113]                           inherits = FALSE)) {
[10:21:47.113]                           master <- get("master", mode = "list", 
[10:21:47.113]                             envir = envir, inherits = FALSE)
[10:21:47.113]                           if (inherits(master, c("SOCKnode", 
[10:21:47.113]                             "SOCK0node"))) {
[10:21:47.113]                             sendCondition <<- function(cond) {
[10:21:47.113]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.113]                                 success = TRUE)
[10:21:47.113]                               parallel_sendData(master, data)
[10:21:47.113]                             }
[10:21:47.113]                             return(sendCondition)
[10:21:47.113]                           }
[10:21:47.113]                         }
[10:21:47.113]                         frame <- frame + 1L
[10:21:47.113]                         envir <- sys.frame(frame)
[10:21:47.113]                       }
[10:21:47.113]                     }
[10:21:47.113]                     sendCondition <<- function(cond) NULL
[10:21:47.113]                   }
[10:21:47.113]                 })
[10:21:47.113]                 withCallingHandlers({
[10:21:47.113]                   {
[10:21:47.113]                     b <- a * ii
[10:21:47.113]                     a <- 0
[10:21:47.113]                     b
[10:21:47.113]                   }
[10:21:47.113]                 }, immediateCondition = function(cond) {
[10:21:47.113]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.113]                   sendCondition(cond)
[10:21:47.113]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.113]                   {
[10:21:47.113]                     inherits <- base::inherits
[10:21:47.113]                     invokeRestart <- base::invokeRestart
[10:21:47.113]                     is.null <- base::is.null
[10:21:47.113]                     muffled <- FALSE
[10:21:47.113]                     if (inherits(cond, "message")) {
[10:21:47.113]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.113]                       if (muffled) 
[10:21:47.113]                         invokeRestart("muffleMessage")
[10:21:47.113]                     }
[10:21:47.113]                     else if (inherits(cond, "warning")) {
[10:21:47.113]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.113]                       if (muffled) 
[10:21:47.113]                         invokeRestart("muffleWarning")
[10:21:47.113]                     }
[10:21:47.113]                     else if (inherits(cond, "condition")) {
[10:21:47.113]                       if (!is.null(pattern)) {
[10:21:47.113]                         computeRestarts <- base::computeRestarts
[10:21:47.113]                         grepl <- base::grepl
[10:21:47.113]                         restarts <- computeRestarts(cond)
[10:21:47.113]                         for (restart in restarts) {
[10:21:47.113]                           name <- restart$name
[10:21:47.113]                           if (is.null(name)) 
[10:21:47.113]                             next
[10:21:47.113]                           if (!grepl(pattern, name)) 
[10:21:47.113]                             next
[10:21:47.113]                           invokeRestart(restart)
[10:21:47.113]                           muffled <- TRUE
[10:21:47.113]                           break
[10:21:47.113]                         }
[10:21:47.113]                       }
[10:21:47.113]                     }
[10:21:47.113]                     invisible(muffled)
[10:21:47.113]                   }
[10:21:47.113]                   muffleCondition(cond)
[10:21:47.113]                 })
[10:21:47.113]             }))
[10:21:47.113]             future::FutureResult(value = ...future.value$value, 
[10:21:47.113]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.113]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.113]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.113]                     ...future.globalenv.names))
[10:21:47.113]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.113]         }, condition = base::local({
[10:21:47.113]             c <- base::c
[10:21:47.113]             inherits <- base::inherits
[10:21:47.113]             invokeRestart <- base::invokeRestart
[10:21:47.113]             length <- base::length
[10:21:47.113]             list <- base::list
[10:21:47.113]             seq.int <- base::seq.int
[10:21:47.113]             signalCondition <- base::signalCondition
[10:21:47.113]             sys.calls <- base::sys.calls
[10:21:47.113]             `[[` <- base::`[[`
[10:21:47.113]             `+` <- base::`+`
[10:21:47.113]             `<<-` <- base::`<<-`
[10:21:47.113]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.113]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.113]                   3L)]
[10:21:47.113]             }
[10:21:47.113]             function(cond) {
[10:21:47.113]                 is_error <- inherits(cond, "error")
[10:21:47.113]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.113]                   NULL)
[10:21:47.113]                 if (is_error) {
[10:21:47.113]                   sessionInformation <- function() {
[10:21:47.113]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.113]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.113]                       search = base::search(), system = base::Sys.info())
[10:21:47.113]                   }
[10:21:47.113]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.113]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.113]                     cond$call), session = sessionInformation(), 
[10:21:47.113]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.113]                   signalCondition(cond)
[10:21:47.113]                 }
[10:21:47.113]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.113]                 "immediateCondition"))) {
[10:21:47.113]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.113]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.113]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.113]                   if (TRUE && !signal) {
[10:21:47.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.113]                     {
[10:21:47.113]                       inherits <- base::inherits
[10:21:47.113]                       invokeRestart <- base::invokeRestart
[10:21:47.113]                       is.null <- base::is.null
[10:21:47.113]                       muffled <- FALSE
[10:21:47.113]                       if (inherits(cond, "message")) {
[10:21:47.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.113]                         if (muffled) 
[10:21:47.113]                           invokeRestart("muffleMessage")
[10:21:47.113]                       }
[10:21:47.113]                       else if (inherits(cond, "warning")) {
[10:21:47.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.113]                         if (muffled) 
[10:21:47.113]                           invokeRestart("muffleWarning")
[10:21:47.113]                       }
[10:21:47.113]                       else if (inherits(cond, "condition")) {
[10:21:47.113]                         if (!is.null(pattern)) {
[10:21:47.113]                           computeRestarts <- base::computeRestarts
[10:21:47.113]                           grepl <- base::grepl
[10:21:47.113]                           restarts <- computeRestarts(cond)
[10:21:47.113]                           for (restart in restarts) {
[10:21:47.113]                             name <- restart$name
[10:21:47.113]                             if (is.null(name)) 
[10:21:47.113]                               next
[10:21:47.113]                             if (!grepl(pattern, name)) 
[10:21:47.113]                               next
[10:21:47.113]                             invokeRestart(restart)
[10:21:47.113]                             muffled <- TRUE
[10:21:47.113]                             break
[10:21:47.113]                           }
[10:21:47.113]                         }
[10:21:47.113]                       }
[10:21:47.113]                       invisible(muffled)
[10:21:47.113]                     }
[10:21:47.113]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.113]                   }
[10:21:47.113]                 }
[10:21:47.113]                 else {
[10:21:47.113]                   if (TRUE) {
[10:21:47.113]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.113]                     {
[10:21:47.113]                       inherits <- base::inherits
[10:21:47.113]                       invokeRestart <- base::invokeRestart
[10:21:47.113]                       is.null <- base::is.null
[10:21:47.113]                       muffled <- FALSE
[10:21:47.113]                       if (inherits(cond, "message")) {
[10:21:47.113]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.113]                         if (muffled) 
[10:21:47.113]                           invokeRestart("muffleMessage")
[10:21:47.113]                       }
[10:21:47.113]                       else if (inherits(cond, "warning")) {
[10:21:47.113]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.113]                         if (muffled) 
[10:21:47.113]                           invokeRestart("muffleWarning")
[10:21:47.113]                       }
[10:21:47.113]                       else if (inherits(cond, "condition")) {
[10:21:47.113]                         if (!is.null(pattern)) {
[10:21:47.113]                           computeRestarts <- base::computeRestarts
[10:21:47.113]                           grepl <- base::grepl
[10:21:47.113]                           restarts <- computeRestarts(cond)
[10:21:47.113]                           for (restart in restarts) {
[10:21:47.113]                             name <- restart$name
[10:21:47.113]                             if (is.null(name)) 
[10:21:47.113]                               next
[10:21:47.113]                             if (!grepl(pattern, name)) 
[10:21:47.113]                               next
[10:21:47.113]                             invokeRestart(restart)
[10:21:47.113]                             muffled <- TRUE
[10:21:47.113]                             break
[10:21:47.113]                           }
[10:21:47.113]                         }
[10:21:47.113]                       }
[10:21:47.113]                       invisible(muffled)
[10:21:47.113]                     }
[10:21:47.113]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.113]                   }
[10:21:47.113]                 }
[10:21:47.113]             }
[10:21:47.113]         }))
[10:21:47.113]     }, error = function(ex) {
[10:21:47.113]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.113]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.113]                 ...future.rng), started = ...future.startTime, 
[10:21:47.113]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.113]             version = "1.8"), class = "FutureResult")
[10:21:47.113]     }, finally = {
[10:21:47.113]         if (!identical(...future.workdir, getwd())) 
[10:21:47.113]             setwd(...future.workdir)
[10:21:47.113]         {
[10:21:47.113]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.113]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.113]             }
[10:21:47.113]             base::options(...future.oldOptions)
[10:21:47.113]             if (.Platform$OS.type == "windows") {
[10:21:47.113]                 old_names <- names(...future.oldEnvVars)
[10:21:47.113]                 envs <- base::Sys.getenv()
[10:21:47.113]                 names <- names(envs)
[10:21:47.113]                 common <- intersect(names, old_names)
[10:21:47.113]                 added <- setdiff(names, old_names)
[10:21:47.113]                 removed <- setdiff(old_names, names)
[10:21:47.113]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.113]                   envs[common]]
[10:21:47.113]                 NAMES <- toupper(changed)
[10:21:47.113]                 args <- list()
[10:21:47.113]                 for (kk in seq_along(NAMES)) {
[10:21:47.113]                   name <- changed[[kk]]
[10:21:47.113]                   NAME <- NAMES[[kk]]
[10:21:47.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.113]                     next
[10:21:47.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.113]                 }
[10:21:47.113]                 NAMES <- toupper(added)
[10:21:47.113]                 for (kk in seq_along(NAMES)) {
[10:21:47.113]                   name <- added[[kk]]
[10:21:47.113]                   NAME <- NAMES[[kk]]
[10:21:47.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.113]                     next
[10:21:47.113]                   args[[name]] <- ""
[10:21:47.113]                 }
[10:21:47.113]                 NAMES <- toupper(removed)
[10:21:47.113]                 for (kk in seq_along(NAMES)) {
[10:21:47.113]                   name <- removed[[kk]]
[10:21:47.113]                   NAME <- NAMES[[kk]]
[10:21:47.113]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.113]                     next
[10:21:47.113]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.113]                 }
[10:21:47.113]                 if (length(args) > 0) 
[10:21:47.113]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.113]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.113]             }
[10:21:47.113]             else {
[10:21:47.113]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.113]             }
[10:21:47.113]             {
[10:21:47.113]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.113]                   0L) {
[10:21:47.113]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.113]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.113]                   base::options(opts)
[10:21:47.113]                 }
[10:21:47.113]                 {
[10:21:47.113]                   {
[10:21:47.113]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.113]                     NULL
[10:21:47.113]                   }
[10:21:47.113]                   options(future.plan = NULL)
[10:21:47.113]                   if (is.na(NA_character_)) 
[10:21:47.113]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.113]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.113]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.113]                     .init = FALSE)
[10:21:47.113]                 }
[10:21:47.113]             }
[10:21:47.113]         }
[10:21:47.113]     })
[10:21:47.113]     if (TRUE) {
[10:21:47.113]         base::sink(type = "output", split = FALSE)
[10:21:47.113]         if (TRUE) {
[10:21:47.113]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.113]         }
[10:21:47.113]         else {
[10:21:47.113]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.113]         }
[10:21:47.113]         base::close(...future.stdout)
[10:21:47.113]         ...future.stdout <- NULL
[10:21:47.113]     }
[10:21:47.113]     ...future.result$conditions <- ...future.conditions
[10:21:47.113]     ...future.result$finished <- base::Sys.time()
[10:21:47.113]     ...future.result
[10:21:47.113] }
[10:21:47.116] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[10:21:47.116] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:47.117] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:47.117] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:47.117] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:47.117] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[10:21:47.118] MultisessionFuture started
[10:21:47.118] - Launch lazy future ... done
[10:21:47.118] run() for ‘MultisessionFuture’ ... done
[10:21:47.118] result() for ClusterFuture ...
[10:21:47.118] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.118] - Validating connection of MultisessionFuture
[10:21:47.160] - received message: FutureResult
[10:21:47.160] - Received FutureResult
[10:21:47.161] - Erased future from FutureRegistry
[10:21:47.161] result() for ClusterFuture ...
[10:21:47.161] - result already collected: FutureResult
[10:21:47.161] result() for ClusterFuture ... done
[10:21:47.161] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.161] result() for ClusterFuture ... done
[10:21:47.161] result() for ClusterFuture ...
[10:21:47.161] - result already collected: FutureResult
[10:21:47.161] result() for ClusterFuture ... done
[10:21:47.162] run() for ‘Future’ ...
[10:21:47.162] - state: ‘created’
[10:21:47.162] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.176] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.176] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.176]   - Field: ‘node’
[10:21:47.176]   - Field: ‘label’
[10:21:47.177]   - Field: ‘local’
[10:21:47.177]   - Field: ‘owner’
[10:21:47.177]   - Field: ‘envir’
[10:21:47.177]   - Field: ‘workers’
[10:21:47.177]   - Field: ‘packages’
[10:21:47.177]   - Field: ‘gc’
[10:21:47.177]   - Field: ‘conditions’
[10:21:47.177]   - Field: ‘persistent’
[10:21:47.177]   - Field: ‘expr’
[10:21:47.177]   - Field: ‘uuid’
[10:21:47.177]   - Field: ‘seed’
[10:21:47.177]   - Field: ‘version’
[10:21:47.178]   - Field: ‘result’
[10:21:47.178]   - Field: ‘asynchronous’
[10:21:47.178]   - Field: ‘calls’
[10:21:47.178]   - Field: ‘globals’
[10:21:47.178]   - Field: ‘stdout’
[10:21:47.178]   - Field: ‘earlySignal’
[10:21:47.178]   - Field: ‘lazy’
[10:21:47.178]   - Field: ‘state’
[10:21:47.178] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.178] - Launch lazy future ...
[10:21:47.179] Packages needed by the future expression (n = 0): <none>
[10:21:47.179] Packages needed by future strategies (n = 0): <none>
[10:21:47.179] {
[10:21:47.179]     {
[10:21:47.179]         {
[10:21:47.179]             ...future.startTime <- base::Sys.time()
[10:21:47.179]             {
[10:21:47.179]                 {
[10:21:47.179]                   {
[10:21:47.179]                     {
[10:21:47.179]                       base::local({
[10:21:47.179]                         has_future <- base::requireNamespace("future", 
[10:21:47.179]                           quietly = TRUE)
[10:21:47.179]                         if (has_future) {
[10:21:47.179]                           ns <- base::getNamespace("future")
[10:21:47.179]                           version <- ns[[".package"]][["version"]]
[10:21:47.179]                           if (is.null(version)) 
[10:21:47.179]                             version <- utils::packageVersion("future")
[10:21:47.179]                         }
[10:21:47.179]                         else {
[10:21:47.179]                           version <- NULL
[10:21:47.179]                         }
[10:21:47.179]                         if (!has_future || version < "1.8.0") {
[10:21:47.179]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.179]                             "", base::R.version$version.string), 
[10:21:47.179]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:47.179]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:47.179]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.179]                               "release", "version")], collapse = " "), 
[10:21:47.179]                             hostname = base::Sys.info()[["nodename"]])
[10:21:47.179]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.179]                             info)
[10:21:47.179]                           info <- base::paste(info, collapse = "; ")
[10:21:47.179]                           if (!has_future) {
[10:21:47.179]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.179]                               info)
[10:21:47.179]                           }
[10:21:47.179]                           else {
[10:21:47.179]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.179]                               info, version)
[10:21:47.179]                           }
[10:21:47.179]                           base::stop(msg)
[10:21:47.179]                         }
[10:21:47.179]                       })
[10:21:47.179]                     }
[10:21:47.179]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.179]                     base::options(mc.cores = 1L)
[10:21:47.179]                   }
[10:21:47.179]                   ...future.strategy.old <- future::plan("list")
[10:21:47.179]                   options(future.plan = NULL)
[10:21:47.179]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.179]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.179]                 }
[10:21:47.179]                 ...future.workdir <- getwd()
[10:21:47.179]             }
[10:21:47.179]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.179]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.179]         }
[10:21:47.179]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.179]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.179]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.179]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.179]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.179]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.179]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.179]             base::names(...future.oldOptions))
[10:21:47.179]     }
[10:21:47.179]     if (FALSE) {
[10:21:47.179]     }
[10:21:47.179]     else {
[10:21:47.179]         if (TRUE) {
[10:21:47.179]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.179]                 open = "w")
[10:21:47.179]         }
[10:21:47.179]         else {
[10:21:47.179]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.179]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.179]         }
[10:21:47.179]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.179]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.179]             base::sink(type = "output", split = FALSE)
[10:21:47.179]             base::close(...future.stdout)
[10:21:47.179]         }, add = TRUE)
[10:21:47.179]     }
[10:21:47.179]     ...future.frame <- base::sys.nframe()
[10:21:47.179]     ...future.conditions <- base::list()
[10:21:47.179]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.179]     if (FALSE) {
[10:21:47.179]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.179]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.179]     }
[10:21:47.179]     ...future.result <- base::tryCatch({
[10:21:47.179]         base::withCallingHandlers({
[10:21:47.179]             ...future.value <- base::withVisible(base::local({
[10:21:47.179]                 ...future.makeSendCondition <- base::local({
[10:21:47.179]                   sendCondition <- NULL
[10:21:47.179]                   function(frame = 1L) {
[10:21:47.179]                     if (is.function(sendCondition)) 
[10:21:47.179]                       return(sendCondition)
[10:21:47.179]                     ns <- getNamespace("parallel")
[10:21:47.179]                     if (exists("sendData", mode = "function", 
[10:21:47.179]                       envir = ns)) {
[10:21:47.179]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.179]                         envir = ns)
[10:21:47.179]                       envir <- sys.frame(frame)
[10:21:47.179]                       master <- NULL
[10:21:47.179]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.179]                         !identical(envir, emptyenv())) {
[10:21:47.179]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.179]                           inherits = FALSE)) {
[10:21:47.179]                           master <- get("master", mode = "list", 
[10:21:47.179]                             envir = envir, inherits = FALSE)
[10:21:47.179]                           if (inherits(master, c("SOCKnode", 
[10:21:47.179]                             "SOCK0node"))) {
[10:21:47.179]                             sendCondition <<- function(cond) {
[10:21:47.179]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.179]                                 success = TRUE)
[10:21:47.179]                               parallel_sendData(master, data)
[10:21:47.179]                             }
[10:21:47.179]                             return(sendCondition)
[10:21:47.179]                           }
[10:21:47.179]                         }
[10:21:47.179]                         frame <- frame + 1L
[10:21:47.179]                         envir <- sys.frame(frame)
[10:21:47.179]                       }
[10:21:47.179]                     }
[10:21:47.179]                     sendCondition <<- function(cond) NULL
[10:21:47.179]                   }
[10:21:47.179]                 })
[10:21:47.179]                 withCallingHandlers({
[10:21:47.179]                   {
[10:21:47.179]                     b <- a * ii
[10:21:47.179]                     a <- 0
[10:21:47.179]                     b
[10:21:47.179]                   }
[10:21:47.179]                 }, immediateCondition = function(cond) {
[10:21:47.179]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.179]                   sendCondition(cond)
[10:21:47.179]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.179]                   {
[10:21:47.179]                     inherits <- base::inherits
[10:21:47.179]                     invokeRestart <- base::invokeRestart
[10:21:47.179]                     is.null <- base::is.null
[10:21:47.179]                     muffled <- FALSE
[10:21:47.179]                     if (inherits(cond, "message")) {
[10:21:47.179]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.179]                       if (muffled) 
[10:21:47.179]                         invokeRestart("muffleMessage")
[10:21:47.179]                     }
[10:21:47.179]                     else if (inherits(cond, "warning")) {
[10:21:47.179]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.179]                       if (muffled) 
[10:21:47.179]                         invokeRestart("muffleWarning")
[10:21:47.179]                     }
[10:21:47.179]                     else if (inherits(cond, "condition")) {
[10:21:47.179]                       if (!is.null(pattern)) {
[10:21:47.179]                         computeRestarts <- base::computeRestarts
[10:21:47.179]                         grepl <- base::grepl
[10:21:47.179]                         restarts <- computeRestarts(cond)
[10:21:47.179]                         for (restart in restarts) {
[10:21:47.179]                           name <- restart$name
[10:21:47.179]                           if (is.null(name)) 
[10:21:47.179]                             next
[10:21:47.179]                           if (!grepl(pattern, name)) 
[10:21:47.179]                             next
[10:21:47.179]                           invokeRestart(restart)
[10:21:47.179]                           muffled <- TRUE
[10:21:47.179]                           break
[10:21:47.179]                         }
[10:21:47.179]                       }
[10:21:47.179]                     }
[10:21:47.179]                     invisible(muffled)
[10:21:47.179]                   }
[10:21:47.179]                   muffleCondition(cond)
[10:21:47.179]                 })
[10:21:47.179]             }))
[10:21:47.179]             future::FutureResult(value = ...future.value$value, 
[10:21:47.179]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.179]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.179]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.179]                     ...future.globalenv.names))
[10:21:47.179]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.179]         }, condition = base::local({
[10:21:47.179]             c <- base::c
[10:21:47.179]             inherits <- base::inherits
[10:21:47.179]             invokeRestart <- base::invokeRestart
[10:21:47.179]             length <- base::length
[10:21:47.179]             list <- base::list
[10:21:47.179]             seq.int <- base::seq.int
[10:21:47.179]             signalCondition <- base::signalCondition
[10:21:47.179]             sys.calls <- base::sys.calls
[10:21:47.179]             `[[` <- base::`[[`
[10:21:47.179]             `+` <- base::`+`
[10:21:47.179]             `<<-` <- base::`<<-`
[10:21:47.179]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.179]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.179]                   3L)]
[10:21:47.179]             }
[10:21:47.179]             function(cond) {
[10:21:47.179]                 is_error <- inherits(cond, "error")
[10:21:47.179]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.179]                   NULL)
[10:21:47.179]                 if (is_error) {
[10:21:47.179]                   sessionInformation <- function() {
[10:21:47.179]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.179]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.179]                       search = base::search(), system = base::Sys.info())
[10:21:47.179]                   }
[10:21:47.179]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.179]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.179]                     cond$call), session = sessionInformation(), 
[10:21:47.179]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.179]                   signalCondition(cond)
[10:21:47.179]                 }
[10:21:47.179]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.179]                 "immediateCondition"))) {
[10:21:47.179]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.179]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.179]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.179]                   if (TRUE && !signal) {
[10:21:47.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.179]                     {
[10:21:47.179]                       inherits <- base::inherits
[10:21:47.179]                       invokeRestart <- base::invokeRestart
[10:21:47.179]                       is.null <- base::is.null
[10:21:47.179]                       muffled <- FALSE
[10:21:47.179]                       if (inherits(cond, "message")) {
[10:21:47.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.179]                         if (muffled) 
[10:21:47.179]                           invokeRestart("muffleMessage")
[10:21:47.179]                       }
[10:21:47.179]                       else if (inherits(cond, "warning")) {
[10:21:47.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.179]                         if (muffled) 
[10:21:47.179]                           invokeRestart("muffleWarning")
[10:21:47.179]                       }
[10:21:47.179]                       else if (inherits(cond, "condition")) {
[10:21:47.179]                         if (!is.null(pattern)) {
[10:21:47.179]                           computeRestarts <- base::computeRestarts
[10:21:47.179]                           grepl <- base::grepl
[10:21:47.179]                           restarts <- computeRestarts(cond)
[10:21:47.179]                           for (restart in restarts) {
[10:21:47.179]                             name <- restart$name
[10:21:47.179]                             if (is.null(name)) 
[10:21:47.179]                               next
[10:21:47.179]                             if (!grepl(pattern, name)) 
[10:21:47.179]                               next
[10:21:47.179]                             invokeRestart(restart)
[10:21:47.179]                             muffled <- TRUE
[10:21:47.179]                             break
[10:21:47.179]                           }
[10:21:47.179]                         }
[10:21:47.179]                       }
[10:21:47.179]                       invisible(muffled)
[10:21:47.179]                     }
[10:21:47.179]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.179]                   }
[10:21:47.179]                 }
[10:21:47.179]                 else {
[10:21:47.179]                   if (TRUE) {
[10:21:47.179]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.179]                     {
[10:21:47.179]                       inherits <- base::inherits
[10:21:47.179]                       invokeRestart <- base::invokeRestart
[10:21:47.179]                       is.null <- base::is.null
[10:21:47.179]                       muffled <- FALSE
[10:21:47.179]                       if (inherits(cond, "message")) {
[10:21:47.179]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.179]                         if (muffled) 
[10:21:47.179]                           invokeRestart("muffleMessage")
[10:21:47.179]                       }
[10:21:47.179]                       else if (inherits(cond, "warning")) {
[10:21:47.179]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.179]                         if (muffled) 
[10:21:47.179]                           invokeRestart("muffleWarning")
[10:21:47.179]                       }
[10:21:47.179]                       else if (inherits(cond, "condition")) {
[10:21:47.179]                         if (!is.null(pattern)) {
[10:21:47.179]                           computeRestarts <- base::computeRestarts
[10:21:47.179]                           grepl <- base::grepl
[10:21:47.179]                           restarts <- computeRestarts(cond)
[10:21:47.179]                           for (restart in restarts) {
[10:21:47.179]                             name <- restart$name
[10:21:47.179]                             if (is.null(name)) 
[10:21:47.179]                               next
[10:21:47.179]                             if (!grepl(pattern, name)) 
[10:21:47.179]                               next
[10:21:47.179]                             invokeRestart(restart)
[10:21:47.179]                             muffled <- TRUE
[10:21:47.179]                             break
[10:21:47.179]                           }
[10:21:47.179]                         }
[10:21:47.179]                       }
[10:21:47.179]                       invisible(muffled)
[10:21:47.179]                     }
[10:21:47.179]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.179]                   }
[10:21:47.179]                 }
[10:21:47.179]             }
[10:21:47.179]         }))
[10:21:47.179]     }, error = function(ex) {
[10:21:47.179]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.179]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.179]                 ...future.rng), started = ...future.startTime, 
[10:21:47.179]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.179]             version = "1.8"), class = "FutureResult")
[10:21:47.179]     }, finally = {
[10:21:47.179]         if (!identical(...future.workdir, getwd())) 
[10:21:47.179]             setwd(...future.workdir)
[10:21:47.179]         {
[10:21:47.179]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.179]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.179]             }
[10:21:47.179]             base::options(...future.oldOptions)
[10:21:47.179]             if (.Platform$OS.type == "windows") {
[10:21:47.179]                 old_names <- names(...future.oldEnvVars)
[10:21:47.179]                 envs <- base::Sys.getenv()
[10:21:47.179]                 names <- names(envs)
[10:21:47.179]                 common <- intersect(names, old_names)
[10:21:47.179]                 added <- setdiff(names, old_names)
[10:21:47.179]                 removed <- setdiff(old_names, names)
[10:21:47.179]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.179]                   envs[common]]
[10:21:47.179]                 NAMES <- toupper(changed)
[10:21:47.179]                 args <- list()
[10:21:47.179]                 for (kk in seq_along(NAMES)) {
[10:21:47.179]                   name <- changed[[kk]]
[10:21:47.179]                   NAME <- NAMES[[kk]]
[10:21:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.179]                     next
[10:21:47.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.179]                 }
[10:21:47.179]                 NAMES <- toupper(added)
[10:21:47.179]                 for (kk in seq_along(NAMES)) {
[10:21:47.179]                   name <- added[[kk]]
[10:21:47.179]                   NAME <- NAMES[[kk]]
[10:21:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.179]                     next
[10:21:47.179]                   args[[name]] <- ""
[10:21:47.179]                 }
[10:21:47.179]                 NAMES <- toupper(removed)
[10:21:47.179]                 for (kk in seq_along(NAMES)) {
[10:21:47.179]                   name <- removed[[kk]]
[10:21:47.179]                   NAME <- NAMES[[kk]]
[10:21:47.179]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.179]                     next
[10:21:47.179]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.179]                 }
[10:21:47.179]                 if (length(args) > 0) 
[10:21:47.179]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.179]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.179]             }
[10:21:47.179]             else {
[10:21:47.179]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.179]             }
[10:21:47.179]             {
[10:21:47.179]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.179]                   0L) {
[10:21:47.179]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.179]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.179]                   base::options(opts)
[10:21:47.179]                 }
[10:21:47.179]                 {
[10:21:47.179]                   {
[10:21:47.179]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.179]                     NULL
[10:21:47.179]                   }
[10:21:47.179]                   options(future.plan = NULL)
[10:21:47.179]                   if (is.na(NA_character_)) 
[10:21:47.179]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.179]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.179]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.179]                     .init = FALSE)
[10:21:47.179]                 }
[10:21:47.179]             }
[10:21:47.179]         }
[10:21:47.179]     })
[10:21:47.179]     if (TRUE) {
[10:21:47.179]         base::sink(type = "output", split = FALSE)
[10:21:47.179]         if (TRUE) {
[10:21:47.179]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.179]         }
[10:21:47.179]         else {
[10:21:47.179]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.179]         }
[10:21:47.179]         base::close(...future.stdout)
[10:21:47.179]         ...future.stdout <- NULL
[10:21:47.179]     }
[10:21:47.179]     ...future.result$conditions <- ...future.conditions
[10:21:47.179]     ...future.result$finished <- base::Sys.time()
[10:21:47.179]     ...future.result
[10:21:47.179] }
[10:21:47.182] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[10:21:47.182] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[10:21:47.182] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[10:21:47.183] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[10:21:47.183] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[10:21:47.183] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[10:21:47.184] MultisessionFuture started
[10:21:47.184] - Launch lazy future ... done
[10:21:47.184] run() for ‘MultisessionFuture’ ... done
[10:21:47.184] result() for ClusterFuture ...
[10:21:47.184] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.184] - Validating connection of MultisessionFuture
[10:21:47.226] - received message: FutureResult
[10:21:47.226] - Received FutureResult
[10:21:47.226] - Erased future from FutureRegistry
[10:21:47.227] result() for ClusterFuture ...
[10:21:47.227] - result already collected: FutureResult
[10:21:47.227] result() for ClusterFuture ... done
[10:21:47.227] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.227] result() for ClusterFuture ... done
[10:21:47.227] result() for ClusterFuture ...
[10:21:47.227] - result already collected: FutureResult
[10:21:47.227] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.228] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.228] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.228] 
[10:21:47.228] Searching for globals ... DONE
[10:21:47.229] - globals: [0] <none>
[10:21:47.229] getGlobalsAndPackages() ... DONE
[10:21:47.229] run() for ‘Future’ ...
[10:21:47.229] - state: ‘created’
[10:21:47.229] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.243] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.243] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.243]   - Field: ‘node’
[10:21:47.243]   - Field: ‘label’
[10:21:47.243]   - Field: ‘local’
[10:21:47.244]   - Field: ‘owner’
[10:21:47.244]   - Field: ‘envir’
[10:21:47.244]   - Field: ‘workers’
[10:21:47.244]   - Field: ‘packages’
[10:21:47.244]   - Field: ‘gc’
[10:21:47.244]   - Field: ‘conditions’
[10:21:47.244]   - Field: ‘persistent’
[10:21:47.244]   - Field: ‘expr’
[10:21:47.244]   - Field: ‘uuid’
[10:21:47.244]   - Field: ‘seed’
[10:21:47.244]   - Field: ‘version’
[10:21:47.244]   - Field: ‘result’
[10:21:47.245]   - Field: ‘asynchronous’
[10:21:47.245]   - Field: ‘calls’
[10:21:47.245]   - Field: ‘globals’
[10:21:47.245]   - Field: ‘stdout’
[10:21:47.245]   - Field: ‘earlySignal’
[10:21:47.245]   - Field: ‘lazy’
[10:21:47.245]   - Field: ‘state’
[10:21:47.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.245] - Launch lazy future ...
[10:21:47.246] Packages needed by the future expression (n = 0): <none>
[10:21:47.246] Packages needed by future strategies (n = 0): <none>
[10:21:47.246] {
[10:21:47.246]     {
[10:21:47.246]         {
[10:21:47.246]             ...future.startTime <- base::Sys.time()
[10:21:47.246]             {
[10:21:47.246]                 {
[10:21:47.246]                   {
[10:21:47.246]                     {
[10:21:47.246]                       base::local({
[10:21:47.246]                         has_future <- base::requireNamespace("future", 
[10:21:47.246]                           quietly = TRUE)
[10:21:47.246]                         if (has_future) {
[10:21:47.246]                           ns <- base::getNamespace("future")
[10:21:47.246]                           version <- ns[[".package"]][["version"]]
[10:21:47.246]                           if (is.null(version)) 
[10:21:47.246]                             version <- utils::packageVersion("future")
[10:21:47.246]                         }
[10:21:47.246]                         else {
[10:21:47.246]                           version <- NULL
[10:21:47.246]                         }
[10:21:47.246]                         if (!has_future || version < "1.8.0") {
[10:21:47.246]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.246]                             "", base::R.version$version.string), 
[10:21:47.246]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:47.246]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:47.246]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.246]                               "release", "version")], collapse = " "), 
[10:21:47.246]                             hostname = base::Sys.info()[["nodename"]])
[10:21:47.246]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.246]                             info)
[10:21:47.246]                           info <- base::paste(info, collapse = "; ")
[10:21:47.246]                           if (!has_future) {
[10:21:47.246]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.246]                               info)
[10:21:47.246]                           }
[10:21:47.246]                           else {
[10:21:47.246]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.246]                               info, version)
[10:21:47.246]                           }
[10:21:47.246]                           base::stop(msg)
[10:21:47.246]                         }
[10:21:47.246]                       })
[10:21:47.246]                     }
[10:21:47.246]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.246]                     base::options(mc.cores = 1L)
[10:21:47.246]                   }
[10:21:47.246]                   ...future.strategy.old <- future::plan("list")
[10:21:47.246]                   options(future.plan = NULL)
[10:21:47.246]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.246]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.246]                 }
[10:21:47.246]                 ...future.workdir <- getwd()
[10:21:47.246]             }
[10:21:47.246]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.246]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.246]         }
[10:21:47.246]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.246]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.246]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.246]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.246]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.246]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.246]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.246]             base::names(...future.oldOptions))
[10:21:47.246]     }
[10:21:47.246]     if (FALSE) {
[10:21:47.246]     }
[10:21:47.246]     else {
[10:21:47.246]         if (TRUE) {
[10:21:47.246]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.246]                 open = "w")
[10:21:47.246]         }
[10:21:47.246]         else {
[10:21:47.246]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.246]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.246]         }
[10:21:47.246]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.246]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.246]             base::sink(type = "output", split = FALSE)
[10:21:47.246]             base::close(...future.stdout)
[10:21:47.246]         }, add = TRUE)
[10:21:47.246]     }
[10:21:47.246]     ...future.frame <- base::sys.nframe()
[10:21:47.246]     ...future.conditions <- base::list()
[10:21:47.246]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.246]     if (FALSE) {
[10:21:47.246]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.246]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.246]     }
[10:21:47.246]     ...future.result <- base::tryCatch({
[10:21:47.246]         base::withCallingHandlers({
[10:21:47.246]             ...future.value <- base::withVisible(base::local({
[10:21:47.246]                 ...future.makeSendCondition <- base::local({
[10:21:47.246]                   sendCondition <- NULL
[10:21:47.246]                   function(frame = 1L) {
[10:21:47.246]                     if (is.function(sendCondition)) 
[10:21:47.246]                       return(sendCondition)
[10:21:47.246]                     ns <- getNamespace("parallel")
[10:21:47.246]                     if (exists("sendData", mode = "function", 
[10:21:47.246]                       envir = ns)) {
[10:21:47.246]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.246]                         envir = ns)
[10:21:47.246]                       envir <- sys.frame(frame)
[10:21:47.246]                       master <- NULL
[10:21:47.246]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.246]                         !identical(envir, emptyenv())) {
[10:21:47.246]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.246]                           inherits = FALSE)) {
[10:21:47.246]                           master <- get("master", mode = "list", 
[10:21:47.246]                             envir = envir, inherits = FALSE)
[10:21:47.246]                           if (inherits(master, c("SOCKnode", 
[10:21:47.246]                             "SOCK0node"))) {
[10:21:47.246]                             sendCondition <<- function(cond) {
[10:21:47.246]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.246]                                 success = TRUE)
[10:21:47.246]                               parallel_sendData(master, data)
[10:21:47.246]                             }
[10:21:47.246]                             return(sendCondition)
[10:21:47.246]                           }
[10:21:47.246]                         }
[10:21:47.246]                         frame <- frame + 1L
[10:21:47.246]                         envir <- sys.frame(frame)
[10:21:47.246]                       }
[10:21:47.246]                     }
[10:21:47.246]                     sendCondition <<- function(cond) NULL
[10:21:47.246]                   }
[10:21:47.246]                 })
[10:21:47.246]                 withCallingHandlers({
[10:21:47.246]                   1
[10:21:47.246]                 }, immediateCondition = function(cond) {
[10:21:47.246]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.246]                   sendCondition(cond)
[10:21:47.246]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.246]                   {
[10:21:47.246]                     inherits <- base::inherits
[10:21:47.246]                     invokeRestart <- base::invokeRestart
[10:21:47.246]                     is.null <- base::is.null
[10:21:47.246]                     muffled <- FALSE
[10:21:47.246]                     if (inherits(cond, "message")) {
[10:21:47.246]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.246]                       if (muffled) 
[10:21:47.246]                         invokeRestart("muffleMessage")
[10:21:47.246]                     }
[10:21:47.246]                     else if (inherits(cond, "warning")) {
[10:21:47.246]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.246]                       if (muffled) 
[10:21:47.246]                         invokeRestart("muffleWarning")
[10:21:47.246]                     }
[10:21:47.246]                     else if (inherits(cond, "condition")) {
[10:21:47.246]                       if (!is.null(pattern)) {
[10:21:47.246]                         computeRestarts <- base::computeRestarts
[10:21:47.246]                         grepl <- base::grepl
[10:21:47.246]                         restarts <- computeRestarts(cond)
[10:21:47.246]                         for (restart in restarts) {
[10:21:47.246]                           name <- restart$name
[10:21:47.246]                           if (is.null(name)) 
[10:21:47.246]                             next
[10:21:47.246]                           if (!grepl(pattern, name)) 
[10:21:47.246]                             next
[10:21:47.246]                           invokeRestart(restart)
[10:21:47.246]                           muffled <- TRUE
[10:21:47.246]                           break
[10:21:47.246]                         }
[10:21:47.246]                       }
[10:21:47.246]                     }
[10:21:47.246]                     invisible(muffled)
[10:21:47.246]                   }
[10:21:47.246]                   muffleCondition(cond)
[10:21:47.246]                 })
[10:21:47.246]             }))
[10:21:47.246]             future::FutureResult(value = ...future.value$value, 
[10:21:47.246]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.246]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.246]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.246]                     ...future.globalenv.names))
[10:21:47.246]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.246]         }, condition = base::local({
[10:21:47.246]             c <- base::c
[10:21:47.246]             inherits <- base::inherits
[10:21:47.246]             invokeRestart <- base::invokeRestart
[10:21:47.246]             length <- base::length
[10:21:47.246]             list <- base::list
[10:21:47.246]             seq.int <- base::seq.int
[10:21:47.246]             signalCondition <- base::signalCondition
[10:21:47.246]             sys.calls <- base::sys.calls
[10:21:47.246]             `[[` <- base::`[[`
[10:21:47.246]             `+` <- base::`+`
[10:21:47.246]             `<<-` <- base::`<<-`
[10:21:47.246]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.246]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.246]                   3L)]
[10:21:47.246]             }
[10:21:47.246]             function(cond) {
[10:21:47.246]                 is_error <- inherits(cond, "error")
[10:21:47.246]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.246]                   NULL)
[10:21:47.246]                 if (is_error) {
[10:21:47.246]                   sessionInformation <- function() {
[10:21:47.246]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.246]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.246]                       search = base::search(), system = base::Sys.info())
[10:21:47.246]                   }
[10:21:47.246]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.246]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.246]                     cond$call), session = sessionInformation(), 
[10:21:47.246]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.246]                   signalCondition(cond)
[10:21:47.246]                 }
[10:21:47.246]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.246]                 "immediateCondition"))) {
[10:21:47.246]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.246]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.246]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.246]                   if (TRUE && !signal) {
[10:21:47.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.246]                     {
[10:21:47.246]                       inherits <- base::inherits
[10:21:47.246]                       invokeRestart <- base::invokeRestart
[10:21:47.246]                       is.null <- base::is.null
[10:21:47.246]                       muffled <- FALSE
[10:21:47.246]                       if (inherits(cond, "message")) {
[10:21:47.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.246]                         if (muffled) 
[10:21:47.246]                           invokeRestart("muffleMessage")
[10:21:47.246]                       }
[10:21:47.246]                       else if (inherits(cond, "warning")) {
[10:21:47.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.246]                         if (muffled) 
[10:21:47.246]                           invokeRestart("muffleWarning")
[10:21:47.246]                       }
[10:21:47.246]                       else if (inherits(cond, "condition")) {
[10:21:47.246]                         if (!is.null(pattern)) {
[10:21:47.246]                           computeRestarts <- base::computeRestarts
[10:21:47.246]                           grepl <- base::grepl
[10:21:47.246]                           restarts <- computeRestarts(cond)
[10:21:47.246]                           for (restart in restarts) {
[10:21:47.246]                             name <- restart$name
[10:21:47.246]                             if (is.null(name)) 
[10:21:47.246]                               next
[10:21:47.246]                             if (!grepl(pattern, name)) 
[10:21:47.246]                               next
[10:21:47.246]                             invokeRestart(restart)
[10:21:47.246]                             muffled <- TRUE
[10:21:47.246]                             break
[10:21:47.246]                           }
[10:21:47.246]                         }
[10:21:47.246]                       }
[10:21:47.246]                       invisible(muffled)
[10:21:47.246]                     }
[10:21:47.246]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.246]                   }
[10:21:47.246]                 }
[10:21:47.246]                 else {
[10:21:47.246]                   if (TRUE) {
[10:21:47.246]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.246]                     {
[10:21:47.246]                       inherits <- base::inherits
[10:21:47.246]                       invokeRestart <- base::invokeRestart
[10:21:47.246]                       is.null <- base::is.null
[10:21:47.246]                       muffled <- FALSE
[10:21:47.246]                       if (inherits(cond, "message")) {
[10:21:47.246]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.246]                         if (muffled) 
[10:21:47.246]                           invokeRestart("muffleMessage")
[10:21:47.246]                       }
[10:21:47.246]                       else if (inherits(cond, "warning")) {
[10:21:47.246]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.246]                         if (muffled) 
[10:21:47.246]                           invokeRestart("muffleWarning")
[10:21:47.246]                       }
[10:21:47.246]                       else if (inherits(cond, "condition")) {
[10:21:47.246]                         if (!is.null(pattern)) {
[10:21:47.246]                           computeRestarts <- base::computeRestarts
[10:21:47.246]                           grepl <- base::grepl
[10:21:47.246]                           restarts <- computeRestarts(cond)
[10:21:47.246]                           for (restart in restarts) {
[10:21:47.246]                             name <- restart$name
[10:21:47.246]                             if (is.null(name)) 
[10:21:47.246]                               next
[10:21:47.246]                             if (!grepl(pattern, name)) 
[10:21:47.246]                               next
[10:21:47.246]                             invokeRestart(restart)
[10:21:47.246]                             muffled <- TRUE
[10:21:47.246]                             break
[10:21:47.246]                           }
[10:21:47.246]                         }
[10:21:47.246]                       }
[10:21:47.246]                       invisible(muffled)
[10:21:47.246]                     }
[10:21:47.246]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.246]                   }
[10:21:47.246]                 }
[10:21:47.246]             }
[10:21:47.246]         }))
[10:21:47.246]     }, error = function(ex) {
[10:21:47.246]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.246]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.246]                 ...future.rng), started = ...future.startTime, 
[10:21:47.246]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.246]             version = "1.8"), class = "FutureResult")
[10:21:47.246]     }, finally = {
[10:21:47.246]         if (!identical(...future.workdir, getwd())) 
[10:21:47.246]             setwd(...future.workdir)
[10:21:47.246]         {
[10:21:47.246]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.246]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.246]             }
[10:21:47.246]             base::options(...future.oldOptions)
[10:21:47.246]             if (.Platform$OS.type == "windows") {
[10:21:47.246]                 old_names <- names(...future.oldEnvVars)
[10:21:47.246]                 envs <- base::Sys.getenv()
[10:21:47.246]                 names <- names(envs)
[10:21:47.246]                 common <- intersect(names, old_names)
[10:21:47.246]                 added <- setdiff(names, old_names)
[10:21:47.246]                 removed <- setdiff(old_names, names)
[10:21:47.246]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.246]                   envs[common]]
[10:21:47.246]                 NAMES <- toupper(changed)
[10:21:47.246]                 args <- list()
[10:21:47.246]                 for (kk in seq_along(NAMES)) {
[10:21:47.246]                   name <- changed[[kk]]
[10:21:47.246]                   NAME <- NAMES[[kk]]
[10:21:47.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.246]                     next
[10:21:47.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.246]                 }
[10:21:47.246]                 NAMES <- toupper(added)
[10:21:47.246]                 for (kk in seq_along(NAMES)) {
[10:21:47.246]                   name <- added[[kk]]
[10:21:47.246]                   NAME <- NAMES[[kk]]
[10:21:47.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.246]                     next
[10:21:47.246]                   args[[name]] <- ""
[10:21:47.246]                 }
[10:21:47.246]                 NAMES <- toupper(removed)
[10:21:47.246]                 for (kk in seq_along(NAMES)) {
[10:21:47.246]                   name <- removed[[kk]]
[10:21:47.246]                   NAME <- NAMES[[kk]]
[10:21:47.246]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.246]                     next
[10:21:47.246]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.246]                 }
[10:21:47.246]                 if (length(args) > 0) 
[10:21:47.246]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.246]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.246]             }
[10:21:47.246]             else {
[10:21:47.246]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.246]             }
[10:21:47.246]             {
[10:21:47.246]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.246]                   0L) {
[10:21:47.246]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.246]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.246]                   base::options(opts)
[10:21:47.246]                 }
[10:21:47.246]                 {
[10:21:47.246]                   {
[10:21:47.246]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.246]                     NULL
[10:21:47.246]                   }
[10:21:47.246]                   options(future.plan = NULL)
[10:21:47.246]                   if (is.na(NA_character_)) 
[10:21:47.246]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.246]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.246]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.246]                     .init = FALSE)
[10:21:47.246]                 }
[10:21:47.246]             }
[10:21:47.246]         }
[10:21:47.246]     })
[10:21:47.246]     if (TRUE) {
[10:21:47.246]         base::sink(type = "output", split = FALSE)
[10:21:47.246]         if (TRUE) {
[10:21:47.246]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.246]         }
[10:21:47.246]         else {
[10:21:47.246]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.246]         }
[10:21:47.246]         base::close(...future.stdout)
[10:21:47.246]         ...future.stdout <- NULL
[10:21:47.246]     }
[10:21:47.246]     ...future.result$conditions <- ...future.conditions
[10:21:47.246]     ...future.result$finished <- base::Sys.time()
[10:21:47.246]     ...future.result
[10:21:47.246] }
[10:21:47.249] MultisessionFuture started
[10:21:47.249] - Launch lazy future ... done
[10:21:47.249] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.249] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.250] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.250] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:47.251] Searching for globals ... DONE
[10:21:47.251] Resolving globals: TRUE
[10:21:47.251] Resolving any globals that are futures ...
[10:21:47.251] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:47.251] Resolving any globals that are futures ... DONE
[10:21:47.253] Resolving futures part of globals (recursively) ...
[10:21:47.254] resolve() on list ...
[10:21:47.254]  recursive: 99
[10:21:47.254]  length: 1
[10:21:47.254]  elements: ‘a’
[10:21:47.296] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.296] - Validating connection of MultisessionFuture
[10:21:47.296] - received message: FutureResult
[10:21:47.296] - Received FutureResult
[10:21:47.296] - Erased future from FutureRegistry
[10:21:47.296] result() for ClusterFuture ...
[10:21:47.296] - result already collected: FutureResult
[10:21:47.296] result() for ClusterFuture ... done
[10:21:47.296] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.297] Future #1
[10:21:47.297] result() for ClusterFuture ...
[10:21:47.297] - result already collected: FutureResult
[10:21:47.297] result() for ClusterFuture ... done
[10:21:47.297] result() for ClusterFuture ...
[10:21:47.297] - result already collected: FutureResult
[10:21:47.297] result() for ClusterFuture ... done
[10:21:47.297] A MultisessionFuture was resolved
[10:21:47.297]  length: 0 (resolved future 1)
[10:21:47.297] resolve() on list ... DONE
[10:21:47.298] - globals: [1] ‘a’
[10:21:47.298] Resolving futures part of globals (recursively) ... DONE
[10:21:47.309] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[10:21:47.309] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[10:21:47.309] - globals: [1] ‘a’
[10:21:47.309] - packages: [1] ‘future’
[10:21:47.310] getGlobalsAndPackages() ... DONE
[10:21:47.310] run() for ‘Future’ ...
[10:21:47.310] - state: ‘created’
[10:21:47.310] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.324] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.324] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.324]   - Field: ‘node’
[10:21:47.324]   - Field: ‘label’
[10:21:47.324]   - Field: ‘local’
[10:21:47.324]   - Field: ‘owner’
[10:21:47.324]   - Field: ‘envir’
[10:21:47.324]   - Field: ‘workers’
[10:21:47.324]   - Field: ‘packages’
[10:21:47.324]   - Field: ‘gc’
[10:21:47.325]   - Field: ‘conditions’
[10:21:47.325]   - Field: ‘persistent’
[10:21:47.325]   - Field: ‘expr’
[10:21:47.325]   - Field: ‘uuid’
[10:21:47.325]   - Field: ‘seed’
[10:21:47.325]   - Field: ‘version’
[10:21:47.325]   - Field: ‘result’
[10:21:47.325]   - Field: ‘asynchronous’
[10:21:47.325]   - Field: ‘calls’
[10:21:47.325]   - Field: ‘globals’
[10:21:47.325]   - Field: ‘stdout’
[10:21:47.325]   - Field: ‘earlySignal’
[10:21:47.326]   - Field: ‘lazy’
[10:21:47.326]   - Field: ‘state’
[10:21:47.326] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.326] - Launch lazy future ...
[10:21:47.326] Packages needed by the future expression (n = 1): ‘future’
[10:21:47.326] Packages needed by future strategies (n = 0): <none>
[10:21:47.327] {
[10:21:47.327]     {
[10:21:47.327]         {
[10:21:47.327]             ...future.startTime <- base::Sys.time()
[10:21:47.327]             {
[10:21:47.327]                 {
[10:21:47.327]                   {
[10:21:47.327]                     {
[10:21:47.327]                       {
[10:21:47.327]                         base::local({
[10:21:47.327]                           has_future <- base::requireNamespace("future", 
[10:21:47.327]                             quietly = TRUE)
[10:21:47.327]                           if (has_future) {
[10:21:47.327]                             ns <- base::getNamespace("future")
[10:21:47.327]                             version <- ns[[".package"]][["version"]]
[10:21:47.327]                             if (is.null(version)) 
[10:21:47.327]                               version <- utils::packageVersion("future")
[10:21:47.327]                           }
[10:21:47.327]                           else {
[10:21:47.327]                             version <- NULL
[10:21:47.327]                           }
[10:21:47.327]                           if (!has_future || version < "1.8.0") {
[10:21:47.327]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.327]                               "", base::R.version$version.string), 
[10:21:47.327]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:47.327]                                 base::R.version$platform, 8 * 
[10:21:47.327]                                   base::.Machine$sizeof.pointer), 
[10:21:47.327]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.327]                                 "release", "version")], collapse = " "), 
[10:21:47.327]                               hostname = base::Sys.info()[["nodename"]])
[10:21:47.327]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.327]                               info)
[10:21:47.327]                             info <- base::paste(info, collapse = "; ")
[10:21:47.327]                             if (!has_future) {
[10:21:47.327]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.327]                                 info)
[10:21:47.327]                             }
[10:21:47.327]                             else {
[10:21:47.327]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.327]                                 info, version)
[10:21:47.327]                             }
[10:21:47.327]                             base::stop(msg)
[10:21:47.327]                           }
[10:21:47.327]                         })
[10:21:47.327]                       }
[10:21:47.327]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.327]                       base::options(mc.cores = 1L)
[10:21:47.327]                     }
[10:21:47.327]                     base::local({
[10:21:47.327]                       for (pkg in "future") {
[10:21:47.327]                         base::loadNamespace(pkg)
[10:21:47.327]                         base::library(pkg, character.only = TRUE)
[10:21:47.327]                       }
[10:21:47.327]                     })
[10:21:47.327]                   }
[10:21:47.327]                   ...future.strategy.old <- future::plan("list")
[10:21:47.327]                   options(future.plan = NULL)
[10:21:47.327]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.327]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.327]                 }
[10:21:47.327]                 ...future.workdir <- getwd()
[10:21:47.327]             }
[10:21:47.327]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.327]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.327]         }
[10:21:47.327]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.327]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.327]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.327]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.327]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.327]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.327]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.327]             base::names(...future.oldOptions))
[10:21:47.327]     }
[10:21:47.327]     if (FALSE) {
[10:21:47.327]     }
[10:21:47.327]     else {
[10:21:47.327]         if (TRUE) {
[10:21:47.327]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.327]                 open = "w")
[10:21:47.327]         }
[10:21:47.327]         else {
[10:21:47.327]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.327]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.327]         }
[10:21:47.327]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.327]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.327]             base::sink(type = "output", split = FALSE)
[10:21:47.327]             base::close(...future.stdout)
[10:21:47.327]         }, add = TRUE)
[10:21:47.327]     }
[10:21:47.327]     ...future.frame <- base::sys.nframe()
[10:21:47.327]     ...future.conditions <- base::list()
[10:21:47.327]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.327]     if (FALSE) {
[10:21:47.327]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.327]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.327]     }
[10:21:47.327]     ...future.result <- base::tryCatch({
[10:21:47.327]         base::withCallingHandlers({
[10:21:47.327]             ...future.value <- base::withVisible(base::local({
[10:21:47.327]                 ...future.makeSendCondition <- base::local({
[10:21:47.327]                   sendCondition <- NULL
[10:21:47.327]                   function(frame = 1L) {
[10:21:47.327]                     if (is.function(sendCondition)) 
[10:21:47.327]                       return(sendCondition)
[10:21:47.327]                     ns <- getNamespace("parallel")
[10:21:47.327]                     if (exists("sendData", mode = "function", 
[10:21:47.327]                       envir = ns)) {
[10:21:47.327]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.327]                         envir = ns)
[10:21:47.327]                       envir <- sys.frame(frame)
[10:21:47.327]                       master <- NULL
[10:21:47.327]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.327]                         !identical(envir, emptyenv())) {
[10:21:47.327]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.327]                           inherits = FALSE)) {
[10:21:47.327]                           master <- get("master", mode = "list", 
[10:21:47.327]                             envir = envir, inherits = FALSE)
[10:21:47.327]                           if (inherits(master, c("SOCKnode", 
[10:21:47.327]                             "SOCK0node"))) {
[10:21:47.327]                             sendCondition <<- function(cond) {
[10:21:47.327]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.327]                                 success = TRUE)
[10:21:47.327]                               parallel_sendData(master, data)
[10:21:47.327]                             }
[10:21:47.327]                             return(sendCondition)
[10:21:47.327]                           }
[10:21:47.327]                         }
[10:21:47.327]                         frame <- frame + 1L
[10:21:47.327]                         envir <- sys.frame(frame)
[10:21:47.327]                       }
[10:21:47.327]                     }
[10:21:47.327]                     sendCondition <<- function(cond) NULL
[10:21:47.327]                   }
[10:21:47.327]                 })
[10:21:47.327]                 withCallingHandlers({
[10:21:47.327]                   value(a) + 1
[10:21:47.327]                 }, immediateCondition = function(cond) {
[10:21:47.327]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.327]                   sendCondition(cond)
[10:21:47.327]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.327]                   {
[10:21:47.327]                     inherits <- base::inherits
[10:21:47.327]                     invokeRestart <- base::invokeRestart
[10:21:47.327]                     is.null <- base::is.null
[10:21:47.327]                     muffled <- FALSE
[10:21:47.327]                     if (inherits(cond, "message")) {
[10:21:47.327]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.327]                       if (muffled) 
[10:21:47.327]                         invokeRestart("muffleMessage")
[10:21:47.327]                     }
[10:21:47.327]                     else if (inherits(cond, "warning")) {
[10:21:47.327]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.327]                       if (muffled) 
[10:21:47.327]                         invokeRestart("muffleWarning")
[10:21:47.327]                     }
[10:21:47.327]                     else if (inherits(cond, "condition")) {
[10:21:47.327]                       if (!is.null(pattern)) {
[10:21:47.327]                         computeRestarts <- base::computeRestarts
[10:21:47.327]                         grepl <- base::grepl
[10:21:47.327]                         restarts <- computeRestarts(cond)
[10:21:47.327]                         for (restart in restarts) {
[10:21:47.327]                           name <- restart$name
[10:21:47.327]                           if (is.null(name)) 
[10:21:47.327]                             next
[10:21:47.327]                           if (!grepl(pattern, name)) 
[10:21:47.327]                             next
[10:21:47.327]                           invokeRestart(restart)
[10:21:47.327]                           muffled <- TRUE
[10:21:47.327]                           break
[10:21:47.327]                         }
[10:21:47.327]                       }
[10:21:47.327]                     }
[10:21:47.327]                     invisible(muffled)
[10:21:47.327]                   }
[10:21:47.327]                   muffleCondition(cond)
[10:21:47.327]                 })
[10:21:47.327]             }))
[10:21:47.327]             future::FutureResult(value = ...future.value$value, 
[10:21:47.327]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.327]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.327]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.327]                     ...future.globalenv.names))
[10:21:47.327]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.327]         }, condition = base::local({
[10:21:47.327]             c <- base::c
[10:21:47.327]             inherits <- base::inherits
[10:21:47.327]             invokeRestart <- base::invokeRestart
[10:21:47.327]             length <- base::length
[10:21:47.327]             list <- base::list
[10:21:47.327]             seq.int <- base::seq.int
[10:21:47.327]             signalCondition <- base::signalCondition
[10:21:47.327]             sys.calls <- base::sys.calls
[10:21:47.327]             `[[` <- base::`[[`
[10:21:47.327]             `+` <- base::`+`
[10:21:47.327]             `<<-` <- base::`<<-`
[10:21:47.327]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.327]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.327]                   3L)]
[10:21:47.327]             }
[10:21:47.327]             function(cond) {
[10:21:47.327]                 is_error <- inherits(cond, "error")
[10:21:47.327]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.327]                   NULL)
[10:21:47.327]                 if (is_error) {
[10:21:47.327]                   sessionInformation <- function() {
[10:21:47.327]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.327]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.327]                       search = base::search(), system = base::Sys.info())
[10:21:47.327]                   }
[10:21:47.327]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.327]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.327]                     cond$call), session = sessionInformation(), 
[10:21:47.327]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.327]                   signalCondition(cond)
[10:21:47.327]                 }
[10:21:47.327]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.327]                 "immediateCondition"))) {
[10:21:47.327]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.327]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.327]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.327]                   if (TRUE && !signal) {
[10:21:47.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.327]                     {
[10:21:47.327]                       inherits <- base::inherits
[10:21:47.327]                       invokeRestart <- base::invokeRestart
[10:21:47.327]                       is.null <- base::is.null
[10:21:47.327]                       muffled <- FALSE
[10:21:47.327]                       if (inherits(cond, "message")) {
[10:21:47.327]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.327]                         if (muffled) 
[10:21:47.327]                           invokeRestart("muffleMessage")
[10:21:47.327]                       }
[10:21:47.327]                       else if (inherits(cond, "warning")) {
[10:21:47.327]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.327]                         if (muffled) 
[10:21:47.327]                           invokeRestart("muffleWarning")
[10:21:47.327]                       }
[10:21:47.327]                       else if (inherits(cond, "condition")) {
[10:21:47.327]                         if (!is.null(pattern)) {
[10:21:47.327]                           computeRestarts <- base::computeRestarts
[10:21:47.327]                           grepl <- base::grepl
[10:21:47.327]                           restarts <- computeRestarts(cond)
[10:21:47.327]                           for (restart in restarts) {
[10:21:47.327]                             name <- restart$name
[10:21:47.327]                             if (is.null(name)) 
[10:21:47.327]                               next
[10:21:47.327]                             if (!grepl(pattern, name)) 
[10:21:47.327]                               next
[10:21:47.327]                             invokeRestart(restart)
[10:21:47.327]                             muffled <- TRUE
[10:21:47.327]                             break
[10:21:47.327]                           }
[10:21:47.327]                         }
[10:21:47.327]                       }
[10:21:47.327]                       invisible(muffled)
[10:21:47.327]                     }
[10:21:47.327]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.327]                   }
[10:21:47.327]                 }
[10:21:47.327]                 else {
[10:21:47.327]                   if (TRUE) {
[10:21:47.327]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.327]                     {
[10:21:47.327]                       inherits <- base::inherits
[10:21:47.327]                       invokeRestart <- base::invokeRestart
[10:21:47.327]                       is.null <- base::is.null
[10:21:47.327]                       muffled <- FALSE
[10:21:47.327]                       if (inherits(cond, "message")) {
[10:21:47.327]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.327]                         if (muffled) 
[10:21:47.327]                           invokeRestart("muffleMessage")
[10:21:47.327]                       }
[10:21:47.327]                       else if (inherits(cond, "warning")) {
[10:21:47.327]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.327]                         if (muffled) 
[10:21:47.327]                           invokeRestart("muffleWarning")
[10:21:47.327]                       }
[10:21:47.327]                       else if (inherits(cond, "condition")) {
[10:21:47.327]                         if (!is.null(pattern)) {
[10:21:47.327]                           computeRestarts <- base::computeRestarts
[10:21:47.327]                           grepl <- base::grepl
[10:21:47.327]                           restarts <- computeRestarts(cond)
[10:21:47.327]                           for (restart in restarts) {
[10:21:47.327]                             name <- restart$name
[10:21:47.327]                             if (is.null(name)) 
[10:21:47.327]                               next
[10:21:47.327]                             if (!grepl(pattern, name)) 
[10:21:47.327]                               next
[10:21:47.327]                             invokeRestart(restart)
[10:21:47.327]                             muffled <- TRUE
[10:21:47.327]                             break
[10:21:47.327]                           }
[10:21:47.327]                         }
[10:21:47.327]                       }
[10:21:47.327]                       invisible(muffled)
[10:21:47.327]                     }
[10:21:47.327]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.327]                   }
[10:21:47.327]                 }
[10:21:47.327]             }
[10:21:47.327]         }))
[10:21:47.327]     }, error = function(ex) {
[10:21:47.327]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.327]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.327]                 ...future.rng), started = ...future.startTime, 
[10:21:47.327]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.327]             version = "1.8"), class = "FutureResult")
[10:21:47.327]     }, finally = {
[10:21:47.327]         if (!identical(...future.workdir, getwd())) 
[10:21:47.327]             setwd(...future.workdir)
[10:21:47.327]         {
[10:21:47.327]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.327]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.327]             }
[10:21:47.327]             base::options(...future.oldOptions)
[10:21:47.327]             if (.Platform$OS.type == "windows") {
[10:21:47.327]                 old_names <- names(...future.oldEnvVars)
[10:21:47.327]                 envs <- base::Sys.getenv()
[10:21:47.327]                 names <- names(envs)
[10:21:47.327]                 common <- intersect(names, old_names)
[10:21:47.327]                 added <- setdiff(names, old_names)
[10:21:47.327]                 removed <- setdiff(old_names, names)
[10:21:47.327]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.327]                   envs[common]]
[10:21:47.327]                 NAMES <- toupper(changed)
[10:21:47.327]                 args <- list()
[10:21:47.327]                 for (kk in seq_along(NAMES)) {
[10:21:47.327]                   name <- changed[[kk]]
[10:21:47.327]                   NAME <- NAMES[[kk]]
[10:21:47.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.327]                     next
[10:21:47.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.327]                 }
[10:21:47.327]                 NAMES <- toupper(added)
[10:21:47.327]                 for (kk in seq_along(NAMES)) {
[10:21:47.327]                   name <- added[[kk]]
[10:21:47.327]                   NAME <- NAMES[[kk]]
[10:21:47.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.327]                     next
[10:21:47.327]                   args[[name]] <- ""
[10:21:47.327]                 }
[10:21:47.327]                 NAMES <- toupper(removed)
[10:21:47.327]                 for (kk in seq_along(NAMES)) {
[10:21:47.327]                   name <- removed[[kk]]
[10:21:47.327]                   NAME <- NAMES[[kk]]
[10:21:47.327]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.327]                     next
[10:21:47.327]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.327]                 }
[10:21:47.327]                 if (length(args) > 0) 
[10:21:47.327]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.327]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.327]             }
[10:21:47.327]             else {
[10:21:47.327]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.327]             }
[10:21:47.327]             {
[10:21:47.327]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.327]                   0L) {
[10:21:47.327]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.327]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.327]                   base::options(opts)
[10:21:47.327]                 }
[10:21:47.327]                 {
[10:21:47.327]                   {
[10:21:47.327]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.327]                     NULL
[10:21:47.327]                   }
[10:21:47.327]                   options(future.plan = NULL)
[10:21:47.327]                   if (is.na(NA_character_)) 
[10:21:47.327]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.327]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.327]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.327]                     .init = FALSE)
[10:21:47.327]                 }
[10:21:47.327]             }
[10:21:47.327]         }
[10:21:47.327]     })
[10:21:47.327]     if (TRUE) {
[10:21:47.327]         base::sink(type = "output", split = FALSE)
[10:21:47.327]         if (TRUE) {
[10:21:47.327]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.327]         }
[10:21:47.327]         else {
[10:21:47.327]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.327]         }
[10:21:47.327]         base::close(...future.stdout)
[10:21:47.327]         ...future.stdout <- NULL
[10:21:47.327]     }
[10:21:47.327]     ...future.result$conditions <- ...future.conditions
[10:21:47.327]     ...future.result$finished <- base::Sys.time()
[10:21:47.327]     ...future.result
[10:21:47.327] }
[10:21:47.340] Exporting 1 global objects (313.44 KiB) to cluster node #1 ...
[10:21:47.351] Exporting ‘a’ (313.23 KiB) to cluster node #1 ...
[10:21:47.404] Exporting ‘a’ (313.23 KiB) to cluster node #1 ... DONE
[10:21:47.404] Exporting 1 global objects (313.44 KiB) to cluster node #1 ... DONE
[10:21:47.405] MultisessionFuture started
[10:21:47.405] - Launch lazy future ... done
[10:21:47.405] run() for ‘MultisessionFuture’ ... done
[10:21:47.405] result() for ClusterFuture ...
[10:21:47.405] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.405] - Validating connection of MultisessionFuture
[10:21:47.450] - received message: FutureResult
[10:21:47.450] - Received FutureResult
[10:21:47.451] - Erased future from FutureRegistry
[10:21:47.451] result() for ClusterFuture ...
[10:21:47.451] - result already collected: FutureResult
[10:21:47.451] result() for ClusterFuture ... done
[10:21:47.451] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.451] result() for ClusterFuture ... done
[10:21:47.451] result() for ClusterFuture ...
[10:21:47.451] - result already collected: FutureResult
[10:21:47.451] result() for ClusterFuture ... done
value(b) = 2
[10:21:47.452] result() for ClusterFuture ...
[10:21:47.452] - result already collected: FutureResult
[10:21:47.452] result() for ClusterFuture ... done
[10:21:47.452] result() for ClusterFuture ...
[10:21:47.452] - result already collected: FutureResult
[10:21:47.452] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.452] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.453] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.453] 
[10:21:47.453] Searching for globals ... DONE
[10:21:47.453] - globals: [0] <none>
[10:21:47.453] getGlobalsAndPackages() ... DONE
[10:21:47.454] run() for ‘Future’ ...
[10:21:47.454] - state: ‘created’
[10:21:47.454] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.469] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.469] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.469]   - Field: ‘node’
[10:21:47.469]   - Field: ‘label’
[10:21:47.469]   - Field: ‘local’
[10:21:47.469]   - Field: ‘owner’
[10:21:47.469]   - Field: ‘envir’
[10:21:47.469]   - Field: ‘workers’
[10:21:47.470]   - Field: ‘packages’
[10:21:47.470]   - Field: ‘gc’
[10:21:47.470]   - Field: ‘conditions’
[10:21:47.470]   - Field: ‘persistent’
[10:21:47.470]   - Field: ‘expr’
[10:21:47.470]   - Field: ‘uuid’
[10:21:47.470]   - Field: ‘seed’
[10:21:47.470]   - Field: ‘version’
[10:21:47.470]   - Field: ‘result’
[10:21:47.470]   - Field: ‘asynchronous’
[10:21:47.470]   - Field: ‘calls’
[10:21:47.470]   - Field: ‘globals’
[10:21:47.471]   - Field: ‘stdout’
[10:21:47.471]   - Field: ‘earlySignal’
[10:21:47.471]   - Field: ‘lazy’
[10:21:47.471]   - Field: ‘state’
[10:21:47.471] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.471] - Launch lazy future ...
[10:21:47.471] Packages needed by the future expression (n = 0): <none>
[10:21:47.471] Packages needed by future strategies (n = 0): <none>
[10:21:47.472] {
[10:21:47.472]     {
[10:21:47.472]         {
[10:21:47.472]             ...future.startTime <- base::Sys.time()
[10:21:47.472]             {
[10:21:47.472]                 {
[10:21:47.472]                   {
[10:21:47.472]                     {
[10:21:47.472]                       base::local({
[10:21:47.472]                         has_future <- base::requireNamespace("future", 
[10:21:47.472]                           quietly = TRUE)
[10:21:47.472]                         if (has_future) {
[10:21:47.472]                           ns <- base::getNamespace("future")
[10:21:47.472]                           version <- ns[[".package"]][["version"]]
[10:21:47.472]                           if (is.null(version)) 
[10:21:47.472]                             version <- utils::packageVersion("future")
[10:21:47.472]                         }
[10:21:47.472]                         else {
[10:21:47.472]                           version <- NULL
[10:21:47.472]                         }
[10:21:47.472]                         if (!has_future || version < "1.8.0") {
[10:21:47.472]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.472]                             "", base::R.version$version.string), 
[10:21:47.472]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:47.472]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:47.472]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.472]                               "release", "version")], collapse = " "), 
[10:21:47.472]                             hostname = base::Sys.info()[["nodename"]])
[10:21:47.472]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.472]                             info)
[10:21:47.472]                           info <- base::paste(info, collapse = "; ")
[10:21:47.472]                           if (!has_future) {
[10:21:47.472]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.472]                               info)
[10:21:47.472]                           }
[10:21:47.472]                           else {
[10:21:47.472]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.472]                               info, version)
[10:21:47.472]                           }
[10:21:47.472]                           base::stop(msg)
[10:21:47.472]                         }
[10:21:47.472]                       })
[10:21:47.472]                     }
[10:21:47.472]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.472]                     base::options(mc.cores = 1L)
[10:21:47.472]                   }
[10:21:47.472]                   ...future.strategy.old <- future::plan("list")
[10:21:47.472]                   options(future.plan = NULL)
[10:21:47.472]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.472]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.472]                 }
[10:21:47.472]                 ...future.workdir <- getwd()
[10:21:47.472]             }
[10:21:47.472]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.472]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.472]         }
[10:21:47.472]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.472]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.472]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.472]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.472]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.472]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.472]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.472]             base::names(...future.oldOptions))
[10:21:47.472]     }
[10:21:47.472]     if (FALSE) {
[10:21:47.472]     }
[10:21:47.472]     else {
[10:21:47.472]         if (TRUE) {
[10:21:47.472]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.472]                 open = "w")
[10:21:47.472]         }
[10:21:47.472]         else {
[10:21:47.472]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.472]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.472]         }
[10:21:47.472]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.472]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.472]             base::sink(type = "output", split = FALSE)
[10:21:47.472]             base::close(...future.stdout)
[10:21:47.472]         }, add = TRUE)
[10:21:47.472]     }
[10:21:47.472]     ...future.frame <- base::sys.nframe()
[10:21:47.472]     ...future.conditions <- base::list()
[10:21:47.472]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.472]     if (FALSE) {
[10:21:47.472]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.472]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.472]     }
[10:21:47.472]     ...future.result <- base::tryCatch({
[10:21:47.472]         base::withCallingHandlers({
[10:21:47.472]             ...future.value <- base::withVisible(base::local({
[10:21:47.472]                 ...future.makeSendCondition <- base::local({
[10:21:47.472]                   sendCondition <- NULL
[10:21:47.472]                   function(frame = 1L) {
[10:21:47.472]                     if (is.function(sendCondition)) 
[10:21:47.472]                       return(sendCondition)
[10:21:47.472]                     ns <- getNamespace("parallel")
[10:21:47.472]                     if (exists("sendData", mode = "function", 
[10:21:47.472]                       envir = ns)) {
[10:21:47.472]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.472]                         envir = ns)
[10:21:47.472]                       envir <- sys.frame(frame)
[10:21:47.472]                       master <- NULL
[10:21:47.472]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.472]                         !identical(envir, emptyenv())) {
[10:21:47.472]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.472]                           inherits = FALSE)) {
[10:21:47.472]                           master <- get("master", mode = "list", 
[10:21:47.472]                             envir = envir, inherits = FALSE)
[10:21:47.472]                           if (inherits(master, c("SOCKnode", 
[10:21:47.472]                             "SOCK0node"))) {
[10:21:47.472]                             sendCondition <<- function(cond) {
[10:21:47.472]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.472]                                 success = TRUE)
[10:21:47.472]                               parallel_sendData(master, data)
[10:21:47.472]                             }
[10:21:47.472]                             return(sendCondition)
[10:21:47.472]                           }
[10:21:47.472]                         }
[10:21:47.472]                         frame <- frame + 1L
[10:21:47.472]                         envir <- sys.frame(frame)
[10:21:47.472]                       }
[10:21:47.472]                     }
[10:21:47.472]                     sendCondition <<- function(cond) NULL
[10:21:47.472]                   }
[10:21:47.472]                 })
[10:21:47.472]                 withCallingHandlers({
[10:21:47.472]                   1
[10:21:47.472]                 }, immediateCondition = function(cond) {
[10:21:47.472]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.472]                   sendCondition(cond)
[10:21:47.472]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.472]                   {
[10:21:47.472]                     inherits <- base::inherits
[10:21:47.472]                     invokeRestart <- base::invokeRestart
[10:21:47.472]                     is.null <- base::is.null
[10:21:47.472]                     muffled <- FALSE
[10:21:47.472]                     if (inherits(cond, "message")) {
[10:21:47.472]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.472]                       if (muffled) 
[10:21:47.472]                         invokeRestart("muffleMessage")
[10:21:47.472]                     }
[10:21:47.472]                     else if (inherits(cond, "warning")) {
[10:21:47.472]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.472]                       if (muffled) 
[10:21:47.472]                         invokeRestart("muffleWarning")
[10:21:47.472]                     }
[10:21:47.472]                     else if (inherits(cond, "condition")) {
[10:21:47.472]                       if (!is.null(pattern)) {
[10:21:47.472]                         computeRestarts <- base::computeRestarts
[10:21:47.472]                         grepl <- base::grepl
[10:21:47.472]                         restarts <- computeRestarts(cond)
[10:21:47.472]                         for (restart in restarts) {
[10:21:47.472]                           name <- restart$name
[10:21:47.472]                           if (is.null(name)) 
[10:21:47.472]                             next
[10:21:47.472]                           if (!grepl(pattern, name)) 
[10:21:47.472]                             next
[10:21:47.472]                           invokeRestart(restart)
[10:21:47.472]                           muffled <- TRUE
[10:21:47.472]                           break
[10:21:47.472]                         }
[10:21:47.472]                       }
[10:21:47.472]                     }
[10:21:47.472]                     invisible(muffled)
[10:21:47.472]                   }
[10:21:47.472]                   muffleCondition(cond)
[10:21:47.472]                 })
[10:21:47.472]             }))
[10:21:47.472]             future::FutureResult(value = ...future.value$value, 
[10:21:47.472]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.472]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.472]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.472]                     ...future.globalenv.names))
[10:21:47.472]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.472]         }, condition = base::local({
[10:21:47.472]             c <- base::c
[10:21:47.472]             inherits <- base::inherits
[10:21:47.472]             invokeRestart <- base::invokeRestart
[10:21:47.472]             length <- base::length
[10:21:47.472]             list <- base::list
[10:21:47.472]             seq.int <- base::seq.int
[10:21:47.472]             signalCondition <- base::signalCondition
[10:21:47.472]             sys.calls <- base::sys.calls
[10:21:47.472]             `[[` <- base::`[[`
[10:21:47.472]             `+` <- base::`+`
[10:21:47.472]             `<<-` <- base::`<<-`
[10:21:47.472]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.472]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.472]                   3L)]
[10:21:47.472]             }
[10:21:47.472]             function(cond) {
[10:21:47.472]                 is_error <- inherits(cond, "error")
[10:21:47.472]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.472]                   NULL)
[10:21:47.472]                 if (is_error) {
[10:21:47.472]                   sessionInformation <- function() {
[10:21:47.472]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.472]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.472]                       search = base::search(), system = base::Sys.info())
[10:21:47.472]                   }
[10:21:47.472]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.472]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.472]                     cond$call), session = sessionInformation(), 
[10:21:47.472]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.472]                   signalCondition(cond)
[10:21:47.472]                 }
[10:21:47.472]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.472]                 "immediateCondition"))) {
[10:21:47.472]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.472]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.472]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.472]                   if (TRUE && !signal) {
[10:21:47.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.472]                     {
[10:21:47.472]                       inherits <- base::inherits
[10:21:47.472]                       invokeRestart <- base::invokeRestart
[10:21:47.472]                       is.null <- base::is.null
[10:21:47.472]                       muffled <- FALSE
[10:21:47.472]                       if (inherits(cond, "message")) {
[10:21:47.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.472]                         if (muffled) 
[10:21:47.472]                           invokeRestart("muffleMessage")
[10:21:47.472]                       }
[10:21:47.472]                       else if (inherits(cond, "warning")) {
[10:21:47.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.472]                         if (muffled) 
[10:21:47.472]                           invokeRestart("muffleWarning")
[10:21:47.472]                       }
[10:21:47.472]                       else if (inherits(cond, "condition")) {
[10:21:47.472]                         if (!is.null(pattern)) {
[10:21:47.472]                           computeRestarts <- base::computeRestarts
[10:21:47.472]                           grepl <- base::grepl
[10:21:47.472]                           restarts <- computeRestarts(cond)
[10:21:47.472]                           for (restart in restarts) {
[10:21:47.472]                             name <- restart$name
[10:21:47.472]                             if (is.null(name)) 
[10:21:47.472]                               next
[10:21:47.472]                             if (!grepl(pattern, name)) 
[10:21:47.472]                               next
[10:21:47.472]                             invokeRestart(restart)
[10:21:47.472]                             muffled <- TRUE
[10:21:47.472]                             break
[10:21:47.472]                           }
[10:21:47.472]                         }
[10:21:47.472]                       }
[10:21:47.472]                       invisible(muffled)
[10:21:47.472]                     }
[10:21:47.472]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.472]                   }
[10:21:47.472]                 }
[10:21:47.472]                 else {
[10:21:47.472]                   if (TRUE) {
[10:21:47.472]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.472]                     {
[10:21:47.472]                       inherits <- base::inherits
[10:21:47.472]                       invokeRestart <- base::invokeRestart
[10:21:47.472]                       is.null <- base::is.null
[10:21:47.472]                       muffled <- FALSE
[10:21:47.472]                       if (inherits(cond, "message")) {
[10:21:47.472]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.472]                         if (muffled) 
[10:21:47.472]                           invokeRestart("muffleMessage")
[10:21:47.472]                       }
[10:21:47.472]                       else if (inherits(cond, "warning")) {
[10:21:47.472]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.472]                         if (muffled) 
[10:21:47.472]                           invokeRestart("muffleWarning")
[10:21:47.472]                       }
[10:21:47.472]                       else if (inherits(cond, "condition")) {
[10:21:47.472]                         if (!is.null(pattern)) {
[10:21:47.472]                           computeRestarts <- base::computeRestarts
[10:21:47.472]                           grepl <- base::grepl
[10:21:47.472]                           restarts <- computeRestarts(cond)
[10:21:47.472]                           for (restart in restarts) {
[10:21:47.472]                             name <- restart$name
[10:21:47.472]                             if (is.null(name)) 
[10:21:47.472]                               next
[10:21:47.472]                             if (!grepl(pattern, name)) 
[10:21:47.472]                               next
[10:21:47.472]                             invokeRestart(restart)
[10:21:47.472]                             muffled <- TRUE
[10:21:47.472]                             break
[10:21:47.472]                           }
[10:21:47.472]                         }
[10:21:47.472]                       }
[10:21:47.472]                       invisible(muffled)
[10:21:47.472]                     }
[10:21:47.472]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.472]                   }
[10:21:47.472]                 }
[10:21:47.472]             }
[10:21:47.472]         }))
[10:21:47.472]     }, error = function(ex) {
[10:21:47.472]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.472]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.472]                 ...future.rng), started = ...future.startTime, 
[10:21:47.472]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.472]             version = "1.8"), class = "FutureResult")
[10:21:47.472]     }, finally = {
[10:21:47.472]         if (!identical(...future.workdir, getwd())) 
[10:21:47.472]             setwd(...future.workdir)
[10:21:47.472]         {
[10:21:47.472]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.472]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.472]             }
[10:21:47.472]             base::options(...future.oldOptions)
[10:21:47.472]             if (.Platform$OS.type == "windows") {
[10:21:47.472]                 old_names <- names(...future.oldEnvVars)
[10:21:47.472]                 envs <- base::Sys.getenv()
[10:21:47.472]                 names <- names(envs)
[10:21:47.472]                 common <- intersect(names, old_names)
[10:21:47.472]                 added <- setdiff(names, old_names)
[10:21:47.472]                 removed <- setdiff(old_names, names)
[10:21:47.472]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.472]                   envs[common]]
[10:21:47.472]                 NAMES <- toupper(changed)
[10:21:47.472]                 args <- list()
[10:21:47.472]                 for (kk in seq_along(NAMES)) {
[10:21:47.472]                   name <- changed[[kk]]
[10:21:47.472]                   NAME <- NAMES[[kk]]
[10:21:47.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.472]                     next
[10:21:47.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.472]                 }
[10:21:47.472]                 NAMES <- toupper(added)
[10:21:47.472]                 for (kk in seq_along(NAMES)) {
[10:21:47.472]                   name <- added[[kk]]
[10:21:47.472]                   NAME <- NAMES[[kk]]
[10:21:47.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.472]                     next
[10:21:47.472]                   args[[name]] <- ""
[10:21:47.472]                 }
[10:21:47.472]                 NAMES <- toupper(removed)
[10:21:47.472]                 for (kk in seq_along(NAMES)) {
[10:21:47.472]                   name <- removed[[kk]]
[10:21:47.472]                   NAME <- NAMES[[kk]]
[10:21:47.472]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.472]                     next
[10:21:47.472]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.472]                 }
[10:21:47.472]                 if (length(args) > 0) 
[10:21:47.472]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.472]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.472]             }
[10:21:47.472]             else {
[10:21:47.472]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.472]             }
[10:21:47.472]             {
[10:21:47.472]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.472]                   0L) {
[10:21:47.472]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.472]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.472]                   base::options(opts)
[10:21:47.472]                 }
[10:21:47.472]                 {
[10:21:47.472]                   {
[10:21:47.472]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.472]                     NULL
[10:21:47.472]                   }
[10:21:47.472]                   options(future.plan = NULL)
[10:21:47.472]                   if (is.na(NA_character_)) 
[10:21:47.472]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.472]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.472]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.472]                     .init = FALSE)
[10:21:47.472]                 }
[10:21:47.472]             }
[10:21:47.472]         }
[10:21:47.472]     })
[10:21:47.472]     if (TRUE) {
[10:21:47.472]         base::sink(type = "output", split = FALSE)
[10:21:47.472]         if (TRUE) {
[10:21:47.472]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.472]         }
[10:21:47.472]         else {
[10:21:47.472]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.472]         }
[10:21:47.472]         base::close(...future.stdout)
[10:21:47.472]         ...future.stdout <- NULL
[10:21:47.472]     }
[10:21:47.472]     ...future.result$conditions <- ...future.conditions
[10:21:47.472]     ...future.result$finished <- base::Sys.time()
[10:21:47.472]     ...future.result
[10:21:47.472] }
[10:21:47.475] MultisessionFuture started
[10:21:47.475] - Launch lazy future ... done
[10:21:47.475] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.475] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.475] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.476] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:47.476] Searching for globals ... DONE
[10:21:47.476] Resolving globals: TRUE
[10:21:47.476] Resolving any globals that are futures ...
[10:21:47.476] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:47.477] Resolving any globals that are futures ... DONE
[10:21:47.477] Resolving futures part of globals (recursively) ...
[10:21:47.477] resolve() on list ...
[10:21:47.477]  recursive: 99
[10:21:47.477]  length: 1
[10:21:47.477]  elements: ‘a’
[10:21:47.519] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.519] - Validating connection of MultisessionFuture
[10:21:47.519] - received message: FutureResult
[10:21:47.520] - Received FutureResult
[10:21:47.520] - Erased future from FutureRegistry
[10:21:47.520] result() for ClusterFuture ...
[10:21:47.520] - result already collected: FutureResult
[10:21:47.520] result() for ClusterFuture ... done
[10:21:47.520] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.520] Future #1
[10:21:47.520] result() for ClusterFuture ...
[10:21:47.520] - result already collected: FutureResult
[10:21:47.520] result() for ClusterFuture ... done
[10:21:47.520] result() for ClusterFuture ...
[10:21:47.521] - result already collected: FutureResult
[10:21:47.521] result() for ClusterFuture ... done
[10:21:47.521] A MultisessionFuture was resolved
[10:21:47.521]  length: 0 (resolved future 1)
[10:21:47.521] resolve() on list ... DONE
[10:21:47.521] - globals: [1] ‘a’
[10:21:47.521] Resolving futures part of globals (recursively) ... DONE
[10:21:47.532] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[10:21:47.532] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[10:21:47.532] - globals: [1] ‘a’
[10:21:47.532] - packages: [1] ‘future’
[10:21:47.533] getGlobalsAndPackages() ... DONE
[10:21:47.533] run() for ‘Future’ ...
[10:21:47.533] - state: ‘created’
[10:21:47.533] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.546] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.547]   - Field: ‘node’
[10:21:47.547]   - Field: ‘label’
[10:21:47.547]   - Field: ‘local’
[10:21:47.547]   - Field: ‘owner’
[10:21:47.547]   - Field: ‘envir’
[10:21:47.547]   - Field: ‘workers’
[10:21:47.547]   - Field: ‘packages’
[10:21:47.547]   - Field: ‘gc’
[10:21:47.547]   - Field: ‘conditions’
[10:21:47.548]   - Field: ‘persistent’
[10:21:47.548]   - Field: ‘expr’
[10:21:47.548]   - Field: ‘uuid’
[10:21:47.548]   - Field: ‘seed’
[10:21:47.548]   - Field: ‘version’
[10:21:47.548]   - Field: ‘result’
[10:21:47.548]   - Field: ‘asynchronous’
[10:21:47.548]   - Field: ‘calls’
[10:21:47.548]   - Field: ‘globals’
[10:21:47.548]   - Field: ‘stdout’
[10:21:47.548]   - Field: ‘earlySignal’
[10:21:47.548]   - Field: ‘lazy’
[10:21:47.549]   - Field: ‘state’
[10:21:47.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.549] - Launch lazy future ...
[10:21:47.549] Packages needed by the future expression (n = 1): ‘future’
[10:21:47.549] Packages needed by future strategies (n = 0): <none>
[10:21:47.550] {
[10:21:47.550]     {
[10:21:47.550]         {
[10:21:47.550]             ...future.startTime <- base::Sys.time()
[10:21:47.550]             {
[10:21:47.550]                 {
[10:21:47.550]                   {
[10:21:47.550]                     {
[10:21:47.550]                       {
[10:21:47.550]                         base::local({
[10:21:47.550]                           has_future <- base::requireNamespace("future", 
[10:21:47.550]                             quietly = TRUE)
[10:21:47.550]                           if (has_future) {
[10:21:47.550]                             ns <- base::getNamespace("future")
[10:21:47.550]                             version <- ns[[".package"]][["version"]]
[10:21:47.550]                             if (is.null(version)) 
[10:21:47.550]                               version <- utils::packageVersion("future")
[10:21:47.550]                           }
[10:21:47.550]                           else {
[10:21:47.550]                             version <- NULL
[10:21:47.550]                           }
[10:21:47.550]                           if (!has_future || version < "1.8.0") {
[10:21:47.550]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.550]                               "", base::R.version$version.string), 
[10:21:47.550]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:47.550]                                 base::R.version$platform, 8 * 
[10:21:47.550]                                   base::.Machine$sizeof.pointer), 
[10:21:47.550]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.550]                                 "release", "version")], collapse = " "), 
[10:21:47.550]                               hostname = base::Sys.info()[["nodename"]])
[10:21:47.550]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.550]                               info)
[10:21:47.550]                             info <- base::paste(info, collapse = "; ")
[10:21:47.550]                             if (!has_future) {
[10:21:47.550]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.550]                                 info)
[10:21:47.550]                             }
[10:21:47.550]                             else {
[10:21:47.550]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.550]                                 info, version)
[10:21:47.550]                             }
[10:21:47.550]                             base::stop(msg)
[10:21:47.550]                           }
[10:21:47.550]                         })
[10:21:47.550]                       }
[10:21:47.550]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.550]                       base::options(mc.cores = 1L)
[10:21:47.550]                     }
[10:21:47.550]                     base::local({
[10:21:47.550]                       for (pkg in "future") {
[10:21:47.550]                         base::loadNamespace(pkg)
[10:21:47.550]                         base::library(pkg, character.only = TRUE)
[10:21:47.550]                       }
[10:21:47.550]                     })
[10:21:47.550]                   }
[10:21:47.550]                   ...future.strategy.old <- future::plan("list")
[10:21:47.550]                   options(future.plan = NULL)
[10:21:47.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.550]                 }
[10:21:47.550]                 ...future.workdir <- getwd()
[10:21:47.550]             }
[10:21:47.550]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.550]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.550]         }
[10:21:47.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.550]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.550]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.550]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.550]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.550]             base::names(...future.oldOptions))
[10:21:47.550]     }
[10:21:47.550]     if (FALSE) {
[10:21:47.550]     }
[10:21:47.550]     else {
[10:21:47.550]         if (TRUE) {
[10:21:47.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.550]                 open = "w")
[10:21:47.550]         }
[10:21:47.550]         else {
[10:21:47.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.550]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.550]         }
[10:21:47.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.550]             base::sink(type = "output", split = FALSE)
[10:21:47.550]             base::close(...future.stdout)
[10:21:47.550]         }, add = TRUE)
[10:21:47.550]     }
[10:21:47.550]     ...future.frame <- base::sys.nframe()
[10:21:47.550]     ...future.conditions <- base::list()
[10:21:47.550]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.550]     if (FALSE) {
[10:21:47.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.550]     }
[10:21:47.550]     ...future.result <- base::tryCatch({
[10:21:47.550]         base::withCallingHandlers({
[10:21:47.550]             ...future.value <- base::withVisible(base::local({
[10:21:47.550]                 ...future.makeSendCondition <- base::local({
[10:21:47.550]                   sendCondition <- NULL
[10:21:47.550]                   function(frame = 1L) {
[10:21:47.550]                     if (is.function(sendCondition)) 
[10:21:47.550]                       return(sendCondition)
[10:21:47.550]                     ns <- getNamespace("parallel")
[10:21:47.550]                     if (exists("sendData", mode = "function", 
[10:21:47.550]                       envir = ns)) {
[10:21:47.550]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.550]                         envir = ns)
[10:21:47.550]                       envir <- sys.frame(frame)
[10:21:47.550]                       master <- NULL
[10:21:47.550]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.550]                         !identical(envir, emptyenv())) {
[10:21:47.550]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.550]                           inherits = FALSE)) {
[10:21:47.550]                           master <- get("master", mode = "list", 
[10:21:47.550]                             envir = envir, inherits = FALSE)
[10:21:47.550]                           if (inherits(master, c("SOCKnode", 
[10:21:47.550]                             "SOCK0node"))) {
[10:21:47.550]                             sendCondition <<- function(cond) {
[10:21:47.550]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.550]                                 success = TRUE)
[10:21:47.550]                               parallel_sendData(master, data)
[10:21:47.550]                             }
[10:21:47.550]                             return(sendCondition)
[10:21:47.550]                           }
[10:21:47.550]                         }
[10:21:47.550]                         frame <- frame + 1L
[10:21:47.550]                         envir <- sys.frame(frame)
[10:21:47.550]                       }
[10:21:47.550]                     }
[10:21:47.550]                     sendCondition <<- function(cond) NULL
[10:21:47.550]                   }
[10:21:47.550]                 })
[10:21:47.550]                 withCallingHandlers({
[10:21:47.550]                   value(a) + 1
[10:21:47.550]                 }, immediateCondition = function(cond) {
[10:21:47.550]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.550]                   sendCondition(cond)
[10:21:47.550]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.550]                   {
[10:21:47.550]                     inherits <- base::inherits
[10:21:47.550]                     invokeRestart <- base::invokeRestart
[10:21:47.550]                     is.null <- base::is.null
[10:21:47.550]                     muffled <- FALSE
[10:21:47.550]                     if (inherits(cond, "message")) {
[10:21:47.550]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.550]                       if (muffled) 
[10:21:47.550]                         invokeRestart("muffleMessage")
[10:21:47.550]                     }
[10:21:47.550]                     else if (inherits(cond, "warning")) {
[10:21:47.550]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.550]                       if (muffled) 
[10:21:47.550]                         invokeRestart("muffleWarning")
[10:21:47.550]                     }
[10:21:47.550]                     else if (inherits(cond, "condition")) {
[10:21:47.550]                       if (!is.null(pattern)) {
[10:21:47.550]                         computeRestarts <- base::computeRestarts
[10:21:47.550]                         grepl <- base::grepl
[10:21:47.550]                         restarts <- computeRestarts(cond)
[10:21:47.550]                         for (restart in restarts) {
[10:21:47.550]                           name <- restart$name
[10:21:47.550]                           if (is.null(name)) 
[10:21:47.550]                             next
[10:21:47.550]                           if (!grepl(pattern, name)) 
[10:21:47.550]                             next
[10:21:47.550]                           invokeRestart(restart)
[10:21:47.550]                           muffled <- TRUE
[10:21:47.550]                           break
[10:21:47.550]                         }
[10:21:47.550]                       }
[10:21:47.550]                     }
[10:21:47.550]                     invisible(muffled)
[10:21:47.550]                   }
[10:21:47.550]                   muffleCondition(cond)
[10:21:47.550]                 })
[10:21:47.550]             }))
[10:21:47.550]             future::FutureResult(value = ...future.value$value, 
[10:21:47.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.550]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.550]                     ...future.globalenv.names))
[10:21:47.550]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.550]         }, condition = base::local({
[10:21:47.550]             c <- base::c
[10:21:47.550]             inherits <- base::inherits
[10:21:47.550]             invokeRestart <- base::invokeRestart
[10:21:47.550]             length <- base::length
[10:21:47.550]             list <- base::list
[10:21:47.550]             seq.int <- base::seq.int
[10:21:47.550]             signalCondition <- base::signalCondition
[10:21:47.550]             sys.calls <- base::sys.calls
[10:21:47.550]             `[[` <- base::`[[`
[10:21:47.550]             `+` <- base::`+`
[10:21:47.550]             `<<-` <- base::`<<-`
[10:21:47.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.550]                   3L)]
[10:21:47.550]             }
[10:21:47.550]             function(cond) {
[10:21:47.550]                 is_error <- inherits(cond, "error")
[10:21:47.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.550]                   NULL)
[10:21:47.550]                 if (is_error) {
[10:21:47.550]                   sessionInformation <- function() {
[10:21:47.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.550]                       search = base::search(), system = base::Sys.info())
[10:21:47.550]                   }
[10:21:47.550]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.550]                     cond$call), session = sessionInformation(), 
[10:21:47.550]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.550]                   signalCondition(cond)
[10:21:47.550]                 }
[10:21:47.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.550]                 "immediateCondition"))) {
[10:21:47.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.550]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.550]                   if (TRUE && !signal) {
[10:21:47.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.550]                     {
[10:21:47.550]                       inherits <- base::inherits
[10:21:47.550]                       invokeRestart <- base::invokeRestart
[10:21:47.550]                       is.null <- base::is.null
[10:21:47.550]                       muffled <- FALSE
[10:21:47.550]                       if (inherits(cond, "message")) {
[10:21:47.550]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.550]                         if (muffled) 
[10:21:47.550]                           invokeRestart("muffleMessage")
[10:21:47.550]                       }
[10:21:47.550]                       else if (inherits(cond, "warning")) {
[10:21:47.550]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.550]                         if (muffled) 
[10:21:47.550]                           invokeRestart("muffleWarning")
[10:21:47.550]                       }
[10:21:47.550]                       else if (inherits(cond, "condition")) {
[10:21:47.550]                         if (!is.null(pattern)) {
[10:21:47.550]                           computeRestarts <- base::computeRestarts
[10:21:47.550]                           grepl <- base::grepl
[10:21:47.550]                           restarts <- computeRestarts(cond)
[10:21:47.550]                           for (restart in restarts) {
[10:21:47.550]                             name <- restart$name
[10:21:47.550]                             if (is.null(name)) 
[10:21:47.550]                               next
[10:21:47.550]                             if (!grepl(pattern, name)) 
[10:21:47.550]                               next
[10:21:47.550]                             invokeRestart(restart)
[10:21:47.550]                             muffled <- TRUE
[10:21:47.550]                             break
[10:21:47.550]                           }
[10:21:47.550]                         }
[10:21:47.550]                       }
[10:21:47.550]                       invisible(muffled)
[10:21:47.550]                     }
[10:21:47.550]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.550]                   }
[10:21:47.550]                 }
[10:21:47.550]                 else {
[10:21:47.550]                   if (TRUE) {
[10:21:47.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.550]                     {
[10:21:47.550]                       inherits <- base::inherits
[10:21:47.550]                       invokeRestart <- base::invokeRestart
[10:21:47.550]                       is.null <- base::is.null
[10:21:47.550]                       muffled <- FALSE
[10:21:47.550]                       if (inherits(cond, "message")) {
[10:21:47.550]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.550]                         if (muffled) 
[10:21:47.550]                           invokeRestart("muffleMessage")
[10:21:47.550]                       }
[10:21:47.550]                       else if (inherits(cond, "warning")) {
[10:21:47.550]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.550]                         if (muffled) 
[10:21:47.550]                           invokeRestart("muffleWarning")
[10:21:47.550]                       }
[10:21:47.550]                       else if (inherits(cond, "condition")) {
[10:21:47.550]                         if (!is.null(pattern)) {
[10:21:47.550]                           computeRestarts <- base::computeRestarts
[10:21:47.550]                           grepl <- base::grepl
[10:21:47.550]                           restarts <- computeRestarts(cond)
[10:21:47.550]                           for (restart in restarts) {
[10:21:47.550]                             name <- restart$name
[10:21:47.550]                             if (is.null(name)) 
[10:21:47.550]                               next
[10:21:47.550]                             if (!grepl(pattern, name)) 
[10:21:47.550]                               next
[10:21:47.550]                             invokeRestart(restart)
[10:21:47.550]                             muffled <- TRUE
[10:21:47.550]                             break
[10:21:47.550]                           }
[10:21:47.550]                         }
[10:21:47.550]                       }
[10:21:47.550]                       invisible(muffled)
[10:21:47.550]                     }
[10:21:47.550]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.550]                   }
[10:21:47.550]                 }
[10:21:47.550]             }
[10:21:47.550]         }))
[10:21:47.550]     }, error = function(ex) {
[10:21:47.550]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.550]                 ...future.rng), started = ...future.startTime, 
[10:21:47.550]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.550]             version = "1.8"), class = "FutureResult")
[10:21:47.550]     }, finally = {
[10:21:47.550]         if (!identical(...future.workdir, getwd())) 
[10:21:47.550]             setwd(...future.workdir)
[10:21:47.550]         {
[10:21:47.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.550]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.550]             }
[10:21:47.550]             base::options(...future.oldOptions)
[10:21:47.550]             if (.Platform$OS.type == "windows") {
[10:21:47.550]                 old_names <- names(...future.oldEnvVars)
[10:21:47.550]                 envs <- base::Sys.getenv()
[10:21:47.550]                 names <- names(envs)
[10:21:47.550]                 common <- intersect(names, old_names)
[10:21:47.550]                 added <- setdiff(names, old_names)
[10:21:47.550]                 removed <- setdiff(old_names, names)
[10:21:47.550]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.550]                   envs[common]]
[10:21:47.550]                 NAMES <- toupper(changed)
[10:21:47.550]                 args <- list()
[10:21:47.550]                 for (kk in seq_along(NAMES)) {
[10:21:47.550]                   name <- changed[[kk]]
[10:21:47.550]                   NAME <- NAMES[[kk]]
[10:21:47.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.550]                     next
[10:21:47.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.550]                 }
[10:21:47.550]                 NAMES <- toupper(added)
[10:21:47.550]                 for (kk in seq_along(NAMES)) {
[10:21:47.550]                   name <- added[[kk]]
[10:21:47.550]                   NAME <- NAMES[[kk]]
[10:21:47.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.550]                     next
[10:21:47.550]                   args[[name]] <- ""
[10:21:47.550]                 }
[10:21:47.550]                 NAMES <- toupper(removed)
[10:21:47.550]                 for (kk in seq_along(NAMES)) {
[10:21:47.550]                   name <- removed[[kk]]
[10:21:47.550]                   NAME <- NAMES[[kk]]
[10:21:47.550]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.550]                     next
[10:21:47.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.550]                 }
[10:21:47.550]                 if (length(args) > 0) 
[10:21:47.550]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.550]             }
[10:21:47.550]             else {
[10:21:47.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.550]             }
[10:21:47.550]             {
[10:21:47.550]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.550]                   0L) {
[10:21:47.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.550]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.550]                   base::options(opts)
[10:21:47.550]                 }
[10:21:47.550]                 {
[10:21:47.550]                   {
[10:21:47.550]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.550]                     NULL
[10:21:47.550]                   }
[10:21:47.550]                   options(future.plan = NULL)
[10:21:47.550]                   if (is.na(NA_character_)) 
[10:21:47.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.550]                     .init = FALSE)
[10:21:47.550]                 }
[10:21:47.550]             }
[10:21:47.550]         }
[10:21:47.550]     })
[10:21:47.550]     if (TRUE) {
[10:21:47.550]         base::sink(type = "output", split = FALSE)
[10:21:47.550]         if (TRUE) {
[10:21:47.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.550]         }
[10:21:47.550]         else {
[10:21:47.550]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.550]         }
[10:21:47.550]         base::close(...future.stdout)
[10:21:47.550]         ...future.stdout <- NULL
[10:21:47.550]     }
[10:21:47.550]     ...future.result$conditions <- ...future.conditions
[10:21:47.550]     ...future.result$finished <- base::Sys.time()
[10:21:47.550]     ...future.result
[10:21:47.550] }
[10:21:47.563] Exporting 1 global objects (313.44 KiB) to cluster node #1 ...
[10:21:47.574] Exporting ‘a’ (313.23 KiB) to cluster node #1 ...
[10:21:47.626] Exporting ‘a’ (313.23 KiB) to cluster node #1 ... DONE
[10:21:47.626] Exporting 1 global objects (313.44 KiB) to cluster node #1 ... DONE
[10:21:47.627] MultisessionFuture started
[10:21:47.627] - Launch lazy future ... done
[10:21:47.627] run() for ‘MultisessionFuture’ ... done
[10:21:47.627] result() for ClusterFuture ...
[10:21:47.627] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.627] - Validating connection of MultisessionFuture
[10:21:47.669] - received message: FutureResult
[10:21:47.670] - Received FutureResult
[10:21:47.670] - Erased future from FutureRegistry
[10:21:47.670] result() for ClusterFuture ...
[10:21:47.670] - result already collected: FutureResult
[10:21:47.670] result() for ClusterFuture ... done
[10:21:47.670] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.670] result() for ClusterFuture ... done
[10:21:47.670] result() for ClusterFuture ...
[10:21:47.670] - result already collected: FutureResult
[10:21:47.671] result() for ClusterFuture ... done
value(b) = 2
[10:21:47.671] result() for ClusterFuture ...
[10:21:47.671] - result already collected: FutureResult
[10:21:47.671] result() for ClusterFuture ... done
[10:21:47.671] result() for ClusterFuture ...
[10:21:47.671] - result already collected: FutureResult
[10:21:47.671] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.671] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.672] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.672] 
[10:21:47.672] Searching for globals ... DONE
[10:21:47.672] - globals: [0] <none>
[10:21:47.672] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.673] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.673] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.674] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:47.674] Searching for globals ... DONE
[10:21:47.674] Resolving globals: TRUE
[10:21:47.674] Resolving any globals that are futures ...
[10:21:47.674] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:47.674] Resolving any globals that are futures ... DONE
[10:21:47.674] Resolving futures part of globals (recursively) ...
[10:21:47.675] resolve() on list ...
[10:21:47.675]  recursive: 99
[10:21:47.675]  length: 1
[10:21:47.675]  elements: ‘a’
[10:21:47.675] run() for ‘Future’ ...
[10:21:47.675] - state: ‘created’
[10:21:47.675] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.689] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.689] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.690]   - Field: ‘node’
[10:21:47.690]   - Field: ‘label’
[10:21:47.690]   - Field: ‘local’
[10:21:47.690]   - Field: ‘owner’
[10:21:47.690]   - Field: ‘envir’
[10:21:47.690]   - Field: ‘workers’
[10:21:47.690]   - Field: ‘packages’
[10:21:47.690]   - Field: ‘gc’
[10:21:47.690]   - Field: ‘conditions’
[10:21:47.690]   - Field: ‘persistent’
[10:21:47.690]   - Field: ‘expr’
[10:21:47.691]   - Field: ‘uuid’
[10:21:47.691]   - Field: ‘seed’
[10:21:47.691]   - Field: ‘version’
[10:21:47.691]   - Field: ‘result’
[10:21:47.691]   - Field: ‘asynchronous’
[10:21:47.691]   - Field: ‘calls’
[10:21:47.691]   - Field: ‘globals’
[10:21:47.691]   - Field: ‘stdout’
[10:21:47.691]   - Field: ‘earlySignal’
[10:21:47.691]   - Field: ‘lazy’
[10:21:47.691]   - Field: ‘state’
[10:21:47.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.692] - Launch lazy future ...
[10:21:47.692] Packages needed by the future expression (n = 0): <none>
[10:21:47.692] Packages needed by future strategies (n = 0): <none>
[10:21:47.692] {
[10:21:47.692]     {
[10:21:47.692]         {
[10:21:47.692]             ...future.startTime <- base::Sys.time()
[10:21:47.692]             {
[10:21:47.692]                 {
[10:21:47.692]                   {
[10:21:47.692]                     {
[10:21:47.692]                       base::local({
[10:21:47.692]                         has_future <- base::requireNamespace("future", 
[10:21:47.692]                           quietly = TRUE)
[10:21:47.692]                         if (has_future) {
[10:21:47.692]                           ns <- base::getNamespace("future")
[10:21:47.692]                           version <- ns[[".package"]][["version"]]
[10:21:47.692]                           if (is.null(version)) 
[10:21:47.692]                             version <- utils::packageVersion("future")
[10:21:47.692]                         }
[10:21:47.692]                         else {
[10:21:47.692]                           version <- NULL
[10:21:47.692]                         }
[10:21:47.692]                         if (!has_future || version < "1.8.0") {
[10:21:47.692]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.692]                             "", base::R.version$version.string), 
[10:21:47.692]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:47.692]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:47.692]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.692]                               "release", "version")], collapse = " "), 
[10:21:47.692]                             hostname = base::Sys.info()[["nodename"]])
[10:21:47.692]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.692]                             info)
[10:21:47.692]                           info <- base::paste(info, collapse = "; ")
[10:21:47.692]                           if (!has_future) {
[10:21:47.692]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.692]                               info)
[10:21:47.692]                           }
[10:21:47.692]                           else {
[10:21:47.692]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.692]                               info, version)
[10:21:47.692]                           }
[10:21:47.692]                           base::stop(msg)
[10:21:47.692]                         }
[10:21:47.692]                       })
[10:21:47.692]                     }
[10:21:47.692]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.692]                     base::options(mc.cores = 1L)
[10:21:47.692]                   }
[10:21:47.692]                   ...future.strategy.old <- future::plan("list")
[10:21:47.692]                   options(future.plan = NULL)
[10:21:47.692]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.692]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.692]                 }
[10:21:47.692]                 ...future.workdir <- getwd()
[10:21:47.692]             }
[10:21:47.692]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.692]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.692]         }
[10:21:47.692]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.692]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.692]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.692]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.692]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.692]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.692]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.692]             base::names(...future.oldOptions))
[10:21:47.692]     }
[10:21:47.692]     if (FALSE) {
[10:21:47.692]     }
[10:21:47.692]     else {
[10:21:47.692]         if (TRUE) {
[10:21:47.692]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.692]                 open = "w")
[10:21:47.692]         }
[10:21:47.692]         else {
[10:21:47.692]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.692]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.692]         }
[10:21:47.692]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.692]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.692]             base::sink(type = "output", split = FALSE)
[10:21:47.692]             base::close(...future.stdout)
[10:21:47.692]         }, add = TRUE)
[10:21:47.692]     }
[10:21:47.692]     ...future.frame <- base::sys.nframe()
[10:21:47.692]     ...future.conditions <- base::list()
[10:21:47.692]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.692]     if (FALSE) {
[10:21:47.692]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.692]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.692]     }
[10:21:47.692]     ...future.result <- base::tryCatch({
[10:21:47.692]         base::withCallingHandlers({
[10:21:47.692]             ...future.value <- base::withVisible(base::local({
[10:21:47.692]                 ...future.makeSendCondition <- base::local({
[10:21:47.692]                   sendCondition <- NULL
[10:21:47.692]                   function(frame = 1L) {
[10:21:47.692]                     if (is.function(sendCondition)) 
[10:21:47.692]                       return(sendCondition)
[10:21:47.692]                     ns <- getNamespace("parallel")
[10:21:47.692]                     if (exists("sendData", mode = "function", 
[10:21:47.692]                       envir = ns)) {
[10:21:47.692]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.692]                         envir = ns)
[10:21:47.692]                       envir <- sys.frame(frame)
[10:21:47.692]                       master <- NULL
[10:21:47.692]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.692]                         !identical(envir, emptyenv())) {
[10:21:47.692]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.692]                           inherits = FALSE)) {
[10:21:47.692]                           master <- get("master", mode = "list", 
[10:21:47.692]                             envir = envir, inherits = FALSE)
[10:21:47.692]                           if (inherits(master, c("SOCKnode", 
[10:21:47.692]                             "SOCK0node"))) {
[10:21:47.692]                             sendCondition <<- function(cond) {
[10:21:47.692]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.692]                                 success = TRUE)
[10:21:47.692]                               parallel_sendData(master, data)
[10:21:47.692]                             }
[10:21:47.692]                             return(sendCondition)
[10:21:47.692]                           }
[10:21:47.692]                         }
[10:21:47.692]                         frame <- frame + 1L
[10:21:47.692]                         envir <- sys.frame(frame)
[10:21:47.692]                       }
[10:21:47.692]                     }
[10:21:47.692]                     sendCondition <<- function(cond) NULL
[10:21:47.692]                   }
[10:21:47.692]                 })
[10:21:47.692]                 withCallingHandlers({
[10:21:47.692]                   1
[10:21:47.692]                 }, immediateCondition = function(cond) {
[10:21:47.692]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.692]                   sendCondition(cond)
[10:21:47.692]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.692]                   {
[10:21:47.692]                     inherits <- base::inherits
[10:21:47.692]                     invokeRestart <- base::invokeRestart
[10:21:47.692]                     is.null <- base::is.null
[10:21:47.692]                     muffled <- FALSE
[10:21:47.692]                     if (inherits(cond, "message")) {
[10:21:47.692]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.692]                       if (muffled) 
[10:21:47.692]                         invokeRestart("muffleMessage")
[10:21:47.692]                     }
[10:21:47.692]                     else if (inherits(cond, "warning")) {
[10:21:47.692]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.692]                       if (muffled) 
[10:21:47.692]                         invokeRestart("muffleWarning")
[10:21:47.692]                     }
[10:21:47.692]                     else if (inherits(cond, "condition")) {
[10:21:47.692]                       if (!is.null(pattern)) {
[10:21:47.692]                         computeRestarts <- base::computeRestarts
[10:21:47.692]                         grepl <- base::grepl
[10:21:47.692]                         restarts <- computeRestarts(cond)
[10:21:47.692]                         for (restart in restarts) {
[10:21:47.692]                           name <- restart$name
[10:21:47.692]                           if (is.null(name)) 
[10:21:47.692]                             next
[10:21:47.692]                           if (!grepl(pattern, name)) 
[10:21:47.692]                             next
[10:21:47.692]                           invokeRestart(restart)
[10:21:47.692]                           muffled <- TRUE
[10:21:47.692]                           break
[10:21:47.692]                         }
[10:21:47.692]                       }
[10:21:47.692]                     }
[10:21:47.692]                     invisible(muffled)
[10:21:47.692]                   }
[10:21:47.692]                   muffleCondition(cond)
[10:21:47.692]                 })
[10:21:47.692]             }))
[10:21:47.692]             future::FutureResult(value = ...future.value$value, 
[10:21:47.692]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.692]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.692]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.692]                     ...future.globalenv.names))
[10:21:47.692]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.692]         }, condition = base::local({
[10:21:47.692]             c <- base::c
[10:21:47.692]             inherits <- base::inherits
[10:21:47.692]             invokeRestart <- base::invokeRestart
[10:21:47.692]             length <- base::length
[10:21:47.692]             list <- base::list
[10:21:47.692]             seq.int <- base::seq.int
[10:21:47.692]             signalCondition <- base::signalCondition
[10:21:47.692]             sys.calls <- base::sys.calls
[10:21:47.692]             `[[` <- base::`[[`
[10:21:47.692]             `+` <- base::`+`
[10:21:47.692]             `<<-` <- base::`<<-`
[10:21:47.692]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.692]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.692]                   3L)]
[10:21:47.692]             }
[10:21:47.692]             function(cond) {
[10:21:47.692]                 is_error <- inherits(cond, "error")
[10:21:47.692]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.692]                   NULL)
[10:21:47.692]                 if (is_error) {
[10:21:47.692]                   sessionInformation <- function() {
[10:21:47.692]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.692]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.692]                       search = base::search(), system = base::Sys.info())
[10:21:47.692]                   }
[10:21:47.692]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.692]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.692]                     cond$call), session = sessionInformation(), 
[10:21:47.692]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.692]                   signalCondition(cond)
[10:21:47.692]                 }
[10:21:47.692]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.692]                 "immediateCondition"))) {
[10:21:47.692]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.692]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.692]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.692]                   if (TRUE && !signal) {
[10:21:47.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.692]                     {
[10:21:47.692]                       inherits <- base::inherits
[10:21:47.692]                       invokeRestart <- base::invokeRestart
[10:21:47.692]                       is.null <- base::is.null
[10:21:47.692]                       muffled <- FALSE
[10:21:47.692]                       if (inherits(cond, "message")) {
[10:21:47.692]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.692]                         if (muffled) 
[10:21:47.692]                           invokeRestart("muffleMessage")
[10:21:47.692]                       }
[10:21:47.692]                       else if (inherits(cond, "warning")) {
[10:21:47.692]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.692]                         if (muffled) 
[10:21:47.692]                           invokeRestart("muffleWarning")
[10:21:47.692]                       }
[10:21:47.692]                       else if (inherits(cond, "condition")) {
[10:21:47.692]                         if (!is.null(pattern)) {
[10:21:47.692]                           computeRestarts <- base::computeRestarts
[10:21:47.692]                           grepl <- base::grepl
[10:21:47.692]                           restarts <- computeRestarts(cond)
[10:21:47.692]                           for (restart in restarts) {
[10:21:47.692]                             name <- restart$name
[10:21:47.692]                             if (is.null(name)) 
[10:21:47.692]                               next
[10:21:47.692]                             if (!grepl(pattern, name)) 
[10:21:47.692]                               next
[10:21:47.692]                             invokeRestart(restart)
[10:21:47.692]                             muffled <- TRUE
[10:21:47.692]                             break
[10:21:47.692]                           }
[10:21:47.692]                         }
[10:21:47.692]                       }
[10:21:47.692]                       invisible(muffled)
[10:21:47.692]                     }
[10:21:47.692]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.692]                   }
[10:21:47.692]                 }
[10:21:47.692]                 else {
[10:21:47.692]                   if (TRUE) {
[10:21:47.692]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.692]                     {
[10:21:47.692]                       inherits <- base::inherits
[10:21:47.692]                       invokeRestart <- base::invokeRestart
[10:21:47.692]                       is.null <- base::is.null
[10:21:47.692]                       muffled <- FALSE
[10:21:47.692]                       if (inherits(cond, "message")) {
[10:21:47.692]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.692]                         if (muffled) 
[10:21:47.692]                           invokeRestart("muffleMessage")
[10:21:47.692]                       }
[10:21:47.692]                       else if (inherits(cond, "warning")) {
[10:21:47.692]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.692]                         if (muffled) 
[10:21:47.692]                           invokeRestart("muffleWarning")
[10:21:47.692]                       }
[10:21:47.692]                       else if (inherits(cond, "condition")) {
[10:21:47.692]                         if (!is.null(pattern)) {
[10:21:47.692]                           computeRestarts <- base::computeRestarts
[10:21:47.692]                           grepl <- base::grepl
[10:21:47.692]                           restarts <- computeRestarts(cond)
[10:21:47.692]                           for (restart in restarts) {
[10:21:47.692]                             name <- restart$name
[10:21:47.692]                             if (is.null(name)) 
[10:21:47.692]                               next
[10:21:47.692]                             if (!grepl(pattern, name)) 
[10:21:47.692]                               next
[10:21:47.692]                             invokeRestart(restart)
[10:21:47.692]                             muffled <- TRUE
[10:21:47.692]                             break
[10:21:47.692]                           }
[10:21:47.692]                         }
[10:21:47.692]                       }
[10:21:47.692]                       invisible(muffled)
[10:21:47.692]                     }
[10:21:47.692]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.692]                   }
[10:21:47.692]                 }
[10:21:47.692]             }
[10:21:47.692]         }))
[10:21:47.692]     }, error = function(ex) {
[10:21:47.692]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.692]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.692]                 ...future.rng), started = ...future.startTime, 
[10:21:47.692]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.692]             version = "1.8"), class = "FutureResult")
[10:21:47.692]     }, finally = {
[10:21:47.692]         if (!identical(...future.workdir, getwd())) 
[10:21:47.692]             setwd(...future.workdir)
[10:21:47.692]         {
[10:21:47.692]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.692]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.692]             }
[10:21:47.692]             base::options(...future.oldOptions)
[10:21:47.692]             if (.Platform$OS.type == "windows") {
[10:21:47.692]                 old_names <- names(...future.oldEnvVars)
[10:21:47.692]                 envs <- base::Sys.getenv()
[10:21:47.692]                 names <- names(envs)
[10:21:47.692]                 common <- intersect(names, old_names)
[10:21:47.692]                 added <- setdiff(names, old_names)
[10:21:47.692]                 removed <- setdiff(old_names, names)
[10:21:47.692]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.692]                   envs[common]]
[10:21:47.692]                 NAMES <- toupper(changed)
[10:21:47.692]                 args <- list()
[10:21:47.692]                 for (kk in seq_along(NAMES)) {
[10:21:47.692]                   name <- changed[[kk]]
[10:21:47.692]                   NAME <- NAMES[[kk]]
[10:21:47.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.692]                     next
[10:21:47.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.692]                 }
[10:21:47.692]                 NAMES <- toupper(added)
[10:21:47.692]                 for (kk in seq_along(NAMES)) {
[10:21:47.692]                   name <- added[[kk]]
[10:21:47.692]                   NAME <- NAMES[[kk]]
[10:21:47.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.692]                     next
[10:21:47.692]                   args[[name]] <- ""
[10:21:47.692]                 }
[10:21:47.692]                 NAMES <- toupper(removed)
[10:21:47.692]                 for (kk in seq_along(NAMES)) {
[10:21:47.692]                   name <- removed[[kk]]
[10:21:47.692]                   NAME <- NAMES[[kk]]
[10:21:47.692]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.692]                     next
[10:21:47.692]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.692]                 }
[10:21:47.692]                 if (length(args) > 0) 
[10:21:47.692]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.692]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.692]             }
[10:21:47.692]             else {
[10:21:47.692]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.692]             }
[10:21:47.692]             {
[10:21:47.692]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.692]                   0L) {
[10:21:47.692]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.692]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.692]                   base::options(opts)
[10:21:47.692]                 }
[10:21:47.692]                 {
[10:21:47.692]                   {
[10:21:47.692]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.692]                     NULL
[10:21:47.692]                   }
[10:21:47.692]                   options(future.plan = NULL)
[10:21:47.692]                   if (is.na(NA_character_)) 
[10:21:47.692]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.692]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.692]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.692]                     .init = FALSE)
[10:21:47.692]                 }
[10:21:47.692]             }
[10:21:47.692]         }
[10:21:47.692]     })
[10:21:47.692]     if (TRUE) {
[10:21:47.692]         base::sink(type = "output", split = FALSE)
[10:21:47.692]         if (TRUE) {
[10:21:47.692]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.692]         }
[10:21:47.692]         else {
[10:21:47.692]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.692]         }
[10:21:47.692]         base::close(...future.stdout)
[10:21:47.692]         ...future.stdout <- NULL
[10:21:47.692]     }
[10:21:47.692]     ...future.result$conditions <- ...future.conditions
[10:21:47.692]     ...future.result$finished <- base::Sys.time()
[10:21:47.692]     ...future.result
[10:21:47.692] }
[10:21:47.696] MultisessionFuture started
[10:21:47.696] - Launch lazy future ... done
[10:21:47.696] run() for ‘MultisessionFuture’ ... done
[10:21:47.738] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.738] - Validating connection of MultisessionFuture
[10:21:47.738] - received message: FutureResult
[10:21:47.739] - Received FutureResult
[10:21:47.739] - Erased future from FutureRegistry
[10:21:47.739] result() for ClusterFuture ...
[10:21:47.739] - result already collected: FutureResult
[10:21:47.739] result() for ClusterFuture ... done
[10:21:47.739] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.739] Future #1
[10:21:47.739] result() for ClusterFuture ...
[10:21:47.739] - result already collected: FutureResult
[10:21:47.739] result() for ClusterFuture ... done
[10:21:47.740] result() for ClusterFuture ...
[10:21:47.740] - result already collected: FutureResult
[10:21:47.740] result() for ClusterFuture ... done
[10:21:47.740] A MultisessionFuture was resolved
[10:21:47.740]  length: 0 (resolved future 1)
[10:21:47.740] resolve() on list ... DONE
[10:21:47.740] - globals: [1] ‘a’
[10:21:47.740] Resolving futures part of globals (recursively) ... DONE
[10:21:47.751] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[10:21:47.752] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[10:21:47.752] - globals: [1] ‘a’
[10:21:47.752] - packages: [1] ‘future’
[10:21:47.752] getGlobalsAndPackages() ... DONE
[10:21:47.752] run() for ‘Future’ ...
[10:21:47.752] - state: ‘created’
[10:21:47.753] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.767] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.767]   - Field: ‘node’
[10:21:47.767]   - Field: ‘label’
[10:21:47.768]   - Field: ‘local’
[10:21:47.768]   - Field: ‘owner’
[10:21:47.768]   - Field: ‘envir’
[10:21:47.768]   - Field: ‘workers’
[10:21:47.768]   - Field: ‘packages’
[10:21:47.768]   - Field: ‘gc’
[10:21:47.768]   - Field: ‘conditions’
[10:21:47.768]   - Field: ‘persistent’
[10:21:47.768]   - Field: ‘expr’
[10:21:47.768]   - Field: ‘uuid’
[10:21:47.768]   - Field: ‘seed’
[10:21:47.768]   - Field: ‘version’
[10:21:47.769]   - Field: ‘result’
[10:21:47.769]   - Field: ‘asynchronous’
[10:21:47.769]   - Field: ‘calls’
[10:21:47.769]   - Field: ‘globals’
[10:21:47.769]   - Field: ‘stdout’
[10:21:47.769]   - Field: ‘earlySignal’
[10:21:47.769]   - Field: ‘lazy’
[10:21:47.769]   - Field: ‘state’
[10:21:47.772] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.772] - Launch lazy future ...
[10:21:47.772] Packages needed by the future expression (n = 1): ‘future’
[10:21:47.772] Packages needed by future strategies (n = 0): <none>
[10:21:47.773] {
[10:21:47.773]     {
[10:21:47.773]         {
[10:21:47.773]             ...future.startTime <- base::Sys.time()
[10:21:47.773]             {
[10:21:47.773]                 {
[10:21:47.773]                   {
[10:21:47.773]                     {
[10:21:47.773]                       {
[10:21:47.773]                         base::local({
[10:21:47.773]                           has_future <- base::requireNamespace("future", 
[10:21:47.773]                             quietly = TRUE)
[10:21:47.773]                           if (has_future) {
[10:21:47.773]                             ns <- base::getNamespace("future")
[10:21:47.773]                             version <- ns[[".package"]][["version"]]
[10:21:47.773]                             if (is.null(version)) 
[10:21:47.773]                               version <- utils::packageVersion("future")
[10:21:47.773]                           }
[10:21:47.773]                           else {
[10:21:47.773]                             version <- NULL
[10:21:47.773]                           }
[10:21:47.773]                           if (!has_future || version < "1.8.0") {
[10:21:47.773]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.773]                               "", base::R.version$version.string), 
[10:21:47.773]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:47.773]                                 base::R.version$platform, 8 * 
[10:21:47.773]                                   base::.Machine$sizeof.pointer), 
[10:21:47.773]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.773]                                 "release", "version")], collapse = " "), 
[10:21:47.773]                               hostname = base::Sys.info()[["nodename"]])
[10:21:47.773]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.773]                               info)
[10:21:47.773]                             info <- base::paste(info, collapse = "; ")
[10:21:47.773]                             if (!has_future) {
[10:21:47.773]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.773]                                 info)
[10:21:47.773]                             }
[10:21:47.773]                             else {
[10:21:47.773]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.773]                                 info, version)
[10:21:47.773]                             }
[10:21:47.773]                             base::stop(msg)
[10:21:47.773]                           }
[10:21:47.773]                         })
[10:21:47.773]                       }
[10:21:47.773]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.773]                       base::options(mc.cores = 1L)
[10:21:47.773]                     }
[10:21:47.773]                     base::local({
[10:21:47.773]                       for (pkg in "future") {
[10:21:47.773]                         base::loadNamespace(pkg)
[10:21:47.773]                         base::library(pkg, character.only = TRUE)
[10:21:47.773]                       }
[10:21:47.773]                     })
[10:21:47.773]                   }
[10:21:47.773]                   ...future.strategy.old <- future::plan("list")
[10:21:47.773]                   options(future.plan = NULL)
[10:21:47.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.773]                 }
[10:21:47.773]                 ...future.workdir <- getwd()
[10:21:47.773]             }
[10:21:47.773]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.773]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.773]         }
[10:21:47.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.773]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.773]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.773]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.773]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.773]             base::names(...future.oldOptions))
[10:21:47.773]     }
[10:21:47.773]     if (FALSE) {
[10:21:47.773]     }
[10:21:47.773]     else {
[10:21:47.773]         if (TRUE) {
[10:21:47.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.773]                 open = "w")
[10:21:47.773]         }
[10:21:47.773]         else {
[10:21:47.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.773]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.773]         }
[10:21:47.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.773]             base::sink(type = "output", split = FALSE)
[10:21:47.773]             base::close(...future.stdout)
[10:21:47.773]         }, add = TRUE)
[10:21:47.773]     }
[10:21:47.773]     ...future.frame <- base::sys.nframe()
[10:21:47.773]     ...future.conditions <- base::list()
[10:21:47.773]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.773]     if (FALSE) {
[10:21:47.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.773]     }
[10:21:47.773]     ...future.result <- base::tryCatch({
[10:21:47.773]         base::withCallingHandlers({
[10:21:47.773]             ...future.value <- base::withVisible(base::local({
[10:21:47.773]                 ...future.makeSendCondition <- base::local({
[10:21:47.773]                   sendCondition <- NULL
[10:21:47.773]                   function(frame = 1L) {
[10:21:47.773]                     if (is.function(sendCondition)) 
[10:21:47.773]                       return(sendCondition)
[10:21:47.773]                     ns <- getNamespace("parallel")
[10:21:47.773]                     if (exists("sendData", mode = "function", 
[10:21:47.773]                       envir = ns)) {
[10:21:47.773]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.773]                         envir = ns)
[10:21:47.773]                       envir <- sys.frame(frame)
[10:21:47.773]                       master <- NULL
[10:21:47.773]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.773]                         !identical(envir, emptyenv())) {
[10:21:47.773]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.773]                           inherits = FALSE)) {
[10:21:47.773]                           master <- get("master", mode = "list", 
[10:21:47.773]                             envir = envir, inherits = FALSE)
[10:21:47.773]                           if (inherits(master, c("SOCKnode", 
[10:21:47.773]                             "SOCK0node"))) {
[10:21:47.773]                             sendCondition <<- function(cond) {
[10:21:47.773]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.773]                                 success = TRUE)
[10:21:47.773]                               parallel_sendData(master, data)
[10:21:47.773]                             }
[10:21:47.773]                             return(sendCondition)
[10:21:47.773]                           }
[10:21:47.773]                         }
[10:21:47.773]                         frame <- frame + 1L
[10:21:47.773]                         envir <- sys.frame(frame)
[10:21:47.773]                       }
[10:21:47.773]                     }
[10:21:47.773]                     sendCondition <<- function(cond) NULL
[10:21:47.773]                   }
[10:21:47.773]                 })
[10:21:47.773]                 withCallingHandlers({
[10:21:47.773]                   value(a) + 1
[10:21:47.773]                 }, immediateCondition = function(cond) {
[10:21:47.773]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.773]                   sendCondition(cond)
[10:21:47.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.773]                   {
[10:21:47.773]                     inherits <- base::inherits
[10:21:47.773]                     invokeRestart <- base::invokeRestart
[10:21:47.773]                     is.null <- base::is.null
[10:21:47.773]                     muffled <- FALSE
[10:21:47.773]                     if (inherits(cond, "message")) {
[10:21:47.773]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.773]                       if (muffled) 
[10:21:47.773]                         invokeRestart("muffleMessage")
[10:21:47.773]                     }
[10:21:47.773]                     else if (inherits(cond, "warning")) {
[10:21:47.773]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.773]                       if (muffled) 
[10:21:47.773]                         invokeRestart("muffleWarning")
[10:21:47.773]                     }
[10:21:47.773]                     else if (inherits(cond, "condition")) {
[10:21:47.773]                       if (!is.null(pattern)) {
[10:21:47.773]                         computeRestarts <- base::computeRestarts
[10:21:47.773]                         grepl <- base::grepl
[10:21:47.773]                         restarts <- computeRestarts(cond)
[10:21:47.773]                         for (restart in restarts) {
[10:21:47.773]                           name <- restart$name
[10:21:47.773]                           if (is.null(name)) 
[10:21:47.773]                             next
[10:21:47.773]                           if (!grepl(pattern, name)) 
[10:21:47.773]                             next
[10:21:47.773]                           invokeRestart(restart)
[10:21:47.773]                           muffled <- TRUE
[10:21:47.773]                           break
[10:21:47.773]                         }
[10:21:47.773]                       }
[10:21:47.773]                     }
[10:21:47.773]                     invisible(muffled)
[10:21:47.773]                   }
[10:21:47.773]                   muffleCondition(cond)
[10:21:47.773]                 })
[10:21:47.773]             }))
[10:21:47.773]             future::FutureResult(value = ...future.value$value, 
[10:21:47.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.773]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.773]                     ...future.globalenv.names))
[10:21:47.773]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.773]         }, condition = base::local({
[10:21:47.773]             c <- base::c
[10:21:47.773]             inherits <- base::inherits
[10:21:47.773]             invokeRestart <- base::invokeRestart
[10:21:47.773]             length <- base::length
[10:21:47.773]             list <- base::list
[10:21:47.773]             seq.int <- base::seq.int
[10:21:47.773]             signalCondition <- base::signalCondition
[10:21:47.773]             sys.calls <- base::sys.calls
[10:21:47.773]             `[[` <- base::`[[`
[10:21:47.773]             `+` <- base::`+`
[10:21:47.773]             `<<-` <- base::`<<-`
[10:21:47.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.773]                   3L)]
[10:21:47.773]             }
[10:21:47.773]             function(cond) {
[10:21:47.773]                 is_error <- inherits(cond, "error")
[10:21:47.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.773]                   NULL)
[10:21:47.773]                 if (is_error) {
[10:21:47.773]                   sessionInformation <- function() {
[10:21:47.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.773]                       search = base::search(), system = base::Sys.info())
[10:21:47.773]                   }
[10:21:47.773]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.773]                     cond$call), session = sessionInformation(), 
[10:21:47.773]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.773]                   signalCondition(cond)
[10:21:47.773]                 }
[10:21:47.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.773]                 "immediateCondition"))) {
[10:21:47.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.773]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.773]                   if (TRUE && !signal) {
[10:21:47.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.773]                     {
[10:21:47.773]                       inherits <- base::inherits
[10:21:47.773]                       invokeRestart <- base::invokeRestart
[10:21:47.773]                       is.null <- base::is.null
[10:21:47.773]                       muffled <- FALSE
[10:21:47.773]                       if (inherits(cond, "message")) {
[10:21:47.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.773]                         if (muffled) 
[10:21:47.773]                           invokeRestart("muffleMessage")
[10:21:47.773]                       }
[10:21:47.773]                       else if (inherits(cond, "warning")) {
[10:21:47.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.773]                         if (muffled) 
[10:21:47.773]                           invokeRestart("muffleWarning")
[10:21:47.773]                       }
[10:21:47.773]                       else if (inherits(cond, "condition")) {
[10:21:47.773]                         if (!is.null(pattern)) {
[10:21:47.773]                           computeRestarts <- base::computeRestarts
[10:21:47.773]                           grepl <- base::grepl
[10:21:47.773]                           restarts <- computeRestarts(cond)
[10:21:47.773]                           for (restart in restarts) {
[10:21:47.773]                             name <- restart$name
[10:21:47.773]                             if (is.null(name)) 
[10:21:47.773]                               next
[10:21:47.773]                             if (!grepl(pattern, name)) 
[10:21:47.773]                               next
[10:21:47.773]                             invokeRestart(restart)
[10:21:47.773]                             muffled <- TRUE
[10:21:47.773]                             break
[10:21:47.773]                           }
[10:21:47.773]                         }
[10:21:47.773]                       }
[10:21:47.773]                       invisible(muffled)
[10:21:47.773]                     }
[10:21:47.773]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.773]                   }
[10:21:47.773]                 }
[10:21:47.773]                 else {
[10:21:47.773]                   if (TRUE) {
[10:21:47.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.773]                     {
[10:21:47.773]                       inherits <- base::inherits
[10:21:47.773]                       invokeRestart <- base::invokeRestart
[10:21:47.773]                       is.null <- base::is.null
[10:21:47.773]                       muffled <- FALSE
[10:21:47.773]                       if (inherits(cond, "message")) {
[10:21:47.773]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.773]                         if (muffled) 
[10:21:47.773]                           invokeRestart("muffleMessage")
[10:21:47.773]                       }
[10:21:47.773]                       else if (inherits(cond, "warning")) {
[10:21:47.773]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.773]                         if (muffled) 
[10:21:47.773]                           invokeRestart("muffleWarning")
[10:21:47.773]                       }
[10:21:47.773]                       else if (inherits(cond, "condition")) {
[10:21:47.773]                         if (!is.null(pattern)) {
[10:21:47.773]                           computeRestarts <- base::computeRestarts
[10:21:47.773]                           grepl <- base::grepl
[10:21:47.773]                           restarts <- computeRestarts(cond)
[10:21:47.773]                           for (restart in restarts) {
[10:21:47.773]                             name <- restart$name
[10:21:47.773]                             if (is.null(name)) 
[10:21:47.773]                               next
[10:21:47.773]                             if (!grepl(pattern, name)) 
[10:21:47.773]                               next
[10:21:47.773]                             invokeRestart(restart)
[10:21:47.773]                             muffled <- TRUE
[10:21:47.773]                             break
[10:21:47.773]                           }
[10:21:47.773]                         }
[10:21:47.773]                       }
[10:21:47.773]                       invisible(muffled)
[10:21:47.773]                     }
[10:21:47.773]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.773]                   }
[10:21:47.773]                 }
[10:21:47.773]             }
[10:21:47.773]         }))
[10:21:47.773]     }, error = function(ex) {
[10:21:47.773]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.773]                 ...future.rng), started = ...future.startTime, 
[10:21:47.773]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.773]             version = "1.8"), class = "FutureResult")
[10:21:47.773]     }, finally = {
[10:21:47.773]         if (!identical(...future.workdir, getwd())) 
[10:21:47.773]             setwd(...future.workdir)
[10:21:47.773]         {
[10:21:47.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.773]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.773]             }
[10:21:47.773]             base::options(...future.oldOptions)
[10:21:47.773]             if (.Platform$OS.type == "windows") {
[10:21:47.773]                 old_names <- names(...future.oldEnvVars)
[10:21:47.773]                 envs <- base::Sys.getenv()
[10:21:47.773]                 names <- names(envs)
[10:21:47.773]                 common <- intersect(names, old_names)
[10:21:47.773]                 added <- setdiff(names, old_names)
[10:21:47.773]                 removed <- setdiff(old_names, names)
[10:21:47.773]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.773]                   envs[common]]
[10:21:47.773]                 NAMES <- toupper(changed)
[10:21:47.773]                 args <- list()
[10:21:47.773]                 for (kk in seq_along(NAMES)) {
[10:21:47.773]                   name <- changed[[kk]]
[10:21:47.773]                   NAME <- NAMES[[kk]]
[10:21:47.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.773]                     next
[10:21:47.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.773]                 }
[10:21:47.773]                 NAMES <- toupper(added)
[10:21:47.773]                 for (kk in seq_along(NAMES)) {
[10:21:47.773]                   name <- added[[kk]]
[10:21:47.773]                   NAME <- NAMES[[kk]]
[10:21:47.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.773]                     next
[10:21:47.773]                   args[[name]] <- ""
[10:21:47.773]                 }
[10:21:47.773]                 NAMES <- toupper(removed)
[10:21:47.773]                 for (kk in seq_along(NAMES)) {
[10:21:47.773]                   name <- removed[[kk]]
[10:21:47.773]                   NAME <- NAMES[[kk]]
[10:21:47.773]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.773]                     next
[10:21:47.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.773]                 }
[10:21:47.773]                 if (length(args) > 0) 
[10:21:47.773]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.773]             }
[10:21:47.773]             else {
[10:21:47.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.773]             }
[10:21:47.773]             {
[10:21:47.773]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.773]                   0L) {
[10:21:47.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.773]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.773]                   base::options(opts)
[10:21:47.773]                 }
[10:21:47.773]                 {
[10:21:47.773]                   {
[10:21:47.773]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.773]                     NULL
[10:21:47.773]                   }
[10:21:47.773]                   options(future.plan = NULL)
[10:21:47.773]                   if (is.na(NA_character_)) 
[10:21:47.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.773]                     .init = FALSE)
[10:21:47.773]                 }
[10:21:47.773]             }
[10:21:47.773]         }
[10:21:47.773]     })
[10:21:47.773]     if (TRUE) {
[10:21:47.773]         base::sink(type = "output", split = FALSE)
[10:21:47.773]         if (TRUE) {
[10:21:47.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.773]         }
[10:21:47.773]         else {
[10:21:47.773]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.773]         }
[10:21:47.773]         base::close(...future.stdout)
[10:21:47.773]         ...future.stdout <- NULL
[10:21:47.773]     }
[10:21:47.773]     ...future.result$conditions <- ...future.conditions
[10:21:47.773]     ...future.result$finished <- base::Sys.time()
[10:21:47.773]     ...future.result
[10:21:47.773] }
[10:21:47.786] Exporting 1 global objects (313.46 KiB) to cluster node #1 ...
[10:21:47.797] Exporting ‘a’ (313.25 KiB) to cluster node #1 ...
[10:21:47.849] Exporting ‘a’ (313.25 KiB) to cluster node #1 ... DONE
[10:21:47.849] Exporting 1 global objects (313.46 KiB) to cluster node #1 ... DONE
[10:21:47.850] MultisessionFuture started
[10:21:47.850] - Launch lazy future ... done
[10:21:47.850] run() for ‘MultisessionFuture’ ... done
[10:21:47.850] result() for ClusterFuture ...
[10:21:47.850] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.850] - Validating connection of MultisessionFuture
[10:21:47.892] - received message: FutureResult
[10:21:47.893] - Received FutureResult
[10:21:47.893] - Erased future from FutureRegistry
[10:21:47.893] result() for ClusterFuture ...
[10:21:47.893] - result already collected: FutureResult
[10:21:47.893] result() for ClusterFuture ... done
[10:21:47.893] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.893] result() for ClusterFuture ... done
[10:21:47.893] result() for ClusterFuture ...
[10:21:47.893] - result already collected: FutureResult
[10:21:47.893] result() for ClusterFuture ... done
value(b) = 2
[10:21:47.894] result() for ClusterFuture ...
[10:21:47.894] - result already collected: FutureResult
[10:21:47.894] result() for ClusterFuture ... done
[10:21:47.894] result() for ClusterFuture ...
[10:21:47.894] - result already collected: FutureResult
[10:21:47.894] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.894] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.895] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.895] 
[10:21:47.895] Searching for globals ... DONE
[10:21:47.895] - globals: [0] <none>
[10:21:47.895] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:47.896] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:47.896] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:47.897] - globals found: [3] ‘+’, ‘value’, ‘a’
[10:21:47.897] Searching for globals ... DONE
[10:21:47.897] Resolving globals: TRUE
[10:21:47.897] Resolving any globals that are futures ...
[10:21:47.897] - globals: [3] ‘+’, ‘value’, ‘a’
[10:21:47.897] Resolving any globals that are futures ... DONE
[10:21:47.897] Resolving futures part of globals (recursively) ...
[10:21:47.898] resolve() on list ...
[10:21:47.898]  recursive: 99
[10:21:47.898]  length: 1
[10:21:47.898]  elements: ‘a’
[10:21:47.898] run() for ‘Future’ ...
[10:21:47.898] - state: ‘created’
[10:21:47.898] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.912] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.912] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.912]   - Field: ‘node’
[10:21:47.913]   - Field: ‘label’
[10:21:47.913]   - Field: ‘local’
[10:21:47.913]   - Field: ‘owner’
[10:21:47.913]   - Field: ‘envir’
[10:21:47.913]   - Field: ‘workers’
[10:21:47.913]   - Field: ‘packages’
[10:21:47.913]   - Field: ‘gc’
[10:21:47.913]   - Field: ‘conditions’
[10:21:47.913]   - Field: ‘persistent’
[10:21:47.913]   - Field: ‘expr’
[10:21:47.913]   - Field: ‘uuid’
[10:21:47.914]   - Field: ‘seed’
[10:21:47.914]   - Field: ‘version’
[10:21:47.914]   - Field: ‘result’
[10:21:47.914]   - Field: ‘asynchronous’
[10:21:47.914]   - Field: ‘calls’
[10:21:47.914]   - Field: ‘globals’
[10:21:47.914]   - Field: ‘stdout’
[10:21:47.914]   - Field: ‘earlySignal’
[10:21:47.914]   - Field: ‘lazy’
[10:21:47.914]   - Field: ‘state’
[10:21:47.914] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.914] - Launch lazy future ...
[10:21:47.915] Packages needed by the future expression (n = 0): <none>
[10:21:47.915] Packages needed by future strategies (n = 0): <none>
[10:21:47.915] {
[10:21:47.915]     {
[10:21:47.915]         {
[10:21:47.915]             ...future.startTime <- base::Sys.time()
[10:21:47.915]             {
[10:21:47.915]                 {
[10:21:47.915]                   {
[10:21:47.915]                     {
[10:21:47.915]                       base::local({
[10:21:47.915]                         has_future <- base::requireNamespace("future", 
[10:21:47.915]                           quietly = TRUE)
[10:21:47.915]                         if (has_future) {
[10:21:47.915]                           ns <- base::getNamespace("future")
[10:21:47.915]                           version <- ns[[".package"]][["version"]]
[10:21:47.915]                           if (is.null(version)) 
[10:21:47.915]                             version <- utils::packageVersion("future")
[10:21:47.915]                         }
[10:21:47.915]                         else {
[10:21:47.915]                           version <- NULL
[10:21:47.915]                         }
[10:21:47.915]                         if (!has_future || version < "1.8.0") {
[10:21:47.915]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.915]                             "", base::R.version$version.string), 
[10:21:47.915]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:47.915]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:47.915]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.915]                               "release", "version")], collapse = " "), 
[10:21:47.915]                             hostname = base::Sys.info()[["nodename"]])
[10:21:47.915]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.915]                             info)
[10:21:47.915]                           info <- base::paste(info, collapse = "; ")
[10:21:47.915]                           if (!has_future) {
[10:21:47.915]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.915]                               info)
[10:21:47.915]                           }
[10:21:47.915]                           else {
[10:21:47.915]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.915]                               info, version)
[10:21:47.915]                           }
[10:21:47.915]                           base::stop(msg)
[10:21:47.915]                         }
[10:21:47.915]                       })
[10:21:47.915]                     }
[10:21:47.915]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.915]                     base::options(mc.cores = 1L)
[10:21:47.915]                   }
[10:21:47.915]                   ...future.strategy.old <- future::plan("list")
[10:21:47.915]                   options(future.plan = NULL)
[10:21:47.915]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.915]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.915]                 }
[10:21:47.915]                 ...future.workdir <- getwd()
[10:21:47.915]             }
[10:21:47.915]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.915]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.915]         }
[10:21:47.915]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.915]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.915]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.915]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.915]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.915]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.915]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.915]             base::names(...future.oldOptions))
[10:21:47.915]     }
[10:21:47.915]     if (FALSE) {
[10:21:47.915]     }
[10:21:47.915]     else {
[10:21:47.915]         if (TRUE) {
[10:21:47.915]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.915]                 open = "w")
[10:21:47.915]         }
[10:21:47.915]         else {
[10:21:47.915]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.915]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.915]         }
[10:21:47.915]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.915]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.915]             base::sink(type = "output", split = FALSE)
[10:21:47.915]             base::close(...future.stdout)
[10:21:47.915]         }, add = TRUE)
[10:21:47.915]     }
[10:21:47.915]     ...future.frame <- base::sys.nframe()
[10:21:47.915]     ...future.conditions <- base::list()
[10:21:47.915]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.915]     if (FALSE) {
[10:21:47.915]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.915]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.915]     }
[10:21:47.915]     ...future.result <- base::tryCatch({
[10:21:47.915]         base::withCallingHandlers({
[10:21:47.915]             ...future.value <- base::withVisible(base::local({
[10:21:47.915]                 ...future.makeSendCondition <- base::local({
[10:21:47.915]                   sendCondition <- NULL
[10:21:47.915]                   function(frame = 1L) {
[10:21:47.915]                     if (is.function(sendCondition)) 
[10:21:47.915]                       return(sendCondition)
[10:21:47.915]                     ns <- getNamespace("parallel")
[10:21:47.915]                     if (exists("sendData", mode = "function", 
[10:21:47.915]                       envir = ns)) {
[10:21:47.915]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.915]                         envir = ns)
[10:21:47.915]                       envir <- sys.frame(frame)
[10:21:47.915]                       master <- NULL
[10:21:47.915]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.915]                         !identical(envir, emptyenv())) {
[10:21:47.915]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.915]                           inherits = FALSE)) {
[10:21:47.915]                           master <- get("master", mode = "list", 
[10:21:47.915]                             envir = envir, inherits = FALSE)
[10:21:47.915]                           if (inherits(master, c("SOCKnode", 
[10:21:47.915]                             "SOCK0node"))) {
[10:21:47.915]                             sendCondition <<- function(cond) {
[10:21:47.915]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.915]                                 success = TRUE)
[10:21:47.915]                               parallel_sendData(master, data)
[10:21:47.915]                             }
[10:21:47.915]                             return(sendCondition)
[10:21:47.915]                           }
[10:21:47.915]                         }
[10:21:47.915]                         frame <- frame + 1L
[10:21:47.915]                         envir <- sys.frame(frame)
[10:21:47.915]                       }
[10:21:47.915]                     }
[10:21:47.915]                     sendCondition <<- function(cond) NULL
[10:21:47.915]                   }
[10:21:47.915]                 })
[10:21:47.915]                 withCallingHandlers({
[10:21:47.915]                   1
[10:21:47.915]                 }, immediateCondition = function(cond) {
[10:21:47.915]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.915]                   sendCondition(cond)
[10:21:47.915]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.915]                   {
[10:21:47.915]                     inherits <- base::inherits
[10:21:47.915]                     invokeRestart <- base::invokeRestart
[10:21:47.915]                     is.null <- base::is.null
[10:21:47.915]                     muffled <- FALSE
[10:21:47.915]                     if (inherits(cond, "message")) {
[10:21:47.915]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.915]                       if (muffled) 
[10:21:47.915]                         invokeRestart("muffleMessage")
[10:21:47.915]                     }
[10:21:47.915]                     else if (inherits(cond, "warning")) {
[10:21:47.915]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.915]                       if (muffled) 
[10:21:47.915]                         invokeRestart("muffleWarning")
[10:21:47.915]                     }
[10:21:47.915]                     else if (inherits(cond, "condition")) {
[10:21:47.915]                       if (!is.null(pattern)) {
[10:21:47.915]                         computeRestarts <- base::computeRestarts
[10:21:47.915]                         grepl <- base::grepl
[10:21:47.915]                         restarts <- computeRestarts(cond)
[10:21:47.915]                         for (restart in restarts) {
[10:21:47.915]                           name <- restart$name
[10:21:47.915]                           if (is.null(name)) 
[10:21:47.915]                             next
[10:21:47.915]                           if (!grepl(pattern, name)) 
[10:21:47.915]                             next
[10:21:47.915]                           invokeRestart(restart)
[10:21:47.915]                           muffled <- TRUE
[10:21:47.915]                           break
[10:21:47.915]                         }
[10:21:47.915]                       }
[10:21:47.915]                     }
[10:21:47.915]                     invisible(muffled)
[10:21:47.915]                   }
[10:21:47.915]                   muffleCondition(cond)
[10:21:47.915]                 })
[10:21:47.915]             }))
[10:21:47.915]             future::FutureResult(value = ...future.value$value, 
[10:21:47.915]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.915]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.915]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.915]                     ...future.globalenv.names))
[10:21:47.915]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.915]         }, condition = base::local({
[10:21:47.915]             c <- base::c
[10:21:47.915]             inherits <- base::inherits
[10:21:47.915]             invokeRestart <- base::invokeRestart
[10:21:47.915]             length <- base::length
[10:21:47.915]             list <- base::list
[10:21:47.915]             seq.int <- base::seq.int
[10:21:47.915]             signalCondition <- base::signalCondition
[10:21:47.915]             sys.calls <- base::sys.calls
[10:21:47.915]             `[[` <- base::`[[`
[10:21:47.915]             `+` <- base::`+`
[10:21:47.915]             `<<-` <- base::`<<-`
[10:21:47.915]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.915]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.915]                   3L)]
[10:21:47.915]             }
[10:21:47.915]             function(cond) {
[10:21:47.915]                 is_error <- inherits(cond, "error")
[10:21:47.915]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.915]                   NULL)
[10:21:47.915]                 if (is_error) {
[10:21:47.915]                   sessionInformation <- function() {
[10:21:47.915]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.915]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.915]                       search = base::search(), system = base::Sys.info())
[10:21:47.915]                   }
[10:21:47.915]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.915]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.915]                     cond$call), session = sessionInformation(), 
[10:21:47.915]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.915]                   signalCondition(cond)
[10:21:47.915]                 }
[10:21:47.915]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.915]                 "immediateCondition"))) {
[10:21:47.915]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.915]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.915]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.915]                   if (TRUE && !signal) {
[10:21:47.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.915]                     {
[10:21:47.915]                       inherits <- base::inherits
[10:21:47.915]                       invokeRestart <- base::invokeRestart
[10:21:47.915]                       is.null <- base::is.null
[10:21:47.915]                       muffled <- FALSE
[10:21:47.915]                       if (inherits(cond, "message")) {
[10:21:47.915]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.915]                         if (muffled) 
[10:21:47.915]                           invokeRestart("muffleMessage")
[10:21:47.915]                       }
[10:21:47.915]                       else if (inherits(cond, "warning")) {
[10:21:47.915]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.915]                         if (muffled) 
[10:21:47.915]                           invokeRestart("muffleWarning")
[10:21:47.915]                       }
[10:21:47.915]                       else if (inherits(cond, "condition")) {
[10:21:47.915]                         if (!is.null(pattern)) {
[10:21:47.915]                           computeRestarts <- base::computeRestarts
[10:21:47.915]                           grepl <- base::grepl
[10:21:47.915]                           restarts <- computeRestarts(cond)
[10:21:47.915]                           for (restart in restarts) {
[10:21:47.915]                             name <- restart$name
[10:21:47.915]                             if (is.null(name)) 
[10:21:47.915]                               next
[10:21:47.915]                             if (!grepl(pattern, name)) 
[10:21:47.915]                               next
[10:21:47.915]                             invokeRestart(restart)
[10:21:47.915]                             muffled <- TRUE
[10:21:47.915]                             break
[10:21:47.915]                           }
[10:21:47.915]                         }
[10:21:47.915]                       }
[10:21:47.915]                       invisible(muffled)
[10:21:47.915]                     }
[10:21:47.915]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.915]                   }
[10:21:47.915]                 }
[10:21:47.915]                 else {
[10:21:47.915]                   if (TRUE) {
[10:21:47.915]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.915]                     {
[10:21:47.915]                       inherits <- base::inherits
[10:21:47.915]                       invokeRestart <- base::invokeRestart
[10:21:47.915]                       is.null <- base::is.null
[10:21:47.915]                       muffled <- FALSE
[10:21:47.915]                       if (inherits(cond, "message")) {
[10:21:47.915]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.915]                         if (muffled) 
[10:21:47.915]                           invokeRestart("muffleMessage")
[10:21:47.915]                       }
[10:21:47.915]                       else if (inherits(cond, "warning")) {
[10:21:47.915]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.915]                         if (muffled) 
[10:21:47.915]                           invokeRestart("muffleWarning")
[10:21:47.915]                       }
[10:21:47.915]                       else if (inherits(cond, "condition")) {
[10:21:47.915]                         if (!is.null(pattern)) {
[10:21:47.915]                           computeRestarts <- base::computeRestarts
[10:21:47.915]                           grepl <- base::grepl
[10:21:47.915]                           restarts <- computeRestarts(cond)
[10:21:47.915]                           for (restart in restarts) {
[10:21:47.915]                             name <- restart$name
[10:21:47.915]                             if (is.null(name)) 
[10:21:47.915]                               next
[10:21:47.915]                             if (!grepl(pattern, name)) 
[10:21:47.915]                               next
[10:21:47.915]                             invokeRestart(restart)
[10:21:47.915]                             muffled <- TRUE
[10:21:47.915]                             break
[10:21:47.915]                           }
[10:21:47.915]                         }
[10:21:47.915]                       }
[10:21:47.915]                       invisible(muffled)
[10:21:47.915]                     }
[10:21:47.915]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.915]                   }
[10:21:47.915]                 }
[10:21:47.915]             }
[10:21:47.915]         }))
[10:21:47.915]     }, error = function(ex) {
[10:21:47.915]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.915]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.915]                 ...future.rng), started = ...future.startTime, 
[10:21:47.915]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.915]             version = "1.8"), class = "FutureResult")
[10:21:47.915]     }, finally = {
[10:21:47.915]         if (!identical(...future.workdir, getwd())) 
[10:21:47.915]             setwd(...future.workdir)
[10:21:47.915]         {
[10:21:47.915]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.915]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.915]             }
[10:21:47.915]             base::options(...future.oldOptions)
[10:21:47.915]             if (.Platform$OS.type == "windows") {
[10:21:47.915]                 old_names <- names(...future.oldEnvVars)
[10:21:47.915]                 envs <- base::Sys.getenv()
[10:21:47.915]                 names <- names(envs)
[10:21:47.915]                 common <- intersect(names, old_names)
[10:21:47.915]                 added <- setdiff(names, old_names)
[10:21:47.915]                 removed <- setdiff(old_names, names)
[10:21:47.915]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.915]                   envs[common]]
[10:21:47.915]                 NAMES <- toupper(changed)
[10:21:47.915]                 args <- list()
[10:21:47.915]                 for (kk in seq_along(NAMES)) {
[10:21:47.915]                   name <- changed[[kk]]
[10:21:47.915]                   NAME <- NAMES[[kk]]
[10:21:47.915]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.915]                     next
[10:21:47.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.915]                 }
[10:21:47.915]                 NAMES <- toupper(added)
[10:21:47.915]                 for (kk in seq_along(NAMES)) {
[10:21:47.915]                   name <- added[[kk]]
[10:21:47.915]                   NAME <- NAMES[[kk]]
[10:21:47.915]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.915]                     next
[10:21:47.915]                   args[[name]] <- ""
[10:21:47.915]                 }
[10:21:47.915]                 NAMES <- toupper(removed)
[10:21:47.915]                 for (kk in seq_along(NAMES)) {
[10:21:47.915]                   name <- removed[[kk]]
[10:21:47.915]                   NAME <- NAMES[[kk]]
[10:21:47.915]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.915]                     next
[10:21:47.915]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.915]                 }
[10:21:47.915]                 if (length(args) > 0) 
[10:21:47.915]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.915]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.915]             }
[10:21:47.915]             else {
[10:21:47.915]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.915]             }
[10:21:47.915]             {
[10:21:47.915]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.915]                   0L) {
[10:21:47.915]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.915]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.915]                   base::options(opts)
[10:21:47.915]                 }
[10:21:47.915]                 {
[10:21:47.915]                   {
[10:21:47.915]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.915]                     NULL
[10:21:47.915]                   }
[10:21:47.915]                   options(future.plan = NULL)
[10:21:47.915]                   if (is.na(NA_character_)) 
[10:21:47.915]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.915]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.915]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.915]                     .init = FALSE)
[10:21:47.915]                 }
[10:21:47.915]             }
[10:21:47.915]         }
[10:21:47.915]     })
[10:21:47.915]     if (TRUE) {
[10:21:47.915]         base::sink(type = "output", split = FALSE)
[10:21:47.915]         if (TRUE) {
[10:21:47.915]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.915]         }
[10:21:47.915]         else {
[10:21:47.915]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.915]         }
[10:21:47.915]         base::close(...future.stdout)
[10:21:47.915]         ...future.stdout <- NULL
[10:21:47.915]     }
[10:21:47.915]     ...future.result$conditions <- ...future.conditions
[10:21:47.915]     ...future.result$finished <- base::Sys.time()
[10:21:47.915]     ...future.result
[10:21:47.915] }
[10:21:47.918] MultisessionFuture started
[10:21:47.918] - Launch lazy future ... done
[10:21:47.919] run() for ‘MultisessionFuture’ ... done
[10:21:47.960] receiveMessageFromWorker() for ClusterFuture ...
[10:21:47.960] - Validating connection of MultisessionFuture
[10:21:47.961] - received message: FutureResult
[10:21:47.961] - Received FutureResult
[10:21:47.961] - Erased future from FutureRegistry
[10:21:47.961] result() for ClusterFuture ...
[10:21:47.961] - result already collected: FutureResult
[10:21:47.961] result() for ClusterFuture ... done
[10:21:47.961] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:47.961] Future #1
[10:21:47.961] result() for ClusterFuture ...
[10:21:47.962] - result already collected: FutureResult
[10:21:47.962] result() for ClusterFuture ... done
[10:21:47.962] result() for ClusterFuture ...
[10:21:47.962] - result already collected: FutureResult
[10:21:47.962] result() for ClusterFuture ... done
[10:21:47.962] A MultisessionFuture was resolved
[10:21:47.962]  length: 0 (resolved future 1)
[10:21:47.962] resolve() on list ... DONE
[10:21:47.962] - globals: [1] ‘a’
[10:21:47.962] Resolving futures part of globals (recursively) ... DONE
[10:21:47.975] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[10:21:47.975] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[10:21:47.975] - globals: [1] ‘a’
[10:21:47.975] - packages: [1] ‘future’
[10:21:47.976] getGlobalsAndPackages() ... DONE
[10:21:47.976] run() for ‘Future’ ...
[10:21:47.976] - state: ‘created’
[10:21:47.976] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:47.990] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:47.990] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:47.990]   - Field: ‘node’
[10:21:47.990]   - Field: ‘label’
[10:21:47.990]   - Field: ‘local’
[10:21:47.990]   - Field: ‘owner’
[10:21:47.990]   - Field: ‘envir’
[10:21:47.991]   - Field: ‘workers’
[10:21:47.991]   - Field: ‘packages’
[10:21:47.991]   - Field: ‘gc’
[10:21:47.991]   - Field: ‘conditions’
[10:21:47.991]   - Field: ‘persistent’
[10:21:47.991]   - Field: ‘expr’
[10:21:47.991]   - Field: ‘uuid’
[10:21:47.991]   - Field: ‘seed’
[10:21:47.991]   - Field: ‘version’
[10:21:47.991]   - Field: ‘result’
[10:21:47.991]   - Field: ‘asynchronous’
[10:21:47.991]   - Field: ‘calls’
[10:21:47.992]   - Field: ‘globals’
[10:21:47.992]   - Field: ‘stdout’
[10:21:47.992]   - Field: ‘earlySignal’
[10:21:47.992]   - Field: ‘lazy’
[10:21:47.992]   - Field: ‘state’
[10:21:47.992] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:47.992] - Launch lazy future ...
[10:21:47.992] Packages needed by the future expression (n = 1): ‘future’
[10:21:47.992] Packages needed by future strategies (n = 0): <none>
[10:21:47.993] {
[10:21:47.993]     {
[10:21:47.993]         {
[10:21:47.993]             ...future.startTime <- base::Sys.time()
[10:21:47.993]             {
[10:21:47.993]                 {
[10:21:47.993]                   {
[10:21:47.993]                     {
[10:21:47.993]                       {
[10:21:47.993]                         base::local({
[10:21:47.993]                           has_future <- base::requireNamespace("future", 
[10:21:47.993]                             quietly = TRUE)
[10:21:47.993]                           if (has_future) {
[10:21:47.993]                             ns <- base::getNamespace("future")
[10:21:47.993]                             version <- ns[[".package"]][["version"]]
[10:21:47.993]                             if (is.null(version)) 
[10:21:47.993]                               version <- utils::packageVersion("future")
[10:21:47.993]                           }
[10:21:47.993]                           else {
[10:21:47.993]                             version <- NULL
[10:21:47.993]                           }
[10:21:47.993]                           if (!has_future || version < "1.8.0") {
[10:21:47.993]                             info <- base::c(r_version = base::gsub("R version ", 
[10:21:47.993]                               "", base::R.version$version.string), 
[10:21:47.993]                               platform = base::sprintf("%s (%s-bit)", 
[10:21:47.993]                                 base::R.version$platform, 8 * 
[10:21:47.993]                                   base::.Machine$sizeof.pointer), 
[10:21:47.993]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:47.993]                                 "release", "version")], collapse = " "), 
[10:21:47.993]                               hostname = base::Sys.info()[["nodename"]])
[10:21:47.993]                             info <- base::sprintf("%s: %s", base::names(info), 
[10:21:47.993]                               info)
[10:21:47.993]                             info <- base::paste(info, collapse = "; ")
[10:21:47.993]                             if (!has_future) {
[10:21:47.993]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:47.993]                                 info)
[10:21:47.993]                             }
[10:21:47.993]                             else {
[10:21:47.993]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:47.993]                                 info, version)
[10:21:47.993]                             }
[10:21:47.993]                             base::stop(msg)
[10:21:47.993]                           }
[10:21:47.993]                         })
[10:21:47.993]                       }
[10:21:47.993]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:47.993]                       base::options(mc.cores = 1L)
[10:21:47.993]                     }
[10:21:47.993]                     base::local({
[10:21:47.993]                       for (pkg in "future") {
[10:21:47.993]                         base::loadNamespace(pkg)
[10:21:47.993]                         base::library(pkg, character.only = TRUE)
[10:21:47.993]                       }
[10:21:47.993]                     })
[10:21:47.993]                   }
[10:21:47.993]                   ...future.strategy.old <- future::plan("list")
[10:21:47.993]                   options(future.plan = NULL)
[10:21:47.993]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.993]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:47.993]                 }
[10:21:47.993]                 ...future.workdir <- getwd()
[10:21:47.993]             }
[10:21:47.993]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:47.993]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:47.993]         }
[10:21:47.993]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:47.993]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:47.993]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:47.993]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:47.993]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:47.993]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:47.993]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:47.993]             base::names(...future.oldOptions))
[10:21:47.993]     }
[10:21:47.993]     if (FALSE) {
[10:21:47.993]     }
[10:21:47.993]     else {
[10:21:47.993]         if (TRUE) {
[10:21:47.993]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:47.993]                 open = "w")
[10:21:47.993]         }
[10:21:47.993]         else {
[10:21:47.993]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:47.993]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:47.993]         }
[10:21:47.993]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:47.993]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:47.993]             base::sink(type = "output", split = FALSE)
[10:21:47.993]             base::close(...future.stdout)
[10:21:47.993]         }, add = TRUE)
[10:21:47.993]     }
[10:21:47.993]     ...future.frame <- base::sys.nframe()
[10:21:47.993]     ...future.conditions <- base::list()
[10:21:47.993]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:47.993]     if (FALSE) {
[10:21:47.993]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:47.993]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:47.993]     }
[10:21:47.993]     ...future.result <- base::tryCatch({
[10:21:47.993]         base::withCallingHandlers({
[10:21:47.993]             ...future.value <- base::withVisible(base::local({
[10:21:47.993]                 ...future.makeSendCondition <- base::local({
[10:21:47.993]                   sendCondition <- NULL
[10:21:47.993]                   function(frame = 1L) {
[10:21:47.993]                     if (is.function(sendCondition)) 
[10:21:47.993]                       return(sendCondition)
[10:21:47.993]                     ns <- getNamespace("parallel")
[10:21:47.993]                     if (exists("sendData", mode = "function", 
[10:21:47.993]                       envir = ns)) {
[10:21:47.993]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:47.993]                         envir = ns)
[10:21:47.993]                       envir <- sys.frame(frame)
[10:21:47.993]                       master <- NULL
[10:21:47.993]                       while (!identical(envir, .GlobalEnv) && 
[10:21:47.993]                         !identical(envir, emptyenv())) {
[10:21:47.993]                         if (exists("master", mode = "list", envir = envir, 
[10:21:47.993]                           inherits = FALSE)) {
[10:21:47.993]                           master <- get("master", mode = "list", 
[10:21:47.993]                             envir = envir, inherits = FALSE)
[10:21:47.993]                           if (inherits(master, c("SOCKnode", 
[10:21:47.993]                             "SOCK0node"))) {
[10:21:47.993]                             sendCondition <<- function(cond) {
[10:21:47.993]                               data <- list(type = "VALUE", value = cond, 
[10:21:47.993]                                 success = TRUE)
[10:21:47.993]                               parallel_sendData(master, data)
[10:21:47.993]                             }
[10:21:47.993]                             return(sendCondition)
[10:21:47.993]                           }
[10:21:47.993]                         }
[10:21:47.993]                         frame <- frame + 1L
[10:21:47.993]                         envir <- sys.frame(frame)
[10:21:47.993]                       }
[10:21:47.993]                     }
[10:21:47.993]                     sendCondition <<- function(cond) NULL
[10:21:47.993]                   }
[10:21:47.993]                 })
[10:21:47.993]                 withCallingHandlers({
[10:21:47.993]                   value(a) + 1
[10:21:47.993]                 }, immediateCondition = function(cond) {
[10:21:47.993]                   sendCondition <- ...future.makeSendCondition()
[10:21:47.993]                   sendCondition(cond)
[10:21:47.993]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.993]                   {
[10:21:47.993]                     inherits <- base::inherits
[10:21:47.993]                     invokeRestart <- base::invokeRestart
[10:21:47.993]                     is.null <- base::is.null
[10:21:47.993]                     muffled <- FALSE
[10:21:47.993]                     if (inherits(cond, "message")) {
[10:21:47.993]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:47.993]                       if (muffled) 
[10:21:47.993]                         invokeRestart("muffleMessage")
[10:21:47.993]                     }
[10:21:47.993]                     else if (inherits(cond, "warning")) {
[10:21:47.993]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:47.993]                       if (muffled) 
[10:21:47.993]                         invokeRestart("muffleWarning")
[10:21:47.993]                     }
[10:21:47.993]                     else if (inherits(cond, "condition")) {
[10:21:47.993]                       if (!is.null(pattern)) {
[10:21:47.993]                         computeRestarts <- base::computeRestarts
[10:21:47.993]                         grepl <- base::grepl
[10:21:47.993]                         restarts <- computeRestarts(cond)
[10:21:47.993]                         for (restart in restarts) {
[10:21:47.993]                           name <- restart$name
[10:21:47.993]                           if (is.null(name)) 
[10:21:47.993]                             next
[10:21:47.993]                           if (!grepl(pattern, name)) 
[10:21:47.993]                             next
[10:21:47.993]                           invokeRestart(restart)
[10:21:47.993]                           muffled <- TRUE
[10:21:47.993]                           break
[10:21:47.993]                         }
[10:21:47.993]                       }
[10:21:47.993]                     }
[10:21:47.993]                     invisible(muffled)
[10:21:47.993]                   }
[10:21:47.993]                   muffleCondition(cond)
[10:21:47.993]                 })
[10:21:47.993]             }))
[10:21:47.993]             future::FutureResult(value = ...future.value$value, 
[10:21:47.993]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.993]                   ...future.rng), globalenv = if (FALSE) 
[10:21:47.993]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:47.993]                     ...future.globalenv.names))
[10:21:47.993]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:47.993]         }, condition = base::local({
[10:21:47.993]             c <- base::c
[10:21:47.993]             inherits <- base::inherits
[10:21:47.993]             invokeRestart <- base::invokeRestart
[10:21:47.993]             length <- base::length
[10:21:47.993]             list <- base::list
[10:21:47.993]             seq.int <- base::seq.int
[10:21:47.993]             signalCondition <- base::signalCondition
[10:21:47.993]             sys.calls <- base::sys.calls
[10:21:47.993]             `[[` <- base::`[[`
[10:21:47.993]             `+` <- base::`+`
[10:21:47.993]             `<<-` <- base::`<<-`
[10:21:47.993]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:47.993]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:47.993]                   3L)]
[10:21:47.993]             }
[10:21:47.993]             function(cond) {
[10:21:47.993]                 is_error <- inherits(cond, "error")
[10:21:47.993]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:47.993]                   NULL)
[10:21:47.993]                 if (is_error) {
[10:21:47.993]                   sessionInformation <- function() {
[10:21:47.993]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:47.993]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:47.993]                       search = base::search(), system = base::Sys.info())
[10:21:47.993]                   }
[10:21:47.993]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.993]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:47.993]                     cond$call), session = sessionInformation(), 
[10:21:47.993]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:47.993]                   signalCondition(cond)
[10:21:47.993]                 }
[10:21:47.993]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:47.993]                 "immediateCondition"))) {
[10:21:47.993]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:47.993]                   ...future.conditions[[length(...future.conditions) + 
[10:21:47.993]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:47.993]                   if (TRUE && !signal) {
[10:21:47.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.993]                     {
[10:21:47.993]                       inherits <- base::inherits
[10:21:47.993]                       invokeRestart <- base::invokeRestart
[10:21:47.993]                       is.null <- base::is.null
[10:21:47.993]                       muffled <- FALSE
[10:21:47.993]                       if (inherits(cond, "message")) {
[10:21:47.993]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.993]                         if (muffled) 
[10:21:47.993]                           invokeRestart("muffleMessage")
[10:21:47.993]                       }
[10:21:47.993]                       else if (inherits(cond, "warning")) {
[10:21:47.993]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.993]                         if (muffled) 
[10:21:47.993]                           invokeRestart("muffleWarning")
[10:21:47.993]                       }
[10:21:47.993]                       else if (inherits(cond, "condition")) {
[10:21:47.993]                         if (!is.null(pattern)) {
[10:21:47.993]                           computeRestarts <- base::computeRestarts
[10:21:47.993]                           grepl <- base::grepl
[10:21:47.993]                           restarts <- computeRestarts(cond)
[10:21:47.993]                           for (restart in restarts) {
[10:21:47.993]                             name <- restart$name
[10:21:47.993]                             if (is.null(name)) 
[10:21:47.993]                               next
[10:21:47.993]                             if (!grepl(pattern, name)) 
[10:21:47.993]                               next
[10:21:47.993]                             invokeRestart(restart)
[10:21:47.993]                             muffled <- TRUE
[10:21:47.993]                             break
[10:21:47.993]                           }
[10:21:47.993]                         }
[10:21:47.993]                       }
[10:21:47.993]                       invisible(muffled)
[10:21:47.993]                     }
[10:21:47.993]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.993]                   }
[10:21:47.993]                 }
[10:21:47.993]                 else {
[10:21:47.993]                   if (TRUE) {
[10:21:47.993]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:47.993]                     {
[10:21:47.993]                       inherits <- base::inherits
[10:21:47.993]                       invokeRestart <- base::invokeRestart
[10:21:47.993]                       is.null <- base::is.null
[10:21:47.993]                       muffled <- FALSE
[10:21:47.993]                       if (inherits(cond, "message")) {
[10:21:47.993]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:47.993]                         if (muffled) 
[10:21:47.993]                           invokeRestart("muffleMessage")
[10:21:47.993]                       }
[10:21:47.993]                       else if (inherits(cond, "warning")) {
[10:21:47.993]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:47.993]                         if (muffled) 
[10:21:47.993]                           invokeRestart("muffleWarning")
[10:21:47.993]                       }
[10:21:47.993]                       else if (inherits(cond, "condition")) {
[10:21:47.993]                         if (!is.null(pattern)) {
[10:21:47.993]                           computeRestarts <- base::computeRestarts
[10:21:47.993]                           grepl <- base::grepl
[10:21:47.993]                           restarts <- computeRestarts(cond)
[10:21:47.993]                           for (restart in restarts) {
[10:21:47.993]                             name <- restart$name
[10:21:47.993]                             if (is.null(name)) 
[10:21:47.993]                               next
[10:21:47.993]                             if (!grepl(pattern, name)) 
[10:21:47.993]                               next
[10:21:47.993]                             invokeRestart(restart)
[10:21:47.993]                             muffled <- TRUE
[10:21:47.993]                             break
[10:21:47.993]                           }
[10:21:47.993]                         }
[10:21:47.993]                       }
[10:21:47.993]                       invisible(muffled)
[10:21:47.993]                     }
[10:21:47.993]                     muffleCondition(cond, pattern = "^muffle")
[10:21:47.993]                   }
[10:21:47.993]                 }
[10:21:47.993]             }
[10:21:47.993]         }))
[10:21:47.993]     }, error = function(ex) {
[10:21:47.993]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:47.993]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:47.993]                 ...future.rng), started = ...future.startTime, 
[10:21:47.993]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:47.993]             version = "1.8"), class = "FutureResult")
[10:21:47.993]     }, finally = {
[10:21:47.993]         if (!identical(...future.workdir, getwd())) 
[10:21:47.993]             setwd(...future.workdir)
[10:21:47.993]         {
[10:21:47.993]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:47.993]                 ...future.oldOptions$nwarnings <- NULL
[10:21:47.993]             }
[10:21:47.993]             base::options(...future.oldOptions)
[10:21:47.993]             if (.Platform$OS.type == "windows") {
[10:21:47.993]                 old_names <- names(...future.oldEnvVars)
[10:21:47.993]                 envs <- base::Sys.getenv()
[10:21:47.993]                 names <- names(envs)
[10:21:47.993]                 common <- intersect(names, old_names)
[10:21:47.993]                 added <- setdiff(names, old_names)
[10:21:47.993]                 removed <- setdiff(old_names, names)
[10:21:47.993]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:47.993]                   envs[common]]
[10:21:47.993]                 NAMES <- toupper(changed)
[10:21:47.993]                 args <- list()
[10:21:47.993]                 for (kk in seq_along(NAMES)) {
[10:21:47.993]                   name <- changed[[kk]]
[10:21:47.993]                   NAME <- NAMES[[kk]]
[10:21:47.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.993]                     next
[10:21:47.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.993]                 }
[10:21:47.993]                 NAMES <- toupper(added)
[10:21:47.993]                 for (kk in seq_along(NAMES)) {
[10:21:47.993]                   name <- added[[kk]]
[10:21:47.993]                   NAME <- NAMES[[kk]]
[10:21:47.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.993]                     next
[10:21:47.993]                   args[[name]] <- ""
[10:21:47.993]                 }
[10:21:47.993]                 NAMES <- toupper(removed)
[10:21:47.993]                 for (kk in seq_along(NAMES)) {
[10:21:47.993]                   name <- removed[[kk]]
[10:21:47.993]                   NAME <- NAMES[[kk]]
[10:21:47.993]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:47.993]                     next
[10:21:47.993]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:47.993]                 }
[10:21:47.993]                 if (length(args) > 0) 
[10:21:47.993]                   base::do.call(base::Sys.setenv, args = args)
[10:21:47.993]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:47.993]             }
[10:21:47.993]             else {
[10:21:47.993]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:47.993]             }
[10:21:47.993]             {
[10:21:47.993]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:47.993]                   0L) {
[10:21:47.993]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:47.993]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:47.993]                   base::options(opts)
[10:21:47.993]                 }
[10:21:47.993]                 {
[10:21:47.993]                   {
[10:21:47.993]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:47.993]                     NULL
[10:21:47.993]                   }
[10:21:47.993]                   options(future.plan = NULL)
[10:21:47.993]                   if (is.na(NA_character_)) 
[10:21:47.993]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:47.993]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:47.993]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:47.993]                     .init = FALSE)
[10:21:47.993]                 }
[10:21:47.993]             }
[10:21:47.993]         }
[10:21:47.993]     })
[10:21:47.993]     if (TRUE) {
[10:21:47.993]         base::sink(type = "output", split = FALSE)
[10:21:47.993]         if (TRUE) {
[10:21:47.993]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:47.993]         }
[10:21:47.993]         else {
[10:21:47.993]             ...future.result["stdout"] <- base::list(NULL)
[10:21:47.993]         }
[10:21:47.993]         base::close(...future.stdout)
[10:21:47.993]         ...future.stdout <- NULL
[10:21:47.993]     }
[10:21:47.993]     ...future.result$conditions <- ...future.conditions
[10:21:47.993]     ...future.result$finished <- base::Sys.time()
[10:21:47.993]     ...future.result
[10:21:47.993] }
[10:21:48.006] Exporting 1 global objects (313.46 KiB) to cluster node #1 ...
[10:21:48.017] Exporting ‘a’ (313.25 KiB) to cluster node #1 ...
[10:21:48.070] Exporting ‘a’ (313.25 KiB) to cluster node #1 ... DONE
[10:21:48.070] Exporting 1 global objects (313.46 KiB) to cluster node #1 ... DONE
[10:21:48.071] MultisessionFuture started
[10:21:48.071] - Launch lazy future ... done
[10:21:48.071] run() for ‘MultisessionFuture’ ... done
[10:21:48.071] result() for ClusterFuture ...
[10:21:48.071] receiveMessageFromWorker() for ClusterFuture ...
[10:21:48.071] - Validating connection of MultisessionFuture
[10:21:48.113] - received message: FutureResult
[10:21:48.114] - Received FutureResult
[10:21:48.114] - Erased future from FutureRegistry
[10:21:48.114] result() for ClusterFuture ...
[10:21:48.114] - result already collected: FutureResult
[10:21:48.114] result() for ClusterFuture ... done
[10:21:48.114] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:48.114] result() for ClusterFuture ... done
[10:21:48.114] result() for ClusterFuture ...
[10:21:48.114] - result already collected: FutureResult
[10:21:48.114] result() for ClusterFuture ... done
value(b) = 2
[10:21:48.115] result() for ClusterFuture ...
[10:21:48.115] - result already collected: FutureResult
[10:21:48.115] result() for ClusterFuture ... done
[10:21:48.115] result() for ClusterFuture ...
[10:21:48.115] - result already collected: FutureResult
[10:21:48.115] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:48.115] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:48.116] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:48.116] - globals found: [2] ‘{’, ‘pkg’
[10:21:48.117] Searching for globals ... DONE
[10:21:48.117] Resolving globals: TRUE
[10:21:48.117] Resolving any globals that are futures ...
[10:21:48.117] - globals: [2] ‘{’, ‘pkg’
[10:21:48.117] Resolving any globals that are futures ... DONE
[10:21:48.117] Resolving futures part of globals (recursively) ...
[10:21:48.118] resolve() on list ...
[10:21:48.118]  recursive: 99
[10:21:48.118]  length: 1
[10:21:48.118]  elements: ‘pkg’
[10:21:48.118]  length: 0 (resolved future 1)
[10:21:48.118] resolve() on list ... DONE
[10:21:48.118] - globals: [1] ‘pkg’
[10:21:48.118] Resolving futures part of globals (recursively) ... DONE
[10:21:48.118] The total size of the 1 globals is 42 bytes (42 bytes)
[10:21:48.119] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[10:21:48.119] - globals: [1] ‘pkg’
[10:21:48.119] 
[10:21:48.119] getGlobalsAndPackages() ... DONE
[10:21:48.119] Packages needed by the future expression (n = 0): <none>
[10:21:48.119] Packages needed by future strategies (n = 0): <none>
[10:21:48.120] {
[10:21:48.120]     {
[10:21:48.120]         {
[10:21:48.120]             ...future.startTime <- base::Sys.time()
[10:21:48.120]             {
[10:21:48.120]                 {
[10:21:48.120]                   {
[10:21:48.120]                     base::local({
[10:21:48.120]                       has_future <- base::requireNamespace("future", 
[10:21:48.120]                         quietly = TRUE)
[10:21:48.120]                       if (has_future) {
[10:21:48.120]                         ns <- base::getNamespace("future")
[10:21:48.120]                         version <- ns[[".package"]][["version"]]
[10:21:48.120]                         if (is.null(version)) 
[10:21:48.120]                           version <- utils::packageVersion("future")
[10:21:48.120]                       }
[10:21:48.120]                       else {
[10:21:48.120]                         version <- NULL
[10:21:48.120]                       }
[10:21:48.120]                       if (!has_future || version < "1.8.0") {
[10:21:48.120]                         info <- base::c(r_version = base::gsub("R version ", 
[10:21:48.120]                           "", base::R.version$version.string), 
[10:21:48.120]                           platform = base::sprintf("%s (%s-bit)", 
[10:21:48.120]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:48.120]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:48.120]                             "release", "version")], collapse = " "), 
[10:21:48.120]                           hostname = base::Sys.info()[["nodename"]])
[10:21:48.120]                         info <- base::sprintf("%s: %s", base::names(info), 
[10:21:48.120]                           info)
[10:21:48.120]                         info <- base::paste(info, collapse = "; ")
[10:21:48.120]                         if (!has_future) {
[10:21:48.120]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:48.120]                             info)
[10:21:48.120]                         }
[10:21:48.120]                         else {
[10:21:48.120]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:48.120]                             info, version)
[10:21:48.120]                         }
[10:21:48.120]                         base::stop(msg)
[10:21:48.120]                       }
[10:21:48.120]                     })
[10:21:48.120]                   }
[10:21:48.120]                   ...future.strategy.old <- future::plan("list")
[10:21:48.120]                   options(future.plan = NULL)
[10:21:48.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:48.120]                 }
[10:21:48.120]                 ...future.workdir <- getwd()
[10:21:48.120]             }
[10:21:48.120]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:48.120]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:48.120]         }
[10:21:48.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:48.120]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:48.120]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:48.120]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:48.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:48.120]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:48.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:48.120]             base::names(...future.oldOptions))
[10:21:48.120]     }
[10:21:48.120]     if (FALSE) {
[10:21:48.120]     }
[10:21:48.120]     else {
[10:21:48.120]         if (TRUE) {
[10:21:48.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:48.120]                 open = "w")
[10:21:48.120]         }
[10:21:48.120]         else {
[10:21:48.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:48.120]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:48.120]         }
[10:21:48.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:48.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:48.120]             base::sink(type = "output", split = FALSE)
[10:21:48.120]             base::close(...future.stdout)
[10:21:48.120]         }, add = TRUE)
[10:21:48.120]     }
[10:21:48.120]     ...future.frame <- base::sys.nframe()
[10:21:48.120]     ...future.conditions <- base::list()
[10:21:48.120]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:48.120]     if (FALSE) {
[10:21:48.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:48.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:48.120]     }
[10:21:48.120]     ...future.result <- base::tryCatch({
[10:21:48.120]         base::withCallingHandlers({
[10:21:48.120]             ...future.value <- base::withVisible(base::local({
[10:21:48.120]                 pkg
[10:21:48.120]             }))
[10:21:48.120]             future::FutureResult(value = ...future.value$value, 
[10:21:48.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.120]                   ...future.rng), globalenv = if (FALSE) 
[10:21:48.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:48.120]                     ...future.globalenv.names))
[10:21:48.120]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:48.120]         }, condition = base::local({
[10:21:48.120]             c <- base::c
[10:21:48.120]             inherits <- base::inherits
[10:21:48.120]             invokeRestart <- base::invokeRestart
[10:21:48.120]             length <- base::length
[10:21:48.120]             list <- base::list
[10:21:48.120]             seq.int <- base::seq.int
[10:21:48.120]             signalCondition <- base::signalCondition
[10:21:48.120]             sys.calls <- base::sys.calls
[10:21:48.120]             `[[` <- base::`[[`
[10:21:48.120]             `+` <- base::`+`
[10:21:48.120]             `<<-` <- base::`<<-`
[10:21:48.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:48.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:48.120]                   3L)]
[10:21:48.120]             }
[10:21:48.120]             function(cond) {
[10:21:48.120]                 is_error <- inherits(cond, "error")
[10:21:48.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:48.120]                   NULL)
[10:21:48.120]                 if (is_error) {
[10:21:48.120]                   sessionInformation <- function() {
[10:21:48.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:48.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:48.120]                       search = base::search(), system = base::Sys.info())
[10:21:48.120]                   }
[10:21:48.120]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:48.120]                     cond$call), session = sessionInformation(), 
[10:21:48.120]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:48.120]                   signalCondition(cond)
[10:21:48.120]                 }
[10:21:48.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:48.120]                 "immediateCondition"))) {
[10:21:48.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:48.120]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:48.120]                   if (TRUE && !signal) {
[10:21:48.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.120]                     {
[10:21:48.120]                       inherits <- base::inherits
[10:21:48.120]                       invokeRestart <- base::invokeRestart
[10:21:48.120]                       is.null <- base::is.null
[10:21:48.120]                       muffled <- FALSE
[10:21:48.120]                       if (inherits(cond, "message")) {
[10:21:48.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.120]                         if (muffled) 
[10:21:48.120]                           invokeRestart("muffleMessage")
[10:21:48.120]                       }
[10:21:48.120]                       else if (inherits(cond, "warning")) {
[10:21:48.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.120]                         if (muffled) 
[10:21:48.120]                           invokeRestart("muffleWarning")
[10:21:48.120]                       }
[10:21:48.120]                       else if (inherits(cond, "condition")) {
[10:21:48.120]                         if (!is.null(pattern)) {
[10:21:48.120]                           computeRestarts <- base::computeRestarts
[10:21:48.120]                           grepl <- base::grepl
[10:21:48.120]                           restarts <- computeRestarts(cond)
[10:21:48.120]                           for (restart in restarts) {
[10:21:48.120]                             name <- restart$name
[10:21:48.120]                             if (is.null(name)) 
[10:21:48.120]                               next
[10:21:48.120]                             if (!grepl(pattern, name)) 
[10:21:48.120]                               next
[10:21:48.120]                             invokeRestart(restart)
[10:21:48.120]                             muffled <- TRUE
[10:21:48.120]                             break
[10:21:48.120]                           }
[10:21:48.120]                         }
[10:21:48.120]                       }
[10:21:48.120]                       invisible(muffled)
[10:21:48.120]                     }
[10:21:48.120]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.120]                   }
[10:21:48.120]                 }
[10:21:48.120]                 else {
[10:21:48.120]                   if (TRUE) {
[10:21:48.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.120]                     {
[10:21:48.120]                       inherits <- base::inherits
[10:21:48.120]                       invokeRestart <- base::invokeRestart
[10:21:48.120]                       is.null <- base::is.null
[10:21:48.120]                       muffled <- FALSE
[10:21:48.120]                       if (inherits(cond, "message")) {
[10:21:48.120]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.120]                         if (muffled) 
[10:21:48.120]                           invokeRestart("muffleMessage")
[10:21:48.120]                       }
[10:21:48.120]                       else if (inherits(cond, "warning")) {
[10:21:48.120]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.120]                         if (muffled) 
[10:21:48.120]                           invokeRestart("muffleWarning")
[10:21:48.120]                       }
[10:21:48.120]                       else if (inherits(cond, "condition")) {
[10:21:48.120]                         if (!is.null(pattern)) {
[10:21:48.120]                           computeRestarts <- base::computeRestarts
[10:21:48.120]                           grepl <- base::grepl
[10:21:48.120]                           restarts <- computeRestarts(cond)
[10:21:48.120]                           for (restart in restarts) {
[10:21:48.120]                             name <- restart$name
[10:21:48.120]                             if (is.null(name)) 
[10:21:48.120]                               next
[10:21:48.120]                             if (!grepl(pattern, name)) 
[10:21:48.120]                               next
[10:21:48.120]                             invokeRestart(restart)
[10:21:48.120]                             muffled <- TRUE
[10:21:48.120]                             break
[10:21:48.120]                           }
[10:21:48.120]                         }
[10:21:48.120]                       }
[10:21:48.120]                       invisible(muffled)
[10:21:48.120]                     }
[10:21:48.120]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.120]                   }
[10:21:48.120]                 }
[10:21:48.120]             }
[10:21:48.120]         }))
[10:21:48.120]     }, error = function(ex) {
[10:21:48.120]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:48.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.120]                 ...future.rng), started = ...future.startTime, 
[10:21:48.120]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:48.120]             version = "1.8"), class = "FutureResult")
[10:21:48.120]     }, finally = {
[10:21:48.120]         if (!identical(...future.workdir, getwd())) 
[10:21:48.120]             setwd(...future.workdir)
[10:21:48.120]         {
[10:21:48.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:48.120]                 ...future.oldOptions$nwarnings <- NULL
[10:21:48.120]             }
[10:21:48.120]             base::options(...future.oldOptions)
[10:21:48.120]             if (.Platform$OS.type == "windows") {
[10:21:48.120]                 old_names <- names(...future.oldEnvVars)
[10:21:48.120]                 envs <- base::Sys.getenv()
[10:21:48.120]                 names <- names(envs)
[10:21:48.120]                 common <- intersect(names, old_names)
[10:21:48.120]                 added <- setdiff(names, old_names)
[10:21:48.120]                 removed <- setdiff(old_names, names)
[10:21:48.120]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:48.120]                   envs[common]]
[10:21:48.120]                 NAMES <- toupper(changed)
[10:21:48.120]                 args <- list()
[10:21:48.120]                 for (kk in seq_along(NAMES)) {
[10:21:48.120]                   name <- changed[[kk]]
[10:21:48.120]                   NAME <- NAMES[[kk]]
[10:21:48.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.120]                     next
[10:21:48.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.120]                 }
[10:21:48.120]                 NAMES <- toupper(added)
[10:21:48.120]                 for (kk in seq_along(NAMES)) {
[10:21:48.120]                   name <- added[[kk]]
[10:21:48.120]                   NAME <- NAMES[[kk]]
[10:21:48.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.120]                     next
[10:21:48.120]                   args[[name]] <- ""
[10:21:48.120]                 }
[10:21:48.120]                 NAMES <- toupper(removed)
[10:21:48.120]                 for (kk in seq_along(NAMES)) {
[10:21:48.120]                   name <- removed[[kk]]
[10:21:48.120]                   NAME <- NAMES[[kk]]
[10:21:48.120]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.120]                     next
[10:21:48.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.120]                 }
[10:21:48.120]                 if (length(args) > 0) 
[10:21:48.120]                   base::do.call(base::Sys.setenv, args = args)
[10:21:48.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:48.120]             }
[10:21:48.120]             else {
[10:21:48.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:48.120]             }
[10:21:48.120]             {
[10:21:48.120]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:48.120]                   0L) {
[10:21:48.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:48.120]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:48.120]                   base::options(opts)
[10:21:48.120]                 }
[10:21:48.120]                 {
[10:21:48.120]                   {
[10:21:48.120]                     NULL
[10:21:48.120]                     RNGkind("Mersenne-Twister")
[10:21:48.120]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[10:21:48.120]                       inherits = FALSE)
[10:21:48.120]                   }
[10:21:48.120]                   options(future.plan = NULL)
[10:21:48.120]                   if (is.na(NA_character_)) 
[10:21:48.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:48.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:48.120]                     .init = FALSE)
[10:21:48.120]                 }
[10:21:48.120]             }
[10:21:48.120]         }
[10:21:48.120]     })
[10:21:48.120]     if (TRUE) {
[10:21:48.120]         base::sink(type = "output", split = FALSE)
[10:21:48.120]         if (TRUE) {
[10:21:48.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:48.120]         }
[10:21:48.120]         else {
[10:21:48.120]             ...future.result["stdout"] <- base::list(NULL)
[10:21:48.120]         }
[10:21:48.120]         base::close(...future.stdout)
[10:21:48.120]         ...future.stdout <- NULL
[10:21:48.120]     }
[10:21:48.120]     ...future.result$conditions <- ...future.conditions
[10:21:48.120]     ...future.result$finished <- base::Sys.time()
[10:21:48.120]     ...future.result
[10:21:48.120] }
[10:21:48.122] assign_globals() ...
[10:21:48.122] List of 1
[10:21:48.122]  $ pkg: chr "foo"
[10:21:48.122]  - attr(*, "where")=List of 1
[10:21:48.122]   ..$ pkg:<environment: R_EmptyEnv> 
[10:21:48.122]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[10:21:48.122]  - attr(*, "resolved")= logi TRUE
[10:21:48.122]  - attr(*, "total_size")= num 42
[10:21:48.124] - copied ‘pkg’ to environment
[10:21:48.124] assign_globals() ... done
[10:21:48.124] plan(): Setting new future strategy stack:
[10:21:48.124] List of future strategies:
[10:21:48.124] 1. sequential:
[10:21:48.124]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:48.124]    - tweaked: FALSE
[10:21:48.124]    - call: NULL
[10:21:48.125] plan(): nbrOfWorkers() = 1
[10:21:48.126] plan(): Setting new future strategy stack:
[10:21:48.126] List of future strategies:
[10:21:48.126] 1. multisession:
[10:21:48.126]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:48.126]    - tweaked: FALSE
[10:21:48.126]    - call: plan(strategy)
[10:21:48.127] plan(): nbrOfWorkers() = 2
[10:21:48.127] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:48.128] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:48.128] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:48.130] - globals found: [3] ‘{’, ‘<-’, ‘+’
[10:21:48.130] Searching for globals ... DONE
[10:21:48.130] Resolving globals: TRUE
[10:21:48.130] Resolving any globals that are futures ...
[10:21:48.130] - globals: [3] ‘{’, ‘<-’, ‘+’
[10:21:48.130] Resolving any globals that are futures ... DONE
[10:21:48.131] 
[10:21:48.131] 
[10:21:48.131] getGlobalsAndPackages() ... DONE
[10:21:48.131] run() for ‘Future’ ...
[10:21:48.131] - state: ‘created’
[10:21:48.131] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:48.145] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:48.145] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:48.145]   - Field: ‘node’
[10:21:48.145]   - Field: ‘label’
[10:21:48.145]   - Field: ‘local’
[10:21:48.145]   - Field: ‘owner’
[10:21:48.145]   - Field: ‘envir’
[10:21:48.146]   - Field: ‘workers’
[10:21:48.146]   - Field: ‘packages’
[10:21:48.146]   - Field: ‘gc’
[10:21:48.146]   - Field: ‘conditions’
[10:21:48.146]   - Field: ‘persistent’
[10:21:48.146]   - Field: ‘expr’
[10:21:48.146]   - Field: ‘uuid’
[10:21:48.146]   - Field: ‘seed’
[10:21:48.146]   - Field: ‘version’
[10:21:48.146]   - Field: ‘result’
[10:21:48.146]   - Field: ‘asynchronous’
[10:21:48.147]   - Field: ‘calls’
[10:21:48.147]   - Field: ‘globals’
[10:21:48.147]   - Field: ‘stdout’
[10:21:48.147]   - Field: ‘earlySignal’
[10:21:48.147]   - Field: ‘lazy’
[10:21:48.147]   - Field: ‘state’
[10:21:48.147] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:48.147] - Launch lazy future ...
[10:21:48.147] Packages needed by the future expression (n = 0): <none>
[10:21:48.148] Packages needed by future strategies (n = 0): <none>
[10:21:48.148] {
[10:21:48.148]     {
[10:21:48.148]         {
[10:21:48.148]             ...future.startTime <- base::Sys.time()
[10:21:48.148]             {
[10:21:48.148]                 {
[10:21:48.148]                   {
[10:21:48.148]                     {
[10:21:48.148]                       base::local({
[10:21:48.148]                         has_future <- base::requireNamespace("future", 
[10:21:48.148]                           quietly = TRUE)
[10:21:48.148]                         if (has_future) {
[10:21:48.148]                           ns <- base::getNamespace("future")
[10:21:48.148]                           version <- ns[[".package"]][["version"]]
[10:21:48.148]                           if (is.null(version)) 
[10:21:48.148]                             version <- utils::packageVersion("future")
[10:21:48.148]                         }
[10:21:48.148]                         else {
[10:21:48.148]                           version <- NULL
[10:21:48.148]                         }
[10:21:48.148]                         if (!has_future || version < "1.8.0") {
[10:21:48.148]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:48.148]                             "", base::R.version$version.string), 
[10:21:48.148]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:48.148]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:48.148]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:48.148]                               "release", "version")], collapse = " "), 
[10:21:48.148]                             hostname = base::Sys.info()[["nodename"]])
[10:21:48.148]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:48.148]                             info)
[10:21:48.148]                           info <- base::paste(info, collapse = "; ")
[10:21:48.148]                           if (!has_future) {
[10:21:48.148]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:48.148]                               info)
[10:21:48.148]                           }
[10:21:48.148]                           else {
[10:21:48.148]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:48.148]                               info, version)
[10:21:48.148]                           }
[10:21:48.148]                           base::stop(msg)
[10:21:48.148]                         }
[10:21:48.148]                       })
[10:21:48.148]                     }
[10:21:48.148]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:48.148]                     base::options(mc.cores = 1L)
[10:21:48.148]                   }
[10:21:48.148]                   ...future.strategy.old <- future::plan("list")
[10:21:48.148]                   options(future.plan = NULL)
[10:21:48.148]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.148]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:48.148]                 }
[10:21:48.148]                 ...future.workdir <- getwd()
[10:21:48.148]             }
[10:21:48.148]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:48.148]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:48.148]         }
[10:21:48.148]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:48.148]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:48.148]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:48.148]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:48.148]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:48.148]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:48.148]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:48.148]             base::names(...future.oldOptions))
[10:21:48.148]     }
[10:21:48.148]     if (FALSE) {
[10:21:48.148]     }
[10:21:48.148]     else {
[10:21:48.148]         if (TRUE) {
[10:21:48.148]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:48.148]                 open = "w")
[10:21:48.148]         }
[10:21:48.148]         else {
[10:21:48.148]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:48.148]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:48.148]         }
[10:21:48.148]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:48.148]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:48.148]             base::sink(type = "output", split = FALSE)
[10:21:48.148]             base::close(...future.stdout)
[10:21:48.148]         }, add = TRUE)
[10:21:48.148]     }
[10:21:48.148]     ...future.frame <- base::sys.nframe()
[10:21:48.148]     ...future.conditions <- base::list()
[10:21:48.148]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:48.148]     if (FALSE) {
[10:21:48.148]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:48.148]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:48.148]     }
[10:21:48.148]     ...future.result <- base::tryCatch({
[10:21:48.148]         base::withCallingHandlers({
[10:21:48.148]             ...future.value <- base::withVisible(base::local({
[10:21:48.148]                 ...future.makeSendCondition <- base::local({
[10:21:48.148]                   sendCondition <- NULL
[10:21:48.148]                   function(frame = 1L) {
[10:21:48.148]                     if (is.function(sendCondition)) 
[10:21:48.148]                       return(sendCondition)
[10:21:48.148]                     ns <- getNamespace("parallel")
[10:21:48.148]                     if (exists("sendData", mode = "function", 
[10:21:48.148]                       envir = ns)) {
[10:21:48.148]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:48.148]                         envir = ns)
[10:21:48.148]                       envir <- sys.frame(frame)
[10:21:48.148]                       master <- NULL
[10:21:48.148]                       while (!identical(envir, .GlobalEnv) && 
[10:21:48.148]                         !identical(envir, emptyenv())) {
[10:21:48.148]                         if (exists("master", mode = "list", envir = envir, 
[10:21:48.148]                           inherits = FALSE)) {
[10:21:48.148]                           master <- get("master", mode = "list", 
[10:21:48.148]                             envir = envir, inherits = FALSE)
[10:21:48.148]                           if (inherits(master, c("SOCKnode", 
[10:21:48.148]                             "SOCK0node"))) {
[10:21:48.148]                             sendCondition <<- function(cond) {
[10:21:48.148]                               data <- list(type = "VALUE", value = cond, 
[10:21:48.148]                                 success = TRUE)
[10:21:48.148]                               parallel_sendData(master, data)
[10:21:48.148]                             }
[10:21:48.148]                             return(sendCondition)
[10:21:48.148]                           }
[10:21:48.148]                         }
[10:21:48.148]                         frame <- frame + 1L
[10:21:48.148]                         envir <- sys.frame(frame)
[10:21:48.148]                       }
[10:21:48.148]                     }
[10:21:48.148]                     sendCondition <<- function(cond) NULL
[10:21:48.148]                   }
[10:21:48.148]                 })
[10:21:48.148]                 withCallingHandlers({
[10:21:48.148]                   {
[10:21:48.148]                     x <- 0
[10:21:48.148]                     x <- x + 1
[10:21:48.148]                     x
[10:21:48.148]                   }
[10:21:48.148]                 }, immediateCondition = function(cond) {
[10:21:48.148]                   sendCondition <- ...future.makeSendCondition()
[10:21:48.148]                   sendCondition(cond)
[10:21:48.148]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.148]                   {
[10:21:48.148]                     inherits <- base::inherits
[10:21:48.148]                     invokeRestart <- base::invokeRestart
[10:21:48.148]                     is.null <- base::is.null
[10:21:48.148]                     muffled <- FALSE
[10:21:48.148]                     if (inherits(cond, "message")) {
[10:21:48.148]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:48.148]                       if (muffled) 
[10:21:48.148]                         invokeRestart("muffleMessage")
[10:21:48.148]                     }
[10:21:48.148]                     else if (inherits(cond, "warning")) {
[10:21:48.148]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:48.148]                       if (muffled) 
[10:21:48.148]                         invokeRestart("muffleWarning")
[10:21:48.148]                     }
[10:21:48.148]                     else if (inherits(cond, "condition")) {
[10:21:48.148]                       if (!is.null(pattern)) {
[10:21:48.148]                         computeRestarts <- base::computeRestarts
[10:21:48.148]                         grepl <- base::grepl
[10:21:48.148]                         restarts <- computeRestarts(cond)
[10:21:48.148]                         for (restart in restarts) {
[10:21:48.148]                           name <- restart$name
[10:21:48.148]                           if (is.null(name)) 
[10:21:48.148]                             next
[10:21:48.148]                           if (!grepl(pattern, name)) 
[10:21:48.148]                             next
[10:21:48.148]                           invokeRestart(restart)
[10:21:48.148]                           muffled <- TRUE
[10:21:48.148]                           break
[10:21:48.148]                         }
[10:21:48.148]                       }
[10:21:48.148]                     }
[10:21:48.148]                     invisible(muffled)
[10:21:48.148]                   }
[10:21:48.148]                   muffleCondition(cond)
[10:21:48.148]                 })
[10:21:48.148]             }))
[10:21:48.148]             future::FutureResult(value = ...future.value$value, 
[10:21:48.148]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.148]                   ...future.rng), globalenv = if (FALSE) 
[10:21:48.148]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:48.148]                     ...future.globalenv.names))
[10:21:48.148]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:48.148]         }, condition = base::local({
[10:21:48.148]             c <- base::c
[10:21:48.148]             inherits <- base::inherits
[10:21:48.148]             invokeRestart <- base::invokeRestart
[10:21:48.148]             length <- base::length
[10:21:48.148]             list <- base::list
[10:21:48.148]             seq.int <- base::seq.int
[10:21:48.148]             signalCondition <- base::signalCondition
[10:21:48.148]             sys.calls <- base::sys.calls
[10:21:48.148]             `[[` <- base::`[[`
[10:21:48.148]             `+` <- base::`+`
[10:21:48.148]             `<<-` <- base::`<<-`
[10:21:48.148]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:48.148]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:48.148]                   3L)]
[10:21:48.148]             }
[10:21:48.148]             function(cond) {
[10:21:48.148]                 is_error <- inherits(cond, "error")
[10:21:48.148]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:48.148]                   NULL)
[10:21:48.148]                 if (is_error) {
[10:21:48.148]                   sessionInformation <- function() {
[10:21:48.148]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:48.148]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:48.148]                       search = base::search(), system = base::Sys.info())
[10:21:48.148]                   }
[10:21:48.148]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.148]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:48.148]                     cond$call), session = sessionInformation(), 
[10:21:48.148]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:48.148]                   signalCondition(cond)
[10:21:48.148]                 }
[10:21:48.148]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:48.148]                 "immediateCondition"))) {
[10:21:48.148]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:48.148]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.148]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:48.148]                   if (TRUE && !signal) {
[10:21:48.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.148]                     {
[10:21:48.148]                       inherits <- base::inherits
[10:21:48.148]                       invokeRestart <- base::invokeRestart
[10:21:48.148]                       is.null <- base::is.null
[10:21:48.148]                       muffled <- FALSE
[10:21:48.148]                       if (inherits(cond, "message")) {
[10:21:48.148]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.148]                         if (muffled) 
[10:21:48.148]                           invokeRestart("muffleMessage")
[10:21:48.148]                       }
[10:21:48.148]                       else if (inherits(cond, "warning")) {
[10:21:48.148]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.148]                         if (muffled) 
[10:21:48.148]                           invokeRestart("muffleWarning")
[10:21:48.148]                       }
[10:21:48.148]                       else if (inherits(cond, "condition")) {
[10:21:48.148]                         if (!is.null(pattern)) {
[10:21:48.148]                           computeRestarts <- base::computeRestarts
[10:21:48.148]                           grepl <- base::grepl
[10:21:48.148]                           restarts <- computeRestarts(cond)
[10:21:48.148]                           for (restart in restarts) {
[10:21:48.148]                             name <- restart$name
[10:21:48.148]                             if (is.null(name)) 
[10:21:48.148]                               next
[10:21:48.148]                             if (!grepl(pattern, name)) 
[10:21:48.148]                               next
[10:21:48.148]                             invokeRestart(restart)
[10:21:48.148]                             muffled <- TRUE
[10:21:48.148]                             break
[10:21:48.148]                           }
[10:21:48.148]                         }
[10:21:48.148]                       }
[10:21:48.148]                       invisible(muffled)
[10:21:48.148]                     }
[10:21:48.148]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.148]                   }
[10:21:48.148]                 }
[10:21:48.148]                 else {
[10:21:48.148]                   if (TRUE) {
[10:21:48.148]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.148]                     {
[10:21:48.148]                       inherits <- base::inherits
[10:21:48.148]                       invokeRestart <- base::invokeRestart
[10:21:48.148]                       is.null <- base::is.null
[10:21:48.148]                       muffled <- FALSE
[10:21:48.148]                       if (inherits(cond, "message")) {
[10:21:48.148]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.148]                         if (muffled) 
[10:21:48.148]                           invokeRestart("muffleMessage")
[10:21:48.148]                       }
[10:21:48.148]                       else if (inherits(cond, "warning")) {
[10:21:48.148]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.148]                         if (muffled) 
[10:21:48.148]                           invokeRestart("muffleWarning")
[10:21:48.148]                       }
[10:21:48.148]                       else if (inherits(cond, "condition")) {
[10:21:48.148]                         if (!is.null(pattern)) {
[10:21:48.148]                           computeRestarts <- base::computeRestarts
[10:21:48.148]                           grepl <- base::grepl
[10:21:48.148]                           restarts <- computeRestarts(cond)
[10:21:48.148]                           for (restart in restarts) {
[10:21:48.148]                             name <- restart$name
[10:21:48.148]                             if (is.null(name)) 
[10:21:48.148]                               next
[10:21:48.148]                             if (!grepl(pattern, name)) 
[10:21:48.148]                               next
[10:21:48.148]                             invokeRestart(restart)
[10:21:48.148]                             muffled <- TRUE
[10:21:48.148]                             break
[10:21:48.148]                           }
[10:21:48.148]                         }
[10:21:48.148]                       }
[10:21:48.148]                       invisible(muffled)
[10:21:48.148]                     }
[10:21:48.148]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.148]                   }
[10:21:48.148]                 }
[10:21:48.148]             }
[10:21:48.148]         }))
[10:21:48.148]     }, error = function(ex) {
[10:21:48.148]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:48.148]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.148]                 ...future.rng), started = ...future.startTime, 
[10:21:48.148]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:48.148]             version = "1.8"), class = "FutureResult")
[10:21:48.148]     }, finally = {
[10:21:48.148]         if (!identical(...future.workdir, getwd())) 
[10:21:48.148]             setwd(...future.workdir)
[10:21:48.148]         {
[10:21:48.148]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:48.148]                 ...future.oldOptions$nwarnings <- NULL
[10:21:48.148]             }
[10:21:48.148]             base::options(...future.oldOptions)
[10:21:48.148]             if (.Platform$OS.type == "windows") {
[10:21:48.148]                 old_names <- names(...future.oldEnvVars)
[10:21:48.148]                 envs <- base::Sys.getenv()
[10:21:48.148]                 names <- names(envs)
[10:21:48.148]                 common <- intersect(names, old_names)
[10:21:48.148]                 added <- setdiff(names, old_names)
[10:21:48.148]                 removed <- setdiff(old_names, names)
[10:21:48.148]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:48.148]                   envs[common]]
[10:21:48.148]                 NAMES <- toupper(changed)
[10:21:48.148]                 args <- list()
[10:21:48.148]                 for (kk in seq_along(NAMES)) {
[10:21:48.148]                   name <- changed[[kk]]
[10:21:48.148]                   NAME <- NAMES[[kk]]
[10:21:48.148]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.148]                     next
[10:21:48.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.148]                 }
[10:21:48.148]                 NAMES <- toupper(added)
[10:21:48.148]                 for (kk in seq_along(NAMES)) {
[10:21:48.148]                   name <- added[[kk]]
[10:21:48.148]                   NAME <- NAMES[[kk]]
[10:21:48.148]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.148]                     next
[10:21:48.148]                   args[[name]] <- ""
[10:21:48.148]                 }
[10:21:48.148]                 NAMES <- toupper(removed)
[10:21:48.148]                 for (kk in seq_along(NAMES)) {
[10:21:48.148]                   name <- removed[[kk]]
[10:21:48.148]                   NAME <- NAMES[[kk]]
[10:21:48.148]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.148]                     next
[10:21:48.148]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.148]                 }
[10:21:48.148]                 if (length(args) > 0) 
[10:21:48.148]                   base::do.call(base::Sys.setenv, args = args)
[10:21:48.148]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:48.148]             }
[10:21:48.148]             else {
[10:21:48.148]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:48.148]             }
[10:21:48.148]             {
[10:21:48.148]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:48.148]                   0L) {
[10:21:48.148]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:48.148]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:48.148]                   base::options(opts)
[10:21:48.148]                 }
[10:21:48.148]                 {
[10:21:48.148]                   {
[10:21:48.148]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:48.148]                     NULL
[10:21:48.148]                   }
[10:21:48.148]                   options(future.plan = NULL)
[10:21:48.148]                   if (is.na(NA_character_)) 
[10:21:48.148]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.148]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:48.148]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:48.148]                     .init = FALSE)
[10:21:48.148]                 }
[10:21:48.148]             }
[10:21:48.148]         }
[10:21:48.148]     })
[10:21:48.148]     if (TRUE) {
[10:21:48.148]         base::sink(type = "output", split = FALSE)
[10:21:48.148]         if (TRUE) {
[10:21:48.148]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:48.148]         }
[10:21:48.148]         else {
[10:21:48.148]             ...future.result["stdout"] <- base::list(NULL)
[10:21:48.148]         }
[10:21:48.148]         base::close(...future.stdout)
[10:21:48.148]         ...future.stdout <- NULL
[10:21:48.148]     }
[10:21:48.148]     ...future.result$conditions <- ...future.conditions
[10:21:48.148]     ...future.result$finished <- base::Sys.time()
[10:21:48.148]     ...future.result
[10:21:48.148] }
[10:21:48.151] MultisessionFuture started
[10:21:48.151] - Launch lazy future ... done
[10:21:48.151] run() for ‘MultisessionFuture’ ... done
[10:21:48.151] result() for ClusterFuture ...
[10:21:48.151] receiveMessageFromWorker() for ClusterFuture ...
[10:21:48.151] - Validating connection of MultisessionFuture
[10:21:48.193] - received message: FutureResult
[10:21:48.193] - Received FutureResult
[10:21:48.193] - Erased future from FutureRegistry
[10:21:48.193] result() for ClusterFuture ...
[10:21:48.194] - result already collected: FutureResult
[10:21:48.194] result() for ClusterFuture ... done
[10:21:48.194] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:48.194] result() for ClusterFuture ... done
[10:21:48.194] result() for ClusterFuture ...
[10:21:48.194] - result already collected: FutureResult
[10:21:48.194] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:48.194] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:48.195] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:48.196] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:21:48.196] Searching for globals ... DONE
[10:21:48.196] Resolving globals: TRUE
[10:21:48.196] Resolving any globals that are futures ...
[10:21:48.196] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[10:21:48.197] Resolving any globals that are futures ... DONE
[10:21:48.197] Resolving futures part of globals (recursively) ...
[10:21:48.197] resolve() on list ...
[10:21:48.197]  recursive: 99
[10:21:48.197]  length: 1
[10:21:48.197]  elements: ‘x’
[10:21:48.197]  length: 0 (resolved future 1)
[10:21:48.198] resolve() on list ... DONE
[10:21:48.198] - globals: [1] ‘x’
[10:21:48.198] Resolving futures part of globals (recursively) ... DONE
[10:21:48.198] The total size of the 1 globals is 39 bytes (39 bytes)
[10:21:48.198] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[10:21:48.198] - globals: [1] ‘x’
[10:21:48.198] 
[10:21:48.198] getGlobalsAndPackages() ... DONE
[10:21:48.199] run() for ‘Future’ ...
[10:21:48.199] - state: ‘created’
[10:21:48.199] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:48.213] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:48.213] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:48.213]   - Field: ‘node’
[10:21:48.213]   - Field: ‘label’
[10:21:48.213]   - Field: ‘local’
[10:21:48.213]   - Field: ‘owner’
[10:21:48.213]   - Field: ‘envir’
[10:21:48.213]   - Field: ‘workers’
[10:21:48.214]   - Field: ‘packages’
[10:21:48.214]   - Field: ‘gc’
[10:21:48.214]   - Field: ‘conditions’
[10:21:48.214]   - Field: ‘persistent’
[10:21:48.214]   - Field: ‘expr’
[10:21:48.214]   - Field: ‘uuid’
[10:21:48.214]   - Field: ‘seed’
[10:21:48.214]   - Field: ‘version’
[10:21:48.214]   - Field: ‘result’
[10:21:48.214]   - Field: ‘asynchronous’
[10:21:48.214]   - Field: ‘calls’
[10:21:48.214]   - Field: ‘globals’
[10:21:48.217]   - Field: ‘stdout’
[10:21:48.217]   - Field: ‘earlySignal’
[10:21:48.217]   - Field: ‘lazy’
[10:21:48.217]   - Field: ‘state’
[10:21:48.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:48.217] - Launch lazy future ...
[10:21:48.218] Packages needed by the future expression (n = 0): <none>
[10:21:48.218] Packages needed by future strategies (n = 0): <none>
[10:21:48.218] {
[10:21:48.218]     {
[10:21:48.218]         {
[10:21:48.218]             ...future.startTime <- base::Sys.time()
[10:21:48.218]             {
[10:21:48.218]                 {
[10:21:48.218]                   {
[10:21:48.218]                     {
[10:21:48.218]                       base::local({
[10:21:48.218]                         has_future <- base::requireNamespace("future", 
[10:21:48.218]                           quietly = TRUE)
[10:21:48.218]                         if (has_future) {
[10:21:48.218]                           ns <- base::getNamespace("future")
[10:21:48.218]                           version <- ns[[".package"]][["version"]]
[10:21:48.218]                           if (is.null(version)) 
[10:21:48.218]                             version <- utils::packageVersion("future")
[10:21:48.218]                         }
[10:21:48.218]                         else {
[10:21:48.218]                           version <- NULL
[10:21:48.218]                         }
[10:21:48.218]                         if (!has_future || version < "1.8.0") {
[10:21:48.218]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:48.218]                             "", base::R.version$version.string), 
[10:21:48.218]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:48.218]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:48.218]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:48.218]                               "release", "version")], collapse = " "), 
[10:21:48.218]                             hostname = base::Sys.info()[["nodename"]])
[10:21:48.218]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:48.218]                             info)
[10:21:48.218]                           info <- base::paste(info, collapse = "; ")
[10:21:48.218]                           if (!has_future) {
[10:21:48.218]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:48.218]                               info)
[10:21:48.218]                           }
[10:21:48.218]                           else {
[10:21:48.218]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:48.218]                               info, version)
[10:21:48.218]                           }
[10:21:48.218]                           base::stop(msg)
[10:21:48.218]                         }
[10:21:48.218]                       })
[10:21:48.218]                     }
[10:21:48.218]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:48.218]                     base::options(mc.cores = 1L)
[10:21:48.218]                   }
[10:21:48.218]                   ...future.strategy.old <- future::plan("list")
[10:21:48.218]                   options(future.plan = NULL)
[10:21:48.218]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.218]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:48.218]                 }
[10:21:48.218]                 ...future.workdir <- getwd()
[10:21:48.218]             }
[10:21:48.218]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:48.218]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:48.218]         }
[10:21:48.218]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:48.218]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:48.218]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:48.218]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:48.218]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:48.218]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:48.218]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:48.218]             base::names(...future.oldOptions))
[10:21:48.218]     }
[10:21:48.218]     if (FALSE) {
[10:21:48.218]     }
[10:21:48.218]     else {
[10:21:48.218]         if (TRUE) {
[10:21:48.218]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:48.218]                 open = "w")
[10:21:48.218]         }
[10:21:48.218]         else {
[10:21:48.218]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:48.218]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:48.218]         }
[10:21:48.218]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:48.218]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:48.218]             base::sink(type = "output", split = FALSE)
[10:21:48.218]             base::close(...future.stdout)
[10:21:48.218]         }, add = TRUE)
[10:21:48.218]     }
[10:21:48.218]     ...future.frame <- base::sys.nframe()
[10:21:48.218]     ...future.conditions <- base::list()
[10:21:48.218]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:48.218]     if (FALSE) {
[10:21:48.218]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:48.218]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:48.218]     }
[10:21:48.218]     ...future.result <- base::tryCatch({
[10:21:48.218]         base::withCallingHandlers({
[10:21:48.218]             ...future.value <- base::withVisible(base::local({
[10:21:48.218]                 ...future.makeSendCondition <- base::local({
[10:21:48.218]                   sendCondition <- NULL
[10:21:48.218]                   function(frame = 1L) {
[10:21:48.218]                     if (is.function(sendCondition)) 
[10:21:48.218]                       return(sendCondition)
[10:21:48.218]                     ns <- getNamespace("parallel")
[10:21:48.218]                     if (exists("sendData", mode = "function", 
[10:21:48.218]                       envir = ns)) {
[10:21:48.218]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:48.218]                         envir = ns)
[10:21:48.218]                       envir <- sys.frame(frame)
[10:21:48.218]                       master <- NULL
[10:21:48.218]                       while (!identical(envir, .GlobalEnv) && 
[10:21:48.218]                         !identical(envir, emptyenv())) {
[10:21:48.218]                         if (exists("master", mode = "list", envir = envir, 
[10:21:48.218]                           inherits = FALSE)) {
[10:21:48.218]                           master <- get("master", mode = "list", 
[10:21:48.218]                             envir = envir, inherits = FALSE)
[10:21:48.218]                           if (inherits(master, c("SOCKnode", 
[10:21:48.218]                             "SOCK0node"))) {
[10:21:48.218]                             sendCondition <<- function(cond) {
[10:21:48.218]                               data <- list(type = "VALUE", value = cond, 
[10:21:48.218]                                 success = TRUE)
[10:21:48.218]                               parallel_sendData(master, data)
[10:21:48.218]                             }
[10:21:48.218]                             return(sendCondition)
[10:21:48.218]                           }
[10:21:48.218]                         }
[10:21:48.218]                         frame <- frame + 1L
[10:21:48.218]                         envir <- sys.frame(frame)
[10:21:48.218]                       }
[10:21:48.218]                     }
[10:21:48.218]                     sendCondition <<- function(cond) NULL
[10:21:48.218]                   }
[10:21:48.218]                 })
[10:21:48.218]                 withCallingHandlers({
[10:21:48.218]                   {
[10:21:48.218]                     x <- x + 1
[10:21:48.218]                     x
[10:21:48.218]                   }
[10:21:48.218]                 }, immediateCondition = function(cond) {
[10:21:48.218]                   sendCondition <- ...future.makeSendCondition()
[10:21:48.218]                   sendCondition(cond)
[10:21:48.218]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.218]                   {
[10:21:48.218]                     inherits <- base::inherits
[10:21:48.218]                     invokeRestart <- base::invokeRestart
[10:21:48.218]                     is.null <- base::is.null
[10:21:48.218]                     muffled <- FALSE
[10:21:48.218]                     if (inherits(cond, "message")) {
[10:21:48.218]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:48.218]                       if (muffled) 
[10:21:48.218]                         invokeRestart("muffleMessage")
[10:21:48.218]                     }
[10:21:48.218]                     else if (inherits(cond, "warning")) {
[10:21:48.218]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:48.218]                       if (muffled) 
[10:21:48.218]                         invokeRestart("muffleWarning")
[10:21:48.218]                     }
[10:21:48.218]                     else if (inherits(cond, "condition")) {
[10:21:48.218]                       if (!is.null(pattern)) {
[10:21:48.218]                         computeRestarts <- base::computeRestarts
[10:21:48.218]                         grepl <- base::grepl
[10:21:48.218]                         restarts <- computeRestarts(cond)
[10:21:48.218]                         for (restart in restarts) {
[10:21:48.218]                           name <- restart$name
[10:21:48.218]                           if (is.null(name)) 
[10:21:48.218]                             next
[10:21:48.218]                           if (!grepl(pattern, name)) 
[10:21:48.218]                             next
[10:21:48.218]                           invokeRestart(restart)
[10:21:48.218]                           muffled <- TRUE
[10:21:48.218]                           break
[10:21:48.218]                         }
[10:21:48.218]                       }
[10:21:48.218]                     }
[10:21:48.218]                     invisible(muffled)
[10:21:48.218]                   }
[10:21:48.218]                   muffleCondition(cond)
[10:21:48.218]                 })
[10:21:48.218]             }))
[10:21:48.218]             future::FutureResult(value = ...future.value$value, 
[10:21:48.218]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.218]                   ...future.rng), globalenv = if (FALSE) 
[10:21:48.218]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:48.218]                     ...future.globalenv.names))
[10:21:48.218]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:48.218]         }, condition = base::local({
[10:21:48.218]             c <- base::c
[10:21:48.218]             inherits <- base::inherits
[10:21:48.218]             invokeRestart <- base::invokeRestart
[10:21:48.218]             length <- base::length
[10:21:48.218]             list <- base::list
[10:21:48.218]             seq.int <- base::seq.int
[10:21:48.218]             signalCondition <- base::signalCondition
[10:21:48.218]             sys.calls <- base::sys.calls
[10:21:48.218]             `[[` <- base::`[[`
[10:21:48.218]             `+` <- base::`+`
[10:21:48.218]             `<<-` <- base::`<<-`
[10:21:48.218]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:48.218]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:48.218]                   3L)]
[10:21:48.218]             }
[10:21:48.218]             function(cond) {
[10:21:48.218]                 is_error <- inherits(cond, "error")
[10:21:48.218]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:48.218]                   NULL)
[10:21:48.218]                 if (is_error) {
[10:21:48.218]                   sessionInformation <- function() {
[10:21:48.218]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:48.218]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:48.218]                       search = base::search(), system = base::Sys.info())
[10:21:48.218]                   }
[10:21:48.218]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.218]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:48.218]                     cond$call), session = sessionInformation(), 
[10:21:48.218]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:48.218]                   signalCondition(cond)
[10:21:48.218]                 }
[10:21:48.218]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:48.218]                 "immediateCondition"))) {
[10:21:48.218]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:48.218]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.218]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:48.218]                   if (TRUE && !signal) {
[10:21:48.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.218]                     {
[10:21:48.218]                       inherits <- base::inherits
[10:21:48.218]                       invokeRestart <- base::invokeRestart
[10:21:48.218]                       is.null <- base::is.null
[10:21:48.218]                       muffled <- FALSE
[10:21:48.218]                       if (inherits(cond, "message")) {
[10:21:48.218]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.218]                         if (muffled) 
[10:21:48.218]                           invokeRestart("muffleMessage")
[10:21:48.218]                       }
[10:21:48.218]                       else if (inherits(cond, "warning")) {
[10:21:48.218]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.218]                         if (muffled) 
[10:21:48.218]                           invokeRestart("muffleWarning")
[10:21:48.218]                       }
[10:21:48.218]                       else if (inherits(cond, "condition")) {
[10:21:48.218]                         if (!is.null(pattern)) {
[10:21:48.218]                           computeRestarts <- base::computeRestarts
[10:21:48.218]                           grepl <- base::grepl
[10:21:48.218]                           restarts <- computeRestarts(cond)
[10:21:48.218]                           for (restart in restarts) {
[10:21:48.218]                             name <- restart$name
[10:21:48.218]                             if (is.null(name)) 
[10:21:48.218]                               next
[10:21:48.218]                             if (!grepl(pattern, name)) 
[10:21:48.218]                               next
[10:21:48.218]                             invokeRestart(restart)
[10:21:48.218]                             muffled <- TRUE
[10:21:48.218]                             break
[10:21:48.218]                           }
[10:21:48.218]                         }
[10:21:48.218]                       }
[10:21:48.218]                       invisible(muffled)
[10:21:48.218]                     }
[10:21:48.218]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.218]                   }
[10:21:48.218]                 }
[10:21:48.218]                 else {
[10:21:48.218]                   if (TRUE) {
[10:21:48.218]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.218]                     {
[10:21:48.218]                       inherits <- base::inherits
[10:21:48.218]                       invokeRestart <- base::invokeRestart
[10:21:48.218]                       is.null <- base::is.null
[10:21:48.218]                       muffled <- FALSE
[10:21:48.218]                       if (inherits(cond, "message")) {
[10:21:48.218]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.218]                         if (muffled) 
[10:21:48.218]                           invokeRestart("muffleMessage")
[10:21:48.218]                       }
[10:21:48.218]                       else if (inherits(cond, "warning")) {
[10:21:48.218]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.218]                         if (muffled) 
[10:21:48.218]                           invokeRestart("muffleWarning")
[10:21:48.218]                       }
[10:21:48.218]                       else if (inherits(cond, "condition")) {
[10:21:48.218]                         if (!is.null(pattern)) {
[10:21:48.218]                           computeRestarts <- base::computeRestarts
[10:21:48.218]                           grepl <- base::grepl
[10:21:48.218]                           restarts <- computeRestarts(cond)
[10:21:48.218]                           for (restart in restarts) {
[10:21:48.218]                             name <- restart$name
[10:21:48.218]                             if (is.null(name)) 
[10:21:48.218]                               next
[10:21:48.218]                             if (!grepl(pattern, name)) 
[10:21:48.218]                               next
[10:21:48.218]                             invokeRestart(restart)
[10:21:48.218]                             muffled <- TRUE
[10:21:48.218]                             break
[10:21:48.218]                           }
[10:21:48.218]                         }
[10:21:48.218]                       }
[10:21:48.218]                       invisible(muffled)
[10:21:48.218]                     }
[10:21:48.218]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.218]                   }
[10:21:48.218]                 }
[10:21:48.218]             }
[10:21:48.218]         }))
[10:21:48.218]     }, error = function(ex) {
[10:21:48.218]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:48.218]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.218]                 ...future.rng), started = ...future.startTime, 
[10:21:48.218]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:48.218]             version = "1.8"), class = "FutureResult")
[10:21:48.218]     }, finally = {
[10:21:48.218]         if (!identical(...future.workdir, getwd())) 
[10:21:48.218]             setwd(...future.workdir)
[10:21:48.218]         {
[10:21:48.218]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:48.218]                 ...future.oldOptions$nwarnings <- NULL
[10:21:48.218]             }
[10:21:48.218]             base::options(...future.oldOptions)
[10:21:48.218]             if (.Platform$OS.type == "windows") {
[10:21:48.218]                 old_names <- names(...future.oldEnvVars)
[10:21:48.218]                 envs <- base::Sys.getenv()
[10:21:48.218]                 names <- names(envs)
[10:21:48.218]                 common <- intersect(names, old_names)
[10:21:48.218]                 added <- setdiff(names, old_names)
[10:21:48.218]                 removed <- setdiff(old_names, names)
[10:21:48.218]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:48.218]                   envs[common]]
[10:21:48.218]                 NAMES <- toupper(changed)
[10:21:48.218]                 args <- list()
[10:21:48.218]                 for (kk in seq_along(NAMES)) {
[10:21:48.218]                   name <- changed[[kk]]
[10:21:48.218]                   NAME <- NAMES[[kk]]
[10:21:48.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.218]                     next
[10:21:48.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.218]                 }
[10:21:48.218]                 NAMES <- toupper(added)
[10:21:48.218]                 for (kk in seq_along(NAMES)) {
[10:21:48.218]                   name <- added[[kk]]
[10:21:48.218]                   NAME <- NAMES[[kk]]
[10:21:48.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.218]                     next
[10:21:48.218]                   args[[name]] <- ""
[10:21:48.218]                 }
[10:21:48.218]                 NAMES <- toupper(removed)
[10:21:48.218]                 for (kk in seq_along(NAMES)) {
[10:21:48.218]                   name <- removed[[kk]]
[10:21:48.218]                   NAME <- NAMES[[kk]]
[10:21:48.218]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.218]                     next
[10:21:48.218]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.218]                 }
[10:21:48.218]                 if (length(args) > 0) 
[10:21:48.218]                   base::do.call(base::Sys.setenv, args = args)
[10:21:48.218]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:48.218]             }
[10:21:48.218]             else {
[10:21:48.218]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:48.218]             }
[10:21:48.218]             {
[10:21:48.218]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:48.218]                   0L) {
[10:21:48.218]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:48.218]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:48.218]                   base::options(opts)
[10:21:48.218]                 }
[10:21:48.218]                 {
[10:21:48.218]                   {
[10:21:48.218]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:48.218]                     NULL
[10:21:48.218]                   }
[10:21:48.218]                   options(future.plan = NULL)
[10:21:48.218]                   if (is.na(NA_character_)) 
[10:21:48.218]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.218]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:48.218]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:48.218]                     .init = FALSE)
[10:21:48.218]                 }
[10:21:48.218]             }
[10:21:48.218]         }
[10:21:48.218]     })
[10:21:48.218]     if (TRUE) {
[10:21:48.218]         base::sink(type = "output", split = FALSE)
[10:21:48.218]         if (TRUE) {
[10:21:48.218]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:48.218]         }
[10:21:48.218]         else {
[10:21:48.218]             ...future.result["stdout"] <- base::list(NULL)
[10:21:48.218]         }
[10:21:48.218]         base::close(...future.stdout)
[10:21:48.218]         ...future.stdout <- NULL
[10:21:48.218]     }
[10:21:48.218]     ...future.result$conditions <- ...future.conditions
[10:21:48.218]     ...future.result$finished <- base::Sys.time()
[10:21:48.218]     ...future.result
[10:21:48.218] }
[10:21:48.221] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[10:21:48.221] Exporting ‘x’ (39 bytes) to cluster node #1 ...
[10:21:48.221] Exporting ‘x’ (39 bytes) to cluster node #1 ... DONE
[10:21:48.221] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[10:21:48.222] MultisessionFuture started
[10:21:48.222] - Launch lazy future ... done
[10:21:48.222] run() for ‘MultisessionFuture’ ... done
[10:21:48.222] result() for ClusterFuture ...
[10:21:48.222] receiveMessageFromWorker() for ClusterFuture ...
[10:21:48.222] - Validating connection of MultisessionFuture
[10:21:48.264] - received message: FutureResult
[10:21:48.264] - Received FutureResult
[10:21:48.264] - Erased future from FutureRegistry
[10:21:48.264] result() for ClusterFuture ...
[10:21:48.264] - result already collected: FutureResult
[10:21:48.265] result() for ClusterFuture ... done
[10:21:48.265] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:48.265] result() for ClusterFuture ... done
[10:21:48.265] result() for ClusterFuture ...
[10:21:48.265] - result already collected: FutureResult
[10:21:48.265] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[10:21:48.265] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[10:21:48.266] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[10:21:48.267] - globals found: [3] ‘{’, ‘<-’, ‘x’
[10:21:48.267] Searching for globals ... DONE
[10:21:48.267] Resolving globals: TRUE
[10:21:48.268] Resolving any globals that are futures ...
[10:21:48.268] - globals: [3] ‘{’, ‘<-’, ‘x’
[10:21:48.268] Resolving any globals that are futures ... DONE
[10:21:48.268] Resolving futures part of globals (recursively) ...
[10:21:48.268] resolve() on list ...
[10:21:48.268]  recursive: 99
[10:21:48.268]  length: 1
[10:21:48.268]  elements: ‘x’
[10:21:48.269]  length: 0 (resolved future 1)
[10:21:48.269] resolve() on list ... DONE
[10:21:48.269] - globals: [1] ‘x’
[10:21:48.269] Resolving futures part of globals (recursively) ... DONE
[10:21:48.269] The total size of the 1 globals is 260 bytes (260 bytes)
[10:21:48.269] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[10:21:48.269] - globals: [1] ‘x’
[10:21:48.270] 
[10:21:48.270] getGlobalsAndPackages() ... DONE
[10:21:48.270] run() for ‘Future’ ...
[10:21:48.270] - state: ‘created’
[10:21:48.270] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[10:21:48.284] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[10:21:48.284] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[10:21:48.285]   - Field: ‘node’
[10:21:48.285]   - Field: ‘label’
[10:21:48.285]   - Field: ‘local’
[10:21:48.285]   - Field: ‘owner’
[10:21:48.285]   - Field: ‘envir’
[10:21:48.285]   - Field: ‘workers’
[10:21:48.285]   - Field: ‘packages’
[10:21:48.285]   - Field: ‘gc’
[10:21:48.285]   - Field: ‘conditions’
[10:21:48.285]   - Field: ‘persistent’
[10:21:48.285]   - Field: ‘expr’
[10:21:48.286]   - Field: ‘uuid’
[10:21:48.286]   - Field: ‘seed’
[10:21:48.286]   - Field: ‘version’
[10:21:48.286]   - Field: ‘result’
[10:21:48.286]   - Field: ‘asynchronous’
[10:21:48.286]   - Field: ‘calls’
[10:21:48.286]   - Field: ‘globals’
[10:21:48.286]   - Field: ‘stdout’
[10:21:48.286]   - Field: ‘earlySignal’
[10:21:48.286]   - Field: ‘lazy’
[10:21:48.286]   - Field: ‘state’
[10:21:48.286] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[10:21:48.287] - Launch lazy future ...
[10:21:48.287] Packages needed by the future expression (n = 0): <none>
[10:21:48.287] Packages needed by future strategies (n = 0): <none>
[10:21:48.287] {
[10:21:48.287]     {
[10:21:48.287]         {
[10:21:48.287]             ...future.startTime <- base::Sys.time()
[10:21:48.287]             {
[10:21:48.287]                 {
[10:21:48.287]                   {
[10:21:48.287]                     {
[10:21:48.287]                       base::local({
[10:21:48.287]                         has_future <- base::requireNamespace("future", 
[10:21:48.287]                           quietly = TRUE)
[10:21:48.287]                         if (has_future) {
[10:21:48.287]                           ns <- base::getNamespace("future")
[10:21:48.287]                           version <- ns[[".package"]][["version"]]
[10:21:48.287]                           if (is.null(version)) 
[10:21:48.287]                             version <- utils::packageVersion("future")
[10:21:48.287]                         }
[10:21:48.287]                         else {
[10:21:48.287]                           version <- NULL
[10:21:48.287]                         }
[10:21:48.287]                         if (!has_future || version < "1.8.0") {
[10:21:48.287]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:48.287]                             "", base::R.version$version.string), 
[10:21:48.287]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:48.287]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:48.287]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:48.287]                               "release", "version")], collapse = " "), 
[10:21:48.287]                             hostname = base::Sys.info()[["nodename"]])
[10:21:48.287]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:48.287]                             info)
[10:21:48.287]                           info <- base::paste(info, collapse = "; ")
[10:21:48.287]                           if (!has_future) {
[10:21:48.287]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:48.287]                               info)
[10:21:48.287]                           }
[10:21:48.287]                           else {
[10:21:48.287]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:48.287]                               info, version)
[10:21:48.287]                           }
[10:21:48.287]                           base::stop(msg)
[10:21:48.287]                         }
[10:21:48.287]                       })
[10:21:48.287]                     }
[10:21:48.287]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:48.287]                     base::options(mc.cores = 1L)
[10:21:48.287]                   }
[10:21:48.287]                   ...future.strategy.old <- future::plan("list")
[10:21:48.287]                   options(future.plan = NULL)
[10:21:48.287]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.287]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:48.287]                 }
[10:21:48.287]                 ...future.workdir <- getwd()
[10:21:48.287]             }
[10:21:48.287]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:48.287]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:48.287]         }
[10:21:48.287]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[10:21:48.287]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[10:21:48.287]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[10:21:48.287]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[10:21:48.287]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:48.287]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:48.287]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:48.287]             base::names(...future.oldOptions))
[10:21:48.287]     }
[10:21:48.287]     if (FALSE) {
[10:21:48.287]     }
[10:21:48.287]     else {
[10:21:48.287]         if (TRUE) {
[10:21:48.287]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:48.287]                 open = "w")
[10:21:48.287]         }
[10:21:48.287]         else {
[10:21:48.287]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:48.287]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:48.287]         }
[10:21:48.287]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:48.287]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:48.287]             base::sink(type = "output", split = FALSE)
[10:21:48.287]             base::close(...future.stdout)
[10:21:48.287]         }, add = TRUE)
[10:21:48.287]     }
[10:21:48.287]     ...future.frame <- base::sys.nframe()
[10:21:48.287]     ...future.conditions <- base::list()
[10:21:48.287]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:48.287]     if (FALSE) {
[10:21:48.287]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:48.287]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:48.287]     }
[10:21:48.287]     ...future.result <- base::tryCatch({
[10:21:48.287]         base::withCallingHandlers({
[10:21:48.287]             ...future.value <- base::withVisible(base::local({
[10:21:48.287]                 ...future.makeSendCondition <- base::local({
[10:21:48.287]                   sendCondition <- NULL
[10:21:48.287]                   function(frame = 1L) {
[10:21:48.287]                     if (is.function(sendCondition)) 
[10:21:48.287]                       return(sendCondition)
[10:21:48.287]                     ns <- getNamespace("parallel")
[10:21:48.287]                     if (exists("sendData", mode = "function", 
[10:21:48.287]                       envir = ns)) {
[10:21:48.287]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:48.287]                         envir = ns)
[10:21:48.287]                       envir <- sys.frame(frame)
[10:21:48.287]                       master <- NULL
[10:21:48.287]                       while (!identical(envir, .GlobalEnv) && 
[10:21:48.287]                         !identical(envir, emptyenv())) {
[10:21:48.287]                         if (exists("master", mode = "list", envir = envir, 
[10:21:48.287]                           inherits = FALSE)) {
[10:21:48.287]                           master <- get("master", mode = "list", 
[10:21:48.287]                             envir = envir, inherits = FALSE)
[10:21:48.287]                           if (inherits(master, c("SOCKnode", 
[10:21:48.287]                             "SOCK0node"))) {
[10:21:48.287]                             sendCondition <<- function(cond) {
[10:21:48.287]                               data <- list(type = "VALUE", value = cond, 
[10:21:48.287]                                 success = TRUE)
[10:21:48.287]                               parallel_sendData(master, data)
[10:21:48.287]                             }
[10:21:48.287]                             return(sendCondition)
[10:21:48.287]                           }
[10:21:48.287]                         }
[10:21:48.287]                         frame <- frame + 1L
[10:21:48.287]                         envir <- sys.frame(frame)
[10:21:48.287]                       }
[10:21:48.287]                     }
[10:21:48.287]                     sendCondition <<- function(cond) NULL
[10:21:48.287]                   }
[10:21:48.287]                 })
[10:21:48.287]                 withCallingHandlers({
[10:21:48.287]                   {
[10:21:48.287]                     x <- x()
[10:21:48.287]                     x
[10:21:48.287]                   }
[10:21:48.287]                 }, immediateCondition = function(cond) {
[10:21:48.287]                   sendCondition <- ...future.makeSendCondition()
[10:21:48.287]                   sendCondition(cond)
[10:21:48.287]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.287]                   {
[10:21:48.287]                     inherits <- base::inherits
[10:21:48.287]                     invokeRestart <- base::invokeRestart
[10:21:48.287]                     is.null <- base::is.null
[10:21:48.287]                     muffled <- FALSE
[10:21:48.287]                     if (inherits(cond, "message")) {
[10:21:48.287]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:48.287]                       if (muffled) 
[10:21:48.287]                         invokeRestart("muffleMessage")
[10:21:48.287]                     }
[10:21:48.287]                     else if (inherits(cond, "warning")) {
[10:21:48.287]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:48.287]                       if (muffled) 
[10:21:48.287]                         invokeRestart("muffleWarning")
[10:21:48.287]                     }
[10:21:48.287]                     else if (inherits(cond, "condition")) {
[10:21:48.287]                       if (!is.null(pattern)) {
[10:21:48.287]                         computeRestarts <- base::computeRestarts
[10:21:48.287]                         grepl <- base::grepl
[10:21:48.287]                         restarts <- computeRestarts(cond)
[10:21:48.287]                         for (restart in restarts) {
[10:21:48.287]                           name <- restart$name
[10:21:48.287]                           if (is.null(name)) 
[10:21:48.287]                             next
[10:21:48.287]                           if (!grepl(pattern, name)) 
[10:21:48.287]                             next
[10:21:48.287]                           invokeRestart(restart)
[10:21:48.287]                           muffled <- TRUE
[10:21:48.287]                           break
[10:21:48.287]                         }
[10:21:48.287]                       }
[10:21:48.287]                     }
[10:21:48.287]                     invisible(muffled)
[10:21:48.287]                   }
[10:21:48.287]                   muffleCondition(cond)
[10:21:48.287]                 })
[10:21:48.287]             }))
[10:21:48.287]             future::FutureResult(value = ...future.value$value, 
[10:21:48.287]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.287]                   ...future.rng), globalenv = if (FALSE) 
[10:21:48.287]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:48.287]                     ...future.globalenv.names))
[10:21:48.287]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:48.287]         }, condition = base::local({
[10:21:48.287]             c <- base::c
[10:21:48.287]             inherits <- base::inherits
[10:21:48.287]             invokeRestart <- base::invokeRestart
[10:21:48.287]             length <- base::length
[10:21:48.287]             list <- base::list
[10:21:48.287]             seq.int <- base::seq.int
[10:21:48.287]             signalCondition <- base::signalCondition
[10:21:48.287]             sys.calls <- base::sys.calls
[10:21:48.287]             `[[` <- base::`[[`
[10:21:48.287]             `+` <- base::`+`
[10:21:48.287]             `<<-` <- base::`<<-`
[10:21:48.287]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:48.287]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:48.287]                   3L)]
[10:21:48.287]             }
[10:21:48.287]             function(cond) {
[10:21:48.287]                 is_error <- inherits(cond, "error")
[10:21:48.287]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:48.287]                   NULL)
[10:21:48.287]                 if (is_error) {
[10:21:48.287]                   sessionInformation <- function() {
[10:21:48.287]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:48.287]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:48.287]                       search = base::search(), system = base::Sys.info())
[10:21:48.287]                   }
[10:21:48.287]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.287]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:48.287]                     cond$call), session = sessionInformation(), 
[10:21:48.287]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:48.287]                   signalCondition(cond)
[10:21:48.287]                 }
[10:21:48.287]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:48.287]                 "immediateCondition"))) {
[10:21:48.287]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:48.287]                   ...future.conditions[[length(...future.conditions) + 
[10:21:48.287]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:48.287]                   if (TRUE && !signal) {
[10:21:48.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.287]                     {
[10:21:48.287]                       inherits <- base::inherits
[10:21:48.287]                       invokeRestart <- base::invokeRestart
[10:21:48.287]                       is.null <- base::is.null
[10:21:48.287]                       muffled <- FALSE
[10:21:48.287]                       if (inherits(cond, "message")) {
[10:21:48.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.287]                         if (muffled) 
[10:21:48.287]                           invokeRestart("muffleMessage")
[10:21:48.287]                       }
[10:21:48.287]                       else if (inherits(cond, "warning")) {
[10:21:48.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.287]                         if (muffled) 
[10:21:48.287]                           invokeRestart("muffleWarning")
[10:21:48.287]                       }
[10:21:48.287]                       else if (inherits(cond, "condition")) {
[10:21:48.287]                         if (!is.null(pattern)) {
[10:21:48.287]                           computeRestarts <- base::computeRestarts
[10:21:48.287]                           grepl <- base::grepl
[10:21:48.287]                           restarts <- computeRestarts(cond)
[10:21:48.287]                           for (restart in restarts) {
[10:21:48.287]                             name <- restart$name
[10:21:48.287]                             if (is.null(name)) 
[10:21:48.287]                               next
[10:21:48.287]                             if (!grepl(pattern, name)) 
[10:21:48.287]                               next
[10:21:48.287]                             invokeRestart(restart)
[10:21:48.287]                             muffled <- TRUE
[10:21:48.287]                             break
[10:21:48.287]                           }
[10:21:48.287]                         }
[10:21:48.287]                       }
[10:21:48.287]                       invisible(muffled)
[10:21:48.287]                     }
[10:21:48.287]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.287]                   }
[10:21:48.287]                 }
[10:21:48.287]                 else {
[10:21:48.287]                   if (TRUE) {
[10:21:48.287]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:48.287]                     {
[10:21:48.287]                       inherits <- base::inherits
[10:21:48.287]                       invokeRestart <- base::invokeRestart
[10:21:48.287]                       is.null <- base::is.null
[10:21:48.287]                       muffled <- FALSE
[10:21:48.287]                       if (inherits(cond, "message")) {
[10:21:48.287]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:48.287]                         if (muffled) 
[10:21:48.287]                           invokeRestart("muffleMessage")
[10:21:48.287]                       }
[10:21:48.287]                       else if (inherits(cond, "warning")) {
[10:21:48.287]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:48.287]                         if (muffled) 
[10:21:48.287]                           invokeRestart("muffleWarning")
[10:21:48.287]                       }
[10:21:48.287]                       else if (inherits(cond, "condition")) {
[10:21:48.287]                         if (!is.null(pattern)) {
[10:21:48.287]                           computeRestarts <- base::computeRestarts
[10:21:48.287]                           grepl <- base::grepl
[10:21:48.287]                           restarts <- computeRestarts(cond)
[10:21:48.287]                           for (restart in restarts) {
[10:21:48.287]                             name <- restart$name
[10:21:48.287]                             if (is.null(name)) 
[10:21:48.287]                               next
[10:21:48.287]                             if (!grepl(pattern, name)) 
[10:21:48.287]                               next
[10:21:48.287]                             invokeRestart(restart)
[10:21:48.287]                             muffled <- TRUE
[10:21:48.287]                             break
[10:21:48.287]                           }
[10:21:48.287]                         }
[10:21:48.287]                       }
[10:21:48.287]                       invisible(muffled)
[10:21:48.287]                     }
[10:21:48.287]                     muffleCondition(cond, pattern = "^muffle")
[10:21:48.287]                   }
[10:21:48.287]                 }
[10:21:48.287]             }
[10:21:48.287]         }))
[10:21:48.287]     }, error = function(ex) {
[10:21:48.287]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:48.287]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:48.287]                 ...future.rng), started = ...future.startTime, 
[10:21:48.287]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:48.287]             version = "1.8"), class = "FutureResult")
[10:21:48.287]     }, finally = {
[10:21:48.287]         if (!identical(...future.workdir, getwd())) 
[10:21:48.287]             setwd(...future.workdir)
[10:21:48.287]         {
[10:21:48.287]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:48.287]                 ...future.oldOptions$nwarnings <- NULL
[10:21:48.287]             }
[10:21:48.287]             base::options(...future.oldOptions)
[10:21:48.287]             if (.Platform$OS.type == "windows") {
[10:21:48.287]                 old_names <- names(...future.oldEnvVars)
[10:21:48.287]                 envs <- base::Sys.getenv()
[10:21:48.287]                 names <- names(envs)
[10:21:48.287]                 common <- intersect(names, old_names)
[10:21:48.287]                 added <- setdiff(names, old_names)
[10:21:48.287]                 removed <- setdiff(old_names, names)
[10:21:48.287]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:48.287]                   envs[common]]
[10:21:48.287]                 NAMES <- toupper(changed)
[10:21:48.287]                 args <- list()
[10:21:48.287]                 for (kk in seq_along(NAMES)) {
[10:21:48.287]                   name <- changed[[kk]]
[10:21:48.287]                   NAME <- NAMES[[kk]]
[10:21:48.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.287]                     next
[10:21:48.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.287]                 }
[10:21:48.287]                 NAMES <- toupper(added)
[10:21:48.287]                 for (kk in seq_along(NAMES)) {
[10:21:48.287]                   name <- added[[kk]]
[10:21:48.287]                   NAME <- NAMES[[kk]]
[10:21:48.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.287]                     next
[10:21:48.287]                   args[[name]] <- ""
[10:21:48.287]                 }
[10:21:48.287]                 NAMES <- toupper(removed)
[10:21:48.287]                 for (kk in seq_along(NAMES)) {
[10:21:48.287]                   name <- removed[[kk]]
[10:21:48.287]                   NAME <- NAMES[[kk]]
[10:21:48.287]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:48.287]                     next
[10:21:48.287]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:48.287]                 }
[10:21:48.287]                 if (length(args) > 0) 
[10:21:48.287]                   base::do.call(base::Sys.setenv, args = args)
[10:21:48.287]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:48.287]             }
[10:21:48.287]             else {
[10:21:48.287]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:48.287]             }
[10:21:48.287]             {
[10:21:48.287]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:48.287]                   0L) {
[10:21:48.287]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:48.287]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:48.287]                   base::options(opts)
[10:21:48.287]                 }
[10:21:48.287]                 {
[10:21:48.287]                   {
[10:21:48.287]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:48.287]                     NULL
[10:21:48.287]                   }
[10:21:48.287]                   options(future.plan = NULL)
[10:21:48.287]                   if (is.na(NA_character_)) 
[10:21:48.287]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:48.287]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:48.287]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:48.287]                     .init = FALSE)
[10:21:48.287]                 }
[10:21:48.287]             }
[10:21:48.287]         }
[10:21:48.287]     })
[10:21:48.287]     if (TRUE) {
[10:21:48.287]         base::sink(type = "output", split = FALSE)
[10:21:48.287]         if (TRUE) {
[10:21:48.287]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:48.287]         }
[10:21:48.287]         else {
[10:21:48.287]             ...future.result["stdout"] <- base::list(NULL)
[10:21:48.287]         }
[10:21:48.287]         base::close(...future.stdout)
[10:21:48.287]         ...future.stdout <- NULL
[10:21:48.287]     }
[10:21:48.287]     ...future.result$conditions <- ...future.conditions
[10:21:48.287]     ...future.result$finished <- base::Sys.time()
[10:21:48.287]     ...future.result
[10:21:48.287] }
[10:21:48.290] Exporting 1 global objects (554 bytes) to cluster node #1 ...
[10:21:48.290] Exporting ‘x’ (260 bytes) to cluster node #1 ...
[10:21:48.291] Exporting ‘x’ (260 bytes) to cluster node #1 ... DONE
[10:21:48.291] Exporting 1 global objects (554 bytes) to cluster node #1 ... DONE
[10:21:48.291] MultisessionFuture started
[10:21:48.292] - Launch lazy future ... done
[10:21:48.292] run() for ‘MultisessionFuture’ ... done
[10:21:48.292] result() for ClusterFuture ...
[10:21:48.292] receiveMessageFromWorker() for ClusterFuture ...
[10:21:48.292] - Validating connection of MultisessionFuture
[10:21:48.334] - received message: FutureResult
[10:21:48.334] - Received FutureResult
[10:21:48.334] - Erased future from FutureRegistry
[10:21:48.334] result() for ClusterFuture ...
[10:21:48.334] - result already collected: FutureResult
[10:21:48.334] result() for ClusterFuture ... done
[10:21:48.335] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:48.335] result() for ClusterFuture ... done
[10:21:48.335] result() for ClusterFuture ...
[10:21:48.335] - result already collected: FutureResult
[10:21:48.335] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[10:21:48.336] plan(): Setting new future strategy stack:
[10:21:48.336] List of future strategies:
[10:21:48.336] 1. FutureStrategy:
[10:21:48.336]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:48.336]    - tweaked: FALSE
[10:21:48.336]    - call: future::plan(oplan)
[10:21:48.337] plan(): nbrOfWorkers() = 1
> 
