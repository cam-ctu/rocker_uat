
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[08:28:14.104] plan(): Setting new future strategy stack:
[08:28:14.105] List of future strategies:
[08:28:14.105] 1. sequential:
[08:28:14.105]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.105]    - tweaked: FALSE
[08:28:14.105]    - call: future::plan("sequential")
[08:28:14.118] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[08:28:14.210] plan(): Setting new future strategy stack:
[08:28:14.210] List of future strategies:
[08:28:14.210] 1. sequential:
[08:28:14.210]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.210]    - tweaked: FALSE
[08:28:14.210]    - call: plan(strategy)
[08:28:14.221] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.223] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.223] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.228] - globals found: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.229] Searching for globals ... DONE
[08:28:14.229] Resolving globals: TRUE
[08:28:14.229] Resolving any globals that are futures ...
[08:28:14.229] - globals: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.229] Resolving any globals that are futures ... DONE
[08:28:14.229] 
[08:28:14.230] 
[08:28:14.230] getGlobalsAndPackages() ... DONE
[08:28:14.230] run() for ‘Future’ ...
[08:28:14.230] - state: ‘created’
[08:28:14.231] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.231] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.231] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.231]   - Field: ‘label’
[08:28:14.231]   - Field: ‘local’
[08:28:14.231]   - Field: ‘owner’
[08:28:14.231]   - Field: ‘envir’
[08:28:14.231]   - Field: ‘packages’
[08:28:14.232]   - Field: ‘gc’
[08:28:14.232]   - Field: ‘conditions’
[08:28:14.232]   - Field: ‘expr’
[08:28:14.232]   - Field: ‘uuid’
[08:28:14.232]   - Field: ‘seed’
[08:28:14.232]   - Field: ‘version’
[08:28:14.232]   - Field: ‘result’
[08:28:14.232]   - Field: ‘asynchronous’
[08:28:14.232]   - Field: ‘calls’
[08:28:14.232]   - Field: ‘globals’
[08:28:14.232]   - Field: ‘stdout’
[08:28:14.232]   - Field: ‘earlySignal’
[08:28:14.232]   - Field: ‘lazy’
[08:28:14.233]   - Field: ‘state’
[08:28:14.233] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.233] - Launch lazy future ...
[08:28:14.233] Packages needed by the future expression (n = 0): <none>
[08:28:14.233] Packages needed by future strategies (n = 0): <none>
[08:28:14.234] {
[08:28:14.234]     {
[08:28:14.234]         {
[08:28:14.234]             ...future.startTime <- base::Sys.time()
[08:28:14.234]             {
[08:28:14.234]                 {
[08:28:14.234]                   {
[08:28:14.234]                     base::local({
[08:28:14.234]                       has_future <- base::requireNamespace("future", 
[08:28:14.234]                         quietly = TRUE)
[08:28:14.234]                       if (has_future) {
[08:28:14.234]                         ns <- base::getNamespace("future")
[08:28:14.234]                         version <- ns[[".package"]][["version"]]
[08:28:14.234]                         if (is.null(version)) 
[08:28:14.234]                           version <- utils::packageVersion("future")
[08:28:14.234]                       }
[08:28:14.234]                       else {
[08:28:14.234]                         version <- NULL
[08:28:14.234]                       }
[08:28:14.234]                       if (!has_future || version < "1.8.0") {
[08:28:14.234]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.234]                           "", base::R.version$version.string), 
[08:28:14.234]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.234]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.234]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.234]                             "release", "version")], collapse = " "), 
[08:28:14.234]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.234]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.234]                           info)
[08:28:14.234]                         info <- base::paste(info, collapse = "; ")
[08:28:14.234]                         if (!has_future) {
[08:28:14.234]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.234]                             info)
[08:28:14.234]                         }
[08:28:14.234]                         else {
[08:28:14.234]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.234]                             info, version)
[08:28:14.234]                         }
[08:28:14.234]                         base::stop(msg)
[08:28:14.234]                       }
[08:28:14.234]                     })
[08:28:14.234]                   }
[08:28:14.234]                   ...future.strategy.old <- future::plan("list")
[08:28:14.234]                   options(future.plan = NULL)
[08:28:14.234]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.234]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.234]                 }
[08:28:14.234]                 ...future.workdir <- getwd()
[08:28:14.234]             }
[08:28:14.234]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.234]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.234]         }
[08:28:14.234]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.234]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.234]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.234]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.234]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.234]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.234]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.234]             base::names(...future.oldOptions))
[08:28:14.234]     }
[08:28:14.234]     if (FALSE) {
[08:28:14.234]     }
[08:28:14.234]     else {
[08:28:14.234]         if (TRUE) {
[08:28:14.234]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.234]                 open = "w")
[08:28:14.234]         }
[08:28:14.234]         else {
[08:28:14.234]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.234]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.234]         }
[08:28:14.234]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.234]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.234]             base::sink(type = "output", split = FALSE)
[08:28:14.234]             base::close(...future.stdout)
[08:28:14.234]         }, add = TRUE)
[08:28:14.234]     }
[08:28:14.234]     ...future.frame <- base::sys.nframe()
[08:28:14.234]     ...future.conditions <- base::list()
[08:28:14.234]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.234]     if (FALSE) {
[08:28:14.234]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.234]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.234]     }
[08:28:14.234]     ...future.result <- base::tryCatch({
[08:28:14.234]         base::withCallingHandlers({
[08:28:14.234]             ...future.value <- base::withVisible(base::local({
[08:28:14.234]                 b <- a
[08:28:14.234]                 a <- 2
[08:28:14.234]                 a * b
[08:28:14.234]             }))
[08:28:14.234]             future::FutureResult(value = ...future.value$value, 
[08:28:14.234]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.234]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.234]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.234]                     ...future.globalenv.names))
[08:28:14.234]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.234]         }, condition = base::local({
[08:28:14.234]             c <- base::c
[08:28:14.234]             inherits <- base::inherits
[08:28:14.234]             invokeRestart <- base::invokeRestart
[08:28:14.234]             length <- base::length
[08:28:14.234]             list <- base::list
[08:28:14.234]             seq.int <- base::seq.int
[08:28:14.234]             signalCondition <- base::signalCondition
[08:28:14.234]             sys.calls <- base::sys.calls
[08:28:14.234]             `[[` <- base::`[[`
[08:28:14.234]             `+` <- base::`+`
[08:28:14.234]             `<<-` <- base::`<<-`
[08:28:14.234]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.234]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.234]                   3L)]
[08:28:14.234]             }
[08:28:14.234]             function(cond) {
[08:28:14.234]                 is_error <- inherits(cond, "error")
[08:28:14.234]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.234]                   NULL)
[08:28:14.234]                 if (is_error) {
[08:28:14.234]                   sessionInformation <- function() {
[08:28:14.234]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.234]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.234]                       search = base::search(), system = base::Sys.info())
[08:28:14.234]                   }
[08:28:14.234]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.234]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.234]                     cond$call), session = sessionInformation(), 
[08:28:14.234]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.234]                   signalCondition(cond)
[08:28:14.234]                 }
[08:28:14.234]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.234]                 "immediateCondition"))) {
[08:28:14.234]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.234]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.234]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.234]                   if (TRUE && !signal) {
[08:28:14.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.234]                     {
[08:28:14.234]                       inherits <- base::inherits
[08:28:14.234]                       invokeRestart <- base::invokeRestart
[08:28:14.234]                       is.null <- base::is.null
[08:28:14.234]                       muffled <- FALSE
[08:28:14.234]                       if (inherits(cond, "message")) {
[08:28:14.234]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.234]                         if (muffled) 
[08:28:14.234]                           invokeRestart("muffleMessage")
[08:28:14.234]                       }
[08:28:14.234]                       else if (inherits(cond, "warning")) {
[08:28:14.234]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.234]                         if (muffled) 
[08:28:14.234]                           invokeRestart("muffleWarning")
[08:28:14.234]                       }
[08:28:14.234]                       else if (inherits(cond, "condition")) {
[08:28:14.234]                         if (!is.null(pattern)) {
[08:28:14.234]                           computeRestarts <- base::computeRestarts
[08:28:14.234]                           grepl <- base::grepl
[08:28:14.234]                           restarts <- computeRestarts(cond)
[08:28:14.234]                           for (restart in restarts) {
[08:28:14.234]                             name <- restart$name
[08:28:14.234]                             if (is.null(name)) 
[08:28:14.234]                               next
[08:28:14.234]                             if (!grepl(pattern, name)) 
[08:28:14.234]                               next
[08:28:14.234]                             invokeRestart(restart)
[08:28:14.234]                             muffled <- TRUE
[08:28:14.234]                             break
[08:28:14.234]                           }
[08:28:14.234]                         }
[08:28:14.234]                       }
[08:28:14.234]                       invisible(muffled)
[08:28:14.234]                     }
[08:28:14.234]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.234]                   }
[08:28:14.234]                 }
[08:28:14.234]                 else {
[08:28:14.234]                   if (TRUE) {
[08:28:14.234]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.234]                     {
[08:28:14.234]                       inherits <- base::inherits
[08:28:14.234]                       invokeRestart <- base::invokeRestart
[08:28:14.234]                       is.null <- base::is.null
[08:28:14.234]                       muffled <- FALSE
[08:28:14.234]                       if (inherits(cond, "message")) {
[08:28:14.234]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.234]                         if (muffled) 
[08:28:14.234]                           invokeRestart("muffleMessage")
[08:28:14.234]                       }
[08:28:14.234]                       else if (inherits(cond, "warning")) {
[08:28:14.234]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.234]                         if (muffled) 
[08:28:14.234]                           invokeRestart("muffleWarning")
[08:28:14.234]                       }
[08:28:14.234]                       else if (inherits(cond, "condition")) {
[08:28:14.234]                         if (!is.null(pattern)) {
[08:28:14.234]                           computeRestarts <- base::computeRestarts
[08:28:14.234]                           grepl <- base::grepl
[08:28:14.234]                           restarts <- computeRestarts(cond)
[08:28:14.234]                           for (restart in restarts) {
[08:28:14.234]                             name <- restart$name
[08:28:14.234]                             if (is.null(name)) 
[08:28:14.234]                               next
[08:28:14.234]                             if (!grepl(pattern, name)) 
[08:28:14.234]                               next
[08:28:14.234]                             invokeRestart(restart)
[08:28:14.234]                             muffled <- TRUE
[08:28:14.234]                             break
[08:28:14.234]                           }
[08:28:14.234]                         }
[08:28:14.234]                       }
[08:28:14.234]                       invisible(muffled)
[08:28:14.234]                     }
[08:28:14.234]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.234]                   }
[08:28:14.234]                 }
[08:28:14.234]             }
[08:28:14.234]         }))
[08:28:14.234]     }, error = function(ex) {
[08:28:14.234]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.234]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.234]                 ...future.rng), started = ...future.startTime, 
[08:28:14.234]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.234]             version = "1.8"), class = "FutureResult")
[08:28:14.234]     }, finally = {
[08:28:14.234]         if (!identical(...future.workdir, getwd())) 
[08:28:14.234]             setwd(...future.workdir)
[08:28:14.234]         {
[08:28:14.234]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.234]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.234]             }
[08:28:14.234]             base::options(...future.oldOptions)
[08:28:14.234]             if (.Platform$OS.type == "windows") {
[08:28:14.234]                 old_names <- names(...future.oldEnvVars)
[08:28:14.234]                 envs <- base::Sys.getenv()
[08:28:14.234]                 names <- names(envs)
[08:28:14.234]                 common <- intersect(names, old_names)
[08:28:14.234]                 added <- setdiff(names, old_names)
[08:28:14.234]                 removed <- setdiff(old_names, names)
[08:28:14.234]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.234]                   envs[common]]
[08:28:14.234]                 NAMES <- toupper(changed)
[08:28:14.234]                 args <- list()
[08:28:14.234]                 for (kk in seq_along(NAMES)) {
[08:28:14.234]                   name <- changed[[kk]]
[08:28:14.234]                   NAME <- NAMES[[kk]]
[08:28:14.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.234]                     next
[08:28:14.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.234]                 }
[08:28:14.234]                 NAMES <- toupper(added)
[08:28:14.234]                 for (kk in seq_along(NAMES)) {
[08:28:14.234]                   name <- added[[kk]]
[08:28:14.234]                   NAME <- NAMES[[kk]]
[08:28:14.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.234]                     next
[08:28:14.234]                   args[[name]] <- ""
[08:28:14.234]                 }
[08:28:14.234]                 NAMES <- toupper(removed)
[08:28:14.234]                 for (kk in seq_along(NAMES)) {
[08:28:14.234]                   name <- removed[[kk]]
[08:28:14.234]                   NAME <- NAMES[[kk]]
[08:28:14.234]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.234]                     next
[08:28:14.234]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.234]                 }
[08:28:14.234]                 if (length(args) > 0) 
[08:28:14.234]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.234]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.234]             }
[08:28:14.234]             else {
[08:28:14.234]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.234]             }
[08:28:14.234]             {
[08:28:14.234]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.234]                   0L) {
[08:28:14.234]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.234]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.234]                   base::options(opts)
[08:28:14.234]                 }
[08:28:14.234]                 {
[08:28:14.234]                   {
[08:28:14.234]                     NULL
[08:28:14.234]                     RNGkind("Mersenne-Twister")
[08:28:14.234]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.234]                       inherits = FALSE)
[08:28:14.234]                   }
[08:28:14.234]                   options(future.plan = NULL)
[08:28:14.234]                   if (is.na(NA_character_)) 
[08:28:14.234]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.234]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.234]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.234]                     .init = FALSE)
[08:28:14.234]                 }
[08:28:14.234]             }
[08:28:14.234]         }
[08:28:14.234]     })
[08:28:14.234]     if (TRUE) {
[08:28:14.234]         base::sink(type = "output", split = FALSE)
[08:28:14.234]         if (TRUE) {
[08:28:14.234]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.234]         }
[08:28:14.234]         else {
[08:28:14.234]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.234]         }
[08:28:14.234]         base::close(...future.stdout)
[08:28:14.234]         ...future.stdout <- NULL
[08:28:14.234]     }
[08:28:14.234]     ...future.result$conditions <- ...future.conditions
[08:28:14.234]     ...future.result$finished <- base::Sys.time()
[08:28:14.234]     ...future.result
[08:28:14.234] }
[08:28:14.236] plan(): Setting new future strategy stack:
[08:28:14.236] List of future strategies:
[08:28:14.236] 1. sequential:
[08:28:14.236]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.236]    - tweaked: FALSE
[08:28:14.236]    - call: NULL
[08:28:14.237] plan(): nbrOfWorkers() = 1
[08:28:14.238] plan(): Setting new future strategy stack:
[08:28:14.238] List of future strategies:
[08:28:14.238] 1. sequential:
[08:28:14.238]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.238]    - tweaked: FALSE
[08:28:14.238]    - call: plan(strategy)
[08:28:14.238] plan(): nbrOfWorkers() = 1
[08:28:14.238] SequentialFuture started (and completed)
[08:28:14.239] - Launch lazy future ... done
[08:28:14.239] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.239] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.240] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.241] - globals found: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.241] Searching for globals ... DONE
[08:28:14.241] Resolving globals: TRUE
[08:28:14.241] Resolving any globals that are futures ...
[08:28:14.241] - globals: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.241] Resolving any globals that are futures ... DONE
[08:28:14.242] 
[08:28:14.242] 
[08:28:14.242] getGlobalsAndPackages() ... DONE
[08:28:14.242] run() for ‘Future’ ...
[08:28:14.242] - state: ‘created’
[08:28:14.244] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.244] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.244] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.244]   - Field: ‘label’
[08:28:14.244]   - Field: ‘local’
[08:28:14.244]   - Field: ‘owner’
[08:28:14.244]   - Field: ‘envir’
[08:28:14.245]   - Field: ‘packages’
[08:28:14.245]   - Field: ‘gc’
[08:28:14.245]   - Field: ‘conditions’
[08:28:14.245]   - Field: ‘expr’
[08:28:14.245]   - Field: ‘uuid’
[08:28:14.245]   - Field: ‘seed’
[08:28:14.245]   - Field: ‘version’
[08:28:14.245]   - Field: ‘result’
[08:28:14.245]   - Field: ‘asynchronous’
[08:28:14.245]   - Field: ‘calls’
[08:28:14.245]   - Field: ‘globals’
[08:28:14.245]   - Field: ‘stdout’
[08:28:14.246]   - Field: ‘earlySignal’
[08:28:14.246]   - Field: ‘lazy’
[08:28:14.246]   - Field: ‘state’
[08:28:14.246] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.246] - Launch lazy future ...
[08:28:14.246] Packages needed by the future expression (n = 0): <none>
[08:28:14.246] Packages needed by future strategies (n = 0): <none>
[08:28:14.247] {
[08:28:14.247]     {
[08:28:14.247]         {
[08:28:14.247]             ...future.startTime <- base::Sys.time()
[08:28:14.247]             {
[08:28:14.247]                 {
[08:28:14.247]                   {
[08:28:14.247]                     base::local({
[08:28:14.247]                       has_future <- base::requireNamespace("future", 
[08:28:14.247]                         quietly = TRUE)
[08:28:14.247]                       if (has_future) {
[08:28:14.247]                         ns <- base::getNamespace("future")
[08:28:14.247]                         version <- ns[[".package"]][["version"]]
[08:28:14.247]                         if (is.null(version)) 
[08:28:14.247]                           version <- utils::packageVersion("future")
[08:28:14.247]                       }
[08:28:14.247]                       else {
[08:28:14.247]                         version <- NULL
[08:28:14.247]                       }
[08:28:14.247]                       if (!has_future || version < "1.8.0") {
[08:28:14.247]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.247]                           "", base::R.version$version.string), 
[08:28:14.247]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.247]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.247]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.247]                             "release", "version")], collapse = " "), 
[08:28:14.247]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.247]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.247]                           info)
[08:28:14.247]                         info <- base::paste(info, collapse = "; ")
[08:28:14.247]                         if (!has_future) {
[08:28:14.247]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.247]                             info)
[08:28:14.247]                         }
[08:28:14.247]                         else {
[08:28:14.247]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.247]                             info, version)
[08:28:14.247]                         }
[08:28:14.247]                         base::stop(msg)
[08:28:14.247]                       }
[08:28:14.247]                     })
[08:28:14.247]                   }
[08:28:14.247]                   ...future.strategy.old <- future::plan("list")
[08:28:14.247]                   options(future.plan = NULL)
[08:28:14.247]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.247]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.247]                 }
[08:28:14.247]                 ...future.workdir <- getwd()
[08:28:14.247]             }
[08:28:14.247]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.247]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.247]         }
[08:28:14.247]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.247]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.247]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.247]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.247]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.247]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.247]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.247]             base::names(...future.oldOptions))
[08:28:14.247]     }
[08:28:14.247]     if (FALSE) {
[08:28:14.247]     }
[08:28:14.247]     else {
[08:28:14.247]         if (TRUE) {
[08:28:14.247]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.247]                 open = "w")
[08:28:14.247]         }
[08:28:14.247]         else {
[08:28:14.247]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.247]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.247]         }
[08:28:14.247]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.247]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.247]             base::sink(type = "output", split = FALSE)
[08:28:14.247]             base::close(...future.stdout)
[08:28:14.247]         }, add = TRUE)
[08:28:14.247]     }
[08:28:14.247]     ...future.frame <- base::sys.nframe()
[08:28:14.247]     ...future.conditions <- base::list()
[08:28:14.247]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.247]     if (FALSE) {
[08:28:14.247]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.247]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.247]     }
[08:28:14.247]     ...future.result <- base::tryCatch({
[08:28:14.247]         base::withCallingHandlers({
[08:28:14.247]             ...future.value <- base::withVisible(base::local({
[08:28:14.247]                 b <- a
[08:28:14.247]                 a <- 2
[08:28:14.247]                 a * b
[08:28:14.247]             }))
[08:28:14.247]             future::FutureResult(value = ...future.value$value, 
[08:28:14.247]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.247]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.247]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.247]                     ...future.globalenv.names))
[08:28:14.247]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.247]         }, condition = base::local({
[08:28:14.247]             c <- base::c
[08:28:14.247]             inherits <- base::inherits
[08:28:14.247]             invokeRestart <- base::invokeRestart
[08:28:14.247]             length <- base::length
[08:28:14.247]             list <- base::list
[08:28:14.247]             seq.int <- base::seq.int
[08:28:14.247]             signalCondition <- base::signalCondition
[08:28:14.247]             sys.calls <- base::sys.calls
[08:28:14.247]             `[[` <- base::`[[`
[08:28:14.247]             `+` <- base::`+`
[08:28:14.247]             `<<-` <- base::`<<-`
[08:28:14.247]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.247]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.247]                   3L)]
[08:28:14.247]             }
[08:28:14.247]             function(cond) {
[08:28:14.247]                 is_error <- inherits(cond, "error")
[08:28:14.247]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.247]                   NULL)
[08:28:14.247]                 if (is_error) {
[08:28:14.247]                   sessionInformation <- function() {
[08:28:14.247]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.247]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.247]                       search = base::search(), system = base::Sys.info())
[08:28:14.247]                   }
[08:28:14.247]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.247]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.247]                     cond$call), session = sessionInformation(), 
[08:28:14.247]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.247]                   signalCondition(cond)
[08:28:14.247]                 }
[08:28:14.247]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.247]                 "immediateCondition"))) {
[08:28:14.247]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.247]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.247]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.247]                   if (TRUE && !signal) {
[08:28:14.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.247]                     {
[08:28:14.247]                       inherits <- base::inherits
[08:28:14.247]                       invokeRestart <- base::invokeRestart
[08:28:14.247]                       is.null <- base::is.null
[08:28:14.247]                       muffled <- FALSE
[08:28:14.247]                       if (inherits(cond, "message")) {
[08:28:14.247]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.247]                         if (muffled) 
[08:28:14.247]                           invokeRestart("muffleMessage")
[08:28:14.247]                       }
[08:28:14.247]                       else if (inherits(cond, "warning")) {
[08:28:14.247]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.247]                         if (muffled) 
[08:28:14.247]                           invokeRestart("muffleWarning")
[08:28:14.247]                       }
[08:28:14.247]                       else if (inherits(cond, "condition")) {
[08:28:14.247]                         if (!is.null(pattern)) {
[08:28:14.247]                           computeRestarts <- base::computeRestarts
[08:28:14.247]                           grepl <- base::grepl
[08:28:14.247]                           restarts <- computeRestarts(cond)
[08:28:14.247]                           for (restart in restarts) {
[08:28:14.247]                             name <- restart$name
[08:28:14.247]                             if (is.null(name)) 
[08:28:14.247]                               next
[08:28:14.247]                             if (!grepl(pattern, name)) 
[08:28:14.247]                               next
[08:28:14.247]                             invokeRestart(restart)
[08:28:14.247]                             muffled <- TRUE
[08:28:14.247]                             break
[08:28:14.247]                           }
[08:28:14.247]                         }
[08:28:14.247]                       }
[08:28:14.247]                       invisible(muffled)
[08:28:14.247]                     }
[08:28:14.247]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.247]                   }
[08:28:14.247]                 }
[08:28:14.247]                 else {
[08:28:14.247]                   if (TRUE) {
[08:28:14.247]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.247]                     {
[08:28:14.247]                       inherits <- base::inherits
[08:28:14.247]                       invokeRestart <- base::invokeRestart
[08:28:14.247]                       is.null <- base::is.null
[08:28:14.247]                       muffled <- FALSE
[08:28:14.247]                       if (inherits(cond, "message")) {
[08:28:14.247]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.247]                         if (muffled) 
[08:28:14.247]                           invokeRestart("muffleMessage")
[08:28:14.247]                       }
[08:28:14.247]                       else if (inherits(cond, "warning")) {
[08:28:14.247]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.247]                         if (muffled) 
[08:28:14.247]                           invokeRestart("muffleWarning")
[08:28:14.247]                       }
[08:28:14.247]                       else if (inherits(cond, "condition")) {
[08:28:14.247]                         if (!is.null(pattern)) {
[08:28:14.247]                           computeRestarts <- base::computeRestarts
[08:28:14.247]                           grepl <- base::grepl
[08:28:14.247]                           restarts <- computeRestarts(cond)
[08:28:14.247]                           for (restart in restarts) {
[08:28:14.247]                             name <- restart$name
[08:28:14.247]                             if (is.null(name)) 
[08:28:14.247]                               next
[08:28:14.247]                             if (!grepl(pattern, name)) 
[08:28:14.247]                               next
[08:28:14.247]                             invokeRestart(restart)
[08:28:14.247]                             muffled <- TRUE
[08:28:14.247]                             break
[08:28:14.247]                           }
[08:28:14.247]                         }
[08:28:14.247]                       }
[08:28:14.247]                       invisible(muffled)
[08:28:14.247]                     }
[08:28:14.247]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.247]                   }
[08:28:14.247]                 }
[08:28:14.247]             }
[08:28:14.247]         }))
[08:28:14.247]     }, error = function(ex) {
[08:28:14.247]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.247]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.247]                 ...future.rng), started = ...future.startTime, 
[08:28:14.247]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.247]             version = "1.8"), class = "FutureResult")
[08:28:14.247]     }, finally = {
[08:28:14.247]         if (!identical(...future.workdir, getwd())) 
[08:28:14.247]             setwd(...future.workdir)
[08:28:14.247]         {
[08:28:14.247]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.247]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.247]             }
[08:28:14.247]             base::options(...future.oldOptions)
[08:28:14.247]             if (.Platform$OS.type == "windows") {
[08:28:14.247]                 old_names <- names(...future.oldEnvVars)
[08:28:14.247]                 envs <- base::Sys.getenv()
[08:28:14.247]                 names <- names(envs)
[08:28:14.247]                 common <- intersect(names, old_names)
[08:28:14.247]                 added <- setdiff(names, old_names)
[08:28:14.247]                 removed <- setdiff(old_names, names)
[08:28:14.247]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.247]                   envs[common]]
[08:28:14.247]                 NAMES <- toupper(changed)
[08:28:14.247]                 args <- list()
[08:28:14.247]                 for (kk in seq_along(NAMES)) {
[08:28:14.247]                   name <- changed[[kk]]
[08:28:14.247]                   NAME <- NAMES[[kk]]
[08:28:14.247]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.247]                     next
[08:28:14.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.247]                 }
[08:28:14.247]                 NAMES <- toupper(added)
[08:28:14.247]                 for (kk in seq_along(NAMES)) {
[08:28:14.247]                   name <- added[[kk]]
[08:28:14.247]                   NAME <- NAMES[[kk]]
[08:28:14.247]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.247]                     next
[08:28:14.247]                   args[[name]] <- ""
[08:28:14.247]                 }
[08:28:14.247]                 NAMES <- toupper(removed)
[08:28:14.247]                 for (kk in seq_along(NAMES)) {
[08:28:14.247]                   name <- removed[[kk]]
[08:28:14.247]                   NAME <- NAMES[[kk]]
[08:28:14.247]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.247]                     next
[08:28:14.247]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.247]                 }
[08:28:14.247]                 if (length(args) > 0) 
[08:28:14.247]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.247]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.247]             }
[08:28:14.247]             else {
[08:28:14.247]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.247]             }
[08:28:14.247]             {
[08:28:14.247]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.247]                   0L) {
[08:28:14.247]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.247]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.247]                   base::options(opts)
[08:28:14.247]                 }
[08:28:14.247]                 {
[08:28:14.247]                   {
[08:28:14.247]                     NULL
[08:28:14.247]                     RNGkind("Mersenne-Twister")
[08:28:14.247]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.247]                       inherits = FALSE)
[08:28:14.247]                   }
[08:28:14.247]                   options(future.plan = NULL)
[08:28:14.247]                   if (is.na(NA_character_)) 
[08:28:14.247]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.247]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.247]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.247]                     .init = FALSE)
[08:28:14.247]                 }
[08:28:14.247]             }
[08:28:14.247]         }
[08:28:14.247]     })
[08:28:14.247]     if (TRUE) {
[08:28:14.247]         base::sink(type = "output", split = FALSE)
[08:28:14.247]         if (TRUE) {
[08:28:14.247]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.247]         }
[08:28:14.247]         else {
[08:28:14.247]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.247]         }
[08:28:14.247]         base::close(...future.stdout)
[08:28:14.247]         ...future.stdout <- NULL
[08:28:14.247]     }
[08:28:14.247]     ...future.result$conditions <- ...future.conditions
[08:28:14.247]     ...future.result$finished <- base::Sys.time()
[08:28:14.247]     ...future.result
[08:28:14.247] }
[08:28:14.248] plan(): Setting new future strategy stack:
[08:28:14.248] List of future strategies:
[08:28:14.248] 1. sequential:
[08:28:14.248]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.248]    - tweaked: FALSE
[08:28:14.248]    - call: NULL
[08:28:14.249] plan(): nbrOfWorkers() = 1
[08:28:14.250] plan(): Setting new future strategy stack:
[08:28:14.250] List of future strategies:
[08:28:14.250] 1. sequential:
[08:28:14.250]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.250]    - tweaked: FALSE
[08:28:14.250]    - call: plan(strategy)
[08:28:14.250] plan(): nbrOfWorkers() = 1
[08:28:14.250] SequentialFuture started (and completed)
[08:28:14.250] signalConditions() ...
[08:28:14.251]  - include = ‘immediateCondition’
[08:28:14.251]  - exclude = 
[08:28:14.251]  - resignal = FALSE
[08:28:14.251]  - Number of conditions: 1
[08:28:14.251] signalConditions() ... done
[08:28:14.251] - Launch lazy future ... done
[08:28:14.251] run() for ‘SequentialFuture’ ... done
[08:28:14.251] signalConditions() ...
[08:28:14.251]  - include = ‘immediateCondition’
[08:28:14.251]  - exclude = 
[08:28:14.251]  - resignal = FALSE
[08:28:14.251]  - Number of conditions: 1
[08:28:14.252] signalConditions() ... done
[08:28:14.252] Future state: ‘finished’
[08:28:14.252] signalConditions() ...
[08:28:14.252]  - include = ‘condition’
[08:28:14.252]  - exclude = ‘immediateCondition’
[08:28:14.252]  - resignal = TRUE
[08:28:14.252]  - Number of conditions: 1
[08:28:14.252]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:14.252] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.266] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.267] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.268] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.268] Searching for globals ... DONE
[08:28:14.268] Resolving globals: TRUE
[08:28:14.268] Resolving any globals that are futures ...
[08:28:14.268] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.268] Resolving any globals that are futures ... DONE
[08:28:14.269] Resolving futures part of globals (recursively) ...
[08:28:14.269] resolve() on list ...
[08:28:14.269]  recursive: 99
[08:28:14.270]  length: 1
[08:28:14.270]  elements: ‘ii’
[08:28:14.270]  length: 0 (resolved future 1)
[08:28:14.270] resolve() on list ... DONE
[08:28:14.270] - globals: [1] ‘ii’
[08:28:14.271] Resolving futures part of globals (recursively) ... DONE
[08:28:14.272] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.272] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.272] - globals: [1] ‘ii’
[08:28:14.272] 
[08:28:14.272] getGlobalsAndPackages() ... DONE
[08:28:14.273] run() for ‘Future’ ...
[08:28:14.273] - state: ‘created’
[08:28:14.273] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.273] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.273] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.273]   - Field: ‘label’
[08:28:14.273]   - Field: ‘local’
[08:28:14.274]   - Field: ‘owner’
[08:28:14.274]   - Field: ‘envir’
[08:28:14.274]   - Field: ‘packages’
[08:28:14.274]   - Field: ‘gc’
[08:28:14.274]   - Field: ‘conditions’
[08:28:14.274]   - Field: ‘expr’
[08:28:14.274]   - Field: ‘uuid’
[08:28:14.274]   - Field: ‘seed’
[08:28:14.274]   - Field: ‘version’
[08:28:14.274]   - Field: ‘result’
[08:28:14.274]   - Field: ‘asynchronous’
[08:28:14.274]   - Field: ‘calls’
[08:28:14.275]   - Field: ‘globals’
[08:28:14.275]   - Field: ‘stdout’
[08:28:14.275]   - Field: ‘earlySignal’
[08:28:14.275]   - Field: ‘lazy’
[08:28:14.275]   - Field: ‘state’
[08:28:14.275] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.275] - Launch lazy future ...
[08:28:14.275] Packages needed by the future expression (n = 0): <none>
[08:28:14.275] Packages needed by future strategies (n = 0): <none>
[08:28:14.276] {
[08:28:14.276]     {
[08:28:14.276]         {
[08:28:14.276]             ...future.startTime <- base::Sys.time()
[08:28:14.276]             {
[08:28:14.276]                 {
[08:28:14.276]                   {
[08:28:14.276]                     base::local({
[08:28:14.276]                       has_future <- base::requireNamespace("future", 
[08:28:14.276]                         quietly = TRUE)
[08:28:14.276]                       if (has_future) {
[08:28:14.276]                         ns <- base::getNamespace("future")
[08:28:14.276]                         version <- ns[[".package"]][["version"]]
[08:28:14.276]                         if (is.null(version)) 
[08:28:14.276]                           version <- utils::packageVersion("future")
[08:28:14.276]                       }
[08:28:14.276]                       else {
[08:28:14.276]                         version <- NULL
[08:28:14.276]                       }
[08:28:14.276]                       if (!has_future || version < "1.8.0") {
[08:28:14.276]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.276]                           "", base::R.version$version.string), 
[08:28:14.276]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.276]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.276]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.276]                             "release", "version")], collapse = " "), 
[08:28:14.276]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.276]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.276]                           info)
[08:28:14.276]                         info <- base::paste(info, collapse = "; ")
[08:28:14.276]                         if (!has_future) {
[08:28:14.276]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.276]                             info)
[08:28:14.276]                         }
[08:28:14.276]                         else {
[08:28:14.276]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.276]                             info, version)
[08:28:14.276]                         }
[08:28:14.276]                         base::stop(msg)
[08:28:14.276]                       }
[08:28:14.276]                     })
[08:28:14.276]                   }
[08:28:14.276]                   ...future.strategy.old <- future::plan("list")
[08:28:14.276]                   options(future.plan = NULL)
[08:28:14.276]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.276]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.276]                 }
[08:28:14.276]                 ...future.workdir <- getwd()
[08:28:14.276]             }
[08:28:14.276]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.276]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.276]         }
[08:28:14.276]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.276]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.276]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.276]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.276]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.276]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.276]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.276]             base::names(...future.oldOptions))
[08:28:14.276]     }
[08:28:14.276]     if (FALSE) {
[08:28:14.276]     }
[08:28:14.276]     else {
[08:28:14.276]         if (TRUE) {
[08:28:14.276]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.276]                 open = "w")
[08:28:14.276]         }
[08:28:14.276]         else {
[08:28:14.276]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.276]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.276]         }
[08:28:14.276]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.276]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.276]             base::sink(type = "output", split = FALSE)
[08:28:14.276]             base::close(...future.stdout)
[08:28:14.276]         }, add = TRUE)
[08:28:14.276]     }
[08:28:14.276]     ...future.frame <- base::sys.nframe()
[08:28:14.276]     ...future.conditions <- base::list()
[08:28:14.276]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.276]     if (FALSE) {
[08:28:14.276]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.276]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.276]     }
[08:28:14.276]     ...future.result <- base::tryCatch({
[08:28:14.276]         base::withCallingHandlers({
[08:28:14.276]             ...future.value <- base::withVisible(base::local({
[08:28:14.276]                 b <- a * ii
[08:28:14.276]                 a <- 0
[08:28:14.276]                 b
[08:28:14.276]             }))
[08:28:14.276]             future::FutureResult(value = ...future.value$value, 
[08:28:14.276]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.276]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.276]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.276]                     ...future.globalenv.names))
[08:28:14.276]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.276]         }, condition = base::local({
[08:28:14.276]             c <- base::c
[08:28:14.276]             inherits <- base::inherits
[08:28:14.276]             invokeRestart <- base::invokeRestart
[08:28:14.276]             length <- base::length
[08:28:14.276]             list <- base::list
[08:28:14.276]             seq.int <- base::seq.int
[08:28:14.276]             signalCondition <- base::signalCondition
[08:28:14.276]             sys.calls <- base::sys.calls
[08:28:14.276]             `[[` <- base::`[[`
[08:28:14.276]             `+` <- base::`+`
[08:28:14.276]             `<<-` <- base::`<<-`
[08:28:14.276]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.276]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.276]                   3L)]
[08:28:14.276]             }
[08:28:14.276]             function(cond) {
[08:28:14.276]                 is_error <- inherits(cond, "error")
[08:28:14.276]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.276]                   NULL)
[08:28:14.276]                 if (is_error) {
[08:28:14.276]                   sessionInformation <- function() {
[08:28:14.276]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.276]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.276]                       search = base::search(), system = base::Sys.info())
[08:28:14.276]                   }
[08:28:14.276]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.276]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.276]                     cond$call), session = sessionInformation(), 
[08:28:14.276]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.276]                   signalCondition(cond)
[08:28:14.276]                 }
[08:28:14.276]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.276]                 "immediateCondition"))) {
[08:28:14.276]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.276]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.276]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.276]                   if (TRUE && !signal) {
[08:28:14.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.276]                     {
[08:28:14.276]                       inherits <- base::inherits
[08:28:14.276]                       invokeRestart <- base::invokeRestart
[08:28:14.276]                       is.null <- base::is.null
[08:28:14.276]                       muffled <- FALSE
[08:28:14.276]                       if (inherits(cond, "message")) {
[08:28:14.276]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.276]                         if (muffled) 
[08:28:14.276]                           invokeRestart("muffleMessage")
[08:28:14.276]                       }
[08:28:14.276]                       else if (inherits(cond, "warning")) {
[08:28:14.276]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.276]                         if (muffled) 
[08:28:14.276]                           invokeRestart("muffleWarning")
[08:28:14.276]                       }
[08:28:14.276]                       else if (inherits(cond, "condition")) {
[08:28:14.276]                         if (!is.null(pattern)) {
[08:28:14.276]                           computeRestarts <- base::computeRestarts
[08:28:14.276]                           grepl <- base::grepl
[08:28:14.276]                           restarts <- computeRestarts(cond)
[08:28:14.276]                           for (restart in restarts) {
[08:28:14.276]                             name <- restart$name
[08:28:14.276]                             if (is.null(name)) 
[08:28:14.276]                               next
[08:28:14.276]                             if (!grepl(pattern, name)) 
[08:28:14.276]                               next
[08:28:14.276]                             invokeRestart(restart)
[08:28:14.276]                             muffled <- TRUE
[08:28:14.276]                             break
[08:28:14.276]                           }
[08:28:14.276]                         }
[08:28:14.276]                       }
[08:28:14.276]                       invisible(muffled)
[08:28:14.276]                     }
[08:28:14.276]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.276]                   }
[08:28:14.276]                 }
[08:28:14.276]                 else {
[08:28:14.276]                   if (TRUE) {
[08:28:14.276]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.276]                     {
[08:28:14.276]                       inherits <- base::inherits
[08:28:14.276]                       invokeRestart <- base::invokeRestart
[08:28:14.276]                       is.null <- base::is.null
[08:28:14.276]                       muffled <- FALSE
[08:28:14.276]                       if (inherits(cond, "message")) {
[08:28:14.276]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.276]                         if (muffled) 
[08:28:14.276]                           invokeRestart("muffleMessage")
[08:28:14.276]                       }
[08:28:14.276]                       else if (inherits(cond, "warning")) {
[08:28:14.276]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.276]                         if (muffled) 
[08:28:14.276]                           invokeRestart("muffleWarning")
[08:28:14.276]                       }
[08:28:14.276]                       else if (inherits(cond, "condition")) {
[08:28:14.276]                         if (!is.null(pattern)) {
[08:28:14.276]                           computeRestarts <- base::computeRestarts
[08:28:14.276]                           grepl <- base::grepl
[08:28:14.276]                           restarts <- computeRestarts(cond)
[08:28:14.276]                           for (restart in restarts) {
[08:28:14.276]                             name <- restart$name
[08:28:14.276]                             if (is.null(name)) 
[08:28:14.276]                               next
[08:28:14.276]                             if (!grepl(pattern, name)) 
[08:28:14.276]                               next
[08:28:14.276]                             invokeRestart(restart)
[08:28:14.276]                             muffled <- TRUE
[08:28:14.276]                             break
[08:28:14.276]                           }
[08:28:14.276]                         }
[08:28:14.276]                       }
[08:28:14.276]                       invisible(muffled)
[08:28:14.276]                     }
[08:28:14.276]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.276]                   }
[08:28:14.276]                 }
[08:28:14.276]             }
[08:28:14.276]         }))
[08:28:14.276]     }, error = function(ex) {
[08:28:14.276]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.276]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.276]                 ...future.rng), started = ...future.startTime, 
[08:28:14.276]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.276]             version = "1.8"), class = "FutureResult")
[08:28:14.276]     }, finally = {
[08:28:14.276]         if (!identical(...future.workdir, getwd())) 
[08:28:14.276]             setwd(...future.workdir)
[08:28:14.276]         {
[08:28:14.276]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.276]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.276]             }
[08:28:14.276]             base::options(...future.oldOptions)
[08:28:14.276]             if (.Platform$OS.type == "windows") {
[08:28:14.276]                 old_names <- names(...future.oldEnvVars)
[08:28:14.276]                 envs <- base::Sys.getenv()
[08:28:14.276]                 names <- names(envs)
[08:28:14.276]                 common <- intersect(names, old_names)
[08:28:14.276]                 added <- setdiff(names, old_names)
[08:28:14.276]                 removed <- setdiff(old_names, names)
[08:28:14.276]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.276]                   envs[common]]
[08:28:14.276]                 NAMES <- toupper(changed)
[08:28:14.276]                 args <- list()
[08:28:14.276]                 for (kk in seq_along(NAMES)) {
[08:28:14.276]                   name <- changed[[kk]]
[08:28:14.276]                   NAME <- NAMES[[kk]]
[08:28:14.276]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.276]                     next
[08:28:14.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.276]                 }
[08:28:14.276]                 NAMES <- toupper(added)
[08:28:14.276]                 for (kk in seq_along(NAMES)) {
[08:28:14.276]                   name <- added[[kk]]
[08:28:14.276]                   NAME <- NAMES[[kk]]
[08:28:14.276]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.276]                     next
[08:28:14.276]                   args[[name]] <- ""
[08:28:14.276]                 }
[08:28:14.276]                 NAMES <- toupper(removed)
[08:28:14.276]                 for (kk in seq_along(NAMES)) {
[08:28:14.276]                   name <- removed[[kk]]
[08:28:14.276]                   NAME <- NAMES[[kk]]
[08:28:14.276]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.276]                     next
[08:28:14.276]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.276]                 }
[08:28:14.276]                 if (length(args) > 0) 
[08:28:14.276]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.276]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.276]             }
[08:28:14.276]             else {
[08:28:14.276]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.276]             }
[08:28:14.276]             {
[08:28:14.276]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.276]                   0L) {
[08:28:14.276]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.276]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.276]                   base::options(opts)
[08:28:14.276]                 }
[08:28:14.276]                 {
[08:28:14.276]                   {
[08:28:14.276]                     NULL
[08:28:14.276]                     RNGkind("Mersenne-Twister")
[08:28:14.276]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.276]                       inherits = FALSE)
[08:28:14.276]                   }
[08:28:14.276]                   options(future.plan = NULL)
[08:28:14.276]                   if (is.na(NA_character_)) 
[08:28:14.276]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.276]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.276]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.276]                     .init = FALSE)
[08:28:14.276]                 }
[08:28:14.276]             }
[08:28:14.276]         }
[08:28:14.276]     })
[08:28:14.276]     if (TRUE) {
[08:28:14.276]         base::sink(type = "output", split = FALSE)
[08:28:14.276]         if (TRUE) {
[08:28:14.276]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.276]         }
[08:28:14.276]         else {
[08:28:14.276]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.276]         }
[08:28:14.276]         base::close(...future.stdout)
[08:28:14.276]         ...future.stdout <- NULL
[08:28:14.276]     }
[08:28:14.276]     ...future.result$conditions <- ...future.conditions
[08:28:14.276]     ...future.result$finished <- base::Sys.time()
[08:28:14.276]     ...future.result
[08:28:14.276] }
[08:28:14.277] assign_globals() ...
[08:28:14.277] List of 1
[08:28:14.277]  $ ii: int 1
[08:28:14.277]  - attr(*, "where")=List of 1
[08:28:14.277]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.277]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.277]  - attr(*, "resolved")= logi TRUE
[08:28:14.277]  - attr(*, "total_size")= num 35
[08:28:14.277]  - attr(*, "already-done")= logi TRUE
[08:28:14.280] - copied ‘ii’ to environment
[08:28:14.280] assign_globals() ... done
[08:28:14.280] plan(): Setting new future strategy stack:
[08:28:14.280] List of future strategies:
[08:28:14.280] 1. sequential:
[08:28:14.280]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.280]    - tweaked: FALSE
[08:28:14.280]    - call: NULL
[08:28:14.281] plan(): nbrOfWorkers() = 1
[08:28:14.281] plan(): Setting new future strategy stack:
[08:28:14.281] List of future strategies:
[08:28:14.281] 1. sequential:
[08:28:14.281]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.281]    - tweaked: FALSE
[08:28:14.281]    - call: plan(strategy)
[08:28:14.282] plan(): nbrOfWorkers() = 1
[08:28:14.282] SequentialFuture started (and completed)
[08:28:14.282] - Launch lazy future ... done
[08:28:14.282] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.283] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.283] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.284] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.284] Searching for globals ... DONE
[08:28:14.284] Resolving globals: TRUE
[08:28:14.284] Resolving any globals that are futures ...
[08:28:14.284] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.285] Resolving any globals that are futures ... DONE
[08:28:14.285] Resolving futures part of globals (recursively) ...
[08:28:14.285] resolve() on list ...
[08:28:14.285]  recursive: 99
[08:28:14.285]  length: 1
[08:28:14.285]  elements: ‘ii’
[08:28:14.285]  length: 0 (resolved future 1)
[08:28:14.285] resolve() on list ... DONE
[08:28:14.286] - globals: [1] ‘ii’
[08:28:14.286] Resolving futures part of globals (recursively) ... DONE
[08:28:14.286] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.286] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.286] - globals: [1] ‘ii’
[08:28:14.286] 
[08:28:14.286] getGlobalsAndPackages() ... DONE
[08:28:14.287] run() for ‘Future’ ...
[08:28:14.287] - state: ‘created’
[08:28:14.287] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.287] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.287] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.287]   - Field: ‘label’
[08:28:14.287]   - Field: ‘local’
[08:28:14.287]   - Field: ‘owner’
[08:28:14.287]   - Field: ‘envir’
[08:28:14.288]   - Field: ‘packages’
[08:28:14.288]   - Field: ‘gc’
[08:28:14.288]   - Field: ‘conditions’
[08:28:14.288]   - Field: ‘expr’
[08:28:14.288]   - Field: ‘uuid’
[08:28:14.288]   - Field: ‘seed’
[08:28:14.288]   - Field: ‘version’
[08:28:14.288]   - Field: ‘result’
[08:28:14.288]   - Field: ‘asynchronous’
[08:28:14.288]   - Field: ‘calls’
[08:28:14.288]   - Field: ‘globals’
[08:28:14.288]   - Field: ‘stdout’
[08:28:14.289]   - Field: ‘earlySignal’
[08:28:14.289]   - Field: ‘lazy’
[08:28:14.289]   - Field: ‘state’
[08:28:14.289] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.289] - Launch lazy future ...
[08:28:14.289] Packages needed by the future expression (n = 0): <none>
[08:28:14.289] Packages needed by future strategies (n = 0): <none>
[08:28:14.289] {
[08:28:14.289]     {
[08:28:14.289]         {
[08:28:14.289]             ...future.startTime <- base::Sys.time()
[08:28:14.289]             {
[08:28:14.289]                 {
[08:28:14.289]                   {
[08:28:14.289]                     base::local({
[08:28:14.289]                       has_future <- base::requireNamespace("future", 
[08:28:14.289]                         quietly = TRUE)
[08:28:14.289]                       if (has_future) {
[08:28:14.289]                         ns <- base::getNamespace("future")
[08:28:14.289]                         version <- ns[[".package"]][["version"]]
[08:28:14.289]                         if (is.null(version)) 
[08:28:14.289]                           version <- utils::packageVersion("future")
[08:28:14.289]                       }
[08:28:14.289]                       else {
[08:28:14.289]                         version <- NULL
[08:28:14.289]                       }
[08:28:14.289]                       if (!has_future || version < "1.8.0") {
[08:28:14.289]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.289]                           "", base::R.version$version.string), 
[08:28:14.289]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.289]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.289]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.289]                             "release", "version")], collapse = " "), 
[08:28:14.289]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.289]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.289]                           info)
[08:28:14.289]                         info <- base::paste(info, collapse = "; ")
[08:28:14.289]                         if (!has_future) {
[08:28:14.289]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.289]                             info)
[08:28:14.289]                         }
[08:28:14.289]                         else {
[08:28:14.289]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.289]                             info, version)
[08:28:14.289]                         }
[08:28:14.289]                         base::stop(msg)
[08:28:14.289]                       }
[08:28:14.289]                     })
[08:28:14.289]                   }
[08:28:14.289]                   ...future.strategy.old <- future::plan("list")
[08:28:14.289]                   options(future.plan = NULL)
[08:28:14.289]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.289]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.289]                 }
[08:28:14.289]                 ...future.workdir <- getwd()
[08:28:14.289]             }
[08:28:14.289]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.289]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.289]         }
[08:28:14.289]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.289]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.289]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.289]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.289]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.289]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.289]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.289]             base::names(...future.oldOptions))
[08:28:14.289]     }
[08:28:14.289]     if (FALSE) {
[08:28:14.289]     }
[08:28:14.289]     else {
[08:28:14.289]         if (TRUE) {
[08:28:14.289]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.289]                 open = "w")
[08:28:14.289]         }
[08:28:14.289]         else {
[08:28:14.289]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.289]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.289]         }
[08:28:14.289]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.289]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.289]             base::sink(type = "output", split = FALSE)
[08:28:14.289]             base::close(...future.stdout)
[08:28:14.289]         }, add = TRUE)
[08:28:14.289]     }
[08:28:14.289]     ...future.frame <- base::sys.nframe()
[08:28:14.289]     ...future.conditions <- base::list()
[08:28:14.289]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.289]     if (FALSE) {
[08:28:14.289]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.289]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.289]     }
[08:28:14.289]     ...future.result <- base::tryCatch({
[08:28:14.289]         base::withCallingHandlers({
[08:28:14.289]             ...future.value <- base::withVisible(base::local({
[08:28:14.289]                 b <- a * ii
[08:28:14.289]                 a <- 0
[08:28:14.289]                 b
[08:28:14.289]             }))
[08:28:14.289]             future::FutureResult(value = ...future.value$value, 
[08:28:14.289]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.289]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.289]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.289]                     ...future.globalenv.names))
[08:28:14.289]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.289]         }, condition = base::local({
[08:28:14.289]             c <- base::c
[08:28:14.289]             inherits <- base::inherits
[08:28:14.289]             invokeRestart <- base::invokeRestart
[08:28:14.289]             length <- base::length
[08:28:14.289]             list <- base::list
[08:28:14.289]             seq.int <- base::seq.int
[08:28:14.289]             signalCondition <- base::signalCondition
[08:28:14.289]             sys.calls <- base::sys.calls
[08:28:14.289]             `[[` <- base::`[[`
[08:28:14.289]             `+` <- base::`+`
[08:28:14.289]             `<<-` <- base::`<<-`
[08:28:14.289]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.289]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.289]                   3L)]
[08:28:14.289]             }
[08:28:14.289]             function(cond) {
[08:28:14.289]                 is_error <- inherits(cond, "error")
[08:28:14.289]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.289]                   NULL)
[08:28:14.289]                 if (is_error) {
[08:28:14.289]                   sessionInformation <- function() {
[08:28:14.289]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.289]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.289]                       search = base::search(), system = base::Sys.info())
[08:28:14.289]                   }
[08:28:14.289]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.289]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.289]                     cond$call), session = sessionInformation(), 
[08:28:14.289]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.289]                   signalCondition(cond)
[08:28:14.289]                 }
[08:28:14.289]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.289]                 "immediateCondition"))) {
[08:28:14.289]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.289]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.289]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.289]                   if (TRUE && !signal) {
[08:28:14.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.289]                     {
[08:28:14.289]                       inherits <- base::inherits
[08:28:14.289]                       invokeRestart <- base::invokeRestart
[08:28:14.289]                       is.null <- base::is.null
[08:28:14.289]                       muffled <- FALSE
[08:28:14.289]                       if (inherits(cond, "message")) {
[08:28:14.289]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.289]                         if (muffled) 
[08:28:14.289]                           invokeRestart("muffleMessage")
[08:28:14.289]                       }
[08:28:14.289]                       else if (inherits(cond, "warning")) {
[08:28:14.289]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.289]                         if (muffled) 
[08:28:14.289]                           invokeRestart("muffleWarning")
[08:28:14.289]                       }
[08:28:14.289]                       else if (inherits(cond, "condition")) {
[08:28:14.289]                         if (!is.null(pattern)) {
[08:28:14.289]                           computeRestarts <- base::computeRestarts
[08:28:14.289]                           grepl <- base::grepl
[08:28:14.289]                           restarts <- computeRestarts(cond)
[08:28:14.289]                           for (restart in restarts) {
[08:28:14.289]                             name <- restart$name
[08:28:14.289]                             if (is.null(name)) 
[08:28:14.289]                               next
[08:28:14.289]                             if (!grepl(pattern, name)) 
[08:28:14.289]                               next
[08:28:14.289]                             invokeRestart(restart)
[08:28:14.289]                             muffled <- TRUE
[08:28:14.289]                             break
[08:28:14.289]                           }
[08:28:14.289]                         }
[08:28:14.289]                       }
[08:28:14.289]                       invisible(muffled)
[08:28:14.289]                     }
[08:28:14.289]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.289]                   }
[08:28:14.289]                 }
[08:28:14.289]                 else {
[08:28:14.289]                   if (TRUE) {
[08:28:14.289]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.289]                     {
[08:28:14.289]                       inherits <- base::inherits
[08:28:14.289]                       invokeRestart <- base::invokeRestart
[08:28:14.289]                       is.null <- base::is.null
[08:28:14.289]                       muffled <- FALSE
[08:28:14.289]                       if (inherits(cond, "message")) {
[08:28:14.289]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.289]                         if (muffled) 
[08:28:14.289]                           invokeRestart("muffleMessage")
[08:28:14.289]                       }
[08:28:14.289]                       else if (inherits(cond, "warning")) {
[08:28:14.289]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.289]                         if (muffled) 
[08:28:14.289]                           invokeRestart("muffleWarning")
[08:28:14.289]                       }
[08:28:14.289]                       else if (inherits(cond, "condition")) {
[08:28:14.289]                         if (!is.null(pattern)) {
[08:28:14.289]                           computeRestarts <- base::computeRestarts
[08:28:14.289]                           grepl <- base::grepl
[08:28:14.289]                           restarts <- computeRestarts(cond)
[08:28:14.289]                           for (restart in restarts) {
[08:28:14.289]                             name <- restart$name
[08:28:14.289]                             if (is.null(name)) 
[08:28:14.289]                               next
[08:28:14.289]                             if (!grepl(pattern, name)) 
[08:28:14.289]                               next
[08:28:14.289]                             invokeRestart(restart)
[08:28:14.289]                             muffled <- TRUE
[08:28:14.289]                             break
[08:28:14.289]                           }
[08:28:14.289]                         }
[08:28:14.289]                       }
[08:28:14.289]                       invisible(muffled)
[08:28:14.289]                     }
[08:28:14.289]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.289]                   }
[08:28:14.289]                 }
[08:28:14.289]             }
[08:28:14.289]         }))
[08:28:14.289]     }, error = function(ex) {
[08:28:14.289]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.289]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.289]                 ...future.rng), started = ...future.startTime, 
[08:28:14.289]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.289]             version = "1.8"), class = "FutureResult")
[08:28:14.289]     }, finally = {
[08:28:14.289]         if (!identical(...future.workdir, getwd())) 
[08:28:14.289]             setwd(...future.workdir)
[08:28:14.289]         {
[08:28:14.289]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.289]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.289]             }
[08:28:14.289]             base::options(...future.oldOptions)
[08:28:14.289]             if (.Platform$OS.type == "windows") {
[08:28:14.289]                 old_names <- names(...future.oldEnvVars)
[08:28:14.289]                 envs <- base::Sys.getenv()
[08:28:14.289]                 names <- names(envs)
[08:28:14.289]                 common <- intersect(names, old_names)
[08:28:14.289]                 added <- setdiff(names, old_names)
[08:28:14.289]                 removed <- setdiff(old_names, names)
[08:28:14.289]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.289]                   envs[common]]
[08:28:14.289]                 NAMES <- toupper(changed)
[08:28:14.289]                 args <- list()
[08:28:14.289]                 for (kk in seq_along(NAMES)) {
[08:28:14.289]                   name <- changed[[kk]]
[08:28:14.289]                   NAME <- NAMES[[kk]]
[08:28:14.289]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.289]                     next
[08:28:14.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.289]                 }
[08:28:14.289]                 NAMES <- toupper(added)
[08:28:14.289]                 for (kk in seq_along(NAMES)) {
[08:28:14.289]                   name <- added[[kk]]
[08:28:14.289]                   NAME <- NAMES[[kk]]
[08:28:14.289]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.289]                     next
[08:28:14.289]                   args[[name]] <- ""
[08:28:14.289]                 }
[08:28:14.289]                 NAMES <- toupper(removed)
[08:28:14.289]                 for (kk in seq_along(NAMES)) {
[08:28:14.289]                   name <- removed[[kk]]
[08:28:14.289]                   NAME <- NAMES[[kk]]
[08:28:14.289]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.289]                     next
[08:28:14.289]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.289]                 }
[08:28:14.289]                 if (length(args) > 0) 
[08:28:14.289]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.289]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.289]             }
[08:28:14.289]             else {
[08:28:14.289]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.289]             }
[08:28:14.289]             {
[08:28:14.289]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.289]                   0L) {
[08:28:14.289]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.289]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.289]                   base::options(opts)
[08:28:14.289]                 }
[08:28:14.289]                 {
[08:28:14.289]                   {
[08:28:14.289]                     NULL
[08:28:14.289]                     RNGkind("Mersenne-Twister")
[08:28:14.289]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.289]                       inherits = FALSE)
[08:28:14.289]                   }
[08:28:14.289]                   options(future.plan = NULL)
[08:28:14.289]                   if (is.na(NA_character_)) 
[08:28:14.289]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.289]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.289]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.289]                     .init = FALSE)
[08:28:14.289]                 }
[08:28:14.289]             }
[08:28:14.289]         }
[08:28:14.289]     })
[08:28:14.289]     if (TRUE) {
[08:28:14.289]         base::sink(type = "output", split = FALSE)
[08:28:14.289]         if (TRUE) {
[08:28:14.289]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.289]         }
[08:28:14.289]         else {
[08:28:14.289]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.289]         }
[08:28:14.289]         base::close(...future.stdout)
[08:28:14.289]         ...future.stdout <- NULL
[08:28:14.289]     }
[08:28:14.289]     ...future.result$conditions <- ...future.conditions
[08:28:14.289]     ...future.result$finished <- base::Sys.time()
[08:28:14.289]     ...future.result
[08:28:14.289] }
[08:28:14.291] assign_globals() ...
[08:28:14.291] List of 1
[08:28:14.291]  $ ii: int 2
[08:28:14.291]  - attr(*, "where")=List of 1
[08:28:14.291]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.291]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.291]  - attr(*, "resolved")= logi TRUE
[08:28:14.291]  - attr(*, "total_size")= num 35
[08:28:14.291]  - attr(*, "already-done")= logi TRUE
[08:28:14.293] - copied ‘ii’ to environment
[08:28:14.294] assign_globals() ... done
[08:28:14.294] plan(): Setting new future strategy stack:
[08:28:14.294] List of future strategies:
[08:28:14.294] 1. sequential:
[08:28:14.294]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.294]    - tweaked: FALSE
[08:28:14.294]    - call: NULL
[08:28:14.294] plan(): nbrOfWorkers() = 1
[08:28:14.295] plan(): Setting new future strategy stack:
[08:28:14.295] List of future strategies:
[08:28:14.295] 1. sequential:
[08:28:14.295]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.295]    - tweaked: FALSE
[08:28:14.295]    - call: plan(strategy)
[08:28:14.296] plan(): nbrOfWorkers() = 1
[08:28:14.296] SequentialFuture started (and completed)
[08:28:14.296] - Launch lazy future ... done
[08:28:14.296] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.296] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.296] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.299] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.299] Searching for globals ... DONE
[08:28:14.299] Resolving globals: TRUE
[08:28:14.299] Resolving any globals that are futures ...
[08:28:14.299] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.299] Resolving any globals that are futures ... DONE
[08:28:14.300] Resolving futures part of globals (recursively) ...
[08:28:14.300] resolve() on list ...
[08:28:14.300]  recursive: 99
[08:28:14.300]  length: 1
[08:28:14.300]  elements: ‘ii’
[08:28:14.300]  length: 0 (resolved future 1)
[08:28:14.300] resolve() on list ... DONE
[08:28:14.300] - globals: [1] ‘ii’
[08:28:14.301] Resolving futures part of globals (recursively) ... DONE
[08:28:14.301] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.301] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.301] - globals: [1] ‘ii’
[08:28:14.301] 
[08:28:14.301] getGlobalsAndPackages() ... DONE
[08:28:14.302] run() for ‘Future’ ...
[08:28:14.302] - state: ‘created’
[08:28:14.302] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.302] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.302] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.302]   - Field: ‘label’
[08:28:14.302]   - Field: ‘local’
[08:28:14.302]   - Field: ‘owner’
[08:28:14.302]   - Field: ‘envir’
[08:28:14.303]   - Field: ‘packages’
[08:28:14.303]   - Field: ‘gc’
[08:28:14.303]   - Field: ‘conditions’
[08:28:14.303]   - Field: ‘expr’
[08:28:14.303]   - Field: ‘uuid’
[08:28:14.303]   - Field: ‘seed’
[08:28:14.303]   - Field: ‘version’
[08:28:14.303]   - Field: ‘result’
[08:28:14.303]   - Field: ‘asynchronous’
[08:28:14.303]   - Field: ‘calls’
[08:28:14.303]   - Field: ‘globals’
[08:28:14.303]   - Field: ‘stdout’
[08:28:14.304]   - Field: ‘earlySignal’
[08:28:14.304]   - Field: ‘lazy’
[08:28:14.304]   - Field: ‘state’
[08:28:14.304] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.304] - Launch lazy future ...
[08:28:14.304] Packages needed by the future expression (n = 0): <none>
[08:28:14.304] Packages needed by future strategies (n = 0): <none>
[08:28:14.304] {
[08:28:14.304]     {
[08:28:14.304]         {
[08:28:14.304]             ...future.startTime <- base::Sys.time()
[08:28:14.304]             {
[08:28:14.304]                 {
[08:28:14.304]                   {
[08:28:14.304]                     base::local({
[08:28:14.304]                       has_future <- base::requireNamespace("future", 
[08:28:14.304]                         quietly = TRUE)
[08:28:14.304]                       if (has_future) {
[08:28:14.304]                         ns <- base::getNamespace("future")
[08:28:14.304]                         version <- ns[[".package"]][["version"]]
[08:28:14.304]                         if (is.null(version)) 
[08:28:14.304]                           version <- utils::packageVersion("future")
[08:28:14.304]                       }
[08:28:14.304]                       else {
[08:28:14.304]                         version <- NULL
[08:28:14.304]                       }
[08:28:14.304]                       if (!has_future || version < "1.8.0") {
[08:28:14.304]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.304]                           "", base::R.version$version.string), 
[08:28:14.304]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.304]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.304]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.304]                             "release", "version")], collapse = " "), 
[08:28:14.304]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.304]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.304]                           info)
[08:28:14.304]                         info <- base::paste(info, collapse = "; ")
[08:28:14.304]                         if (!has_future) {
[08:28:14.304]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.304]                             info)
[08:28:14.304]                         }
[08:28:14.304]                         else {
[08:28:14.304]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.304]                             info, version)
[08:28:14.304]                         }
[08:28:14.304]                         base::stop(msg)
[08:28:14.304]                       }
[08:28:14.304]                     })
[08:28:14.304]                   }
[08:28:14.304]                   ...future.strategy.old <- future::plan("list")
[08:28:14.304]                   options(future.plan = NULL)
[08:28:14.304]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.304]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.304]                 }
[08:28:14.304]                 ...future.workdir <- getwd()
[08:28:14.304]             }
[08:28:14.304]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.304]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.304]         }
[08:28:14.304]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.304]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.304]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.304]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.304]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.304]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.304]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.304]             base::names(...future.oldOptions))
[08:28:14.304]     }
[08:28:14.304]     if (FALSE) {
[08:28:14.304]     }
[08:28:14.304]     else {
[08:28:14.304]         if (TRUE) {
[08:28:14.304]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.304]                 open = "w")
[08:28:14.304]         }
[08:28:14.304]         else {
[08:28:14.304]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.304]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.304]         }
[08:28:14.304]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.304]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.304]             base::sink(type = "output", split = FALSE)
[08:28:14.304]             base::close(...future.stdout)
[08:28:14.304]         }, add = TRUE)
[08:28:14.304]     }
[08:28:14.304]     ...future.frame <- base::sys.nframe()
[08:28:14.304]     ...future.conditions <- base::list()
[08:28:14.304]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.304]     if (FALSE) {
[08:28:14.304]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.304]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.304]     }
[08:28:14.304]     ...future.result <- base::tryCatch({
[08:28:14.304]         base::withCallingHandlers({
[08:28:14.304]             ...future.value <- base::withVisible(base::local({
[08:28:14.304]                 b <- a * ii
[08:28:14.304]                 a <- 0
[08:28:14.304]                 b
[08:28:14.304]             }))
[08:28:14.304]             future::FutureResult(value = ...future.value$value, 
[08:28:14.304]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.304]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.304]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.304]                     ...future.globalenv.names))
[08:28:14.304]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.304]         }, condition = base::local({
[08:28:14.304]             c <- base::c
[08:28:14.304]             inherits <- base::inherits
[08:28:14.304]             invokeRestart <- base::invokeRestart
[08:28:14.304]             length <- base::length
[08:28:14.304]             list <- base::list
[08:28:14.304]             seq.int <- base::seq.int
[08:28:14.304]             signalCondition <- base::signalCondition
[08:28:14.304]             sys.calls <- base::sys.calls
[08:28:14.304]             `[[` <- base::`[[`
[08:28:14.304]             `+` <- base::`+`
[08:28:14.304]             `<<-` <- base::`<<-`
[08:28:14.304]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.304]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.304]                   3L)]
[08:28:14.304]             }
[08:28:14.304]             function(cond) {
[08:28:14.304]                 is_error <- inherits(cond, "error")
[08:28:14.304]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.304]                   NULL)
[08:28:14.304]                 if (is_error) {
[08:28:14.304]                   sessionInformation <- function() {
[08:28:14.304]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.304]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.304]                       search = base::search(), system = base::Sys.info())
[08:28:14.304]                   }
[08:28:14.304]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.304]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.304]                     cond$call), session = sessionInformation(), 
[08:28:14.304]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.304]                   signalCondition(cond)
[08:28:14.304]                 }
[08:28:14.304]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.304]                 "immediateCondition"))) {
[08:28:14.304]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.304]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.304]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.304]                   if (TRUE && !signal) {
[08:28:14.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.304]                     {
[08:28:14.304]                       inherits <- base::inherits
[08:28:14.304]                       invokeRestart <- base::invokeRestart
[08:28:14.304]                       is.null <- base::is.null
[08:28:14.304]                       muffled <- FALSE
[08:28:14.304]                       if (inherits(cond, "message")) {
[08:28:14.304]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.304]                         if (muffled) 
[08:28:14.304]                           invokeRestart("muffleMessage")
[08:28:14.304]                       }
[08:28:14.304]                       else if (inherits(cond, "warning")) {
[08:28:14.304]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.304]                         if (muffled) 
[08:28:14.304]                           invokeRestart("muffleWarning")
[08:28:14.304]                       }
[08:28:14.304]                       else if (inherits(cond, "condition")) {
[08:28:14.304]                         if (!is.null(pattern)) {
[08:28:14.304]                           computeRestarts <- base::computeRestarts
[08:28:14.304]                           grepl <- base::grepl
[08:28:14.304]                           restarts <- computeRestarts(cond)
[08:28:14.304]                           for (restart in restarts) {
[08:28:14.304]                             name <- restart$name
[08:28:14.304]                             if (is.null(name)) 
[08:28:14.304]                               next
[08:28:14.304]                             if (!grepl(pattern, name)) 
[08:28:14.304]                               next
[08:28:14.304]                             invokeRestart(restart)
[08:28:14.304]                             muffled <- TRUE
[08:28:14.304]                             break
[08:28:14.304]                           }
[08:28:14.304]                         }
[08:28:14.304]                       }
[08:28:14.304]                       invisible(muffled)
[08:28:14.304]                     }
[08:28:14.304]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.304]                   }
[08:28:14.304]                 }
[08:28:14.304]                 else {
[08:28:14.304]                   if (TRUE) {
[08:28:14.304]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.304]                     {
[08:28:14.304]                       inherits <- base::inherits
[08:28:14.304]                       invokeRestart <- base::invokeRestart
[08:28:14.304]                       is.null <- base::is.null
[08:28:14.304]                       muffled <- FALSE
[08:28:14.304]                       if (inherits(cond, "message")) {
[08:28:14.304]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.304]                         if (muffled) 
[08:28:14.304]                           invokeRestart("muffleMessage")
[08:28:14.304]                       }
[08:28:14.304]                       else if (inherits(cond, "warning")) {
[08:28:14.304]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.304]                         if (muffled) 
[08:28:14.304]                           invokeRestart("muffleWarning")
[08:28:14.304]                       }
[08:28:14.304]                       else if (inherits(cond, "condition")) {
[08:28:14.304]                         if (!is.null(pattern)) {
[08:28:14.304]                           computeRestarts <- base::computeRestarts
[08:28:14.304]                           grepl <- base::grepl
[08:28:14.304]                           restarts <- computeRestarts(cond)
[08:28:14.304]                           for (restart in restarts) {
[08:28:14.304]                             name <- restart$name
[08:28:14.304]                             if (is.null(name)) 
[08:28:14.304]                               next
[08:28:14.304]                             if (!grepl(pattern, name)) 
[08:28:14.304]                               next
[08:28:14.304]                             invokeRestart(restart)
[08:28:14.304]                             muffled <- TRUE
[08:28:14.304]                             break
[08:28:14.304]                           }
[08:28:14.304]                         }
[08:28:14.304]                       }
[08:28:14.304]                       invisible(muffled)
[08:28:14.304]                     }
[08:28:14.304]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.304]                   }
[08:28:14.304]                 }
[08:28:14.304]             }
[08:28:14.304]         }))
[08:28:14.304]     }, error = function(ex) {
[08:28:14.304]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.304]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.304]                 ...future.rng), started = ...future.startTime, 
[08:28:14.304]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.304]             version = "1.8"), class = "FutureResult")
[08:28:14.304]     }, finally = {
[08:28:14.304]         if (!identical(...future.workdir, getwd())) 
[08:28:14.304]             setwd(...future.workdir)
[08:28:14.304]         {
[08:28:14.304]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.304]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.304]             }
[08:28:14.304]             base::options(...future.oldOptions)
[08:28:14.304]             if (.Platform$OS.type == "windows") {
[08:28:14.304]                 old_names <- names(...future.oldEnvVars)
[08:28:14.304]                 envs <- base::Sys.getenv()
[08:28:14.304]                 names <- names(envs)
[08:28:14.304]                 common <- intersect(names, old_names)
[08:28:14.304]                 added <- setdiff(names, old_names)
[08:28:14.304]                 removed <- setdiff(old_names, names)
[08:28:14.304]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.304]                   envs[common]]
[08:28:14.304]                 NAMES <- toupper(changed)
[08:28:14.304]                 args <- list()
[08:28:14.304]                 for (kk in seq_along(NAMES)) {
[08:28:14.304]                   name <- changed[[kk]]
[08:28:14.304]                   NAME <- NAMES[[kk]]
[08:28:14.304]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.304]                     next
[08:28:14.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.304]                 }
[08:28:14.304]                 NAMES <- toupper(added)
[08:28:14.304]                 for (kk in seq_along(NAMES)) {
[08:28:14.304]                   name <- added[[kk]]
[08:28:14.304]                   NAME <- NAMES[[kk]]
[08:28:14.304]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.304]                     next
[08:28:14.304]                   args[[name]] <- ""
[08:28:14.304]                 }
[08:28:14.304]                 NAMES <- toupper(removed)
[08:28:14.304]                 for (kk in seq_along(NAMES)) {
[08:28:14.304]                   name <- removed[[kk]]
[08:28:14.304]                   NAME <- NAMES[[kk]]
[08:28:14.304]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.304]                     next
[08:28:14.304]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.304]                 }
[08:28:14.304]                 if (length(args) > 0) 
[08:28:14.304]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.304]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.304]             }
[08:28:14.304]             else {
[08:28:14.304]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.304]             }
[08:28:14.304]             {
[08:28:14.304]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.304]                   0L) {
[08:28:14.304]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.304]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.304]                   base::options(opts)
[08:28:14.304]                 }
[08:28:14.304]                 {
[08:28:14.304]                   {
[08:28:14.304]                     NULL
[08:28:14.304]                     RNGkind("Mersenne-Twister")
[08:28:14.304]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.304]                       inherits = FALSE)
[08:28:14.304]                   }
[08:28:14.304]                   options(future.plan = NULL)
[08:28:14.304]                   if (is.na(NA_character_)) 
[08:28:14.304]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.304]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.304]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.304]                     .init = FALSE)
[08:28:14.304]                 }
[08:28:14.304]             }
[08:28:14.304]         }
[08:28:14.304]     })
[08:28:14.304]     if (TRUE) {
[08:28:14.304]         base::sink(type = "output", split = FALSE)
[08:28:14.304]         if (TRUE) {
[08:28:14.304]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.304]         }
[08:28:14.304]         else {
[08:28:14.304]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.304]         }
[08:28:14.304]         base::close(...future.stdout)
[08:28:14.304]         ...future.stdout <- NULL
[08:28:14.304]     }
[08:28:14.304]     ...future.result$conditions <- ...future.conditions
[08:28:14.304]     ...future.result$finished <- base::Sys.time()
[08:28:14.304]     ...future.result
[08:28:14.304] }
[08:28:14.306] assign_globals() ...
[08:28:14.306] List of 1
[08:28:14.306]  $ ii: int 3
[08:28:14.306]  - attr(*, "where")=List of 1
[08:28:14.306]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.306]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.306]  - attr(*, "resolved")= logi TRUE
[08:28:14.306]  - attr(*, "total_size")= num 35
[08:28:14.306]  - attr(*, "already-done")= logi TRUE
[08:28:14.309] - copied ‘ii’ to environment
[08:28:14.309] assign_globals() ... done
[08:28:14.309] plan(): Setting new future strategy stack:
[08:28:14.309] List of future strategies:
[08:28:14.309] 1. sequential:
[08:28:14.309]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.309]    - tweaked: FALSE
[08:28:14.309]    - call: NULL
[08:28:14.309] plan(): nbrOfWorkers() = 1
[08:28:14.310] plan(): Setting new future strategy stack:
[08:28:14.310] List of future strategies:
[08:28:14.310] 1. sequential:
[08:28:14.310]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.310]    - tweaked: FALSE
[08:28:14.310]    - call: plan(strategy)
[08:28:14.311] plan(): nbrOfWorkers() = 1
[08:28:14.311] SequentialFuture started (and completed)
[08:28:14.311] - Launch lazy future ... done
[08:28:14.311] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.312] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.312] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.313] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.313] Searching for globals ... DONE
[08:28:14.313] Resolving globals: TRUE
[08:28:14.314] Resolving any globals that are futures ...
[08:28:14.314] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.314] Resolving any globals that are futures ... DONE
[08:28:14.314] Resolving futures part of globals (recursively) ...
[08:28:14.314] resolve() on list ...
[08:28:14.314]  recursive: 99
[08:28:14.314]  length: 1
[08:28:14.314]  elements: ‘ii’
[08:28:14.315]  length: 0 (resolved future 1)
[08:28:14.315] resolve() on list ... DONE
[08:28:14.315] - globals: [1] ‘ii’
[08:28:14.315] Resolving futures part of globals (recursively) ... DONE
[08:28:14.315] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.315] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.315] - globals: [1] ‘ii’
[08:28:14.315] 
[08:28:14.316] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.316] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.316] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.317] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.318] Searching for globals ... DONE
[08:28:14.318] Resolving globals: TRUE
[08:28:14.318] Resolving any globals that are futures ...
[08:28:14.318] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.318] Resolving any globals that are futures ... DONE
[08:28:14.318] Resolving futures part of globals (recursively) ...
[08:28:14.318] resolve() on list ...
[08:28:14.318]  recursive: 99
[08:28:14.319]  length: 1
[08:28:14.319]  elements: ‘ii’
[08:28:14.319]  length: 0 (resolved future 1)
[08:28:14.319] resolve() on list ... DONE
[08:28:14.319] - globals: [1] ‘ii’
[08:28:14.319] Resolving futures part of globals (recursively) ... DONE
[08:28:14.319] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.319] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.319] - globals: [1] ‘ii’
[08:28:14.320] 
[08:28:14.320] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.320] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.320] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.322] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.322] Searching for globals ... DONE
[08:28:14.322] Resolving globals: TRUE
[08:28:14.322] Resolving any globals that are futures ...
[08:28:14.322] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.322] Resolving any globals that are futures ... DONE
[08:28:14.323] Resolving futures part of globals (recursively) ...
[08:28:14.324] resolve() on list ...
[08:28:14.324]  recursive: 99
[08:28:14.324]  length: 1
[08:28:14.324]  elements: ‘ii’
[08:28:14.324]  length: 0 (resolved future 1)
[08:28:14.324] resolve() on list ... DONE
[08:28:14.324] - globals: [1] ‘ii’
[08:28:14.324] Resolving futures part of globals (recursively) ... DONE
[08:28:14.324] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.325] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.325] - globals: [1] ‘ii’
[08:28:14.325] 
[08:28:14.325] getGlobalsAndPackages() ... DONE
[08:28:14.325] run() for ‘Future’ ...
[08:28:14.325] - state: ‘created’
[08:28:14.325] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.326] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.326] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.326]   - Field: ‘label’
[08:28:14.326]   - Field: ‘local’
[08:28:14.326]   - Field: ‘owner’
[08:28:14.326]   - Field: ‘envir’
[08:28:14.326]   - Field: ‘packages’
[08:28:14.326]   - Field: ‘gc’
[08:28:14.326]   - Field: ‘conditions’
[08:28:14.326]   - Field: ‘expr’
[08:28:14.327]   - Field: ‘uuid’
[08:28:14.327]   - Field: ‘seed’
[08:28:14.327]   - Field: ‘version’
[08:28:14.327]   - Field: ‘result’
[08:28:14.327]   - Field: ‘asynchronous’
[08:28:14.327]   - Field: ‘calls’
[08:28:14.327]   - Field: ‘globals’
[08:28:14.327]   - Field: ‘stdout’
[08:28:14.327]   - Field: ‘earlySignal’
[08:28:14.327]   - Field: ‘lazy’
[08:28:14.328]   - Field: ‘state’
[08:28:14.328] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.328] - Launch lazy future ...
[08:28:14.328] Packages needed by the future expression (n = 0): <none>
[08:28:14.328] Packages needed by future strategies (n = 0): <none>
[08:28:14.328] {
[08:28:14.328]     {
[08:28:14.328]         {
[08:28:14.328]             ...future.startTime <- base::Sys.time()
[08:28:14.328]             {
[08:28:14.328]                 {
[08:28:14.328]                   {
[08:28:14.328]                     base::local({
[08:28:14.328]                       has_future <- base::requireNamespace("future", 
[08:28:14.328]                         quietly = TRUE)
[08:28:14.328]                       if (has_future) {
[08:28:14.328]                         ns <- base::getNamespace("future")
[08:28:14.328]                         version <- ns[[".package"]][["version"]]
[08:28:14.328]                         if (is.null(version)) 
[08:28:14.328]                           version <- utils::packageVersion("future")
[08:28:14.328]                       }
[08:28:14.328]                       else {
[08:28:14.328]                         version <- NULL
[08:28:14.328]                       }
[08:28:14.328]                       if (!has_future || version < "1.8.0") {
[08:28:14.328]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.328]                           "", base::R.version$version.string), 
[08:28:14.328]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.328]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.328]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.328]                             "release", "version")], collapse = " "), 
[08:28:14.328]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.328]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.328]                           info)
[08:28:14.328]                         info <- base::paste(info, collapse = "; ")
[08:28:14.328]                         if (!has_future) {
[08:28:14.328]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.328]                             info)
[08:28:14.328]                         }
[08:28:14.328]                         else {
[08:28:14.328]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.328]                             info, version)
[08:28:14.328]                         }
[08:28:14.328]                         base::stop(msg)
[08:28:14.328]                       }
[08:28:14.328]                     })
[08:28:14.328]                   }
[08:28:14.328]                   ...future.strategy.old <- future::plan("list")
[08:28:14.328]                   options(future.plan = NULL)
[08:28:14.328]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.328]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.328]                 }
[08:28:14.328]                 ...future.workdir <- getwd()
[08:28:14.328]             }
[08:28:14.328]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.328]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.328]         }
[08:28:14.328]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.328]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.328]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.328]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.328]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.328]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.328]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.328]             base::names(...future.oldOptions))
[08:28:14.328]     }
[08:28:14.328]     if (FALSE) {
[08:28:14.328]     }
[08:28:14.328]     else {
[08:28:14.328]         if (TRUE) {
[08:28:14.328]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.328]                 open = "w")
[08:28:14.328]         }
[08:28:14.328]         else {
[08:28:14.328]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.328]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.328]         }
[08:28:14.328]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.328]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.328]             base::sink(type = "output", split = FALSE)
[08:28:14.328]             base::close(...future.stdout)
[08:28:14.328]         }, add = TRUE)
[08:28:14.328]     }
[08:28:14.328]     ...future.frame <- base::sys.nframe()
[08:28:14.328]     ...future.conditions <- base::list()
[08:28:14.328]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.328]     if (FALSE) {
[08:28:14.328]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.328]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.328]     }
[08:28:14.328]     ...future.result <- base::tryCatch({
[08:28:14.328]         base::withCallingHandlers({
[08:28:14.328]             ...future.value <- base::withVisible(base::local({
[08:28:14.328]                 b <- a * ii
[08:28:14.328]                 a <- 0
[08:28:14.328]                 b
[08:28:14.328]             }))
[08:28:14.328]             future::FutureResult(value = ...future.value$value, 
[08:28:14.328]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.328]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.328]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.328]                     ...future.globalenv.names))
[08:28:14.328]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.328]         }, condition = base::local({
[08:28:14.328]             c <- base::c
[08:28:14.328]             inherits <- base::inherits
[08:28:14.328]             invokeRestart <- base::invokeRestart
[08:28:14.328]             length <- base::length
[08:28:14.328]             list <- base::list
[08:28:14.328]             seq.int <- base::seq.int
[08:28:14.328]             signalCondition <- base::signalCondition
[08:28:14.328]             sys.calls <- base::sys.calls
[08:28:14.328]             `[[` <- base::`[[`
[08:28:14.328]             `+` <- base::`+`
[08:28:14.328]             `<<-` <- base::`<<-`
[08:28:14.328]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.328]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.328]                   3L)]
[08:28:14.328]             }
[08:28:14.328]             function(cond) {
[08:28:14.328]                 is_error <- inherits(cond, "error")
[08:28:14.328]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.328]                   NULL)
[08:28:14.328]                 if (is_error) {
[08:28:14.328]                   sessionInformation <- function() {
[08:28:14.328]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.328]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.328]                       search = base::search(), system = base::Sys.info())
[08:28:14.328]                   }
[08:28:14.328]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.328]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.328]                     cond$call), session = sessionInformation(), 
[08:28:14.328]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.328]                   signalCondition(cond)
[08:28:14.328]                 }
[08:28:14.328]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.328]                 "immediateCondition"))) {
[08:28:14.328]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.328]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.328]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.328]                   if (TRUE && !signal) {
[08:28:14.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.328]                     {
[08:28:14.328]                       inherits <- base::inherits
[08:28:14.328]                       invokeRestart <- base::invokeRestart
[08:28:14.328]                       is.null <- base::is.null
[08:28:14.328]                       muffled <- FALSE
[08:28:14.328]                       if (inherits(cond, "message")) {
[08:28:14.328]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.328]                         if (muffled) 
[08:28:14.328]                           invokeRestart("muffleMessage")
[08:28:14.328]                       }
[08:28:14.328]                       else if (inherits(cond, "warning")) {
[08:28:14.328]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.328]                         if (muffled) 
[08:28:14.328]                           invokeRestart("muffleWarning")
[08:28:14.328]                       }
[08:28:14.328]                       else if (inherits(cond, "condition")) {
[08:28:14.328]                         if (!is.null(pattern)) {
[08:28:14.328]                           computeRestarts <- base::computeRestarts
[08:28:14.328]                           grepl <- base::grepl
[08:28:14.328]                           restarts <- computeRestarts(cond)
[08:28:14.328]                           for (restart in restarts) {
[08:28:14.328]                             name <- restart$name
[08:28:14.328]                             if (is.null(name)) 
[08:28:14.328]                               next
[08:28:14.328]                             if (!grepl(pattern, name)) 
[08:28:14.328]                               next
[08:28:14.328]                             invokeRestart(restart)
[08:28:14.328]                             muffled <- TRUE
[08:28:14.328]                             break
[08:28:14.328]                           }
[08:28:14.328]                         }
[08:28:14.328]                       }
[08:28:14.328]                       invisible(muffled)
[08:28:14.328]                     }
[08:28:14.328]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.328]                   }
[08:28:14.328]                 }
[08:28:14.328]                 else {
[08:28:14.328]                   if (TRUE) {
[08:28:14.328]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.328]                     {
[08:28:14.328]                       inherits <- base::inherits
[08:28:14.328]                       invokeRestart <- base::invokeRestart
[08:28:14.328]                       is.null <- base::is.null
[08:28:14.328]                       muffled <- FALSE
[08:28:14.328]                       if (inherits(cond, "message")) {
[08:28:14.328]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.328]                         if (muffled) 
[08:28:14.328]                           invokeRestart("muffleMessage")
[08:28:14.328]                       }
[08:28:14.328]                       else if (inherits(cond, "warning")) {
[08:28:14.328]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.328]                         if (muffled) 
[08:28:14.328]                           invokeRestart("muffleWarning")
[08:28:14.328]                       }
[08:28:14.328]                       else if (inherits(cond, "condition")) {
[08:28:14.328]                         if (!is.null(pattern)) {
[08:28:14.328]                           computeRestarts <- base::computeRestarts
[08:28:14.328]                           grepl <- base::grepl
[08:28:14.328]                           restarts <- computeRestarts(cond)
[08:28:14.328]                           for (restart in restarts) {
[08:28:14.328]                             name <- restart$name
[08:28:14.328]                             if (is.null(name)) 
[08:28:14.328]                               next
[08:28:14.328]                             if (!grepl(pattern, name)) 
[08:28:14.328]                               next
[08:28:14.328]                             invokeRestart(restart)
[08:28:14.328]                             muffled <- TRUE
[08:28:14.328]                             break
[08:28:14.328]                           }
[08:28:14.328]                         }
[08:28:14.328]                       }
[08:28:14.328]                       invisible(muffled)
[08:28:14.328]                     }
[08:28:14.328]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.328]                   }
[08:28:14.328]                 }
[08:28:14.328]             }
[08:28:14.328]         }))
[08:28:14.328]     }, error = function(ex) {
[08:28:14.328]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.328]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.328]                 ...future.rng), started = ...future.startTime, 
[08:28:14.328]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.328]             version = "1.8"), class = "FutureResult")
[08:28:14.328]     }, finally = {
[08:28:14.328]         if (!identical(...future.workdir, getwd())) 
[08:28:14.328]             setwd(...future.workdir)
[08:28:14.328]         {
[08:28:14.328]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.328]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.328]             }
[08:28:14.328]             base::options(...future.oldOptions)
[08:28:14.328]             if (.Platform$OS.type == "windows") {
[08:28:14.328]                 old_names <- names(...future.oldEnvVars)
[08:28:14.328]                 envs <- base::Sys.getenv()
[08:28:14.328]                 names <- names(envs)
[08:28:14.328]                 common <- intersect(names, old_names)
[08:28:14.328]                 added <- setdiff(names, old_names)
[08:28:14.328]                 removed <- setdiff(old_names, names)
[08:28:14.328]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.328]                   envs[common]]
[08:28:14.328]                 NAMES <- toupper(changed)
[08:28:14.328]                 args <- list()
[08:28:14.328]                 for (kk in seq_along(NAMES)) {
[08:28:14.328]                   name <- changed[[kk]]
[08:28:14.328]                   NAME <- NAMES[[kk]]
[08:28:14.328]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.328]                     next
[08:28:14.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.328]                 }
[08:28:14.328]                 NAMES <- toupper(added)
[08:28:14.328]                 for (kk in seq_along(NAMES)) {
[08:28:14.328]                   name <- added[[kk]]
[08:28:14.328]                   NAME <- NAMES[[kk]]
[08:28:14.328]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.328]                     next
[08:28:14.328]                   args[[name]] <- ""
[08:28:14.328]                 }
[08:28:14.328]                 NAMES <- toupper(removed)
[08:28:14.328]                 for (kk in seq_along(NAMES)) {
[08:28:14.328]                   name <- removed[[kk]]
[08:28:14.328]                   NAME <- NAMES[[kk]]
[08:28:14.328]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.328]                     next
[08:28:14.328]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.328]                 }
[08:28:14.328]                 if (length(args) > 0) 
[08:28:14.328]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.328]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.328]             }
[08:28:14.328]             else {
[08:28:14.328]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.328]             }
[08:28:14.328]             {
[08:28:14.328]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.328]                   0L) {
[08:28:14.328]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.328]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.328]                   base::options(opts)
[08:28:14.328]                 }
[08:28:14.328]                 {
[08:28:14.328]                   {
[08:28:14.328]                     NULL
[08:28:14.328]                     RNGkind("Mersenne-Twister")
[08:28:14.328]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.328]                       inherits = FALSE)
[08:28:14.328]                   }
[08:28:14.328]                   options(future.plan = NULL)
[08:28:14.328]                   if (is.na(NA_character_)) 
[08:28:14.328]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.328]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.328]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.328]                     .init = FALSE)
[08:28:14.328]                 }
[08:28:14.328]             }
[08:28:14.328]         }
[08:28:14.328]     })
[08:28:14.328]     if (TRUE) {
[08:28:14.328]         base::sink(type = "output", split = FALSE)
[08:28:14.328]         if (TRUE) {
[08:28:14.328]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.328]         }
[08:28:14.328]         else {
[08:28:14.328]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.328]         }
[08:28:14.328]         base::close(...future.stdout)
[08:28:14.328]         ...future.stdout <- NULL
[08:28:14.328]     }
[08:28:14.328]     ...future.result$conditions <- ...future.conditions
[08:28:14.328]     ...future.result$finished <- base::Sys.time()
[08:28:14.328]     ...future.result
[08:28:14.328] }
[08:28:14.330] assign_globals() ...
[08:28:14.330] List of 1
[08:28:14.330]  $ ii: int 1
[08:28:14.330]  - attr(*, "where")=List of 1
[08:28:14.330]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.330]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.330]  - attr(*, "resolved")= logi TRUE
[08:28:14.330]  - attr(*, "total_size")= num 35
[08:28:14.330]  - attr(*, "already-done")= logi TRUE
[08:28:14.332] - copied ‘ii’ to environment
[08:28:14.333] assign_globals() ... done
[08:28:14.333] plan(): Setting new future strategy stack:
[08:28:14.333] List of future strategies:
[08:28:14.333] 1. sequential:
[08:28:14.333]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.333]    - tweaked: FALSE
[08:28:14.333]    - call: NULL
[08:28:14.333] plan(): nbrOfWorkers() = 1
[08:28:14.334] plan(): Setting new future strategy stack:
[08:28:14.334] List of future strategies:
[08:28:14.334] 1. sequential:
[08:28:14.334]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.334]    - tweaked: FALSE
[08:28:14.334]    - call: plan(strategy)
[08:28:14.335] plan(): nbrOfWorkers() = 1
[08:28:14.335] SequentialFuture started (and completed)
[08:28:14.335] signalConditions() ...
[08:28:14.335]  - include = ‘immediateCondition’
[08:28:14.335]  - exclude = 
[08:28:14.335]  - resignal = FALSE
[08:28:14.335]  - Number of conditions: 1
[08:28:14.335] signalConditions() ... done
[08:28:14.335] - Launch lazy future ... done
[08:28:14.336] run() for ‘SequentialFuture’ ... done
[08:28:14.336] signalConditions() ...
[08:28:14.336]  - include = ‘immediateCondition’
[08:28:14.336]  - exclude = 
[08:28:14.336]  - resignal = FALSE
[08:28:14.336]  - Number of conditions: 1
[08:28:14.336] signalConditions() ... done
[08:28:14.336] Future state: ‘finished’
[08:28:14.336] signalConditions() ...
[08:28:14.336]  - include = ‘condition’
[08:28:14.336]  - exclude = ‘immediateCondition’
[08:28:14.337]  - resignal = TRUE
[08:28:14.337]  - Number of conditions: 1
[08:28:14.337]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:14.337] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.350] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.350] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.351] 
[08:28:14.351] Searching for globals ... DONE
[08:28:14.351] - globals: [0] <none>
[08:28:14.351] getGlobalsAndPackages() ... DONE
[08:28:14.351] run() for ‘Future’ ...
[08:28:14.351] - state: ‘created’
[08:28:14.351] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.352] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.352] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.352]   - Field: ‘label’
[08:28:14.352]   - Field: ‘local’
[08:28:14.352]   - Field: ‘owner’
[08:28:14.352]   - Field: ‘envir’
[08:28:14.352]   - Field: ‘packages’
[08:28:14.352]   - Field: ‘gc’
[08:28:14.352]   - Field: ‘conditions’
[08:28:14.352]   - Field: ‘expr’
[08:28:14.353]   - Field: ‘uuid’
[08:28:14.353]   - Field: ‘seed’
[08:28:14.353]   - Field: ‘version’
[08:28:14.353]   - Field: ‘result’
[08:28:14.353]   - Field: ‘asynchronous’
[08:28:14.353]   - Field: ‘calls’
[08:28:14.353]   - Field: ‘globals’
[08:28:14.353]   - Field: ‘stdout’
[08:28:14.353]   - Field: ‘earlySignal’
[08:28:14.353]   - Field: ‘lazy’
[08:28:14.353]   - Field: ‘state’
[08:28:14.353] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.354] - Launch lazy future ...
[08:28:14.354] Packages needed by the future expression (n = 0): <none>
[08:28:14.354] Packages needed by future strategies (n = 0): <none>
[08:28:14.354] {
[08:28:14.354]     {
[08:28:14.354]         {
[08:28:14.354]             ...future.startTime <- base::Sys.time()
[08:28:14.354]             {
[08:28:14.354]                 {
[08:28:14.354]                   {
[08:28:14.354]                     base::local({
[08:28:14.354]                       has_future <- base::requireNamespace("future", 
[08:28:14.354]                         quietly = TRUE)
[08:28:14.354]                       if (has_future) {
[08:28:14.354]                         ns <- base::getNamespace("future")
[08:28:14.354]                         version <- ns[[".package"]][["version"]]
[08:28:14.354]                         if (is.null(version)) 
[08:28:14.354]                           version <- utils::packageVersion("future")
[08:28:14.354]                       }
[08:28:14.354]                       else {
[08:28:14.354]                         version <- NULL
[08:28:14.354]                       }
[08:28:14.354]                       if (!has_future || version < "1.8.0") {
[08:28:14.354]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.354]                           "", base::R.version$version.string), 
[08:28:14.354]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.354]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.354]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.354]                             "release", "version")], collapse = " "), 
[08:28:14.354]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.354]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.354]                           info)
[08:28:14.354]                         info <- base::paste(info, collapse = "; ")
[08:28:14.354]                         if (!has_future) {
[08:28:14.354]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.354]                             info)
[08:28:14.354]                         }
[08:28:14.354]                         else {
[08:28:14.354]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.354]                             info, version)
[08:28:14.354]                         }
[08:28:14.354]                         base::stop(msg)
[08:28:14.354]                       }
[08:28:14.354]                     })
[08:28:14.354]                   }
[08:28:14.354]                   ...future.strategy.old <- future::plan("list")
[08:28:14.354]                   options(future.plan = NULL)
[08:28:14.354]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.354]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.354]                 }
[08:28:14.354]                 ...future.workdir <- getwd()
[08:28:14.354]             }
[08:28:14.354]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.354]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.354]         }
[08:28:14.354]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.354]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.354]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.354]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.354]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.354]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.354]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.354]             base::names(...future.oldOptions))
[08:28:14.354]     }
[08:28:14.354]     if (FALSE) {
[08:28:14.354]     }
[08:28:14.354]     else {
[08:28:14.354]         if (TRUE) {
[08:28:14.354]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.354]                 open = "w")
[08:28:14.354]         }
[08:28:14.354]         else {
[08:28:14.354]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.354]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.354]         }
[08:28:14.354]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.354]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.354]             base::sink(type = "output", split = FALSE)
[08:28:14.354]             base::close(...future.stdout)
[08:28:14.354]         }, add = TRUE)
[08:28:14.354]     }
[08:28:14.354]     ...future.frame <- base::sys.nframe()
[08:28:14.354]     ...future.conditions <- base::list()
[08:28:14.354]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.354]     if (FALSE) {
[08:28:14.354]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.354]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.354]     }
[08:28:14.354]     ...future.result <- base::tryCatch({
[08:28:14.354]         base::withCallingHandlers({
[08:28:14.354]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.354]             future::FutureResult(value = ...future.value$value, 
[08:28:14.354]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.354]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.354]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.354]                     ...future.globalenv.names))
[08:28:14.354]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.354]         }, condition = base::local({
[08:28:14.354]             c <- base::c
[08:28:14.354]             inherits <- base::inherits
[08:28:14.354]             invokeRestart <- base::invokeRestart
[08:28:14.354]             length <- base::length
[08:28:14.354]             list <- base::list
[08:28:14.354]             seq.int <- base::seq.int
[08:28:14.354]             signalCondition <- base::signalCondition
[08:28:14.354]             sys.calls <- base::sys.calls
[08:28:14.354]             `[[` <- base::`[[`
[08:28:14.354]             `+` <- base::`+`
[08:28:14.354]             `<<-` <- base::`<<-`
[08:28:14.354]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.354]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.354]                   3L)]
[08:28:14.354]             }
[08:28:14.354]             function(cond) {
[08:28:14.354]                 is_error <- inherits(cond, "error")
[08:28:14.354]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.354]                   NULL)
[08:28:14.354]                 if (is_error) {
[08:28:14.354]                   sessionInformation <- function() {
[08:28:14.354]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.354]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.354]                       search = base::search(), system = base::Sys.info())
[08:28:14.354]                   }
[08:28:14.354]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.354]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.354]                     cond$call), session = sessionInformation(), 
[08:28:14.354]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.354]                   signalCondition(cond)
[08:28:14.354]                 }
[08:28:14.354]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.354]                 "immediateCondition"))) {
[08:28:14.354]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.354]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.354]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.354]                   if (TRUE && !signal) {
[08:28:14.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.354]                     {
[08:28:14.354]                       inherits <- base::inherits
[08:28:14.354]                       invokeRestart <- base::invokeRestart
[08:28:14.354]                       is.null <- base::is.null
[08:28:14.354]                       muffled <- FALSE
[08:28:14.354]                       if (inherits(cond, "message")) {
[08:28:14.354]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.354]                         if (muffled) 
[08:28:14.354]                           invokeRestart("muffleMessage")
[08:28:14.354]                       }
[08:28:14.354]                       else if (inherits(cond, "warning")) {
[08:28:14.354]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.354]                         if (muffled) 
[08:28:14.354]                           invokeRestart("muffleWarning")
[08:28:14.354]                       }
[08:28:14.354]                       else if (inherits(cond, "condition")) {
[08:28:14.354]                         if (!is.null(pattern)) {
[08:28:14.354]                           computeRestarts <- base::computeRestarts
[08:28:14.354]                           grepl <- base::grepl
[08:28:14.354]                           restarts <- computeRestarts(cond)
[08:28:14.354]                           for (restart in restarts) {
[08:28:14.354]                             name <- restart$name
[08:28:14.354]                             if (is.null(name)) 
[08:28:14.354]                               next
[08:28:14.354]                             if (!grepl(pattern, name)) 
[08:28:14.354]                               next
[08:28:14.354]                             invokeRestart(restart)
[08:28:14.354]                             muffled <- TRUE
[08:28:14.354]                             break
[08:28:14.354]                           }
[08:28:14.354]                         }
[08:28:14.354]                       }
[08:28:14.354]                       invisible(muffled)
[08:28:14.354]                     }
[08:28:14.354]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.354]                   }
[08:28:14.354]                 }
[08:28:14.354]                 else {
[08:28:14.354]                   if (TRUE) {
[08:28:14.354]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.354]                     {
[08:28:14.354]                       inherits <- base::inherits
[08:28:14.354]                       invokeRestart <- base::invokeRestart
[08:28:14.354]                       is.null <- base::is.null
[08:28:14.354]                       muffled <- FALSE
[08:28:14.354]                       if (inherits(cond, "message")) {
[08:28:14.354]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.354]                         if (muffled) 
[08:28:14.354]                           invokeRestart("muffleMessage")
[08:28:14.354]                       }
[08:28:14.354]                       else if (inherits(cond, "warning")) {
[08:28:14.354]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.354]                         if (muffled) 
[08:28:14.354]                           invokeRestart("muffleWarning")
[08:28:14.354]                       }
[08:28:14.354]                       else if (inherits(cond, "condition")) {
[08:28:14.354]                         if (!is.null(pattern)) {
[08:28:14.354]                           computeRestarts <- base::computeRestarts
[08:28:14.354]                           grepl <- base::grepl
[08:28:14.354]                           restarts <- computeRestarts(cond)
[08:28:14.354]                           for (restart in restarts) {
[08:28:14.354]                             name <- restart$name
[08:28:14.354]                             if (is.null(name)) 
[08:28:14.354]                               next
[08:28:14.354]                             if (!grepl(pattern, name)) 
[08:28:14.354]                               next
[08:28:14.354]                             invokeRestart(restart)
[08:28:14.354]                             muffled <- TRUE
[08:28:14.354]                             break
[08:28:14.354]                           }
[08:28:14.354]                         }
[08:28:14.354]                       }
[08:28:14.354]                       invisible(muffled)
[08:28:14.354]                     }
[08:28:14.354]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.354]                   }
[08:28:14.354]                 }
[08:28:14.354]             }
[08:28:14.354]         }))
[08:28:14.354]     }, error = function(ex) {
[08:28:14.354]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.354]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.354]                 ...future.rng), started = ...future.startTime, 
[08:28:14.354]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.354]             version = "1.8"), class = "FutureResult")
[08:28:14.354]     }, finally = {
[08:28:14.354]         if (!identical(...future.workdir, getwd())) 
[08:28:14.354]             setwd(...future.workdir)
[08:28:14.354]         {
[08:28:14.354]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.354]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.354]             }
[08:28:14.354]             base::options(...future.oldOptions)
[08:28:14.354]             if (.Platform$OS.type == "windows") {
[08:28:14.354]                 old_names <- names(...future.oldEnvVars)
[08:28:14.354]                 envs <- base::Sys.getenv()
[08:28:14.354]                 names <- names(envs)
[08:28:14.354]                 common <- intersect(names, old_names)
[08:28:14.354]                 added <- setdiff(names, old_names)
[08:28:14.354]                 removed <- setdiff(old_names, names)
[08:28:14.354]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.354]                   envs[common]]
[08:28:14.354]                 NAMES <- toupper(changed)
[08:28:14.354]                 args <- list()
[08:28:14.354]                 for (kk in seq_along(NAMES)) {
[08:28:14.354]                   name <- changed[[kk]]
[08:28:14.354]                   NAME <- NAMES[[kk]]
[08:28:14.354]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.354]                     next
[08:28:14.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.354]                 }
[08:28:14.354]                 NAMES <- toupper(added)
[08:28:14.354]                 for (kk in seq_along(NAMES)) {
[08:28:14.354]                   name <- added[[kk]]
[08:28:14.354]                   NAME <- NAMES[[kk]]
[08:28:14.354]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.354]                     next
[08:28:14.354]                   args[[name]] <- ""
[08:28:14.354]                 }
[08:28:14.354]                 NAMES <- toupper(removed)
[08:28:14.354]                 for (kk in seq_along(NAMES)) {
[08:28:14.354]                   name <- removed[[kk]]
[08:28:14.354]                   NAME <- NAMES[[kk]]
[08:28:14.354]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.354]                     next
[08:28:14.354]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.354]                 }
[08:28:14.354]                 if (length(args) > 0) 
[08:28:14.354]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.354]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.354]             }
[08:28:14.354]             else {
[08:28:14.354]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.354]             }
[08:28:14.354]             {
[08:28:14.354]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.354]                   0L) {
[08:28:14.354]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.354]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.354]                   base::options(opts)
[08:28:14.354]                 }
[08:28:14.354]                 {
[08:28:14.354]                   {
[08:28:14.354]                     NULL
[08:28:14.354]                     RNGkind("Mersenne-Twister")
[08:28:14.354]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.354]                       inherits = FALSE)
[08:28:14.354]                   }
[08:28:14.354]                   options(future.plan = NULL)
[08:28:14.354]                   if (is.na(NA_character_)) 
[08:28:14.354]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.354]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.354]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.354]                     .init = FALSE)
[08:28:14.354]                 }
[08:28:14.354]             }
[08:28:14.354]         }
[08:28:14.354]     })
[08:28:14.354]     if (TRUE) {
[08:28:14.354]         base::sink(type = "output", split = FALSE)
[08:28:14.354]         if (TRUE) {
[08:28:14.354]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.354]         }
[08:28:14.354]         else {
[08:28:14.354]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.354]         }
[08:28:14.354]         base::close(...future.stdout)
[08:28:14.354]         ...future.stdout <- NULL
[08:28:14.354]     }
[08:28:14.354]     ...future.result$conditions <- ...future.conditions
[08:28:14.354]     ...future.result$finished <- base::Sys.time()
[08:28:14.354]     ...future.result
[08:28:14.354] }
[08:28:14.356] plan(): Setting new future strategy stack:
[08:28:14.356] List of future strategies:
[08:28:14.356] 1. sequential:
[08:28:14.356]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.356]    - tweaked: FALSE
[08:28:14.356]    - call: NULL
[08:28:14.356] plan(): nbrOfWorkers() = 1
[08:28:14.357] plan(): Setting new future strategy stack:
[08:28:14.357] List of future strategies:
[08:28:14.357] 1. sequential:
[08:28:14.357]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.357]    - tweaked: FALSE
[08:28:14.357]    - call: plan(strategy)
[08:28:14.358] plan(): nbrOfWorkers() = 1
[08:28:14.358] SequentialFuture started (and completed)
[08:28:14.358] - Launch lazy future ... done
[08:28:14.358] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.358] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.358] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.359] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.359] Searching for globals ... DONE
[08:28:14.359] Resolving globals: TRUE
[08:28:14.359] Resolving any globals that are futures ...
[08:28:14.359] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.360] Resolving any globals that are futures ... DONE
[08:28:14.360] Resolving futures part of globals (recursively) ...
[08:28:14.360] resolve() on list ...
[08:28:14.360]  recursive: 99
[08:28:14.360]  length: 1
[08:28:14.360]  elements: ‘a’
[08:28:14.361] resolved() for ‘SequentialFuture’ ...
[08:28:14.361] - state: ‘finished’
[08:28:14.361] - run: TRUE
[08:28:14.361] - result: ‘FutureResult’
[08:28:14.361] resolved() for ‘SequentialFuture’ ... done
[08:28:14.361] Future #1
[08:28:14.361] resolved() for ‘SequentialFuture’ ...
[08:28:14.361] - state: ‘finished’
[08:28:14.361] - run: TRUE
[08:28:14.362] - result: ‘FutureResult’
[08:28:14.362] resolved() for ‘SequentialFuture’ ... done
[08:28:14.362] A SequentialFuture was resolved
[08:28:14.362]  length: 0 (resolved future 1)
[08:28:14.362] resolve() on list ... DONE
[08:28:14.362] - globals: [1] ‘a’
[08:28:14.362] Resolving futures part of globals (recursively) ... DONE
[08:28:14.362] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[08:28:14.362] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[08:28:14.363] - globals: [1] ‘a’
[08:28:14.363] - packages: [1] ‘future’
[08:28:14.363] getGlobalsAndPackages() ... DONE
[08:28:14.363] run() for ‘Future’ ...
[08:28:14.363] - state: ‘created’
[08:28:14.363] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.363] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.364] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.364]   - Field: ‘label’
[08:28:14.364]   - Field: ‘local’
[08:28:14.364]   - Field: ‘owner’
[08:28:14.364]   - Field: ‘envir’
[08:28:14.364]   - Field: ‘packages’
[08:28:14.364]   - Field: ‘gc’
[08:28:14.364]   - Field: ‘conditions’
[08:28:14.364]   - Field: ‘expr’
[08:28:14.364]   - Field: ‘uuid’
[08:28:14.364]   - Field: ‘seed’
[08:28:14.364]   - Field: ‘version’
[08:28:14.365]   - Field: ‘result’
[08:28:14.365]   - Field: ‘asynchronous’
[08:28:14.365]   - Field: ‘calls’
[08:28:14.365]   - Field: ‘globals’
[08:28:14.365]   - Field: ‘stdout’
[08:28:14.365]   - Field: ‘earlySignal’
[08:28:14.365]   - Field: ‘lazy’
[08:28:14.365]   - Field: ‘state’
[08:28:14.365] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.365] - Launch lazy future ...
[08:28:14.365] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.366] Packages needed by future strategies (n = 0): <none>
[08:28:14.366] {
[08:28:14.366]     {
[08:28:14.366]         {
[08:28:14.366]             ...future.startTime <- base::Sys.time()
[08:28:14.366]             {
[08:28:14.366]                 {
[08:28:14.366]                   {
[08:28:14.366]                     {
[08:28:14.366]                       base::local({
[08:28:14.366]                         has_future <- base::requireNamespace("future", 
[08:28:14.366]                           quietly = TRUE)
[08:28:14.366]                         if (has_future) {
[08:28:14.366]                           ns <- base::getNamespace("future")
[08:28:14.366]                           version <- ns[[".package"]][["version"]]
[08:28:14.366]                           if (is.null(version)) 
[08:28:14.366]                             version <- utils::packageVersion("future")
[08:28:14.366]                         }
[08:28:14.366]                         else {
[08:28:14.366]                           version <- NULL
[08:28:14.366]                         }
[08:28:14.366]                         if (!has_future || version < "1.8.0") {
[08:28:14.366]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.366]                             "", base::R.version$version.string), 
[08:28:14.366]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.366]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.366]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.366]                               "release", "version")], collapse = " "), 
[08:28:14.366]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.366]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.366]                             info)
[08:28:14.366]                           info <- base::paste(info, collapse = "; ")
[08:28:14.366]                           if (!has_future) {
[08:28:14.366]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.366]                               info)
[08:28:14.366]                           }
[08:28:14.366]                           else {
[08:28:14.366]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.366]                               info, version)
[08:28:14.366]                           }
[08:28:14.366]                           base::stop(msg)
[08:28:14.366]                         }
[08:28:14.366]                       })
[08:28:14.366]                     }
[08:28:14.366]                     base::local({
[08:28:14.366]                       for (pkg in "future") {
[08:28:14.366]                         base::loadNamespace(pkg)
[08:28:14.366]                         base::library(pkg, character.only = TRUE)
[08:28:14.366]                       }
[08:28:14.366]                     })
[08:28:14.366]                   }
[08:28:14.366]                   ...future.strategy.old <- future::plan("list")
[08:28:14.366]                   options(future.plan = NULL)
[08:28:14.366]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.366]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.366]                 }
[08:28:14.366]                 ...future.workdir <- getwd()
[08:28:14.366]             }
[08:28:14.366]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.366]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.366]         }
[08:28:14.366]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.366]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.366]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.366]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.366]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.366]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.366]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.366]             base::names(...future.oldOptions))
[08:28:14.366]     }
[08:28:14.366]     if (FALSE) {
[08:28:14.366]     }
[08:28:14.366]     else {
[08:28:14.366]         if (TRUE) {
[08:28:14.366]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.366]                 open = "w")
[08:28:14.366]         }
[08:28:14.366]         else {
[08:28:14.366]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.366]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.366]         }
[08:28:14.366]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.366]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.366]             base::sink(type = "output", split = FALSE)
[08:28:14.366]             base::close(...future.stdout)
[08:28:14.366]         }, add = TRUE)
[08:28:14.366]     }
[08:28:14.366]     ...future.frame <- base::sys.nframe()
[08:28:14.366]     ...future.conditions <- base::list()
[08:28:14.366]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.366]     if (FALSE) {
[08:28:14.366]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.366]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.366]     }
[08:28:14.366]     ...future.result <- base::tryCatch({
[08:28:14.366]         base::withCallingHandlers({
[08:28:14.366]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.366]                 1))
[08:28:14.366]             future::FutureResult(value = ...future.value$value, 
[08:28:14.366]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.366]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.366]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.366]                     ...future.globalenv.names))
[08:28:14.366]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.366]         }, condition = base::local({
[08:28:14.366]             c <- base::c
[08:28:14.366]             inherits <- base::inherits
[08:28:14.366]             invokeRestart <- base::invokeRestart
[08:28:14.366]             length <- base::length
[08:28:14.366]             list <- base::list
[08:28:14.366]             seq.int <- base::seq.int
[08:28:14.366]             signalCondition <- base::signalCondition
[08:28:14.366]             sys.calls <- base::sys.calls
[08:28:14.366]             `[[` <- base::`[[`
[08:28:14.366]             `+` <- base::`+`
[08:28:14.366]             `<<-` <- base::`<<-`
[08:28:14.366]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.366]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.366]                   3L)]
[08:28:14.366]             }
[08:28:14.366]             function(cond) {
[08:28:14.366]                 is_error <- inherits(cond, "error")
[08:28:14.366]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.366]                   NULL)
[08:28:14.366]                 if (is_error) {
[08:28:14.366]                   sessionInformation <- function() {
[08:28:14.366]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.366]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.366]                       search = base::search(), system = base::Sys.info())
[08:28:14.366]                   }
[08:28:14.366]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.366]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.366]                     cond$call), session = sessionInformation(), 
[08:28:14.366]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.366]                   signalCondition(cond)
[08:28:14.366]                 }
[08:28:14.366]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.366]                 "immediateCondition"))) {
[08:28:14.366]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.366]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.366]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.366]                   if (TRUE && !signal) {
[08:28:14.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.366]                     {
[08:28:14.366]                       inherits <- base::inherits
[08:28:14.366]                       invokeRestart <- base::invokeRestart
[08:28:14.366]                       is.null <- base::is.null
[08:28:14.366]                       muffled <- FALSE
[08:28:14.366]                       if (inherits(cond, "message")) {
[08:28:14.366]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.366]                         if (muffled) 
[08:28:14.366]                           invokeRestart("muffleMessage")
[08:28:14.366]                       }
[08:28:14.366]                       else if (inherits(cond, "warning")) {
[08:28:14.366]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.366]                         if (muffled) 
[08:28:14.366]                           invokeRestart("muffleWarning")
[08:28:14.366]                       }
[08:28:14.366]                       else if (inherits(cond, "condition")) {
[08:28:14.366]                         if (!is.null(pattern)) {
[08:28:14.366]                           computeRestarts <- base::computeRestarts
[08:28:14.366]                           grepl <- base::grepl
[08:28:14.366]                           restarts <- computeRestarts(cond)
[08:28:14.366]                           for (restart in restarts) {
[08:28:14.366]                             name <- restart$name
[08:28:14.366]                             if (is.null(name)) 
[08:28:14.366]                               next
[08:28:14.366]                             if (!grepl(pattern, name)) 
[08:28:14.366]                               next
[08:28:14.366]                             invokeRestart(restart)
[08:28:14.366]                             muffled <- TRUE
[08:28:14.366]                             break
[08:28:14.366]                           }
[08:28:14.366]                         }
[08:28:14.366]                       }
[08:28:14.366]                       invisible(muffled)
[08:28:14.366]                     }
[08:28:14.366]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.366]                   }
[08:28:14.366]                 }
[08:28:14.366]                 else {
[08:28:14.366]                   if (TRUE) {
[08:28:14.366]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.366]                     {
[08:28:14.366]                       inherits <- base::inherits
[08:28:14.366]                       invokeRestart <- base::invokeRestart
[08:28:14.366]                       is.null <- base::is.null
[08:28:14.366]                       muffled <- FALSE
[08:28:14.366]                       if (inherits(cond, "message")) {
[08:28:14.366]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.366]                         if (muffled) 
[08:28:14.366]                           invokeRestart("muffleMessage")
[08:28:14.366]                       }
[08:28:14.366]                       else if (inherits(cond, "warning")) {
[08:28:14.366]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.366]                         if (muffled) 
[08:28:14.366]                           invokeRestart("muffleWarning")
[08:28:14.366]                       }
[08:28:14.366]                       else if (inherits(cond, "condition")) {
[08:28:14.366]                         if (!is.null(pattern)) {
[08:28:14.366]                           computeRestarts <- base::computeRestarts
[08:28:14.366]                           grepl <- base::grepl
[08:28:14.366]                           restarts <- computeRestarts(cond)
[08:28:14.366]                           for (restart in restarts) {
[08:28:14.366]                             name <- restart$name
[08:28:14.366]                             if (is.null(name)) 
[08:28:14.366]                               next
[08:28:14.366]                             if (!grepl(pattern, name)) 
[08:28:14.366]                               next
[08:28:14.366]                             invokeRestart(restart)
[08:28:14.366]                             muffled <- TRUE
[08:28:14.366]                             break
[08:28:14.366]                           }
[08:28:14.366]                         }
[08:28:14.366]                       }
[08:28:14.366]                       invisible(muffled)
[08:28:14.366]                     }
[08:28:14.366]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.366]                   }
[08:28:14.366]                 }
[08:28:14.366]             }
[08:28:14.366]         }))
[08:28:14.366]     }, error = function(ex) {
[08:28:14.366]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.366]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.366]                 ...future.rng), started = ...future.startTime, 
[08:28:14.366]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.366]             version = "1.8"), class = "FutureResult")
[08:28:14.366]     }, finally = {
[08:28:14.366]         if (!identical(...future.workdir, getwd())) 
[08:28:14.366]             setwd(...future.workdir)
[08:28:14.366]         {
[08:28:14.366]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.366]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.366]             }
[08:28:14.366]             base::options(...future.oldOptions)
[08:28:14.366]             if (.Platform$OS.type == "windows") {
[08:28:14.366]                 old_names <- names(...future.oldEnvVars)
[08:28:14.366]                 envs <- base::Sys.getenv()
[08:28:14.366]                 names <- names(envs)
[08:28:14.366]                 common <- intersect(names, old_names)
[08:28:14.366]                 added <- setdiff(names, old_names)
[08:28:14.366]                 removed <- setdiff(old_names, names)
[08:28:14.366]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.366]                   envs[common]]
[08:28:14.366]                 NAMES <- toupper(changed)
[08:28:14.366]                 args <- list()
[08:28:14.366]                 for (kk in seq_along(NAMES)) {
[08:28:14.366]                   name <- changed[[kk]]
[08:28:14.366]                   NAME <- NAMES[[kk]]
[08:28:14.366]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.366]                     next
[08:28:14.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.366]                 }
[08:28:14.366]                 NAMES <- toupper(added)
[08:28:14.366]                 for (kk in seq_along(NAMES)) {
[08:28:14.366]                   name <- added[[kk]]
[08:28:14.366]                   NAME <- NAMES[[kk]]
[08:28:14.366]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.366]                     next
[08:28:14.366]                   args[[name]] <- ""
[08:28:14.366]                 }
[08:28:14.366]                 NAMES <- toupper(removed)
[08:28:14.366]                 for (kk in seq_along(NAMES)) {
[08:28:14.366]                   name <- removed[[kk]]
[08:28:14.366]                   NAME <- NAMES[[kk]]
[08:28:14.366]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.366]                     next
[08:28:14.366]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.366]                 }
[08:28:14.366]                 if (length(args) > 0) 
[08:28:14.366]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.366]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.366]             }
[08:28:14.366]             else {
[08:28:14.366]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.366]             }
[08:28:14.366]             {
[08:28:14.366]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.366]                   0L) {
[08:28:14.366]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.366]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.366]                   base::options(opts)
[08:28:14.366]                 }
[08:28:14.366]                 {
[08:28:14.366]                   {
[08:28:14.366]                     NULL
[08:28:14.366]                     RNGkind("Mersenne-Twister")
[08:28:14.366]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.366]                       inherits = FALSE)
[08:28:14.366]                   }
[08:28:14.366]                   options(future.plan = NULL)
[08:28:14.366]                   if (is.na(NA_character_)) 
[08:28:14.366]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.366]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.366]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.366]                     .init = FALSE)
[08:28:14.366]                 }
[08:28:14.366]             }
[08:28:14.366]         }
[08:28:14.366]     })
[08:28:14.366]     if (TRUE) {
[08:28:14.366]         base::sink(type = "output", split = FALSE)
[08:28:14.366]         if (TRUE) {
[08:28:14.366]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.366]         }
[08:28:14.366]         else {
[08:28:14.366]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.366]         }
[08:28:14.366]         base::close(...future.stdout)
[08:28:14.366]         ...future.stdout <- NULL
[08:28:14.366]     }
[08:28:14.366]     ...future.result$conditions <- ...future.conditions
[08:28:14.366]     ...future.result$finished <- base::Sys.time()
[08:28:14.366]     ...future.result
[08:28:14.366] }
[08:28:14.368] assign_globals() ...
[08:28:14.368] List of 1
[08:28:14.368]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a107e7a2e0> 
[08:28:14.368]  - attr(*, "where")=List of 1
[08:28:14.368]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.368]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.368]  - attr(*, "resolved")= logi TRUE
[08:28:14.368]  - attr(*, "total_size")= num 3535
[08:28:14.368]  - attr(*, "already-done")= logi TRUE
[08:28:14.370] - copied ‘a’ to environment
[08:28:14.370] assign_globals() ... done
[08:28:14.370] plan(): Setting new future strategy stack:
[08:28:14.370] List of future strategies:
[08:28:14.370] 1. sequential:
[08:28:14.370]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.370]    - tweaked: FALSE
[08:28:14.370]    - call: NULL
[08:28:14.371] plan(): nbrOfWorkers() = 1
[08:28:14.372] plan(): Setting new future strategy stack:
[08:28:14.372] List of future strategies:
[08:28:14.372] 1. sequential:
[08:28:14.372]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.372]    - tweaked: FALSE
[08:28:14.372]    - call: plan(strategy)
[08:28:14.372] plan(): nbrOfWorkers() = 1
[08:28:14.372] SequentialFuture started (and completed)
[08:28:14.372] - Launch lazy future ... done
[08:28:14.372] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.373] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.373] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.374] 
[08:28:14.375] Searching for globals ... DONE
[08:28:14.375] - globals: [0] <none>
[08:28:14.375] getGlobalsAndPackages() ... DONE
[08:28:14.375] run() for ‘Future’ ...
[08:28:14.375] - state: ‘created’
[08:28:14.375] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.376] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.376] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.376]   - Field: ‘label’
[08:28:14.376]   - Field: ‘local’
[08:28:14.376]   - Field: ‘owner’
[08:28:14.376]   - Field: ‘envir’
[08:28:14.376]   - Field: ‘packages’
[08:28:14.376]   - Field: ‘gc’
[08:28:14.376]   - Field: ‘conditions’
[08:28:14.376]   - Field: ‘expr’
[08:28:14.376]   - Field: ‘uuid’
[08:28:14.377]   - Field: ‘seed’
[08:28:14.377]   - Field: ‘version’
[08:28:14.377]   - Field: ‘result’
[08:28:14.377]   - Field: ‘asynchronous’
[08:28:14.377]   - Field: ‘calls’
[08:28:14.377]   - Field: ‘globals’
[08:28:14.377]   - Field: ‘stdout’
[08:28:14.377]   - Field: ‘earlySignal’
[08:28:14.377]   - Field: ‘lazy’
[08:28:14.377]   - Field: ‘state’
[08:28:14.377] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.377] - Launch lazy future ...
[08:28:14.378] Packages needed by the future expression (n = 0): <none>
[08:28:14.378] Packages needed by future strategies (n = 0): <none>
[08:28:14.378] {
[08:28:14.378]     {
[08:28:14.378]         {
[08:28:14.378]             ...future.startTime <- base::Sys.time()
[08:28:14.378]             {
[08:28:14.378]                 {
[08:28:14.378]                   {
[08:28:14.378]                     base::local({
[08:28:14.378]                       has_future <- base::requireNamespace("future", 
[08:28:14.378]                         quietly = TRUE)
[08:28:14.378]                       if (has_future) {
[08:28:14.378]                         ns <- base::getNamespace("future")
[08:28:14.378]                         version <- ns[[".package"]][["version"]]
[08:28:14.378]                         if (is.null(version)) 
[08:28:14.378]                           version <- utils::packageVersion("future")
[08:28:14.378]                       }
[08:28:14.378]                       else {
[08:28:14.378]                         version <- NULL
[08:28:14.378]                       }
[08:28:14.378]                       if (!has_future || version < "1.8.0") {
[08:28:14.378]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.378]                           "", base::R.version$version.string), 
[08:28:14.378]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.378]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.378]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.378]                             "release", "version")], collapse = " "), 
[08:28:14.378]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.378]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.378]                           info)
[08:28:14.378]                         info <- base::paste(info, collapse = "; ")
[08:28:14.378]                         if (!has_future) {
[08:28:14.378]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.378]                             info)
[08:28:14.378]                         }
[08:28:14.378]                         else {
[08:28:14.378]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.378]                             info, version)
[08:28:14.378]                         }
[08:28:14.378]                         base::stop(msg)
[08:28:14.378]                       }
[08:28:14.378]                     })
[08:28:14.378]                   }
[08:28:14.378]                   ...future.strategy.old <- future::plan("list")
[08:28:14.378]                   options(future.plan = NULL)
[08:28:14.378]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.378]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.378]                 }
[08:28:14.378]                 ...future.workdir <- getwd()
[08:28:14.378]             }
[08:28:14.378]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.378]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.378]         }
[08:28:14.378]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.378]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.378]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.378]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.378]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.378]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.378]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.378]             base::names(...future.oldOptions))
[08:28:14.378]     }
[08:28:14.378]     if (FALSE) {
[08:28:14.378]     }
[08:28:14.378]     else {
[08:28:14.378]         if (TRUE) {
[08:28:14.378]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.378]                 open = "w")
[08:28:14.378]         }
[08:28:14.378]         else {
[08:28:14.378]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.378]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.378]         }
[08:28:14.378]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.378]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.378]             base::sink(type = "output", split = FALSE)
[08:28:14.378]             base::close(...future.stdout)
[08:28:14.378]         }, add = TRUE)
[08:28:14.378]     }
[08:28:14.378]     ...future.frame <- base::sys.nframe()
[08:28:14.378]     ...future.conditions <- base::list()
[08:28:14.378]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.378]     if (FALSE) {
[08:28:14.378]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.378]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.378]     }
[08:28:14.378]     ...future.result <- base::tryCatch({
[08:28:14.378]         base::withCallingHandlers({
[08:28:14.378]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.378]             future::FutureResult(value = ...future.value$value, 
[08:28:14.378]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.378]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.378]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.378]                     ...future.globalenv.names))
[08:28:14.378]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.378]         }, condition = base::local({
[08:28:14.378]             c <- base::c
[08:28:14.378]             inherits <- base::inherits
[08:28:14.378]             invokeRestart <- base::invokeRestart
[08:28:14.378]             length <- base::length
[08:28:14.378]             list <- base::list
[08:28:14.378]             seq.int <- base::seq.int
[08:28:14.378]             signalCondition <- base::signalCondition
[08:28:14.378]             sys.calls <- base::sys.calls
[08:28:14.378]             `[[` <- base::`[[`
[08:28:14.378]             `+` <- base::`+`
[08:28:14.378]             `<<-` <- base::`<<-`
[08:28:14.378]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.378]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.378]                   3L)]
[08:28:14.378]             }
[08:28:14.378]             function(cond) {
[08:28:14.378]                 is_error <- inherits(cond, "error")
[08:28:14.378]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.378]                   NULL)
[08:28:14.378]                 if (is_error) {
[08:28:14.378]                   sessionInformation <- function() {
[08:28:14.378]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.378]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.378]                       search = base::search(), system = base::Sys.info())
[08:28:14.378]                   }
[08:28:14.378]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.378]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.378]                     cond$call), session = sessionInformation(), 
[08:28:14.378]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.378]                   signalCondition(cond)
[08:28:14.378]                 }
[08:28:14.378]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.378]                 "immediateCondition"))) {
[08:28:14.378]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.378]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.378]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.378]                   if (TRUE && !signal) {
[08:28:14.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.378]                     {
[08:28:14.378]                       inherits <- base::inherits
[08:28:14.378]                       invokeRestart <- base::invokeRestart
[08:28:14.378]                       is.null <- base::is.null
[08:28:14.378]                       muffled <- FALSE
[08:28:14.378]                       if (inherits(cond, "message")) {
[08:28:14.378]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.378]                         if (muffled) 
[08:28:14.378]                           invokeRestart("muffleMessage")
[08:28:14.378]                       }
[08:28:14.378]                       else if (inherits(cond, "warning")) {
[08:28:14.378]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.378]                         if (muffled) 
[08:28:14.378]                           invokeRestart("muffleWarning")
[08:28:14.378]                       }
[08:28:14.378]                       else if (inherits(cond, "condition")) {
[08:28:14.378]                         if (!is.null(pattern)) {
[08:28:14.378]                           computeRestarts <- base::computeRestarts
[08:28:14.378]                           grepl <- base::grepl
[08:28:14.378]                           restarts <- computeRestarts(cond)
[08:28:14.378]                           for (restart in restarts) {
[08:28:14.378]                             name <- restart$name
[08:28:14.378]                             if (is.null(name)) 
[08:28:14.378]                               next
[08:28:14.378]                             if (!grepl(pattern, name)) 
[08:28:14.378]                               next
[08:28:14.378]                             invokeRestart(restart)
[08:28:14.378]                             muffled <- TRUE
[08:28:14.378]                             break
[08:28:14.378]                           }
[08:28:14.378]                         }
[08:28:14.378]                       }
[08:28:14.378]                       invisible(muffled)
[08:28:14.378]                     }
[08:28:14.378]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.378]                   }
[08:28:14.378]                 }
[08:28:14.378]                 else {
[08:28:14.378]                   if (TRUE) {
[08:28:14.378]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.378]                     {
[08:28:14.378]                       inherits <- base::inherits
[08:28:14.378]                       invokeRestart <- base::invokeRestart
[08:28:14.378]                       is.null <- base::is.null
[08:28:14.378]                       muffled <- FALSE
[08:28:14.378]                       if (inherits(cond, "message")) {
[08:28:14.378]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.378]                         if (muffled) 
[08:28:14.378]                           invokeRestart("muffleMessage")
[08:28:14.378]                       }
[08:28:14.378]                       else if (inherits(cond, "warning")) {
[08:28:14.378]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.378]                         if (muffled) 
[08:28:14.378]                           invokeRestart("muffleWarning")
[08:28:14.378]                       }
[08:28:14.378]                       else if (inherits(cond, "condition")) {
[08:28:14.378]                         if (!is.null(pattern)) {
[08:28:14.378]                           computeRestarts <- base::computeRestarts
[08:28:14.378]                           grepl <- base::grepl
[08:28:14.378]                           restarts <- computeRestarts(cond)
[08:28:14.378]                           for (restart in restarts) {
[08:28:14.378]                             name <- restart$name
[08:28:14.378]                             if (is.null(name)) 
[08:28:14.378]                               next
[08:28:14.378]                             if (!grepl(pattern, name)) 
[08:28:14.378]                               next
[08:28:14.378]                             invokeRestart(restart)
[08:28:14.378]                             muffled <- TRUE
[08:28:14.378]                             break
[08:28:14.378]                           }
[08:28:14.378]                         }
[08:28:14.378]                       }
[08:28:14.378]                       invisible(muffled)
[08:28:14.378]                     }
[08:28:14.378]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.378]                   }
[08:28:14.378]                 }
[08:28:14.378]             }
[08:28:14.378]         }))
[08:28:14.378]     }, error = function(ex) {
[08:28:14.378]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.378]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.378]                 ...future.rng), started = ...future.startTime, 
[08:28:14.378]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.378]             version = "1.8"), class = "FutureResult")
[08:28:14.378]     }, finally = {
[08:28:14.378]         if (!identical(...future.workdir, getwd())) 
[08:28:14.378]             setwd(...future.workdir)
[08:28:14.378]         {
[08:28:14.378]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.378]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.378]             }
[08:28:14.378]             base::options(...future.oldOptions)
[08:28:14.378]             if (.Platform$OS.type == "windows") {
[08:28:14.378]                 old_names <- names(...future.oldEnvVars)
[08:28:14.378]                 envs <- base::Sys.getenv()
[08:28:14.378]                 names <- names(envs)
[08:28:14.378]                 common <- intersect(names, old_names)
[08:28:14.378]                 added <- setdiff(names, old_names)
[08:28:14.378]                 removed <- setdiff(old_names, names)
[08:28:14.378]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.378]                   envs[common]]
[08:28:14.378]                 NAMES <- toupper(changed)
[08:28:14.378]                 args <- list()
[08:28:14.378]                 for (kk in seq_along(NAMES)) {
[08:28:14.378]                   name <- changed[[kk]]
[08:28:14.378]                   NAME <- NAMES[[kk]]
[08:28:14.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.378]                     next
[08:28:14.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.378]                 }
[08:28:14.378]                 NAMES <- toupper(added)
[08:28:14.378]                 for (kk in seq_along(NAMES)) {
[08:28:14.378]                   name <- added[[kk]]
[08:28:14.378]                   NAME <- NAMES[[kk]]
[08:28:14.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.378]                     next
[08:28:14.378]                   args[[name]] <- ""
[08:28:14.378]                 }
[08:28:14.378]                 NAMES <- toupper(removed)
[08:28:14.378]                 for (kk in seq_along(NAMES)) {
[08:28:14.378]                   name <- removed[[kk]]
[08:28:14.378]                   NAME <- NAMES[[kk]]
[08:28:14.378]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.378]                     next
[08:28:14.378]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.378]                 }
[08:28:14.378]                 if (length(args) > 0) 
[08:28:14.378]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.378]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.378]             }
[08:28:14.378]             else {
[08:28:14.378]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.378]             }
[08:28:14.378]             {
[08:28:14.378]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.378]                   0L) {
[08:28:14.378]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.378]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.378]                   base::options(opts)
[08:28:14.378]                 }
[08:28:14.378]                 {
[08:28:14.378]                   {
[08:28:14.378]                     NULL
[08:28:14.378]                     RNGkind("Mersenne-Twister")
[08:28:14.378]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.378]                       inherits = FALSE)
[08:28:14.378]                   }
[08:28:14.378]                   options(future.plan = NULL)
[08:28:14.378]                   if (is.na(NA_character_)) 
[08:28:14.378]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.378]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.378]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.378]                     .init = FALSE)
[08:28:14.378]                 }
[08:28:14.378]             }
[08:28:14.378]         }
[08:28:14.378]     })
[08:28:14.378]     if (TRUE) {
[08:28:14.378]         base::sink(type = "output", split = FALSE)
[08:28:14.378]         if (TRUE) {
[08:28:14.378]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.378]         }
[08:28:14.378]         else {
[08:28:14.378]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.378]         }
[08:28:14.378]         base::close(...future.stdout)
[08:28:14.378]         ...future.stdout <- NULL
[08:28:14.378]     }
[08:28:14.378]     ...future.result$conditions <- ...future.conditions
[08:28:14.378]     ...future.result$finished <- base::Sys.time()
[08:28:14.378]     ...future.result
[08:28:14.378] }
[08:28:14.380] plan(): Setting new future strategy stack:
[08:28:14.380] List of future strategies:
[08:28:14.380] 1. sequential:
[08:28:14.380]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.380]    - tweaked: FALSE
[08:28:14.380]    - call: NULL
[08:28:14.380] plan(): nbrOfWorkers() = 1
[08:28:14.381] plan(): Setting new future strategy stack:
[08:28:14.381] List of future strategies:
[08:28:14.381] 1. sequential:
[08:28:14.381]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.381]    - tweaked: FALSE
[08:28:14.381]    - call: plan(strategy)
[08:28:14.381] plan(): nbrOfWorkers() = 1
[08:28:14.382] SequentialFuture started (and completed)
[08:28:14.382] - Launch lazy future ... done
[08:28:14.382] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.382] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.382] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.383] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.383] Searching for globals ... DONE
[08:28:14.383] Resolving globals: TRUE
[08:28:14.383] Resolving any globals that are futures ...
[08:28:14.383] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.383] Resolving any globals that are futures ... DONE
[08:28:14.384] Resolving futures part of globals (recursively) ...
[08:28:14.384] resolve() on list ...
[08:28:14.384]  recursive: 99
[08:28:14.384]  length: 1
[08:28:14.384]  elements: ‘a’
[08:28:14.384] resolved() for ‘SequentialFuture’ ...
[08:28:14.384] - state: ‘finished’
[08:28:14.384] - run: TRUE
[08:28:14.385] - result: ‘FutureResult’
[08:28:14.385] resolved() for ‘SequentialFuture’ ... done
[08:28:14.385] Future #1
[08:28:14.385] resolved() for ‘SequentialFuture’ ...
[08:28:14.385] - state: ‘finished’
[08:28:14.385] - run: TRUE
[08:28:14.385] - result: ‘FutureResult’
[08:28:14.385] resolved() for ‘SequentialFuture’ ... done
[08:28:14.385] A SequentialFuture was resolved
[08:28:14.385]  length: 0 (resolved future 1)
[08:28:14.385] resolve() on list ... DONE
[08:28:14.386] - globals: [1] ‘a’
[08:28:14.386] Resolving futures part of globals (recursively) ... DONE
[08:28:14.386] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[08:28:14.386] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[08:28:14.386] - globals: [1] ‘a’
[08:28:14.386] - packages: [1] ‘future’
[08:28:14.386] getGlobalsAndPackages() ... DONE
[08:28:14.387] run() for ‘Future’ ...
[08:28:14.387] - state: ‘created’
[08:28:14.387] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.387] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.387] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.387]   - Field: ‘label’
[08:28:14.387]   - Field: ‘local’
[08:28:14.387]   - Field: ‘owner’
[08:28:14.388]   - Field: ‘envir’
[08:28:14.388]   - Field: ‘packages’
[08:28:14.388]   - Field: ‘gc’
[08:28:14.388]   - Field: ‘conditions’
[08:28:14.388]   - Field: ‘expr’
[08:28:14.388]   - Field: ‘uuid’
[08:28:14.388]   - Field: ‘seed’
[08:28:14.388]   - Field: ‘version’
[08:28:14.388]   - Field: ‘result’
[08:28:14.388]   - Field: ‘asynchronous’
[08:28:14.388]   - Field: ‘calls’
[08:28:14.388]   - Field: ‘globals’
[08:28:14.388]   - Field: ‘stdout’
[08:28:14.389]   - Field: ‘earlySignal’
[08:28:14.389]   - Field: ‘lazy’
[08:28:14.389]   - Field: ‘state’
[08:28:14.389] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.389] - Launch lazy future ...
[08:28:14.389] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.389] Packages needed by future strategies (n = 0): <none>
[08:28:14.390] {
[08:28:14.390]     {
[08:28:14.390]         {
[08:28:14.390]             ...future.startTime <- base::Sys.time()
[08:28:14.390]             {
[08:28:14.390]                 {
[08:28:14.390]                   {
[08:28:14.390]                     {
[08:28:14.390]                       base::local({
[08:28:14.390]                         has_future <- base::requireNamespace("future", 
[08:28:14.390]                           quietly = TRUE)
[08:28:14.390]                         if (has_future) {
[08:28:14.390]                           ns <- base::getNamespace("future")
[08:28:14.390]                           version <- ns[[".package"]][["version"]]
[08:28:14.390]                           if (is.null(version)) 
[08:28:14.390]                             version <- utils::packageVersion("future")
[08:28:14.390]                         }
[08:28:14.390]                         else {
[08:28:14.390]                           version <- NULL
[08:28:14.390]                         }
[08:28:14.390]                         if (!has_future || version < "1.8.0") {
[08:28:14.390]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.390]                             "", base::R.version$version.string), 
[08:28:14.390]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.390]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.390]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.390]                               "release", "version")], collapse = " "), 
[08:28:14.390]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.390]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.390]                             info)
[08:28:14.390]                           info <- base::paste(info, collapse = "; ")
[08:28:14.390]                           if (!has_future) {
[08:28:14.390]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.390]                               info)
[08:28:14.390]                           }
[08:28:14.390]                           else {
[08:28:14.390]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.390]                               info, version)
[08:28:14.390]                           }
[08:28:14.390]                           base::stop(msg)
[08:28:14.390]                         }
[08:28:14.390]                       })
[08:28:14.390]                     }
[08:28:14.390]                     base::local({
[08:28:14.390]                       for (pkg in "future") {
[08:28:14.390]                         base::loadNamespace(pkg)
[08:28:14.390]                         base::library(pkg, character.only = TRUE)
[08:28:14.390]                       }
[08:28:14.390]                     })
[08:28:14.390]                   }
[08:28:14.390]                   ...future.strategy.old <- future::plan("list")
[08:28:14.390]                   options(future.plan = NULL)
[08:28:14.390]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.390]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.390]                 }
[08:28:14.390]                 ...future.workdir <- getwd()
[08:28:14.390]             }
[08:28:14.390]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.390]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.390]         }
[08:28:14.390]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.390]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.390]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.390]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.390]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.390]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.390]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.390]             base::names(...future.oldOptions))
[08:28:14.390]     }
[08:28:14.390]     if (FALSE) {
[08:28:14.390]     }
[08:28:14.390]     else {
[08:28:14.390]         if (TRUE) {
[08:28:14.390]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.390]                 open = "w")
[08:28:14.390]         }
[08:28:14.390]         else {
[08:28:14.390]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.390]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.390]         }
[08:28:14.390]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.390]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.390]             base::sink(type = "output", split = FALSE)
[08:28:14.390]             base::close(...future.stdout)
[08:28:14.390]         }, add = TRUE)
[08:28:14.390]     }
[08:28:14.390]     ...future.frame <- base::sys.nframe()
[08:28:14.390]     ...future.conditions <- base::list()
[08:28:14.390]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.390]     if (FALSE) {
[08:28:14.390]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.390]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.390]     }
[08:28:14.390]     ...future.result <- base::tryCatch({
[08:28:14.390]         base::withCallingHandlers({
[08:28:14.390]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.390]                 1))
[08:28:14.390]             future::FutureResult(value = ...future.value$value, 
[08:28:14.390]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.390]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.390]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.390]                     ...future.globalenv.names))
[08:28:14.390]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.390]         }, condition = base::local({
[08:28:14.390]             c <- base::c
[08:28:14.390]             inherits <- base::inherits
[08:28:14.390]             invokeRestart <- base::invokeRestart
[08:28:14.390]             length <- base::length
[08:28:14.390]             list <- base::list
[08:28:14.390]             seq.int <- base::seq.int
[08:28:14.390]             signalCondition <- base::signalCondition
[08:28:14.390]             sys.calls <- base::sys.calls
[08:28:14.390]             `[[` <- base::`[[`
[08:28:14.390]             `+` <- base::`+`
[08:28:14.390]             `<<-` <- base::`<<-`
[08:28:14.390]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.390]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.390]                   3L)]
[08:28:14.390]             }
[08:28:14.390]             function(cond) {
[08:28:14.390]                 is_error <- inherits(cond, "error")
[08:28:14.390]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.390]                   NULL)
[08:28:14.390]                 if (is_error) {
[08:28:14.390]                   sessionInformation <- function() {
[08:28:14.390]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.390]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.390]                       search = base::search(), system = base::Sys.info())
[08:28:14.390]                   }
[08:28:14.390]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.390]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.390]                     cond$call), session = sessionInformation(), 
[08:28:14.390]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.390]                   signalCondition(cond)
[08:28:14.390]                 }
[08:28:14.390]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.390]                 "immediateCondition"))) {
[08:28:14.390]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.390]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.390]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.390]                   if (TRUE && !signal) {
[08:28:14.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.390]                     {
[08:28:14.390]                       inherits <- base::inherits
[08:28:14.390]                       invokeRestart <- base::invokeRestart
[08:28:14.390]                       is.null <- base::is.null
[08:28:14.390]                       muffled <- FALSE
[08:28:14.390]                       if (inherits(cond, "message")) {
[08:28:14.390]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.390]                         if (muffled) 
[08:28:14.390]                           invokeRestart("muffleMessage")
[08:28:14.390]                       }
[08:28:14.390]                       else if (inherits(cond, "warning")) {
[08:28:14.390]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.390]                         if (muffled) 
[08:28:14.390]                           invokeRestart("muffleWarning")
[08:28:14.390]                       }
[08:28:14.390]                       else if (inherits(cond, "condition")) {
[08:28:14.390]                         if (!is.null(pattern)) {
[08:28:14.390]                           computeRestarts <- base::computeRestarts
[08:28:14.390]                           grepl <- base::grepl
[08:28:14.390]                           restarts <- computeRestarts(cond)
[08:28:14.390]                           for (restart in restarts) {
[08:28:14.390]                             name <- restart$name
[08:28:14.390]                             if (is.null(name)) 
[08:28:14.390]                               next
[08:28:14.390]                             if (!grepl(pattern, name)) 
[08:28:14.390]                               next
[08:28:14.390]                             invokeRestart(restart)
[08:28:14.390]                             muffled <- TRUE
[08:28:14.390]                             break
[08:28:14.390]                           }
[08:28:14.390]                         }
[08:28:14.390]                       }
[08:28:14.390]                       invisible(muffled)
[08:28:14.390]                     }
[08:28:14.390]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.390]                   }
[08:28:14.390]                 }
[08:28:14.390]                 else {
[08:28:14.390]                   if (TRUE) {
[08:28:14.390]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.390]                     {
[08:28:14.390]                       inherits <- base::inherits
[08:28:14.390]                       invokeRestart <- base::invokeRestart
[08:28:14.390]                       is.null <- base::is.null
[08:28:14.390]                       muffled <- FALSE
[08:28:14.390]                       if (inherits(cond, "message")) {
[08:28:14.390]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.390]                         if (muffled) 
[08:28:14.390]                           invokeRestart("muffleMessage")
[08:28:14.390]                       }
[08:28:14.390]                       else if (inherits(cond, "warning")) {
[08:28:14.390]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.390]                         if (muffled) 
[08:28:14.390]                           invokeRestart("muffleWarning")
[08:28:14.390]                       }
[08:28:14.390]                       else if (inherits(cond, "condition")) {
[08:28:14.390]                         if (!is.null(pattern)) {
[08:28:14.390]                           computeRestarts <- base::computeRestarts
[08:28:14.390]                           grepl <- base::grepl
[08:28:14.390]                           restarts <- computeRestarts(cond)
[08:28:14.390]                           for (restart in restarts) {
[08:28:14.390]                             name <- restart$name
[08:28:14.390]                             if (is.null(name)) 
[08:28:14.390]                               next
[08:28:14.390]                             if (!grepl(pattern, name)) 
[08:28:14.390]                               next
[08:28:14.390]                             invokeRestart(restart)
[08:28:14.390]                             muffled <- TRUE
[08:28:14.390]                             break
[08:28:14.390]                           }
[08:28:14.390]                         }
[08:28:14.390]                       }
[08:28:14.390]                       invisible(muffled)
[08:28:14.390]                     }
[08:28:14.390]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.390]                   }
[08:28:14.390]                 }
[08:28:14.390]             }
[08:28:14.390]         }))
[08:28:14.390]     }, error = function(ex) {
[08:28:14.390]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.390]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.390]                 ...future.rng), started = ...future.startTime, 
[08:28:14.390]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.390]             version = "1.8"), class = "FutureResult")
[08:28:14.390]     }, finally = {
[08:28:14.390]         if (!identical(...future.workdir, getwd())) 
[08:28:14.390]             setwd(...future.workdir)
[08:28:14.390]         {
[08:28:14.390]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.390]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.390]             }
[08:28:14.390]             base::options(...future.oldOptions)
[08:28:14.390]             if (.Platform$OS.type == "windows") {
[08:28:14.390]                 old_names <- names(...future.oldEnvVars)
[08:28:14.390]                 envs <- base::Sys.getenv()
[08:28:14.390]                 names <- names(envs)
[08:28:14.390]                 common <- intersect(names, old_names)
[08:28:14.390]                 added <- setdiff(names, old_names)
[08:28:14.390]                 removed <- setdiff(old_names, names)
[08:28:14.390]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.390]                   envs[common]]
[08:28:14.390]                 NAMES <- toupper(changed)
[08:28:14.390]                 args <- list()
[08:28:14.390]                 for (kk in seq_along(NAMES)) {
[08:28:14.390]                   name <- changed[[kk]]
[08:28:14.390]                   NAME <- NAMES[[kk]]
[08:28:14.390]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.390]                     next
[08:28:14.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.390]                 }
[08:28:14.390]                 NAMES <- toupper(added)
[08:28:14.390]                 for (kk in seq_along(NAMES)) {
[08:28:14.390]                   name <- added[[kk]]
[08:28:14.390]                   NAME <- NAMES[[kk]]
[08:28:14.390]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.390]                     next
[08:28:14.390]                   args[[name]] <- ""
[08:28:14.390]                 }
[08:28:14.390]                 NAMES <- toupper(removed)
[08:28:14.390]                 for (kk in seq_along(NAMES)) {
[08:28:14.390]                   name <- removed[[kk]]
[08:28:14.390]                   NAME <- NAMES[[kk]]
[08:28:14.390]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.390]                     next
[08:28:14.390]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.390]                 }
[08:28:14.390]                 if (length(args) > 0) 
[08:28:14.390]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.390]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.390]             }
[08:28:14.390]             else {
[08:28:14.390]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.390]             }
[08:28:14.390]             {
[08:28:14.390]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.390]                   0L) {
[08:28:14.390]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.390]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.390]                   base::options(opts)
[08:28:14.390]                 }
[08:28:14.390]                 {
[08:28:14.390]                   {
[08:28:14.390]                     NULL
[08:28:14.390]                     RNGkind("Mersenne-Twister")
[08:28:14.390]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.390]                       inherits = FALSE)
[08:28:14.390]                   }
[08:28:14.390]                   options(future.plan = NULL)
[08:28:14.390]                   if (is.na(NA_character_)) 
[08:28:14.390]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.390]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.390]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.390]                     .init = FALSE)
[08:28:14.390]                 }
[08:28:14.390]             }
[08:28:14.390]         }
[08:28:14.390]     })
[08:28:14.390]     if (TRUE) {
[08:28:14.390]         base::sink(type = "output", split = FALSE)
[08:28:14.390]         if (TRUE) {
[08:28:14.390]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.390]         }
[08:28:14.390]         else {
[08:28:14.390]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.390]         }
[08:28:14.390]         base::close(...future.stdout)
[08:28:14.390]         ...future.stdout <- NULL
[08:28:14.390]     }
[08:28:14.390]     ...future.result$conditions <- ...future.conditions
[08:28:14.390]     ...future.result$finished <- base::Sys.time()
[08:28:14.390]     ...future.result
[08:28:14.390] }
[08:28:14.391] assign_globals() ...
[08:28:14.391] List of 1
[08:28:14.391]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a108d71a08> 
[08:28:14.391]  - attr(*, "where")=List of 1
[08:28:14.391]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.391]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.391]  - attr(*, "resolved")= logi TRUE
[08:28:14.391]  - attr(*, "total_size")= num 3535
[08:28:14.391]  - attr(*, "already-done")= logi TRUE
[08:28:14.393] - copied ‘a’ to environment
[08:28:14.394] assign_globals() ... done
[08:28:14.394] plan(): Setting new future strategy stack:
[08:28:14.394] List of future strategies:
[08:28:14.394] 1. sequential:
[08:28:14.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.394]    - tweaked: FALSE
[08:28:14.394]    - call: NULL
[08:28:14.394] plan(): nbrOfWorkers() = 1
[08:28:14.395] plan(): Setting new future strategy stack:
[08:28:14.395] List of future strategies:
[08:28:14.395] 1. sequential:
[08:28:14.395]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.395]    - tweaked: FALSE
[08:28:14.395]    - call: plan(strategy)
[08:28:14.396] plan(): nbrOfWorkers() = 1
[08:28:14.396] SequentialFuture started (and completed)
[08:28:14.396] - Launch lazy future ... done
[08:28:14.396] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.396] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.397] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.397] 
[08:28:14.397] Searching for globals ... DONE
[08:28:14.397] - globals: [0] <none>
[08:28:14.397] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.398] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.398] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.399] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.399] Searching for globals ... DONE
[08:28:14.399] Resolving globals: TRUE
[08:28:14.399] Resolving any globals that are futures ...
[08:28:14.399] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.399] Resolving any globals that are futures ... DONE
[08:28:14.399] Resolving futures part of globals (recursively) ...
[08:28:14.401] resolve() on list ...
[08:28:14.401]  recursive: 99
[08:28:14.401]  length: 1
[08:28:14.401]  elements: ‘a’
[08:28:14.401] run() for ‘Future’ ...
[08:28:14.401] - state: ‘created’
[08:28:14.401] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.401] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.402] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.402]   - Field: ‘label’
[08:28:14.402]   - Field: ‘local’
[08:28:14.402]   - Field: ‘owner’
[08:28:14.402]   - Field: ‘envir’
[08:28:14.402]   - Field: ‘packages’
[08:28:14.402]   - Field: ‘gc’
[08:28:14.402]   - Field: ‘conditions’
[08:28:14.402]   - Field: ‘expr’
[08:28:14.402]   - Field: ‘uuid’
[08:28:14.402]   - Field: ‘seed’
[08:28:14.402]   - Field: ‘version’
[08:28:14.403]   - Field: ‘result’
[08:28:14.403]   - Field: ‘asynchronous’
[08:28:14.403]   - Field: ‘calls’
[08:28:14.403]   - Field: ‘globals’
[08:28:14.403]   - Field: ‘stdout’
[08:28:14.403]   - Field: ‘earlySignal’
[08:28:14.403]   - Field: ‘lazy’
[08:28:14.403]   - Field: ‘state’
[08:28:14.403] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.403] - Launch lazy future ...
[08:28:14.403] Packages needed by the future expression (n = 0): <none>
[08:28:14.404] Packages needed by future strategies (n = 0): <none>
[08:28:14.404] {
[08:28:14.404]     {
[08:28:14.404]         {
[08:28:14.404]             ...future.startTime <- base::Sys.time()
[08:28:14.404]             {
[08:28:14.404]                 {
[08:28:14.404]                   {
[08:28:14.404]                     base::local({
[08:28:14.404]                       has_future <- base::requireNamespace("future", 
[08:28:14.404]                         quietly = TRUE)
[08:28:14.404]                       if (has_future) {
[08:28:14.404]                         ns <- base::getNamespace("future")
[08:28:14.404]                         version <- ns[[".package"]][["version"]]
[08:28:14.404]                         if (is.null(version)) 
[08:28:14.404]                           version <- utils::packageVersion("future")
[08:28:14.404]                       }
[08:28:14.404]                       else {
[08:28:14.404]                         version <- NULL
[08:28:14.404]                       }
[08:28:14.404]                       if (!has_future || version < "1.8.0") {
[08:28:14.404]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.404]                           "", base::R.version$version.string), 
[08:28:14.404]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.404]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.404]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.404]                             "release", "version")], collapse = " "), 
[08:28:14.404]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.404]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.404]                           info)
[08:28:14.404]                         info <- base::paste(info, collapse = "; ")
[08:28:14.404]                         if (!has_future) {
[08:28:14.404]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.404]                             info)
[08:28:14.404]                         }
[08:28:14.404]                         else {
[08:28:14.404]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.404]                             info, version)
[08:28:14.404]                         }
[08:28:14.404]                         base::stop(msg)
[08:28:14.404]                       }
[08:28:14.404]                     })
[08:28:14.404]                   }
[08:28:14.404]                   ...future.strategy.old <- future::plan("list")
[08:28:14.404]                   options(future.plan = NULL)
[08:28:14.404]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.404]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.404]                 }
[08:28:14.404]                 ...future.workdir <- getwd()
[08:28:14.404]             }
[08:28:14.404]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.404]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.404]         }
[08:28:14.404]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.404]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.404]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.404]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.404]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.404]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.404]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.404]             base::names(...future.oldOptions))
[08:28:14.404]     }
[08:28:14.404]     if (FALSE) {
[08:28:14.404]     }
[08:28:14.404]     else {
[08:28:14.404]         if (TRUE) {
[08:28:14.404]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.404]                 open = "w")
[08:28:14.404]         }
[08:28:14.404]         else {
[08:28:14.404]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.404]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.404]         }
[08:28:14.404]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.404]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.404]             base::sink(type = "output", split = FALSE)
[08:28:14.404]             base::close(...future.stdout)
[08:28:14.404]         }, add = TRUE)
[08:28:14.404]     }
[08:28:14.404]     ...future.frame <- base::sys.nframe()
[08:28:14.404]     ...future.conditions <- base::list()
[08:28:14.404]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.404]     if (FALSE) {
[08:28:14.404]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.404]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.404]     }
[08:28:14.404]     ...future.result <- base::tryCatch({
[08:28:14.404]         base::withCallingHandlers({
[08:28:14.404]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.404]             future::FutureResult(value = ...future.value$value, 
[08:28:14.404]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.404]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.404]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.404]                     ...future.globalenv.names))
[08:28:14.404]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.404]         }, condition = base::local({
[08:28:14.404]             c <- base::c
[08:28:14.404]             inherits <- base::inherits
[08:28:14.404]             invokeRestart <- base::invokeRestart
[08:28:14.404]             length <- base::length
[08:28:14.404]             list <- base::list
[08:28:14.404]             seq.int <- base::seq.int
[08:28:14.404]             signalCondition <- base::signalCondition
[08:28:14.404]             sys.calls <- base::sys.calls
[08:28:14.404]             `[[` <- base::`[[`
[08:28:14.404]             `+` <- base::`+`
[08:28:14.404]             `<<-` <- base::`<<-`
[08:28:14.404]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.404]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.404]                   3L)]
[08:28:14.404]             }
[08:28:14.404]             function(cond) {
[08:28:14.404]                 is_error <- inherits(cond, "error")
[08:28:14.404]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.404]                   NULL)
[08:28:14.404]                 if (is_error) {
[08:28:14.404]                   sessionInformation <- function() {
[08:28:14.404]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.404]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.404]                       search = base::search(), system = base::Sys.info())
[08:28:14.404]                   }
[08:28:14.404]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.404]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.404]                     cond$call), session = sessionInformation(), 
[08:28:14.404]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.404]                   signalCondition(cond)
[08:28:14.404]                 }
[08:28:14.404]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.404]                 "immediateCondition"))) {
[08:28:14.404]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.404]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.404]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.404]                   if (TRUE && !signal) {
[08:28:14.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.404]                     {
[08:28:14.404]                       inherits <- base::inherits
[08:28:14.404]                       invokeRestart <- base::invokeRestart
[08:28:14.404]                       is.null <- base::is.null
[08:28:14.404]                       muffled <- FALSE
[08:28:14.404]                       if (inherits(cond, "message")) {
[08:28:14.404]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.404]                         if (muffled) 
[08:28:14.404]                           invokeRestart("muffleMessage")
[08:28:14.404]                       }
[08:28:14.404]                       else if (inherits(cond, "warning")) {
[08:28:14.404]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.404]                         if (muffled) 
[08:28:14.404]                           invokeRestart("muffleWarning")
[08:28:14.404]                       }
[08:28:14.404]                       else if (inherits(cond, "condition")) {
[08:28:14.404]                         if (!is.null(pattern)) {
[08:28:14.404]                           computeRestarts <- base::computeRestarts
[08:28:14.404]                           grepl <- base::grepl
[08:28:14.404]                           restarts <- computeRestarts(cond)
[08:28:14.404]                           for (restart in restarts) {
[08:28:14.404]                             name <- restart$name
[08:28:14.404]                             if (is.null(name)) 
[08:28:14.404]                               next
[08:28:14.404]                             if (!grepl(pattern, name)) 
[08:28:14.404]                               next
[08:28:14.404]                             invokeRestart(restart)
[08:28:14.404]                             muffled <- TRUE
[08:28:14.404]                             break
[08:28:14.404]                           }
[08:28:14.404]                         }
[08:28:14.404]                       }
[08:28:14.404]                       invisible(muffled)
[08:28:14.404]                     }
[08:28:14.404]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.404]                   }
[08:28:14.404]                 }
[08:28:14.404]                 else {
[08:28:14.404]                   if (TRUE) {
[08:28:14.404]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.404]                     {
[08:28:14.404]                       inherits <- base::inherits
[08:28:14.404]                       invokeRestart <- base::invokeRestart
[08:28:14.404]                       is.null <- base::is.null
[08:28:14.404]                       muffled <- FALSE
[08:28:14.404]                       if (inherits(cond, "message")) {
[08:28:14.404]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.404]                         if (muffled) 
[08:28:14.404]                           invokeRestart("muffleMessage")
[08:28:14.404]                       }
[08:28:14.404]                       else if (inherits(cond, "warning")) {
[08:28:14.404]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.404]                         if (muffled) 
[08:28:14.404]                           invokeRestart("muffleWarning")
[08:28:14.404]                       }
[08:28:14.404]                       else if (inherits(cond, "condition")) {
[08:28:14.404]                         if (!is.null(pattern)) {
[08:28:14.404]                           computeRestarts <- base::computeRestarts
[08:28:14.404]                           grepl <- base::grepl
[08:28:14.404]                           restarts <- computeRestarts(cond)
[08:28:14.404]                           for (restart in restarts) {
[08:28:14.404]                             name <- restart$name
[08:28:14.404]                             if (is.null(name)) 
[08:28:14.404]                               next
[08:28:14.404]                             if (!grepl(pattern, name)) 
[08:28:14.404]                               next
[08:28:14.404]                             invokeRestart(restart)
[08:28:14.404]                             muffled <- TRUE
[08:28:14.404]                             break
[08:28:14.404]                           }
[08:28:14.404]                         }
[08:28:14.404]                       }
[08:28:14.404]                       invisible(muffled)
[08:28:14.404]                     }
[08:28:14.404]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.404]                   }
[08:28:14.404]                 }
[08:28:14.404]             }
[08:28:14.404]         }))
[08:28:14.404]     }, error = function(ex) {
[08:28:14.404]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.404]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.404]                 ...future.rng), started = ...future.startTime, 
[08:28:14.404]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.404]             version = "1.8"), class = "FutureResult")
[08:28:14.404]     }, finally = {
[08:28:14.404]         if (!identical(...future.workdir, getwd())) 
[08:28:14.404]             setwd(...future.workdir)
[08:28:14.404]         {
[08:28:14.404]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.404]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.404]             }
[08:28:14.404]             base::options(...future.oldOptions)
[08:28:14.404]             if (.Platform$OS.type == "windows") {
[08:28:14.404]                 old_names <- names(...future.oldEnvVars)
[08:28:14.404]                 envs <- base::Sys.getenv()
[08:28:14.404]                 names <- names(envs)
[08:28:14.404]                 common <- intersect(names, old_names)
[08:28:14.404]                 added <- setdiff(names, old_names)
[08:28:14.404]                 removed <- setdiff(old_names, names)
[08:28:14.404]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.404]                   envs[common]]
[08:28:14.404]                 NAMES <- toupper(changed)
[08:28:14.404]                 args <- list()
[08:28:14.404]                 for (kk in seq_along(NAMES)) {
[08:28:14.404]                   name <- changed[[kk]]
[08:28:14.404]                   NAME <- NAMES[[kk]]
[08:28:14.404]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.404]                     next
[08:28:14.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.404]                 }
[08:28:14.404]                 NAMES <- toupper(added)
[08:28:14.404]                 for (kk in seq_along(NAMES)) {
[08:28:14.404]                   name <- added[[kk]]
[08:28:14.404]                   NAME <- NAMES[[kk]]
[08:28:14.404]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.404]                     next
[08:28:14.404]                   args[[name]] <- ""
[08:28:14.404]                 }
[08:28:14.404]                 NAMES <- toupper(removed)
[08:28:14.404]                 for (kk in seq_along(NAMES)) {
[08:28:14.404]                   name <- removed[[kk]]
[08:28:14.404]                   NAME <- NAMES[[kk]]
[08:28:14.404]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.404]                     next
[08:28:14.404]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.404]                 }
[08:28:14.404]                 if (length(args) > 0) 
[08:28:14.404]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.404]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.404]             }
[08:28:14.404]             else {
[08:28:14.404]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.404]             }
[08:28:14.404]             {
[08:28:14.404]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.404]                   0L) {
[08:28:14.404]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.404]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.404]                   base::options(opts)
[08:28:14.404]                 }
[08:28:14.404]                 {
[08:28:14.404]                   {
[08:28:14.404]                     NULL
[08:28:14.404]                     RNGkind("Mersenne-Twister")
[08:28:14.404]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.404]                       inherits = FALSE)
[08:28:14.404]                   }
[08:28:14.404]                   options(future.plan = NULL)
[08:28:14.404]                   if (is.na(NA_character_)) 
[08:28:14.404]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.404]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.404]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.404]                     .init = FALSE)
[08:28:14.404]                 }
[08:28:14.404]             }
[08:28:14.404]         }
[08:28:14.404]     })
[08:28:14.404]     if (TRUE) {
[08:28:14.404]         base::sink(type = "output", split = FALSE)
[08:28:14.404]         if (TRUE) {
[08:28:14.404]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.404]         }
[08:28:14.404]         else {
[08:28:14.404]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.404]         }
[08:28:14.404]         base::close(...future.stdout)
[08:28:14.404]         ...future.stdout <- NULL
[08:28:14.404]     }
[08:28:14.404]     ...future.result$conditions <- ...future.conditions
[08:28:14.404]     ...future.result$finished <- base::Sys.time()
[08:28:14.404]     ...future.result
[08:28:14.404] }
[08:28:14.406] plan(): Setting new future strategy stack:
[08:28:14.406] List of future strategies:
[08:28:14.406] 1. sequential:
[08:28:14.406]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.406]    - tweaked: FALSE
[08:28:14.406]    - call: NULL
[08:28:14.406] plan(): nbrOfWorkers() = 1
[08:28:14.407] plan(): Setting new future strategy stack:
[08:28:14.407] List of future strategies:
[08:28:14.407] 1. sequential:
[08:28:14.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.407]    - tweaked: FALSE
[08:28:14.407]    - call: plan(strategy)
[08:28:14.407] plan(): nbrOfWorkers() = 1
[08:28:14.407] SequentialFuture started (and completed)
[08:28:14.408] - Launch lazy future ... done
[08:28:14.408] run() for ‘SequentialFuture’ ... done
[08:28:14.408] resolved() for ‘SequentialFuture’ ...
[08:28:14.408] - state: ‘finished’
[08:28:14.408] - run: TRUE
[08:28:14.408] - result: ‘FutureResult’
[08:28:14.408] resolved() for ‘SequentialFuture’ ... done
[08:28:14.408] Future #1
[08:28:14.408] resolved() for ‘SequentialFuture’ ...
[08:28:14.408] - state: ‘finished’
[08:28:14.409] - run: TRUE
[08:28:14.409] - result: ‘FutureResult’
[08:28:14.409] resolved() for ‘SequentialFuture’ ... done
[08:28:14.409] A SequentialFuture was resolved
[08:28:14.409]  length: 0 (resolved future 1)
[08:28:14.409] resolve() on list ... DONE
[08:28:14.409] - globals: [1] ‘a’
[08:28:14.409] Resolving futures part of globals (recursively) ... DONE
[08:28:14.409] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[08:28:14.410] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[08:28:14.410] - globals: [1] ‘a’
[08:28:14.410] - packages: [1] ‘future’
[08:28:14.410] getGlobalsAndPackages() ... DONE
[08:28:14.410] run() for ‘Future’ ...
[08:28:14.410] - state: ‘created’
[08:28:14.410] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.411] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.411] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.411]   - Field: ‘label’
[08:28:14.411]   - Field: ‘local’
[08:28:14.411]   - Field: ‘owner’
[08:28:14.411]   - Field: ‘envir’
[08:28:14.411]   - Field: ‘packages’
[08:28:14.411]   - Field: ‘gc’
[08:28:14.411]   - Field: ‘conditions’
[08:28:14.411]   - Field: ‘expr’
[08:28:14.411]   - Field: ‘uuid’
[08:28:14.412]   - Field: ‘seed’
[08:28:14.412]   - Field: ‘version’
[08:28:14.412]   - Field: ‘result’
[08:28:14.412]   - Field: ‘asynchronous’
[08:28:14.412]   - Field: ‘calls’
[08:28:14.412]   - Field: ‘globals’
[08:28:14.412]   - Field: ‘stdout’
[08:28:14.412]   - Field: ‘earlySignal’
[08:28:14.412]   - Field: ‘lazy’
[08:28:14.412]   - Field: ‘state’
[08:28:14.412] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.412] - Launch lazy future ...
[08:28:14.413] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.413] Packages needed by future strategies (n = 0): <none>
[08:28:14.413] {
[08:28:14.413]     {
[08:28:14.413]         {
[08:28:14.413]             ...future.startTime <- base::Sys.time()
[08:28:14.413]             {
[08:28:14.413]                 {
[08:28:14.413]                   {
[08:28:14.413]                     {
[08:28:14.413]                       base::local({
[08:28:14.413]                         has_future <- base::requireNamespace("future", 
[08:28:14.413]                           quietly = TRUE)
[08:28:14.413]                         if (has_future) {
[08:28:14.413]                           ns <- base::getNamespace("future")
[08:28:14.413]                           version <- ns[[".package"]][["version"]]
[08:28:14.413]                           if (is.null(version)) 
[08:28:14.413]                             version <- utils::packageVersion("future")
[08:28:14.413]                         }
[08:28:14.413]                         else {
[08:28:14.413]                           version <- NULL
[08:28:14.413]                         }
[08:28:14.413]                         if (!has_future || version < "1.8.0") {
[08:28:14.413]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.413]                             "", base::R.version$version.string), 
[08:28:14.413]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.413]                               "release", "version")], collapse = " "), 
[08:28:14.413]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.413]                             info)
[08:28:14.413]                           info <- base::paste(info, collapse = "; ")
[08:28:14.413]                           if (!has_future) {
[08:28:14.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.413]                               info)
[08:28:14.413]                           }
[08:28:14.413]                           else {
[08:28:14.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.413]                               info, version)
[08:28:14.413]                           }
[08:28:14.413]                           base::stop(msg)
[08:28:14.413]                         }
[08:28:14.413]                       })
[08:28:14.413]                     }
[08:28:14.413]                     base::local({
[08:28:14.413]                       for (pkg in "future") {
[08:28:14.413]                         base::loadNamespace(pkg)
[08:28:14.413]                         base::library(pkg, character.only = TRUE)
[08:28:14.413]                       }
[08:28:14.413]                     })
[08:28:14.413]                   }
[08:28:14.413]                   ...future.strategy.old <- future::plan("list")
[08:28:14.413]                   options(future.plan = NULL)
[08:28:14.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.413]                 }
[08:28:14.413]                 ...future.workdir <- getwd()
[08:28:14.413]             }
[08:28:14.413]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.413]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.413]         }
[08:28:14.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.413]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.413]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.413]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.413]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.413]             base::names(...future.oldOptions))
[08:28:14.413]     }
[08:28:14.413]     if (FALSE) {
[08:28:14.413]     }
[08:28:14.413]     else {
[08:28:14.413]         if (TRUE) {
[08:28:14.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.413]                 open = "w")
[08:28:14.413]         }
[08:28:14.413]         else {
[08:28:14.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.413]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.413]         }
[08:28:14.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.413]             base::sink(type = "output", split = FALSE)
[08:28:14.413]             base::close(...future.stdout)
[08:28:14.413]         }, add = TRUE)
[08:28:14.413]     }
[08:28:14.413]     ...future.frame <- base::sys.nframe()
[08:28:14.413]     ...future.conditions <- base::list()
[08:28:14.413]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.413]     if (FALSE) {
[08:28:14.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.413]     }
[08:28:14.413]     ...future.result <- base::tryCatch({
[08:28:14.413]         base::withCallingHandlers({
[08:28:14.413]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.413]                 1))
[08:28:14.413]             future::FutureResult(value = ...future.value$value, 
[08:28:14.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.413]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.413]                     ...future.globalenv.names))
[08:28:14.413]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.413]         }, condition = base::local({
[08:28:14.413]             c <- base::c
[08:28:14.413]             inherits <- base::inherits
[08:28:14.413]             invokeRestart <- base::invokeRestart
[08:28:14.413]             length <- base::length
[08:28:14.413]             list <- base::list
[08:28:14.413]             seq.int <- base::seq.int
[08:28:14.413]             signalCondition <- base::signalCondition
[08:28:14.413]             sys.calls <- base::sys.calls
[08:28:14.413]             `[[` <- base::`[[`
[08:28:14.413]             `+` <- base::`+`
[08:28:14.413]             `<<-` <- base::`<<-`
[08:28:14.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.413]                   3L)]
[08:28:14.413]             }
[08:28:14.413]             function(cond) {
[08:28:14.413]                 is_error <- inherits(cond, "error")
[08:28:14.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.413]                   NULL)
[08:28:14.413]                 if (is_error) {
[08:28:14.413]                   sessionInformation <- function() {
[08:28:14.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.413]                       search = base::search(), system = base::Sys.info())
[08:28:14.413]                   }
[08:28:14.413]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.413]                     cond$call), session = sessionInformation(), 
[08:28:14.413]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.413]                   signalCondition(cond)
[08:28:14.413]                 }
[08:28:14.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.413]                 "immediateCondition"))) {
[08:28:14.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.413]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.413]                   if (TRUE && !signal) {
[08:28:14.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.413]                     {
[08:28:14.413]                       inherits <- base::inherits
[08:28:14.413]                       invokeRestart <- base::invokeRestart
[08:28:14.413]                       is.null <- base::is.null
[08:28:14.413]                       muffled <- FALSE
[08:28:14.413]                       if (inherits(cond, "message")) {
[08:28:14.413]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.413]                         if (muffled) 
[08:28:14.413]                           invokeRestart("muffleMessage")
[08:28:14.413]                       }
[08:28:14.413]                       else if (inherits(cond, "warning")) {
[08:28:14.413]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.413]                         if (muffled) 
[08:28:14.413]                           invokeRestart("muffleWarning")
[08:28:14.413]                       }
[08:28:14.413]                       else if (inherits(cond, "condition")) {
[08:28:14.413]                         if (!is.null(pattern)) {
[08:28:14.413]                           computeRestarts <- base::computeRestarts
[08:28:14.413]                           grepl <- base::grepl
[08:28:14.413]                           restarts <- computeRestarts(cond)
[08:28:14.413]                           for (restart in restarts) {
[08:28:14.413]                             name <- restart$name
[08:28:14.413]                             if (is.null(name)) 
[08:28:14.413]                               next
[08:28:14.413]                             if (!grepl(pattern, name)) 
[08:28:14.413]                               next
[08:28:14.413]                             invokeRestart(restart)
[08:28:14.413]                             muffled <- TRUE
[08:28:14.413]                             break
[08:28:14.413]                           }
[08:28:14.413]                         }
[08:28:14.413]                       }
[08:28:14.413]                       invisible(muffled)
[08:28:14.413]                     }
[08:28:14.413]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.413]                   }
[08:28:14.413]                 }
[08:28:14.413]                 else {
[08:28:14.413]                   if (TRUE) {
[08:28:14.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.413]                     {
[08:28:14.413]                       inherits <- base::inherits
[08:28:14.413]                       invokeRestart <- base::invokeRestart
[08:28:14.413]                       is.null <- base::is.null
[08:28:14.413]                       muffled <- FALSE
[08:28:14.413]                       if (inherits(cond, "message")) {
[08:28:14.413]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.413]                         if (muffled) 
[08:28:14.413]                           invokeRestart("muffleMessage")
[08:28:14.413]                       }
[08:28:14.413]                       else if (inherits(cond, "warning")) {
[08:28:14.413]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.413]                         if (muffled) 
[08:28:14.413]                           invokeRestart("muffleWarning")
[08:28:14.413]                       }
[08:28:14.413]                       else if (inherits(cond, "condition")) {
[08:28:14.413]                         if (!is.null(pattern)) {
[08:28:14.413]                           computeRestarts <- base::computeRestarts
[08:28:14.413]                           grepl <- base::grepl
[08:28:14.413]                           restarts <- computeRestarts(cond)
[08:28:14.413]                           for (restart in restarts) {
[08:28:14.413]                             name <- restart$name
[08:28:14.413]                             if (is.null(name)) 
[08:28:14.413]                               next
[08:28:14.413]                             if (!grepl(pattern, name)) 
[08:28:14.413]                               next
[08:28:14.413]                             invokeRestart(restart)
[08:28:14.413]                             muffled <- TRUE
[08:28:14.413]                             break
[08:28:14.413]                           }
[08:28:14.413]                         }
[08:28:14.413]                       }
[08:28:14.413]                       invisible(muffled)
[08:28:14.413]                     }
[08:28:14.413]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.413]                   }
[08:28:14.413]                 }
[08:28:14.413]             }
[08:28:14.413]         }))
[08:28:14.413]     }, error = function(ex) {
[08:28:14.413]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.413]                 ...future.rng), started = ...future.startTime, 
[08:28:14.413]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.413]             version = "1.8"), class = "FutureResult")
[08:28:14.413]     }, finally = {
[08:28:14.413]         if (!identical(...future.workdir, getwd())) 
[08:28:14.413]             setwd(...future.workdir)
[08:28:14.413]         {
[08:28:14.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.413]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.413]             }
[08:28:14.413]             base::options(...future.oldOptions)
[08:28:14.413]             if (.Platform$OS.type == "windows") {
[08:28:14.413]                 old_names <- names(...future.oldEnvVars)
[08:28:14.413]                 envs <- base::Sys.getenv()
[08:28:14.413]                 names <- names(envs)
[08:28:14.413]                 common <- intersect(names, old_names)
[08:28:14.413]                 added <- setdiff(names, old_names)
[08:28:14.413]                 removed <- setdiff(old_names, names)
[08:28:14.413]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.413]                   envs[common]]
[08:28:14.413]                 NAMES <- toupper(changed)
[08:28:14.413]                 args <- list()
[08:28:14.413]                 for (kk in seq_along(NAMES)) {
[08:28:14.413]                   name <- changed[[kk]]
[08:28:14.413]                   NAME <- NAMES[[kk]]
[08:28:14.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.413]                     next
[08:28:14.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.413]                 }
[08:28:14.413]                 NAMES <- toupper(added)
[08:28:14.413]                 for (kk in seq_along(NAMES)) {
[08:28:14.413]                   name <- added[[kk]]
[08:28:14.413]                   NAME <- NAMES[[kk]]
[08:28:14.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.413]                     next
[08:28:14.413]                   args[[name]] <- ""
[08:28:14.413]                 }
[08:28:14.413]                 NAMES <- toupper(removed)
[08:28:14.413]                 for (kk in seq_along(NAMES)) {
[08:28:14.413]                   name <- removed[[kk]]
[08:28:14.413]                   NAME <- NAMES[[kk]]
[08:28:14.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.413]                     next
[08:28:14.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.413]                 }
[08:28:14.413]                 if (length(args) > 0) 
[08:28:14.413]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.413]             }
[08:28:14.413]             else {
[08:28:14.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.413]             }
[08:28:14.413]             {
[08:28:14.413]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.413]                   0L) {
[08:28:14.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.413]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.413]                   base::options(opts)
[08:28:14.413]                 }
[08:28:14.413]                 {
[08:28:14.413]                   {
[08:28:14.413]                     NULL
[08:28:14.413]                     RNGkind("Mersenne-Twister")
[08:28:14.413]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.413]                       inherits = FALSE)
[08:28:14.413]                   }
[08:28:14.413]                   options(future.plan = NULL)
[08:28:14.413]                   if (is.na(NA_character_)) 
[08:28:14.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.413]                     .init = FALSE)
[08:28:14.413]                 }
[08:28:14.413]             }
[08:28:14.413]         }
[08:28:14.413]     })
[08:28:14.413]     if (TRUE) {
[08:28:14.413]         base::sink(type = "output", split = FALSE)
[08:28:14.413]         if (TRUE) {
[08:28:14.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.413]         }
[08:28:14.413]         else {
[08:28:14.413]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.413]         }
[08:28:14.413]         base::close(...future.stdout)
[08:28:14.413]         ...future.stdout <- NULL
[08:28:14.413]     }
[08:28:14.413]     ...future.result$conditions <- ...future.conditions
[08:28:14.413]     ...future.result$finished <- base::Sys.time()
[08:28:14.413]     ...future.result
[08:28:14.413] }
[08:28:14.415] assign_globals() ...
[08:28:14.415] List of 1
[08:28:14.415]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a109d628b0> 
[08:28:14.415]  - attr(*, "where")=List of 1
[08:28:14.415]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.415]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.415]  - attr(*, "resolved")= logi TRUE
[08:28:14.415]  - attr(*, "total_size")= num 3555
[08:28:14.415]  - attr(*, "already-done")= logi TRUE
[08:28:14.417] - copied ‘a’ to environment
[08:28:14.417] assign_globals() ... done
[08:28:14.418] plan(): Setting new future strategy stack:
[08:28:14.418] List of future strategies:
[08:28:14.418] 1. sequential:
[08:28:14.418]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.418]    - tweaked: FALSE
[08:28:14.418]    - call: NULL
[08:28:14.418] plan(): nbrOfWorkers() = 1
[08:28:14.419] plan(): Setting new future strategy stack:
[08:28:14.419] List of future strategies:
[08:28:14.419] 1. sequential:
[08:28:14.419]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.419]    - tweaked: FALSE
[08:28:14.419]    - call: plan(strategy)
[08:28:14.419] plan(): nbrOfWorkers() = 1
[08:28:14.419] SequentialFuture started (and completed)
[08:28:14.420] - Launch lazy future ... done
[08:28:14.420] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.420] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.420] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.421] 
[08:28:14.421] Searching for globals ... DONE
[08:28:14.421] - globals: [0] <none>
[08:28:14.421] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.421] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.421] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.422] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.422] Searching for globals ... DONE
[08:28:14.422] Resolving globals: TRUE
[08:28:14.422] Resolving any globals that are futures ...
[08:28:14.423] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.423] Resolving any globals that are futures ... DONE
[08:28:14.423] Resolving futures part of globals (recursively) ...
[08:28:14.423] resolve() on list ...
[08:28:14.423]  recursive: 99
[08:28:14.423]  length: 1
[08:28:14.423]  elements: ‘a’
[08:28:14.423] run() for ‘Future’ ...
[08:28:14.424] - state: ‘created’
[08:28:14.424] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.424] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.424] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.424]   - Field: ‘label’
[08:28:14.424]   - Field: ‘local’
[08:28:14.424]   - Field: ‘owner’
[08:28:14.424]   - Field: ‘envir’
[08:28:14.424]   - Field: ‘packages’
[08:28:14.424]   - Field: ‘gc’
[08:28:14.425]   - Field: ‘conditions’
[08:28:14.425]   - Field: ‘expr’
[08:28:14.425]   - Field: ‘uuid’
[08:28:14.425]   - Field: ‘seed’
[08:28:14.425]   - Field: ‘version’
[08:28:14.425]   - Field: ‘result’
[08:28:14.426]   - Field: ‘asynchronous’
[08:28:14.426]   - Field: ‘calls’
[08:28:14.426]   - Field: ‘globals’
[08:28:14.426]   - Field: ‘stdout’
[08:28:14.426]   - Field: ‘earlySignal’
[08:28:14.427]   - Field: ‘lazy’
[08:28:14.427]   - Field: ‘state’
[08:28:14.427] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.427] - Launch lazy future ...
[08:28:14.427] Packages needed by the future expression (n = 0): <none>
[08:28:14.427] Packages needed by future strategies (n = 0): <none>
[08:28:14.427] {
[08:28:14.427]     {
[08:28:14.427]         {
[08:28:14.427]             ...future.startTime <- base::Sys.time()
[08:28:14.427]             {
[08:28:14.427]                 {
[08:28:14.427]                   {
[08:28:14.427]                     base::local({
[08:28:14.427]                       has_future <- base::requireNamespace("future", 
[08:28:14.427]                         quietly = TRUE)
[08:28:14.427]                       if (has_future) {
[08:28:14.427]                         ns <- base::getNamespace("future")
[08:28:14.427]                         version <- ns[[".package"]][["version"]]
[08:28:14.427]                         if (is.null(version)) 
[08:28:14.427]                           version <- utils::packageVersion("future")
[08:28:14.427]                       }
[08:28:14.427]                       else {
[08:28:14.427]                         version <- NULL
[08:28:14.427]                       }
[08:28:14.427]                       if (!has_future || version < "1.8.0") {
[08:28:14.427]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.427]                           "", base::R.version$version.string), 
[08:28:14.427]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.427]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.427]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.427]                             "release", "version")], collapse = " "), 
[08:28:14.427]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.427]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.427]                           info)
[08:28:14.427]                         info <- base::paste(info, collapse = "; ")
[08:28:14.427]                         if (!has_future) {
[08:28:14.427]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.427]                             info)
[08:28:14.427]                         }
[08:28:14.427]                         else {
[08:28:14.427]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.427]                             info, version)
[08:28:14.427]                         }
[08:28:14.427]                         base::stop(msg)
[08:28:14.427]                       }
[08:28:14.427]                     })
[08:28:14.427]                   }
[08:28:14.427]                   ...future.strategy.old <- future::plan("list")
[08:28:14.427]                   options(future.plan = NULL)
[08:28:14.427]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.427]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.427]                 }
[08:28:14.427]                 ...future.workdir <- getwd()
[08:28:14.427]             }
[08:28:14.427]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.427]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.427]         }
[08:28:14.427]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.427]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.427]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.427]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.427]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.427]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.427]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.427]             base::names(...future.oldOptions))
[08:28:14.427]     }
[08:28:14.427]     if (FALSE) {
[08:28:14.427]     }
[08:28:14.427]     else {
[08:28:14.427]         if (TRUE) {
[08:28:14.427]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.427]                 open = "w")
[08:28:14.427]         }
[08:28:14.427]         else {
[08:28:14.427]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.427]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.427]         }
[08:28:14.427]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.427]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.427]             base::sink(type = "output", split = FALSE)
[08:28:14.427]             base::close(...future.stdout)
[08:28:14.427]         }, add = TRUE)
[08:28:14.427]     }
[08:28:14.427]     ...future.frame <- base::sys.nframe()
[08:28:14.427]     ...future.conditions <- base::list()
[08:28:14.427]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.427]     if (FALSE) {
[08:28:14.427]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.427]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.427]     }
[08:28:14.427]     ...future.result <- base::tryCatch({
[08:28:14.427]         base::withCallingHandlers({
[08:28:14.427]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.427]             future::FutureResult(value = ...future.value$value, 
[08:28:14.427]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.427]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.427]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.427]                     ...future.globalenv.names))
[08:28:14.427]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.427]         }, condition = base::local({
[08:28:14.427]             c <- base::c
[08:28:14.427]             inherits <- base::inherits
[08:28:14.427]             invokeRestart <- base::invokeRestart
[08:28:14.427]             length <- base::length
[08:28:14.427]             list <- base::list
[08:28:14.427]             seq.int <- base::seq.int
[08:28:14.427]             signalCondition <- base::signalCondition
[08:28:14.427]             sys.calls <- base::sys.calls
[08:28:14.427]             `[[` <- base::`[[`
[08:28:14.427]             `+` <- base::`+`
[08:28:14.427]             `<<-` <- base::`<<-`
[08:28:14.427]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.427]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.427]                   3L)]
[08:28:14.427]             }
[08:28:14.427]             function(cond) {
[08:28:14.427]                 is_error <- inherits(cond, "error")
[08:28:14.427]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.427]                   NULL)
[08:28:14.427]                 if (is_error) {
[08:28:14.427]                   sessionInformation <- function() {
[08:28:14.427]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.427]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.427]                       search = base::search(), system = base::Sys.info())
[08:28:14.427]                   }
[08:28:14.427]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.427]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.427]                     cond$call), session = sessionInformation(), 
[08:28:14.427]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.427]                   signalCondition(cond)
[08:28:14.427]                 }
[08:28:14.427]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.427]                 "immediateCondition"))) {
[08:28:14.427]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.427]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.427]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.427]                   if (TRUE && !signal) {
[08:28:14.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.427]                     {
[08:28:14.427]                       inherits <- base::inherits
[08:28:14.427]                       invokeRestart <- base::invokeRestart
[08:28:14.427]                       is.null <- base::is.null
[08:28:14.427]                       muffled <- FALSE
[08:28:14.427]                       if (inherits(cond, "message")) {
[08:28:14.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.427]                         if (muffled) 
[08:28:14.427]                           invokeRestart("muffleMessage")
[08:28:14.427]                       }
[08:28:14.427]                       else if (inherits(cond, "warning")) {
[08:28:14.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.427]                         if (muffled) 
[08:28:14.427]                           invokeRestart("muffleWarning")
[08:28:14.427]                       }
[08:28:14.427]                       else if (inherits(cond, "condition")) {
[08:28:14.427]                         if (!is.null(pattern)) {
[08:28:14.427]                           computeRestarts <- base::computeRestarts
[08:28:14.427]                           grepl <- base::grepl
[08:28:14.427]                           restarts <- computeRestarts(cond)
[08:28:14.427]                           for (restart in restarts) {
[08:28:14.427]                             name <- restart$name
[08:28:14.427]                             if (is.null(name)) 
[08:28:14.427]                               next
[08:28:14.427]                             if (!grepl(pattern, name)) 
[08:28:14.427]                               next
[08:28:14.427]                             invokeRestart(restart)
[08:28:14.427]                             muffled <- TRUE
[08:28:14.427]                             break
[08:28:14.427]                           }
[08:28:14.427]                         }
[08:28:14.427]                       }
[08:28:14.427]                       invisible(muffled)
[08:28:14.427]                     }
[08:28:14.427]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.427]                   }
[08:28:14.427]                 }
[08:28:14.427]                 else {
[08:28:14.427]                   if (TRUE) {
[08:28:14.427]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.427]                     {
[08:28:14.427]                       inherits <- base::inherits
[08:28:14.427]                       invokeRestart <- base::invokeRestart
[08:28:14.427]                       is.null <- base::is.null
[08:28:14.427]                       muffled <- FALSE
[08:28:14.427]                       if (inherits(cond, "message")) {
[08:28:14.427]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.427]                         if (muffled) 
[08:28:14.427]                           invokeRestart("muffleMessage")
[08:28:14.427]                       }
[08:28:14.427]                       else if (inherits(cond, "warning")) {
[08:28:14.427]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.427]                         if (muffled) 
[08:28:14.427]                           invokeRestart("muffleWarning")
[08:28:14.427]                       }
[08:28:14.427]                       else if (inherits(cond, "condition")) {
[08:28:14.427]                         if (!is.null(pattern)) {
[08:28:14.427]                           computeRestarts <- base::computeRestarts
[08:28:14.427]                           grepl <- base::grepl
[08:28:14.427]                           restarts <- computeRestarts(cond)
[08:28:14.427]                           for (restart in restarts) {
[08:28:14.427]                             name <- restart$name
[08:28:14.427]                             if (is.null(name)) 
[08:28:14.427]                               next
[08:28:14.427]                             if (!grepl(pattern, name)) 
[08:28:14.427]                               next
[08:28:14.427]                             invokeRestart(restart)
[08:28:14.427]                             muffled <- TRUE
[08:28:14.427]                             break
[08:28:14.427]                           }
[08:28:14.427]                         }
[08:28:14.427]                       }
[08:28:14.427]                       invisible(muffled)
[08:28:14.427]                     }
[08:28:14.427]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.427]                   }
[08:28:14.427]                 }
[08:28:14.427]             }
[08:28:14.427]         }))
[08:28:14.427]     }, error = function(ex) {
[08:28:14.427]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.427]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.427]                 ...future.rng), started = ...future.startTime, 
[08:28:14.427]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.427]             version = "1.8"), class = "FutureResult")
[08:28:14.427]     }, finally = {
[08:28:14.427]         if (!identical(...future.workdir, getwd())) 
[08:28:14.427]             setwd(...future.workdir)
[08:28:14.427]         {
[08:28:14.427]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.427]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.427]             }
[08:28:14.427]             base::options(...future.oldOptions)
[08:28:14.427]             if (.Platform$OS.type == "windows") {
[08:28:14.427]                 old_names <- names(...future.oldEnvVars)
[08:28:14.427]                 envs <- base::Sys.getenv()
[08:28:14.427]                 names <- names(envs)
[08:28:14.427]                 common <- intersect(names, old_names)
[08:28:14.427]                 added <- setdiff(names, old_names)
[08:28:14.427]                 removed <- setdiff(old_names, names)
[08:28:14.427]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.427]                   envs[common]]
[08:28:14.427]                 NAMES <- toupper(changed)
[08:28:14.427]                 args <- list()
[08:28:14.427]                 for (kk in seq_along(NAMES)) {
[08:28:14.427]                   name <- changed[[kk]]
[08:28:14.427]                   NAME <- NAMES[[kk]]
[08:28:14.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.427]                     next
[08:28:14.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.427]                 }
[08:28:14.427]                 NAMES <- toupper(added)
[08:28:14.427]                 for (kk in seq_along(NAMES)) {
[08:28:14.427]                   name <- added[[kk]]
[08:28:14.427]                   NAME <- NAMES[[kk]]
[08:28:14.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.427]                     next
[08:28:14.427]                   args[[name]] <- ""
[08:28:14.427]                 }
[08:28:14.427]                 NAMES <- toupper(removed)
[08:28:14.427]                 for (kk in seq_along(NAMES)) {
[08:28:14.427]                   name <- removed[[kk]]
[08:28:14.427]                   NAME <- NAMES[[kk]]
[08:28:14.427]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.427]                     next
[08:28:14.427]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.427]                 }
[08:28:14.427]                 if (length(args) > 0) 
[08:28:14.427]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.427]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.427]             }
[08:28:14.427]             else {
[08:28:14.427]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.427]             }
[08:28:14.427]             {
[08:28:14.427]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.427]                   0L) {
[08:28:14.427]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.427]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.427]                   base::options(opts)
[08:28:14.427]                 }
[08:28:14.427]                 {
[08:28:14.427]                   {
[08:28:14.427]                     NULL
[08:28:14.427]                     RNGkind("Mersenne-Twister")
[08:28:14.427]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.427]                       inherits = FALSE)
[08:28:14.427]                   }
[08:28:14.427]                   options(future.plan = NULL)
[08:28:14.427]                   if (is.na(NA_character_)) 
[08:28:14.427]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.427]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.427]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.427]                     .init = FALSE)
[08:28:14.427]                 }
[08:28:14.427]             }
[08:28:14.427]         }
[08:28:14.427]     })
[08:28:14.427]     if (TRUE) {
[08:28:14.427]         base::sink(type = "output", split = FALSE)
[08:28:14.427]         if (TRUE) {
[08:28:14.427]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.427]         }
[08:28:14.427]         else {
[08:28:14.427]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.427]         }
[08:28:14.427]         base::close(...future.stdout)
[08:28:14.427]         ...future.stdout <- NULL
[08:28:14.427]     }
[08:28:14.427]     ...future.result$conditions <- ...future.conditions
[08:28:14.427]     ...future.result$finished <- base::Sys.time()
[08:28:14.427]     ...future.result
[08:28:14.427] }
[08:28:14.429] plan(): Setting new future strategy stack:
[08:28:14.429] List of future strategies:
[08:28:14.429] 1. sequential:
[08:28:14.429]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.429]    - tweaked: FALSE
[08:28:14.429]    - call: NULL
[08:28:14.430] plan(): nbrOfWorkers() = 1
[08:28:14.430] plan(): Setting new future strategy stack:
[08:28:14.430] List of future strategies:
[08:28:14.430] 1. sequential:
[08:28:14.430]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.430]    - tweaked: FALSE
[08:28:14.430]    - call: plan(strategy)
[08:28:14.431] plan(): nbrOfWorkers() = 1
[08:28:14.431] SequentialFuture started (and completed)
[08:28:14.431] - Launch lazy future ... done
[08:28:14.431] run() for ‘SequentialFuture’ ... done
[08:28:14.431] resolved() for ‘SequentialFuture’ ...
[08:28:14.431] - state: ‘finished’
[08:28:14.431] - run: TRUE
[08:28:14.432] - result: ‘FutureResult’
[08:28:14.432] resolved() for ‘SequentialFuture’ ... done
[08:28:14.432] Future #1
[08:28:14.432] resolved() for ‘SequentialFuture’ ...
[08:28:14.432] - state: ‘finished’
[08:28:14.432] - run: TRUE
[08:28:14.432] - result: ‘FutureResult’
[08:28:14.432] resolved() for ‘SequentialFuture’ ... done
[08:28:14.432] A SequentialFuture was resolved
[08:28:14.432]  length: 0 (resolved future 1)
[08:28:14.432] resolve() on list ... DONE
[08:28:14.433] - globals: [1] ‘a’
[08:28:14.433] Resolving futures part of globals (recursively) ... DONE
[08:28:14.433] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[08:28:14.433] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[08:28:14.433] - globals: [1] ‘a’
[08:28:14.433] - packages: [1] ‘future’
[08:28:14.433] getGlobalsAndPackages() ... DONE
[08:28:14.434] run() for ‘Future’ ...
[08:28:14.434] - state: ‘created’
[08:28:14.434] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.434] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.434] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.434]   - Field: ‘label’
[08:28:14.434]   - Field: ‘local’
[08:28:14.434]   - Field: ‘owner’
[08:28:14.435]   - Field: ‘envir’
[08:28:14.435]   - Field: ‘packages’
[08:28:14.435]   - Field: ‘gc’
[08:28:14.435]   - Field: ‘conditions’
[08:28:14.435]   - Field: ‘expr’
[08:28:14.435]   - Field: ‘uuid’
[08:28:14.435]   - Field: ‘seed’
[08:28:14.435]   - Field: ‘version’
[08:28:14.435]   - Field: ‘result’
[08:28:14.435]   - Field: ‘asynchronous’
[08:28:14.435]   - Field: ‘calls’
[08:28:14.435]   - Field: ‘globals’
[08:28:14.435]   - Field: ‘stdout’
[08:28:14.436]   - Field: ‘earlySignal’
[08:28:14.436]   - Field: ‘lazy’
[08:28:14.436]   - Field: ‘state’
[08:28:14.436] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.436] - Launch lazy future ...
[08:28:14.436] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.436] Packages needed by future strategies (n = 0): <none>
[08:28:14.437] {
[08:28:14.437]     {
[08:28:14.437]         {
[08:28:14.437]             ...future.startTime <- base::Sys.time()
[08:28:14.437]             {
[08:28:14.437]                 {
[08:28:14.437]                   {
[08:28:14.437]                     {
[08:28:14.437]                       base::local({
[08:28:14.437]                         has_future <- base::requireNamespace("future", 
[08:28:14.437]                           quietly = TRUE)
[08:28:14.437]                         if (has_future) {
[08:28:14.437]                           ns <- base::getNamespace("future")
[08:28:14.437]                           version <- ns[[".package"]][["version"]]
[08:28:14.437]                           if (is.null(version)) 
[08:28:14.437]                             version <- utils::packageVersion("future")
[08:28:14.437]                         }
[08:28:14.437]                         else {
[08:28:14.437]                           version <- NULL
[08:28:14.437]                         }
[08:28:14.437]                         if (!has_future || version < "1.8.0") {
[08:28:14.437]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.437]                             "", base::R.version$version.string), 
[08:28:14.437]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.437]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.437]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.437]                               "release", "version")], collapse = " "), 
[08:28:14.437]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.437]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.437]                             info)
[08:28:14.437]                           info <- base::paste(info, collapse = "; ")
[08:28:14.437]                           if (!has_future) {
[08:28:14.437]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.437]                               info)
[08:28:14.437]                           }
[08:28:14.437]                           else {
[08:28:14.437]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.437]                               info, version)
[08:28:14.437]                           }
[08:28:14.437]                           base::stop(msg)
[08:28:14.437]                         }
[08:28:14.437]                       })
[08:28:14.437]                     }
[08:28:14.437]                     base::local({
[08:28:14.437]                       for (pkg in "future") {
[08:28:14.437]                         base::loadNamespace(pkg)
[08:28:14.437]                         base::library(pkg, character.only = TRUE)
[08:28:14.437]                       }
[08:28:14.437]                     })
[08:28:14.437]                   }
[08:28:14.437]                   ...future.strategy.old <- future::plan("list")
[08:28:14.437]                   options(future.plan = NULL)
[08:28:14.437]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.437]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.437]                 }
[08:28:14.437]                 ...future.workdir <- getwd()
[08:28:14.437]             }
[08:28:14.437]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.437]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.437]         }
[08:28:14.437]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.437]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.437]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.437]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.437]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.437]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.437]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.437]             base::names(...future.oldOptions))
[08:28:14.437]     }
[08:28:14.437]     if (FALSE) {
[08:28:14.437]     }
[08:28:14.437]     else {
[08:28:14.437]         if (TRUE) {
[08:28:14.437]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.437]                 open = "w")
[08:28:14.437]         }
[08:28:14.437]         else {
[08:28:14.437]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.437]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.437]         }
[08:28:14.437]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.437]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.437]             base::sink(type = "output", split = FALSE)
[08:28:14.437]             base::close(...future.stdout)
[08:28:14.437]         }, add = TRUE)
[08:28:14.437]     }
[08:28:14.437]     ...future.frame <- base::sys.nframe()
[08:28:14.437]     ...future.conditions <- base::list()
[08:28:14.437]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.437]     if (FALSE) {
[08:28:14.437]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.437]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.437]     }
[08:28:14.437]     ...future.result <- base::tryCatch({
[08:28:14.437]         base::withCallingHandlers({
[08:28:14.437]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.437]                 1))
[08:28:14.437]             future::FutureResult(value = ...future.value$value, 
[08:28:14.437]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.437]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.437]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.437]                     ...future.globalenv.names))
[08:28:14.437]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.437]         }, condition = base::local({
[08:28:14.437]             c <- base::c
[08:28:14.437]             inherits <- base::inherits
[08:28:14.437]             invokeRestart <- base::invokeRestart
[08:28:14.437]             length <- base::length
[08:28:14.437]             list <- base::list
[08:28:14.437]             seq.int <- base::seq.int
[08:28:14.437]             signalCondition <- base::signalCondition
[08:28:14.437]             sys.calls <- base::sys.calls
[08:28:14.437]             `[[` <- base::`[[`
[08:28:14.437]             `+` <- base::`+`
[08:28:14.437]             `<<-` <- base::`<<-`
[08:28:14.437]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.437]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.437]                   3L)]
[08:28:14.437]             }
[08:28:14.437]             function(cond) {
[08:28:14.437]                 is_error <- inherits(cond, "error")
[08:28:14.437]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.437]                   NULL)
[08:28:14.437]                 if (is_error) {
[08:28:14.437]                   sessionInformation <- function() {
[08:28:14.437]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.437]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.437]                       search = base::search(), system = base::Sys.info())
[08:28:14.437]                   }
[08:28:14.437]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.437]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.437]                     cond$call), session = sessionInformation(), 
[08:28:14.437]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.437]                   signalCondition(cond)
[08:28:14.437]                 }
[08:28:14.437]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.437]                 "immediateCondition"))) {
[08:28:14.437]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.437]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.437]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.437]                   if (TRUE && !signal) {
[08:28:14.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.437]                     {
[08:28:14.437]                       inherits <- base::inherits
[08:28:14.437]                       invokeRestart <- base::invokeRestart
[08:28:14.437]                       is.null <- base::is.null
[08:28:14.437]                       muffled <- FALSE
[08:28:14.437]                       if (inherits(cond, "message")) {
[08:28:14.437]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.437]                         if (muffled) 
[08:28:14.437]                           invokeRestart("muffleMessage")
[08:28:14.437]                       }
[08:28:14.437]                       else if (inherits(cond, "warning")) {
[08:28:14.437]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.437]                         if (muffled) 
[08:28:14.437]                           invokeRestart("muffleWarning")
[08:28:14.437]                       }
[08:28:14.437]                       else if (inherits(cond, "condition")) {
[08:28:14.437]                         if (!is.null(pattern)) {
[08:28:14.437]                           computeRestarts <- base::computeRestarts
[08:28:14.437]                           grepl <- base::grepl
[08:28:14.437]                           restarts <- computeRestarts(cond)
[08:28:14.437]                           for (restart in restarts) {
[08:28:14.437]                             name <- restart$name
[08:28:14.437]                             if (is.null(name)) 
[08:28:14.437]                               next
[08:28:14.437]                             if (!grepl(pattern, name)) 
[08:28:14.437]                               next
[08:28:14.437]                             invokeRestart(restart)
[08:28:14.437]                             muffled <- TRUE
[08:28:14.437]                             break
[08:28:14.437]                           }
[08:28:14.437]                         }
[08:28:14.437]                       }
[08:28:14.437]                       invisible(muffled)
[08:28:14.437]                     }
[08:28:14.437]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.437]                   }
[08:28:14.437]                 }
[08:28:14.437]                 else {
[08:28:14.437]                   if (TRUE) {
[08:28:14.437]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.437]                     {
[08:28:14.437]                       inherits <- base::inherits
[08:28:14.437]                       invokeRestart <- base::invokeRestart
[08:28:14.437]                       is.null <- base::is.null
[08:28:14.437]                       muffled <- FALSE
[08:28:14.437]                       if (inherits(cond, "message")) {
[08:28:14.437]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.437]                         if (muffled) 
[08:28:14.437]                           invokeRestart("muffleMessage")
[08:28:14.437]                       }
[08:28:14.437]                       else if (inherits(cond, "warning")) {
[08:28:14.437]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.437]                         if (muffled) 
[08:28:14.437]                           invokeRestart("muffleWarning")
[08:28:14.437]                       }
[08:28:14.437]                       else if (inherits(cond, "condition")) {
[08:28:14.437]                         if (!is.null(pattern)) {
[08:28:14.437]                           computeRestarts <- base::computeRestarts
[08:28:14.437]                           grepl <- base::grepl
[08:28:14.437]                           restarts <- computeRestarts(cond)
[08:28:14.437]                           for (restart in restarts) {
[08:28:14.437]                             name <- restart$name
[08:28:14.437]                             if (is.null(name)) 
[08:28:14.437]                               next
[08:28:14.437]                             if (!grepl(pattern, name)) 
[08:28:14.437]                               next
[08:28:14.437]                             invokeRestart(restart)
[08:28:14.437]                             muffled <- TRUE
[08:28:14.437]                             break
[08:28:14.437]                           }
[08:28:14.437]                         }
[08:28:14.437]                       }
[08:28:14.437]                       invisible(muffled)
[08:28:14.437]                     }
[08:28:14.437]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.437]                   }
[08:28:14.437]                 }
[08:28:14.437]             }
[08:28:14.437]         }))
[08:28:14.437]     }, error = function(ex) {
[08:28:14.437]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.437]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.437]                 ...future.rng), started = ...future.startTime, 
[08:28:14.437]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.437]             version = "1.8"), class = "FutureResult")
[08:28:14.437]     }, finally = {
[08:28:14.437]         if (!identical(...future.workdir, getwd())) 
[08:28:14.437]             setwd(...future.workdir)
[08:28:14.437]         {
[08:28:14.437]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.437]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.437]             }
[08:28:14.437]             base::options(...future.oldOptions)
[08:28:14.437]             if (.Platform$OS.type == "windows") {
[08:28:14.437]                 old_names <- names(...future.oldEnvVars)
[08:28:14.437]                 envs <- base::Sys.getenv()
[08:28:14.437]                 names <- names(envs)
[08:28:14.437]                 common <- intersect(names, old_names)
[08:28:14.437]                 added <- setdiff(names, old_names)
[08:28:14.437]                 removed <- setdiff(old_names, names)
[08:28:14.437]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.437]                   envs[common]]
[08:28:14.437]                 NAMES <- toupper(changed)
[08:28:14.437]                 args <- list()
[08:28:14.437]                 for (kk in seq_along(NAMES)) {
[08:28:14.437]                   name <- changed[[kk]]
[08:28:14.437]                   NAME <- NAMES[[kk]]
[08:28:14.437]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.437]                     next
[08:28:14.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.437]                 }
[08:28:14.437]                 NAMES <- toupper(added)
[08:28:14.437]                 for (kk in seq_along(NAMES)) {
[08:28:14.437]                   name <- added[[kk]]
[08:28:14.437]                   NAME <- NAMES[[kk]]
[08:28:14.437]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.437]                     next
[08:28:14.437]                   args[[name]] <- ""
[08:28:14.437]                 }
[08:28:14.437]                 NAMES <- toupper(removed)
[08:28:14.437]                 for (kk in seq_along(NAMES)) {
[08:28:14.437]                   name <- removed[[kk]]
[08:28:14.437]                   NAME <- NAMES[[kk]]
[08:28:14.437]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.437]                     next
[08:28:14.437]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.437]                 }
[08:28:14.437]                 if (length(args) > 0) 
[08:28:14.437]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.437]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.437]             }
[08:28:14.437]             else {
[08:28:14.437]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.437]             }
[08:28:14.437]             {
[08:28:14.437]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.437]                   0L) {
[08:28:14.437]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.437]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.437]                   base::options(opts)
[08:28:14.437]                 }
[08:28:14.437]                 {
[08:28:14.437]                   {
[08:28:14.437]                     NULL
[08:28:14.437]                     RNGkind("Mersenne-Twister")
[08:28:14.437]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.437]                       inherits = FALSE)
[08:28:14.437]                   }
[08:28:14.437]                   options(future.plan = NULL)
[08:28:14.437]                   if (is.na(NA_character_)) 
[08:28:14.437]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.437]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.437]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.437]                     .init = FALSE)
[08:28:14.437]                 }
[08:28:14.437]             }
[08:28:14.437]         }
[08:28:14.437]     })
[08:28:14.437]     if (TRUE) {
[08:28:14.437]         base::sink(type = "output", split = FALSE)
[08:28:14.437]         if (TRUE) {
[08:28:14.437]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.437]         }
[08:28:14.437]         else {
[08:28:14.437]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.437]         }
[08:28:14.437]         base::close(...future.stdout)
[08:28:14.437]         ...future.stdout <- NULL
[08:28:14.437]     }
[08:28:14.437]     ...future.result$conditions <- ...future.conditions
[08:28:14.437]     ...future.result$finished <- base::Sys.time()
[08:28:14.437]     ...future.result
[08:28:14.437] }
[08:28:14.438] assign_globals() ...
[08:28:14.438] List of 1
[08:28:14.438]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a109b38e50> 
[08:28:14.438]  - attr(*, "where")=List of 1
[08:28:14.438]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.438]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.438]  - attr(*, "resolved")= logi TRUE
[08:28:14.438]  - attr(*, "total_size")= num 3555
[08:28:14.438]  - attr(*, "already-done")= logi TRUE
[08:28:14.440] - copied ‘a’ to environment
[08:28:14.441] assign_globals() ... done
[08:28:14.441] plan(): Setting new future strategy stack:
[08:28:14.441] List of future strategies:
[08:28:14.441] 1. sequential:
[08:28:14.441]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.441]    - tweaked: FALSE
[08:28:14.441]    - call: NULL
[08:28:14.441] plan(): nbrOfWorkers() = 1
[08:28:14.442] plan(): Setting new future strategy stack:
[08:28:14.442] List of future strategies:
[08:28:14.442] 1. sequential:
[08:28:14.442]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.442]    - tweaked: FALSE
[08:28:14.442]    - call: plan(strategy)
[08:28:14.443] plan(): nbrOfWorkers() = 1
[08:28:14.443] SequentialFuture started (and completed)
[08:28:14.443] - Launch lazy future ... done
[08:28:14.443] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.443] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.444] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.444] - globals found: [2] ‘{’, ‘pkg’
[08:28:14.444] Searching for globals ... DONE
[08:28:14.444] Resolving globals: TRUE
[08:28:14.445] Resolving any globals that are futures ...
[08:28:14.445] - globals: [2] ‘{’, ‘pkg’
[08:28:14.445] Resolving any globals that are futures ... DONE
[08:28:14.445] Resolving futures part of globals (recursively) ...
[08:28:14.445] resolve() on list ...
[08:28:14.445]  recursive: 99
[08:28:14.445]  length: 1
[08:28:14.445]  elements: ‘pkg’
[08:28:14.446]  length: 0 (resolved future 1)
[08:28:14.446] resolve() on list ... DONE
[08:28:14.446] - globals: [1] ‘pkg’
[08:28:14.446] Resolving futures part of globals (recursively) ... DONE
[08:28:14.446] The total size of the 1 globals is 42 bytes (42 bytes)
[08:28:14.446] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[08:28:14.446] - globals: [1] ‘pkg’
[08:28:14.446] 
[08:28:14.446] getGlobalsAndPackages() ... DONE
[08:28:14.447] Packages needed by the future expression (n = 0): <none>
[08:28:14.447] Packages needed by future strategies (n = 0): <none>
[08:28:14.447] {
[08:28:14.447]     {
[08:28:14.447]         {
[08:28:14.447]             ...future.startTime <- base::Sys.time()
[08:28:14.447]             {
[08:28:14.447]                 {
[08:28:14.447]                   {
[08:28:14.447]                     base::local({
[08:28:14.447]                       has_future <- base::requireNamespace("future", 
[08:28:14.447]                         quietly = TRUE)
[08:28:14.447]                       if (has_future) {
[08:28:14.447]                         ns <- base::getNamespace("future")
[08:28:14.447]                         version <- ns[[".package"]][["version"]]
[08:28:14.447]                         if (is.null(version)) 
[08:28:14.447]                           version <- utils::packageVersion("future")
[08:28:14.447]                       }
[08:28:14.447]                       else {
[08:28:14.447]                         version <- NULL
[08:28:14.447]                       }
[08:28:14.447]                       if (!has_future || version < "1.8.0") {
[08:28:14.447]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.447]                           "", base::R.version$version.string), 
[08:28:14.447]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.447]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.447]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.447]                             "release", "version")], collapse = " "), 
[08:28:14.447]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.447]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.447]                           info)
[08:28:14.447]                         info <- base::paste(info, collapse = "; ")
[08:28:14.447]                         if (!has_future) {
[08:28:14.447]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.447]                             info)
[08:28:14.447]                         }
[08:28:14.447]                         else {
[08:28:14.447]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.447]                             info, version)
[08:28:14.447]                         }
[08:28:14.447]                         base::stop(msg)
[08:28:14.447]                       }
[08:28:14.447]                     })
[08:28:14.447]                   }
[08:28:14.447]                   ...future.strategy.old <- future::plan("list")
[08:28:14.447]                   options(future.plan = NULL)
[08:28:14.447]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.447]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.447]                 }
[08:28:14.447]                 ...future.workdir <- getwd()
[08:28:14.447]             }
[08:28:14.447]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.447]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.447]         }
[08:28:14.447]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.447]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.447]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.447]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.447]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.447]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.447]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.447]             base::names(...future.oldOptions))
[08:28:14.447]     }
[08:28:14.447]     if (FALSE) {
[08:28:14.447]     }
[08:28:14.447]     else {
[08:28:14.447]         if (TRUE) {
[08:28:14.447]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.447]                 open = "w")
[08:28:14.447]         }
[08:28:14.447]         else {
[08:28:14.447]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.447]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.447]         }
[08:28:14.447]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.447]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.447]             base::sink(type = "output", split = FALSE)
[08:28:14.447]             base::close(...future.stdout)
[08:28:14.447]         }, add = TRUE)
[08:28:14.447]     }
[08:28:14.447]     ...future.frame <- base::sys.nframe()
[08:28:14.447]     ...future.conditions <- base::list()
[08:28:14.447]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.447]     if (FALSE) {
[08:28:14.447]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.447]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.447]     }
[08:28:14.447]     ...future.result <- base::tryCatch({
[08:28:14.447]         base::withCallingHandlers({
[08:28:14.447]             ...future.value <- base::withVisible(base::local({
[08:28:14.447]                 pkg
[08:28:14.447]             }))
[08:28:14.447]             future::FutureResult(value = ...future.value$value, 
[08:28:14.447]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.447]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.447]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.447]                     ...future.globalenv.names))
[08:28:14.447]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.447]         }, condition = base::local({
[08:28:14.447]             c <- base::c
[08:28:14.447]             inherits <- base::inherits
[08:28:14.447]             invokeRestart <- base::invokeRestart
[08:28:14.447]             length <- base::length
[08:28:14.447]             list <- base::list
[08:28:14.447]             seq.int <- base::seq.int
[08:28:14.447]             signalCondition <- base::signalCondition
[08:28:14.447]             sys.calls <- base::sys.calls
[08:28:14.447]             `[[` <- base::`[[`
[08:28:14.447]             `+` <- base::`+`
[08:28:14.447]             `<<-` <- base::`<<-`
[08:28:14.447]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.447]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.447]                   3L)]
[08:28:14.447]             }
[08:28:14.447]             function(cond) {
[08:28:14.447]                 is_error <- inherits(cond, "error")
[08:28:14.447]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.447]                   NULL)
[08:28:14.447]                 if (is_error) {
[08:28:14.447]                   sessionInformation <- function() {
[08:28:14.447]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.447]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.447]                       search = base::search(), system = base::Sys.info())
[08:28:14.447]                   }
[08:28:14.447]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.447]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.447]                     cond$call), session = sessionInformation(), 
[08:28:14.447]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.447]                   signalCondition(cond)
[08:28:14.447]                 }
[08:28:14.447]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.447]                 "immediateCondition"))) {
[08:28:14.447]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.447]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.447]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.447]                   if (TRUE && !signal) {
[08:28:14.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.447]                     {
[08:28:14.447]                       inherits <- base::inherits
[08:28:14.447]                       invokeRestart <- base::invokeRestart
[08:28:14.447]                       is.null <- base::is.null
[08:28:14.447]                       muffled <- FALSE
[08:28:14.447]                       if (inherits(cond, "message")) {
[08:28:14.447]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.447]                         if (muffled) 
[08:28:14.447]                           invokeRestart("muffleMessage")
[08:28:14.447]                       }
[08:28:14.447]                       else if (inherits(cond, "warning")) {
[08:28:14.447]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.447]                         if (muffled) 
[08:28:14.447]                           invokeRestart("muffleWarning")
[08:28:14.447]                       }
[08:28:14.447]                       else if (inherits(cond, "condition")) {
[08:28:14.447]                         if (!is.null(pattern)) {
[08:28:14.447]                           computeRestarts <- base::computeRestarts
[08:28:14.447]                           grepl <- base::grepl
[08:28:14.447]                           restarts <- computeRestarts(cond)
[08:28:14.447]                           for (restart in restarts) {
[08:28:14.447]                             name <- restart$name
[08:28:14.447]                             if (is.null(name)) 
[08:28:14.447]                               next
[08:28:14.447]                             if (!grepl(pattern, name)) 
[08:28:14.447]                               next
[08:28:14.447]                             invokeRestart(restart)
[08:28:14.447]                             muffled <- TRUE
[08:28:14.447]                             break
[08:28:14.447]                           }
[08:28:14.447]                         }
[08:28:14.447]                       }
[08:28:14.447]                       invisible(muffled)
[08:28:14.447]                     }
[08:28:14.447]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.447]                   }
[08:28:14.447]                 }
[08:28:14.447]                 else {
[08:28:14.447]                   if (TRUE) {
[08:28:14.447]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.447]                     {
[08:28:14.447]                       inherits <- base::inherits
[08:28:14.447]                       invokeRestart <- base::invokeRestart
[08:28:14.447]                       is.null <- base::is.null
[08:28:14.447]                       muffled <- FALSE
[08:28:14.447]                       if (inherits(cond, "message")) {
[08:28:14.447]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.447]                         if (muffled) 
[08:28:14.447]                           invokeRestart("muffleMessage")
[08:28:14.447]                       }
[08:28:14.447]                       else if (inherits(cond, "warning")) {
[08:28:14.447]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.447]                         if (muffled) 
[08:28:14.447]                           invokeRestart("muffleWarning")
[08:28:14.447]                       }
[08:28:14.447]                       else if (inherits(cond, "condition")) {
[08:28:14.447]                         if (!is.null(pattern)) {
[08:28:14.447]                           computeRestarts <- base::computeRestarts
[08:28:14.447]                           grepl <- base::grepl
[08:28:14.447]                           restarts <- computeRestarts(cond)
[08:28:14.447]                           for (restart in restarts) {
[08:28:14.447]                             name <- restart$name
[08:28:14.447]                             if (is.null(name)) 
[08:28:14.447]                               next
[08:28:14.447]                             if (!grepl(pattern, name)) 
[08:28:14.447]                               next
[08:28:14.447]                             invokeRestart(restart)
[08:28:14.447]                             muffled <- TRUE
[08:28:14.447]                             break
[08:28:14.447]                           }
[08:28:14.447]                         }
[08:28:14.447]                       }
[08:28:14.447]                       invisible(muffled)
[08:28:14.447]                     }
[08:28:14.447]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.447]                   }
[08:28:14.447]                 }
[08:28:14.447]             }
[08:28:14.447]         }))
[08:28:14.447]     }, error = function(ex) {
[08:28:14.447]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.447]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.447]                 ...future.rng), started = ...future.startTime, 
[08:28:14.447]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.447]             version = "1.8"), class = "FutureResult")
[08:28:14.447]     }, finally = {
[08:28:14.447]         if (!identical(...future.workdir, getwd())) 
[08:28:14.447]             setwd(...future.workdir)
[08:28:14.447]         {
[08:28:14.447]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.447]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.447]             }
[08:28:14.447]             base::options(...future.oldOptions)
[08:28:14.447]             if (.Platform$OS.type == "windows") {
[08:28:14.447]                 old_names <- names(...future.oldEnvVars)
[08:28:14.447]                 envs <- base::Sys.getenv()
[08:28:14.447]                 names <- names(envs)
[08:28:14.447]                 common <- intersect(names, old_names)
[08:28:14.447]                 added <- setdiff(names, old_names)
[08:28:14.447]                 removed <- setdiff(old_names, names)
[08:28:14.447]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.447]                   envs[common]]
[08:28:14.447]                 NAMES <- toupper(changed)
[08:28:14.447]                 args <- list()
[08:28:14.447]                 for (kk in seq_along(NAMES)) {
[08:28:14.447]                   name <- changed[[kk]]
[08:28:14.447]                   NAME <- NAMES[[kk]]
[08:28:14.447]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.447]                     next
[08:28:14.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.447]                 }
[08:28:14.447]                 NAMES <- toupper(added)
[08:28:14.447]                 for (kk in seq_along(NAMES)) {
[08:28:14.447]                   name <- added[[kk]]
[08:28:14.447]                   NAME <- NAMES[[kk]]
[08:28:14.447]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.447]                     next
[08:28:14.447]                   args[[name]] <- ""
[08:28:14.447]                 }
[08:28:14.447]                 NAMES <- toupper(removed)
[08:28:14.447]                 for (kk in seq_along(NAMES)) {
[08:28:14.447]                   name <- removed[[kk]]
[08:28:14.447]                   NAME <- NAMES[[kk]]
[08:28:14.447]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.447]                     next
[08:28:14.447]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.447]                 }
[08:28:14.447]                 if (length(args) > 0) 
[08:28:14.447]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.447]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.447]             }
[08:28:14.447]             else {
[08:28:14.447]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.447]             }
[08:28:14.447]             {
[08:28:14.447]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.447]                   0L) {
[08:28:14.447]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.447]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.447]                   base::options(opts)
[08:28:14.447]                 }
[08:28:14.447]                 {
[08:28:14.447]                   {
[08:28:14.447]                     NULL
[08:28:14.447]                     RNGkind("Mersenne-Twister")
[08:28:14.447]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.447]                       inherits = FALSE)
[08:28:14.447]                   }
[08:28:14.447]                   options(future.plan = NULL)
[08:28:14.447]                   if (is.na(NA_character_)) 
[08:28:14.447]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.447]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.447]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.447]                     .init = FALSE)
[08:28:14.447]                 }
[08:28:14.447]             }
[08:28:14.447]         }
[08:28:14.447]     })
[08:28:14.447]     if (TRUE) {
[08:28:14.447]         base::sink(type = "output", split = FALSE)
[08:28:14.447]         if (TRUE) {
[08:28:14.447]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.447]         }
[08:28:14.447]         else {
[08:28:14.447]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.447]         }
[08:28:14.447]         base::close(...future.stdout)
[08:28:14.447]         ...future.stdout <- NULL
[08:28:14.447]     }
[08:28:14.447]     ...future.result$conditions <- ...future.conditions
[08:28:14.447]     ...future.result$finished <- base::Sys.time()
[08:28:14.447]     ...future.result
[08:28:14.447] }
[08:28:14.449] assign_globals() ...
[08:28:14.449] List of 1
[08:28:14.449]  $ pkg: chr "foo"
[08:28:14.449]  - attr(*, "where")=List of 1
[08:28:14.449]   ..$ pkg:<environment: R_EmptyEnv> 
[08:28:14.449]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.449]  - attr(*, "resolved")= logi TRUE
[08:28:14.449]  - attr(*, "total_size")= num 42
[08:28:14.451] - copied ‘pkg’ to environment
[08:28:14.451] assign_globals() ... done
[08:28:14.451] plan(): Setting new future strategy stack:
[08:28:14.451] List of future strategies:
[08:28:14.451] 1. sequential:
[08:28:14.451]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.451]    - tweaked: FALSE
[08:28:14.451]    - call: NULL
[08:28:14.452] plan(): nbrOfWorkers() = 1
[08:28:14.452] plan(): Setting new future strategy stack:
[08:28:14.453] List of future strategies:
[08:28:14.453] 1. sequential:
[08:28:14.453]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.453]    - tweaked: FALSE
[08:28:14.453]    - call: plan(strategy)
[08:28:14.454] plan(): nbrOfWorkers() = 1
[08:28:14.454] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.455] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.455] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.457] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:14.457] Searching for globals ... DONE
[08:28:14.457] Resolving globals: TRUE
[08:28:14.457] Resolving any globals that are futures ...
[08:28:14.457] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:14.457] Resolving any globals that are futures ... DONE
[08:28:14.458] Resolving futures part of globals (recursively) ...
[08:28:14.458] resolve() on list ...
[08:28:14.458]  recursive: 99
[08:28:14.458]  length: 1
[08:28:14.458]  elements: ‘a’
[08:28:14.458]  length: 0 (resolved future 1)
[08:28:14.458] resolve() on list ... DONE
[08:28:14.458] - globals: [1] ‘a’
[08:28:14.459] Resolving futures part of globals (recursively) ... DONE
[08:28:14.459] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:14.459] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:14.459] - globals: [1] ‘a’
[08:28:14.459] 
[08:28:14.459] getGlobalsAndPackages() ... DONE
[08:28:14.459] run() for ‘Future’ ...
[08:28:14.460] - state: ‘created’
[08:28:14.460] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.460] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.460] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.460]   - Field: ‘label’
[08:28:14.460]   - Field: ‘local’
[08:28:14.460]   - Field: ‘owner’
[08:28:14.460]   - Field: ‘envir’
[08:28:14.460]   - Field: ‘packages’
[08:28:14.461]   - Field: ‘gc’
[08:28:14.461]   - Field: ‘conditions’
[08:28:14.461]   - Field: ‘expr’
[08:28:14.461]   - Field: ‘uuid’
[08:28:14.461]   - Field: ‘seed’
[08:28:14.461]   - Field: ‘version’
[08:28:14.461]   - Field: ‘result’
[08:28:14.461]   - Field: ‘asynchronous’
[08:28:14.461]   - Field: ‘calls’
[08:28:14.461]   - Field: ‘globals’
[08:28:14.461]   - Field: ‘stdout’
[08:28:14.461]   - Field: ‘earlySignal’
[08:28:14.461]   - Field: ‘lazy’
[08:28:14.462]   - Field: ‘state’
[08:28:14.462] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.462] - Launch lazy future ...
[08:28:14.462] Packages needed by the future expression (n = 0): <none>
[08:28:14.462] Packages needed by future strategies (n = 0): <none>
[08:28:14.462] {
[08:28:14.462]     {
[08:28:14.462]         {
[08:28:14.462]             ...future.startTime <- base::Sys.time()
[08:28:14.462]             {
[08:28:14.462]                 {
[08:28:14.462]                   {
[08:28:14.462]                     base::local({
[08:28:14.462]                       has_future <- base::requireNamespace("future", 
[08:28:14.462]                         quietly = TRUE)
[08:28:14.462]                       if (has_future) {
[08:28:14.462]                         ns <- base::getNamespace("future")
[08:28:14.462]                         version <- ns[[".package"]][["version"]]
[08:28:14.462]                         if (is.null(version)) 
[08:28:14.462]                           version <- utils::packageVersion("future")
[08:28:14.462]                       }
[08:28:14.462]                       else {
[08:28:14.462]                         version <- NULL
[08:28:14.462]                       }
[08:28:14.462]                       if (!has_future || version < "1.8.0") {
[08:28:14.462]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.462]                           "", base::R.version$version.string), 
[08:28:14.462]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.462]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.462]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.462]                             "release", "version")], collapse = " "), 
[08:28:14.462]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.462]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.462]                           info)
[08:28:14.462]                         info <- base::paste(info, collapse = "; ")
[08:28:14.462]                         if (!has_future) {
[08:28:14.462]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.462]                             info)
[08:28:14.462]                         }
[08:28:14.462]                         else {
[08:28:14.462]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.462]                             info, version)
[08:28:14.462]                         }
[08:28:14.462]                         base::stop(msg)
[08:28:14.462]                       }
[08:28:14.462]                     })
[08:28:14.462]                   }
[08:28:14.462]                   ...future.strategy.old <- future::plan("list")
[08:28:14.462]                   options(future.plan = NULL)
[08:28:14.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.462]                 }
[08:28:14.462]                 ...future.workdir <- getwd()
[08:28:14.462]             }
[08:28:14.462]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.462]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.462]         }
[08:28:14.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.462]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.462]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.462]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.462]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.462]             base::names(...future.oldOptions))
[08:28:14.462]     }
[08:28:14.462]     if (FALSE) {
[08:28:14.462]     }
[08:28:14.462]     else {
[08:28:14.462]         if (TRUE) {
[08:28:14.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.462]                 open = "w")
[08:28:14.462]         }
[08:28:14.462]         else {
[08:28:14.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.462]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.462]         }
[08:28:14.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.462]             base::sink(type = "output", split = FALSE)
[08:28:14.462]             base::close(...future.stdout)
[08:28:14.462]         }, add = TRUE)
[08:28:14.462]     }
[08:28:14.462]     ...future.frame <- base::sys.nframe()
[08:28:14.462]     ...future.conditions <- base::list()
[08:28:14.462]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.462]     if (FALSE) {
[08:28:14.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.462]     }
[08:28:14.462]     ...future.result <- base::tryCatch({
[08:28:14.462]         base::withCallingHandlers({
[08:28:14.462]             ...future.value <- base::withVisible(base::local({
[08:28:14.462]                 b <- a
[08:28:14.462]                 a <- 2
[08:28:14.462]                 a * b
[08:28:14.462]             }))
[08:28:14.462]             future::FutureResult(value = ...future.value$value, 
[08:28:14.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.462]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.462]                     ...future.globalenv.names))
[08:28:14.462]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.462]         }, condition = base::local({
[08:28:14.462]             c <- base::c
[08:28:14.462]             inherits <- base::inherits
[08:28:14.462]             invokeRestart <- base::invokeRestart
[08:28:14.462]             length <- base::length
[08:28:14.462]             list <- base::list
[08:28:14.462]             seq.int <- base::seq.int
[08:28:14.462]             signalCondition <- base::signalCondition
[08:28:14.462]             sys.calls <- base::sys.calls
[08:28:14.462]             `[[` <- base::`[[`
[08:28:14.462]             `+` <- base::`+`
[08:28:14.462]             `<<-` <- base::`<<-`
[08:28:14.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.462]                   3L)]
[08:28:14.462]             }
[08:28:14.462]             function(cond) {
[08:28:14.462]                 is_error <- inherits(cond, "error")
[08:28:14.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.462]                   NULL)
[08:28:14.462]                 if (is_error) {
[08:28:14.462]                   sessionInformation <- function() {
[08:28:14.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.462]                       search = base::search(), system = base::Sys.info())
[08:28:14.462]                   }
[08:28:14.462]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.462]                     cond$call), session = sessionInformation(), 
[08:28:14.462]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.462]                   signalCondition(cond)
[08:28:14.462]                 }
[08:28:14.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.462]                 "immediateCondition"))) {
[08:28:14.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.462]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.462]                   if (TRUE && !signal) {
[08:28:14.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.462]                     {
[08:28:14.462]                       inherits <- base::inherits
[08:28:14.462]                       invokeRestart <- base::invokeRestart
[08:28:14.462]                       is.null <- base::is.null
[08:28:14.462]                       muffled <- FALSE
[08:28:14.462]                       if (inherits(cond, "message")) {
[08:28:14.462]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.462]                         if (muffled) 
[08:28:14.462]                           invokeRestart("muffleMessage")
[08:28:14.462]                       }
[08:28:14.462]                       else if (inherits(cond, "warning")) {
[08:28:14.462]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.462]                         if (muffled) 
[08:28:14.462]                           invokeRestart("muffleWarning")
[08:28:14.462]                       }
[08:28:14.462]                       else if (inherits(cond, "condition")) {
[08:28:14.462]                         if (!is.null(pattern)) {
[08:28:14.462]                           computeRestarts <- base::computeRestarts
[08:28:14.462]                           grepl <- base::grepl
[08:28:14.462]                           restarts <- computeRestarts(cond)
[08:28:14.462]                           for (restart in restarts) {
[08:28:14.462]                             name <- restart$name
[08:28:14.462]                             if (is.null(name)) 
[08:28:14.462]                               next
[08:28:14.462]                             if (!grepl(pattern, name)) 
[08:28:14.462]                               next
[08:28:14.462]                             invokeRestart(restart)
[08:28:14.462]                             muffled <- TRUE
[08:28:14.462]                             break
[08:28:14.462]                           }
[08:28:14.462]                         }
[08:28:14.462]                       }
[08:28:14.462]                       invisible(muffled)
[08:28:14.462]                     }
[08:28:14.462]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.462]                   }
[08:28:14.462]                 }
[08:28:14.462]                 else {
[08:28:14.462]                   if (TRUE) {
[08:28:14.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.462]                     {
[08:28:14.462]                       inherits <- base::inherits
[08:28:14.462]                       invokeRestart <- base::invokeRestart
[08:28:14.462]                       is.null <- base::is.null
[08:28:14.462]                       muffled <- FALSE
[08:28:14.462]                       if (inherits(cond, "message")) {
[08:28:14.462]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.462]                         if (muffled) 
[08:28:14.462]                           invokeRestart("muffleMessage")
[08:28:14.462]                       }
[08:28:14.462]                       else if (inherits(cond, "warning")) {
[08:28:14.462]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.462]                         if (muffled) 
[08:28:14.462]                           invokeRestart("muffleWarning")
[08:28:14.462]                       }
[08:28:14.462]                       else if (inherits(cond, "condition")) {
[08:28:14.462]                         if (!is.null(pattern)) {
[08:28:14.462]                           computeRestarts <- base::computeRestarts
[08:28:14.462]                           grepl <- base::grepl
[08:28:14.462]                           restarts <- computeRestarts(cond)
[08:28:14.462]                           for (restart in restarts) {
[08:28:14.462]                             name <- restart$name
[08:28:14.462]                             if (is.null(name)) 
[08:28:14.462]                               next
[08:28:14.462]                             if (!grepl(pattern, name)) 
[08:28:14.462]                               next
[08:28:14.462]                             invokeRestart(restart)
[08:28:14.462]                             muffled <- TRUE
[08:28:14.462]                             break
[08:28:14.462]                           }
[08:28:14.462]                         }
[08:28:14.462]                       }
[08:28:14.462]                       invisible(muffled)
[08:28:14.462]                     }
[08:28:14.462]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.462]                   }
[08:28:14.462]                 }
[08:28:14.462]             }
[08:28:14.462]         }))
[08:28:14.462]     }, error = function(ex) {
[08:28:14.462]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.462]                 ...future.rng), started = ...future.startTime, 
[08:28:14.462]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.462]             version = "1.8"), class = "FutureResult")
[08:28:14.462]     }, finally = {
[08:28:14.462]         if (!identical(...future.workdir, getwd())) 
[08:28:14.462]             setwd(...future.workdir)
[08:28:14.462]         {
[08:28:14.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.462]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.462]             }
[08:28:14.462]             base::options(...future.oldOptions)
[08:28:14.462]             if (.Platform$OS.type == "windows") {
[08:28:14.462]                 old_names <- names(...future.oldEnvVars)
[08:28:14.462]                 envs <- base::Sys.getenv()
[08:28:14.462]                 names <- names(envs)
[08:28:14.462]                 common <- intersect(names, old_names)
[08:28:14.462]                 added <- setdiff(names, old_names)
[08:28:14.462]                 removed <- setdiff(old_names, names)
[08:28:14.462]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.462]                   envs[common]]
[08:28:14.462]                 NAMES <- toupper(changed)
[08:28:14.462]                 args <- list()
[08:28:14.462]                 for (kk in seq_along(NAMES)) {
[08:28:14.462]                   name <- changed[[kk]]
[08:28:14.462]                   NAME <- NAMES[[kk]]
[08:28:14.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.462]                     next
[08:28:14.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.462]                 }
[08:28:14.462]                 NAMES <- toupper(added)
[08:28:14.462]                 for (kk in seq_along(NAMES)) {
[08:28:14.462]                   name <- added[[kk]]
[08:28:14.462]                   NAME <- NAMES[[kk]]
[08:28:14.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.462]                     next
[08:28:14.462]                   args[[name]] <- ""
[08:28:14.462]                 }
[08:28:14.462]                 NAMES <- toupper(removed)
[08:28:14.462]                 for (kk in seq_along(NAMES)) {
[08:28:14.462]                   name <- removed[[kk]]
[08:28:14.462]                   NAME <- NAMES[[kk]]
[08:28:14.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.462]                     next
[08:28:14.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.462]                 }
[08:28:14.462]                 if (length(args) > 0) 
[08:28:14.462]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.462]             }
[08:28:14.462]             else {
[08:28:14.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.462]             }
[08:28:14.462]             {
[08:28:14.462]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.462]                   0L) {
[08:28:14.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.462]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.462]                   base::options(opts)
[08:28:14.462]                 }
[08:28:14.462]                 {
[08:28:14.462]                   {
[08:28:14.462]                     NULL
[08:28:14.462]                     RNGkind("Mersenne-Twister")
[08:28:14.462]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.462]                       inherits = FALSE)
[08:28:14.462]                   }
[08:28:14.462]                   options(future.plan = NULL)
[08:28:14.462]                   if (is.na(NA_character_)) 
[08:28:14.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.462]                     .init = FALSE)
[08:28:14.462]                 }
[08:28:14.462]             }
[08:28:14.462]         }
[08:28:14.462]     })
[08:28:14.462]     if (TRUE) {
[08:28:14.462]         base::sink(type = "output", split = FALSE)
[08:28:14.462]         if (TRUE) {
[08:28:14.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.462]         }
[08:28:14.462]         else {
[08:28:14.462]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.462]         }
[08:28:14.462]         base::close(...future.stdout)
[08:28:14.462]         ...future.stdout <- NULL
[08:28:14.462]     }
[08:28:14.462]     ...future.result$conditions <- ...future.conditions
[08:28:14.462]     ...future.result$finished <- base::Sys.time()
[08:28:14.462]     ...future.result
[08:28:14.462] }
[08:28:14.464] assign_globals() ...
[08:28:14.464] List of 1
[08:28:14.464]  $ a: num 3
[08:28:14.464]  - attr(*, "where")=List of 1
[08:28:14.464]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.464]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.464]  - attr(*, "resolved")= logi TRUE
[08:28:14.464]  - attr(*, "total_size")= num 39
[08:28:14.464]  - attr(*, "already-done")= logi TRUE
[08:28:14.466] - copied ‘a’ to environment
[08:28:14.466] assign_globals() ... done
[08:28:14.467] plan(): Setting new future strategy stack:
[08:28:14.467] List of future strategies:
[08:28:14.467] 1. sequential:
[08:28:14.467]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.467]    - tweaked: FALSE
[08:28:14.467]    - call: NULL
[08:28:14.467] plan(): nbrOfWorkers() = 1
[08:28:14.468] plan(): Setting new future strategy stack:
[08:28:14.468] List of future strategies:
[08:28:14.468] 1. sequential:
[08:28:14.468]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.468]    - tweaked: FALSE
[08:28:14.468]    - call: plan(strategy)
[08:28:14.468] plan(): nbrOfWorkers() = 1
[08:28:14.468] SequentialFuture started (and completed)
[08:28:14.469] - Launch lazy future ... done
[08:28:14.469] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.469] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.469] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.471] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:14.471] Searching for globals ... DONE
[08:28:14.471] Resolving globals: TRUE
[08:28:14.471] Resolving any globals that are futures ...
[08:28:14.471] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:14.471] Resolving any globals that are futures ... DONE
[08:28:14.472] Resolving futures part of globals (recursively) ...
[08:28:14.472] resolve() on list ...
[08:28:14.472]  recursive: 99
[08:28:14.472]  length: 1
[08:28:14.472]  elements: ‘a’
[08:28:14.472]  length: 0 (resolved future 1)
[08:28:14.472] resolve() on list ... DONE
[08:28:14.472] - globals: [1] ‘a’
[08:28:14.472] Resolving futures part of globals (recursively) ... DONE
[08:28:14.473] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:14.473] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:14.473] - globals: [1] ‘a’
[08:28:14.473] 
[08:28:14.473] getGlobalsAndPackages() ... DONE
[08:28:14.473] run() for ‘Future’ ...
[08:28:14.473] - state: ‘created’
[08:28:14.474] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.474] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.474] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.474]   - Field: ‘label’
[08:28:14.474]   - Field: ‘local’
[08:28:14.474]   - Field: ‘owner’
[08:28:14.474]   - Field: ‘envir’
[08:28:14.474]   - Field: ‘packages’
[08:28:14.474]   - Field: ‘gc’
[08:28:14.475]   - Field: ‘conditions’
[08:28:14.475]   - Field: ‘expr’
[08:28:14.475]   - Field: ‘uuid’
[08:28:14.475]   - Field: ‘seed’
[08:28:14.475]   - Field: ‘version’
[08:28:14.475]   - Field: ‘result’
[08:28:14.475]   - Field: ‘asynchronous’
[08:28:14.475]   - Field: ‘calls’
[08:28:14.475]   - Field: ‘globals’
[08:28:14.475]   - Field: ‘stdout’
[08:28:14.475]   - Field: ‘earlySignal’
[08:28:14.475]   - Field: ‘lazy’
[08:28:14.477]   - Field: ‘state’
[08:28:14.477] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.477] - Launch lazy future ...
[08:28:14.477] Packages needed by the future expression (n = 0): <none>
[08:28:14.477] Packages needed by future strategies (n = 0): <none>
[08:28:14.477] {
[08:28:14.477]     {
[08:28:14.477]         {
[08:28:14.477]             ...future.startTime <- base::Sys.time()
[08:28:14.477]             {
[08:28:14.477]                 {
[08:28:14.477]                   {
[08:28:14.477]                     base::local({
[08:28:14.477]                       has_future <- base::requireNamespace("future", 
[08:28:14.477]                         quietly = TRUE)
[08:28:14.477]                       if (has_future) {
[08:28:14.477]                         ns <- base::getNamespace("future")
[08:28:14.477]                         version <- ns[[".package"]][["version"]]
[08:28:14.477]                         if (is.null(version)) 
[08:28:14.477]                           version <- utils::packageVersion("future")
[08:28:14.477]                       }
[08:28:14.477]                       else {
[08:28:14.477]                         version <- NULL
[08:28:14.477]                       }
[08:28:14.477]                       if (!has_future || version < "1.8.0") {
[08:28:14.477]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.477]                           "", base::R.version$version.string), 
[08:28:14.477]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.477]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.477]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.477]                             "release", "version")], collapse = " "), 
[08:28:14.477]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.477]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.477]                           info)
[08:28:14.477]                         info <- base::paste(info, collapse = "; ")
[08:28:14.477]                         if (!has_future) {
[08:28:14.477]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.477]                             info)
[08:28:14.477]                         }
[08:28:14.477]                         else {
[08:28:14.477]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.477]                             info, version)
[08:28:14.477]                         }
[08:28:14.477]                         base::stop(msg)
[08:28:14.477]                       }
[08:28:14.477]                     })
[08:28:14.477]                   }
[08:28:14.477]                   ...future.strategy.old <- future::plan("list")
[08:28:14.477]                   options(future.plan = NULL)
[08:28:14.477]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.477]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.477]                 }
[08:28:14.477]                 ...future.workdir <- getwd()
[08:28:14.477]             }
[08:28:14.477]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.477]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.477]         }
[08:28:14.477]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.477]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.477]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.477]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.477]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.477]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.477]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.477]             base::names(...future.oldOptions))
[08:28:14.477]     }
[08:28:14.477]     if (FALSE) {
[08:28:14.477]     }
[08:28:14.477]     else {
[08:28:14.477]         if (TRUE) {
[08:28:14.477]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.477]                 open = "w")
[08:28:14.477]         }
[08:28:14.477]         else {
[08:28:14.477]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.477]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.477]         }
[08:28:14.477]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.477]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.477]             base::sink(type = "output", split = FALSE)
[08:28:14.477]             base::close(...future.stdout)
[08:28:14.477]         }, add = TRUE)
[08:28:14.477]     }
[08:28:14.477]     ...future.frame <- base::sys.nframe()
[08:28:14.477]     ...future.conditions <- base::list()
[08:28:14.477]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.477]     if (FALSE) {
[08:28:14.477]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.477]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.477]     }
[08:28:14.477]     ...future.result <- base::tryCatch({
[08:28:14.477]         base::withCallingHandlers({
[08:28:14.477]             ...future.value <- base::withVisible(base::local({
[08:28:14.477]                 b <- a
[08:28:14.477]                 a <- 2
[08:28:14.477]                 a * b
[08:28:14.477]             }))
[08:28:14.477]             future::FutureResult(value = ...future.value$value, 
[08:28:14.477]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.477]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.477]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.477]                     ...future.globalenv.names))
[08:28:14.477]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.477]         }, condition = base::local({
[08:28:14.477]             c <- base::c
[08:28:14.477]             inherits <- base::inherits
[08:28:14.477]             invokeRestart <- base::invokeRestart
[08:28:14.477]             length <- base::length
[08:28:14.477]             list <- base::list
[08:28:14.477]             seq.int <- base::seq.int
[08:28:14.477]             signalCondition <- base::signalCondition
[08:28:14.477]             sys.calls <- base::sys.calls
[08:28:14.477]             `[[` <- base::`[[`
[08:28:14.477]             `+` <- base::`+`
[08:28:14.477]             `<<-` <- base::`<<-`
[08:28:14.477]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.477]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.477]                   3L)]
[08:28:14.477]             }
[08:28:14.477]             function(cond) {
[08:28:14.477]                 is_error <- inherits(cond, "error")
[08:28:14.477]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.477]                   NULL)
[08:28:14.477]                 if (is_error) {
[08:28:14.477]                   sessionInformation <- function() {
[08:28:14.477]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.477]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.477]                       search = base::search(), system = base::Sys.info())
[08:28:14.477]                   }
[08:28:14.477]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.477]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.477]                     cond$call), session = sessionInformation(), 
[08:28:14.477]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.477]                   signalCondition(cond)
[08:28:14.477]                 }
[08:28:14.477]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.477]                 "immediateCondition"))) {
[08:28:14.477]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.477]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.477]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.477]                   if (TRUE && !signal) {
[08:28:14.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.477]                     {
[08:28:14.477]                       inherits <- base::inherits
[08:28:14.477]                       invokeRestart <- base::invokeRestart
[08:28:14.477]                       is.null <- base::is.null
[08:28:14.477]                       muffled <- FALSE
[08:28:14.477]                       if (inherits(cond, "message")) {
[08:28:14.477]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.477]                         if (muffled) 
[08:28:14.477]                           invokeRestart("muffleMessage")
[08:28:14.477]                       }
[08:28:14.477]                       else if (inherits(cond, "warning")) {
[08:28:14.477]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.477]                         if (muffled) 
[08:28:14.477]                           invokeRestart("muffleWarning")
[08:28:14.477]                       }
[08:28:14.477]                       else if (inherits(cond, "condition")) {
[08:28:14.477]                         if (!is.null(pattern)) {
[08:28:14.477]                           computeRestarts <- base::computeRestarts
[08:28:14.477]                           grepl <- base::grepl
[08:28:14.477]                           restarts <- computeRestarts(cond)
[08:28:14.477]                           for (restart in restarts) {
[08:28:14.477]                             name <- restart$name
[08:28:14.477]                             if (is.null(name)) 
[08:28:14.477]                               next
[08:28:14.477]                             if (!grepl(pattern, name)) 
[08:28:14.477]                               next
[08:28:14.477]                             invokeRestart(restart)
[08:28:14.477]                             muffled <- TRUE
[08:28:14.477]                             break
[08:28:14.477]                           }
[08:28:14.477]                         }
[08:28:14.477]                       }
[08:28:14.477]                       invisible(muffled)
[08:28:14.477]                     }
[08:28:14.477]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.477]                   }
[08:28:14.477]                 }
[08:28:14.477]                 else {
[08:28:14.477]                   if (TRUE) {
[08:28:14.477]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.477]                     {
[08:28:14.477]                       inherits <- base::inherits
[08:28:14.477]                       invokeRestart <- base::invokeRestart
[08:28:14.477]                       is.null <- base::is.null
[08:28:14.477]                       muffled <- FALSE
[08:28:14.477]                       if (inherits(cond, "message")) {
[08:28:14.477]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.477]                         if (muffled) 
[08:28:14.477]                           invokeRestart("muffleMessage")
[08:28:14.477]                       }
[08:28:14.477]                       else if (inherits(cond, "warning")) {
[08:28:14.477]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.477]                         if (muffled) 
[08:28:14.477]                           invokeRestart("muffleWarning")
[08:28:14.477]                       }
[08:28:14.477]                       else if (inherits(cond, "condition")) {
[08:28:14.477]                         if (!is.null(pattern)) {
[08:28:14.477]                           computeRestarts <- base::computeRestarts
[08:28:14.477]                           grepl <- base::grepl
[08:28:14.477]                           restarts <- computeRestarts(cond)
[08:28:14.477]                           for (restart in restarts) {
[08:28:14.477]                             name <- restart$name
[08:28:14.477]                             if (is.null(name)) 
[08:28:14.477]                               next
[08:28:14.477]                             if (!grepl(pattern, name)) 
[08:28:14.477]                               next
[08:28:14.477]                             invokeRestart(restart)
[08:28:14.477]                             muffled <- TRUE
[08:28:14.477]                             break
[08:28:14.477]                           }
[08:28:14.477]                         }
[08:28:14.477]                       }
[08:28:14.477]                       invisible(muffled)
[08:28:14.477]                     }
[08:28:14.477]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.477]                   }
[08:28:14.477]                 }
[08:28:14.477]             }
[08:28:14.477]         }))
[08:28:14.477]     }, error = function(ex) {
[08:28:14.477]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.477]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.477]                 ...future.rng), started = ...future.startTime, 
[08:28:14.477]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.477]             version = "1.8"), class = "FutureResult")
[08:28:14.477]     }, finally = {
[08:28:14.477]         if (!identical(...future.workdir, getwd())) 
[08:28:14.477]             setwd(...future.workdir)
[08:28:14.477]         {
[08:28:14.477]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.477]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.477]             }
[08:28:14.477]             base::options(...future.oldOptions)
[08:28:14.477]             if (.Platform$OS.type == "windows") {
[08:28:14.477]                 old_names <- names(...future.oldEnvVars)
[08:28:14.477]                 envs <- base::Sys.getenv()
[08:28:14.477]                 names <- names(envs)
[08:28:14.477]                 common <- intersect(names, old_names)
[08:28:14.477]                 added <- setdiff(names, old_names)
[08:28:14.477]                 removed <- setdiff(old_names, names)
[08:28:14.477]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.477]                   envs[common]]
[08:28:14.477]                 NAMES <- toupper(changed)
[08:28:14.477]                 args <- list()
[08:28:14.477]                 for (kk in seq_along(NAMES)) {
[08:28:14.477]                   name <- changed[[kk]]
[08:28:14.477]                   NAME <- NAMES[[kk]]
[08:28:14.477]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.477]                     next
[08:28:14.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.477]                 }
[08:28:14.477]                 NAMES <- toupper(added)
[08:28:14.477]                 for (kk in seq_along(NAMES)) {
[08:28:14.477]                   name <- added[[kk]]
[08:28:14.477]                   NAME <- NAMES[[kk]]
[08:28:14.477]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.477]                     next
[08:28:14.477]                   args[[name]] <- ""
[08:28:14.477]                 }
[08:28:14.477]                 NAMES <- toupper(removed)
[08:28:14.477]                 for (kk in seq_along(NAMES)) {
[08:28:14.477]                   name <- removed[[kk]]
[08:28:14.477]                   NAME <- NAMES[[kk]]
[08:28:14.477]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.477]                     next
[08:28:14.477]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.477]                 }
[08:28:14.477]                 if (length(args) > 0) 
[08:28:14.477]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.477]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.477]             }
[08:28:14.477]             else {
[08:28:14.477]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.477]             }
[08:28:14.477]             {
[08:28:14.477]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.477]                   0L) {
[08:28:14.477]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.477]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.477]                   base::options(opts)
[08:28:14.477]                 }
[08:28:14.477]                 {
[08:28:14.477]                   {
[08:28:14.477]                     NULL
[08:28:14.477]                     RNGkind("Mersenne-Twister")
[08:28:14.477]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.477]                       inherits = FALSE)
[08:28:14.477]                   }
[08:28:14.477]                   options(future.plan = NULL)
[08:28:14.477]                   if (is.na(NA_character_)) 
[08:28:14.477]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.477]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.477]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.477]                     .init = FALSE)
[08:28:14.477]                 }
[08:28:14.477]             }
[08:28:14.477]         }
[08:28:14.477]     })
[08:28:14.477]     if (TRUE) {
[08:28:14.477]         base::sink(type = "output", split = FALSE)
[08:28:14.477]         if (TRUE) {
[08:28:14.477]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.477]         }
[08:28:14.477]         else {
[08:28:14.477]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.477]         }
[08:28:14.477]         base::close(...future.stdout)
[08:28:14.477]         ...future.stdout <- NULL
[08:28:14.477]     }
[08:28:14.477]     ...future.result$conditions <- ...future.conditions
[08:28:14.477]     ...future.result$finished <- base::Sys.time()
[08:28:14.477]     ...future.result
[08:28:14.477] }
[08:28:14.479] assign_globals() ...
[08:28:14.479] List of 1
[08:28:14.479]  $ a: num 3
[08:28:14.479]  - attr(*, "where")=List of 1
[08:28:14.479]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.479]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.479]  - attr(*, "resolved")= logi TRUE
[08:28:14.479]  - attr(*, "total_size")= num 39
[08:28:14.479]  - attr(*, "already-done")= logi TRUE
[08:28:14.482] - copied ‘a’ to environment
[08:28:14.482] assign_globals() ... done
[08:28:14.482] plan(): Setting new future strategy stack:
[08:28:14.482] List of future strategies:
[08:28:14.482] 1. sequential:
[08:28:14.482]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.482]    - tweaked: FALSE
[08:28:14.482]    - call: NULL
[08:28:14.482] plan(): nbrOfWorkers() = 1
[08:28:14.483] plan(): Setting new future strategy stack:
[08:28:14.483] List of future strategies:
[08:28:14.483] 1. sequential:
[08:28:14.483]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.483]    - tweaked: FALSE
[08:28:14.483]    - call: plan(strategy)
[08:28:14.484] plan(): nbrOfWorkers() = 1
[08:28:14.484] SequentialFuture started (and completed)
[08:28:14.484] - Launch lazy future ... done
[08:28:14.484] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.484] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.485] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.486] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.486] Searching for globals ... DONE
[08:28:14.487] Resolving globals: TRUE
[08:28:14.487] Resolving any globals that are futures ...
[08:28:14.487] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.487] Resolving any globals that are futures ... DONE
[08:28:14.487] Resolving futures part of globals (recursively) ...
[08:28:14.487] resolve() on list ...
[08:28:14.487]  recursive: 99
[08:28:14.488]  length: 2
[08:28:14.488]  elements: ‘a’, ‘ii’
[08:28:14.488]  length: 1 (resolved future 1)
[08:28:14.488]  length: 0 (resolved future 2)
[08:28:14.488] resolve() on list ... DONE
[08:28:14.488] - globals: [2] ‘a’, ‘ii’
[08:28:14.488] Resolving futures part of globals (recursively) ... DONE
[08:28:14.488] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:14.489] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.489] - globals: [2] ‘a’, ‘ii’
[08:28:14.489] 
[08:28:14.489] getGlobalsAndPackages() ... DONE
[08:28:14.489] run() for ‘Future’ ...
[08:28:14.489] - state: ‘created’
[08:28:14.489] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.489] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.490] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.490]   - Field: ‘label’
[08:28:14.490]   - Field: ‘local’
[08:28:14.490]   - Field: ‘owner’
[08:28:14.490]   - Field: ‘envir’
[08:28:14.490]   - Field: ‘packages’
[08:28:14.490]   - Field: ‘gc’
[08:28:14.490]   - Field: ‘conditions’
[08:28:14.490]   - Field: ‘expr’
[08:28:14.490]   - Field: ‘uuid’
[08:28:14.490]   - Field: ‘seed’
[08:28:14.490]   - Field: ‘version’
[08:28:14.491]   - Field: ‘result’
[08:28:14.491]   - Field: ‘asynchronous’
[08:28:14.491]   - Field: ‘calls’
[08:28:14.491]   - Field: ‘globals’
[08:28:14.491]   - Field: ‘stdout’
[08:28:14.491]   - Field: ‘earlySignal’
[08:28:14.491]   - Field: ‘lazy’
[08:28:14.491]   - Field: ‘state’
[08:28:14.491] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.491] - Launch lazy future ...
[08:28:14.491] Packages needed by the future expression (n = 0): <none>
[08:28:14.491] Packages needed by future strategies (n = 0): <none>
[08:28:14.492] {
[08:28:14.492]     {
[08:28:14.492]         {
[08:28:14.492]             ...future.startTime <- base::Sys.time()
[08:28:14.492]             {
[08:28:14.492]                 {
[08:28:14.492]                   {
[08:28:14.492]                     base::local({
[08:28:14.492]                       has_future <- base::requireNamespace("future", 
[08:28:14.492]                         quietly = TRUE)
[08:28:14.492]                       if (has_future) {
[08:28:14.492]                         ns <- base::getNamespace("future")
[08:28:14.492]                         version <- ns[[".package"]][["version"]]
[08:28:14.492]                         if (is.null(version)) 
[08:28:14.492]                           version <- utils::packageVersion("future")
[08:28:14.492]                       }
[08:28:14.492]                       else {
[08:28:14.492]                         version <- NULL
[08:28:14.492]                       }
[08:28:14.492]                       if (!has_future || version < "1.8.0") {
[08:28:14.492]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.492]                           "", base::R.version$version.string), 
[08:28:14.492]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.492]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.492]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.492]                             "release", "version")], collapse = " "), 
[08:28:14.492]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.492]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.492]                           info)
[08:28:14.492]                         info <- base::paste(info, collapse = "; ")
[08:28:14.492]                         if (!has_future) {
[08:28:14.492]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.492]                             info)
[08:28:14.492]                         }
[08:28:14.492]                         else {
[08:28:14.492]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.492]                             info, version)
[08:28:14.492]                         }
[08:28:14.492]                         base::stop(msg)
[08:28:14.492]                       }
[08:28:14.492]                     })
[08:28:14.492]                   }
[08:28:14.492]                   ...future.strategy.old <- future::plan("list")
[08:28:14.492]                   options(future.plan = NULL)
[08:28:14.492]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.492]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.492]                 }
[08:28:14.492]                 ...future.workdir <- getwd()
[08:28:14.492]             }
[08:28:14.492]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.492]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.492]         }
[08:28:14.492]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.492]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.492]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.492]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.492]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.492]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.492]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.492]             base::names(...future.oldOptions))
[08:28:14.492]     }
[08:28:14.492]     if (FALSE) {
[08:28:14.492]     }
[08:28:14.492]     else {
[08:28:14.492]         if (TRUE) {
[08:28:14.492]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.492]                 open = "w")
[08:28:14.492]         }
[08:28:14.492]         else {
[08:28:14.492]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.492]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.492]         }
[08:28:14.492]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.492]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.492]             base::sink(type = "output", split = FALSE)
[08:28:14.492]             base::close(...future.stdout)
[08:28:14.492]         }, add = TRUE)
[08:28:14.492]     }
[08:28:14.492]     ...future.frame <- base::sys.nframe()
[08:28:14.492]     ...future.conditions <- base::list()
[08:28:14.492]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.492]     if (FALSE) {
[08:28:14.492]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.492]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.492]     }
[08:28:14.492]     ...future.result <- base::tryCatch({
[08:28:14.492]         base::withCallingHandlers({
[08:28:14.492]             ...future.value <- base::withVisible(base::local({
[08:28:14.492]                 b <- a * ii
[08:28:14.492]                 a <- 0
[08:28:14.492]                 b
[08:28:14.492]             }))
[08:28:14.492]             future::FutureResult(value = ...future.value$value, 
[08:28:14.492]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.492]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.492]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.492]                     ...future.globalenv.names))
[08:28:14.492]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.492]         }, condition = base::local({
[08:28:14.492]             c <- base::c
[08:28:14.492]             inherits <- base::inherits
[08:28:14.492]             invokeRestart <- base::invokeRestart
[08:28:14.492]             length <- base::length
[08:28:14.492]             list <- base::list
[08:28:14.492]             seq.int <- base::seq.int
[08:28:14.492]             signalCondition <- base::signalCondition
[08:28:14.492]             sys.calls <- base::sys.calls
[08:28:14.492]             `[[` <- base::`[[`
[08:28:14.492]             `+` <- base::`+`
[08:28:14.492]             `<<-` <- base::`<<-`
[08:28:14.492]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.492]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.492]                   3L)]
[08:28:14.492]             }
[08:28:14.492]             function(cond) {
[08:28:14.492]                 is_error <- inherits(cond, "error")
[08:28:14.492]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.492]                   NULL)
[08:28:14.492]                 if (is_error) {
[08:28:14.492]                   sessionInformation <- function() {
[08:28:14.492]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.492]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.492]                       search = base::search(), system = base::Sys.info())
[08:28:14.492]                   }
[08:28:14.492]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.492]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.492]                     cond$call), session = sessionInformation(), 
[08:28:14.492]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.492]                   signalCondition(cond)
[08:28:14.492]                 }
[08:28:14.492]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.492]                 "immediateCondition"))) {
[08:28:14.492]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.492]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.492]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.492]                   if (TRUE && !signal) {
[08:28:14.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.492]                     {
[08:28:14.492]                       inherits <- base::inherits
[08:28:14.492]                       invokeRestart <- base::invokeRestart
[08:28:14.492]                       is.null <- base::is.null
[08:28:14.492]                       muffled <- FALSE
[08:28:14.492]                       if (inherits(cond, "message")) {
[08:28:14.492]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.492]                         if (muffled) 
[08:28:14.492]                           invokeRestart("muffleMessage")
[08:28:14.492]                       }
[08:28:14.492]                       else if (inherits(cond, "warning")) {
[08:28:14.492]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.492]                         if (muffled) 
[08:28:14.492]                           invokeRestart("muffleWarning")
[08:28:14.492]                       }
[08:28:14.492]                       else if (inherits(cond, "condition")) {
[08:28:14.492]                         if (!is.null(pattern)) {
[08:28:14.492]                           computeRestarts <- base::computeRestarts
[08:28:14.492]                           grepl <- base::grepl
[08:28:14.492]                           restarts <- computeRestarts(cond)
[08:28:14.492]                           for (restart in restarts) {
[08:28:14.492]                             name <- restart$name
[08:28:14.492]                             if (is.null(name)) 
[08:28:14.492]                               next
[08:28:14.492]                             if (!grepl(pattern, name)) 
[08:28:14.492]                               next
[08:28:14.492]                             invokeRestart(restart)
[08:28:14.492]                             muffled <- TRUE
[08:28:14.492]                             break
[08:28:14.492]                           }
[08:28:14.492]                         }
[08:28:14.492]                       }
[08:28:14.492]                       invisible(muffled)
[08:28:14.492]                     }
[08:28:14.492]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.492]                   }
[08:28:14.492]                 }
[08:28:14.492]                 else {
[08:28:14.492]                   if (TRUE) {
[08:28:14.492]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.492]                     {
[08:28:14.492]                       inherits <- base::inherits
[08:28:14.492]                       invokeRestart <- base::invokeRestart
[08:28:14.492]                       is.null <- base::is.null
[08:28:14.492]                       muffled <- FALSE
[08:28:14.492]                       if (inherits(cond, "message")) {
[08:28:14.492]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.492]                         if (muffled) 
[08:28:14.492]                           invokeRestart("muffleMessage")
[08:28:14.492]                       }
[08:28:14.492]                       else if (inherits(cond, "warning")) {
[08:28:14.492]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.492]                         if (muffled) 
[08:28:14.492]                           invokeRestart("muffleWarning")
[08:28:14.492]                       }
[08:28:14.492]                       else if (inherits(cond, "condition")) {
[08:28:14.492]                         if (!is.null(pattern)) {
[08:28:14.492]                           computeRestarts <- base::computeRestarts
[08:28:14.492]                           grepl <- base::grepl
[08:28:14.492]                           restarts <- computeRestarts(cond)
[08:28:14.492]                           for (restart in restarts) {
[08:28:14.492]                             name <- restart$name
[08:28:14.492]                             if (is.null(name)) 
[08:28:14.492]                               next
[08:28:14.492]                             if (!grepl(pattern, name)) 
[08:28:14.492]                               next
[08:28:14.492]                             invokeRestart(restart)
[08:28:14.492]                             muffled <- TRUE
[08:28:14.492]                             break
[08:28:14.492]                           }
[08:28:14.492]                         }
[08:28:14.492]                       }
[08:28:14.492]                       invisible(muffled)
[08:28:14.492]                     }
[08:28:14.492]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.492]                   }
[08:28:14.492]                 }
[08:28:14.492]             }
[08:28:14.492]         }))
[08:28:14.492]     }, error = function(ex) {
[08:28:14.492]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.492]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.492]                 ...future.rng), started = ...future.startTime, 
[08:28:14.492]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.492]             version = "1.8"), class = "FutureResult")
[08:28:14.492]     }, finally = {
[08:28:14.492]         if (!identical(...future.workdir, getwd())) 
[08:28:14.492]             setwd(...future.workdir)
[08:28:14.492]         {
[08:28:14.492]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.492]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.492]             }
[08:28:14.492]             base::options(...future.oldOptions)
[08:28:14.492]             if (.Platform$OS.type == "windows") {
[08:28:14.492]                 old_names <- names(...future.oldEnvVars)
[08:28:14.492]                 envs <- base::Sys.getenv()
[08:28:14.492]                 names <- names(envs)
[08:28:14.492]                 common <- intersect(names, old_names)
[08:28:14.492]                 added <- setdiff(names, old_names)
[08:28:14.492]                 removed <- setdiff(old_names, names)
[08:28:14.492]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.492]                   envs[common]]
[08:28:14.492]                 NAMES <- toupper(changed)
[08:28:14.492]                 args <- list()
[08:28:14.492]                 for (kk in seq_along(NAMES)) {
[08:28:14.492]                   name <- changed[[kk]]
[08:28:14.492]                   NAME <- NAMES[[kk]]
[08:28:14.492]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.492]                     next
[08:28:14.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.492]                 }
[08:28:14.492]                 NAMES <- toupper(added)
[08:28:14.492]                 for (kk in seq_along(NAMES)) {
[08:28:14.492]                   name <- added[[kk]]
[08:28:14.492]                   NAME <- NAMES[[kk]]
[08:28:14.492]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.492]                     next
[08:28:14.492]                   args[[name]] <- ""
[08:28:14.492]                 }
[08:28:14.492]                 NAMES <- toupper(removed)
[08:28:14.492]                 for (kk in seq_along(NAMES)) {
[08:28:14.492]                   name <- removed[[kk]]
[08:28:14.492]                   NAME <- NAMES[[kk]]
[08:28:14.492]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.492]                     next
[08:28:14.492]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.492]                 }
[08:28:14.492]                 if (length(args) > 0) 
[08:28:14.492]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.492]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.492]             }
[08:28:14.492]             else {
[08:28:14.492]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.492]             }
[08:28:14.492]             {
[08:28:14.492]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.492]                   0L) {
[08:28:14.492]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.492]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.492]                   base::options(opts)
[08:28:14.492]                 }
[08:28:14.492]                 {
[08:28:14.492]                   {
[08:28:14.492]                     NULL
[08:28:14.492]                     RNGkind("Mersenne-Twister")
[08:28:14.492]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.492]                       inherits = FALSE)
[08:28:14.492]                   }
[08:28:14.492]                   options(future.plan = NULL)
[08:28:14.492]                   if (is.na(NA_character_)) 
[08:28:14.492]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.492]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.492]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.492]                     .init = FALSE)
[08:28:14.492]                 }
[08:28:14.492]             }
[08:28:14.492]         }
[08:28:14.492]     })
[08:28:14.492]     if (TRUE) {
[08:28:14.492]         base::sink(type = "output", split = FALSE)
[08:28:14.492]         if (TRUE) {
[08:28:14.492]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.492]         }
[08:28:14.492]         else {
[08:28:14.492]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.492]         }
[08:28:14.492]         base::close(...future.stdout)
[08:28:14.492]         ...future.stdout <- NULL
[08:28:14.492]     }
[08:28:14.492]     ...future.result$conditions <- ...future.conditions
[08:28:14.492]     ...future.result$finished <- base::Sys.time()
[08:28:14.492]     ...future.result
[08:28:14.492] }
[08:28:14.493] assign_globals() ...
[08:28:14.494] List of 2
[08:28:14.494]  $ a : num 1
[08:28:14.494]  $ ii: int 1
[08:28:14.494]  - attr(*, "where")=List of 2
[08:28:14.494]   ..$ a :<environment: R_EmptyEnv> 
[08:28:14.494]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.494]  - attr(*, "resolved")= logi TRUE
[08:28:14.494]  - attr(*, "total_size")= num 74
[08:28:14.494]  - attr(*, "already-done")= logi TRUE
[08:28:14.496] - copied ‘a’ to environment
[08:28:14.496] - copied ‘ii’ to environment
[08:28:14.496] assign_globals() ... done
[08:28:14.497] plan(): Setting new future strategy stack:
[08:28:14.497] List of future strategies:
[08:28:14.497] 1. sequential:
[08:28:14.497]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.497]    - tweaked: FALSE
[08:28:14.497]    - call: NULL
[08:28:14.497] plan(): nbrOfWorkers() = 1
[08:28:14.498] plan(): Setting new future strategy stack:
[08:28:14.498] List of future strategies:
[08:28:14.498] 1. sequential:
[08:28:14.498]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.498]    - tweaked: FALSE
[08:28:14.498]    - call: plan(strategy)
[08:28:14.498] plan(): nbrOfWorkers() = 1
[08:28:14.498] SequentialFuture started (and completed)
[08:28:14.499] - Launch lazy future ... done
[08:28:14.499] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.499] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.499] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.502] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.502] Searching for globals ... DONE
[08:28:14.502] Resolving globals: TRUE
[08:28:14.503] Resolving any globals that are futures ...
[08:28:14.503] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.503] Resolving any globals that are futures ... DONE
[08:28:14.503] Resolving futures part of globals (recursively) ...
[08:28:14.503] resolve() on list ...
[08:28:14.503]  recursive: 99
[08:28:14.503]  length: 2
[08:28:14.503]  elements: ‘a’, ‘ii’
[08:28:14.504]  length: 1 (resolved future 1)
[08:28:14.504]  length: 0 (resolved future 2)
[08:28:14.504] resolve() on list ... DONE
[08:28:14.504] - globals: [2] ‘a’, ‘ii’
[08:28:14.504] Resolving futures part of globals (recursively) ... DONE
[08:28:14.504] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:14.504] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.504] - globals: [2] ‘a’, ‘ii’
[08:28:14.505] 
[08:28:14.505] getGlobalsAndPackages() ... DONE
[08:28:14.505] run() for ‘Future’ ...
[08:28:14.505] - state: ‘created’
[08:28:14.505] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.505] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.505] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.506]   - Field: ‘label’
[08:28:14.506]   - Field: ‘local’
[08:28:14.506]   - Field: ‘owner’
[08:28:14.506]   - Field: ‘envir’
[08:28:14.506]   - Field: ‘packages’
[08:28:14.506]   - Field: ‘gc’
[08:28:14.506]   - Field: ‘conditions’
[08:28:14.506]   - Field: ‘expr’
[08:28:14.506]   - Field: ‘uuid’
[08:28:14.506]   - Field: ‘seed’
[08:28:14.506]   - Field: ‘version’
[08:28:14.506]   - Field: ‘result’
[08:28:14.507]   - Field: ‘asynchronous’
[08:28:14.507]   - Field: ‘calls’
[08:28:14.507]   - Field: ‘globals’
[08:28:14.507]   - Field: ‘stdout’
[08:28:14.507]   - Field: ‘earlySignal’
[08:28:14.507]   - Field: ‘lazy’
[08:28:14.507]   - Field: ‘state’
[08:28:14.507] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.507] - Launch lazy future ...
[08:28:14.507] Packages needed by the future expression (n = 0): <none>
[08:28:14.507] Packages needed by future strategies (n = 0): <none>
[08:28:14.508] {
[08:28:14.508]     {
[08:28:14.508]         {
[08:28:14.508]             ...future.startTime <- base::Sys.time()
[08:28:14.508]             {
[08:28:14.508]                 {
[08:28:14.508]                   {
[08:28:14.508]                     base::local({
[08:28:14.508]                       has_future <- base::requireNamespace("future", 
[08:28:14.508]                         quietly = TRUE)
[08:28:14.508]                       if (has_future) {
[08:28:14.508]                         ns <- base::getNamespace("future")
[08:28:14.508]                         version <- ns[[".package"]][["version"]]
[08:28:14.508]                         if (is.null(version)) 
[08:28:14.508]                           version <- utils::packageVersion("future")
[08:28:14.508]                       }
[08:28:14.508]                       else {
[08:28:14.508]                         version <- NULL
[08:28:14.508]                       }
[08:28:14.508]                       if (!has_future || version < "1.8.0") {
[08:28:14.508]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.508]                           "", base::R.version$version.string), 
[08:28:14.508]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.508]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.508]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.508]                             "release", "version")], collapse = " "), 
[08:28:14.508]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.508]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.508]                           info)
[08:28:14.508]                         info <- base::paste(info, collapse = "; ")
[08:28:14.508]                         if (!has_future) {
[08:28:14.508]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.508]                             info)
[08:28:14.508]                         }
[08:28:14.508]                         else {
[08:28:14.508]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.508]                             info, version)
[08:28:14.508]                         }
[08:28:14.508]                         base::stop(msg)
[08:28:14.508]                       }
[08:28:14.508]                     })
[08:28:14.508]                   }
[08:28:14.508]                   ...future.strategy.old <- future::plan("list")
[08:28:14.508]                   options(future.plan = NULL)
[08:28:14.508]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.508]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.508]                 }
[08:28:14.508]                 ...future.workdir <- getwd()
[08:28:14.508]             }
[08:28:14.508]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.508]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.508]         }
[08:28:14.508]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.508]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.508]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.508]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.508]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.508]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.508]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.508]             base::names(...future.oldOptions))
[08:28:14.508]     }
[08:28:14.508]     if (FALSE) {
[08:28:14.508]     }
[08:28:14.508]     else {
[08:28:14.508]         if (TRUE) {
[08:28:14.508]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.508]                 open = "w")
[08:28:14.508]         }
[08:28:14.508]         else {
[08:28:14.508]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.508]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.508]         }
[08:28:14.508]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.508]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.508]             base::sink(type = "output", split = FALSE)
[08:28:14.508]             base::close(...future.stdout)
[08:28:14.508]         }, add = TRUE)
[08:28:14.508]     }
[08:28:14.508]     ...future.frame <- base::sys.nframe()
[08:28:14.508]     ...future.conditions <- base::list()
[08:28:14.508]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.508]     if (FALSE) {
[08:28:14.508]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.508]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.508]     }
[08:28:14.508]     ...future.result <- base::tryCatch({
[08:28:14.508]         base::withCallingHandlers({
[08:28:14.508]             ...future.value <- base::withVisible(base::local({
[08:28:14.508]                 b <- a * ii
[08:28:14.508]                 a <- 0
[08:28:14.508]                 b
[08:28:14.508]             }))
[08:28:14.508]             future::FutureResult(value = ...future.value$value, 
[08:28:14.508]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.508]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.508]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.508]                     ...future.globalenv.names))
[08:28:14.508]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.508]         }, condition = base::local({
[08:28:14.508]             c <- base::c
[08:28:14.508]             inherits <- base::inherits
[08:28:14.508]             invokeRestart <- base::invokeRestart
[08:28:14.508]             length <- base::length
[08:28:14.508]             list <- base::list
[08:28:14.508]             seq.int <- base::seq.int
[08:28:14.508]             signalCondition <- base::signalCondition
[08:28:14.508]             sys.calls <- base::sys.calls
[08:28:14.508]             `[[` <- base::`[[`
[08:28:14.508]             `+` <- base::`+`
[08:28:14.508]             `<<-` <- base::`<<-`
[08:28:14.508]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.508]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.508]                   3L)]
[08:28:14.508]             }
[08:28:14.508]             function(cond) {
[08:28:14.508]                 is_error <- inherits(cond, "error")
[08:28:14.508]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.508]                   NULL)
[08:28:14.508]                 if (is_error) {
[08:28:14.508]                   sessionInformation <- function() {
[08:28:14.508]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.508]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.508]                       search = base::search(), system = base::Sys.info())
[08:28:14.508]                   }
[08:28:14.508]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.508]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.508]                     cond$call), session = sessionInformation(), 
[08:28:14.508]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.508]                   signalCondition(cond)
[08:28:14.508]                 }
[08:28:14.508]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.508]                 "immediateCondition"))) {
[08:28:14.508]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.508]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.508]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.508]                   if (TRUE && !signal) {
[08:28:14.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.508]                     {
[08:28:14.508]                       inherits <- base::inherits
[08:28:14.508]                       invokeRestart <- base::invokeRestart
[08:28:14.508]                       is.null <- base::is.null
[08:28:14.508]                       muffled <- FALSE
[08:28:14.508]                       if (inherits(cond, "message")) {
[08:28:14.508]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.508]                         if (muffled) 
[08:28:14.508]                           invokeRestart("muffleMessage")
[08:28:14.508]                       }
[08:28:14.508]                       else if (inherits(cond, "warning")) {
[08:28:14.508]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.508]                         if (muffled) 
[08:28:14.508]                           invokeRestart("muffleWarning")
[08:28:14.508]                       }
[08:28:14.508]                       else if (inherits(cond, "condition")) {
[08:28:14.508]                         if (!is.null(pattern)) {
[08:28:14.508]                           computeRestarts <- base::computeRestarts
[08:28:14.508]                           grepl <- base::grepl
[08:28:14.508]                           restarts <- computeRestarts(cond)
[08:28:14.508]                           for (restart in restarts) {
[08:28:14.508]                             name <- restart$name
[08:28:14.508]                             if (is.null(name)) 
[08:28:14.508]                               next
[08:28:14.508]                             if (!grepl(pattern, name)) 
[08:28:14.508]                               next
[08:28:14.508]                             invokeRestart(restart)
[08:28:14.508]                             muffled <- TRUE
[08:28:14.508]                             break
[08:28:14.508]                           }
[08:28:14.508]                         }
[08:28:14.508]                       }
[08:28:14.508]                       invisible(muffled)
[08:28:14.508]                     }
[08:28:14.508]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.508]                   }
[08:28:14.508]                 }
[08:28:14.508]                 else {
[08:28:14.508]                   if (TRUE) {
[08:28:14.508]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.508]                     {
[08:28:14.508]                       inherits <- base::inherits
[08:28:14.508]                       invokeRestart <- base::invokeRestart
[08:28:14.508]                       is.null <- base::is.null
[08:28:14.508]                       muffled <- FALSE
[08:28:14.508]                       if (inherits(cond, "message")) {
[08:28:14.508]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.508]                         if (muffled) 
[08:28:14.508]                           invokeRestart("muffleMessage")
[08:28:14.508]                       }
[08:28:14.508]                       else if (inherits(cond, "warning")) {
[08:28:14.508]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.508]                         if (muffled) 
[08:28:14.508]                           invokeRestart("muffleWarning")
[08:28:14.508]                       }
[08:28:14.508]                       else if (inherits(cond, "condition")) {
[08:28:14.508]                         if (!is.null(pattern)) {
[08:28:14.508]                           computeRestarts <- base::computeRestarts
[08:28:14.508]                           grepl <- base::grepl
[08:28:14.508]                           restarts <- computeRestarts(cond)
[08:28:14.508]                           for (restart in restarts) {
[08:28:14.508]                             name <- restart$name
[08:28:14.508]                             if (is.null(name)) 
[08:28:14.508]                               next
[08:28:14.508]                             if (!grepl(pattern, name)) 
[08:28:14.508]                               next
[08:28:14.508]                             invokeRestart(restart)
[08:28:14.508]                             muffled <- TRUE
[08:28:14.508]                             break
[08:28:14.508]                           }
[08:28:14.508]                         }
[08:28:14.508]                       }
[08:28:14.508]                       invisible(muffled)
[08:28:14.508]                     }
[08:28:14.508]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.508]                   }
[08:28:14.508]                 }
[08:28:14.508]             }
[08:28:14.508]         }))
[08:28:14.508]     }, error = function(ex) {
[08:28:14.508]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.508]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.508]                 ...future.rng), started = ...future.startTime, 
[08:28:14.508]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.508]             version = "1.8"), class = "FutureResult")
[08:28:14.508]     }, finally = {
[08:28:14.508]         if (!identical(...future.workdir, getwd())) 
[08:28:14.508]             setwd(...future.workdir)
[08:28:14.508]         {
[08:28:14.508]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.508]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.508]             }
[08:28:14.508]             base::options(...future.oldOptions)
[08:28:14.508]             if (.Platform$OS.type == "windows") {
[08:28:14.508]                 old_names <- names(...future.oldEnvVars)
[08:28:14.508]                 envs <- base::Sys.getenv()
[08:28:14.508]                 names <- names(envs)
[08:28:14.508]                 common <- intersect(names, old_names)
[08:28:14.508]                 added <- setdiff(names, old_names)
[08:28:14.508]                 removed <- setdiff(old_names, names)
[08:28:14.508]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.508]                   envs[common]]
[08:28:14.508]                 NAMES <- toupper(changed)
[08:28:14.508]                 args <- list()
[08:28:14.508]                 for (kk in seq_along(NAMES)) {
[08:28:14.508]                   name <- changed[[kk]]
[08:28:14.508]                   NAME <- NAMES[[kk]]
[08:28:14.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.508]                     next
[08:28:14.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.508]                 }
[08:28:14.508]                 NAMES <- toupper(added)
[08:28:14.508]                 for (kk in seq_along(NAMES)) {
[08:28:14.508]                   name <- added[[kk]]
[08:28:14.508]                   NAME <- NAMES[[kk]]
[08:28:14.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.508]                     next
[08:28:14.508]                   args[[name]] <- ""
[08:28:14.508]                 }
[08:28:14.508]                 NAMES <- toupper(removed)
[08:28:14.508]                 for (kk in seq_along(NAMES)) {
[08:28:14.508]                   name <- removed[[kk]]
[08:28:14.508]                   NAME <- NAMES[[kk]]
[08:28:14.508]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.508]                     next
[08:28:14.508]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.508]                 }
[08:28:14.508]                 if (length(args) > 0) 
[08:28:14.508]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.508]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.508]             }
[08:28:14.508]             else {
[08:28:14.508]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.508]             }
[08:28:14.508]             {
[08:28:14.508]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.508]                   0L) {
[08:28:14.508]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.508]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.508]                   base::options(opts)
[08:28:14.508]                 }
[08:28:14.508]                 {
[08:28:14.508]                   {
[08:28:14.508]                     NULL
[08:28:14.508]                     RNGkind("Mersenne-Twister")
[08:28:14.508]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.508]                       inherits = FALSE)
[08:28:14.508]                   }
[08:28:14.508]                   options(future.plan = NULL)
[08:28:14.508]                   if (is.na(NA_character_)) 
[08:28:14.508]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.508]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.508]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.508]                     .init = FALSE)
[08:28:14.508]                 }
[08:28:14.508]             }
[08:28:14.508]         }
[08:28:14.508]     })
[08:28:14.508]     if (TRUE) {
[08:28:14.508]         base::sink(type = "output", split = FALSE)
[08:28:14.508]         if (TRUE) {
[08:28:14.508]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.508]         }
[08:28:14.508]         else {
[08:28:14.508]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.508]         }
[08:28:14.508]         base::close(...future.stdout)
[08:28:14.508]         ...future.stdout <- NULL
[08:28:14.508]     }
[08:28:14.508]     ...future.result$conditions <- ...future.conditions
[08:28:14.508]     ...future.result$finished <- base::Sys.time()
[08:28:14.508]     ...future.result
[08:28:14.508] }
[08:28:14.509] assign_globals() ...
[08:28:14.509] List of 2
[08:28:14.509]  $ a : num 1
[08:28:14.509]  $ ii: int 2
[08:28:14.509]  - attr(*, "where")=List of 2
[08:28:14.509]   ..$ a :<environment: R_EmptyEnv> 
[08:28:14.509]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.509]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.509]  - attr(*, "resolved")= logi TRUE
[08:28:14.509]  - attr(*, "total_size")= num 74
[08:28:14.509]  - attr(*, "already-done")= logi TRUE
[08:28:14.512] - copied ‘a’ to environment
[08:28:14.512] - copied ‘ii’ to environment
[08:28:14.512] assign_globals() ... done
[08:28:14.513] plan(): Setting new future strategy stack:
[08:28:14.513] List of future strategies:
[08:28:14.513] 1. sequential:
[08:28:14.513]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.513]    - tweaked: FALSE
[08:28:14.513]    - call: NULL
[08:28:14.513] plan(): nbrOfWorkers() = 1
[08:28:14.514] plan(): Setting new future strategy stack:
[08:28:14.514] List of future strategies:
[08:28:14.514] 1. sequential:
[08:28:14.514]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.514]    - tweaked: FALSE
[08:28:14.514]    - call: plan(strategy)
[08:28:14.514] plan(): nbrOfWorkers() = 1
[08:28:14.514] SequentialFuture started (and completed)
[08:28:14.515] - Launch lazy future ... done
[08:28:14.515] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.515] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.515] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.517] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.517] Searching for globals ... DONE
[08:28:14.517] Resolving globals: TRUE
[08:28:14.517] Resolving any globals that are futures ...
[08:28:14.517] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.517] Resolving any globals that are futures ... DONE
[08:28:14.518] Resolving futures part of globals (recursively) ...
[08:28:14.518] resolve() on list ...
[08:28:14.518]  recursive: 99
[08:28:14.518]  length: 2
[08:28:14.518]  elements: ‘a’, ‘ii’
[08:28:14.518]  length: 1 (resolved future 1)
[08:28:14.518]  length: 0 (resolved future 2)
[08:28:14.518] resolve() on list ... DONE
[08:28:14.518] - globals: [2] ‘a’, ‘ii’
[08:28:14.519] Resolving futures part of globals (recursively) ... DONE
[08:28:14.519] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:14.519] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.519] - globals: [2] ‘a’, ‘ii’
[08:28:14.519] 
[08:28:14.519] getGlobalsAndPackages() ... DONE
[08:28:14.520] run() for ‘Future’ ...
[08:28:14.520] - state: ‘created’
[08:28:14.520] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.520] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.520] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.520]   - Field: ‘label’
[08:28:14.520]   - Field: ‘local’
[08:28:14.520]   - Field: ‘owner’
[08:28:14.520]   - Field: ‘envir’
[08:28:14.520]   - Field: ‘packages’
[08:28:14.521]   - Field: ‘gc’
[08:28:14.521]   - Field: ‘conditions’
[08:28:14.521]   - Field: ‘expr’
[08:28:14.521]   - Field: ‘uuid’
[08:28:14.521]   - Field: ‘seed’
[08:28:14.521]   - Field: ‘version’
[08:28:14.521]   - Field: ‘result’
[08:28:14.521]   - Field: ‘asynchronous’
[08:28:14.521]   - Field: ‘calls’
[08:28:14.521]   - Field: ‘globals’
[08:28:14.521]   - Field: ‘stdout’
[08:28:14.521]   - Field: ‘earlySignal’
[08:28:14.522]   - Field: ‘lazy’
[08:28:14.522]   - Field: ‘state’
[08:28:14.522] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.522] - Launch lazy future ...
[08:28:14.522] Packages needed by the future expression (n = 0): <none>
[08:28:14.522] Packages needed by future strategies (n = 0): <none>
[08:28:14.522] {
[08:28:14.522]     {
[08:28:14.522]         {
[08:28:14.522]             ...future.startTime <- base::Sys.time()
[08:28:14.522]             {
[08:28:14.522]                 {
[08:28:14.522]                   {
[08:28:14.522]                     base::local({
[08:28:14.522]                       has_future <- base::requireNamespace("future", 
[08:28:14.522]                         quietly = TRUE)
[08:28:14.522]                       if (has_future) {
[08:28:14.522]                         ns <- base::getNamespace("future")
[08:28:14.522]                         version <- ns[[".package"]][["version"]]
[08:28:14.522]                         if (is.null(version)) 
[08:28:14.522]                           version <- utils::packageVersion("future")
[08:28:14.522]                       }
[08:28:14.522]                       else {
[08:28:14.522]                         version <- NULL
[08:28:14.522]                       }
[08:28:14.522]                       if (!has_future || version < "1.8.0") {
[08:28:14.522]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.522]                           "", base::R.version$version.string), 
[08:28:14.522]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.522]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.522]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.522]                             "release", "version")], collapse = " "), 
[08:28:14.522]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.522]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.522]                           info)
[08:28:14.522]                         info <- base::paste(info, collapse = "; ")
[08:28:14.522]                         if (!has_future) {
[08:28:14.522]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.522]                             info)
[08:28:14.522]                         }
[08:28:14.522]                         else {
[08:28:14.522]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.522]                             info, version)
[08:28:14.522]                         }
[08:28:14.522]                         base::stop(msg)
[08:28:14.522]                       }
[08:28:14.522]                     })
[08:28:14.522]                   }
[08:28:14.522]                   ...future.strategy.old <- future::plan("list")
[08:28:14.522]                   options(future.plan = NULL)
[08:28:14.522]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.522]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.522]                 }
[08:28:14.522]                 ...future.workdir <- getwd()
[08:28:14.522]             }
[08:28:14.522]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.522]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.522]         }
[08:28:14.522]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.522]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.522]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.522]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.522]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.522]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.522]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.522]             base::names(...future.oldOptions))
[08:28:14.522]     }
[08:28:14.522]     if (FALSE) {
[08:28:14.522]     }
[08:28:14.522]     else {
[08:28:14.522]         if (TRUE) {
[08:28:14.522]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.522]                 open = "w")
[08:28:14.522]         }
[08:28:14.522]         else {
[08:28:14.522]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.522]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.522]         }
[08:28:14.522]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.522]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.522]             base::sink(type = "output", split = FALSE)
[08:28:14.522]             base::close(...future.stdout)
[08:28:14.522]         }, add = TRUE)
[08:28:14.522]     }
[08:28:14.522]     ...future.frame <- base::sys.nframe()
[08:28:14.522]     ...future.conditions <- base::list()
[08:28:14.522]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.522]     if (FALSE) {
[08:28:14.522]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.522]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.522]     }
[08:28:14.522]     ...future.result <- base::tryCatch({
[08:28:14.522]         base::withCallingHandlers({
[08:28:14.522]             ...future.value <- base::withVisible(base::local({
[08:28:14.522]                 b <- a * ii
[08:28:14.522]                 a <- 0
[08:28:14.522]                 b
[08:28:14.522]             }))
[08:28:14.522]             future::FutureResult(value = ...future.value$value, 
[08:28:14.522]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.522]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.522]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.522]                     ...future.globalenv.names))
[08:28:14.522]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.522]         }, condition = base::local({
[08:28:14.522]             c <- base::c
[08:28:14.522]             inherits <- base::inherits
[08:28:14.522]             invokeRestart <- base::invokeRestart
[08:28:14.522]             length <- base::length
[08:28:14.522]             list <- base::list
[08:28:14.522]             seq.int <- base::seq.int
[08:28:14.522]             signalCondition <- base::signalCondition
[08:28:14.522]             sys.calls <- base::sys.calls
[08:28:14.522]             `[[` <- base::`[[`
[08:28:14.522]             `+` <- base::`+`
[08:28:14.522]             `<<-` <- base::`<<-`
[08:28:14.522]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.522]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.522]                   3L)]
[08:28:14.522]             }
[08:28:14.522]             function(cond) {
[08:28:14.522]                 is_error <- inherits(cond, "error")
[08:28:14.522]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.522]                   NULL)
[08:28:14.522]                 if (is_error) {
[08:28:14.522]                   sessionInformation <- function() {
[08:28:14.522]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.522]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.522]                       search = base::search(), system = base::Sys.info())
[08:28:14.522]                   }
[08:28:14.522]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.522]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.522]                     cond$call), session = sessionInformation(), 
[08:28:14.522]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.522]                   signalCondition(cond)
[08:28:14.522]                 }
[08:28:14.522]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.522]                 "immediateCondition"))) {
[08:28:14.522]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.522]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.522]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.522]                   if (TRUE && !signal) {
[08:28:14.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.522]                     {
[08:28:14.522]                       inherits <- base::inherits
[08:28:14.522]                       invokeRestart <- base::invokeRestart
[08:28:14.522]                       is.null <- base::is.null
[08:28:14.522]                       muffled <- FALSE
[08:28:14.522]                       if (inherits(cond, "message")) {
[08:28:14.522]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.522]                         if (muffled) 
[08:28:14.522]                           invokeRestart("muffleMessage")
[08:28:14.522]                       }
[08:28:14.522]                       else if (inherits(cond, "warning")) {
[08:28:14.522]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.522]                         if (muffled) 
[08:28:14.522]                           invokeRestart("muffleWarning")
[08:28:14.522]                       }
[08:28:14.522]                       else if (inherits(cond, "condition")) {
[08:28:14.522]                         if (!is.null(pattern)) {
[08:28:14.522]                           computeRestarts <- base::computeRestarts
[08:28:14.522]                           grepl <- base::grepl
[08:28:14.522]                           restarts <- computeRestarts(cond)
[08:28:14.522]                           for (restart in restarts) {
[08:28:14.522]                             name <- restart$name
[08:28:14.522]                             if (is.null(name)) 
[08:28:14.522]                               next
[08:28:14.522]                             if (!grepl(pattern, name)) 
[08:28:14.522]                               next
[08:28:14.522]                             invokeRestart(restart)
[08:28:14.522]                             muffled <- TRUE
[08:28:14.522]                             break
[08:28:14.522]                           }
[08:28:14.522]                         }
[08:28:14.522]                       }
[08:28:14.522]                       invisible(muffled)
[08:28:14.522]                     }
[08:28:14.522]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.522]                   }
[08:28:14.522]                 }
[08:28:14.522]                 else {
[08:28:14.522]                   if (TRUE) {
[08:28:14.522]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.522]                     {
[08:28:14.522]                       inherits <- base::inherits
[08:28:14.522]                       invokeRestart <- base::invokeRestart
[08:28:14.522]                       is.null <- base::is.null
[08:28:14.522]                       muffled <- FALSE
[08:28:14.522]                       if (inherits(cond, "message")) {
[08:28:14.522]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.522]                         if (muffled) 
[08:28:14.522]                           invokeRestart("muffleMessage")
[08:28:14.522]                       }
[08:28:14.522]                       else if (inherits(cond, "warning")) {
[08:28:14.522]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.522]                         if (muffled) 
[08:28:14.522]                           invokeRestart("muffleWarning")
[08:28:14.522]                       }
[08:28:14.522]                       else if (inherits(cond, "condition")) {
[08:28:14.522]                         if (!is.null(pattern)) {
[08:28:14.522]                           computeRestarts <- base::computeRestarts
[08:28:14.522]                           grepl <- base::grepl
[08:28:14.522]                           restarts <- computeRestarts(cond)
[08:28:14.522]                           for (restart in restarts) {
[08:28:14.522]                             name <- restart$name
[08:28:14.522]                             if (is.null(name)) 
[08:28:14.522]                               next
[08:28:14.522]                             if (!grepl(pattern, name)) 
[08:28:14.522]                               next
[08:28:14.522]                             invokeRestart(restart)
[08:28:14.522]                             muffled <- TRUE
[08:28:14.522]                             break
[08:28:14.522]                           }
[08:28:14.522]                         }
[08:28:14.522]                       }
[08:28:14.522]                       invisible(muffled)
[08:28:14.522]                     }
[08:28:14.522]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.522]                   }
[08:28:14.522]                 }
[08:28:14.522]             }
[08:28:14.522]         }))
[08:28:14.522]     }, error = function(ex) {
[08:28:14.522]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.522]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.522]                 ...future.rng), started = ...future.startTime, 
[08:28:14.522]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.522]             version = "1.8"), class = "FutureResult")
[08:28:14.522]     }, finally = {
[08:28:14.522]         if (!identical(...future.workdir, getwd())) 
[08:28:14.522]             setwd(...future.workdir)
[08:28:14.522]         {
[08:28:14.522]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.522]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.522]             }
[08:28:14.522]             base::options(...future.oldOptions)
[08:28:14.522]             if (.Platform$OS.type == "windows") {
[08:28:14.522]                 old_names <- names(...future.oldEnvVars)
[08:28:14.522]                 envs <- base::Sys.getenv()
[08:28:14.522]                 names <- names(envs)
[08:28:14.522]                 common <- intersect(names, old_names)
[08:28:14.522]                 added <- setdiff(names, old_names)
[08:28:14.522]                 removed <- setdiff(old_names, names)
[08:28:14.522]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.522]                   envs[common]]
[08:28:14.522]                 NAMES <- toupper(changed)
[08:28:14.522]                 args <- list()
[08:28:14.522]                 for (kk in seq_along(NAMES)) {
[08:28:14.522]                   name <- changed[[kk]]
[08:28:14.522]                   NAME <- NAMES[[kk]]
[08:28:14.522]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.522]                     next
[08:28:14.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.522]                 }
[08:28:14.522]                 NAMES <- toupper(added)
[08:28:14.522]                 for (kk in seq_along(NAMES)) {
[08:28:14.522]                   name <- added[[kk]]
[08:28:14.522]                   NAME <- NAMES[[kk]]
[08:28:14.522]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.522]                     next
[08:28:14.522]                   args[[name]] <- ""
[08:28:14.522]                 }
[08:28:14.522]                 NAMES <- toupper(removed)
[08:28:14.522]                 for (kk in seq_along(NAMES)) {
[08:28:14.522]                   name <- removed[[kk]]
[08:28:14.522]                   NAME <- NAMES[[kk]]
[08:28:14.522]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.522]                     next
[08:28:14.522]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.522]                 }
[08:28:14.522]                 if (length(args) > 0) 
[08:28:14.522]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.522]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.522]             }
[08:28:14.522]             else {
[08:28:14.522]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.522]             }
[08:28:14.522]             {
[08:28:14.522]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.522]                   0L) {
[08:28:14.522]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.522]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.522]                   base::options(opts)
[08:28:14.522]                 }
[08:28:14.522]                 {
[08:28:14.522]                   {
[08:28:14.522]                     NULL
[08:28:14.522]                     RNGkind("Mersenne-Twister")
[08:28:14.522]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.522]                       inherits = FALSE)
[08:28:14.522]                   }
[08:28:14.522]                   options(future.plan = NULL)
[08:28:14.522]                   if (is.na(NA_character_)) 
[08:28:14.522]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.522]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.522]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.522]                     .init = FALSE)
[08:28:14.522]                 }
[08:28:14.522]             }
[08:28:14.522]         }
[08:28:14.522]     })
[08:28:14.522]     if (TRUE) {
[08:28:14.522]         base::sink(type = "output", split = FALSE)
[08:28:14.522]         if (TRUE) {
[08:28:14.522]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.522]         }
[08:28:14.522]         else {
[08:28:14.522]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.522]         }
[08:28:14.522]         base::close(...future.stdout)
[08:28:14.522]         ...future.stdout <- NULL
[08:28:14.522]     }
[08:28:14.522]     ...future.result$conditions <- ...future.conditions
[08:28:14.522]     ...future.result$finished <- base::Sys.time()
[08:28:14.522]     ...future.result
[08:28:14.522] }
[08:28:14.525] assign_globals() ...
[08:28:14.525] List of 2
[08:28:14.525]  $ a : num 1
[08:28:14.525]  $ ii: int 3
[08:28:14.525]  - attr(*, "where")=List of 2
[08:28:14.525]   ..$ a :<environment: R_EmptyEnv> 
[08:28:14.525]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.525]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.525]  - attr(*, "resolved")= logi TRUE
[08:28:14.525]  - attr(*, "total_size")= num 74
[08:28:14.525]  - attr(*, "already-done")= logi TRUE
[08:28:14.528] - copied ‘a’ to environment
[08:28:14.528] - copied ‘ii’ to environment
[08:28:14.528] assign_globals() ... done
[08:28:14.528] plan(): Setting new future strategy stack:
[08:28:14.529] List of future strategies:
[08:28:14.529] 1. sequential:
[08:28:14.529]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.529]    - tweaked: FALSE
[08:28:14.529]    - call: NULL
[08:28:14.529] plan(): nbrOfWorkers() = 1
[08:28:14.530] plan(): Setting new future strategy stack:
[08:28:14.530] List of future strategies:
[08:28:14.530] 1. sequential:
[08:28:14.530]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.530]    - tweaked: FALSE
[08:28:14.530]    - call: plan(strategy)
[08:28:14.530] plan(): nbrOfWorkers() = 1
[08:28:14.530] SequentialFuture started (and completed)
[08:28:14.530] - Launch lazy future ... done
[08:28:14.530] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.531] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.531] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.533] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.533] Searching for globals ... DONE
[08:28:14.533] Resolving globals: TRUE
[08:28:14.533] Resolving any globals that are futures ...
[08:28:14.534] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.534] Resolving any globals that are futures ... DONE
[08:28:14.534] Resolving futures part of globals (recursively) ...
[08:28:14.534] resolve() on list ...
[08:28:14.534]  recursive: 99
[08:28:14.534]  length: 2
[08:28:14.534]  elements: ‘a’, ‘ii’
[08:28:14.535]  length: 1 (resolved future 1)
[08:28:14.535]  length: 0 (resolved future 2)
[08:28:14.535] resolve() on list ... DONE
[08:28:14.535] - globals: [2] ‘a’, ‘ii’
[08:28:14.535] Resolving futures part of globals (recursively) ... DONE
[08:28:14.535] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:14.535] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.535] - globals: [2] ‘a’, ‘ii’
[08:28:14.536] 
[08:28:14.536] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.536] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.536] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.538] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.538] Searching for globals ... DONE
[08:28:14.538] Resolving globals: TRUE
[08:28:14.538] Resolving any globals that are futures ...
[08:28:14.538] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.538] Resolving any globals that are futures ... DONE
[08:28:14.539] Resolving futures part of globals (recursively) ...
[08:28:14.539] resolve() on list ...
[08:28:14.539]  recursive: 99
[08:28:14.539]  length: 2
[08:28:14.539]  elements: ‘a’, ‘ii’
[08:28:14.539]  length: 1 (resolved future 1)
[08:28:14.539]  length: 0 (resolved future 2)
[08:28:14.540] resolve() on list ... DONE
[08:28:14.540] - globals: [2] ‘a’, ‘ii’
[08:28:14.540] Resolving futures part of globals (recursively) ... DONE
[08:28:14.540] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:14.540] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.540] - globals: [2] ‘a’, ‘ii’
[08:28:14.540] 
[08:28:14.540] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.541] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.541] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.543] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.543] Searching for globals ... DONE
[08:28:14.543] Resolving globals: TRUE
[08:28:14.543] Resolving any globals that are futures ...
[08:28:14.543] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:14.543] Resolving any globals that are futures ... DONE
[08:28:14.544] Resolving futures part of globals (recursively) ...
[08:28:14.544] resolve() on list ...
[08:28:14.544]  recursive: 99
[08:28:14.544]  length: 2
[08:28:14.544]  elements: ‘a’, ‘ii’
[08:28:14.544]  length: 1 (resolved future 1)
[08:28:14.544]  length: 0 (resolved future 2)
[08:28:14.544] resolve() on list ... DONE
[08:28:14.544] - globals: [2] ‘a’, ‘ii’
[08:28:14.544] Resolving futures part of globals (recursively) ... DONE
[08:28:14.545] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:14.546] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.546] - globals: [2] ‘a’, ‘ii’
[08:28:14.546] 
[08:28:14.546] getGlobalsAndPackages() ... DONE
[08:28:14.547] run() for ‘Future’ ...
[08:28:14.547] - state: ‘created’
[08:28:14.547] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.547] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.547] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.547]   - Field: ‘label’
[08:28:14.547]   - Field: ‘local’
[08:28:14.548]   - Field: ‘owner’
[08:28:14.548]   - Field: ‘envir’
[08:28:14.548]   - Field: ‘packages’
[08:28:14.548]   - Field: ‘gc’
[08:28:14.548]   - Field: ‘conditions’
[08:28:14.548]   - Field: ‘expr’
[08:28:14.548]   - Field: ‘uuid’
[08:28:14.548]   - Field: ‘seed’
[08:28:14.549]   - Field: ‘version’
[08:28:14.549]   - Field: ‘result’
[08:28:14.549]   - Field: ‘asynchronous’
[08:28:14.549]   - Field: ‘calls’
[08:28:14.549]   - Field: ‘globals’
[08:28:14.549]   - Field: ‘stdout’
[08:28:14.549]   - Field: ‘earlySignal’
[08:28:14.549]   - Field: ‘lazy’
[08:28:14.549]   - Field: ‘state’
[08:28:14.549] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.549] - Launch lazy future ...
[08:28:14.549] Packages needed by the future expression (n = 0): <none>
[08:28:14.550] Packages needed by future strategies (n = 0): <none>
[08:28:14.550] {
[08:28:14.550]     {
[08:28:14.550]         {
[08:28:14.550]             ...future.startTime <- base::Sys.time()
[08:28:14.550]             {
[08:28:14.550]                 {
[08:28:14.550]                   {
[08:28:14.550]                     base::local({
[08:28:14.550]                       has_future <- base::requireNamespace("future", 
[08:28:14.550]                         quietly = TRUE)
[08:28:14.550]                       if (has_future) {
[08:28:14.550]                         ns <- base::getNamespace("future")
[08:28:14.550]                         version <- ns[[".package"]][["version"]]
[08:28:14.550]                         if (is.null(version)) 
[08:28:14.550]                           version <- utils::packageVersion("future")
[08:28:14.550]                       }
[08:28:14.550]                       else {
[08:28:14.550]                         version <- NULL
[08:28:14.550]                       }
[08:28:14.550]                       if (!has_future || version < "1.8.0") {
[08:28:14.550]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.550]                           "", base::R.version$version.string), 
[08:28:14.550]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.550]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.550]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.550]                             "release", "version")], collapse = " "), 
[08:28:14.550]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.550]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.550]                           info)
[08:28:14.550]                         info <- base::paste(info, collapse = "; ")
[08:28:14.550]                         if (!has_future) {
[08:28:14.550]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.550]                             info)
[08:28:14.550]                         }
[08:28:14.550]                         else {
[08:28:14.550]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.550]                             info, version)
[08:28:14.550]                         }
[08:28:14.550]                         base::stop(msg)
[08:28:14.550]                       }
[08:28:14.550]                     })
[08:28:14.550]                   }
[08:28:14.550]                   ...future.strategy.old <- future::plan("list")
[08:28:14.550]                   options(future.plan = NULL)
[08:28:14.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.550]                 }
[08:28:14.550]                 ...future.workdir <- getwd()
[08:28:14.550]             }
[08:28:14.550]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.550]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.550]         }
[08:28:14.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.550]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.550]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.550]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.550]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.550]             base::names(...future.oldOptions))
[08:28:14.550]     }
[08:28:14.550]     if (FALSE) {
[08:28:14.550]     }
[08:28:14.550]     else {
[08:28:14.550]         if (TRUE) {
[08:28:14.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.550]                 open = "w")
[08:28:14.550]         }
[08:28:14.550]         else {
[08:28:14.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.550]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.550]         }
[08:28:14.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.550]             base::sink(type = "output", split = FALSE)
[08:28:14.550]             base::close(...future.stdout)
[08:28:14.550]         }, add = TRUE)
[08:28:14.550]     }
[08:28:14.550]     ...future.frame <- base::sys.nframe()
[08:28:14.550]     ...future.conditions <- base::list()
[08:28:14.550]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.550]     if (FALSE) {
[08:28:14.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.550]     }
[08:28:14.550]     ...future.result <- base::tryCatch({
[08:28:14.550]         base::withCallingHandlers({
[08:28:14.550]             ...future.value <- base::withVisible(base::local({
[08:28:14.550]                 b <- a * ii
[08:28:14.550]                 a <- 0
[08:28:14.550]                 b
[08:28:14.550]             }))
[08:28:14.550]             future::FutureResult(value = ...future.value$value, 
[08:28:14.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.550]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.550]                     ...future.globalenv.names))
[08:28:14.550]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.550]         }, condition = base::local({
[08:28:14.550]             c <- base::c
[08:28:14.550]             inherits <- base::inherits
[08:28:14.550]             invokeRestart <- base::invokeRestart
[08:28:14.550]             length <- base::length
[08:28:14.550]             list <- base::list
[08:28:14.550]             seq.int <- base::seq.int
[08:28:14.550]             signalCondition <- base::signalCondition
[08:28:14.550]             sys.calls <- base::sys.calls
[08:28:14.550]             `[[` <- base::`[[`
[08:28:14.550]             `+` <- base::`+`
[08:28:14.550]             `<<-` <- base::`<<-`
[08:28:14.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.550]                   3L)]
[08:28:14.550]             }
[08:28:14.550]             function(cond) {
[08:28:14.550]                 is_error <- inherits(cond, "error")
[08:28:14.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.550]                   NULL)
[08:28:14.550]                 if (is_error) {
[08:28:14.550]                   sessionInformation <- function() {
[08:28:14.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.550]                       search = base::search(), system = base::Sys.info())
[08:28:14.550]                   }
[08:28:14.550]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.550]                     cond$call), session = sessionInformation(), 
[08:28:14.550]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.550]                   signalCondition(cond)
[08:28:14.550]                 }
[08:28:14.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.550]                 "immediateCondition"))) {
[08:28:14.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.550]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.550]                   if (TRUE && !signal) {
[08:28:14.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.550]                     {
[08:28:14.550]                       inherits <- base::inherits
[08:28:14.550]                       invokeRestart <- base::invokeRestart
[08:28:14.550]                       is.null <- base::is.null
[08:28:14.550]                       muffled <- FALSE
[08:28:14.550]                       if (inherits(cond, "message")) {
[08:28:14.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.550]                         if (muffled) 
[08:28:14.550]                           invokeRestart("muffleMessage")
[08:28:14.550]                       }
[08:28:14.550]                       else if (inherits(cond, "warning")) {
[08:28:14.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.550]                         if (muffled) 
[08:28:14.550]                           invokeRestart("muffleWarning")
[08:28:14.550]                       }
[08:28:14.550]                       else if (inherits(cond, "condition")) {
[08:28:14.550]                         if (!is.null(pattern)) {
[08:28:14.550]                           computeRestarts <- base::computeRestarts
[08:28:14.550]                           grepl <- base::grepl
[08:28:14.550]                           restarts <- computeRestarts(cond)
[08:28:14.550]                           for (restart in restarts) {
[08:28:14.550]                             name <- restart$name
[08:28:14.550]                             if (is.null(name)) 
[08:28:14.550]                               next
[08:28:14.550]                             if (!grepl(pattern, name)) 
[08:28:14.550]                               next
[08:28:14.550]                             invokeRestart(restart)
[08:28:14.550]                             muffled <- TRUE
[08:28:14.550]                             break
[08:28:14.550]                           }
[08:28:14.550]                         }
[08:28:14.550]                       }
[08:28:14.550]                       invisible(muffled)
[08:28:14.550]                     }
[08:28:14.550]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.550]                   }
[08:28:14.550]                 }
[08:28:14.550]                 else {
[08:28:14.550]                   if (TRUE) {
[08:28:14.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.550]                     {
[08:28:14.550]                       inherits <- base::inherits
[08:28:14.550]                       invokeRestart <- base::invokeRestart
[08:28:14.550]                       is.null <- base::is.null
[08:28:14.550]                       muffled <- FALSE
[08:28:14.550]                       if (inherits(cond, "message")) {
[08:28:14.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.550]                         if (muffled) 
[08:28:14.550]                           invokeRestart("muffleMessage")
[08:28:14.550]                       }
[08:28:14.550]                       else if (inherits(cond, "warning")) {
[08:28:14.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.550]                         if (muffled) 
[08:28:14.550]                           invokeRestart("muffleWarning")
[08:28:14.550]                       }
[08:28:14.550]                       else if (inherits(cond, "condition")) {
[08:28:14.550]                         if (!is.null(pattern)) {
[08:28:14.550]                           computeRestarts <- base::computeRestarts
[08:28:14.550]                           grepl <- base::grepl
[08:28:14.550]                           restarts <- computeRestarts(cond)
[08:28:14.550]                           for (restart in restarts) {
[08:28:14.550]                             name <- restart$name
[08:28:14.550]                             if (is.null(name)) 
[08:28:14.550]                               next
[08:28:14.550]                             if (!grepl(pattern, name)) 
[08:28:14.550]                               next
[08:28:14.550]                             invokeRestart(restart)
[08:28:14.550]                             muffled <- TRUE
[08:28:14.550]                             break
[08:28:14.550]                           }
[08:28:14.550]                         }
[08:28:14.550]                       }
[08:28:14.550]                       invisible(muffled)
[08:28:14.550]                     }
[08:28:14.550]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.550]                   }
[08:28:14.550]                 }
[08:28:14.550]             }
[08:28:14.550]         }))
[08:28:14.550]     }, error = function(ex) {
[08:28:14.550]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.550]                 ...future.rng), started = ...future.startTime, 
[08:28:14.550]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.550]             version = "1.8"), class = "FutureResult")
[08:28:14.550]     }, finally = {
[08:28:14.550]         if (!identical(...future.workdir, getwd())) 
[08:28:14.550]             setwd(...future.workdir)
[08:28:14.550]         {
[08:28:14.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.550]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.550]             }
[08:28:14.550]             base::options(...future.oldOptions)
[08:28:14.550]             if (.Platform$OS.type == "windows") {
[08:28:14.550]                 old_names <- names(...future.oldEnvVars)
[08:28:14.550]                 envs <- base::Sys.getenv()
[08:28:14.550]                 names <- names(envs)
[08:28:14.550]                 common <- intersect(names, old_names)
[08:28:14.550]                 added <- setdiff(names, old_names)
[08:28:14.550]                 removed <- setdiff(old_names, names)
[08:28:14.550]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.550]                   envs[common]]
[08:28:14.550]                 NAMES <- toupper(changed)
[08:28:14.550]                 args <- list()
[08:28:14.550]                 for (kk in seq_along(NAMES)) {
[08:28:14.550]                   name <- changed[[kk]]
[08:28:14.550]                   NAME <- NAMES[[kk]]
[08:28:14.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.550]                     next
[08:28:14.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.550]                 }
[08:28:14.550]                 NAMES <- toupper(added)
[08:28:14.550]                 for (kk in seq_along(NAMES)) {
[08:28:14.550]                   name <- added[[kk]]
[08:28:14.550]                   NAME <- NAMES[[kk]]
[08:28:14.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.550]                     next
[08:28:14.550]                   args[[name]] <- ""
[08:28:14.550]                 }
[08:28:14.550]                 NAMES <- toupper(removed)
[08:28:14.550]                 for (kk in seq_along(NAMES)) {
[08:28:14.550]                   name <- removed[[kk]]
[08:28:14.550]                   NAME <- NAMES[[kk]]
[08:28:14.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.550]                     next
[08:28:14.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.550]                 }
[08:28:14.550]                 if (length(args) > 0) 
[08:28:14.550]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.550]             }
[08:28:14.550]             else {
[08:28:14.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.550]             }
[08:28:14.550]             {
[08:28:14.550]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.550]                   0L) {
[08:28:14.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.550]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.550]                   base::options(opts)
[08:28:14.550]                 }
[08:28:14.550]                 {
[08:28:14.550]                   {
[08:28:14.550]                     NULL
[08:28:14.550]                     RNGkind("Mersenne-Twister")
[08:28:14.550]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.550]                       inherits = FALSE)
[08:28:14.550]                   }
[08:28:14.550]                   options(future.plan = NULL)
[08:28:14.550]                   if (is.na(NA_character_)) 
[08:28:14.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.550]                     .init = FALSE)
[08:28:14.550]                 }
[08:28:14.550]             }
[08:28:14.550]         }
[08:28:14.550]     })
[08:28:14.550]     if (TRUE) {
[08:28:14.550]         base::sink(type = "output", split = FALSE)
[08:28:14.550]         if (TRUE) {
[08:28:14.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.550]         }
[08:28:14.550]         else {
[08:28:14.550]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.550]         }
[08:28:14.550]         base::close(...future.stdout)
[08:28:14.550]         ...future.stdout <- NULL
[08:28:14.550]     }
[08:28:14.550]     ...future.result$conditions <- ...future.conditions
[08:28:14.550]     ...future.result$finished <- base::Sys.time()
[08:28:14.550]     ...future.result
[08:28:14.550] }
[08:28:14.552] assign_globals() ...
[08:28:14.552] List of 2
[08:28:14.552]  $ a : num 1
[08:28:14.552]  $ ii: int 1
[08:28:14.552]  - attr(*, "where")=List of 2
[08:28:14.552]   ..$ a :<environment: R_EmptyEnv> 
[08:28:14.552]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.552]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.552]  - attr(*, "resolved")= logi TRUE
[08:28:14.552]  - attr(*, "total_size")= num 74
[08:28:14.552]  - attr(*, "already-done")= logi TRUE
[08:28:14.554] - copied ‘a’ to environment
[08:28:14.555] - copied ‘ii’ to environment
[08:28:14.555] assign_globals() ... done
[08:28:14.555] plan(): Setting new future strategy stack:
[08:28:14.555] List of future strategies:
[08:28:14.555] 1. sequential:
[08:28:14.555]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.555]    - tweaked: FALSE
[08:28:14.555]    - call: NULL
[08:28:14.555] plan(): nbrOfWorkers() = 1
[08:28:14.556] plan(): Setting new future strategy stack:
[08:28:14.556] List of future strategies:
[08:28:14.556] 1. sequential:
[08:28:14.556]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.556]    - tweaked: FALSE
[08:28:14.556]    - call: plan(strategy)
[08:28:14.557] plan(): nbrOfWorkers() = 1
[08:28:14.557] SequentialFuture started (and completed)
[08:28:14.557] - Launch lazy future ... done
[08:28:14.557] run() for ‘SequentialFuture’ ... done
[08:28:14.557] run() for ‘Future’ ...
[08:28:14.557] - state: ‘created’
[08:28:14.557] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.558] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.558] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.558]   - Field: ‘label’
[08:28:14.558]   - Field: ‘local’
[08:28:14.558]   - Field: ‘owner’
[08:28:14.558]   - Field: ‘envir’
[08:28:14.558]   - Field: ‘packages’
[08:28:14.558]   - Field: ‘gc’
[08:28:14.558]   - Field: ‘conditions’
[08:28:14.558]   - Field: ‘expr’
[08:28:14.559]   - Field: ‘uuid’
[08:28:14.559]   - Field: ‘seed’
[08:28:14.559]   - Field: ‘version’
[08:28:14.559]   - Field: ‘result’
[08:28:14.559]   - Field: ‘asynchronous’
[08:28:14.559]   - Field: ‘calls’
[08:28:14.559]   - Field: ‘globals’
[08:28:14.559]   - Field: ‘stdout’
[08:28:14.559]   - Field: ‘earlySignal’
[08:28:14.559]   - Field: ‘lazy’
[08:28:14.559]   - Field: ‘state’
[08:28:14.559] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.560] - Launch lazy future ...
[08:28:14.560] Packages needed by the future expression (n = 0): <none>
[08:28:14.560] Packages needed by future strategies (n = 0): <none>
[08:28:14.560] {
[08:28:14.560]     {
[08:28:14.560]         {
[08:28:14.560]             ...future.startTime <- base::Sys.time()
[08:28:14.560]             {
[08:28:14.560]                 {
[08:28:14.560]                   {
[08:28:14.560]                     base::local({
[08:28:14.560]                       has_future <- base::requireNamespace("future", 
[08:28:14.560]                         quietly = TRUE)
[08:28:14.560]                       if (has_future) {
[08:28:14.560]                         ns <- base::getNamespace("future")
[08:28:14.560]                         version <- ns[[".package"]][["version"]]
[08:28:14.560]                         if (is.null(version)) 
[08:28:14.560]                           version <- utils::packageVersion("future")
[08:28:14.560]                       }
[08:28:14.560]                       else {
[08:28:14.560]                         version <- NULL
[08:28:14.560]                       }
[08:28:14.560]                       if (!has_future || version < "1.8.0") {
[08:28:14.560]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.560]                           "", base::R.version$version.string), 
[08:28:14.560]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.560]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.560]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.560]                             "release", "version")], collapse = " "), 
[08:28:14.560]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.560]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.560]                           info)
[08:28:14.560]                         info <- base::paste(info, collapse = "; ")
[08:28:14.560]                         if (!has_future) {
[08:28:14.560]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.560]                             info)
[08:28:14.560]                         }
[08:28:14.560]                         else {
[08:28:14.560]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.560]                             info, version)
[08:28:14.560]                         }
[08:28:14.560]                         base::stop(msg)
[08:28:14.560]                       }
[08:28:14.560]                     })
[08:28:14.560]                   }
[08:28:14.560]                   ...future.strategy.old <- future::plan("list")
[08:28:14.560]                   options(future.plan = NULL)
[08:28:14.560]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.560]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.560]                 }
[08:28:14.560]                 ...future.workdir <- getwd()
[08:28:14.560]             }
[08:28:14.560]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.560]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.560]         }
[08:28:14.560]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.560]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.560]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.560]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.560]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.560]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.560]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.560]             base::names(...future.oldOptions))
[08:28:14.560]     }
[08:28:14.560]     if (FALSE) {
[08:28:14.560]     }
[08:28:14.560]     else {
[08:28:14.560]         if (TRUE) {
[08:28:14.560]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.560]                 open = "w")
[08:28:14.560]         }
[08:28:14.560]         else {
[08:28:14.560]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.560]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.560]         }
[08:28:14.560]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.560]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.560]             base::sink(type = "output", split = FALSE)
[08:28:14.560]             base::close(...future.stdout)
[08:28:14.560]         }, add = TRUE)
[08:28:14.560]     }
[08:28:14.560]     ...future.frame <- base::sys.nframe()
[08:28:14.560]     ...future.conditions <- base::list()
[08:28:14.560]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.560]     if (FALSE) {
[08:28:14.560]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.560]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.560]     }
[08:28:14.560]     ...future.result <- base::tryCatch({
[08:28:14.560]         base::withCallingHandlers({
[08:28:14.560]             ...future.value <- base::withVisible(base::local({
[08:28:14.560]                 b <- a * ii
[08:28:14.560]                 a <- 0
[08:28:14.560]                 b
[08:28:14.560]             }))
[08:28:14.560]             future::FutureResult(value = ...future.value$value, 
[08:28:14.560]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.560]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.560]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.560]                     ...future.globalenv.names))
[08:28:14.560]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.560]         }, condition = base::local({
[08:28:14.560]             c <- base::c
[08:28:14.560]             inherits <- base::inherits
[08:28:14.560]             invokeRestart <- base::invokeRestart
[08:28:14.560]             length <- base::length
[08:28:14.560]             list <- base::list
[08:28:14.560]             seq.int <- base::seq.int
[08:28:14.560]             signalCondition <- base::signalCondition
[08:28:14.560]             sys.calls <- base::sys.calls
[08:28:14.560]             `[[` <- base::`[[`
[08:28:14.560]             `+` <- base::`+`
[08:28:14.560]             `<<-` <- base::`<<-`
[08:28:14.560]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.560]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.560]                   3L)]
[08:28:14.560]             }
[08:28:14.560]             function(cond) {
[08:28:14.560]                 is_error <- inherits(cond, "error")
[08:28:14.560]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.560]                   NULL)
[08:28:14.560]                 if (is_error) {
[08:28:14.560]                   sessionInformation <- function() {
[08:28:14.560]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.560]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.560]                       search = base::search(), system = base::Sys.info())
[08:28:14.560]                   }
[08:28:14.560]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.560]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.560]                     cond$call), session = sessionInformation(), 
[08:28:14.560]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.560]                   signalCondition(cond)
[08:28:14.560]                 }
[08:28:14.560]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.560]                 "immediateCondition"))) {
[08:28:14.560]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.560]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.560]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.560]                   if (TRUE && !signal) {
[08:28:14.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.560]                     {
[08:28:14.560]                       inherits <- base::inherits
[08:28:14.560]                       invokeRestart <- base::invokeRestart
[08:28:14.560]                       is.null <- base::is.null
[08:28:14.560]                       muffled <- FALSE
[08:28:14.560]                       if (inherits(cond, "message")) {
[08:28:14.560]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.560]                         if (muffled) 
[08:28:14.560]                           invokeRestart("muffleMessage")
[08:28:14.560]                       }
[08:28:14.560]                       else if (inherits(cond, "warning")) {
[08:28:14.560]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.560]                         if (muffled) 
[08:28:14.560]                           invokeRestart("muffleWarning")
[08:28:14.560]                       }
[08:28:14.560]                       else if (inherits(cond, "condition")) {
[08:28:14.560]                         if (!is.null(pattern)) {
[08:28:14.560]                           computeRestarts <- base::computeRestarts
[08:28:14.560]                           grepl <- base::grepl
[08:28:14.560]                           restarts <- computeRestarts(cond)
[08:28:14.560]                           for (restart in restarts) {
[08:28:14.560]                             name <- restart$name
[08:28:14.560]                             if (is.null(name)) 
[08:28:14.560]                               next
[08:28:14.560]                             if (!grepl(pattern, name)) 
[08:28:14.560]                               next
[08:28:14.560]                             invokeRestart(restart)
[08:28:14.560]                             muffled <- TRUE
[08:28:14.560]                             break
[08:28:14.560]                           }
[08:28:14.560]                         }
[08:28:14.560]                       }
[08:28:14.560]                       invisible(muffled)
[08:28:14.560]                     }
[08:28:14.560]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.560]                   }
[08:28:14.560]                 }
[08:28:14.560]                 else {
[08:28:14.560]                   if (TRUE) {
[08:28:14.560]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.560]                     {
[08:28:14.560]                       inherits <- base::inherits
[08:28:14.560]                       invokeRestart <- base::invokeRestart
[08:28:14.560]                       is.null <- base::is.null
[08:28:14.560]                       muffled <- FALSE
[08:28:14.560]                       if (inherits(cond, "message")) {
[08:28:14.560]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.560]                         if (muffled) 
[08:28:14.560]                           invokeRestart("muffleMessage")
[08:28:14.560]                       }
[08:28:14.560]                       else if (inherits(cond, "warning")) {
[08:28:14.560]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.560]                         if (muffled) 
[08:28:14.560]                           invokeRestart("muffleWarning")
[08:28:14.560]                       }
[08:28:14.560]                       else if (inherits(cond, "condition")) {
[08:28:14.560]                         if (!is.null(pattern)) {
[08:28:14.560]                           computeRestarts <- base::computeRestarts
[08:28:14.560]                           grepl <- base::grepl
[08:28:14.560]                           restarts <- computeRestarts(cond)
[08:28:14.560]                           for (restart in restarts) {
[08:28:14.560]                             name <- restart$name
[08:28:14.560]                             if (is.null(name)) 
[08:28:14.560]                               next
[08:28:14.560]                             if (!grepl(pattern, name)) 
[08:28:14.560]                               next
[08:28:14.560]                             invokeRestart(restart)
[08:28:14.560]                             muffled <- TRUE
[08:28:14.560]                             break
[08:28:14.560]                           }
[08:28:14.560]                         }
[08:28:14.560]                       }
[08:28:14.560]                       invisible(muffled)
[08:28:14.560]                     }
[08:28:14.560]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.560]                   }
[08:28:14.560]                 }
[08:28:14.560]             }
[08:28:14.560]         }))
[08:28:14.560]     }, error = function(ex) {
[08:28:14.560]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.560]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.560]                 ...future.rng), started = ...future.startTime, 
[08:28:14.560]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.560]             version = "1.8"), class = "FutureResult")
[08:28:14.560]     }, finally = {
[08:28:14.560]         if (!identical(...future.workdir, getwd())) 
[08:28:14.560]             setwd(...future.workdir)
[08:28:14.560]         {
[08:28:14.560]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.560]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.560]             }
[08:28:14.560]             base::options(...future.oldOptions)
[08:28:14.560]             if (.Platform$OS.type == "windows") {
[08:28:14.560]                 old_names <- names(...future.oldEnvVars)
[08:28:14.560]                 envs <- base::Sys.getenv()
[08:28:14.560]                 names <- names(envs)
[08:28:14.560]                 common <- intersect(names, old_names)
[08:28:14.560]                 added <- setdiff(names, old_names)
[08:28:14.560]                 removed <- setdiff(old_names, names)
[08:28:14.560]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.560]                   envs[common]]
[08:28:14.560]                 NAMES <- toupper(changed)
[08:28:14.560]                 args <- list()
[08:28:14.560]                 for (kk in seq_along(NAMES)) {
[08:28:14.560]                   name <- changed[[kk]]
[08:28:14.560]                   NAME <- NAMES[[kk]]
[08:28:14.560]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.560]                     next
[08:28:14.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.560]                 }
[08:28:14.560]                 NAMES <- toupper(added)
[08:28:14.560]                 for (kk in seq_along(NAMES)) {
[08:28:14.560]                   name <- added[[kk]]
[08:28:14.560]                   NAME <- NAMES[[kk]]
[08:28:14.560]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.560]                     next
[08:28:14.560]                   args[[name]] <- ""
[08:28:14.560]                 }
[08:28:14.560]                 NAMES <- toupper(removed)
[08:28:14.560]                 for (kk in seq_along(NAMES)) {
[08:28:14.560]                   name <- removed[[kk]]
[08:28:14.560]                   NAME <- NAMES[[kk]]
[08:28:14.560]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.560]                     next
[08:28:14.560]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.560]                 }
[08:28:14.560]                 if (length(args) > 0) 
[08:28:14.560]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.560]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.560]             }
[08:28:14.560]             else {
[08:28:14.560]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.560]             }
[08:28:14.560]             {
[08:28:14.560]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.560]                   0L) {
[08:28:14.560]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.560]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.560]                   base::options(opts)
[08:28:14.560]                 }
[08:28:14.560]                 {
[08:28:14.560]                   {
[08:28:14.560]                     NULL
[08:28:14.560]                     RNGkind("Mersenne-Twister")
[08:28:14.560]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.560]                       inherits = FALSE)
[08:28:14.560]                   }
[08:28:14.560]                   options(future.plan = NULL)
[08:28:14.560]                   if (is.na(NA_character_)) 
[08:28:14.560]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.560]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.560]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.560]                     .init = FALSE)
[08:28:14.560]                 }
[08:28:14.560]             }
[08:28:14.560]         }
[08:28:14.560]     })
[08:28:14.560]     if (TRUE) {
[08:28:14.560]         base::sink(type = "output", split = FALSE)
[08:28:14.560]         if (TRUE) {
[08:28:14.560]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.560]         }
[08:28:14.560]         else {
[08:28:14.560]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.560]         }
[08:28:14.560]         base::close(...future.stdout)
[08:28:14.560]         ...future.stdout <- NULL
[08:28:14.560]     }
[08:28:14.560]     ...future.result$conditions <- ...future.conditions
[08:28:14.560]     ...future.result$finished <- base::Sys.time()
[08:28:14.560]     ...future.result
[08:28:14.560] }
[08:28:14.562] assign_globals() ...
[08:28:14.562] List of 2
[08:28:14.562]  $ a : num 1
[08:28:14.562]  $ ii: int 2
[08:28:14.562]  - attr(*, "where")=List of 2
[08:28:14.562]   ..$ a :<environment: R_EmptyEnv> 
[08:28:14.562]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.562]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.562]  - attr(*, "resolved")= logi TRUE
[08:28:14.562]  - attr(*, "total_size")= num 74
[08:28:14.562]  - attr(*, "already-done")= logi TRUE
[08:28:14.565] - copied ‘a’ to environment
[08:28:14.565] - copied ‘ii’ to environment
[08:28:14.565] assign_globals() ... done
[08:28:14.565] plan(): Setting new future strategy stack:
[08:28:14.565] List of future strategies:
[08:28:14.565] 1. sequential:
[08:28:14.565]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.565]    - tweaked: FALSE
[08:28:14.565]    - call: NULL
[08:28:14.566] plan(): nbrOfWorkers() = 1
[08:28:14.566] plan(): Setting new future strategy stack:
[08:28:14.566] List of future strategies:
[08:28:14.566] 1. sequential:
[08:28:14.566]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.566]    - tweaked: FALSE
[08:28:14.566]    - call: plan(strategy)
[08:28:14.567] plan(): nbrOfWorkers() = 1
[08:28:14.567] SequentialFuture started (and completed)
[08:28:14.567] - Launch lazy future ... done
[08:28:14.567] run() for ‘SequentialFuture’ ... done
[08:28:14.567] run() for ‘Future’ ...
[08:28:14.567] - state: ‘created’
[08:28:14.568] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.568] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.568] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.568]   - Field: ‘label’
[08:28:14.568]   - Field: ‘local’
[08:28:14.568]   - Field: ‘owner’
[08:28:14.568]   - Field: ‘envir’
[08:28:14.568]   - Field: ‘packages’
[08:28:14.568]   - Field: ‘gc’
[08:28:14.569]   - Field: ‘conditions’
[08:28:14.569]   - Field: ‘expr’
[08:28:14.569]   - Field: ‘uuid’
[08:28:14.569]   - Field: ‘seed’
[08:28:14.569]   - Field: ‘version’
[08:28:14.569]   - Field: ‘result’
[08:28:14.569]   - Field: ‘asynchronous’
[08:28:14.569]   - Field: ‘calls’
[08:28:14.569]   - Field: ‘globals’
[08:28:14.569]   - Field: ‘stdout’
[08:28:14.569]   - Field: ‘earlySignal’
[08:28:14.569]   - Field: ‘lazy’
[08:28:14.570]   - Field: ‘state’
[08:28:14.570] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.570] - Launch lazy future ...
[08:28:14.571] Packages needed by the future expression (n = 0): <none>
[08:28:14.571] Packages needed by future strategies (n = 0): <none>
[08:28:14.572] {
[08:28:14.572]     {
[08:28:14.572]         {
[08:28:14.572]             ...future.startTime <- base::Sys.time()
[08:28:14.572]             {
[08:28:14.572]                 {
[08:28:14.572]                   {
[08:28:14.572]                     base::local({
[08:28:14.572]                       has_future <- base::requireNamespace("future", 
[08:28:14.572]                         quietly = TRUE)
[08:28:14.572]                       if (has_future) {
[08:28:14.572]                         ns <- base::getNamespace("future")
[08:28:14.572]                         version <- ns[[".package"]][["version"]]
[08:28:14.572]                         if (is.null(version)) 
[08:28:14.572]                           version <- utils::packageVersion("future")
[08:28:14.572]                       }
[08:28:14.572]                       else {
[08:28:14.572]                         version <- NULL
[08:28:14.572]                       }
[08:28:14.572]                       if (!has_future || version < "1.8.0") {
[08:28:14.572]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.572]                           "", base::R.version$version.string), 
[08:28:14.572]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.572]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.572]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.572]                             "release", "version")], collapse = " "), 
[08:28:14.572]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.572]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.572]                           info)
[08:28:14.572]                         info <- base::paste(info, collapse = "; ")
[08:28:14.572]                         if (!has_future) {
[08:28:14.572]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.572]                             info)
[08:28:14.572]                         }
[08:28:14.572]                         else {
[08:28:14.572]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.572]                             info, version)
[08:28:14.572]                         }
[08:28:14.572]                         base::stop(msg)
[08:28:14.572]                       }
[08:28:14.572]                     })
[08:28:14.572]                   }
[08:28:14.572]                   ...future.strategy.old <- future::plan("list")
[08:28:14.572]                   options(future.plan = NULL)
[08:28:14.572]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.572]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.572]                 }
[08:28:14.572]                 ...future.workdir <- getwd()
[08:28:14.572]             }
[08:28:14.572]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.572]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.572]         }
[08:28:14.572]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.572]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.572]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.572]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.572]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.572]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.572]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.572]             base::names(...future.oldOptions))
[08:28:14.572]     }
[08:28:14.572]     if (FALSE) {
[08:28:14.572]     }
[08:28:14.572]     else {
[08:28:14.572]         if (TRUE) {
[08:28:14.572]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.572]                 open = "w")
[08:28:14.572]         }
[08:28:14.572]         else {
[08:28:14.572]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.572]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.572]         }
[08:28:14.572]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.572]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.572]             base::sink(type = "output", split = FALSE)
[08:28:14.572]             base::close(...future.stdout)
[08:28:14.572]         }, add = TRUE)
[08:28:14.572]     }
[08:28:14.572]     ...future.frame <- base::sys.nframe()
[08:28:14.572]     ...future.conditions <- base::list()
[08:28:14.572]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.572]     if (FALSE) {
[08:28:14.572]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.572]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.572]     }
[08:28:14.572]     ...future.result <- base::tryCatch({
[08:28:14.572]         base::withCallingHandlers({
[08:28:14.572]             ...future.value <- base::withVisible(base::local({
[08:28:14.572]                 b <- a * ii
[08:28:14.572]                 a <- 0
[08:28:14.572]                 b
[08:28:14.572]             }))
[08:28:14.572]             future::FutureResult(value = ...future.value$value, 
[08:28:14.572]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.572]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.572]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.572]                     ...future.globalenv.names))
[08:28:14.572]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.572]         }, condition = base::local({
[08:28:14.572]             c <- base::c
[08:28:14.572]             inherits <- base::inherits
[08:28:14.572]             invokeRestart <- base::invokeRestart
[08:28:14.572]             length <- base::length
[08:28:14.572]             list <- base::list
[08:28:14.572]             seq.int <- base::seq.int
[08:28:14.572]             signalCondition <- base::signalCondition
[08:28:14.572]             sys.calls <- base::sys.calls
[08:28:14.572]             `[[` <- base::`[[`
[08:28:14.572]             `+` <- base::`+`
[08:28:14.572]             `<<-` <- base::`<<-`
[08:28:14.572]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.572]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.572]                   3L)]
[08:28:14.572]             }
[08:28:14.572]             function(cond) {
[08:28:14.572]                 is_error <- inherits(cond, "error")
[08:28:14.572]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.572]                   NULL)
[08:28:14.572]                 if (is_error) {
[08:28:14.572]                   sessionInformation <- function() {
[08:28:14.572]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.572]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.572]                       search = base::search(), system = base::Sys.info())
[08:28:14.572]                   }
[08:28:14.572]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.572]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.572]                     cond$call), session = sessionInformation(), 
[08:28:14.572]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.572]                   signalCondition(cond)
[08:28:14.572]                 }
[08:28:14.572]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.572]                 "immediateCondition"))) {
[08:28:14.572]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.572]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.572]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.572]                   if (TRUE && !signal) {
[08:28:14.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.572]                     {
[08:28:14.572]                       inherits <- base::inherits
[08:28:14.572]                       invokeRestart <- base::invokeRestart
[08:28:14.572]                       is.null <- base::is.null
[08:28:14.572]                       muffled <- FALSE
[08:28:14.572]                       if (inherits(cond, "message")) {
[08:28:14.572]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.572]                         if (muffled) 
[08:28:14.572]                           invokeRestart("muffleMessage")
[08:28:14.572]                       }
[08:28:14.572]                       else if (inherits(cond, "warning")) {
[08:28:14.572]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.572]                         if (muffled) 
[08:28:14.572]                           invokeRestart("muffleWarning")
[08:28:14.572]                       }
[08:28:14.572]                       else if (inherits(cond, "condition")) {
[08:28:14.572]                         if (!is.null(pattern)) {
[08:28:14.572]                           computeRestarts <- base::computeRestarts
[08:28:14.572]                           grepl <- base::grepl
[08:28:14.572]                           restarts <- computeRestarts(cond)
[08:28:14.572]                           for (restart in restarts) {
[08:28:14.572]                             name <- restart$name
[08:28:14.572]                             if (is.null(name)) 
[08:28:14.572]                               next
[08:28:14.572]                             if (!grepl(pattern, name)) 
[08:28:14.572]                               next
[08:28:14.572]                             invokeRestart(restart)
[08:28:14.572]                             muffled <- TRUE
[08:28:14.572]                             break
[08:28:14.572]                           }
[08:28:14.572]                         }
[08:28:14.572]                       }
[08:28:14.572]                       invisible(muffled)
[08:28:14.572]                     }
[08:28:14.572]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.572]                   }
[08:28:14.572]                 }
[08:28:14.572]                 else {
[08:28:14.572]                   if (TRUE) {
[08:28:14.572]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.572]                     {
[08:28:14.572]                       inherits <- base::inherits
[08:28:14.572]                       invokeRestart <- base::invokeRestart
[08:28:14.572]                       is.null <- base::is.null
[08:28:14.572]                       muffled <- FALSE
[08:28:14.572]                       if (inherits(cond, "message")) {
[08:28:14.572]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.572]                         if (muffled) 
[08:28:14.572]                           invokeRestart("muffleMessage")
[08:28:14.572]                       }
[08:28:14.572]                       else if (inherits(cond, "warning")) {
[08:28:14.572]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.572]                         if (muffled) 
[08:28:14.572]                           invokeRestart("muffleWarning")
[08:28:14.572]                       }
[08:28:14.572]                       else if (inherits(cond, "condition")) {
[08:28:14.572]                         if (!is.null(pattern)) {
[08:28:14.572]                           computeRestarts <- base::computeRestarts
[08:28:14.572]                           grepl <- base::grepl
[08:28:14.572]                           restarts <- computeRestarts(cond)
[08:28:14.572]                           for (restart in restarts) {
[08:28:14.572]                             name <- restart$name
[08:28:14.572]                             if (is.null(name)) 
[08:28:14.572]                               next
[08:28:14.572]                             if (!grepl(pattern, name)) 
[08:28:14.572]                               next
[08:28:14.572]                             invokeRestart(restart)
[08:28:14.572]                             muffled <- TRUE
[08:28:14.572]                             break
[08:28:14.572]                           }
[08:28:14.572]                         }
[08:28:14.572]                       }
[08:28:14.572]                       invisible(muffled)
[08:28:14.572]                     }
[08:28:14.572]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.572]                   }
[08:28:14.572]                 }
[08:28:14.572]             }
[08:28:14.572]         }))
[08:28:14.572]     }, error = function(ex) {
[08:28:14.572]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.572]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.572]                 ...future.rng), started = ...future.startTime, 
[08:28:14.572]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.572]             version = "1.8"), class = "FutureResult")
[08:28:14.572]     }, finally = {
[08:28:14.572]         if (!identical(...future.workdir, getwd())) 
[08:28:14.572]             setwd(...future.workdir)
[08:28:14.572]         {
[08:28:14.572]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.572]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.572]             }
[08:28:14.572]             base::options(...future.oldOptions)
[08:28:14.572]             if (.Platform$OS.type == "windows") {
[08:28:14.572]                 old_names <- names(...future.oldEnvVars)
[08:28:14.572]                 envs <- base::Sys.getenv()
[08:28:14.572]                 names <- names(envs)
[08:28:14.572]                 common <- intersect(names, old_names)
[08:28:14.572]                 added <- setdiff(names, old_names)
[08:28:14.572]                 removed <- setdiff(old_names, names)
[08:28:14.572]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.572]                   envs[common]]
[08:28:14.572]                 NAMES <- toupper(changed)
[08:28:14.572]                 args <- list()
[08:28:14.572]                 for (kk in seq_along(NAMES)) {
[08:28:14.572]                   name <- changed[[kk]]
[08:28:14.572]                   NAME <- NAMES[[kk]]
[08:28:14.572]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.572]                     next
[08:28:14.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.572]                 }
[08:28:14.572]                 NAMES <- toupper(added)
[08:28:14.572]                 for (kk in seq_along(NAMES)) {
[08:28:14.572]                   name <- added[[kk]]
[08:28:14.572]                   NAME <- NAMES[[kk]]
[08:28:14.572]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.572]                     next
[08:28:14.572]                   args[[name]] <- ""
[08:28:14.572]                 }
[08:28:14.572]                 NAMES <- toupper(removed)
[08:28:14.572]                 for (kk in seq_along(NAMES)) {
[08:28:14.572]                   name <- removed[[kk]]
[08:28:14.572]                   NAME <- NAMES[[kk]]
[08:28:14.572]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.572]                     next
[08:28:14.572]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.572]                 }
[08:28:14.572]                 if (length(args) > 0) 
[08:28:14.572]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.572]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.572]             }
[08:28:14.572]             else {
[08:28:14.572]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.572]             }
[08:28:14.572]             {
[08:28:14.572]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.572]                   0L) {
[08:28:14.572]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.572]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.572]                   base::options(opts)
[08:28:14.572]                 }
[08:28:14.572]                 {
[08:28:14.572]                   {
[08:28:14.572]                     NULL
[08:28:14.572]                     RNGkind("Mersenne-Twister")
[08:28:14.572]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.572]                       inherits = FALSE)
[08:28:14.572]                   }
[08:28:14.572]                   options(future.plan = NULL)
[08:28:14.572]                   if (is.na(NA_character_)) 
[08:28:14.572]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.572]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.572]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.572]                     .init = FALSE)
[08:28:14.572]                 }
[08:28:14.572]             }
[08:28:14.572]         }
[08:28:14.572]     })
[08:28:14.572]     if (TRUE) {
[08:28:14.572]         base::sink(type = "output", split = FALSE)
[08:28:14.572]         if (TRUE) {
[08:28:14.572]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.572]         }
[08:28:14.572]         else {
[08:28:14.572]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.572]         }
[08:28:14.572]         base::close(...future.stdout)
[08:28:14.572]         ...future.stdout <- NULL
[08:28:14.572]     }
[08:28:14.572]     ...future.result$conditions <- ...future.conditions
[08:28:14.572]     ...future.result$finished <- base::Sys.time()
[08:28:14.572]     ...future.result
[08:28:14.572] }
[08:28:14.573] assign_globals() ...
[08:28:14.573] List of 2
[08:28:14.573]  $ a : num 1
[08:28:14.573]  $ ii: int 3
[08:28:14.573]  - attr(*, "where")=List of 2
[08:28:14.573]   ..$ a :<environment: R_EmptyEnv> 
[08:28:14.573]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.573]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.573]  - attr(*, "resolved")= logi TRUE
[08:28:14.573]  - attr(*, "total_size")= num 74
[08:28:14.573]  - attr(*, "already-done")= logi TRUE
[08:28:14.576] - copied ‘a’ to environment
[08:28:14.576] - copied ‘ii’ to environment
[08:28:14.576] assign_globals() ... done
[08:28:14.577] plan(): Setting new future strategy stack:
[08:28:14.577] List of future strategies:
[08:28:14.577] 1. sequential:
[08:28:14.577]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.577]    - tweaked: FALSE
[08:28:14.577]    - call: NULL
[08:28:14.577] plan(): nbrOfWorkers() = 1
[08:28:14.578] plan(): Setting new future strategy stack:
[08:28:14.578] List of future strategies:
[08:28:14.578] 1. sequential:
[08:28:14.578]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.578]    - tweaked: FALSE
[08:28:14.578]    - call: plan(strategy)
[08:28:14.578] plan(): nbrOfWorkers() = 1
[08:28:14.579] SequentialFuture started (and completed)
[08:28:14.579] - Launch lazy future ... done
[08:28:14.579] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.579] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.579] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.580] 
[08:28:14.580] Searching for globals ... DONE
[08:28:14.580] - globals: [0] <none>
[08:28:14.580] getGlobalsAndPackages() ... DONE
[08:28:14.580] run() for ‘Future’ ...
[08:28:14.580] - state: ‘created’
[08:28:14.580] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.581] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.581] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.581]   - Field: ‘label’
[08:28:14.581]   - Field: ‘local’
[08:28:14.581]   - Field: ‘owner’
[08:28:14.581]   - Field: ‘envir’
[08:28:14.581]   - Field: ‘packages’
[08:28:14.581]   - Field: ‘gc’
[08:28:14.581]   - Field: ‘conditions’
[08:28:14.581]   - Field: ‘expr’
[08:28:14.581]   - Field: ‘uuid’
[08:28:14.581]   - Field: ‘seed’
[08:28:14.582]   - Field: ‘version’
[08:28:14.582]   - Field: ‘result’
[08:28:14.582]   - Field: ‘asynchronous’
[08:28:14.582]   - Field: ‘calls’
[08:28:14.582]   - Field: ‘globals’
[08:28:14.582]   - Field: ‘stdout’
[08:28:14.582]   - Field: ‘earlySignal’
[08:28:14.582]   - Field: ‘lazy’
[08:28:14.582]   - Field: ‘state’
[08:28:14.582] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.582] - Launch lazy future ...
[08:28:14.583] Packages needed by the future expression (n = 0): <none>
[08:28:14.583] Packages needed by future strategies (n = 0): <none>
[08:28:14.583] {
[08:28:14.583]     {
[08:28:14.583]         {
[08:28:14.583]             ...future.startTime <- base::Sys.time()
[08:28:14.583]             {
[08:28:14.583]                 {
[08:28:14.583]                   {
[08:28:14.583]                     base::local({
[08:28:14.583]                       has_future <- base::requireNamespace("future", 
[08:28:14.583]                         quietly = TRUE)
[08:28:14.583]                       if (has_future) {
[08:28:14.583]                         ns <- base::getNamespace("future")
[08:28:14.583]                         version <- ns[[".package"]][["version"]]
[08:28:14.583]                         if (is.null(version)) 
[08:28:14.583]                           version <- utils::packageVersion("future")
[08:28:14.583]                       }
[08:28:14.583]                       else {
[08:28:14.583]                         version <- NULL
[08:28:14.583]                       }
[08:28:14.583]                       if (!has_future || version < "1.8.0") {
[08:28:14.583]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.583]                           "", base::R.version$version.string), 
[08:28:14.583]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.583]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.583]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.583]                             "release", "version")], collapse = " "), 
[08:28:14.583]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.583]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.583]                           info)
[08:28:14.583]                         info <- base::paste(info, collapse = "; ")
[08:28:14.583]                         if (!has_future) {
[08:28:14.583]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.583]                             info)
[08:28:14.583]                         }
[08:28:14.583]                         else {
[08:28:14.583]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.583]                             info, version)
[08:28:14.583]                         }
[08:28:14.583]                         base::stop(msg)
[08:28:14.583]                       }
[08:28:14.583]                     })
[08:28:14.583]                   }
[08:28:14.583]                   ...future.strategy.old <- future::plan("list")
[08:28:14.583]                   options(future.plan = NULL)
[08:28:14.583]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.583]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.583]                 }
[08:28:14.583]                 ...future.workdir <- getwd()
[08:28:14.583]             }
[08:28:14.583]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.583]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.583]         }
[08:28:14.583]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.583]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.583]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.583]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.583]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.583]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.583]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.583]             base::names(...future.oldOptions))
[08:28:14.583]     }
[08:28:14.583]     if (FALSE) {
[08:28:14.583]     }
[08:28:14.583]     else {
[08:28:14.583]         if (TRUE) {
[08:28:14.583]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.583]                 open = "w")
[08:28:14.583]         }
[08:28:14.583]         else {
[08:28:14.583]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.583]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.583]         }
[08:28:14.583]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.583]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.583]             base::sink(type = "output", split = FALSE)
[08:28:14.583]             base::close(...future.stdout)
[08:28:14.583]         }, add = TRUE)
[08:28:14.583]     }
[08:28:14.583]     ...future.frame <- base::sys.nframe()
[08:28:14.583]     ...future.conditions <- base::list()
[08:28:14.583]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.583]     if (FALSE) {
[08:28:14.583]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.583]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.583]     }
[08:28:14.583]     ...future.result <- base::tryCatch({
[08:28:14.583]         base::withCallingHandlers({
[08:28:14.583]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.583]             future::FutureResult(value = ...future.value$value, 
[08:28:14.583]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.583]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.583]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.583]                     ...future.globalenv.names))
[08:28:14.583]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.583]         }, condition = base::local({
[08:28:14.583]             c <- base::c
[08:28:14.583]             inherits <- base::inherits
[08:28:14.583]             invokeRestart <- base::invokeRestart
[08:28:14.583]             length <- base::length
[08:28:14.583]             list <- base::list
[08:28:14.583]             seq.int <- base::seq.int
[08:28:14.583]             signalCondition <- base::signalCondition
[08:28:14.583]             sys.calls <- base::sys.calls
[08:28:14.583]             `[[` <- base::`[[`
[08:28:14.583]             `+` <- base::`+`
[08:28:14.583]             `<<-` <- base::`<<-`
[08:28:14.583]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.583]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.583]                   3L)]
[08:28:14.583]             }
[08:28:14.583]             function(cond) {
[08:28:14.583]                 is_error <- inherits(cond, "error")
[08:28:14.583]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.583]                   NULL)
[08:28:14.583]                 if (is_error) {
[08:28:14.583]                   sessionInformation <- function() {
[08:28:14.583]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.583]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.583]                       search = base::search(), system = base::Sys.info())
[08:28:14.583]                   }
[08:28:14.583]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.583]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.583]                     cond$call), session = sessionInformation(), 
[08:28:14.583]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.583]                   signalCondition(cond)
[08:28:14.583]                 }
[08:28:14.583]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.583]                 "immediateCondition"))) {
[08:28:14.583]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.583]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.583]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.583]                   if (TRUE && !signal) {
[08:28:14.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.583]                     {
[08:28:14.583]                       inherits <- base::inherits
[08:28:14.583]                       invokeRestart <- base::invokeRestart
[08:28:14.583]                       is.null <- base::is.null
[08:28:14.583]                       muffled <- FALSE
[08:28:14.583]                       if (inherits(cond, "message")) {
[08:28:14.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.583]                         if (muffled) 
[08:28:14.583]                           invokeRestart("muffleMessage")
[08:28:14.583]                       }
[08:28:14.583]                       else if (inherits(cond, "warning")) {
[08:28:14.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.583]                         if (muffled) 
[08:28:14.583]                           invokeRestart("muffleWarning")
[08:28:14.583]                       }
[08:28:14.583]                       else if (inherits(cond, "condition")) {
[08:28:14.583]                         if (!is.null(pattern)) {
[08:28:14.583]                           computeRestarts <- base::computeRestarts
[08:28:14.583]                           grepl <- base::grepl
[08:28:14.583]                           restarts <- computeRestarts(cond)
[08:28:14.583]                           for (restart in restarts) {
[08:28:14.583]                             name <- restart$name
[08:28:14.583]                             if (is.null(name)) 
[08:28:14.583]                               next
[08:28:14.583]                             if (!grepl(pattern, name)) 
[08:28:14.583]                               next
[08:28:14.583]                             invokeRestart(restart)
[08:28:14.583]                             muffled <- TRUE
[08:28:14.583]                             break
[08:28:14.583]                           }
[08:28:14.583]                         }
[08:28:14.583]                       }
[08:28:14.583]                       invisible(muffled)
[08:28:14.583]                     }
[08:28:14.583]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.583]                   }
[08:28:14.583]                 }
[08:28:14.583]                 else {
[08:28:14.583]                   if (TRUE) {
[08:28:14.583]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.583]                     {
[08:28:14.583]                       inherits <- base::inherits
[08:28:14.583]                       invokeRestart <- base::invokeRestart
[08:28:14.583]                       is.null <- base::is.null
[08:28:14.583]                       muffled <- FALSE
[08:28:14.583]                       if (inherits(cond, "message")) {
[08:28:14.583]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.583]                         if (muffled) 
[08:28:14.583]                           invokeRestart("muffleMessage")
[08:28:14.583]                       }
[08:28:14.583]                       else if (inherits(cond, "warning")) {
[08:28:14.583]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.583]                         if (muffled) 
[08:28:14.583]                           invokeRestart("muffleWarning")
[08:28:14.583]                       }
[08:28:14.583]                       else if (inherits(cond, "condition")) {
[08:28:14.583]                         if (!is.null(pattern)) {
[08:28:14.583]                           computeRestarts <- base::computeRestarts
[08:28:14.583]                           grepl <- base::grepl
[08:28:14.583]                           restarts <- computeRestarts(cond)
[08:28:14.583]                           for (restart in restarts) {
[08:28:14.583]                             name <- restart$name
[08:28:14.583]                             if (is.null(name)) 
[08:28:14.583]                               next
[08:28:14.583]                             if (!grepl(pattern, name)) 
[08:28:14.583]                               next
[08:28:14.583]                             invokeRestart(restart)
[08:28:14.583]                             muffled <- TRUE
[08:28:14.583]                             break
[08:28:14.583]                           }
[08:28:14.583]                         }
[08:28:14.583]                       }
[08:28:14.583]                       invisible(muffled)
[08:28:14.583]                     }
[08:28:14.583]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.583]                   }
[08:28:14.583]                 }
[08:28:14.583]             }
[08:28:14.583]         }))
[08:28:14.583]     }, error = function(ex) {
[08:28:14.583]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.583]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.583]                 ...future.rng), started = ...future.startTime, 
[08:28:14.583]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.583]             version = "1.8"), class = "FutureResult")
[08:28:14.583]     }, finally = {
[08:28:14.583]         if (!identical(...future.workdir, getwd())) 
[08:28:14.583]             setwd(...future.workdir)
[08:28:14.583]         {
[08:28:14.583]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.583]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.583]             }
[08:28:14.583]             base::options(...future.oldOptions)
[08:28:14.583]             if (.Platform$OS.type == "windows") {
[08:28:14.583]                 old_names <- names(...future.oldEnvVars)
[08:28:14.583]                 envs <- base::Sys.getenv()
[08:28:14.583]                 names <- names(envs)
[08:28:14.583]                 common <- intersect(names, old_names)
[08:28:14.583]                 added <- setdiff(names, old_names)
[08:28:14.583]                 removed <- setdiff(old_names, names)
[08:28:14.583]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.583]                   envs[common]]
[08:28:14.583]                 NAMES <- toupper(changed)
[08:28:14.583]                 args <- list()
[08:28:14.583]                 for (kk in seq_along(NAMES)) {
[08:28:14.583]                   name <- changed[[kk]]
[08:28:14.583]                   NAME <- NAMES[[kk]]
[08:28:14.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.583]                     next
[08:28:14.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.583]                 }
[08:28:14.583]                 NAMES <- toupper(added)
[08:28:14.583]                 for (kk in seq_along(NAMES)) {
[08:28:14.583]                   name <- added[[kk]]
[08:28:14.583]                   NAME <- NAMES[[kk]]
[08:28:14.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.583]                     next
[08:28:14.583]                   args[[name]] <- ""
[08:28:14.583]                 }
[08:28:14.583]                 NAMES <- toupper(removed)
[08:28:14.583]                 for (kk in seq_along(NAMES)) {
[08:28:14.583]                   name <- removed[[kk]]
[08:28:14.583]                   NAME <- NAMES[[kk]]
[08:28:14.583]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.583]                     next
[08:28:14.583]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.583]                 }
[08:28:14.583]                 if (length(args) > 0) 
[08:28:14.583]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.583]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.583]             }
[08:28:14.583]             else {
[08:28:14.583]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.583]             }
[08:28:14.583]             {
[08:28:14.583]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.583]                   0L) {
[08:28:14.583]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.583]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.583]                   base::options(opts)
[08:28:14.583]                 }
[08:28:14.583]                 {
[08:28:14.583]                   {
[08:28:14.583]                     NULL
[08:28:14.583]                     RNGkind("Mersenne-Twister")
[08:28:14.583]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.583]                       inherits = FALSE)
[08:28:14.583]                   }
[08:28:14.583]                   options(future.plan = NULL)
[08:28:14.583]                   if (is.na(NA_character_)) 
[08:28:14.583]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.583]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.583]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.583]                     .init = FALSE)
[08:28:14.583]                 }
[08:28:14.583]             }
[08:28:14.583]         }
[08:28:14.583]     })
[08:28:14.583]     if (TRUE) {
[08:28:14.583]         base::sink(type = "output", split = FALSE)
[08:28:14.583]         if (TRUE) {
[08:28:14.583]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.583]         }
[08:28:14.583]         else {
[08:28:14.583]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.583]         }
[08:28:14.583]         base::close(...future.stdout)
[08:28:14.583]         ...future.stdout <- NULL
[08:28:14.583]     }
[08:28:14.583]     ...future.result$conditions <- ...future.conditions
[08:28:14.583]     ...future.result$finished <- base::Sys.time()
[08:28:14.583]     ...future.result
[08:28:14.583] }
[08:28:14.585] plan(): Setting new future strategy stack:
[08:28:14.585] List of future strategies:
[08:28:14.585] 1. sequential:
[08:28:14.585]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.585]    - tweaked: FALSE
[08:28:14.585]    - call: NULL
[08:28:14.585] plan(): nbrOfWorkers() = 1
[08:28:14.586] plan(): Setting new future strategy stack:
[08:28:14.586] List of future strategies:
[08:28:14.586] 1. sequential:
[08:28:14.586]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.586]    - tweaked: FALSE
[08:28:14.586]    - call: plan(strategy)
[08:28:14.586] plan(): nbrOfWorkers() = 1
[08:28:14.587] SequentialFuture started (and completed)
[08:28:14.587] - Launch lazy future ... done
[08:28:14.587] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.587] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.587] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.588] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.588] Searching for globals ... DONE
[08:28:14.588] Resolving globals: TRUE
[08:28:14.588] Resolving any globals that are futures ...
[08:28:14.588] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.588] Resolving any globals that are futures ... DONE
[08:28:14.589] Resolving futures part of globals (recursively) ...
[08:28:14.589] resolve() on list ...
[08:28:14.589]  recursive: 99
[08:28:14.589]  length: 1
[08:28:14.589]  elements: ‘a’
[08:28:14.589] resolved() for ‘SequentialFuture’ ...
[08:28:14.589] - state: ‘finished’
[08:28:14.589] - run: TRUE
[08:28:14.589] - result: ‘FutureResult’
[08:28:14.590] resolved() for ‘SequentialFuture’ ... done
[08:28:14.590] Future #1
[08:28:14.590] resolved() for ‘SequentialFuture’ ...
[08:28:14.590] - state: ‘finished’
[08:28:14.590] - run: TRUE
[08:28:14.590] - result: ‘FutureResult’
[08:28:14.590] resolved() for ‘SequentialFuture’ ... done
[08:28:14.590] A SequentialFuture was resolved
[08:28:14.590]  length: 0 (resolved future 1)
[08:28:14.590] resolve() on list ... DONE
[08:28:14.590] - globals: [1] ‘a’
[08:28:14.591] Resolving futures part of globals (recursively) ... DONE
[08:28:14.591] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[08:28:14.591] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[08:28:14.591] - globals: [1] ‘a’
[08:28:14.591] - packages: [1] ‘future’
[08:28:14.591] getGlobalsAndPackages() ... DONE
[08:28:14.592] run() for ‘Future’ ...
[08:28:14.592] - state: ‘created’
[08:28:14.592] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.592] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.592] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.592]   - Field: ‘label’
[08:28:14.592]   - Field: ‘local’
[08:28:14.592]   - Field: ‘owner’
[08:28:14.592]   - Field: ‘envir’
[08:28:14.593]   - Field: ‘packages’
[08:28:14.593]   - Field: ‘gc’
[08:28:14.593]   - Field: ‘conditions’
[08:28:14.593]   - Field: ‘expr’
[08:28:14.593]   - Field: ‘uuid’
[08:28:14.593]   - Field: ‘seed’
[08:28:14.593]   - Field: ‘version’
[08:28:14.593]   - Field: ‘result’
[08:28:14.593]   - Field: ‘asynchronous’
[08:28:14.593]   - Field: ‘calls’
[08:28:14.593]   - Field: ‘globals’
[08:28:14.593]   - Field: ‘stdout’
[08:28:14.594]   - Field: ‘earlySignal’
[08:28:14.594]   - Field: ‘lazy’
[08:28:14.594]   - Field: ‘state’
[08:28:14.594] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.594] - Launch lazy future ...
[08:28:14.594] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.594] Packages needed by future strategies (n = 0): <none>
[08:28:14.595] {
[08:28:14.595]     {
[08:28:14.595]         {
[08:28:14.595]             ...future.startTime <- base::Sys.time()
[08:28:14.595]             {
[08:28:14.595]                 {
[08:28:14.595]                   {
[08:28:14.595]                     {
[08:28:14.595]                       base::local({
[08:28:14.595]                         has_future <- base::requireNamespace("future", 
[08:28:14.595]                           quietly = TRUE)
[08:28:14.595]                         if (has_future) {
[08:28:14.595]                           ns <- base::getNamespace("future")
[08:28:14.595]                           version <- ns[[".package"]][["version"]]
[08:28:14.595]                           if (is.null(version)) 
[08:28:14.595]                             version <- utils::packageVersion("future")
[08:28:14.595]                         }
[08:28:14.595]                         else {
[08:28:14.595]                           version <- NULL
[08:28:14.595]                         }
[08:28:14.595]                         if (!has_future || version < "1.8.0") {
[08:28:14.595]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.595]                             "", base::R.version$version.string), 
[08:28:14.595]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.595]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.595]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.595]                               "release", "version")], collapse = " "), 
[08:28:14.595]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.595]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.595]                             info)
[08:28:14.595]                           info <- base::paste(info, collapse = "; ")
[08:28:14.595]                           if (!has_future) {
[08:28:14.595]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.595]                               info)
[08:28:14.595]                           }
[08:28:14.595]                           else {
[08:28:14.595]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.595]                               info, version)
[08:28:14.595]                           }
[08:28:14.595]                           base::stop(msg)
[08:28:14.595]                         }
[08:28:14.595]                       })
[08:28:14.595]                     }
[08:28:14.595]                     base::local({
[08:28:14.595]                       for (pkg in "future") {
[08:28:14.595]                         base::loadNamespace(pkg)
[08:28:14.595]                         base::library(pkg, character.only = TRUE)
[08:28:14.595]                       }
[08:28:14.595]                     })
[08:28:14.595]                   }
[08:28:14.595]                   ...future.strategy.old <- future::plan("list")
[08:28:14.595]                   options(future.plan = NULL)
[08:28:14.595]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.595]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.595]                 }
[08:28:14.595]                 ...future.workdir <- getwd()
[08:28:14.595]             }
[08:28:14.595]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.595]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.595]         }
[08:28:14.595]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.595]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.595]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.595]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.595]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.595]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.595]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.595]             base::names(...future.oldOptions))
[08:28:14.595]     }
[08:28:14.595]     if (FALSE) {
[08:28:14.595]     }
[08:28:14.595]     else {
[08:28:14.595]         if (TRUE) {
[08:28:14.595]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.595]                 open = "w")
[08:28:14.595]         }
[08:28:14.595]         else {
[08:28:14.595]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.595]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.595]         }
[08:28:14.595]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.595]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.595]             base::sink(type = "output", split = FALSE)
[08:28:14.595]             base::close(...future.stdout)
[08:28:14.595]         }, add = TRUE)
[08:28:14.595]     }
[08:28:14.595]     ...future.frame <- base::sys.nframe()
[08:28:14.595]     ...future.conditions <- base::list()
[08:28:14.595]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.595]     if (FALSE) {
[08:28:14.595]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.595]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.595]     }
[08:28:14.595]     ...future.result <- base::tryCatch({
[08:28:14.595]         base::withCallingHandlers({
[08:28:14.595]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.595]                 1))
[08:28:14.595]             future::FutureResult(value = ...future.value$value, 
[08:28:14.595]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.595]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.595]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.595]                     ...future.globalenv.names))
[08:28:14.595]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.595]         }, condition = base::local({
[08:28:14.595]             c <- base::c
[08:28:14.595]             inherits <- base::inherits
[08:28:14.595]             invokeRestart <- base::invokeRestart
[08:28:14.595]             length <- base::length
[08:28:14.595]             list <- base::list
[08:28:14.595]             seq.int <- base::seq.int
[08:28:14.595]             signalCondition <- base::signalCondition
[08:28:14.595]             sys.calls <- base::sys.calls
[08:28:14.595]             `[[` <- base::`[[`
[08:28:14.595]             `+` <- base::`+`
[08:28:14.595]             `<<-` <- base::`<<-`
[08:28:14.595]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.595]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.595]                   3L)]
[08:28:14.595]             }
[08:28:14.595]             function(cond) {
[08:28:14.595]                 is_error <- inherits(cond, "error")
[08:28:14.595]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.595]                   NULL)
[08:28:14.595]                 if (is_error) {
[08:28:14.595]                   sessionInformation <- function() {
[08:28:14.595]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.595]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.595]                       search = base::search(), system = base::Sys.info())
[08:28:14.595]                   }
[08:28:14.595]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.595]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.595]                     cond$call), session = sessionInformation(), 
[08:28:14.595]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.595]                   signalCondition(cond)
[08:28:14.595]                 }
[08:28:14.595]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.595]                 "immediateCondition"))) {
[08:28:14.595]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.595]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.595]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.595]                   if (TRUE && !signal) {
[08:28:14.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.595]                     {
[08:28:14.595]                       inherits <- base::inherits
[08:28:14.595]                       invokeRestart <- base::invokeRestart
[08:28:14.595]                       is.null <- base::is.null
[08:28:14.595]                       muffled <- FALSE
[08:28:14.595]                       if (inherits(cond, "message")) {
[08:28:14.595]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.595]                         if (muffled) 
[08:28:14.595]                           invokeRestart("muffleMessage")
[08:28:14.595]                       }
[08:28:14.595]                       else if (inherits(cond, "warning")) {
[08:28:14.595]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.595]                         if (muffled) 
[08:28:14.595]                           invokeRestart("muffleWarning")
[08:28:14.595]                       }
[08:28:14.595]                       else if (inherits(cond, "condition")) {
[08:28:14.595]                         if (!is.null(pattern)) {
[08:28:14.595]                           computeRestarts <- base::computeRestarts
[08:28:14.595]                           grepl <- base::grepl
[08:28:14.595]                           restarts <- computeRestarts(cond)
[08:28:14.595]                           for (restart in restarts) {
[08:28:14.595]                             name <- restart$name
[08:28:14.595]                             if (is.null(name)) 
[08:28:14.595]                               next
[08:28:14.595]                             if (!grepl(pattern, name)) 
[08:28:14.595]                               next
[08:28:14.595]                             invokeRestart(restart)
[08:28:14.595]                             muffled <- TRUE
[08:28:14.595]                             break
[08:28:14.595]                           }
[08:28:14.595]                         }
[08:28:14.595]                       }
[08:28:14.595]                       invisible(muffled)
[08:28:14.595]                     }
[08:28:14.595]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.595]                   }
[08:28:14.595]                 }
[08:28:14.595]                 else {
[08:28:14.595]                   if (TRUE) {
[08:28:14.595]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.595]                     {
[08:28:14.595]                       inherits <- base::inherits
[08:28:14.595]                       invokeRestart <- base::invokeRestart
[08:28:14.595]                       is.null <- base::is.null
[08:28:14.595]                       muffled <- FALSE
[08:28:14.595]                       if (inherits(cond, "message")) {
[08:28:14.595]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.595]                         if (muffled) 
[08:28:14.595]                           invokeRestart("muffleMessage")
[08:28:14.595]                       }
[08:28:14.595]                       else if (inherits(cond, "warning")) {
[08:28:14.595]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.595]                         if (muffled) 
[08:28:14.595]                           invokeRestart("muffleWarning")
[08:28:14.595]                       }
[08:28:14.595]                       else if (inherits(cond, "condition")) {
[08:28:14.595]                         if (!is.null(pattern)) {
[08:28:14.595]                           computeRestarts <- base::computeRestarts
[08:28:14.595]                           grepl <- base::grepl
[08:28:14.595]                           restarts <- computeRestarts(cond)
[08:28:14.595]                           for (restart in restarts) {
[08:28:14.595]                             name <- restart$name
[08:28:14.595]                             if (is.null(name)) 
[08:28:14.595]                               next
[08:28:14.595]                             if (!grepl(pattern, name)) 
[08:28:14.595]                               next
[08:28:14.595]                             invokeRestart(restart)
[08:28:14.595]                             muffled <- TRUE
[08:28:14.595]                             break
[08:28:14.595]                           }
[08:28:14.595]                         }
[08:28:14.595]                       }
[08:28:14.595]                       invisible(muffled)
[08:28:14.595]                     }
[08:28:14.595]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.595]                   }
[08:28:14.595]                 }
[08:28:14.595]             }
[08:28:14.595]         }))
[08:28:14.595]     }, error = function(ex) {
[08:28:14.595]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.595]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.595]                 ...future.rng), started = ...future.startTime, 
[08:28:14.595]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.595]             version = "1.8"), class = "FutureResult")
[08:28:14.595]     }, finally = {
[08:28:14.595]         if (!identical(...future.workdir, getwd())) 
[08:28:14.595]             setwd(...future.workdir)
[08:28:14.595]         {
[08:28:14.595]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.595]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.595]             }
[08:28:14.595]             base::options(...future.oldOptions)
[08:28:14.595]             if (.Platform$OS.type == "windows") {
[08:28:14.595]                 old_names <- names(...future.oldEnvVars)
[08:28:14.595]                 envs <- base::Sys.getenv()
[08:28:14.595]                 names <- names(envs)
[08:28:14.595]                 common <- intersect(names, old_names)
[08:28:14.595]                 added <- setdiff(names, old_names)
[08:28:14.595]                 removed <- setdiff(old_names, names)
[08:28:14.595]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.595]                   envs[common]]
[08:28:14.595]                 NAMES <- toupper(changed)
[08:28:14.595]                 args <- list()
[08:28:14.595]                 for (kk in seq_along(NAMES)) {
[08:28:14.595]                   name <- changed[[kk]]
[08:28:14.595]                   NAME <- NAMES[[kk]]
[08:28:14.595]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.595]                     next
[08:28:14.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.595]                 }
[08:28:14.595]                 NAMES <- toupper(added)
[08:28:14.595]                 for (kk in seq_along(NAMES)) {
[08:28:14.595]                   name <- added[[kk]]
[08:28:14.595]                   NAME <- NAMES[[kk]]
[08:28:14.595]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.595]                     next
[08:28:14.595]                   args[[name]] <- ""
[08:28:14.595]                 }
[08:28:14.595]                 NAMES <- toupper(removed)
[08:28:14.595]                 for (kk in seq_along(NAMES)) {
[08:28:14.595]                   name <- removed[[kk]]
[08:28:14.595]                   NAME <- NAMES[[kk]]
[08:28:14.595]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.595]                     next
[08:28:14.595]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.595]                 }
[08:28:14.595]                 if (length(args) > 0) 
[08:28:14.595]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.595]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.595]             }
[08:28:14.595]             else {
[08:28:14.595]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.595]             }
[08:28:14.595]             {
[08:28:14.595]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.595]                   0L) {
[08:28:14.595]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.595]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.595]                   base::options(opts)
[08:28:14.595]                 }
[08:28:14.595]                 {
[08:28:14.595]                   {
[08:28:14.595]                     NULL
[08:28:14.595]                     RNGkind("Mersenne-Twister")
[08:28:14.595]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.595]                       inherits = FALSE)
[08:28:14.595]                   }
[08:28:14.595]                   options(future.plan = NULL)
[08:28:14.595]                   if (is.na(NA_character_)) 
[08:28:14.595]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.595]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.595]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.595]                     .init = FALSE)
[08:28:14.595]                 }
[08:28:14.595]             }
[08:28:14.595]         }
[08:28:14.595]     })
[08:28:14.595]     if (TRUE) {
[08:28:14.595]         base::sink(type = "output", split = FALSE)
[08:28:14.595]         if (TRUE) {
[08:28:14.595]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.595]         }
[08:28:14.595]         else {
[08:28:14.595]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.595]         }
[08:28:14.595]         base::close(...future.stdout)
[08:28:14.595]         ...future.stdout <- NULL
[08:28:14.595]     }
[08:28:14.595]     ...future.result$conditions <- ...future.conditions
[08:28:14.595]     ...future.result$finished <- base::Sys.time()
[08:28:14.595]     ...future.result
[08:28:14.595] }
[08:28:14.598] assign_globals() ...
[08:28:14.598] List of 1
[08:28:14.598]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a107d46b28> 
[08:28:14.598]  - attr(*, "where")=List of 1
[08:28:14.598]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.598]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.598]  - attr(*, "resolved")= logi TRUE
[08:28:14.598]  - attr(*, "total_size")= num 3535
[08:28:14.598]  - attr(*, "already-done")= logi TRUE
[08:28:14.600] - copied ‘a’ to environment
[08:28:14.600] assign_globals() ... done
[08:28:14.601] plan(): Setting new future strategy stack:
[08:28:14.601] List of future strategies:
[08:28:14.601] 1. sequential:
[08:28:14.601]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.601]    - tweaked: FALSE
[08:28:14.601]    - call: NULL
[08:28:14.601] plan(): nbrOfWorkers() = 1
[08:28:14.602] plan(): Setting new future strategy stack:
[08:28:14.602] List of future strategies:
[08:28:14.602] 1. sequential:
[08:28:14.602]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.602]    - tweaked: FALSE
[08:28:14.602]    - call: plan(strategy)
[08:28:14.602] plan(): nbrOfWorkers() = 1
[08:28:14.602] SequentialFuture started (and completed)
[08:28:14.603] - Launch lazy future ... done
[08:28:14.603] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.603] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.603] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.604] 
[08:28:14.604] Searching for globals ... DONE
[08:28:14.604] - globals: [0] <none>
[08:28:14.604] getGlobalsAndPackages() ... DONE
[08:28:14.604] run() for ‘Future’ ...
[08:28:14.604] - state: ‘created’
[08:28:14.604] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.604] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.605] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.605]   - Field: ‘label’
[08:28:14.605]   - Field: ‘local’
[08:28:14.605]   - Field: ‘owner’
[08:28:14.605]   - Field: ‘envir’
[08:28:14.605]   - Field: ‘packages’
[08:28:14.605]   - Field: ‘gc’
[08:28:14.605]   - Field: ‘conditions’
[08:28:14.605]   - Field: ‘expr’
[08:28:14.605]   - Field: ‘uuid’
[08:28:14.605]   - Field: ‘seed’
[08:28:14.605]   - Field: ‘version’
[08:28:14.606]   - Field: ‘result’
[08:28:14.606]   - Field: ‘asynchronous’
[08:28:14.606]   - Field: ‘calls’
[08:28:14.606]   - Field: ‘globals’
[08:28:14.606]   - Field: ‘stdout’
[08:28:14.606]   - Field: ‘earlySignal’
[08:28:14.606]   - Field: ‘lazy’
[08:28:14.606]   - Field: ‘state’
[08:28:14.606] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.606] - Launch lazy future ...
[08:28:14.606] Packages needed by the future expression (n = 0): <none>
[08:28:14.607] Packages needed by future strategies (n = 0): <none>
[08:28:14.607] {
[08:28:14.607]     {
[08:28:14.607]         {
[08:28:14.607]             ...future.startTime <- base::Sys.time()
[08:28:14.607]             {
[08:28:14.607]                 {
[08:28:14.607]                   {
[08:28:14.607]                     base::local({
[08:28:14.607]                       has_future <- base::requireNamespace("future", 
[08:28:14.607]                         quietly = TRUE)
[08:28:14.607]                       if (has_future) {
[08:28:14.607]                         ns <- base::getNamespace("future")
[08:28:14.607]                         version <- ns[[".package"]][["version"]]
[08:28:14.607]                         if (is.null(version)) 
[08:28:14.607]                           version <- utils::packageVersion("future")
[08:28:14.607]                       }
[08:28:14.607]                       else {
[08:28:14.607]                         version <- NULL
[08:28:14.607]                       }
[08:28:14.607]                       if (!has_future || version < "1.8.0") {
[08:28:14.607]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.607]                           "", base::R.version$version.string), 
[08:28:14.607]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.607]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.607]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.607]                             "release", "version")], collapse = " "), 
[08:28:14.607]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.607]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.607]                           info)
[08:28:14.607]                         info <- base::paste(info, collapse = "; ")
[08:28:14.607]                         if (!has_future) {
[08:28:14.607]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.607]                             info)
[08:28:14.607]                         }
[08:28:14.607]                         else {
[08:28:14.607]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.607]                             info, version)
[08:28:14.607]                         }
[08:28:14.607]                         base::stop(msg)
[08:28:14.607]                       }
[08:28:14.607]                     })
[08:28:14.607]                   }
[08:28:14.607]                   ...future.strategy.old <- future::plan("list")
[08:28:14.607]                   options(future.plan = NULL)
[08:28:14.607]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.607]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.607]                 }
[08:28:14.607]                 ...future.workdir <- getwd()
[08:28:14.607]             }
[08:28:14.607]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.607]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.607]         }
[08:28:14.607]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.607]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.607]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.607]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.607]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.607]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.607]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.607]             base::names(...future.oldOptions))
[08:28:14.607]     }
[08:28:14.607]     if (FALSE) {
[08:28:14.607]     }
[08:28:14.607]     else {
[08:28:14.607]         if (TRUE) {
[08:28:14.607]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.607]                 open = "w")
[08:28:14.607]         }
[08:28:14.607]         else {
[08:28:14.607]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.607]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.607]         }
[08:28:14.607]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.607]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.607]             base::sink(type = "output", split = FALSE)
[08:28:14.607]             base::close(...future.stdout)
[08:28:14.607]         }, add = TRUE)
[08:28:14.607]     }
[08:28:14.607]     ...future.frame <- base::sys.nframe()
[08:28:14.607]     ...future.conditions <- base::list()
[08:28:14.607]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.607]     if (FALSE) {
[08:28:14.607]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.607]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.607]     }
[08:28:14.607]     ...future.result <- base::tryCatch({
[08:28:14.607]         base::withCallingHandlers({
[08:28:14.607]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.607]             future::FutureResult(value = ...future.value$value, 
[08:28:14.607]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.607]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.607]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.607]                     ...future.globalenv.names))
[08:28:14.607]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.607]         }, condition = base::local({
[08:28:14.607]             c <- base::c
[08:28:14.607]             inherits <- base::inherits
[08:28:14.607]             invokeRestart <- base::invokeRestart
[08:28:14.607]             length <- base::length
[08:28:14.607]             list <- base::list
[08:28:14.607]             seq.int <- base::seq.int
[08:28:14.607]             signalCondition <- base::signalCondition
[08:28:14.607]             sys.calls <- base::sys.calls
[08:28:14.607]             `[[` <- base::`[[`
[08:28:14.607]             `+` <- base::`+`
[08:28:14.607]             `<<-` <- base::`<<-`
[08:28:14.607]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.607]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.607]                   3L)]
[08:28:14.607]             }
[08:28:14.607]             function(cond) {
[08:28:14.607]                 is_error <- inherits(cond, "error")
[08:28:14.607]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.607]                   NULL)
[08:28:14.607]                 if (is_error) {
[08:28:14.607]                   sessionInformation <- function() {
[08:28:14.607]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.607]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.607]                       search = base::search(), system = base::Sys.info())
[08:28:14.607]                   }
[08:28:14.607]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.607]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.607]                     cond$call), session = sessionInformation(), 
[08:28:14.607]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.607]                   signalCondition(cond)
[08:28:14.607]                 }
[08:28:14.607]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.607]                 "immediateCondition"))) {
[08:28:14.607]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.607]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.607]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.607]                   if (TRUE && !signal) {
[08:28:14.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.607]                     {
[08:28:14.607]                       inherits <- base::inherits
[08:28:14.607]                       invokeRestart <- base::invokeRestart
[08:28:14.607]                       is.null <- base::is.null
[08:28:14.607]                       muffled <- FALSE
[08:28:14.607]                       if (inherits(cond, "message")) {
[08:28:14.607]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.607]                         if (muffled) 
[08:28:14.607]                           invokeRestart("muffleMessage")
[08:28:14.607]                       }
[08:28:14.607]                       else if (inherits(cond, "warning")) {
[08:28:14.607]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.607]                         if (muffled) 
[08:28:14.607]                           invokeRestart("muffleWarning")
[08:28:14.607]                       }
[08:28:14.607]                       else if (inherits(cond, "condition")) {
[08:28:14.607]                         if (!is.null(pattern)) {
[08:28:14.607]                           computeRestarts <- base::computeRestarts
[08:28:14.607]                           grepl <- base::grepl
[08:28:14.607]                           restarts <- computeRestarts(cond)
[08:28:14.607]                           for (restart in restarts) {
[08:28:14.607]                             name <- restart$name
[08:28:14.607]                             if (is.null(name)) 
[08:28:14.607]                               next
[08:28:14.607]                             if (!grepl(pattern, name)) 
[08:28:14.607]                               next
[08:28:14.607]                             invokeRestart(restart)
[08:28:14.607]                             muffled <- TRUE
[08:28:14.607]                             break
[08:28:14.607]                           }
[08:28:14.607]                         }
[08:28:14.607]                       }
[08:28:14.607]                       invisible(muffled)
[08:28:14.607]                     }
[08:28:14.607]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.607]                   }
[08:28:14.607]                 }
[08:28:14.607]                 else {
[08:28:14.607]                   if (TRUE) {
[08:28:14.607]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.607]                     {
[08:28:14.607]                       inherits <- base::inherits
[08:28:14.607]                       invokeRestart <- base::invokeRestart
[08:28:14.607]                       is.null <- base::is.null
[08:28:14.607]                       muffled <- FALSE
[08:28:14.607]                       if (inherits(cond, "message")) {
[08:28:14.607]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.607]                         if (muffled) 
[08:28:14.607]                           invokeRestart("muffleMessage")
[08:28:14.607]                       }
[08:28:14.607]                       else if (inherits(cond, "warning")) {
[08:28:14.607]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.607]                         if (muffled) 
[08:28:14.607]                           invokeRestart("muffleWarning")
[08:28:14.607]                       }
[08:28:14.607]                       else if (inherits(cond, "condition")) {
[08:28:14.607]                         if (!is.null(pattern)) {
[08:28:14.607]                           computeRestarts <- base::computeRestarts
[08:28:14.607]                           grepl <- base::grepl
[08:28:14.607]                           restarts <- computeRestarts(cond)
[08:28:14.607]                           for (restart in restarts) {
[08:28:14.607]                             name <- restart$name
[08:28:14.607]                             if (is.null(name)) 
[08:28:14.607]                               next
[08:28:14.607]                             if (!grepl(pattern, name)) 
[08:28:14.607]                               next
[08:28:14.607]                             invokeRestart(restart)
[08:28:14.607]                             muffled <- TRUE
[08:28:14.607]                             break
[08:28:14.607]                           }
[08:28:14.607]                         }
[08:28:14.607]                       }
[08:28:14.607]                       invisible(muffled)
[08:28:14.607]                     }
[08:28:14.607]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.607]                   }
[08:28:14.607]                 }
[08:28:14.607]             }
[08:28:14.607]         }))
[08:28:14.607]     }, error = function(ex) {
[08:28:14.607]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.607]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.607]                 ...future.rng), started = ...future.startTime, 
[08:28:14.607]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.607]             version = "1.8"), class = "FutureResult")
[08:28:14.607]     }, finally = {
[08:28:14.607]         if (!identical(...future.workdir, getwd())) 
[08:28:14.607]             setwd(...future.workdir)
[08:28:14.607]         {
[08:28:14.607]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.607]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.607]             }
[08:28:14.607]             base::options(...future.oldOptions)
[08:28:14.607]             if (.Platform$OS.type == "windows") {
[08:28:14.607]                 old_names <- names(...future.oldEnvVars)
[08:28:14.607]                 envs <- base::Sys.getenv()
[08:28:14.607]                 names <- names(envs)
[08:28:14.607]                 common <- intersect(names, old_names)
[08:28:14.607]                 added <- setdiff(names, old_names)
[08:28:14.607]                 removed <- setdiff(old_names, names)
[08:28:14.607]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.607]                   envs[common]]
[08:28:14.607]                 NAMES <- toupper(changed)
[08:28:14.607]                 args <- list()
[08:28:14.607]                 for (kk in seq_along(NAMES)) {
[08:28:14.607]                   name <- changed[[kk]]
[08:28:14.607]                   NAME <- NAMES[[kk]]
[08:28:14.607]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.607]                     next
[08:28:14.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.607]                 }
[08:28:14.607]                 NAMES <- toupper(added)
[08:28:14.607]                 for (kk in seq_along(NAMES)) {
[08:28:14.607]                   name <- added[[kk]]
[08:28:14.607]                   NAME <- NAMES[[kk]]
[08:28:14.607]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.607]                     next
[08:28:14.607]                   args[[name]] <- ""
[08:28:14.607]                 }
[08:28:14.607]                 NAMES <- toupper(removed)
[08:28:14.607]                 for (kk in seq_along(NAMES)) {
[08:28:14.607]                   name <- removed[[kk]]
[08:28:14.607]                   NAME <- NAMES[[kk]]
[08:28:14.607]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.607]                     next
[08:28:14.607]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.607]                 }
[08:28:14.607]                 if (length(args) > 0) 
[08:28:14.607]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.607]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.607]             }
[08:28:14.607]             else {
[08:28:14.607]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.607]             }
[08:28:14.607]             {
[08:28:14.607]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.607]                   0L) {
[08:28:14.607]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.607]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.607]                   base::options(opts)
[08:28:14.607]                 }
[08:28:14.607]                 {
[08:28:14.607]                   {
[08:28:14.607]                     NULL
[08:28:14.607]                     RNGkind("Mersenne-Twister")
[08:28:14.607]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.607]                       inherits = FALSE)
[08:28:14.607]                   }
[08:28:14.607]                   options(future.plan = NULL)
[08:28:14.607]                   if (is.na(NA_character_)) 
[08:28:14.607]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.607]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.607]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.607]                     .init = FALSE)
[08:28:14.607]                 }
[08:28:14.607]             }
[08:28:14.607]         }
[08:28:14.607]     })
[08:28:14.607]     if (TRUE) {
[08:28:14.607]         base::sink(type = "output", split = FALSE)
[08:28:14.607]         if (TRUE) {
[08:28:14.607]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.607]         }
[08:28:14.607]         else {
[08:28:14.607]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.607]         }
[08:28:14.607]         base::close(...future.stdout)
[08:28:14.607]         ...future.stdout <- NULL
[08:28:14.607]     }
[08:28:14.607]     ...future.result$conditions <- ...future.conditions
[08:28:14.607]     ...future.result$finished <- base::Sys.time()
[08:28:14.607]     ...future.result
[08:28:14.607] }
[08:28:14.609] plan(): Setting new future strategy stack:
[08:28:14.609] List of future strategies:
[08:28:14.609] 1. sequential:
[08:28:14.609]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.609]    - tweaked: FALSE
[08:28:14.609]    - call: NULL
[08:28:14.609] plan(): nbrOfWorkers() = 1
[08:28:14.610] plan(): Setting new future strategy stack:
[08:28:14.610] List of future strategies:
[08:28:14.610] 1. sequential:
[08:28:14.610]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.610]    - tweaked: FALSE
[08:28:14.610]    - call: plan(strategy)
[08:28:14.610] plan(): nbrOfWorkers() = 1
[08:28:14.610] SequentialFuture started (and completed)
[08:28:14.611] - Launch lazy future ... done
[08:28:14.611] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.611] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.611] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.612] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.612] Searching for globals ... DONE
[08:28:14.612] Resolving globals: TRUE
[08:28:14.612] Resolving any globals that are futures ...
[08:28:14.612] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.612] Resolving any globals that are futures ... DONE
[08:28:14.612] Resolving futures part of globals (recursively) ...
[08:28:14.613] resolve() on list ...
[08:28:14.613]  recursive: 99
[08:28:14.613]  length: 1
[08:28:14.613]  elements: ‘a’
[08:28:14.613] resolved() for ‘SequentialFuture’ ...
[08:28:14.613] - state: ‘finished’
[08:28:14.613] - run: TRUE
[08:28:14.613] - result: ‘FutureResult’
[08:28:14.613] resolved() for ‘SequentialFuture’ ... done
[08:28:14.614] Future #1
[08:28:14.614] resolved() for ‘SequentialFuture’ ...
[08:28:14.614] - state: ‘finished’
[08:28:14.614] - run: TRUE
[08:28:14.614] - result: ‘FutureResult’
[08:28:14.614] resolved() for ‘SequentialFuture’ ... done
[08:28:14.614] A SequentialFuture was resolved
[08:28:14.614]  length: 0 (resolved future 1)
[08:28:14.614] resolve() on list ... DONE
[08:28:14.614] - globals: [1] ‘a’
[08:28:14.614] Resolving futures part of globals (recursively) ... DONE
[08:28:14.615] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[08:28:14.615] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[08:28:14.615] - globals: [1] ‘a’
[08:28:14.615] - packages: [1] ‘future’
[08:28:14.615] getGlobalsAndPackages() ... DONE
[08:28:14.615] run() for ‘Future’ ...
[08:28:14.616] - state: ‘created’
[08:28:14.616] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.616] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.616] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.616]   - Field: ‘label’
[08:28:14.616]   - Field: ‘local’
[08:28:14.616]   - Field: ‘owner’
[08:28:14.616]   - Field: ‘envir’
[08:28:14.616]   - Field: ‘packages’
[08:28:14.616]   - Field: ‘gc’
[08:28:14.617]   - Field: ‘conditions’
[08:28:14.617]   - Field: ‘expr’
[08:28:14.617]   - Field: ‘uuid’
[08:28:14.617]   - Field: ‘seed’
[08:28:14.617]   - Field: ‘version’
[08:28:14.617]   - Field: ‘result’
[08:28:14.617]   - Field: ‘asynchronous’
[08:28:14.617]   - Field: ‘calls’
[08:28:14.617]   - Field: ‘globals’
[08:28:14.617]   - Field: ‘stdout’
[08:28:14.617]   - Field: ‘earlySignal’
[08:28:14.617]   - Field: ‘lazy’
[08:28:14.618]   - Field: ‘state’
[08:28:14.618] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.618] - Launch lazy future ...
[08:28:14.618] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.618] Packages needed by future strategies (n = 0): <none>
[08:28:14.618] {
[08:28:14.618]     {
[08:28:14.618]         {
[08:28:14.618]             ...future.startTime <- base::Sys.time()
[08:28:14.618]             {
[08:28:14.618]                 {
[08:28:14.618]                   {
[08:28:14.618]                     {
[08:28:14.618]                       base::local({
[08:28:14.618]                         has_future <- base::requireNamespace("future", 
[08:28:14.618]                           quietly = TRUE)
[08:28:14.618]                         if (has_future) {
[08:28:14.618]                           ns <- base::getNamespace("future")
[08:28:14.618]                           version <- ns[[".package"]][["version"]]
[08:28:14.618]                           if (is.null(version)) 
[08:28:14.618]                             version <- utils::packageVersion("future")
[08:28:14.618]                         }
[08:28:14.618]                         else {
[08:28:14.618]                           version <- NULL
[08:28:14.618]                         }
[08:28:14.618]                         if (!has_future || version < "1.8.0") {
[08:28:14.618]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.618]                             "", base::R.version$version.string), 
[08:28:14.618]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.618]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.618]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.618]                               "release", "version")], collapse = " "), 
[08:28:14.618]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.618]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.618]                             info)
[08:28:14.618]                           info <- base::paste(info, collapse = "; ")
[08:28:14.618]                           if (!has_future) {
[08:28:14.618]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.618]                               info)
[08:28:14.618]                           }
[08:28:14.618]                           else {
[08:28:14.618]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.618]                               info, version)
[08:28:14.618]                           }
[08:28:14.618]                           base::stop(msg)
[08:28:14.618]                         }
[08:28:14.618]                       })
[08:28:14.618]                     }
[08:28:14.618]                     base::local({
[08:28:14.618]                       for (pkg in "future") {
[08:28:14.618]                         base::loadNamespace(pkg)
[08:28:14.618]                         base::library(pkg, character.only = TRUE)
[08:28:14.618]                       }
[08:28:14.618]                     })
[08:28:14.618]                   }
[08:28:14.618]                   ...future.strategy.old <- future::plan("list")
[08:28:14.618]                   options(future.plan = NULL)
[08:28:14.618]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.618]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.618]                 }
[08:28:14.618]                 ...future.workdir <- getwd()
[08:28:14.618]             }
[08:28:14.618]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.618]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.618]         }
[08:28:14.618]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.618]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.618]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.618]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.618]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.618]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.618]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.618]             base::names(...future.oldOptions))
[08:28:14.618]     }
[08:28:14.618]     if (FALSE) {
[08:28:14.618]     }
[08:28:14.618]     else {
[08:28:14.618]         if (TRUE) {
[08:28:14.618]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.618]                 open = "w")
[08:28:14.618]         }
[08:28:14.618]         else {
[08:28:14.618]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.618]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.618]         }
[08:28:14.618]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.618]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.618]             base::sink(type = "output", split = FALSE)
[08:28:14.618]             base::close(...future.stdout)
[08:28:14.618]         }, add = TRUE)
[08:28:14.618]     }
[08:28:14.618]     ...future.frame <- base::sys.nframe()
[08:28:14.618]     ...future.conditions <- base::list()
[08:28:14.618]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.618]     if (FALSE) {
[08:28:14.618]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.618]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.618]     }
[08:28:14.618]     ...future.result <- base::tryCatch({
[08:28:14.618]         base::withCallingHandlers({
[08:28:14.618]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.618]                 1))
[08:28:14.618]             future::FutureResult(value = ...future.value$value, 
[08:28:14.618]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.618]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.618]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.618]                     ...future.globalenv.names))
[08:28:14.618]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.618]         }, condition = base::local({
[08:28:14.618]             c <- base::c
[08:28:14.618]             inherits <- base::inherits
[08:28:14.618]             invokeRestart <- base::invokeRestart
[08:28:14.618]             length <- base::length
[08:28:14.618]             list <- base::list
[08:28:14.618]             seq.int <- base::seq.int
[08:28:14.618]             signalCondition <- base::signalCondition
[08:28:14.618]             sys.calls <- base::sys.calls
[08:28:14.618]             `[[` <- base::`[[`
[08:28:14.618]             `+` <- base::`+`
[08:28:14.618]             `<<-` <- base::`<<-`
[08:28:14.618]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.618]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.618]                   3L)]
[08:28:14.618]             }
[08:28:14.618]             function(cond) {
[08:28:14.618]                 is_error <- inherits(cond, "error")
[08:28:14.618]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.618]                   NULL)
[08:28:14.618]                 if (is_error) {
[08:28:14.618]                   sessionInformation <- function() {
[08:28:14.618]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.618]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.618]                       search = base::search(), system = base::Sys.info())
[08:28:14.618]                   }
[08:28:14.618]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.618]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.618]                     cond$call), session = sessionInformation(), 
[08:28:14.618]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.618]                   signalCondition(cond)
[08:28:14.618]                 }
[08:28:14.618]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.618]                 "immediateCondition"))) {
[08:28:14.618]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.618]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.618]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.618]                   if (TRUE && !signal) {
[08:28:14.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.618]                     {
[08:28:14.618]                       inherits <- base::inherits
[08:28:14.618]                       invokeRestart <- base::invokeRestart
[08:28:14.618]                       is.null <- base::is.null
[08:28:14.618]                       muffled <- FALSE
[08:28:14.618]                       if (inherits(cond, "message")) {
[08:28:14.618]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.618]                         if (muffled) 
[08:28:14.618]                           invokeRestart("muffleMessage")
[08:28:14.618]                       }
[08:28:14.618]                       else if (inherits(cond, "warning")) {
[08:28:14.618]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.618]                         if (muffled) 
[08:28:14.618]                           invokeRestart("muffleWarning")
[08:28:14.618]                       }
[08:28:14.618]                       else if (inherits(cond, "condition")) {
[08:28:14.618]                         if (!is.null(pattern)) {
[08:28:14.618]                           computeRestarts <- base::computeRestarts
[08:28:14.618]                           grepl <- base::grepl
[08:28:14.618]                           restarts <- computeRestarts(cond)
[08:28:14.618]                           for (restart in restarts) {
[08:28:14.618]                             name <- restart$name
[08:28:14.618]                             if (is.null(name)) 
[08:28:14.618]                               next
[08:28:14.618]                             if (!grepl(pattern, name)) 
[08:28:14.618]                               next
[08:28:14.618]                             invokeRestart(restart)
[08:28:14.618]                             muffled <- TRUE
[08:28:14.618]                             break
[08:28:14.618]                           }
[08:28:14.618]                         }
[08:28:14.618]                       }
[08:28:14.618]                       invisible(muffled)
[08:28:14.618]                     }
[08:28:14.618]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.618]                   }
[08:28:14.618]                 }
[08:28:14.618]                 else {
[08:28:14.618]                   if (TRUE) {
[08:28:14.618]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.618]                     {
[08:28:14.618]                       inherits <- base::inherits
[08:28:14.618]                       invokeRestart <- base::invokeRestart
[08:28:14.618]                       is.null <- base::is.null
[08:28:14.618]                       muffled <- FALSE
[08:28:14.618]                       if (inherits(cond, "message")) {
[08:28:14.618]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.618]                         if (muffled) 
[08:28:14.618]                           invokeRestart("muffleMessage")
[08:28:14.618]                       }
[08:28:14.618]                       else if (inherits(cond, "warning")) {
[08:28:14.618]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.618]                         if (muffled) 
[08:28:14.618]                           invokeRestart("muffleWarning")
[08:28:14.618]                       }
[08:28:14.618]                       else if (inherits(cond, "condition")) {
[08:28:14.618]                         if (!is.null(pattern)) {
[08:28:14.618]                           computeRestarts <- base::computeRestarts
[08:28:14.618]                           grepl <- base::grepl
[08:28:14.618]                           restarts <- computeRestarts(cond)
[08:28:14.618]                           for (restart in restarts) {
[08:28:14.618]                             name <- restart$name
[08:28:14.618]                             if (is.null(name)) 
[08:28:14.618]                               next
[08:28:14.618]                             if (!grepl(pattern, name)) 
[08:28:14.618]                               next
[08:28:14.618]                             invokeRestart(restart)
[08:28:14.618]                             muffled <- TRUE
[08:28:14.618]                             break
[08:28:14.618]                           }
[08:28:14.618]                         }
[08:28:14.618]                       }
[08:28:14.618]                       invisible(muffled)
[08:28:14.618]                     }
[08:28:14.618]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.618]                   }
[08:28:14.618]                 }
[08:28:14.618]             }
[08:28:14.618]         }))
[08:28:14.618]     }, error = function(ex) {
[08:28:14.618]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.618]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.618]                 ...future.rng), started = ...future.startTime, 
[08:28:14.618]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.618]             version = "1.8"), class = "FutureResult")
[08:28:14.618]     }, finally = {
[08:28:14.618]         if (!identical(...future.workdir, getwd())) 
[08:28:14.618]             setwd(...future.workdir)
[08:28:14.618]         {
[08:28:14.618]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.618]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.618]             }
[08:28:14.618]             base::options(...future.oldOptions)
[08:28:14.618]             if (.Platform$OS.type == "windows") {
[08:28:14.618]                 old_names <- names(...future.oldEnvVars)
[08:28:14.618]                 envs <- base::Sys.getenv()
[08:28:14.618]                 names <- names(envs)
[08:28:14.618]                 common <- intersect(names, old_names)
[08:28:14.618]                 added <- setdiff(names, old_names)
[08:28:14.618]                 removed <- setdiff(old_names, names)
[08:28:14.618]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.618]                   envs[common]]
[08:28:14.618]                 NAMES <- toupper(changed)
[08:28:14.618]                 args <- list()
[08:28:14.618]                 for (kk in seq_along(NAMES)) {
[08:28:14.618]                   name <- changed[[kk]]
[08:28:14.618]                   NAME <- NAMES[[kk]]
[08:28:14.618]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.618]                     next
[08:28:14.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.618]                 }
[08:28:14.618]                 NAMES <- toupper(added)
[08:28:14.618]                 for (kk in seq_along(NAMES)) {
[08:28:14.618]                   name <- added[[kk]]
[08:28:14.618]                   NAME <- NAMES[[kk]]
[08:28:14.618]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.618]                     next
[08:28:14.618]                   args[[name]] <- ""
[08:28:14.618]                 }
[08:28:14.618]                 NAMES <- toupper(removed)
[08:28:14.618]                 for (kk in seq_along(NAMES)) {
[08:28:14.618]                   name <- removed[[kk]]
[08:28:14.618]                   NAME <- NAMES[[kk]]
[08:28:14.618]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.618]                     next
[08:28:14.618]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.618]                 }
[08:28:14.618]                 if (length(args) > 0) 
[08:28:14.618]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.618]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.618]             }
[08:28:14.618]             else {
[08:28:14.618]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.618]             }
[08:28:14.618]             {
[08:28:14.618]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.618]                   0L) {
[08:28:14.618]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.618]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.618]                   base::options(opts)
[08:28:14.618]                 }
[08:28:14.618]                 {
[08:28:14.618]                   {
[08:28:14.618]                     NULL
[08:28:14.618]                     RNGkind("Mersenne-Twister")
[08:28:14.618]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.618]                       inherits = FALSE)
[08:28:14.618]                   }
[08:28:14.618]                   options(future.plan = NULL)
[08:28:14.618]                   if (is.na(NA_character_)) 
[08:28:14.618]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.618]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.618]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.618]                     .init = FALSE)
[08:28:14.618]                 }
[08:28:14.618]             }
[08:28:14.618]         }
[08:28:14.618]     })
[08:28:14.618]     if (TRUE) {
[08:28:14.618]         base::sink(type = "output", split = FALSE)
[08:28:14.618]         if (TRUE) {
[08:28:14.618]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.618]         }
[08:28:14.618]         else {
[08:28:14.618]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.618]         }
[08:28:14.618]         base::close(...future.stdout)
[08:28:14.618]         ...future.stdout <- NULL
[08:28:14.618]     }
[08:28:14.618]     ...future.result$conditions <- ...future.conditions
[08:28:14.618]     ...future.result$finished <- base::Sys.time()
[08:28:14.618]     ...future.result
[08:28:14.618] }
[08:28:14.620] assign_globals() ...
[08:28:14.620] List of 1
[08:28:14.620]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a108230ba0> 
[08:28:14.620]  - attr(*, "where")=List of 1
[08:28:14.620]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.620]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.620]  - attr(*, "resolved")= logi TRUE
[08:28:14.620]  - attr(*, "total_size")= num 3535
[08:28:14.620]  - attr(*, "already-done")= logi TRUE
[08:28:14.647] - copied ‘a’ to environment
[08:28:14.647] assign_globals() ... done
[08:28:14.647] plan(): Setting new future strategy stack:
[08:28:14.648] List of future strategies:
[08:28:14.648] 1. sequential:
[08:28:14.648]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.648]    - tweaked: FALSE
[08:28:14.648]    - call: NULL
[08:28:14.648] plan(): nbrOfWorkers() = 1
[08:28:14.649] plan(): Setting new future strategy stack:
[08:28:14.649] List of future strategies:
[08:28:14.649] 1. sequential:
[08:28:14.649]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.649]    - tweaked: FALSE
[08:28:14.649]    - call: plan(strategy)
[08:28:14.649] plan(): nbrOfWorkers() = 1
[08:28:14.649] SequentialFuture started (and completed)
[08:28:14.650] - Launch lazy future ... done
[08:28:14.650] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.650] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.650] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.651] 
[08:28:14.651] Searching for globals ... DONE
[08:28:14.651] - globals: [0] <none>
[08:28:14.651] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.651] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.651] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.652] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.652] Searching for globals ... DONE
[08:28:14.652] Resolving globals: TRUE
[08:28:14.652] Resolving any globals that are futures ...
[08:28:14.652] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.653] Resolving any globals that are futures ... DONE
[08:28:14.653] Resolving futures part of globals (recursively) ...
[08:28:14.653] resolve() on list ...
[08:28:14.653]  recursive: 99
[08:28:14.653]  length: 1
[08:28:14.653]  elements: ‘a’
[08:28:14.653] run() for ‘Future’ ...
[08:28:14.653] - state: ‘created’
[08:28:14.654] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.654] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.654] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.654]   - Field: ‘label’
[08:28:14.654]   - Field: ‘local’
[08:28:14.654]   - Field: ‘owner’
[08:28:14.654]   - Field: ‘envir’
[08:28:14.654]   - Field: ‘packages’
[08:28:14.654]   - Field: ‘gc’
[08:28:14.655]   - Field: ‘conditions’
[08:28:14.655]   - Field: ‘expr’
[08:28:14.655]   - Field: ‘uuid’
[08:28:14.655]   - Field: ‘seed’
[08:28:14.655]   - Field: ‘version’
[08:28:14.655]   - Field: ‘result’
[08:28:14.655]   - Field: ‘asynchronous’
[08:28:14.655]   - Field: ‘calls’
[08:28:14.655]   - Field: ‘globals’
[08:28:14.655]   - Field: ‘stdout’
[08:28:14.655]   - Field: ‘earlySignal’
[08:28:14.655]   - Field: ‘lazy’
[08:28:14.656]   - Field: ‘state’
[08:28:14.656] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.656] - Launch lazy future ...
[08:28:14.656] Packages needed by the future expression (n = 0): <none>
[08:28:14.656] Packages needed by future strategies (n = 0): <none>
[08:28:14.656] {
[08:28:14.656]     {
[08:28:14.656]         {
[08:28:14.656]             ...future.startTime <- base::Sys.time()
[08:28:14.656]             {
[08:28:14.656]                 {
[08:28:14.656]                   {
[08:28:14.656]                     base::local({
[08:28:14.656]                       has_future <- base::requireNamespace("future", 
[08:28:14.656]                         quietly = TRUE)
[08:28:14.656]                       if (has_future) {
[08:28:14.656]                         ns <- base::getNamespace("future")
[08:28:14.656]                         version <- ns[[".package"]][["version"]]
[08:28:14.656]                         if (is.null(version)) 
[08:28:14.656]                           version <- utils::packageVersion("future")
[08:28:14.656]                       }
[08:28:14.656]                       else {
[08:28:14.656]                         version <- NULL
[08:28:14.656]                       }
[08:28:14.656]                       if (!has_future || version < "1.8.0") {
[08:28:14.656]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.656]                           "", base::R.version$version.string), 
[08:28:14.656]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.656]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.656]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.656]                             "release", "version")], collapse = " "), 
[08:28:14.656]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.656]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.656]                           info)
[08:28:14.656]                         info <- base::paste(info, collapse = "; ")
[08:28:14.656]                         if (!has_future) {
[08:28:14.656]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.656]                             info)
[08:28:14.656]                         }
[08:28:14.656]                         else {
[08:28:14.656]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.656]                             info, version)
[08:28:14.656]                         }
[08:28:14.656]                         base::stop(msg)
[08:28:14.656]                       }
[08:28:14.656]                     })
[08:28:14.656]                   }
[08:28:14.656]                   ...future.strategy.old <- future::plan("list")
[08:28:14.656]                   options(future.plan = NULL)
[08:28:14.656]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.656]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.656]                 }
[08:28:14.656]                 ...future.workdir <- getwd()
[08:28:14.656]             }
[08:28:14.656]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.656]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.656]         }
[08:28:14.656]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.656]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.656]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.656]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.656]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.656]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.656]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.656]             base::names(...future.oldOptions))
[08:28:14.656]     }
[08:28:14.656]     if (FALSE) {
[08:28:14.656]     }
[08:28:14.656]     else {
[08:28:14.656]         if (TRUE) {
[08:28:14.656]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.656]                 open = "w")
[08:28:14.656]         }
[08:28:14.656]         else {
[08:28:14.656]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.656]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.656]         }
[08:28:14.656]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.656]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.656]             base::sink(type = "output", split = FALSE)
[08:28:14.656]             base::close(...future.stdout)
[08:28:14.656]         }, add = TRUE)
[08:28:14.656]     }
[08:28:14.656]     ...future.frame <- base::sys.nframe()
[08:28:14.656]     ...future.conditions <- base::list()
[08:28:14.656]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.656]     if (FALSE) {
[08:28:14.656]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.656]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.656]     }
[08:28:14.656]     ...future.result <- base::tryCatch({
[08:28:14.656]         base::withCallingHandlers({
[08:28:14.656]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.656]             future::FutureResult(value = ...future.value$value, 
[08:28:14.656]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.656]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.656]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.656]                     ...future.globalenv.names))
[08:28:14.656]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.656]         }, condition = base::local({
[08:28:14.656]             c <- base::c
[08:28:14.656]             inherits <- base::inherits
[08:28:14.656]             invokeRestart <- base::invokeRestart
[08:28:14.656]             length <- base::length
[08:28:14.656]             list <- base::list
[08:28:14.656]             seq.int <- base::seq.int
[08:28:14.656]             signalCondition <- base::signalCondition
[08:28:14.656]             sys.calls <- base::sys.calls
[08:28:14.656]             `[[` <- base::`[[`
[08:28:14.656]             `+` <- base::`+`
[08:28:14.656]             `<<-` <- base::`<<-`
[08:28:14.656]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.656]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.656]                   3L)]
[08:28:14.656]             }
[08:28:14.656]             function(cond) {
[08:28:14.656]                 is_error <- inherits(cond, "error")
[08:28:14.656]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.656]                   NULL)
[08:28:14.656]                 if (is_error) {
[08:28:14.656]                   sessionInformation <- function() {
[08:28:14.656]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.656]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.656]                       search = base::search(), system = base::Sys.info())
[08:28:14.656]                   }
[08:28:14.656]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.656]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.656]                     cond$call), session = sessionInformation(), 
[08:28:14.656]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.656]                   signalCondition(cond)
[08:28:14.656]                 }
[08:28:14.656]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.656]                 "immediateCondition"))) {
[08:28:14.656]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.656]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.656]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.656]                   if (TRUE && !signal) {
[08:28:14.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.656]                     {
[08:28:14.656]                       inherits <- base::inherits
[08:28:14.656]                       invokeRestart <- base::invokeRestart
[08:28:14.656]                       is.null <- base::is.null
[08:28:14.656]                       muffled <- FALSE
[08:28:14.656]                       if (inherits(cond, "message")) {
[08:28:14.656]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.656]                         if (muffled) 
[08:28:14.656]                           invokeRestart("muffleMessage")
[08:28:14.656]                       }
[08:28:14.656]                       else if (inherits(cond, "warning")) {
[08:28:14.656]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.656]                         if (muffled) 
[08:28:14.656]                           invokeRestart("muffleWarning")
[08:28:14.656]                       }
[08:28:14.656]                       else if (inherits(cond, "condition")) {
[08:28:14.656]                         if (!is.null(pattern)) {
[08:28:14.656]                           computeRestarts <- base::computeRestarts
[08:28:14.656]                           grepl <- base::grepl
[08:28:14.656]                           restarts <- computeRestarts(cond)
[08:28:14.656]                           for (restart in restarts) {
[08:28:14.656]                             name <- restart$name
[08:28:14.656]                             if (is.null(name)) 
[08:28:14.656]                               next
[08:28:14.656]                             if (!grepl(pattern, name)) 
[08:28:14.656]                               next
[08:28:14.656]                             invokeRestart(restart)
[08:28:14.656]                             muffled <- TRUE
[08:28:14.656]                             break
[08:28:14.656]                           }
[08:28:14.656]                         }
[08:28:14.656]                       }
[08:28:14.656]                       invisible(muffled)
[08:28:14.656]                     }
[08:28:14.656]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.656]                   }
[08:28:14.656]                 }
[08:28:14.656]                 else {
[08:28:14.656]                   if (TRUE) {
[08:28:14.656]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.656]                     {
[08:28:14.656]                       inherits <- base::inherits
[08:28:14.656]                       invokeRestart <- base::invokeRestart
[08:28:14.656]                       is.null <- base::is.null
[08:28:14.656]                       muffled <- FALSE
[08:28:14.656]                       if (inherits(cond, "message")) {
[08:28:14.656]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.656]                         if (muffled) 
[08:28:14.656]                           invokeRestart("muffleMessage")
[08:28:14.656]                       }
[08:28:14.656]                       else if (inherits(cond, "warning")) {
[08:28:14.656]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.656]                         if (muffled) 
[08:28:14.656]                           invokeRestart("muffleWarning")
[08:28:14.656]                       }
[08:28:14.656]                       else if (inherits(cond, "condition")) {
[08:28:14.656]                         if (!is.null(pattern)) {
[08:28:14.656]                           computeRestarts <- base::computeRestarts
[08:28:14.656]                           grepl <- base::grepl
[08:28:14.656]                           restarts <- computeRestarts(cond)
[08:28:14.656]                           for (restart in restarts) {
[08:28:14.656]                             name <- restart$name
[08:28:14.656]                             if (is.null(name)) 
[08:28:14.656]                               next
[08:28:14.656]                             if (!grepl(pattern, name)) 
[08:28:14.656]                               next
[08:28:14.656]                             invokeRestart(restart)
[08:28:14.656]                             muffled <- TRUE
[08:28:14.656]                             break
[08:28:14.656]                           }
[08:28:14.656]                         }
[08:28:14.656]                       }
[08:28:14.656]                       invisible(muffled)
[08:28:14.656]                     }
[08:28:14.656]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.656]                   }
[08:28:14.656]                 }
[08:28:14.656]             }
[08:28:14.656]         }))
[08:28:14.656]     }, error = function(ex) {
[08:28:14.656]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.656]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.656]                 ...future.rng), started = ...future.startTime, 
[08:28:14.656]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.656]             version = "1.8"), class = "FutureResult")
[08:28:14.656]     }, finally = {
[08:28:14.656]         if (!identical(...future.workdir, getwd())) 
[08:28:14.656]             setwd(...future.workdir)
[08:28:14.656]         {
[08:28:14.656]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.656]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.656]             }
[08:28:14.656]             base::options(...future.oldOptions)
[08:28:14.656]             if (.Platform$OS.type == "windows") {
[08:28:14.656]                 old_names <- names(...future.oldEnvVars)
[08:28:14.656]                 envs <- base::Sys.getenv()
[08:28:14.656]                 names <- names(envs)
[08:28:14.656]                 common <- intersect(names, old_names)
[08:28:14.656]                 added <- setdiff(names, old_names)
[08:28:14.656]                 removed <- setdiff(old_names, names)
[08:28:14.656]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.656]                   envs[common]]
[08:28:14.656]                 NAMES <- toupper(changed)
[08:28:14.656]                 args <- list()
[08:28:14.656]                 for (kk in seq_along(NAMES)) {
[08:28:14.656]                   name <- changed[[kk]]
[08:28:14.656]                   NAME <- NAMES[[kk]]
[08:28:14.656]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.656]                     next
[08:28:14.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.656]                 }
[08:28:14.656]                 NAMES <- toupper(added)
[08:28:14.656]                 for (kk in seq_along(NAMES)) {
[08:28:14.656]                   name <- added[[kk]]
[08:28:14.656]                   NAME <- NAMES[[kk]]
[08:28:14.656]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.656]                     next
[08:28:14.656]                   args[[name]] <- ""
[08:28:14.656]                 }
[08:28:14.656]                 NAMES <- toupper(removed)
[08:28:14.656]                 for (kk in seq_along(NAMES)) {
[08:28:14.656]                   name <- removed[[kk]]
[08:28:14.656]                   NAME <- NAMES[[kk]]
[08:28:14.656]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.656]                     next
[08:28:14.656]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.656]                 }
[08:28:14.656]                 if (length(args) > 0) 
[08:28:14.656]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.656]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.656]             }
[08:28:14.656]             else {
[08:28:14.656]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.656]             }
[08:28:14.656]             {
[08:28:14.656]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.656]                   0L) {
[08:28:14.656]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.656]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.656]                   base::options(opts)
[08:28:14.656]                 }
[08:28:14.656]                 {
[08:28:14.656]                   {
[08:28:14.656]                     NULL
[08:28:14.656]                     RNGkind("Mersenne-Twister")
[08:28:14.656]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.656]                       inherits = FALSE)
[08:28:14.656]                   }
[08:28:14.656]                   options(future.plan = NULL)
[08:28:14.656]                   if (is.na(NA_character_)) 
[08:28:14.656]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.656]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.656]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.656]                     .init = FALSE)
[08:28:14.656]                 }
[08:28:14.656]             }
[08:28:14.656]         }
[08:28:14.656]     })
[08:28:14.656]     if (TRUE) {
[08:28:14.656]         base::sink(type = "output", split = FALSE)
[08:28:14.656]         if (TRUE) {
[08:28:14.656]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.656]         }
[08:28:14.656]         else {
[08:28:14.656]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.656]         }
[08:28:14.656]         base::close(...future.stdout)
[08:28:14.656]         ...future.stdout <- NULL
[08:28:14.656]     }
[08:28:14.656]     ...future.result$conditions <- ...future.conditions
[08:28:14.656]     ...future.result$finished <- base::Sys.time()
[08:28:14.656]     ...future.result
[08:28:14.656] }
[08:28:14.658] plan(): Setting new future strategy stack:
[08:28:14.658] List of future strategies:
[08:28:14.658] 1. sequential:
[08:28:14.658]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.658]    - tweaked: FALSE
[08:28:14.658]    - call: NULL
[08:28:14.659] plan(): nbrOfWorkers() = 1
[08:28:14.659] plan(): Setting new future strategy stack:
[08:28:14.659] List of future strategies:
[08:28:14.659] 1. sequential:
[08:28:14.659]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.659]    - tweaked: FALSE
[08:28:14.659]    - call: plan(strategy)
[08:28:14.660] plan(): nbrOfWorkers() = 1
[08:28:14.660] SequentialFuture started (and completed)
[08:28:14.660] - Launch lazy future ... done
[08:28:14.660] run() for ‘SequentialFuture’ ... done
[08:28:14.660] resolved() for ‘SequentialFuture’ ...
[08:28:14.660] - state: ‘finished’
[08:28:14.661] - run: TRUE
[08:28:14.661] - result: ‘FutureResult’
[08:28:14.661] resolved() for ‘SequentialFuture’ ... done
[08:28:14.661] Future #1
[08:28:14.661] resolved() for ‘SequentialFuture’ ...
[08:28:14.661] - state: ‘finished’
[08:28:14.661] - run: TRUE
[08:28:14.661] - result: ‘FutureResult’
[08:28:14.661] resolved() for ‘SequentialFuture’ ... done
[08:28:14.661] A SequentialFuture was resolved
[08:28:14.662]  length: 0 (resolved future 1)
[08:28:14.662] resolve() on list ... DONE
[08:28:14.662] - globals: [1] ‘a’
[08:28:14.662] Resolving futures part of globals (recursively) ... DONE
[08:28:14.662] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[08:28:14.662] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[08:28:14.662] - globals: [1] ‘a’
[08:28:14.662] - packages: [1] ‘future’
[08:28:14.663] getGlobalsAndPackages() ... DONE
[08:28:14.663] run() for ‘Future’ ...
[08:28:14.663] - state: ‘created’
[08:28:14.663] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.663] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.663] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.663]   - Field: ‘label’
[08:28:14.664]   - Field: ‘local’
[08:28:14.664]   - Field: ‘owner’
[08:28:14.664]   - Field: ‘envir’
[08:28:14.664]   - Field: ‘packages’
[08:28:14.664]   - Field: ‘gc’
[08:28:14.664]   - Field: ‘conditions’
[08:28:14.664]   - Field: ‘expr’
[08:28:14.664]   - Field: ‘uuid’
[08:28:14.664]   - Field: ‘seed’
[08:28:14.664]   - Field: ‘version’
[08:28:14.664]   - Field: ‘result’
[08:28:14.664]   - Field: ‘asynchronous’
[08:28:14.665]   - Field: ‘calls’
[08:28:14.665]   - Field: ‘globals’
[08:28:14.665]   - Field: ‘stdout’
[08:28:14.665]   - Field: ‘earlySignal’
[08:28:14.665]   - Field: ‘lazy’
[08:28:14.665]   - Field: ‘state’
[08:28:14.665] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.665] - Launch lazy future ...
[08:28:14.665] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.665] Packages needed by future strategies (n = 0): <none>
[08:28:14.666] {
[08:28:14.666]     {
[08:28:14.666]         {
[08:28:14.666]             ...future.startTime <- base::Sys.time()
[08:28:14.666]             {
[08:28:14.666]                 {
[08:28:14.666]                   {
[08:28:14.666]                     {
[08:28:14.666]                       base::local({
[08:28:14.666]                         has_future <- base::requireNamespace("future", 
[08:28:14.666]                           quietly = TRUE)
[08:28:14.666]                         if (has_future) {
[08:28:14.666]                           ns <- base::getNamespace("future")
[08:28:14.666]                           version <- ns[[".package"]][["version"]]
[08:28:14.666]                           if (is.null(version)) 
[08:28:14.666]                             version <- utils::packageVersion("future")
[08:28:14.666]                         }
[08:28:14.666]                         else {
[08:28:14.666]                           version <- NULL
[08:28:14.666]                         }
[08:28:14.666]                         if (!has_future || version < "1.8.0") {
[08:28:14.666]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.666]                             "", base::R.version$version.string), 
[08:28:14.666]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.666]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.666]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.666]                               "release", "version")], collapse = " "), 
[08:28:14.666]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.666]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.666]                             info)
[08:28:14.666]                           info <- base::paste(info, collapse = "; ")
[08:28:14.666]                           if (!has_future) {
[08:28:14.666]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.666]                               info)
[08:28:14.666]                           }
[08:28:14.666]                           else {
[08:28:14.666]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.666]                               info, version)
[08:28:14.666]                           }
[08:28:14.666]                           base::stop(msg)
[08:28:14.666]                         }
[08:28:14.666]                       })
[08:28:14.666]                     }
[08:28:14.666]                     base::local({
[08:28:14.666]                       for (pkg in "future") {
[08:28:14.666]                         base::loadNamespace(pkg)
[08:28:14.666]                         base::library(pkg, character.only = TRUE)
[08:28:14.666]                       }
[08:28:14.666]                     })
[08:28:14.666]                   }
[08:28:14.666]                   ...future.strategy.old <- future::plan("list")
[08:28:14.666]                   options(future.plan = NULL)
[08:28:14.666]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.666]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.666]                 }
[08:28:14.666]                 ...future.workdir <- getwd()
[08:28:14.666]             }
[08:28:14.666]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.666]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.666]         }
[08:28:14.666]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.666]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.666]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.666]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.666]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.666]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.666]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.666]             base::names(...future.oldOptions))
[08:28:14.666]     }
[08:28:14.666]     if (FALSE) {
[08:28:14.666]     }
[08:28:14.666]     else {
[08:28:14.666]         if (TRUE) {
[08:28:14.666]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.666]                 open = "w")
[08:28:14.666]         }
[08:28:14.666]         else {
[08:28:14.666]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.666]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.666]         }
[08:28:14.666]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.666]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.666]             base::sink(type = "output", split = FALSE)
[08:28:14.666]             base::close(...future.stdout)
[08:28:14.666]         }, add = TRUE)
[08:28:14.666]     }
[08:28:14.666]     ...future.frame <- base::sys.nframe()
[08:28:14.666]     ...future.conditions <- base::list()
[08:28:14.666]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.666]     if (FALSE) {
[08:28:14.666]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.666]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.666]     }
[08:28:14.666]     ...future.result <- base::tryCatch({
[08:28:14.666]         base::withCallingHandlers({
[08:28:14.666]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.666]                 1))
[08:28:14.666]             future::FutureResult(value = ...future.value$value, 
[08:28:14.666]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.666]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.666]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.666]                     ...future.globalenv.names))
[08:28:14.666]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.666]         }, condition = base::local({
[08:28:14.666]             c <- base::c
[08:28:14.666]             inherits <- base::inherits
[08:28:14.666]             invokeRestart <- base::invokeRestart
[08:28:14.666]             length <- base::length
[08:28:14.666]             list <- base::list
[08:28:14.666]             seq.int <- base::seq.int
[08:28:14.666]             signalCondition <- base::signalCondition
[08:28:14.666]             sys.calls <- base::sys.calls
[08:28:14.666]             `[[` <- base::`[[`
[08:28:14.666]             `+` <- base::`+`
[08:28:14.666]             `<<-` <- base::`<<-`
[08:28:14.666]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.666]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.666]                   3L)]
[08:28:14.666]             }
[08:28:14.666]             function(cond) {
[08:28:14.666]                 is_error <- inherits(cond, "error")
[08:28:14.666]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.666]                   NULL)
[08:28:14.666]                 if (is_error) {
[08:28:14.666]                   sessionInformation <- function() {
[08:28:14.666]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.666]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.666]                       search = base::search(), system = base::Sys.info())
[08:28:14.666]                   }
[08:28:14.666]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.666]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.666]                     cond$call), session = sessionInformation(), 
[08:28:14.666]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.666]                   signalCondition(cond)
[08:28:14.666]                 }
[08:28:14.666]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.666]                 "immediateCondition"))) {
[08:28:14.666]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.666]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.666]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.666]                   if (TRUE && !signal) {
[08:28:14.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.666]                     {
[08:28:14.666]                       inherits <- base::inherits
[08:28:14.666]                       invokeRestart <- base::invokeRestart
[08:28:14.666]                       is.null <- base::is.null
[08:28:14.666]                       muffled <- FALSE
[08:28:14.666]                       if (inherits(cond, "message")) {
[08:28:14.666]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.666]                         if (muffled) 
[08:28:14.666]                           invokeRestart("muffleMessage")
[08:28:14.666]                       }
[08:28:14.666]                       else if (inherits(cond, "warning")) {
[08:28:14.666]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.666]                         if (muffled) 
[08:28:14.666]                           invokeRestart("muffleWarning")
[08:28:14.666]                       }
[08:28:14.666]                       else if (inherits(cond, "condition")) {
[08:28:14.666]                         if (!is.null(pattern)) {
[08:28:14.666]                           computeRestarts <- base::computeRestarts
[08:28:14.666]                           grepl <- base::grepl
[08:28:14.666]                           restarts <- computeRestarts(cond)
[08:28:14.666]                           for (restart in restarts) {
[08:28:14.666]                             name <- restart$name
[08:28:14.666]                             if (is.null(name)) 
[08:28:14.666]                               next
[08:28:14.666]                             if (!grepl(pattern, name)) 
[08:28:14.666]                               next
[08:28:14.666]                             invokeRestart(restart)
[08:28:14.666]                             muffled <- TRUE
[08:28:14.666]                             break
[08:28:14.666]                           }
[08:28:14.666]                         }
[08:28:14.666]                       }
[08:28:14.666]                       invisible(muffled)
[08:28:14.666]                     }
[08:28:14.666]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.666]                   }
[08:28:14.666]                 }
[08:28:14.666]                 else {
[08:28:14.666]                   if (TRUE) {
[08:28:14.666]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.666]                     {
[08:28:14.666]                       inherits <- base::inherits
[08:28:14.666]                       invokeRestart <- base::invokeRestart
[08:28:14.666]                       is.null <- base::is.null
[08:28:14.666]                       muffled <- FALSE
[08:28:14.666]                       if (inherits(cond, "message")) {
[08:28:14.666]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.666]                         if (muffled) 
[08:28:14.666]                           invokeRestart("muffleMessage")
[08:28:14.666]                       }
[08:28:14.666]                       else if (inherits(cond, "warning")) {
[08:28:14.666]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.666]                         if (muffled) 
[08:28:14.666]                           invokeRestart("muffleWarning")
[08:28:14.666]                       }
[08:28:14.666]                       else if (inherits(cond, "condition")) {
[08:28:14.666]                         if (!is.null(pattern)) {
[08:28:14.666]                           computeRestarts <- base::computeRestarts
[08:28:14.666]                           grepl <- base::grepl
[08:28:14.666]                           restarts <- computeRestarts(cond)
[08:28:14.666]                           for (restart in restarts) {
[08:28:14.666]                             name <- restart$name
[08:28:14.666]                             if (is.null(name)) 
[08:28:14.666]                               next
[08:28:14.666]                             if (!grepl(pattern, name)) 
[08:28:14.666]                               next
[08:28:14.666]                             invokeRestart(restart)
[08:28:14.666]                             muffled <- TRUE
[08:28:14.666]                             break
[08:28:14.666]                           }
[08:28:14.666]                         }
[08:28:14.666]                       }
[08:28:14.666]                       invisible(muffled)
[08:28:14.666]                     }
[08:28:14.666]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.666]                   }
[08:28:14.666]                 }
[08:28:14.666]             }
[08:28:14.666]         }))
[08:28:14.666]     }, error = function(ex) {
[08:28:14.666]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.666]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.666]                 ...future.rng), started = ...future.startTime, 
[08:28:14.666]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.666]             version = "1.8"), class = "FutureResult")
[08:28:14.666]     }, finally = {
[08:28:14.666]         if (!identical(...future.workdir, getwd())) 
[08:28:14.666]             setwd(...future.workdir)
[08:28:14.666]         {
[08:28:14.666]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.666]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.666]             }
[08:28:14.666]             base::options(...future.oldOptions)
[08:28:14.666]             if (.Platform$OS.type == "windows") {
[08:28:14.666]                 old_names <- names(...future.oldEnvVars)
[08:28:14.666]                 envs <- base::Sys.getenv()
[08:28:14.666]                 names <- names(envs)
[08:28:14.666]                 common <- intersect(names, old_names)
[08:28:14.666]                 added <- setdiff(names, old_names)
[08:28:14.666]                 removed <- setdiff(old_names, names)
[08:28:14.666]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.666]                   envs[common]]
[08:28:14.666]                 NAMES <- toupper(changed)
[08:28:14.666]                 args <- list()
[08:28:14.666]                 for (kk in seq_along(NAMES)) {
[08:28:14.666]                   name <- changed[[kk]]
[08:28:14.666]                   NAME <- NAMES[[kk]]
[08:28:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.666]                     next
[08:28:14.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.666]                 }
[08:28:14.666]                 NAMES <- toupper(added)
[08:28:14.666]                 for (kk in seq_along(NAMES)) {
[08:28:14.666]                   name <- added[[kk]]
[08:28:14.666]                   NAME <- NAMES[[kk]]
[08:28:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.666]                     next
[08:28:14.666]                   args[[name]] <- ""
[08:28:14.666]                 }
[08:28:14.666]                 NAMES <- toupper(removed)
[08:28:14.666]                 for (kk in seq_along(NAMES)) {
[08:28:14.666]                   name <- removed[[kk]]
[08:28:14.666]                   NAME <- NAMES[[kk]]
[08:28:14.666]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.666]                     next
[08:28:14.666]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.666]                 }
[08:28:14.666]                 if (length(args) > 0) 
[08:28:14.666]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.666]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.666]             }
[08:28:14.666]             else {
[08:28:14.666]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.666]             }
[08:28:14.666]             {
[08:28:14.666]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.666]                   0L) {
[08:28:14.666]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.666]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.666]                   base::options(opts)
[08:28:14.666]                 }
[08:28:14.666]                 {
[08:28:14.666]                   {
[08:28:14.666]                     NULL
[08:28:14.666]                     RNGkind("Mersenne-Twister")
[08:28:14.666]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.666]                       inherits = FALSE)
[08:28:14.666]                   }
[08:28:14.666]                   options(future.plan = NULL)
[08:28:14.666]                   if (is.na(NA_character_)) 
[08:28:14.666]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.666]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.666]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.666]                     .init = FALSE)
[08:28:14.666]                 }
[08:28:14.666]             }
[08:28:14.666]         }
[08:28:14.666]     })
[08:28:14.666]     if (TRUE) {
[08:28:14.666]         base::sink(type = "output", split = FALSE)
[08:28:14.666]         if (TRUE) {
[08:28:14.666]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.666]         }
[08:28:14.666]         else {
[08:28:14.666]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.666]         }
[08:28:14.666]         base::close(...future.stdout)
[08:28:14.666]         ...future.stdout <- NULL
[08:28:14.666]     }
[08:28:14.666]     ...future.result$conditions <- ...future.conditions
[08:28:14.666]     ...future.result$finished <- base::Sys.time()
[08:28:14.666]     ...future.result
[08:28:14.666] }
[08:28:14.668] assign_globals() ...
[08:28:14.668] List of 1
[08:28:14.668]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a1076d0278> 
[08:28:14.668]  - attr(*, "where")=List of 1
[08:28:14.668]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.668]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.668]  - attr(*, "resolved")= logi TRUE
[08:28:14.668]  - attr(*, "total_size")= num 3555
[08:28:14.668]  - attr(*, "already-done")= logi TRUE
[08:28:14.670] - copied ‘a’ to environment
[08:28:14.670] assign_globals() ... done
[08:28:14.670] plan(): Setting new future strategy stack:
[08:28:14.670] List of future strategies:
[08:28:14.670] 1. sequential:
[08:28:14.670]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.670]    - tweaked: FALSE
[08:28:14.670]    - call: NULL
[08:28:14.671] plan(): nbrOfWorkers() = 1
[08:28:14.672] plan(): Setting new future strategy stack:
[08:28:14.672] List of future strategies:
[08:28:14.672] 1. sequential:
[08:28:14.672]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.672]    - tweaked: FALSE
[08:28:14.672]    - call: plan(strategy)
[08:28:14.672] plan(): nbrOfWorkers() = 1
[08:28:14.672] SequentialFuture started (and completed)
[08:28:14.672] - Launch lazy future ... done
[08:28:14.673] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.674] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.674] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.675] 
[08:28:14.675] Searching for globals ... DONE
[08:28:14.675] - globals: [0] <none>
[08:28:14.675] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.675] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.675] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.676] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:14.676] Searching for globals ... DONE
[08:28:14.676] Resolving globals: TRUE
[08:28:14.676] Resolving any globals that are futures ...
[08:28:14.676] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:14.676] Resolving any globals that are futures ... DONE
[08:28:14.677] Resolving futures part of globals (recursively) ...
[08:28:14.677] resolve() on list ...
[08:28:14.677]  recursive: 99
[08:28:14.677]  length: 1
[08:28:14.677]  elements: ‘a’
[08:28:14.677] run() for ‘Future’ ...
[08:28:14.677] - state: ‘created’
[08:28:14.678] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.678] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.678] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.678]   - Field: ‘label’
[08:28:14.678]   - Field: ‘local’
[08:28:14.678]   - Field: ‘owner’
[08:28:14.678]   - Field: ‘envir’
[08:28:14.678]   - Field: ‘packages’
[08:28:14.678]   - Field: ‘gc’
[08:28:14.679]   - Field: ‘conditions’
[08:28:14.679]   - Field: ‘expr’
[08:28:14.679]   - Field: ‘uuid’
[08:28:14.679]   - Field: ‘seed’
[08:28:14.679]   - Field: ‘version’
[08:28:14.679]   - Field: ‘result’
[08:28:14.679]   - Field: ‘asynchronous’
[08:28:14.679]   - Field: ‘calls’
[08:28:14.679]   - Field: ‘globals’
[08:28:14.679]   - Field: ‘stdout’
[08:28:14.679]   - Field: ‘earlySignal’
[08:28:14.679]   - Field: ‘lazy’
[08:28:14.679]   - Field: ‘state’
[08:28:14.680] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.680] - Launch lazy future ...
[08:28:14.680] Packages needed by the future expression (n = 0): <none>
[08:28:14.680] Packages needed by future strategies (n = 0): <none>
[08:28:14.680] {
[08:28:14.680]     {
[08:28:14.680]         {
[08:28:14.680]             ...future.startTime <- base::Sys.time()
[08:28:14.680]             {
[08:28:14.680]                 {
[08:28:14.680]                   {
[08:28:14.680]                     base::local({
[08:28:14.680]                       has_future <- base::requireNamespace("future", 
[08:28:14.680]                         quietly = TRUE)
[08:28:14.680]                       if (has_future) {
[08:28:14.680]                         ns <- base::getNamespace("future")
[08:28:14.680]                         version <- ns[[".package"]][["version"]]
[08:28:14.680]                         if (is.null(version)) 
[08:28:14.680]                           version <- utils::packageVersion("future")
[08:28:14.680]                       }
[08:28:14.680]                       else {
[08:28:14.680]                         version <- NULL
[08:28:14.680]                       }
[08:28:14.680]                       if (!has_future || version < "1.8.0") {
[08:28:14.680]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.680]                           "", base::R.version$version.string), 
[08:28:14.680]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.680]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.680]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.680]                             "release", "version")], collapse = " "), 
[08:28:14.680]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.680]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.680]                           info)
[08:28:14.680]                         info <- base::paste(info, collapse = "; ")
[08:28:14.680]                         if (!has_future) {
[08:28:14.680]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.680]                             info)
[08:28:14.680]                         }
[08:28:14.680]                         else {
[08:28:14.680]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.680]                             info, version)
[08:28:14.680]                         }
[08:28:14.680]                         base::stop(msg)
[08:28:14.680]                       }
[08:28:14.680]                     })
[08:28:14.680]                   }
[08:28:14.680]                   ...future.strategy.old <- future::plan("list")
[08:28:14.680]                   options(future.plan = NULL)
[08:28:14.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.680]                 }
[08:28:14.680]                 ...future.workdir <- getwd()
[08:28:14.680]             }
[08:28:14.680]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.680]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.680]         }
[08:28:14.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.680]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.680]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.680]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.680]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.680]             base::names(...future.oldOptions))
[08:28:14.680]     }
[08:28:14.680]     if (FALSE) {
[08:28:14.680]     }
[08:28:14.680]     else {
[08:28:14.680]         if (TRUE) {
[08:28:14.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.680]                 open = "w")
[08:28:14.680]         }
[08:28:14.680]         else {
[08:28:14.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.680]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.680]         }
[08:28:14.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.680]             base::sink(type = "output", split = FALSE)
[08:28:14.680]             base::close(...future.stdout)
[08:28:14.680]         }, add = TRUE)
[08:28:14.680]     }
[08:28:14.680]     ...future.frame <- base::sys.nframe()
[08:28:14.680]     ...future.conditions <- base::list()
[08:28:14.680]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.680]     if (FALSE) {
[08:28:14.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.680]     }
[08:28:14.680]     ...future.result <- base::tryCatch({
[08:28:14.680]         base::withCallingHandlers({
[08:28:14.680]             ...future.value <- base::withVisible(base::local(1))
[08:28:14.680]             future::FutureResult(value = ...future.value$value, 
[08:28:14.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.680]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.680]                     ...future.globalenv.names))
[08:28:14.680]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.680]         }, condition = base::local({
[08:28:14.680]             c <- base::c
[08:28:14.680]             inherits <- base::inherits
[08:28:14.680]             invokeRestart <- base::invokeRestart
[08:28:14.680]             length <- base::length
[08:28:14.680]             list <- base::list
[08:28:14.680]             seq.int <- base::seq.int
[08:28:14.680]             signalCondition <- base::signalCondition
[08:28:14.680]             sys.calls <- base::sys.calls
[08:28:14.680]             `[[` <- base::`[[`
[08:28:14.680]             `+` <- base::`+`
[08:28:14.680]             `<<-` <- base::`<<-`
[08:28:14.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.680]                   3L)]
[08:28:14.680]             }
[08:28:14.680]             function(cond) {
[08:28:14.680]                 is_error <- inherits(cond, "error")
[08:28:14.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.680]                   NULL)
[08:28:14.680]                 if (is_error) {
[08:28:14.680]                   sessionInformation <- function() {
[08:28:14.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.680]                       search = base::search(), system = base::Sys.info())
[08:28:14.680]                   }
[08:28:14.680]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.680]                     cond$call), session = sessionInformation(), 
[08:28:14.680]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.680]                   signalCondition(cond)
[08:28:14.680]                 }
[08:28:14.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.680]                 "immediateCondition"))) {
[08:28:14.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.680]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.680]                   if (TRUE && !signal) {
[08:28:14.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.680]                     {
[08:28:14.680]                       inherits <- base::inherits
[08:28:14.680]                       invokeRestart <- base::invokeRestart
[08:28:14.680]                       is.null <- base::is.null
[08:28:14.680]                       muffled <- FALSE
[08:28:14.680]                       if (inherits(cond, "message")) {
[08:28:14.680]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.680]                         if (muffled) 
[08:28:14.680]                           invokeRestart("muffleMessage")
[08:28:14.680]                       }
[08:28:14.680]                       else if (inherits(cond, "warning")) {
[08:28:14.680]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.680]                         if (muffled) 
[08:28:14.680]                           invokeRestart("muffleWarning")
[08:28:14.680]                       }
[08:28:14.680]                       else if (inherits(cond, "condition")) {
[08:28:14.680]                         if (!is.null(pattern)) {
[08:28:14.680]                           computeRestarts <- base::computeRestarts
[08:28:14.680]                           grepl <- base::grepl
[08:28:14.680]                           restarts <- computeRestarts(cond)
[08:28:14.680]                           for (restart in restarts) {
[08:28:14.680]                             name <- restart$name
[08:28:14.680]                             if (is.null(name)) 
[08:28:14.680]                               next
[08:28:14.680]                             if (!grepl(pattern, name)) 
[08:28:14.680]                               next
[08:28:14.680]                             invokeRestart(restart)
[08:28:14.680]                             muffled <- TRUE
[08:28:14.680]                             break
[08:28:14.680]                           }
[08:28:14.680]                         }
[08:28:14.680]                       }
[08:28:14.680]                       invisible(muffled)
[08:28:14.680]                     }
[08:28:14.680]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.680]                   }
[08:28:14.680]                 }
[08:28:14.680]                 else {
[08:28:14.680]                   if (TRUE) {
[08:28:14.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.680]                     {
[08:28:14.680]                       inherits <- base::inherits
[08:28:14.680]                       invokeRestart <- base::invokeRestart
[08:28:14.680]                       is.null <- base::is.null
[08:28:14.680]                       muffled <- FALSE
[08:28:14.680]                       if (inherits(cond, "message")) {
[08:28:14.680]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.680]                         if (muffled) 
[08:28:14.680]                           invokeRestart("muffleMessage")
[08:28:14.680]                       }
[08:28:14.680]                       else if (inherits(cond, "warning")) {
[08:28:14.680]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.680]                         if (muffled) 
[08:28:14.680]                           invokeRestart("muffleWarning")
[08:28:14.680]                       }
[08:28:14.680]                       else if (inherits(cond, "condition")) {
[08:28:14.680]                         if (!is.null(pattern)) {
[08:28:14.680]                           computeRestarts <- base::computeRestarts
[08:28:14.680]                           grepl <- base::grepl
[08:28:14.680]                           restarts <- computeRestarts(cond)
[08:28:14.680]                           for (restart in restarts) {
[08:28:14.680]                             name <- restart$name
[08:28:14.680]                             if (is.null(name)) 
[08:28:14.680]                               next
[08:28:14.680]                             if (!grepl(pattern, name)) 
[08:28:14.680]                               next
[08:28:14.680]                             invokeRestart(restart)
[08:28:14.680]                             muffled <- TRUE
[08:28:14.680]                             break
[08:28:14.680]                           }
[08:28:14.680]                         }
[08:28:14.680]                       }
[08:28:14.680]                       invisible(muffled)
[08:28:14.680]                     }
[08:28:14.680]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.680]                   }
[08:28:14.680]                 }
[08:28:14.680]             }
[08:28:14.680]         }))
[08:28:14.680]     }, error = function(ex) {
[08:28:14.680]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.680]                 ...future.rng), started = ...future.startTime, 
[08:28:14.680]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.680]             version = "1.8"), class = "FutureResult")
[08:28:14.680]     }, finally = {
[08:28:14.680]         if (!identical(...future.workdir, getwd())) 
[08:28:14.680]             setwd(...future.workdir)
[08:28:14.680]         {
[08:28:14.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.680]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.680]             }
[08:28:14.680]             base::options(...future.oldOptions)
[08:28:14.680]             if (.Platform$OS.type == "windows") {
[08:28:14.680]                 old_names <- names(...future.oldEnvVars)
[08:28:14.680]                 envs <- base::Sys.getenv()
[08:28:14.680]                 names <- names(envs)
[08:28:14.680]                 common <- intersect(names, old_names)
[08:28:14.680]                 added <- setdiff(names, old_names)
[08:28:14.680]                 removed <- setdiff(old_names, names)
[08:28:14.680]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.680]                   envs[common]]
[08:28:14.680]                 NAMES <- toupper(changed)
[08:28:14.680]                 args <- list()
[08:28:14.680]                 for (kk in seq_along(NAMES)) {
[08:28:14.680]                   name <- changed[[kk]]
[08:28:14.680]                   NAME <- NAMES[[kk]]
[08:28:14.680]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.680]                     next
[08:28:14.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.680]                 }
[08:28:14.680]                 NAMES <- toupper(added)
[08:28:14.680]                 for (kk in seq_along(NAMES)) {
[08:28:14.680]                   name <- added[[kk]]
[08:28:14.680]                   NAME <- NAMES[[kk]]
[08:28:14.680]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.680]                     next
[08:28:14.680]                   args[[name]] <- ""
[08:28:14.680]                 }
[08:28:14.680]                 NAMES <- toupper(removed)
[08:28:14.680]                 for (kk in seq_along(NAMES)) {
[08:28:14.680]                   name <- removed[[kk]]
[08:28:14.680]                   NAME <- NAMES[[kk]]
[08:28:14.680]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.680]                     next
[08:28:14.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.680]                 }
[08:28:14.680]                 if (length(args) > 0) 
[08:28:14.680]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.680]             }
[08:28:14.680]             else {
[08:28:14.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.680]             }
[08:28:14.680]             {
[08:28:14.680]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.680]                   0L) {
[08:28:14.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.680]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.680]                   base::options(opts)
[08:28:14.680]                 }
[08:28:14.680]                 {
[08:28:14.680]                   {
[08:28:14.680]                     NULL
[08:28:14.680]                     RNGkind("Mersenne-Twister")
[08:28:14.680]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.680]                       inherits = FALSE)
[08:28:14.680]                   }
[08:28:14.680]                   options(future.plan = NULL)
[08:28:14.680]                   if (is.na(NA_character_)) 
[08:28:14.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.680]                     .init = FALSE)
[08:28:14.680]                 }
[08:28:14.680]             }
[08:28:14.680]         }
[08:28:14.680]     })
[08:28:14.680]     if (TRUE) {
[08:28:14.680]         base::sink(type = "output", split = FALSE)
[08:28:14.680]         if (TRUE) {
[08:28:14.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.680]         }
[08:28:14.680]         else {
[08:28:14.680]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.680]         }
[08:28:14.680]         base::close(...future.stdout)
[08:28:14.680]         ...future.stdout <- NULL
[08:28:14.680]     }
[08:28:14.680]     ...future.result$conditions <- ...future.conditions
[08:28:14.680]     ...future.result$finished <- base::Sys.time()
[08:28:14.680]     ...future.result
[08:28:14.680] }
[08:28:14.682] plan(): Setting new future strategy stack:
[08:28:14.682] List of future strategies:
[08:28:14.682] 1. sequential:
[08:28:14.682]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.682]    - tweaked: FALSE
[08:28:14.682]    - call: NULL
[08:28:14.683] plan(): nbrOfWorkers() = 1
[08:28:14.683] plan(): Setting new future strategy stack:
[08:28:14.683] List of future strategies:
[08:28:14.683] 1. sequential:
[08:28:14.683]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.683]    - tweaked: FALSE
[08:28:14.683]    - call: plan(strategy)
[08:28:14.684] plan(): nbrOfWorkers() = 1
[08:28:14.684] SequentialFuture started (and completed)
[08:28:14.684] - Launch lazy future ... done
[08:28:14.684] run() for ‘SequentialFuture’ ... done
[08:28:14.684] resolved() for ‘SequentialFuture’ ...
[08:28:14.684] - state: ‘finished’
[08:28:14.684] - run: TRUE
[08:28:14.684] - result: ‘FutureResult’
[08:28:14.685] resolved() for ‘SequentialFuture’ ... done
[08:28:14.685] Future #1
[08:28:14.685] resolved() for ‘SequentialFuture’ ...
[08:28:14.685] - state: ‘finished’
[08:28:14.685] - run: TRUE
[08:28:14.685] - result: ‘FutureResult’
[08:28:14.685] resolved() for ‘SequentialFuture’ ... done
[08:28:14.685] A SequentialFuture was resolved
[08:28:14.685]  length: 0 (resolved future 1)
[08:28:14.685] resolve() on list ... DONE
[08:28:14.685] - globals: [1] ‘a’
[08:28:14.686] Resolving futures part of globals (recursively) ... DONE
[08:28:14.686] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[08:28:14.686] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[08:28:14.686] - globals: [1] ‘a’
[08:28:14.686] - packages: [1] ‘future’
[08:28:14.686] getGlobalsAndPackages() ... DONE
[08:28:14.687] run() for ‘Future’ ...
[08:28:14.687] - state: ‘created’
[08:28:14.687] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.687] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.687] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.687]   - Field: ‘label’
[08:28:14.687]   - Field: ‘local’
[08:28:14.687]   - Field: ‘owner’
[08:28:14.687]   - Field: ‘envir’
[08:28:14.688]   - Field: ‘packages’
[08:28:14.688]   - Field: ‘gc’
[08:28:14.688]   - Field: ‘conditions’
[08:28:14.688]   - Field: ‘expr’
[08:28:14.688]   - Field: ‘uuid’
[08:28:14.688]   - Field: ‘seed’
[08:28:14.688]   - Field: ‘version’
[08:28:14.688]   - Field: ‘result’
[08:28:14.688]   - Field: ‘asynchronous’
[08:28:14.688]   - Field: ‘calls’
[08:28:14.688]   - Field: ‘globals’
[08:28:14.688]   - Field: ‘stdout’
[08:28:14.688]   - Field: ‘earlySignal’
[08:28:14.689]   - Field: ‘lazy’
[08:28:14.689]   - Field: ‘state’
[08:28:14.689] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.689] - Launch lazy future ...
[08:28:14.689] Packages needed by the future expression (n = 1): ‘future’
[08:28:14.689] Packages needed by future strategies (n = 0): <none>
[08:28:14.690] {
[08:28:14.690]     {
[08:28:14.690]         {
[08:28:14.690]             ...future.startTime <- base::Sys.time()
[08:28:14.690]             {
[08:28:14.690]                 {
[08:28:14.690]                   {
[08:28:14.690]                     {
[08:28:14.690]                       base::local({
[08:28:14.690]                         has_future <- base::requireNamespace("future", 
[08:28:14.690]                           quietly = TRUE)
[08:28:14.690]                         if (has_future) {
[08:28:14.690]                           ns <- base::getNamespace("future")
[08:28:14.690]                           version <- ns[[".package"]][["version"]]
[08:28:14.690]                           if (is.null(version)) 
[08:28:14.690]                             version <- utils::packageVersion("future")
[08:28:14.690]                         }
[08:28:14.690]                         else {
[08:28:14.690]                           version <- NULL
[08:28:14.690]                         }
[08:28:14.690]                         if (!has_future || version < "1.8.0") {
[08:28:14.690]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.690]                             "", base::R.version$version.string), 
[08:28:14.690]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.690]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.690]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.690]                               "release", "version")], collapse = " "), 
[08:28:14.690]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.690]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.690]                             info)
[08:28:14.690]                           info <- base::paste(info, collapse = "; ")
[08:28:14.690]                           if (!has_future) {
[08:28:14.690]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.690]                               info)
[08:28:14.690]                           }
[08:28:14.690]                           else {
[08:28:14.690]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.690]                               info, version)
[08:28:14.690]                           }
[08:28:14.690]                           base::stop(msg)
[08:28:14.690]                         }
[08:28:14.690]                       })
[08:28:14.690]                     }
[08:28:14.690]                     base::local({
[08:28:14.690]                       for (pkg in "future") {
[08:28:14.690]                         base::loadNamespace(pkg)
[08:28:14.690]                         base::library(pkg, character.only = TRUE)
[08:28:14.690]                       }
[08:28:14.690]                     })
[08:28:14.690]                   }
[08:28:14.690]                   ...future.strategy.old <- future::plan("list")
[08:28:14.690]                   options(future.plan = NULL)
[08:28:14.690]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.690]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.690]                 }
[08:28:14.690]                 ...future.workdir <- getwd()
[08:28:14.690]             }
[08:28:14.690]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.690]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.690]         }
[08:28:14.690]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.690]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.690]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.690]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.690]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.690]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.690]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.690]             base::names(...future.oldOptions))
[08:28:14.690]     }
[08:28:14.690]     if (FALSE) {
[08:28:14.690]     }
[08:28:14.690]     else {
[08:28:14.690]         if (TRUE) {
[08:28:14.690]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.690]                 open = "w")
[08:28:14.690]         }
[08:28:14.690]         else {
[08:28:14.690]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.690]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.690]         }
[08:28:14.690]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.690]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.690]             base::sink(type = "output", split = FALSE)
[08:28:14.690]             base::close(...future.stdout)
[08:28:14.690]         }, add = TRUE)
[08:28:14.690]     }
[08:28:14.690]     ...future.frame <- base::sys.nframe()
[08:28:14.690]     ...future.conditions <- base::list()
[08:28:14.690]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.690]     if (FALSE) {
[08:28:14.690]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.690]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.690]     }
[08:28:14.690]     ...future.result <- base::tryCatch({
[08:28:14.690]         base::withCallingHandlers({
[08:28:14.690]             ...future.value <- base::withVisible(base::local(value(a) + 
[08:28:14.690]                 1))
[08:28:14.690]             future::FutureResult(value = ...future.value$value, 
[08:28:14.690]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.690]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.690]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.690]                     ...future.globalenv.names))
[08:28:14.690]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.690]         }, condition = base::local({
[08:28:14.690]             c <- base::c
[08:28:14.690]             inherits <- base::inherits
[08:28:14.690]             invokeRestart <- base::invokeRestart
[08:28:14.690]             length <- base::length
[08:28:14.690]             list <- base::list
[08:28:14.690]             seq.int <- base::seq.int
[08:28:14.690]             signalCondition <- base::signalCondition
[08:28:14.690]             sys.calls <- base::sys.calls
[08:28:14.690]             `[[` <- base::`[[`
[08:28:14.690]             `+` <- base::`+`
[08:28:14.690]             `<<-` <- base::`<<-`
[08:28:14.690]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.690]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.690]                   3L)]
[08:28:14.690]             }
[08:28:14.690]             function(cond) {
[08:28:14.690]                 is_error <- inherits(cond, "error")
[08:28:14.690]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.690]                   NULL)
[08:28:14.690]                 if (is_error) {
[08:28:14.690]                   sessionInformation <- function() {
[08:28:14.690]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.690]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.690]                       search = base::search(), system = base::Sys.info())
[08:28:14.690]                   }
[08:28:14.690]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.690]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.690]                     cond$call), session = sessionInformation(), 
[08:28:14.690]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.690]                   signalCondition(cond)
[08:28:14.690]                 }
[08:28:14.690]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.690]                 "immediateCondition"))) {
[08:28:14.690]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.690]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.690]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.690]                   if (TRUE && !signal) {
[08:28:14.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.690]                     {
[08:28:14.690]                       inherits <- base::inherits
[08:28:14.690]                       invokeRestart <- base::invokeRestart
[08:28:14.690]                       is.null <- base::is.null
[08:28:14.690]                       muffled <- FALSE
[08:28:14.690]                       if (inherits(cond, "message")) {
[08:28:14.690]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.690]                         if (muffled) 
[08:28:14.690]                           invokeRestart("muffleMessage")
[08:28:14.690]                       }
[08:28:14.690]                       else if (inherits(cond, "warning")) {
[08:28:14.690]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.690]                         if (muffled) 
[08:28:14.690]                           invokeRestart("muffleWarning")
[08:28:14.690]                       }
[08:28:14.690]                       else if (inherits(cond, "condition")) {
[08:28:14.690]                         if (!is.null(pattern)) {
[08:28:14.690]                           computeRestarts <- base::computeRestarts
[08:28:14.690]                           grepl <- base::grepl
[08:28:14.690]                           restarts <- computeRestarts(cond)
[08:28:14.690]                           for (restart in restarts) {
[08:28:14.690]                             name <- restart$name
[08:28:14.690]                             if (is.null(name)) 
[08:28:14.690]                               next
[08:28:14.690]                             if (!grepl(pattern, name)) 
[08:28:14.690]                               next
[08:28:14.690]                             invokeRestart(restart)
[08:28:14.690]                             muffled <- TRUE
[08:28:14.690]                             break
[08:28:14.690]                           }
[08:28:14.690]                         }
[08:28:14.690]                       }
[08:28:14.690]                       invisible(muffled)
[08:28:14.690]                     }
[08:28:14.690]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.690]                   }
[08:28:14.690]                 }
[08:28:14.690]                 else {
[08:28:14.690]                   if (TRUE) {
[08:28:14.690]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.690]                     {
[08:28:14.690]                       inherits <- base::inherits
[08:28:14.690]                       invokeRestart <- base::invokeRestart
[08:28:14.690]                       is.null <- base::is.null
[08:28:14.690]                       muffled <- FALSE
[08:28:14.690]                       if (inherits(cond, "message")) {
[08:28:14.690]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.690]                         if (muffled) 
[08:28:14.690]                           invokeRestart("muffleMessage")
[08:28:14.690]                       }
[08:28:14.690]                       else if (inherits(cond, "warning")) {
[08:28:14.690]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.690]                         if (muffled) 
[08:28:14.690]                           invokeRestart("muffleWarning")
[08:28:14.690]                       }
[08:28:14.690]                       else if (inherits(cond, "condition")) {
[08:28:14.690]                         if (!is.null(pattern)) {
[08:28:14.690]                           computeRestarts <- base::computeRestarts
[08:28:14.690]                           grepl <- base::grepl
[08:28:14.690]                           restarts <- computeRestarts(cond)
[08:28:14.690]                           for (restart in restarts) {
[08:28:14.690]                             name <- restart$name
[08:28:14.690]                             if (is.null(name)) 
[08:28:14.690]                               next
[08:28:14.690]                             if (!grepl(pattern, name)) 
[08:28:14.690]                               next
[08:28:14.690]                             invokeRestart(restart)
[08:28:14.690]                             muffled <- TRUE
[08:28:14.690]                             break
[08:28:14.690]                           }
[08:28:14.690]                         }
[08:28:14.690]                       }
[08:28:14.690]                       invisible(muffled)
[08:28:14.690]                     }
[08:28:14.690]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.690]                   }
[08:28:14.690]                 }
[08:28:14.690]             }
[08:28:14.690]         }))
[08:28:14.690]     }, error = function(ex) {
[08:28:14.690]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.690]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.690]                 ...future.rng), started = ...future.startTime, 
[08:28:14.690]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.690]             version = "1.8"), class = "FutureResult")
[08:28:14.690]     }, finally = {
[08:28:14.690]         if (!identical(...future.workdir, getwd())) 
[08:28:14.690]             setwd(...future.workdir)
[08:28:14.690]         {
[08:28:14.690]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.690]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.690]             }
[08:28:14.690]             base::options(...future.oldOptions)
[08:28:14.690]             if (.Platform$OS.type == "windows") {
[08:28:14.690]                 old_names <- names(...future.oldEnvVars)
[08:28:14.690]                 envs <- base::Sys.getenv()
[08:28:14.690]                 names <- names(envs)
[08:28:14.690]                 common <- intersect(names, old_names)
[08:28:14.690]                 added <- setdiff(names, old_names)
[08:28:14.690]                 removed <- setdiff(old_names, names)
[08:28:14.690]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.690]                   envs[common]]
[08:28:14.690]                 NAMES <- toupper(changed)
[08:28:14.690]                 args <- list()
[08:28:14.690]                 for (kk in seq_along(NAMES)) {
[08:28:14.690]                   name <- changed[[kk]]
[08:28:14.690]                   NAME <- NAMES[[kk]]
[08:28:14.690]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.690]                     next
[08:28:14.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.690]                 }
[08:28:14.690]                 NAMES <- toupper(added)
[08:28:14.690]                 for (kk in seq_along(NAMES)) {
[08:28:14.690]                   name <- added[[kk]]
[08:28:14.690]                   NAME <- NAMES[[kk]]
[08:28:14.690]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.690]                     next
[08:28:14.690]                   args[[name]] <- ""
[08:28:14.690]                 }
[08:28:14.690]                 NAMES <- toupper(removed)
[08:28:14.690]                 for (kk in seq_along(NAMES)) {
[08:28:14.690]                   name <- removed[[kk]]
[08:28:14.690]                   NAME <- NAMES[[kk]]
[08:28:14.690]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.690]                     next
[08:28:14.690]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.690]                 }
[08:28:14.690]                 if (length(args) > 0) 
[08:28:14.690]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.690]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.690]             }
[08:28:14.690]             else {
[08:28:14.690]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.690]             }
[08:28:14.690]             {
[08:28:14.690]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.690]                   0L) {
[08:28:14.690]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.690]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.690]                   base::options(opts)
[08:28:14.690]                 }
[08:28:14.690]                 {
[08:28:14.690]                   {
[08:28:14.690]                     NULL
[08:28:14.690]                     RNGkind("Mersenne-Twister")
[08:28:14.690]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.690]                       inherits = FALSE)
[08:28:14.690]                   }
[08:28:14.690]                   options(future.plan = NULL)
[08:28:14.690]                   if (is.na(NA_character_)) 
[08:28:14.690]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.690]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.690]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.690]                     .init = FALSE)
[08:28:14.690]                 }
[08:28:14.690]             }
[08:28:14.690]         }
[08:28:14.690]     })
[08:28:14.690]     if (TRUE) {
[08:28:14.690]         base::sink(type = "output", split = FALSE)
[08:28:14.690]         if (TRUE) {
[08:28:14.690]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.690]         }
[08:28:14.690]         else {
[08:28:14.690]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.690]         }
[08:28:14.690]         base::close(...future.stdout)
[08:28:14.690]         ...future.stdout <- NULL
[08:28:14.690]     }
[08:28:14.690]     ...future.result$conditions <- ...future.conditions
[08:28:14.690]     ...future.result$finished <- base::Sys.time()
[08:28:14.690]     ...future.result
[08:28:14.690] }
[08:28:14.691] assign_globals() ...
[08:28:14.691] List of 1
[08:28:14.691]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55a109d4b138> 
[08:28:14.691]  - attr(*, "where")=List of 1
[08:28:14.691]   ..$ a:<environment: R_EmptyEnv> 
[08:28:14.691]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.691]  - attr(*, "resolved")= logi TRUE
[08:28:14.691]  - attr(*, "total_size")= num 3555
[08:28:14.691]  - attr(*, "already-done")= logi TRUE
[08:28:14.694] - copied ‘a’ to environment
[08:28:14.694] assign_globals() ... done
[08:28:14.694] plan(): Setting new future strategy stack:
[08:28:14.694] List of future strategies:
[08:28:14.694] 1. sequential:
[08:28:14.694]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.694]    - tweaked: FALSE
[08:28:14.694]    - call: NULL
[08:28:14.694] plan(): nbrOfWorkers() = 1
[08:28:14.695] plan(): Setting new future strategy stack:
[08:28:14.695] List of future strategies:
[08:28:14.695] 1. sequential:
[08:28:14.695]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.695]    - tweaked: FALSE
[08:28:14.695]    - call: plan(strategy)
[08:28:14.696] plan(): nbrOfWorkers() = 1
[08:28:14.696] SequentialFuture started (and completed)
[08:28:14.696] - Launch lazy future ... done
[08:28:14.696] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.697] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.697] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.697] - globals found: [2] ‘{’, ‘pkg’
[08:28:14.697] Searching for globals ... DONE
[08:28:14.698] Resolving globals: TRUE
[08:28:14.698] Resolving any globals that are futures ...
[08:28:14.698] - globals: [2] ‘{’, ‘pkg’
[08:28:14.698] Resolving any globals that are futures ... DONE
[08:28:14.698] Resolving futures part of globals (recursively) ...
[08:28:14.698] resolve() on list ...
[08:28:14.698]  recursive: 99
[08:28:14.699]  length: 1
[08:28:14.699]  elements: ‘pkg’
[08:28:14.699]  length: 0 (resolved future 1)
[08:28:14.699] resolve() on list ... DONE
[08:28:14.699] - globals: [1] ‘pkg’
[08:28:14.699] Resolving futures part of globals (recursively) ... DONE
[08:28:14.699] The total size of the 1 globals is 42 bytes (42 bytes)
[08:28:14.699] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[08:28:14.699] - globals: [1] ‘pkg’
[08:28:14.700] 
[08:28:14.700] getGlobalsAndPackages() ... DONE
[08:28:14.700] Packages needed by the future expression (n = 0): <none>
[08:28:14.700] Packages needed by future strategies (n = 0): <none>
[08:28:14.701] {
[08:28:14.701]     {
[08:28:14.701]         {
[08:28:14.701]             ...future.startTime <- base::Sys.time()
[08:28:14.701]             {
[08:28:14.701]                 {
[08:28:14.701]                   {
[08:28:14.701]                     base::local({
[08:28:14.701]                       has_future <- base::requireNamespace("future", 
[08:28:14.701]                         quietly = TRUE)
[08:28:14.701]                       if (has_future) {
[08:28:14.701]                         ns <- base::getNamespace("future")
[08:28:14.701]                         version <- ns[[".package"]][["version"]]
[08:28:14.701]                         if (is.null(version)) 
[08:28:14.701]                           version <- utils::packageVersion("future")
[08:28:14.701]                       }
[08:28:14.701]                       else {
[08:28:14.701]                         version <- NULL
[08:28:14.701]                       }
[08:28:14.701]                       if (!has_future || version < "1.8.0") {
[08:28:14.701]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.701]                           "", base::R.version$version.string), 
[08:28:14.701]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.701]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.701]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.701]                             "release", "version")], collapse = " "), 
[08:28:14.701]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.701]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.701]                           info)
[08:28:14.701]                         info <- base::paste(info, collapse = "; ")
[08:28:14.701]                         if (!has_future) {
[08:28:14.701]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.701]                             info)
[08:28:14.701]                         }
[08:28:14.701]                         else {
[08:28:14.701]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.701]                             info, version)
[08:28:14.701]                         }
[08:28:14.701]                         base::stop(msg)
[08:28:14.701]                       }
[08:28:14.701]                     })
[08:28:14.701]                   }
[08:28:14.701]                   ...future.strategy.old <- future::plan("list")
[08:28:14.701]                   options(future.plan = NULL)
[08:28:14.701]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.701]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.701]                 }
[08:28:14.701]                 ...future.workdir <- getwd()
[08:28:14.701]             }
[08:28:14.701]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.701]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.701]         }
[08:28:14.701]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.701]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.701]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.701]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.701]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.701]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.701]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.701]             base::names(...future.oldOptions))
[08:28:14.701]     }
[08:28:14.701]     if (FALSE) {
[08:28:14.701]     }
[08:28:14.701]     else {
[08:28:14.701]         if (TRUE) {
[08:28:14.701]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.701]                 open = "w")
[08:28:14.701]         }
[08:28:14.701]         else {
[08:28:14.701]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.701]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.701]         }
[08:28:14.701]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.701]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.701]             base::sink(type = "output", split = FALSE)
[08:28:14.701]             base::close(...future.stdout)
[08:28:14.701]         }, add = TRUE)
[08:28:14.701]     }
[08:28:14.701]     ...future.frame <- base::sys.nframe()
[08:28:14.701]     ...future.conditions <- base::list()
[08:28:14.701]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.701]     if (FALSE) {
[08:28:14.701]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.701]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.701]     }
[08:28:14.701]     ...future.result <- base::tryCatch({
[08:28:14.701]         base::withCallingHandlers({
[08:28:14.701]             ...future.value <- base::withVisible(base::local({
[08:28:14.701]                 pkg
[08:28:14.701]             }))
[08:28:14.701]             future::FutureResult(value = ...future.value$value, 
[08:28:14.701]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.701]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.701]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.701]                     ...future.globalenv.names))
[08:28:14.701]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.701]         }, condition = base::local({
[08:28:14.701]             c <- base::c
[08:28:14.701]             inherits <- base::inherits
[08:28:14.701]             invokeRestart <- base::invokeRestart
[08:28:14.701]             length <- base::length
[08:28:14.701]             list <- base::list
[08:28:14.701]             seq.int <- base::seq.int
[08:28:14.701]             signalCondition <- base::signalCondition
[08:28:14.701]             sys.calls <- base::sys.calls
[08:28:14.701]             `[[` <- base::`[[`
[08:28:14.701]             `+` <- base::`+`
[08:28:14.701]             `<<-` <- base::`<<-`
[08:28:14.701]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.701]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.701]                   3L)]
[08:28:14.701]             }
[08:28:14.701]             function(cond) {
[08:28:14.701]                 is_error <- inherits(cond, "error")
[08:28:14.701]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.701]                   NULL)
[08:28:14.701]                 if (is_error) {
[08:28:14.701]                   sessionInformation <- function() {
[08:28:14.701]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.701]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.701]                       search = base::search(), system = base::Sys.info())
[08:28:14.701]                   }
[08:28:14.701]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.701]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.701]                     cond$call), session = sessionInformation(), 
[08:28:14.701]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.701]                   signalCondition(cond)
[08:28:14.701]                 }
[08:28:14.701]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.701]                 "immediateCondition"))) {
[08:28:14.701]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.701]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.701]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.701]                   if (TRUE && !signal) {
[08:28:14.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.701]                     {
[08:28:14.701]                       inherits <- base::inherits
[08:28:14.701]                       invokeRestart <- base::invokeRestart
[08:28:14.701]                       is.null <- base::is.null
[08:28:14.701]                       muffled <- FALSE
[08:28:14.701]                       if (inherits(cond, "message")) {
[08:28:14.701]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.701]                         if (muffled) 
[08:28:14.701]                           invokeRestart("muffleMessage")
[08:28:14.701]                       }
[08:28:14.701]                       else if (inherits(cond, "warning")) {
[08:28:14.701]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.701]                         if (muffled) 
[08:28:14.701]                           invokeRestart("muffleWarning")
[08:28:14.701]                       }
[08:28:14.701]                       else if (inherits(cond, "condition")) {
[08:28:14.701]                         if (!is.null(pattern)) {
[08:28:14.701]                           computeRestarts <- base::computeRestarts
[08:28:14.701]                           grepl <- base::grepl
[08:28:14.701]                           restarts <- computeRestarts(cond)
[08:28:14.701]                           for (restart in restarts) {
[08:28:14.701]                             name <- restart$name
[08:28:14.701]                             if (is.null(name)) 
[08:28:14.701]                               next
[08:28:14.701]                             if (!grepl(pattern, name)) 
[08:28:14.701]                               next
[08:28:14.701]                             invokeRestart(restart)
[08:28:14.701]                             muffled <- TRUE
[08:28:14.701]                             break
[08:28:14.701]                           }
[08:28:14.701]                         }
[08:28:14.701]                       }
[08:28:14.701]                       invisible(muffled)
[08:28:14.701]                     }
[08:28:14.701]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.701]                   }
[08:28:14.701]                 }
[08:28:14.701]                 else {
[08:28:14.701]                   if (TRUE) {
[08:28:14.701]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.701]                     {
[08:28:14.701]                       inherits <- base::inherits
[08:28:14.701]                       invokeRestart <- base::invokeRestart
[08:28:14.701]                       is.null <- base::is.null
[08:28:14.701]                       muffled <- FALSE
[08:28:14.701]                       if (inherits(cond, "message")) {
[08:28:14.701]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.701]                         if (muffled) 
[08:28:14.701]                           invokeRestart("muffleMessage")
[08:28:14.701]                       }
[08:28:14.701]                       else if (inherits(cond, "warning")) {
[08:28:14.701]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.701]                         if (muffled) 
[08:28:14.701]                           invokeRestart("muffleWarning")
[08:28:14.701]                       }
[08:28:14.701]                       else if (inherits(cond, "condition")) {
[08:28:14.701]                         if (!is.null(pattern)) {
[08:28:14.701]                           computeRestarts <- base::computeRestarts
[08:28:14.701]                           grepl <- base::grepl
[08:28:14.701]                           restarts <- computeRestarts(cond)
[08:28:14.701]                           for (restart in restarts) {
[08:28:14.701]                             name <- restart$name
[08:28:14.701]                             if (is.null(name)) 
[08:28:14.701]                               next
[08:28:14.701]                             if (!grepl(pattern, name)) 
[08:28:14.701]                               next
[08:28:14.701]                             invokeRestart(restart)
[08:28:14.701]                             muffled <- TRUE
[08:28:14.701]                             break
[08:28:14.701]                           }
[08:28:14.701]                         }
[08:28:14.701]                       }
[08:28:14.701]                       invisible(muffled)
[08:28:14.701]                     }
[08:28:14.701]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.701]                   }
[08:28:14.701]                 }
[08:28:14.701]             }
[08:28:14.701]         }))
[08:28:14.701]     }, error = function(ex) {
[08:28:14.701]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.701]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.701]                 ...future.rng), started = ...future.startTime, 
[08:28:14.701]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.701]             version = "1.8"), class = "FutureResult")
[08:28:14.701]     }, finally = {
[08:28:14.701]         if (!identical(...future.workdir, getwd())) 
[08:28:14.701]             setwd(...future.workdir)
[08:28:14.701]         {
[08:28:14.701]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.701]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.701]             }
[08:28:14.701]             base::options(...future.oldOptions)
[08:28:14.701]             if (.Platform$OS.type == "windows") {
[08:28:14.701]                 old_names <- names(...future.oldEnvVars)
[08:28:14.701]                 envs <- base::Sys.getenv()
[08:28:14.701]                 names <- names(envs)
[08:28:14.701]                 common <- intersect(names, old_names)
[08:28:14.701]                 added <- setdiff(names, old_names)
[08:28:14.701]                 removed <- setdiff(old_names, names)
[08:28:14.701]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.701]                   envs[common]]
[08:28:14.701]                 NAMES <- toupper(changed)
[08:28:14.701]                 args <- list()
[08:28:14.701]                 for (kk in seq_along(NAMES)) {
[08:28:14.701]                   name <- changed[[kk]]
[08:28:14.701]                   NAME <- NAMES[[kk]]
[08:28:14.701]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.701]                     next
[08:28:14.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.701]                 }
[08:28:14.701]                 NAMES <- toupper(added)
[08:28:14.701]                 for (kk in seq_along(NAMES)) {
[08:28:14.701]                   name <- added[[kk]]
[08:28:14.701]                   NAME <- NAMES[[kk]]
[08:28:14.701]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.701]                     next
[08:28:14.701]                   args[[name]] <- ""
[08:28:14.701]                 }
[08:28:14.701]                 NAMES <- toupper(removed)
[08:28:14.701]                 for (kk in seq_along(NAMES)) {
[08:28:14.701]                   name <- removed[[kk]]
[08:28:14.701]                   NAME <- NAMES[[kk]]
[08:28:14.701]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.701]                     next
[08:28:14.701]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.701]                 }
[08:28:14.701]                 if (length(args) > 0) 
[08:28:14.701]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.701]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.701]             }
[08:28:14.701]             else {
[08:28:14.701]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.701]             }
[08:28:14.701]             {
[08:28:14.701]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.701]                   0L) {
[08:28:14.701]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.701]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.701]                   base::options(opts)
[08:28:14.701]                 }
[08:28:14.701]                 {
[08:28:14.701]                   {
[08:28:14.701]                     NULL
[08:28:14.701]                     RNGkind("Mersenne-Twister")
[08:28:14.701]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.701]                       inherits = FALSE)
[08:28:14.701]                   }
[08:28:14.701]                   options(future.plan = NULL)
[08:28:14.701]                   if (is.na(NA_character_)) 
[08:28:14.701]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.701]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.701]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.701]                     .init = FALSE)
[08:28:14.701]                 }
[08:28:14.701]             }
[08:28:14.701]         }
[08:28:14.701]     })
[08:28:14.701]     if (TRUE) {
[08:28:14.701]         base::sink(type = "output", split = FALSE)
[08:28:14.701]         if (TRUE) {
[08:28:14.701]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.701]         }
[08:28:14.701]         else {
[08:28:14.701]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.701]         }
[08:28:14.701]         base::close(...future.stdout)
[08:28:14.701]         ...future.stdout <- NULL
[08:28:14.701]     }
[08:28:14.701]     ...future.result$conditions <- ...future.conditions
[08:28:14.701]     ...future.result$finished <- base::Sys.time()
[08:28:14.701]     ...future.result
[08:28:14.701] }
[08:28:14.703] assign_globals() ...
[08:28:14.703] List of 1
[08:28:14.703]  $ pkg: chr "foo"
[08:28:14.703]  - attr(*, "where")=List of 1
[08:28:14.703]   ..$ pkg:<environment: R_EmptyEnv> 
[08:28:14.703]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.703]  - attr(*, "resolved")= logi TRUE
[08:28:14.703]  - attr(*, "total_size")= num 42
[08:28:14.705] - copied ‘pkg’ to environment
[08:28:14.705] assign_globals() ... done
[08:28:14.705] plan(): Setting new future strategy stack:
[08:28:14.705] List of future strategies:
[08:28:14.705] 1. sequential:
[08:28:14.705]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.705]    - tweaked: FALSE
[08:28:14.705]    - call: NULL
[08:28:14.706] plan(): nbrOfWorkers() = 1
[08:28:14.707] plan(): Setting new future strategy stack:
[08:28:14.707] List of future strategies:
[08:28:14.707] 1. sequential:
[08:28:14.707]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.707]    - tweaked: FALSE
[08:28:14.707]    - call: plan(strategy)
[08:28:14.707] plan(): nbrOfWorkers() = 1
[08:28:14.707] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.708] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.708] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.709] - globals found: [3] ‘{’, ‘<-’, ‘+’
[08:28:14.710] Searching for globals ... DONE
[08:28:14.710] Resolving globals: TRUE
[08:28:14.710] Resolving any globals that are futures ...
[08:28:14.710] - globals: [3] ‘{’, ‘<-’, ‘+’
[08:28:14.710] Resolving any globals that are futures ... DONE
[08:28:14.710] 
[08:28:14.710] 
[08:28:14.710] getGlobalsAndPackages() ... DONE
[08:28:14.711] run() for ‘Future’ ...
[08:28:14.711] - state: ‘created’
[08:28:14.711] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.711] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.711] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.711]   - Field: ‘label’
[08:28:14.711]   - Field: ‘local’
[08:28:14.711]   - Field: ‘owner’
[08:28:14.711]   - Field: ‘envir’
[08:28:14.712]   - Field: ‘packages’
[08:28:14.712]   - Field: ‘gc’
[08:28:14.712]   - Field: ‘conditions’
[08:28:14.712]   - Field: ‘expr’
[08:28:14.712]   - Field: ‘uuid’
[08:28:14.712]   - Field: ‘seed’
[08:28:14.712]   - Field: ‘version’
[08:28:14.712]   - Field: ‘result’
[08:28:14.712]   - Field: ‘asynchronous’
[08:28:14.712]   - Field: ‘calls’
[08:28:14.712]   - Field: ‘globals’
[08:28:14.712]   - Field: ‘stdout’
[08:28:14.712]   - Field: ‘earlySignal’
[08:28:14.713]   - Field: ‘lazy’
[08:28:14.713]   - Field: ‘state’
[08:28:14.713] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.713] - Launch lazy future ...
[08:28:14.713] Packages needed by the future expression (n = 0): <none>
[08:28:14.713] Packages needed by future strategies (n = 0): <none>
[08:28:14.713] {
[08:28:14.713]     {
[08:28:14.713]         {
[08:28:14.713]             ...future.startTime <- base::Sys.time()
[08:28:14.713]             {
[08:28:14.713]                 {
[08:28:14.713]                   {
[08:28:14.713]                     base::local({
[08:28:14.713]                       has_future <- base::requireNamespace("future", 
[08:28:14.713]                         quietly = TRUE)
[08:28:14.713]                       if (has_future) {
[08:28:14.713]                         ns <- base::getNamespace("future")
[08:28:14.713]                         version <- ns[[".package"]][["version"]]
[08:28:14.713]                         if (is.null(version)) 
[08:28:14.713]                           version <- utils::packageVersion("future")
[08:28:14.713]                       }
[08:28:14.713]                       else {
[08:28:14.713]                         version <- NULL
[08:28:14.713]                       }
[08:28:14.713]                       if (!has_future || version < "1.8.0") {
[08:28:14.713]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.713]                           "", base::R.version$version.string), 
[08:28:14.713]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.713]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.713]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.713]                             "release", "version")], collapse = " "), 
[08:28:14.713]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.713]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.713]                           info)
[08:28:14.713]                         info <- base::paste(info, collapse = "; ")
[08:28:14.713]                         if (!has_future) {
[08:28:14.713]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.713]                             info)
[08:28:14.713]                         }
[08:28:14.713]                         else {
[08:28:14.713]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.713]                             info, version)
[08:28:14.713]                         }
[08:28:14.713]                         base::stop(msg)
[08:28:14.713]                       }
[08:28:14.713]                     })
[08:28:14.713]                   }
[08:28:14.713]                   ...future.strategy.old <- future::plan("list")
[08:28:14.713]                   options(future.plan = NULL)
[08:28:14.713]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.713]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.713]                 }
[08:28:14.713]                 ...future.workdir <- getwd()
[08:28:14.713]             }
[08:28:14.713]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.713]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.713]         }
[08:28:14.713]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.713]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.713]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.713]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.713]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.713]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.713]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.713]             base::names(...future.oldOptions))
[08:28:14.713]     }
[08:28:14.713]     if (FALSE) {
[08:28:14.713]     }
[08:28:14.713]     else {
[08:28:14.713]         if (TRUE) {
[08:28:14.713]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.713]                 open = "w")
[08:28:14.713]         }
[08:28:14.713]         else {
[08:28:14.713]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.713]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.713]         }
[08:28:14.713]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.713]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.713]             base::sink(type = "output", split = FALSE)
[08:28:14.713]             base::close(...future.stdout)
[08:28:14.713]         }, add = TRUE)
[08:28:14.713]     }
[08:28:14.713]     ...future.frame <- base::sys.nframe()
[08:28:14.713]     ...future.conditions <- base::list()
[08:28:14.713]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.713]     if (FALSE) {
[08:28:14.713]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.713]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.713]     }
[08:28:14.713]     ...future.result <- base::tryCatch({
[08:28:14.713]         base::withCallingHandlers({
[08:28:14.713]             ...future.value <- base::withVisible(base::local({
[08:28:14.713]                 x <- 0
[08:28:14.713]                 x <- x + 1
[08:28:14.713]                 x
[08:28:14.713]             }))
[08:28:14.713]             future::FutureResult(value = ...future.value$value, 
[08:28:14.713]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.713]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.713]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.713]                     ...future.globalenv.names))
[08:28:14.713]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.713]         }, condition = base::local({
[08:28:14.713]             c <- base::c
[08:28:14.713]             inherits <- base::inherits
[08:28:14.713]             invokeRestart <- base::invokeRestart
[08:28:14.713]             length <- base::length
[08:28:14.713]             list <- base::list
[08:28:14.713]             seq.int <- base::seq.int
[08:28:14.713]             signalCondition <- base::signalCondition
[08:28:14.713]             sys.calls <- base::sys.calls
[08:28:14.713]             `[[` <- base::`[[`
[08:28:14.713]             `+` <- base::`+`
[08:28:14.713]             `<<-` <- base::`<<-`
[08:28:14.713]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.713]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.713]                   3L)]
[08:28:14.713]             }
[08:28:14.713]             function(cond) {
[08:28:14.713]                 is_error <- inherits(cond, "error")
[08:28:14.713]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.713]                   NULL)
[08:28:14.713]                 if (is_error) {
[08:28:14.713]                   sessionInformation <- function() {
[08:28:14.713]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.713]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.713]                       search = base::search(), system = base::Sys.info())
[08:28:14.713]                   }
[08:28:14.713]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.713]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.713]                     cond$call), session = sessionInformation(), 
[08:28:14.713]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.713]                   signalCondition(cond)
[08:28:14.713]                 }
[08:28:14.713]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.713]                 "immediateCondition"))) {
[08:28:14.713]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.713]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.713]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.713]                   if (TRUE && !signal) {
[08:28:14.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.713]                     {
[08:28:14.713]                       inherits <- base::inherits
[08:28:14.713]                       invokeRestart <- base::invokeRestart
[08:28:14.713]                       is.null <- base::is.null
[08:28:14.713]                       muffled <- FALSE
[08:28:14.713]                       if (inherits(cond, "message")) {
[08:28:14.713]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.713]                         if (muffled) 
[08:28:14.713]                           invokeRestart("muffleMessage")
[08:28:14.713]                       }
[08:28:14.713]                       else if (inherits(cond, "warning")) {
[08:28:14.713]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.713]                         if (muffled) 
[08:28:14.713]                           invokeRestart("muffleWarning")
[08:28:14.713]                       }
[08:28:14.713]                       else if (inherits(cond, "condition")) {
[08:28:14.713]                         if (!is.null(pattern)) {
[08:28:14.713]                           computeRestarts <- base::computeRestarts
[08:28:14.713]                           grepl <- base::grepl
[08:28:14.713]                           restarts <- computeRestarts(cond)
[08:28:14.713]                           for (restart in restarts) {
[08:28:14.713]                             name <- restart$name
[08:28:14.713]                             if (is.null(name)) 
[08:28:14.713]                               next
[08:28:14.713]                             if (!grepl(pattern, name)) 
[08:28:14.713]                               next
[08:28:14.713]                             invokeRestart(restart)
[08:28:14.713]                             muffled <- TRUE
[08:28:14.713]                             break
[08:28:14.713]                           }
[08:28:14.713]                         }
[08:28:14.713]                       }
[08:28:14.713]                       invisible(muffled)
[08:28:14.713]                     }
[08:28:14.713]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.713]                   }
[08:28:14.713]                 }
[08:28:14.713]                 else {
[08:28:14.713]                   if (TRUE) {
[08:28:14.713]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.713]                     {
[08:28:14.713]                       inherits <- base::inherits
[08:28:14.713]                       invokeRestart <- base::invokeRestart
[08:28:14.713]                       is.null <- base::is.null
[08:28:14.713]                       muffled <- FALSE
[08:28:14.713]                       if (inherits(cond, "message")) {
[08:28:14.713]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.713]                         if (muffled) 
[08:28:14.713]                           invokeRestart("muffleMessage")
[08:28:14.713]                       }
[08:28:14.713]                       else if (inherits(cond, "warning")) {
[08:28:14.713]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.713]                         if (muffled) 
[08:28:14.713]                           invokeRestart("muffleWarning")
[08:28:14.713]                       }
[08:28:14.713]                       else if (inherits(cond, "condition")) {
[08:28:14.713]                         if (!is.null(pattern)) {
[08:28:14.713]                           computeRestarts <- base::computeRestarts
[08:28:14.713]                           grepl <- base::grepl
[08:28:14.713]                           restarts <- computeRestarts(cond)
[08:28:14.713]                           for (restart in restarts) {
[08:28:14.713]                             name <- restart$name
[08:28:14.713]                             if (is.null(name)) 
[08:28:14.713]                               next
[08:28:14.713]                             if (!grepl(pattern, name)) 
[08:28:14.713]                               next
[08:28:14.713]                             invokeRestart(restart)
[08:28:14.713]                             muffled <- TRUE
[08:28:14.713]                             break
[08:28:14.713]                           }
[08:28:14.713]                         }
[08:28:14.713]                       }
[08:28:14.713]                       invisible(muffled)
[08:28:14.713]                     }
[08:28:14.713]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.713]                   }
[08:28:14.713]                 }
[08:28:14.713]             }
[08:28:14.713]         }))
[08:28:14.713]     }, error = function(ex) {
[08:28:14.713]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.713]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.713]                 ...future.rng), started = ...future.startTime, 
[08:28:14.713]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.713]             version = "1.8"), class = "FutureResult")
[08:28:14.713]     }, finally = {
[08:28:14.713]         if (!identical(...future.workdir, getwd())) 
[08:28:14.713]             setwd(...future.workdir)
[08:28:14.713]         {
[08:28:14.713]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.713]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.713]             }
[08:28:14.713]             base::options(...future.oldOptions)
[08:28:14.713]             if (.Platform$OS.type == "windows") {
[08:28:14.713]                 old_names <- names(...future.oldEnvVars)
[08:28:14.713]                 envs <- base::Sys.getenv()
[08:28:14.713]                 names <- names(envs)
[08:28:14.713]                 common <- intersect(names, old_names)
[08:28:14.713]                 added <- setdiff(names, old_names)
[08:28:14.713]                 removed <- setdiff(old_names, names)
[08:28:14.713]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.713]                   envs[common]]
[08:28:14.713]                 NAMES <- toupper(changed)
[08:28:14.713]                 args <- list()
[08:28:14.713]                 for (kk in seq_along(NAMES)) {
[08:28:14.713]                   name <- changed[[kk]]
[08:28:14.713]                   NAME <- NAMES[[kk]]
[08:28:14.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.713]                     next
[08:28:14.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.713]                 }
[08:28:14.713]                 NAMES <- toupper(added)
[08:28:14.713]                 for (kk in seq_along(NAMES)) {
[08:28:14.713]                   name <- added[[kk]]
[08:28:14.713]                   NAME <- NAMES[[kk]]
[08:28:14.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.713]                     next
[08:28:14.713]                   args[[name]] <- ""
[08:28:14.713]                 }
[08:28:14.713]                 NAMES <- toupper(removed)
[08:28:14.713]                 for (kk in seq_along(NAMES)) {
[08:28:14.713]                   name <- removed[[kk]]
[08:28:14.713]                   NAME <- NAMES[[kk]]
[08:28:14.713]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.713]                     next
[08:28:14.713]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.713]                 }
[08:28:14.713]                 if (length(args) > 0) 
[08:28:14.713]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.713]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.713]             }
[08:28:14.713]             else {
[08:28:14.713]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.713]             }
[08:28:14.713]             {
[08:28:14.713]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.713]                   0L) {
[08:28:14.713]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.713]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.713]                   base::options(opts)
[08:28:14.713]                 }
[08:28:14.713]                 {
[08:28:14.713]                   {
[08:28:14.713]                     NULL
[08:28:14.713]                     RNGkind("Mersenne-Twister")
[08:28:14.713]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.713]                       inherits = FALSE)
[08:28:14.713]                   }
[08:28:14.713]                   options(future.plan = NULL)
[08:28:14.713]                   if (is.na(NA_character_)) 
[08:28:14.713]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.713]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.713]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.713]                     .init = FALSE)
[08:28:14.713]                 }
[08:28:14.713]             }
[08:28:14.713]         }
[08:28:14.713]     })
[08:28:14.713]     if (TRUE) {
[08:28:14.713]         base::sink(type = "output", split = FALSE)
[08:28:14.713]         if (TRUE) {
[08:28:14.713]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.713]         }
[08:28:14.713]         else {
[08:28:14.713]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.713]         }
[08:28:14.713]         base::close(...future.stdout)
[08:28:14.713]         ...future.stdout <- NULL
[08:28:14.713]     }
[08:28:14.713]     ...future.result$conditions <- ...future.conditions
[08:28:14.713]     ...future.result$finished <- base::Sys.time()
[08:28:14.713]     ...future.result
[08:28:14.713] }
[08:28:14.715] plan(): Setting new future strategy stack:
[08:28:14.715] List of future strategies:
[08:28:14.715] 1. sequential:
[08:28:14.715]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.715]    - tweaked: FALSE
[08:28:14.715]    - call: NULL
[08:28:14.716] plan(): nbrOfWorkers() = 1
[08:28:14.716] plan(): Setting new future strategy stack:
[08:28:14.716] List of future strategies:
[08:28:14.716] 1. sequential:
[08:28:14.716]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.716]    - tweaked: FALSE
[08:28:14.716]    - call: plan(strategy)
[08:28:14.717] plan(): nbrOfWorkers() = 1
[08:28:14.717] SequentialFuture started (and completed)
[08:28:14.717] - Launch lazy future ... done
[08:28:14.717] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.718] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.718] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.719] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[08:28:14.719] Searching for globals ... DONE
[08:28:14.719] Resolving globals: TRUE
[08:28:14.719] Resolving any globals that are futures ...
[08:28:14.719] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[08:28:14.719] Resolving any globals that are futures ... DONE
[08:28:14.720] Resolving futures part of globals (recursively) ...
[08:28:14.720] resolve() on list ...
[08:28:14.720]  recursive: 99
[08:28:14.720]  length: 1
[08:28:14.720]  elements: ‘x’
[08:28:14.720]  length: 0 (resolved future 1)
[08:28:14.720] resolve() on list ... DONE
[08:28:14.720] - globals: [1] ‘x’
[08:28:14.721] Resolving futures part of globals (recursively) ... DONE
[08:28:14.721] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:14.721] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[08:28:14.721] - globals: [1] ‘x’
[08:28:14.721] 
[08:28:14.721] getGlobalsAndPackages() ... DONE
[08:28:14.721] run() for ‘Future’ ...
[08:28:14.722] - state: ‘created’
[08:28:14.722] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.722] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.722] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.722]   - Field: ‘label’
[08:28:14.722]   - Field: ‘local’
[08:28:14.722]   - Field: ‘owner’
[08:28:14.722]   - Field: ‘envir’
[08:28:14.722]   - Field: ‘packages’
[08:28:14.723]   - Field: ‘gc’
[08:28:14.723]   - Field: ‘conditions’
[08:28:14.723]   - Field: ‘expr’
[08:28:14.723]   - Field: ‘uuid’
[08:28:14.723]   - Field: ‘seed’
[08:28:14.723]   - Field: ‘version’
[08:28:14.723]   - Field: ‘result’
[08:28:14.723]   - Field: ‘asynchronous’
[08:28:14.723]   - Field: ‘calls’
[08:28:14.723]   - Field: ‘globals’
[08:28:14.723]   - Field: ‘stdout’
[08:28:14.723]   - Field: ‘earlySignal’
[08:28:14.723]   - Field: ‘lazy’
[08:28:14.724]   - Field: ‘state’
[08:28:14.724] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.724] - Launch lazy future ...
[08:28:14.724] Packages needed by the future expression (n = 0): <none>
[08:28:14.724] Packages needed by future strategies (n = 0): <none>
[08:28:14.724] {
[08:28:14.724]     {
[08:28:14.724]         {
[08:28:14.724]             ...future.startTime <- base::Sys.time()
[08:28:14.724]             {
[08:28:14.724]                 {
[08:28:14.724]                   {
[08:28:14.724]                     base::local({
[08:28:14.724]                       has_future <- base::requireNamespace("future", 
[08:28:14.724]                         quietly = TRUE)
[08:28:14.724]                       if (has_future) {
[08:28:14.724]                         ns <- base::getNamespace("future")
[08:28:14.724]                         version <- ns[[".package"]][["version"]]
[08:28:14.724]                         if (is.null(version)) 
[08:28:14.724]                           version <- utils::packageVersion("future")
[08:28:14.724]                       }
[08:28:14.724]                       else {
[08:28:14.724]                         version <- NULL
[08:28:14.724]                       }
[08:28:14.724]                       if (!has_future || version < "1.8.0") {
[08:28:14.724]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.724]                           "", base::R.version$version.string), 
[08:28:14.724]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.724]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.724]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.724]                             "release", "version")], collapse = " "), 
[08:28:14.724]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.724]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.724]                           info)
[08:28:14.724]                         info <- base::paste(info, collapse = "; ")
[08:28:14.724]                         if (!has_future) {
[08:28:14.724]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.724]                             info)
[08:28:14.724]                         }
[08:28:14.724]                         else {
[08:28:14.724]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.724]                             info, version)
[08:28:14.724]                         }
[08:28:14.724]                         base::stop(msg)
[08:28:14.724]                       }
[08:28:14.724]                     })
[08:28:14.724]                   }
[08:28:14.724]                   ...future.strategy.old <- future::plan("list")
[08:28:14.724]                   options(future.plan = NULL)
[08:28:14.724]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.724]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.724]                 }
[08:28:14.724]                 ...future.workdir <- getwd()
[08:28:14.724]             }
[08:28:14.724]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.724]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.724]         }
[08:28:14.724]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.724]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.724]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.724]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.724]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.724]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.724]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.724]             base::names(...future.oldOptions))
[08:28:14.724]     }
[08:28:14.724]     if (FALSE) {
[08:28:14.724]     }
[08:28:14.724]     else {
[08:28:14.724]         if (TRUE) {
[08:28:14.724]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.724]                 open = "w")
[08:28:14.724]         }
[08:28:14.724]         else {
[08:28:14.724]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.724]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.724]         }
[08:28:14.724]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.724]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.724]             base::sink(type = "output", split = FALSE)
[08:28:14.724]             base::close(...future.stdout)
[08:28:14.724]         }, add = TRUE)
[08:28:14.724]     }
[08:28:14.724]     ...future.frame <- base::sys.nframe()
[08:28:14.724]     ...future.conditions <- base::list()
[08:28:14.724]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.724]     if (FALSE) {
[08:28:14.724]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.724]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.724]     }
[08:28:14.724]     ...future.result <- base::tryCatch({
[08:28:14.724]         base::withCallingHandlers({
[08:28:14.724]             ...future.value <- base::withVisible(base::local({
[08:28:14.724]                 x <- x + 1
[08:28:14.724]                 x
[08:28:14.724]             }))
[08:28:14.724]             future::FutureResult(value = ...future.value$value, 
[08:28:14.724]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.724]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.724]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.724]                     ...future.globalenv.names))
[08:28:14.724]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.724]         }, condition = base::local({
[08:28:14.724]             c <- base::c
[08:28:14.724]             inherits <- base::inherits
[08:28:14.724]             invokeRestart <- base::invokeRestart
[08:28:14.724]             length <- base::length
[08:28:14.724]             list <- base::list
[08:28:14.724]             seq.int <- base::seq.int
[08:28:14.724]             signalCondition <- base::signalCondition
[08:28:14.724]             sys.calls <- base::sys.calls
[08:28:14.724]             `[[` <- base::`[[`
[08:28:14.724]             `+` <- base::`+`
[08:28:14.724]             `<<-` <- base::`<<-`
[08:28:14.724]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.724]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.724]                   3L)]
[08:28:14.724]             }
[08:28:14.724]             function(cond) {
[08:28:14.724]                 is_error <- inherits(cond, "error")
[08:28:14.724]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.724]                   NULL)
[08:28:14.724]                 if (is_error) {
[08:28:14.724]                   sessionInformation <- function() {
[08:28:14.724]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.724]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.724]                       search = base::search(), system = base::Sys.info())
[08:28:14.724]                   }
[08:28:14.724]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.724]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.724]                     cond$call), session = sessionInformation(), 
[08:28:14.724]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.724]                   signalCondition(cond)
[08:28:14.724]                 }
[08:28:14.724]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.724]                 "immediateCondition"))) {
[08:28:14.724]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.724]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.724]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.724]                   if (TRUE && !signal) {
[08:28:14.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.724]                     {
[08:28:14.724]                       inherits <- base::inherits
[08:28:14.724]                       invokeRestart <- base::invokeRestart
[08:28:14.724]                       is.null <- base::is.null
[08:28:14.724]                       muffled <- FALSE
[08:28:14.724]                       if (inherits(cond, "message")) {
[08:28:14.724]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.724]                         if (muffled) 
[08:28:14.724]                           invokeRestart("muffleMessage")
[08:28:14.724]                       }
[08:28:14.724]                       else if (inherits(cond, "warning")) {
[08:28:14.724]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.724]                         if (muffled) 
[08:28:14.724]                           invokeRestart("muffleWarning")
[08:28:14.724]                       }
[08:28:14.724]                       else if (inherits(cond, "condition")) {
[08:28:14.724]                         if (!is.null(pattern)) {
[08:28:14.724]                           computeRestarts <- base::computeRestarts
[08:28:14.724]                           grepl <- base::grepl
[08:28:14.724]                           restarts <- computeRestarts(cond)
[08:28:14.724]                           for (restart in restarts) {
[08:28:14.724]                             name <- restart$name
[08:28:14.724]                             if (is.null(name)) 
[08:28:14.724]                               next
[08:28:14.724]                             if (!grepl(pattern, name)) 
[08:28:14.724]                               next
[08:28:14.724]                             invokeRestart(restart)
[08:28:14.724]                             muffled <- TRUE
[08:28:14.724]                             break
[08:28:14.724]                           }
[08:28:14.724]                         }
[08:28:14.724]                       }
[08:28:14.724]                       invisible(muffled)
[08:28:14.724]                     }
[08:28:14.724]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.724]                   }
[08:28:14.724]                 }
[08:28:14.724]                 else {
[08:28:14.724]                   if (TRUE) {
[08:28:14.724]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.724]                     {
[08:28:14.724]                       inherits <- base::inherits
[08:28:14.724]                       invokeRestart <- base::invokeRestart
[08:28:14.724]                       is.null <- base::is.null
[08:28:14.724]                       muffled <- FALSE
[08:28:14.724]                       if (inherits(cond, "message")) {
[08:28:14.724]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.724]                         if (muffled) 
[08:28:14.724]                           invokeRestart("muffleMessage")
[08:28:14.724]                       }
[08:28:14.724]                       else if (inherits(cond, "warning")) {
[08:28:14.724]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.724]                         if (muffled) 
[08:28:14.724]                           invokeRestart("muffleWarning")
[08:28:14.724]                       }
[08:28:14.724]                       else if (inherits(cond, "condition")) {
[08:28:14.724]                         if (!is.null(pattern)) {
[08:28:14.724]                           computeRestarts <- base::computeRestarts
[08:28:14.724]                           grepl <- base::grepl
[08:28:14.724]                           restarts <- computeRestarts(cond)
[08:28:14.724]                           for (restart in restarts) {
[08:28:14.724]                             name <- restart$name
[08:28:14.724]                             if (is.null(name)) 
[08:28:14.724]                               next
[08:28:14.724]                             if (!grepl(pattern, name)) 
[08:28:14.724]                               next
[08:28:14.724]                             invokeRestart(restart)
[08:28:14.724]                             muffled <- TRUE
[08:28:14.724]                             break
[08:28:14.724]                           }
[08:28:14.724]                         }
[08:28:14.724]                       }
[08:28:14.724]                       invisible(muffled)
[08:28:14.724]                     }
[08:28:14.724]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.724]                   }
[08:28:14.724]                 }
[08:28:14.724]             }
[08:28:14.724]         }))
[08:28:14.724]     }, error = function(ex) {
[08:28:14.724]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.724]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.724]                 ...future.rng), started = ...future.startTime, 
[08:28:14.724]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.724]             version = "1.8"), class = "FutureResult")
[08:28:14.724]     }, finally = {
[08:28:14.724]         if (!identical(...future.workdir, getwd())) 
[08:28:14.724]             setwd(...future.workdir)
[08:28:14.724]         {
[08:28:14.724]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.724]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.724]             }
[08:28:14.724]             base::options(...future.oldOptions)
[08:28:14.724]             if (.Platform$OS.type == "windows") {
[08:28:14.724]                 old_names <- names(...future.oldEnvVars)
[08:28:14.724]                 envs <- base::Sys.getenv()
[08:28:14.724]                 names <- names(envs)
[08:28:14.724]                 common <- intersect(names, old_names)
[08:28:14.724]                 added <- setdiff(names, old_names)
[08:28:14.724]                 removed <- setdiff(old_names, names)
[08:28:14.724]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.724]                   envs[common]]
[08:28:14.724]                 NAMES <- toupper(changed)
[08:28:14.724]                 args <- list()
[08:28:14.724]                 for (kk in seq_along(NAMES)) {
[08:28:14.724]                   name <- changed[[kk]]
[08:28:14.724]                   NAME <- NAMES[[kk]]
[08:28:14.724]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.724]                     next
[08:28:14.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.724]                 }
[08:28:14.724]                 NAMES <- toupper(added)
[08:28:14.724]                 for (kk in seq_along(NAMES)) {
[08:28:14.724]                   name <- added[[kk]]
[08:28:14.724]                   NAME <- NAMES[[kk]]
[08:28:14.724]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.724]                     next
[08:28:14.724]                   args[[name]] <- ""
[08:28:14.724]                 }
[08:28:14.724]                 NAMES <- toupper(removed)
[08:28:14.724]                 for (kk in seq_along(NAMES)) {
[08:28:14.724]                   name <- removed[[kk]]
[08:28:14.724]                   NAME <- NAMES[[kk]]
[08:28:14.724]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.724]                     next
[08:28:14.724]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.724]                 }
[08:28:14.724]                 if (length(args) > 0) 
[08:28:14.724]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.724]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.724]             }
[08:28:14.724]             else {
[08:28:14.724]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.724]             }
[08:28:14.724]             {
[08:28:14.724]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.724]                   0L) {
[08:28:14.724]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.724]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.724]                   base::options(opts)
[08:28:14.724]                 }
[08:28:14.724]                 {
[08:28:14.724]                   {
[08:28:14.724]                     NULL
[08:28:14.724]                     RNGkind("Mersenne-Twister")
[08:28:14.724]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.724]                       inherits = FALSE)
[08:28:14.724]                   }
[08:28:14.724]                   options(future.plan = NULL)
[08:28:14.724]                   if (is.na(NA_character_)) 
[08:28:14.724]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.724]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.724]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.724]                     .init = FALSE)
[08:28:14.724]                 }
[08:28:14.724]             }
[08:28:14.724]         }
[08:28:14.724]     })
[08:28:14.724]     if (TRUE) {
[08:28:14.724]         base::sink(type = "output", split = FALSE)
[08:28:14.724]         if (TRUE) {
[08:28:14.724]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.724]         }
[08:28:14.724]         else {
[08:28:14.724]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.724]         }
[08:28:14.724]         base::close(...future.stdout)
[08:28:14.724]         ...future.stdout <- NULL
[08:28:14.724]     }
[08:28:14.724]     ...future.result$conditions <- ...future.conditions
[08:28:14.724]     ...future.result$finished <- base::Sys.time()
[08:28:14.724]     ...future.result
[08:28:14.724] }
[08:28:14.726] assign_globals() ...
[08:28:14.726] List of 1
[08:28:14.726]  $ x: num 1
[08:28:14.726]  - attr(*, "where")=List of 1
[08:28:14.726]   ..$ x:<environment: R_EmptyEnv> 
[08:28:14.726]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.726]  - attr(*, "resolved")= logi TRUE
[08:28:14.726]  - attr(*, "total_size")= num 39
[08:28:14.726]  - attr(*, "already-done")= logi TRUE
[08:28:14.729] - copied ‘x’ to environment
[08:28:14.730] assign_globals() ... done
[08:28:14.730] plan(): Setting new future strategy stack:
[08:28:14.730] List of future strategies:
[08:28:14.730] 1. sequential:
[08:28:14.730]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.730]    - tweaked: FALSE
[08:28:14.730]    - call: NULL
[08:28:14.730] plan(): nbrOfWorkers() = 1
[08:28:14.731] plan(): Setting new future strategy stack:
[08:28:14.731] List of future strategies:
[08:28:14.731] 1. sequential:
[08:28:14.731]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.731]    - tweaked: FALSE
[08:28:14.731]    - call: plan(strategy)
[08:28:14.731] plan(): nbrOfWorkers() = 1
[08:28:14.732] SequentialFuture started (and completed)
[08:28:14.732] - Launch lazy future ... done
[08:28:14.732] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.732] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.732] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:14.734] - globals found: [3] ‘{’, ‘<-’, ‘x’
[08:28:14.734] Searching for globals ... DONE
[08:28:14.734] Resolving globals: TRUE
[08:28:14.734] Resolving any globals that are futures ...
[08:28:14.734] - globals: [3] ‘{’, ‘<-’, ‘x’
[08:28:14.734] Resolving any globals that are futures ... DONE
[08:28:14.735] Resolving futures part of globals (recursively) ...
[08:28:14.735] resolve() on list ...
[08:28:14.735]  recursive: 99
[08:28:14.735]  length: 1
[08:28:14.735]  elements: ‘x’
[08:28:14.735]  length: 0 (resolved future 1)
[08:28:14.735] resolve() on list ... DONE
[08:28:14.735] - globals: [1] ‘x’
[08:28:14.736] Resolving futures part of globals (recursively) ... DONE
[08:28:14.736] The total size of the 1 globals is 260 bytes (260 bytes)
[08:28:14.736] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[08:28:14.736] - globals: [1] ‘x’
[08:28:14.736] 
[08:28:14.736] getGlobalsAndPackages() ... DONE
[08:28:14.736] run() for ‘Future’ ...
[08:28:14.737] - state: ‘created’
[08:28:14.737] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[08:28:14.737] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[08:28:14.737] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[08:28:14.737]   - Field: ‘label’
[08:28:14.737]   - Field: ‘local’
[08:28:14.737]   - Field: ‘owner’
[08:28:14.737]   - Field: ‘envir’
[08:28:14.737]   - Field: ‘packages’
[08:28:14.737]   - Field: ‘gc’
[08:28:14.738]   - Field: ‘conditions’
[08:28:14.738]   - Field: ‘expr’
[08:28:14.738]   - Field: ‘uuid’
[08:28:14.738]   - Field: ‘seed’
[08:28:14.738]   - Field: ‘version’
[08:28:14.738]   - Field: ‘result’
[08:28:14.738]   - Field: ‘asynchronous’
[08:28:14.738]   - Field: ‘calls’
[08:28:14.738]   - Field: ‘globals’
[08:28:14.738]   - Field: ‘stdout’
[08:28:14.738]   - Field: ‘earlySignal’
[08:28:14.738]   - Field: ‘lazy’
[08:28:14.739]   - Field: ‘state’
[08:28:14.739] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[08:28:14.739] - Launch lazy future ...
[08:28:14.739] Packages needed by the future expression (n = 0): <none>
[08:28:14.739] Packages needed by future strategies (n = 0): <none>
[08:28:14.739] {
[08:28:14.739]     {
[08:28:14.739]         {
[08:28:14.739]             ...future.startTime <- base::Sys.time()
[08:28:14.739]             {
[08:28:14.739]                 {
[08:28:14.739]                   {
[08:28:14.739]                     base::local({
[08:28:14.739]                       has_future <- base::requireNamespace("future", 
[08:28:14.739]                         quietly = TRUE)
[08:28:14.739]                       if (has_future) {
[08:28:14.739]                         ns <- base::getNamespace("future")
[08:28:14.739]                         version <- ns[[".package"]][["version"]]
[08:28:14.739]                         if (is.null(version)) 
[08:28:14.739]                           version <- utils::packageVersion("future")
[08:28:14.739]                       }
[08:28:14.739]                       else {
[08:28:14.739]                         version <- NULL
[08:28:14.739]                       }
[08:28:14.739]                       if (!has_future || version < "1.8.0") {
[08:28:14.739]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.739]                           "", base::R.version$version.string), 
[08:28:14.739]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:14.739]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.739]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.739]                             "release", "version")], collapse = " "), 
[08:28:14.739]                           hostname = base::Sys.info()[["nodename"]])
[08:28:14.739]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.739]                           info)
[08:28:14.739]                         info <- base::paste(info, collapse = "; ")
[08:28:14.739]                         if (!has_future) {
[08:28:14.739]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.739]                             info)
[08:28:14.739]                         }
[08:28:14.739]                         else {
[08:28:14.739]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.739]                             info, version)
[08:28:14.739]                         }
[08:28:14.739]                         base::stop(msg)
[08:28:14.739]                       }
[08:28:14.739]                     })
[08:28:14.739]                   }
[08:28:14.739]                   ...future.strategy.old <- future::plan("list")
[08:28:14.739]                   options(future.plan = NULL)
[08:28:14.739]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.739]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.739]                 }
[08:28:14.739]                 ...future.workdir <- getwd()
[08:28:14.739]             }
[08:28:14.739]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.739]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.739]         }
[08:28:14.739]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.739]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:14.739]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.739]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.739]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.739]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.739]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.739]             base::names(...future.oldOptions))
[08:28:14.739]     }
[08:28:14.739]     if (FALSE) {
[08:28:14.739]     }
[08:28:14.739]     else {
[08:28:14.739]         if (TRUE) {
[08:28:14.739]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.739]                 open = "w")
[08:28:14.739]         }
[08:28:14.739]         else {
[08:28:14.739]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.739]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.739]         }
[08:28:14.739]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.739]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.739]             base::sink(type = "output", split = FALSE)
[08:28:14.739]             base::close(...future.stdout)
[08:28:14.739]         }, add = TRUE)
[08:28:14.739]     }
[08:28:14.739]     ...future.frame <- base::sys.nframe()
[08:28:14.739]     ...future.conditions <- base::list()
[08:28:14.739]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.739]     if (FALSE) {
[08:28:14.739]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.739]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.739]     }
[08:28:14.739]     ...future.result <- base::tryCatch({
[08:28:14.739]         base::withCallingHandlers({
[08:28:14.739]             ...future.value <- base::withVisible(base::local({
[08:28:14.739]                 x <- x()
[08:28:14.739]                 x
[08:28:14.739]             }))
[08:28:14.739]             future::FutureResult(value = ...future.value$value, 
[08:28:14.739]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.739]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.739]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.739]                     ...future.globalenv.names))
[08:28:14.739]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.739]         }, condition = base::local({
[08:28:14.739]             c <- base::c
[08:28:14.739]             inherits <- base::inherits
[08:28:14.739]             invokeRestart <- base::invokeRestart
[08:28:14.739]             length <- base::length
[08:28:14.739]             list <- base::list
[08:28:14.739]             seq.int <- base::seq.int
[08:28:14.739]             signalCondition <- base::signalCondition
[08:28:14.739]             sys.calls <- base::sys.calls
[08:28:14.739]             `[[` <- base::`[[`
[08:28:14.739]             `+` <- base::`+`
[08:28:14.739]             `<<-` <- base::`<<-`
[08:28:14.739]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.739]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.739]                   3L)]
[08:28:14.739]             }
[08:28:14.739]             function(cond) {
[08:28:14.739]                 is_error <- inherits(cond, "error")
[08:28:14.739]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.739]                   NULL)
[08:28:14.739]                 if (is_error) {
[08:28:14.739]                   sessionInformation <- function() {
[08:28:14.739]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.739]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.739]                       search = base::search(), system = base::Sys.info())
[08:28:14.739]                   }
[08:28:14.739]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.739]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.739]                     cond$call), session = sessionInformation(), 
[08:28:14.739]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.739]                   signalCondition(cond)
[08:28:14.739]                 }
[08:28:14.739]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.739]                 "immediateCondition"))) {
[08:28:14.739]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.739]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.739]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.739]                   if (TRUE && !signal) {
[08:28:14.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.739]                     {
[08:28:14.739]                       inherits <- base::inherits
[08:28:14.739]                       invokeRestart <- base::invokeRestart
[08:28:14.739]                       is.null <- base::is.null
[08:28:14.739]                       muffled <- FALSE
[08:28:14.739]                       if (inherits(cond, "message")) {
[08:28:14.739]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.739]                         if (muffled) 
[08:28:14.739]                           invokeRestart("muffleMessage")
[08:28:14.739]                       }
[08:28:14.739]                       else if (inherits(cond, "warning")) {
[08:28:14.739]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.739]                         if (muffled) 
[08:28:14.739]                           invokeRestart("muffleWarning")
[08:28:14.739]                       }
[08:28:14.739]                       else if (inherits(cond, "condition")) {
[08:28:14.739]                         if (!is.null(pattern)) {
[08:28:14.739]                           computeRestarts <- base::computeRestarts
[08:28:14.739]                           grepl <- base::grepl
[08:28:14.739]                           restarts <- computeRestarts(cond)
[08:28:14.739]                           for (restart in restarts) {
[08:28:14.739]                             name <- restart$name
[08:28:14.739]                             if (is.null(name)) 
[08:28:14.739]                               next
[08:28:14.739]                             if (!grepl(pattern, name)) 
[08:28:14.739]                               next
[08:28:14.739]                             invokeRestart(restart)
[08:28:14.739]                             muffled <- TRUE
[08:28:14.739]                             break
[08:28:14.739]                           }
[08:28:14.739]                         }
[08:28:14.739]                       }
[08:28:14.739]                       invisible(muffled)
[08:28:14.739]                     }
[08:28:14.739]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.739]                   }
[08:28:14.739]                 }
[08:28:14.739]                 else {
[08:28:14.739]                   if (TRUE) {
[08:28:14.739]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.739]                     {
[08:28:14.739]                       inherits <- base::inherits
[08:28:14.739]                       invokeRestart <- base::invokeRestart
[08:28:14.739]                       is.null <- base::is.null
[08:28:14.739]                       muffled <- FALSE
[08:28:14.739]                       if (inherits(cond, "message")) {
[08:28:14.739]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.739]                         if (muffled) 
[08:28:14.739]                           invokeRestart("muffleMessage")
[08:28:14.739]                       }
[08:28:14.739]                       else if (inherits(cond, "warning")) {
[08:28:14.739]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.739]                         if (muffled) 
[08:28:14.739]                           invokeRestart("muffleWarning")
[08:28:14.739]                       }
[08:28:14.739]                       else if (inherits(cond, "condition")) {
[08:28:14.739]                         if (!is.null(pattern)) {
[08:28:14.739]                           computeRestarts <- base::computeRestarts
[08:28:14.739]                           grepl <- base::grepl
[08:28:14.739]                           restarts <- computeRestarts(cond)
[08:28:14.739]                           for (restart in restarts) {
[08:28:14.739]                             name <- restart$name
[08:28:14.739]                             if (is.null(name)) 
[08:28:14.739]                               next
[08:28:14.739]                             if (!grepl(pattern, name)) 
[08:28:14.739]                               next
[08:28:14.739]                             invokeRestart(restart)
[08:28:14.739]                             muffled <- TRUE
[08:28:14.739]                             break
[08:28:14.739]                           }
[08:28:14.739]                         }
[08:28:14.739]                       }
[08:28:14.739]                       invisible(muffled)
[08:28:14.739]                     }
[08:28:14.739]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.739]                   }
[08:28:14.739]                 }
[08:28:14.739]             }
[08:28:14.739]         }))
[08:28:14.739]     }, error = function(ex) {
[08:28:14.739]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.739]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.739]                 ...future.rng), started = ...future.startTime, 
[08:28:14.739]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.739]             version = "1.8"), class = "FutureResult")
[08:28:14.739]     }, finally = {
[08:28:14.739]         if (!identical(...future.workdir, getwd())) 
[08:28:14.739]             setwd(...future.workdir)
[08:28:14.739]         {
[08:28:14.739]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.739]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.739]             }
[08:28:14.739]             base::options(...future.oldOptions)
[08:28:14.739]             if (.Platform$OS.type == "windows") {
[08:28:14.739]                 old_names <- names(...future.oldEnvVars)
[08:28:14.739]                 envs <- base::Sys.getenv()
[08:28:14.739]                 names <- names(envs)
[08:28:14.739]                 common <- intersect(names, old_names)
[08:28:14.739]                 added <- setdiff(names, old_names)
[08:28:14.739]                 removed <- setdiff(old_names, names)
[08:28:14.739]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.739]                   envs[common]]
[08:28:14.739]                 NAMES <- toupper(changed)
[08:28:14.739]                 args <- list()
[08:28:14.739]                 for (kk in seq_along(NAMES)) {
[08:28:14.739]                   name <- changed[[kk]]
[08:28:14.739]                   NAME <- NAMES[[kk]]
[08:28:14.739]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.739]                     next
[08:28:14.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.739]                 }
[08:28:14.739]                 NAMES <- toupper(added)
[08:28:14.739]                 for (kk in seq_along(NAMES)) {
[08:28:14.739]                   name <- added[[kk]]
[08:28:14.739]                   NAME <- NAMES[[kk]]
[08:28:14.739]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.739]                     next
[08:28:14.739]                   args[[name]] <- ""
[08:28:14.739]                 }
[08:28:14.739]                 NAMES <- toupper(removed)
[08:28:14.739]                 for (kk in seq_along(NAMES)) {
[08:28:14.739]                   name <- removed[[kk]]
[08:28:14.739]                   NAME <- NAMES[[kk]]
[08:28:14.739]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.739]                     next
[08:28:14.739]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.739]                 }
[08:28:14.739]                 if (length(args) > 0) 
[08:28:14.739]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.739]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.739]             }
[08:28:14.739]             else {
[08:28:14.739]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.739]             }
[08:28:14.739]             {
[08:28:14.739]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.739]                   0L) {
[08:28:14.739]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.739]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.739]                   base::options(opts)
[08:28:14.739]                 }
[08:28:14.739]                 {
[08:28:14.739]                   {
[08:28:14.739]                     NULL
[08:28:14.739]                     RNGkind("Mersenne-Twister")
[08:28:14.739]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:14.739]                       inherits = FALSE)
[08:28:14.739]                   }
[08:28:14.739]                   options(future.plan = NULL)
[08:28:14.739]                   if (is.na(NA_character_)) 
[08:28:14.739]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.739]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.739]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.739]                     .init = FALSE)
[08:28:14.739]                 }
[08:28:14.739]             }
[08:28:14.739]         }
[08:28:14.739]     })
[08:28:14.739]     if (TRUE) {
[08:28:14.739]         base::sink(type = "output", split = FALSE)
[08:28:14.739]         if (TRUE) {
[08:28:14.739]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.739]         }
[08:28:14.739]         else {
[08:28:14.739]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.739]         }
[08:28:14.739]         base::close(...future.stdout)
[08:28:14.739]         ...future.stdout <- NULL
[08:28:14.739]     }
[08:28:14.739]     ...future.result$conditions <- ...future.conditions
[08:28:14.739]     ...future.result$finished <- base::Sys.time()
[08:28:14.739]     ...future.result
[08:28:14.739] }
[08:28:14.741] assign_globals() ...
[08:28:14.741] List of 1
[08:28:14.741]  $ x:function ()  
[08:28:14.741]  - attr(*, "where")=List of 1
[08:28:14.741]   ..$ x:<environment: R_EmptyEnv> 
[08:28:14.741]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.741]  - attr(*, "resolved")= logi TRUE
[08:28:14.741]  - attr(*, "total_size")= num 260
[08:28:14.741]  - attr(*, "already-done")= logi TRUE
[08:28:14.743] - reassign environment for ‘x’
[08:28:14.743] - copied ‘x’ to environment
[08:28:14.743] assign_globals() ... done
[08:28:14.744] plan(): Setting new future strategy stack:
[08:28:14.744] List of future strategies:
[08:28:14.744] 1. sequential:
[08:28:14.744]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.744]    - tweaked: FALSE
[08:28:14.744]    - call: NULL
[08:28:14.744] plan(): nbrOfWorkers() = 1
[08:28:14.745] plan(): Setting new future strategy stack:
[08:28:14.745] List of future strategies:
[08:28:14.745] 1. sequential:
[08:28:14.745]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.745]    - tweaked: FALSE
[08:28:14.745]    - call: plan(strategy)
[08:28:14.745] plan(): nbrOfWorkers() = 1
[08:28:14.745] SequentialFuture started (and completed)
[08:28:14.746] - Launch lazy future ... done
[08:28:14.746] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[08:28:14.753] plan(): Setting new future strategy stack:
[08:28:14.753] List of future strategies:
[08:28:14.753] 1. multicore:
[08:28:14.753]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:14.753]    - tweaked: FALSE
[08:28:14.753]    - call: plan(strategy)
[08:28:14.755] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.755] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.755] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.757] - globals found: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.757] Searching for globals ... DONE
[08:28:14.757] Resolving globals: TRUE
[08:28:14.757] Resolving any globals that are futures ...
[08:28:14.757] - globals: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.757] Resolving any globals that are futures ... DONE
[08:28:14.757] 
[08:28:14.757] 
[08:28:14.758] getGlobalsAndPackages() ... DONE
[08:28:14.758] run() for ‘Future’ ...
[08:28:14.758] - state: ‘created’
[08:28:14.758] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:14.760] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:14.760] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:14.760]   - Field: ‘label’
[08:28:14.760]   - Field: ‘local’
[08:28:14.760]   - Field: ‘owner’
[08:28:14.760]   - Field: ‘envir’
[08:28:14.760]   - Field: ‘workers’
[08:28:14.760]   - Field: ‘packages’
[08:28:14.760]   - Field: ‘gc’
[08:28:14.760]   - Field: ‘job’
[08:28:14.760]   - Field: ‘conditions’
[08:28:14.761]   - Field: ‘expr’
[08:28:14.761]   - Field: ‘uuid’
[08:28:14.761]   - Field: ‘seed’
[08:28:14.761]   - Field: ‘version’
[08:28:14.761]   - Field: ‘result’
[08:28:14.761]   - Field: ‘asynchronous’
[08:28:14.761]   - Field: ‘calls’
[08:28:14.761]   - Field: ‘globals’
[08:28:14.761]   - Field: ‘stdout’
[08:28:14.761]   - Field: ‘earlySignal’
[08:28:14.761]   - Field: ‘lazy’
[08:28:14.761]   - Field: ‘state’
[08:28:14.762] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:14.762] - Launch lazy future ...
[08:28:14.762] Packages needed by the future expression (n = 0): <none>
[08:28:14.763] Packages needed by future strategies (n = 0): <none>
[08:28:14.763] {
[08:28:14.763]     {
[08:28:14.763]         {
[08:28:14.763]             ...future.startTime <- base::Sys.time()
[08:28:14.763]             {
[08:28:14.763]                 {
[08:28:14.763]                   {
[08:28:14.763]                     {
[08:28:14.763]                       base::local({
[08:28:14.763]                         has_future <- base::requireNamespace("future", 
[08:28:14.763]                           quietly = TRUE)
[08:28:14.763]                         if (has_future) {
[08:28:14.763]                           ns <- base::getNamespace("future")
[08:28:14.763]                           version <- ns[[".package"]][["version"]]
[08:28:14.763]                           if (is.null(version)) 
[08:28:14.763]                             version <- utils::packageVersion("future")
[08:28:14.763]                         }
[08:28:14.763]                         else {
[08:28:14.763]                           version <- NULL
[08:28:14.763]                         }
[08:28:14.763]                         if (!has_future || version < "1.8.0") {
[08:28:14.763]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.763]                             "", base::R.version$version.string), 
[08:28:14.763]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.763]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.763]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.763]                               "release", "version")], collapse = " "), 
[08:28:14.763]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.763]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.763]                             info)
[08:28:14.763]                           info <- base::paste(info, collapse = "; ")
[08:28:14.763]                           if (!has_future) {
[08:28:14.763]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.763]                               info)
[08:28:14.763]                           }
[08:28:14.763]                           else {
[08:28:14.763]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.763]                               info, version)
[08:28:14.763]                           }
[08:28:14.763]                           base::stop(msg)
[08:28:14.763]                         }
[08:28:14.763]                       })
[08:28:14.763]                     }
[08:28:14.763]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:14.763]                     base::options(mc.cores = 1L)
[08:28:14.763]                   }
[08:28:14.763]                   ...future.strategy.old <- future::plan("list")
[08:28:14.763]                   options(future.plan = NULL)
[08:28:14.763]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.763]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.763]                 }
[08:28:14.763]                 ...future.workdir <- getwd()
[08:28:14.763]             }
[08:28:14.763]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.763]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.763]         }
[08:28:14.763]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.763]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.763]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.763]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.763]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.763]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.763]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.763]             base::names(...future.oldOptions))
[08:28:14.763]     }
[08:28:14.763]     if (FALSE) {
[08:28:14.763]     }
[08:28:14.763]     else {
[08:28:14.763]         if (TRUE) {
[08:28:14.763]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.763]                 open = "w")
[08:28:14.763]         }
[08:28:14.763]         else {
[08:28:14.763]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.763]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.763]         }
[08:28:14.763]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.763]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.763]             base::sink(type = "output", split = FALSE)
[08:28:14.763]             base::close(...future.stdout)
[08:28:14.763]         }, add = TRUE)
[08:28:14.763]     }
[08:28:14.763]     ...future.frame <- base::sys.nframe()
[08:28:14.763]     ...future.conditions <- base::list()
[08:28:14.763]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.763]     if (FALSE) {
[08:28:14.763]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.763]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.763]     }
[08:28:14.763]     ...future.result <- base::tryCatch({
[08:28:14.763]         base::withCallingHandlers({
[08:28:14.763]             ...future.value <- base::withVisible(base::local({
[08:28:14.763]                 withCallingHandlers({
[08:28:14.763]                   {
[08:28:14.763]                     b <- a
[08:28:14.763]                     a <- 2
[08:28:14.763]                     a * b
[08:28:14.763]                   }
[08:28:14.763]                 }, immediateCondition = function(cond) {
[08:28:14.763]                   save_rds <- function (object, pathname, ...) 
[08:28:14.763]                   {
[08:28:14.763]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:14.763]                     if (file_test("-f", pathname_tmp)) {
[08:28:14.763]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.763]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:14.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.763]                         fi_tmp[["mtime"]])
[08:28:14.763]                     }
[08:28:14.763]                     tryCatch({
[08:28:14.763]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:14.763]                     }, error = function(ex) {
[08:28:14.763]                       msg <- conditionMessage(ex)
[08:28:14.763]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.763]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:14.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.763]                         fi_tmp[["mtime"]], msg)
[08:28:14.763]                       ex$message <- msg
[08:28:14.763]                       stop(ex)
[08:28:14.763]                     })
[08:28:14.763]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:14.763]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:14.763]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:14.763]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.763]                       fi <- file.info(pathname)
[08:28:14.763]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:14.763]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.763]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:14.763]                         fi[["size"]], fi[["mtime"]])
[08:28:14.763]                       stop(msg)
[08:28:14.763]                     }
[08:28:14.763]                     invisible(pathname)
[08:28:14.763]                   }
[08:28:14.763]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:14.763]                     rootPath = tempdir()) 
[08:28:14.763]                   {
[08:28:14.763]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:14.763]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:14.763]                       tmpdir = path, fileext = ".rds")
[08:28:14.763]                     save_rds(obj, file)
[08:28:14.763]                   }
[08:28:14.763]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:14.763]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.763]                   {
[08:28:14.763]                     inherits <- base::inherits
[08:28:14.763]                     invokeRestart <- base::invokeRestart
[08:28:14.763]                     is.null <- base::is.null
[08:28:14.763]                     muffled <- FALSE
[08:28:14.763]                     if (inherits(cond, "message")) {
[08:28:14.763]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:14.763]                       if (muffled) 
[08:28:14.763]                         invokeRestart("muffleMessage")
[08:28:14.763]                     }
[08:28:14.763]                     else if (inherits(cond, "warning")) {
[08:28:14.763]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:14.763]                       if (muffled) 
[08:28:14.763]                         invokeRestart("muffleWarning")
[08:28:14.763]                     }
[08:28:14.763]                     else if (inherits(cond, "condition")) {
[08:28:14.763]                       if (!is.null(pattern)) {
[08:28:14.763]                         computeRestarts <- base::computeRestarts
[08:28:14.763]                         grepl <- base::grepl
[08:28:14.763]                         restarts <- computeRestarts(cond)
[08:28:14.763]                         for (restart in restarts) {
[08:28:14.763]                           name <- restart$name
[08:28:14.763]                           if (is.null(name)) 
[08:28:14.763]                             next
[08:28:14.763]                           if (!grepl(pattern, name)) 
[08:28:14.763]                             next
[08:28:14.763]                           invokeRestart(restart)
[08:28:14.763]                           muffled <- TRUE
[08:28:14.763]                           break
[08:28:14.763]                         }
[08:28:14.763]                       }
[08:28:14.763]                     }
[08:28:14.763]                     invisible(muffled)
[08:28:14.763]                   }
[08:28:14.763]                   muffleCondition(cond)
[08:28:14.763]                 })
[08:28:14.763]             }))
[08:28:14.763]             future::FutureResult(value = ...future.value$value, 
[08:28:14.763]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.763]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.763]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.763]                     ...future.globalenv.names))
[08:28:14.763]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.763]         }, condition = base::local({
[08:28:14.763]             c <- base::c
[08:28:14.763]             inherits <- base::inherits
[08:28:14.763]             invokeRestart <- base::invokeRestart
[08:28:14.763]             length <- base::length
[08:28:14.763]             list <- base::list
[08:28:14.763]             seq.int <- base::seq.int
[08:28:14.763]             signalCondition <- base::signalCondition
[08:28:14.763]             sys.calls <- base::sys.calls
[08:28:14.763]             `[[` <- base::`[[`
[08:28:14.763]             `+` <- base::`+`
[08:28:14.763]             `<<-` <- base::`<<-`
[08:28:14.763]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.763]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.763]                   3L)]
[08:28:14.763]             }
[08:28:14.763]             function(cond) {
[08:28:14.763]                 is_error <- inherits(cond, "error")
[08:28:14.763]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.763]                   NULL)
[08:28:14.763]                 if (is_error) {
[08:28:14.763]                   sessionInformation <- function() {
[08:28:14.763]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.763]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.763]                       search = base::search(), system = base::Sys.info())
[08:28:14.763]                   }
[08:28:14.763]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.763]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.763]                     cond$call), session = sessionInformation(), 
[08:28:14.763]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.763]                   signalCondition(cond)
[08:28:14.763]                 }
[08:28:14.763]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.763]                 "immediateCondition"))) {
[08:28:14.763]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.763]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.763]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.763]                   if (TRUE && !signal) {
[08:28:14.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.763]                     {
[08:28:14.763]                       inherits <- base::inherits
[08:28:14.763]                       invokeRestart <- base::invokeRestart
[08:28:14.763]                       is.null <- base::is.null
[08:28:14.763]                       muffled <- FALSE
[08:28:14.763]                       if (inherits(cond, "message")) {
[08:28:14.763]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.763]                         if (muffled) 
[08:28:14.763]                           invokeRestart("muffleMessage")
[08:28:14.763]                       }
[08:28:14.763]                       else if (inherits(cond, "warning")) {
[08:28:14.763]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.763]                         if (muffled) 
[08:28:14.763]                           invokeRestart("muffleWarning")
[08:28:14.763]                       }
[08:28:14.763]                       else if (inherits(cond, "condition")) {
[08:28:14.763]                         if (!is.null(pattern)) {
[08:28:14.763]                           computeRestarts <- base::computeRestarts
[08:28:14.763]                           grepl <- base::grepl
[08:28:14.763]                           restarts <- computeRestarts(cond)
[08:28:14.763]                           for (restart in restarts) {
[08:28:14.763]                             name <- restart$name
[08:28:14.763]                             if (is.null(name)) 
[08:28:14.763]                               next
[08:28:14.763]                             if (!grepl(pattern, name)) 
[08:28:14.763]                               next
[08:28:14.763]                             invokeRestart(restart)
[08:28:14.763]                             muffled <- TRUE
[08:28:14.763]                             break
[08:28:14.763]                           }
[08:28:14.763]                         }
[08:28:14.763]                       }
[08:28:14.763]                       invisible(muffled)
[08:28:14.763]                     }
[08:28:14.763]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.763]                   }
[08:28:14.763]                 }
[08:28:14.763]                 else {
[08:28:14.763]                   if (TRUE) {
[08:28:14.763]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.763]                     {
[08:28:14.763]                       inherits <- base::inherits
[08:28:14.763]                       invokeRestart <- base::invokeRestart
[08:28:14.763]                       is.null <- base::is.null
[08:28:14.763]                       muffled <- FALSE
[08:28:14.763]                       if (inherits(cond, "message")) {
[08:28:14.763]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.763]                         if (muffled) 
[08:28:14.763]                           invokeRestart("muffleMessage")
[08:28:14.763]                       }
[08:28:14.763]                       else if (inherits(cond, "warning")) {
[08:28:14.763]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.763]                         if (muffled) 
[08:28:14.763]                           invokeRestart("muffleWarning")
[08:28:14.763]                       }
[08:28:14.763]                       else if (inherits(cond, "condition")) {
[08:28:14.763]                         if (!is.null(pattern)) {
[08:28:14.763]                           computeRestarts <- base::computeRestarts
[08:28:14.763]                           grepl <- base::grepl
[08:28:14.763]                           restarts <- computeRestarts(cond)
[08:28:14.763]                           for (restart in restarts) {
[08:28:14.763]                             name <- restart$name
[08:28:14.763]                             if (is.null(name)) 
[08:28:14.763]                               next
[08:28:14.763]                             if (!grepl(pattern, name)) 
[08:28:14.763]                               next
[08:28:14.763]                             invokeRestart(restart)
[08:28:14.763]                             muffled <- TRUE
[08:28:14.763]                             break
[08:28:14.763]                           }
[08:28:14.763]                         }
[08:28:14.763]                       }
[08:28:14.763]                       invisible(muffled)
[08:28:14.763]                     }
[08:28:14.763]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.763]                   }
[08:28:14.763]                 }
[08:28:14.763]             }
[08:28:14.763]         }))
[08:28:14.763]     }, error = function(ex) {
[08:28:14.763]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.763]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.763]                 ...future.rng), started = ...future.startTime, 
[08:28:14.763]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.763]             version = "1.8"), class = "FutureResult")
[08:28:14.763]     }, finally = {
[08:28:14.763]         if (!identical(...future.workdir, getwd())) 
[08:28:14.763]             setwd(...future.workdir)
[08:28:14.763]         {
[08:28:14.763]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.763]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.763]             }
[08:28:14.763]             base::options(...future.oldOptions)
[08:28:14.763]             if (.Platform$OS.type == "windows") {
[08:28:14.763]                 old_names <- names(...future.oldEnvVars)
[08:28:14.763]                 envs <- base::Sys.getenv()
[08:28:14.763]                 names <- names(envs)
[08:28:14.763]                 common <- intersect(names, old_names)
[08:28:14.763]                 added <- setdiff(names, old_names)
[08:28:14.763]                 removed <- setdiff(old_names, names)
[08:28:14.763]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.763]                   envs[common]]
[08:28:14.763]                 NAMES <- toupper(changed)
[08:28:14.763]                 args <- list()
[08:28:14.763]                 for (kk in seq_along(NAMES)) {
[08:28:14.763]                   name <- changed[[kk]]
[08:28:14.763]                   NAME <- NAMES[[kk]]
[08:28:14.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.763]                     next
[08:28:14.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.763]                 }
[08:28:14.763]                 NAMES <- toupper(added)
[08:28:14.763]                 for (kk in seq_along(NAMES)) {
[08:28:14.763]                   name <- added[[kk]]
[08:28:14.763]                   NAME <- NAMES[[kk]]
[08:28:14.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.763]                     next
[08:28:14.763]                   args[[name]] <- ""
[08:28:14.763]                 }
[08:28:14.763]                 NAMES <- toupper(removed)
[08:28:14.763]                 for (kk in seq_along(NAMES)) {
[08:28:14.763]                   name <- removed[[kk]]
[08:28:14.763]                   NAME <- NAMES[[kk]]
[08:28:14.763]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.763]                     next
[08:28:14.763]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.763]                 }
[08:28:14.763]                 if (length(args) > 0) 
[08:28:14.763]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.763]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.763]             }
[08:28:14.763]             else {
[08:28:14.763]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.763]             }
[08:28:14.763]             {
[08:28:14.763]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.763]                   0L) {
[08:28:14.763]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.763]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.763]                   base::options(opts)
[08:28:14.763]                 }
[08:28:14.763]                 {
[08:28:14.763]                   {
[08:28:14.763]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:14.763]                     NULL
[08:28:14.763]                   }
[08:28:14.763]                   options(future.plan = NULL)
[08:28:14.763]                   if (is.na(NA_character_)) 
[08:28:14.763]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.763]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.763]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.763]                     .init = FALSE)
[08:28:14.763]                 }
[08:28:14.763]             }
[08:28:14.763]         }
[08:28:14.763]     })
[08:28:14.763]     if (TRUE) {
[08:28:14.763]         base::sink(type = "output", split = FALSE)
[08:28:14.763]         if (TRUE) {
[08:28:14.763]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.763]         }
[08:28:14.763]         else {
[08:28:14.763]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.763]         }
[08:28:14.763]         base::close(...future.stdout)
[08:28:14.763]         ...future.stdout <- NULL
[08:28:14.763]     }
[08:28:14.763]     ...future.result$conditions <- ...future.conditions
[08:28:14.763]     ...future.result$finished <- base::Sys.time()
[08:28:14.763]     ...future.result
[08:28:14.763] }
[08:28:14.765] requestCore(): workers = 2
[08:28:14.768] MulticoreFuture started
[08:28:14.769] - Launch lazy future ... done
[08:28:14.769] plan(): Setting new future strategy stack:
[08:28:14.769] run() for ‘MulticoreFuture’ ... done
[08:28:14.769] List of future strategies:
[08:28:14.769] 1. sequential:
[08:28:14.769]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.769]    - tweaked: FALSE
[08:28:14.769]    - call: NULL
[08:28:14.770] plan(): nbrOfWorkers() = 1
[08:28:14.770] result() for MulticoreFuture ...
[08:28:14.772] plan(): Setting new future strategy stack:
[08:28:14.772] List of future strategies:
[08:28:14.772] 1. multicore:
[08:28:14.772]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:14.772]    - tweaked: FALSE
[08:28:14.772]    - call: plan(strategy)
[08:28:14.776] plan(): nbrOfWorkers() = 2
[08:28:14.781] result() for MulticoreFuture ...
[08:28:14.781] result() for MulticoreFuture ... done
[08:28:14.781] result() for MulticoreFuture ... done
[08:28:14.781] result() for MulticoreFuture ...
[08:28:14.781] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.782] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.782] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.784] - globals found: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.784] Searching for globals ... DONE
[08:28:14.784] Resolving globals: TRUE
[08:28:14.785] Resolving any globals that are futures ...
[08:28:14.785] - globals: [3] ‘{’, ‘<-’, ‘*’
[08:28:14.785] Resolving any globals that are futures ... DONE
[08:28:14.785] 
[08:28:14.785] 
[08:28:14.785] getGlobalsAndPackages() ... DONE
[08:28:14.786] run() for ‘Future’ ...
[08:28:14.786] - state: ‘created’
[08:28:14.786] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:14.788] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:14.788] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:14.788]   - Field: ‘label’
[08:28:14.788]   - Field: ‘local’
[08:28:14.789]   - Field: ‘owner’
[08:28:14.789]   - Field: ‘envir’
[08:28:14.789]   - Field: ‘workers’
[08:28:14.789]   - Field: ‘packages’
[08:28:14.789]   - Field: ‘gc’
[08:28:14.789]   - Field: ‘job’
[08:28:14.789]   - Field: ‘conditions’
[08:28:14.789]   - Field: ‘expr’
[08:28:14.789]   - Field: ‘uuid’
[08:28:14.790]   - Field: ‘seed’
[08:28:14.790]   - Field: ‘version’
[08:28:14.790]   - Field: ‘result’
[08:28:14.790]   - Field: ‘asynchronous’
[08:28:14.790]   - Field: ‘calls’
[08:28:14.790]   - Field: ‘globals’
[08:28:14.790]   - Field: ‘stdout’
[08:28:14.790]   - Field: ‘earlySignal’
[08:28:14.790]   - Field: ‘lazy’
[08:28:14.790]   - Field: ‘state’
[08:28:14.791] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:14.791] - Launch lazy future ...
[08:28:14.791] Packages needed by the future expression (n = 0): <none>
[08:28:14.791] Packages needed by future strategies (n = 0): <none>
[08:28:14.792] {
[08:28:14.792]     {
[08:28:14.792]         {
[08:28:14.792]             ...future.startTime <- base::Sys.time()
[08:28:14.792]             {
[08:28:14.792]                 {
[08:28:14.792]                   {
[08:28:14.792]                     {
[08:28:14.792]                       base::local({
[08:28:14.792]                         has_future <- base::requireNamespace("future", 
[08:28:14.792]                           quietly = TRUE)
[08:28:14.792]                         if (has_future) {
[08:28:14.792]                           ns <- base::getNamespace("future")
[08:28:14.792]                           version <- ns[[".package"]][["version"]]
[08:28:14.792]                           if (is.null(version)) 
[08:28:14.792]                             version <- utils::packageVersion("future")
[08:28:14.792]                         }
[08:28:14.792]                         else {
[08:28:14.792]                           version <- NULL
[08:28:14.792]                         }
[08:28:14.792]                         if (!has_future || version < "1.8.0") {
[08:28:14.792]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.792]                             "", base::R.version$version.string), 
[08:28:14.792]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.792]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.792]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.792]                               "release", "version")], collapse = " "), 
[08:28:14.792]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.792]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.792]                             info)
[08:28:14.792]                           info <- base::paste(info, collapse = "; ")
[08:28:14.792]                           if (!has_future) {
[08:28:14.792]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.792]                               info)
[08:28:14.792]                           }
[08:28:14.792]                           else {
[08:28:14.792]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.792]                               info, version)
[08:28:14.792]                           }
[08:28:14.792]                           base::stop(msg)
[08:28:14.792]                         }
[08:28:14.792]                       })
[08:28:14.792]                     }
[08:28:14.792]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:14.792]                     base::options(mc.cores = 1L)
[08:28:14.792]                   }
[08:28:14.792]                   ...future.strategy.old <- future::plan("list")
[08:28:14.792]                   options(future.plan = NULL)
[08:28:14.792]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.792]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.792]                 }
[08:28:14.792]                 ...future.workdir <- getwd()
[08:28:14.792]             }
[08:28:14.792]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.792]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.792]         }
[08:28:14.792]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.792]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.792]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.792]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.792]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.792]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.792]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.792]             base::names(...future.oldOptions))
[08:28:14.792]     }
[08:28:14.792]     if (FALSE) {
[08:28:14.792]     }
[08:28:14.792]     else {
[08:28:14.792]         if (TRUE) {
[08:28:14.792]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.792]                 open = "w")
[08:28:14.792]         }
[08:28:14.792]         else {
[08:28:14.792]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.792]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.792]         }
[08:28:14.792]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.792]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.792]             base::sink(type = "output", split = FALSE)
[08:28:14.792]             base::close(...future.stdout)
[08:28:14.792]         }, add = TRUE)
[08:28:14.792]     }
[08:28:14.792]     ...future.frame <- base::sys.nframe()
[08:28:14.792]     ...future.conditions <- base::list()
[08:28:14.792]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.792]     if (FALSE) {
[08:28:14.792]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.792]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.792]     }
[08:28:14.792]     ...future.result <- base::tryCatch({
[08:28:14.792]         base::withCallingHandlers({
[08:28:14.792]             ...future.value <- base::withVisible(base::local({
[08:28:14.792]                 withCallingHandlers({
[08:28:14.792]                   {
[08:28:14.792]                     b <- a
[08:28:14.792]                     a <- 2
[08:28:14.792]                     a * b
[08:28:14.792]                   }
[08:28:14.792]                 }, immediateCondition = function(cond) {
[08:28:14.792]                   save_rds <- function (object, pathname, ...) 
[08:28:14.792]                   {
[08:28:14.792]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:14.792]                     if (file_test("-f", pathname_tmp)) {
[08:28:14.792]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.792]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:14.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.792]                         fi_tmp[["mtime"]])
[08:28:14.792]                     }
[08:28:14.792]                     tryCatch({
[08:28:14.792]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:14.792]                     }, error = function(ex) {
[08:28:14.792]                       msg <- conditionMessage(ex)
[08:28:14.792]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.792]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:14.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.792]                         fi_tmp[["mtime"]], msg)
[08:28:14.792]                       ex$message <- msg
[08:28:14.792]                       stop(ex)
[08:28:14.792]                     })
[08:28:14.792]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:14.792]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:14.792]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:14.792]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.792]                       fi <- file.info(pathname)
[08:28:14.792]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:14.792]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.792]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:14.792]                         fi[["size"]], fi[["mtime"]])
[08:28:14.792]                       stop(msg)
[08:28:14.792]                     }
[08:28:14.792]                     invisible(pathname)
[08:28:14.792]                   }
[08:28:14.792]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:14.792]                     rootPath = tempdir()) 
[08:28:14.792]                   {
[08:28:14.792]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:14.792]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:14.792]                       tmpdir = path, fileext = ".rds")
[08:28:14.792]                     save_rds(obj, file)
[08:28:14.792]                   }
[08:28:14.792]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:14.792]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.792]                   {
[08:28:14.792]                     inherits <- base::inherits
[08:28:14.792]                     invokeRestart <- base::invokeRestart
[08:28:14.792]                     is.null <- base::is.null
[08:28:14.792]                     muffled <- FALSE
[08:28:14.792]                     if (inherits(cond, "message")) {
[08:28:14.792]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:14.792]                       if (muffled) 
[08:28:14.792]                         invokeRestart("muffleMessage")
[08:28:14.792]                     }
[08:28:14.792]                     else if (inherits(cond, "warning")) {
[08:28:14.792]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:14.792]                       if (muffled) 
[08:28:14.792]                         invokeRestart("muffleWarning")
[08:28:14.792]                     }
[08:28:14.792]                     else if (inherits(cond, "condition")) {
[08:28:14.792]                       if (!is.null(pattern)) {
[08:28:14.792]                         computeRestarts <- base::computeRestarts
[08:28:14.792]                         grepl <- base::grepl
[08:28:14.792]                         restarts <- computeRestarts(cond)
[08:28:14.792]                         for (restart in restarts) {
[08:28:14.792]                           name <- restart$name
[08:28:14.792]                           if (is.null(name)) 
[08:28:14.792]                             next
[08:28:14.792]                           if (!grepl(pattern, name)) 
[08:28:14.792]                             next
[08:28:14.792]                           invokeRestart(restart)
[08:28:14.792]                           muffled <- TRUE
[08:28:14.792]                           break
[08:28:14.792]                         }
[08:28:14.792]                       }
[08:28:14.792]                     }
[08:28:14.792]                     invisible(muffled)
[08:28:14.792]                   }
[08:28:14.792]                   muffleCondition(cond)
[08:28:14.792]                 })
[08:28:14.792]             }))
[08:28:14.792]             future::FutureResult(value = ...future.value$value, 
[08:28:14.792]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.792]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.792]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.792]                     ...future.globalenv.names))
[08:28:14.792]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.792]         }, condition = base::local({
[08:28:14.792]             c <- base::c
[08:28:14.792]             inherits <- base::inherits
[08:28:14.792]             invokeRestart <- base::invokeRestart
[08:28:14.792]             length <- base::length
[08:28:14.792]             list <- base::list
[08:28:14.792]             seq.int <- base::seq.int
[08:28:14.792]             signalCondition <- base::signalCondition
[08:28:14.792]             sys.calls <- base::sys.calls
[08:28:14.792]             `[[` <- base::`[[`
[08:28:14.792]             `+` <- base::`+`
[08:28:14.792]             `<<-` <- base::`<<-`
[08:28:14.792]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.792]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.792]                   3L)]
[08:28:14.792]             }
[08:28:14.792]             function(cond) {
[08:28:14.792]                 is_error <- inherits(cond, "error")
[08:28:14.792]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.792]                   NULL)
[08:28:14.792]                 if (is_error) {
[08:28:14.792]                   sessionInformation <- function() {
[08:28:14.792]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.792]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.792]                       search = base::search(), system = base::Sys.info())
[08:28:14.792]                   }
[08:28:14.792]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.792]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.792]                     cond$call), session = sessionInformation(), 
[08:28:14.792]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.792]                   signalCondition(cond)
[08:28:14.792]                 }
[08:28:14.792]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.792]                 "immediateCondition"))) {
[08:28:14.792]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.792]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.792]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.792]                   if (TRUE && !signal) {
[08:28:14.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.792]                     {
[08:28:14.792]                       inherits <- base::inherits
[08:28:14.792]                       invokeRestart <- base::invokeRestart
[08:28:14.792]                       is.null <- base::is.null
[08:28:14.792]                       muffled <- FALSE
[08:28:14.792]                       if (inherits(cond, "message")) {
[08:28:14.792]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.792]                         if (muffled) 
[08:28:14.792]                           invokeRestart("muffleMessage")
[08:28:14.792]                       }
[08:28:14.792]                       else if (inherits(cond, "warning")) {
[08:28:14.792]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.792]                         if (muffled) 
[08:28:14.792]                           invokeRestart("muffleWarning")
[08:28:14.792]                       }
[08:28:14.792]                       else if (inherits(cond, "condition")) {
[08:28:14.792]                         if (!is.null(pattern)) {
[08:28:14.792]                           computeRestarts <- base::computeRestarts
[08:28:14.792]                           grepl <- base::grepl
[08:28:14.792]                           restarts <- computeRestarts(cond)
[08:28:14.792]                           for (restart in restarts) {
[08:28:14.792]                             name <- restart$name
[08:28:14.792]                             if (is.null(name)) 
[08:28:14.792]                               next
[08:28:14.792]                             if (!grepl(pattern, name)) 
[08:28:14.792]                               next
[08:28:14.792]                             invokeRestart(restart)
[08:28:14.792]                             muffled <- TRUE
[08:28:14.792]                             break
[08:28:14.792]                           }
[08:28:14.792]                         }
[08:28:14.792]                       }
[08:28:14.792]                       invisible(muffled)
[08:28:14.792]                     }
[08:28:14.792]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.792]                   }
[08:28:14.792]                 }
[08:28:14.792]                 else {
[08:28:14.792]                   if (TRUE) {
[08:28:14.792]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.792]                     {
[08:28:14.792]                       inherits <- base::inherits
[08:28:14.792]                       invokeRestart <- base::invokeRestart
[08:28:14.792]                       is.null <- base::is.null
[08:28:14.792]                       muffled <- FALSE
[08:28:14.792]                       if (inherits(cond, "message")) {
[08:28:14.792]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.792]                         if (muffled) 
[08:28:14.792]                           invokeRestart("muffleMessage")
[08:28:14.792]                       }
[08:28:14.792]                       else if (inherits(cond, "warning")) {
[08:28:14.792]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.792]                         if (muffled) 
[08:28:14.792]                           invokeRestart("muffleWarning")
[08:28:14.792]                       }
[08:28:14.792]                       else if (inherits(cond, "condition")) {
[08:28:14.792]                         if (!is.null(pattern)) {
[08:28:14.792]                           computeRestarts <- base::computeRestarts
[08:28:14.792]                           grepl <- base::grepl
[08:28:14.792]                           restarts <- computeRestarts(cond)
[08:28:14.792]                           for (restart in restarts) {
[08:28:14.792]                             name <- restart$name
[08:28:14.792]                             if (is.null(name)) 
[08:28:14.792]                               next
[08:28:14.792]                             if (!grepl(pattern, name)) 
[08:28:14.792]                               next
[08:28:14.792]                             invokeRestart(restart)
[08:28:14.792]                             muffled <- TRUE
[08:28:14.792]                             break
[08:28:14.792]                           }
[08:28:14.792]                         }
[08:28:14.792]                       }
[08:28:14.792]                       invisible(muffled)
[08:28:14.792]                     }
[08:28:14.792]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.792]                   }
[08:28:14.792]                 }
[08:28:14.792]             }
[08:28:14.792]         }))
[08:28:14.792]     }, error = function(ex) {
[08:28:14.792]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.792]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.792]                 ...future.rng), started = ...future.startTime, 
[08:28:14.792]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.792]             version = "1.8"), class = "FutureResult")
[08:28:14.792]     }, finally = {
[08:28:14.792]         if (!identical(...future.workdir, getwd())) 
[08:28:14.792]             setwd(...future.workdir)
[08:28:14.792]         {
[08:28:14.792]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.792]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.792]             }
[08:28:14.792]             base::options(...future.oldOptions)
[08:28:14.792]             if (.Platform$OS.type == "windows") {
[08:28:14.792]                 old_names <- names(...future.oldEnvVars)
[08:28:14.792]                 envs <- base::Sys.getenv()
[08:28:14.792]                 names <- names(envs)
[08:28:14.792]                 common <- intersect(names, old_names)
[08:28:14.792]                 added <- setdiff(names, old_names)
[08:28:14.792]                 removed <- setdiff(old_names, names)
[08:28:14.792]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.792]                   envs[common]]
[08:28:14.792]                 NAMES <- toupper(changed)
[08:28:14.792]                 args <- list()
[08:28:14.792]                 for (kk in seq_along(NAMES)) {
[08:28:14.792]                   name <- changed[[kk]]
[08:28:14.792]                   NAME <- NAMES[[kk]]
[08:28:14.792]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.792]                     next
[08:28:14.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.792]                 }
[08:28:14.792]                 NAMES <- toupper(added)
[08:28:14.792]                 for (kk in seq_along(NAMES)) {
[08:28:14.792]                   name <- added[[kk]]
[08:28:14.792]                   NAME <- NAMES[[kk]]
[08:28:14.792]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.792]                     next
[08:28:14.792]                   args[[name]] <- ""
[08:28:14.792]                 }
[08:28:14.792]                 NAMES <- toupper(removed)
[08:28:14.792]                 for (kk in seq_along(NAMES)) {
[08:28:14.792]                   name <- removed[[kk]]
[08:28:14.792]                   NAME <- NAMES[[kk]]
[08:28:14.792]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.792]                     next
[08:28:14.792]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.792]                 }
[08:28:14.792]                 if (length(args) > 0) 
[08:28:14.792]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.792]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.792]             }
[08:28:14.792]             else {
[08:28:14.792]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.792]             }
[08:28:14.792]             {
[08:28:14.792]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.792]                   0L) {
[08:28:14.792]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.792]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.792]                   base::options(opts)
[08:28:14.792]                 }
[08:28:14.792]                 {
[08:28:14.792]                   {
[08:28:14.792]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:14.792]                     NULL
[08:28:14.792]                   }
[08:28:14.792]                   options(future.plan = NULL)
[08:28:14.792]                   if (is.na(NA_character_)) 
[08:28:14.792]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.792]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.792]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.792]                     .init = FALSE)
[08:28:14.792]                 }
[08:28:14.792]             }
[08:28:14.792]         }
[08:28:14.792]     })
[08:28:14.792]     if (TRUE) {
[08:28:14.792]         base::sink(type = "output", split = FALSE)
[08:28:14.792]         if (TRUE) {
[08:28:14.792]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.792]         }
[08:28:14.792]         else {
[08:28:14.792]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.792]         }
[08:28:14.792]         base::close(...future.stdout)
[08:28:14.792]         ...future.stdout <- NULL
[08:28:14.792]     }
[08:28:14.792]     ...future.result$conditions <- ...future.conditions
[08:28:14.792]     ...future.result$finished <- base::Sys.time()
[08:28:14.792]     ...future.result
[08:28:14.792] }
[08:28:14.794] requestCore(): workers = 2
[08:28:14.796] MulticoreFuture started
[08:28:14.797] - Launch lazy future ... done
[08:28:14.797] run() for ‘MulticoreFuture’ ... done
[08:28:14.797] plan(): Setting new future strategy stack:
[08:28:14.797] result() for MulticoreFuture ...
[08:28:14.797] List of future strategies:
[08:28:14.797] 1. sequential:
[08:28:14.797]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.797]    - tweaked: FALSE
[08:28:14.797]    - call: NULL
[08:28:14.798] plan(): nbrOfWorkers() = 1
[08:28:14.806] plan(): Setting new future strategy stack:
[08:28:14.806] List of future strategies:
[08:28:14.806] 1. multicore:
[08:28:14.806]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:14.806]    - tweaked: FALSE
[08:28:14.806]    - call: plan(strategy)
[08:28:14.811] plan(): nbrOfWorkers() = 2
[08:28:14.821] result() for MulticoreFuture ...
[08:28:14.821] result() for MulticoreFuture ... done
[08:28:14.821] signalConditions() ...
[08:28:14.821]  - include = ‘immediateCondition’
[08:28:14.822]  - exclude = 
[08:28:14.822]  - resignal = FALSE
[08:28:14.822]  - Number of conditions: 1
[08:28:14.822] signalConditions() ... done
[08:28:14.822] result() for MulticoreFuture ... done
[08:28:14.822] result() for MulticoreFuture ...
[08:28:14.822] result() for MulticoreFuture ... done
[08:28:14.823] signalConditions() ...
[08:28:14.823]  - include = ‘immediateCondition’
[08:28:14.823]  - exclude = 
[08:28:14.823]  - resignal = FALSE
[08:28:14.823]  - Number of conditions: 1
[08:28:14.823] signalConditions() ... done
[08:28:14.823] Future state: ‘finished’
[08:28:14.823] result() for MulticoreFuture ...
[08:28:14.824] result() for MulticoreFuture ... done
[08:28:14.824] signalConditions() ...
[08:28:14.824]  - include = ‘condition’
[08:28:14.824]  - exclude = ‘immediateCondition’
[08:28:14.824]  - resignal = TRUE
[08:28:14.824]  - Number of conditions: 1
[08:28:14.824]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:14.825] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.850] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.850] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.852] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.852] Searching for globals ... DONE
[08:28:14.852] Resolving globals: TRUE
[08:28:14.852] Resolving any globals that are futures ...
[08:28:14.852] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.852] Resolving any globals that are futures ... DONE
[08:28:14.853] Resolving futures part of globals (recursively) ...
[08:28:14.853] resolve() on list ...
[08:28:14.853]  recursive: 99
[08:28:14.853]  length: 1
[08:28:14.853]  elements: ‘ii’
[08:28:14.853]  length: 0 (resolved future 1)
[08:28:14.853] resolve() on list ... DONE
[08:28:14.853] - globals: [1] ‘ii’
[08:28:14.854] Resolving futures part of globals (recursively) ... DONE
[08:28:14.854] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.854] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.854] - globals: [1] ‘ii’
[08:28:14.854] 
[08:28:14.854] getGlobalsAndPackages() ... DONE
[08:28:14.855] run() for ‘Future’ ...
[08:28:14.855] - state: ‘created’
[08:28:14.855] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:14.857] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:14.857] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:14.857]   - Field: ‘label’
[08:28:14.857]   - Field: ‘local’
[08:28:14.857]   - Field: ‘owner’
[08:28:14.857]   - Field: ‘envir’
[08:28:14.857]   - Field: ‘workers’
[08:28:14.857]   - Field: ‘packages’
[08:28:14.857]   - Field: ‘gc’
[08:28:14.857]   - Field: ‘job’
[08:28:14.858]   - Field: ‘conditions’
[08:28:14.858]   - Field: ‘expr’
[08:28:14.858]   - Field: ‘uuid’
[08:28:14.858]   - Field: ‘seed’
[08:28:14.858]   - Field: ‘version’
[08:28:14.858]   - Field: ‘result’
[08:28:14.858]   - Field: ‘asynchronous’
[08:28:14.858]   - Field: ‘calls’
[08:28:14.858]   - Field: ‘globals’
[08:28:14.858]   - Field: ‘stdout’
[08:28:14.858]   - Field: ‘earlySignal’
[08:28:14.858]   - Field: ‘lazy’
[08:28:14.859]   - Field: ‘state’
[08:28:14.859] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:14.859] - Launch lazy future ...
[08:28:14.859] Packages needed by the future expression (n = 0): <none>
[08:28:14.859] Packages needed by future strategies (n = 0): <none>
[08:28:14.860] {
[08:28:14.860]     {
[08:28:14.860]         {
[08:28:14.860]             ...future.startTime <- base::Sys.time()
[08:28:14.860]             {
[08:28:14.860]                 {
[08:28:14.860]                   {
[08:28:14.860]                     {
[08:28:14.860]                       base::local({
[08:28:14.860]                         has_future <- base::requireNamespace("future", 
[08:28:14.860]                           quietly = TRUE)
[08:28:14.860]                         if (has_future) {
[08:28:14.860]                           ns <- base::getNamespace("future")
[08:28:14.860]                           version <- ns[[".package"]][["version"]]
[08:28:14.860]                           if (is.null(version)) 
[08:28:14.860]                             version <- utils::packageVersion("future")
[08:28:14.860]                         }
[08:28:14.860]                         else {
[08:28:14.860]                           version <- NULL
[08:28:14.860]                         }
[08:28:14.860]                         if (!has_future || version < "1.8.0") {
[08:28:14.860]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.860]                             "", base::R.version$version.string), 
[08:28:14.860]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.860]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.860]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.860]                               "release", "version")], collapse = " "), 
[08:28:14.860]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.860]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.860]                             info)
[08:28:14.860]                           info <- base::paste(info, collapse = "; ")
[08:28:14.860]                           if (!has_future) {
[08:28:14.860]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.860]                               info)
[08:28:14.860]                           }
[08:28:14.860]                           else {
[08:28:14.860]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.860]                               info, version)
[08:28:14.860]                           }
[08:28:14.860]                           base::stop(msg)
[08:28:14.860]                         }
[08:28:14.860]                       })
[08:28:14.860]                     }
[08:28:14.860]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:14.860]                     base::options(mc.cores = 1L)
[08:28:14.860]                   }
[08:28:14.860]                   ...future.strategy.old <- future::plan("list")
[08:28:14.860]                   options(future.plan = NULL)
[08:28:14.860]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.860]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.860]                 }
[08:28:14.860]                 ...future.workdir <- getwd()
[08:28:14.860]             }
[08:28:14.860]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.860]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.860]         }
[08:28:14.860]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.860]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.860]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.860]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.860]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.860]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.860]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.860]             base::names(...future.oldOptions))
[08:28:14.860]     }
[08:28:14.860]     if (FALSE) {
[08:28:14.860]     }
[08:28:14.860]     else {
[08:28:14.860]         if (TRUE) {
[08:28:14.860]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.860]                 open = "w")
[08:28:14.860]         }
[08:28:14.860]         else {
[08:28:14.860]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.860]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.860]         }
[08:28:14.860]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.860]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.860]             base::sink(type = "output", split = FALSE)
[08:28:14.860]             base::close(...future.stdout)
[08:28:14.860]         }, add = TRUE)
[08:28:14.860]     }
[08:28:14.860]     ...future.frame <- base::sys.nframe()
[08:28:14.860]     ...future.conditions <- base::list()
[08:28:14.860]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.860]     if (FALSE) {
[08:28:14.860]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.860]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.860]     }
[08:28:14.860]     ...future.result <- base::tryCatch({
[08:28:14.860]         base::withCallingHandlers({
[08:28:14.860]             ...future.value <- base::withVisible(base::local({
[08:28:14.860]                 withCallingHandlers({
[08:28:14.860]                   {
[08:28:14.860]                     b <- a * ii
[08:28:14.860]                     a <- 0
[08:28:14.860]                     b
[08:28:14.860]                   }
[08:28:14.860]                 }, immediateCondition = function(cond) {
[08:28:14.860]                   save_rds <- function (object, pathname, ...) 
[08:28:14.860]                   {
[08:28:14.860]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:14.860]                     if (file_test("-f", pathname_tmp)) {
[08:28:14.860]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.860]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:14.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.860]                         fi_tmp[["mtime"]])
[08:28:14.860]                     }
[08:28:14.860]                     tryCatch({
[08:28:14.860]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:14.860]                     }, error = function(ex) {
[08:28:14.860]                       msg <- conditionMessage(ex)
[08:28:14.860]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.860]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:14.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.860]                         fi_tmp[["mtime"]], msg)
[08:28:14.860]                       ex$message <- msg
[08:28:14.860]                       stop(ex)
[08:28:14.860]                     })
[08:28:14.860]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:14.860]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:14.860]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:14.860]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.860]                       fi <- file.info(pathname)
[08:28:14.860]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:14.860]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.860]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:14.860]                         fi[["size"]], fi[["mtime"]])
[08:28:14.860]                       stop(msg)
[08:28:14.860]                     }
[08:28:14.860]                     invisible(pathname)
[08:28:14.860]                   }
[08:28:14.860]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:14.860]                     rootPath = tempdir()) 
[08:28:14.860]                   {
[08:28:14.860]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:14.860]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:14.860]                       tmpdir = path, fileext = ".rds")
[08:28:14.860]                     save_rds(obj, file)
[08:28:14.860]                   }
[08:28:14.860]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:14.860]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.860]                   {
[08:28:14.860]                     inherits <- base::inherits
[08:28:14.860]                     invokeRestart <- base::invokeRestart
[08:28:14.860]                     is.null <- base::is.null
[08:28:14.860]                     muffled <- FALSE
[08:28:14.860]                     if (inherits(cond, "message")) {
[08:28:14.860]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:14.860]                       if (muffled) 
[08:28:14.860]                         invokeRestart("muffleMessage")
[08:28:14.860]                     }
[08:28:14.860]                     else if (inherits(cond, "warning")) {
[08:28:14.860]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:14.860]                       if (muffled) 
[08:28:14.860]                         invokeRestart("muffleWarning")
[08:28:14.860]                     }
[08:28:14.860]                     else if (inherits(cond, "condition")) {
[08:28:14.860]                       if (!is.null(pattern)) {
[08:28:14.860]                         computeRestarts <- base::computeRestarts
[08:28:14.860]                         grepl <- base::grepl
[08:28:14.860]                         restarts <- computeRestarts(cond)
[08:28:14.860]                         for (restart in restarts) {
[08:28:14.860]                           name <- restart$name
[08:28:14.860]                           if (is.null(name)) 
[08:28:14.860]                             next
[08:28:14.860]                           if (!grepl(pattern, name)) 
[08:28:14.860]                             next
[08:28:14.860]                           invokeRestart(restart)
[08:28:14.860]                           muffled <- TRUE
[08:28:14.860]                           break
[08:28:14.860]                         }
[08:28:14.860]                       }
[08:28:14.860]                     }
[08:28:14.860]                     invisible(muffled)
[08:28:14.860]                   }
[08:28:14.860]                   muffleCondition(cond)
[08:28:14.860]                 })
[08:28:14.860]             }))
[08:28:14.860]             future::FutureResult(value = ...future.value$value, 
[08:28:14.860]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.860]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.860]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.860]                     ...future.globalenv.names))
[08:28:14.860]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.860]         }, condition = base::local({
[08:28:14.860]             c <- base::c
[08:28:14.860]             inherits <- base::inherits
[08:28:14.860]             invokeRestart <- base::invokeRestart
[08:28:14.860]             length <- base::length
[08:28:14.860]             list <- base::list
[08:28:14.860]             seq.int <- base::seq.int
[08:28:14.860]             signalCondition <- base::signalCondition
[08:28:14.860]             sys.calls <- base::sys.calls
[08:28:14.860]             `[[` <- base::`[[`
[08:28:14.860]             `+` <- base::`+`
[08:28:14.860]             `<<-` <- base::`<<-`
[08:28:14.860]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.860]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.860]                   3L)]
[08:28:14.860]             }
[08:28:14.860]             function(cond) {
[08:28:14.860]                 is_error <- inherits(cond, "error")
[08:28:14.860]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.860]                   NULL)
[08:28:14.860]                 if (is_error) {
[08:28:14.860]                   sessionInformation <- function() {
[08:28:14.860]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.860]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.860]                       search = base::search(), system = base::Sys.info())
[08:28:14.860]                   }
[08:28:14.860]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.860]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.860]                     cond$call), session = sessionInformation(), 
[08:28:14.860]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.860]                   signalCondition(cond)
[08:28:14.860]                 }
[08:28:14.860]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.860]                 "immediateCondition"))) {
[08:28:14.860]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.860]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.860]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.860]                   if (TRUE && !signal) {
[08:28:14.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.860]                     {
[08:28:14.860]                       inherits <- base::inherits
[08:28:14.860]                       invokeRestart <- base::invokeRestart
[08:28:14.860]                       is.null <- base::is.null
[08:28:14.860]                       muffled <- FALSE
[08:28:14.860]                       if (inherits(cond, "message")) {
[08:28:14.860]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.860]                         if (muffled) 
[08:28:14.860]                           invokeRestart("muffleMessage")
[08:28:14.860]                       }
[08:28:14.860]                       else if (inherits(cond, "warning")) {
[08:28:14.860]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.860]                         if (muffled) 
[08:28:14.860]                           invokeRestart("muffleWarning")
[08:28:14.860]                       }
[08:28:14.860]                       else if (inherits(cond, "condition")) {
[08:28:14.860]                         if (!is.null(pattern)) {
[08:28:14.860]                           computeRestarts <- base::computeRestarts
[08:28:14.860]                           grepl <- base::grepl
[08:28:14.860]                           restarts <- computeRestarts(cond)
[08:28:14.860]                           for (restart in restarts) {
[08:28:14.860]                             name <- restart$name
[08:28:14.860]                             if (is.null(name)) 
[08:28:14.860]                               next
[08:28:14.860]                             if (!grepl(pattern, name)) 
[08:28:14.860]                               next
[08:28:14.860]                             invokeRestart(restart)
[08:28:14.860]                             muffled <- TRUE
[08:28:14.860]                             break
[08:28:14.860]                           }
[08:28:14.860]                         }
[08:28:14.860]                       }
[08:28:14.860]                       invisible(muffled)
[08:28:14.860]                     }
[08:28:14.860]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.860]                   }
[08:28:14.860]                 }
[08:28:14.860]                 else {
[08:28:14.860]                   if (TRUE) {
[08:28:14.860]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.860]                     {
[08:28:14.860]                       inherits <- base::inherits
[08:28:14.860]                       invokeRestart <- base::invokeRestart
[08:28:14.860]                       is.null <- base::is.null
[08:28:14.860]                       muffled <- FALSE
[08:28:14.860]                       if (inherits(cond, "message")) {
[08:28:14.860]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.860]                         if (muffled) 
[08:28:14.860]                           invokeRestart("muffleMessage")
[08:28:14.860]                       }
[08:28:14.860]                       else if (inherits(cond, "warning")) {
[08:28:14.860]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.860]                         if (muffled) 
[08:28:14.860]                           invokeRestart("muffleWarning")
[08:28:14.860]                       }
[08:28:14.860]                       else if (inherits(cond, "condition")) {
[08:28:14.860]                         if (!is.null(pattern)) {
[08:28:14.860]                           computeRestarts <- base::computeRestarts
[08:28:14.860]                           grepl <- base::grepl
[08:28:14.860]                           restarts <- computeRestarts(cond)
[08:28:14.860]                           for (restart in restarts) {
[08:28:14.860]                             name <- restart$name
[08:28:14.860]                             if (is.null(name)) 
[08:28:14.860]                               next
[08:28:14.860]                             if (!grepl(pattern, name)) 
[08:28:14.860]                               next
[08:28:14.860]                             invokeRestart(restart)
[08:28:14.860]                             muffled <- TRUE
[08:28:14.860]                             break
[08:28:14.860]                           }
[08:28:14.860]                         }
[08:28:14.860]                       }
[08:28:14.860]                       invisible(muffled)
[08:28:14.860]                     }
[08:28:14.860]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.860]                   }
[08:28:14.860]                 }
[08:28:14.860]             }
[08:28:14.860]         }))
[08:28:14.860]     }, error = function(ex) {
[08:28:14.860]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.860]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.860]                 ...future.rng), started = ...future.startTime, 
[08:28:14.860]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.860]             version = "1.8"), class = "FutureResult")
[08:28:14.860]     }, finally = {
[08:28:14.860]         if (!identical(...future.workdir, getwd())) 
[08:28:14.860]             setwd(...future.workdir)
[08:28:14.860]         {
[08:28:14.860]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.860]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.860]             }
[08:28:14.860]             base::options(...future.oldOptions)
[08:28:14.860]             if (.Platform$OS.type == "windows") {
[08:28:14.860]                 old_names <- names(...future.oldEnvVars)
[08:28:14.860]                 envs <- base::Sys.getenv()
[08:28:14.860]                 names <- names(envs)
[08:28:14.860]                 common <- intersect(names, old_names)
[08:28:14.860]                 added <- setdiff(names, old_names)
[08:28:14.860]                 removed <- setdiff(old_names, names)
[08:28:14.860]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.860]                   envs[common]]
[08:28:14.860]                 NAMES <- toupper(changed)
[08:28:14.860]                 args <- list()
[08:28:14.860]                 for (kk in seq_along(NAMES)) {
[08:28:14.860]                   name <- changed[[kk]]
[08:28:14.860]                   NAME <- NAMES[[kk]]
[08:28:14.860]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.860]                     next
[08:28:14.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.860]                 }
[08:28:14.860]                 NAMES <- toupper(added)
[08:28:14.860]                 for (kk in seq_along(NAMES)) {
[08:28:14.860]                   name <- added[[kk]]
[08:28:14.860]                   NAME <- NAMES[[kk]]
[08:28:14.860]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.860]                     next
[08:28:14.860]                   args[[name]] <- ""
[08:28:14.860]                 }
[08:28:14.860]                 NAMES <- toupper(removed)
[08:28:14.860]                 for (kk in seq_along(NAMES)) {
[08:28:14.860]                   name <- removed[[kk]]
[08:28:14.860]                   NAME <- NAMES[[kk]]
[08:28:14.860]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.860]                     next
[08:28:14.860]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.860]                 }
[08:28:14.860]                 if (length(args) > 0) 
[08:28:14.860]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.860]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.860]             }
[08:28:14.860]             else {
[08:28:14.860]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.860]             }
[08:28:14.860]             {
[08:28:14.860]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.860]                   0L) {
[08:28:14.860]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.860]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.860]                   base::options(opts)
[08:28:14.860]                 }
[08:28:14.860]                 {
[08:28:14.860]                   {
[08:28:14.860]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:14.860]                     NULL
[08:28:14.860]                   }
[08:28:14.860]                   options(future.plan = NULL)
[08:28:14.860]                   if (is.na(NA_character_)) 
[08:28:14.860]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.860]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.860]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.860]                     .init = FALSE)
[08:28:14.860]                 }
[08:28:14.860]             }
[08:28:14.860]         }
[08:28:14.860]     })
[08:28:14.860]     if (TRUE) {
[08:28:14.860]         base::sink(type = "output", split = FALSE)
[08:28:14.860]         if (TRUE) {
[08:28:14.860]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.860]         }
[08:28:14.860]         else {
[08:28:14.860]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.860]         }
[08:28:14.860]         base::close(...future.stdout)
[08:28:14.860]         ...future.stdout <- NULL
[08:28:14.860]     }
[08:28:14.860]     ...future.result$conditions <- ...future.conditions
[08:28:14.860]     ...future.result$finished <- base::Sys.time()
[08:28:14.860]     ...future.result
[08:28:14.860] }
[08:28:14.862] assign_globals() ...
[08:28:14.862] List of 1
[08:28:14.862]  $ ii: int 1
[08:28:14.862]  - attr(*, "where")=List of 1
[08:28:14.862]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.862]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.862]  - attr(*, "resolved")= logi TRUE
[08:28:14.862]  - attr(*, "total_size")= num 35
[08:28:14.862]  - attr(*, "already-done")= logi TRUE
[08:28:14.864] - copied ‘ii’ to environment
[08:28:14.864] assign_globals() ... done
[08:28:14.864] requestCore(): workers = 2
[08:28:14.866] MulticoreFuture started
[08:28:14.867] - Launch lazy future ... done
[08:28:14.867] run() for ‘MulticoreFuture’ ... done
[08:28:14.867] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.868] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.868] List of future strategies:
[08:28:14.868] 1. sequential:
[08:28:14.868]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.868]    - tweaked: FALSE
[08:28:14.868]    - call: NULL
[08:28:14.869] Searching for globals...
[08:28:14.869] plan(): nbrOfWorkers() = 1
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.871] plan(): Setting new future strategy stack:
[08:28:14.871] List of future strategies:
[08:28:14.871] 1. multicore:
[08:28:14.871]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:14.871]    - tweaked: FALSE
[08:28:14.871]    - call: plan(strategy)
[08:28:14.871] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.872] Searching for globals ... DONE
[08:28:14.872] Resolving globals: TRUE
[08:28:14.872] Resolving any globals that are futures ...
[08:28:14.872] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.872] Resolving any globals that are futures ... DONE
[08:28:14.873] Resolving futures part of globals (recursively) ...
[08:28:14.873] resolve() on list ...
[08:28:14.874]  recursive: 99
[08:28:14.874]  length: 1
[08:28:14.874] plan(): nbrOfWorkers() = 2
[08:28:14.874]  elements: ‘ii’
[08:28:14.874]  length: 0 (resolved future 1)
[08:28:14.874] resolve() on list ... DONE
[08:28:14.874] - globals: [1] ‘ii’
[08:28:14.874] Resolving futures part of globals (recursively) ... DONE
[08:28:14.875] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.879] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.879] - globals: [1] ‘ii’
[08:28:14.879] 
[08:28:14.880] getGlobalsAndPackages() ... DONE
[08:28:14.880] run() for ‘Future’ ...
[08:28:14.881] - state: ‘created’
[08:28:14.881] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:14.884] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:14.884] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:14.884]   - Field: ‘label’
[08:28:14.884]   - Field: ‘local’
[08:28:14.884]   - Field: ‘owner’
[08:28:14.884]   - Field: ‘envir’
[08:28:14.885]   - Field: ‘workers’
[08:28:14.885]   - Field: ‘packages’
[08:28:14.885]   - Field: ‘gc’
[08:28:14.885]   - Field: ‘job’
[08:28:14.885]   - Field: ‘conditions’
[08:28:14.886]   - Field: ‘expr’
[08:28:14.886]   - Field: ‘uuid’
[08:28:14.886]   - Field: ‘seed’
[08:28:14.886]   - Field: ‘version’
[08:28:14.886]   - Field: ‘result’
[08:28:14.886]   - Field: ‘asynchronous’
[08:28:14.886]   - Field: ‘calls’
[08:28:14.887]   - Field: ‘globals’
[08:28:14.887]   - Field: ‘stdout’
[08:28:14.887]   - Field: ‘earlySignal’
[08:28:14.887]   - Field: ‘lazy’
[08:28:14.887]   - Field: ‘state’
[08:28:14.887] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:14.887] - Launch lazy future ...
[08:28:14.888] Packages needed by the future expression (n = 0): <none>
[08:28:14.888] Packages needed by future strategies (n = 0): <none>
[08:28:14.889] {
[08:28:14.889]     {
[08:28:14.889]         {
[08:28:14.889]             ...future.startTime <- base::Sys.time()
[08:28:14.889]             {
[08:28:14.889]                 {
[08:28:14.889]                   {
[08:28:14.889]                     {
[08:28:14.889]                       base::local({
[08:28:14.889]                         has_future <- base::requireNamespace("future", 
[08:28:14.889]                           quietly = TRUE)
[08:28:14.889]                         if (has_future) {
[08:28:14.889]                           ns <- base::getNamespace("future")
[08:28:14.889]                           version <- ns[[".package"]][["version"]]
[08:28:14.889]                           if (is.null(version)) 
[08:28:14.889]                             version <- utils::packageVersion("future")
[08:28:14.889]                         }
[08:28:14.889]                         else {
[08:28:14.889]                           version <- NULL
[08:28:14.889]                         }
[08:28:14.889]                         if (!has_future || version < "1.8.0") {
[08:28:14.889]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.889]                             "", base::R.version$version.string), 
[08:28:14.889]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.889]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.889]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.889]                               "release", "version")], collapse = " "), 
[08:28:14.889]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.889]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.889]                             info)
[08:28:14.889]                           info <- base::paste(info, collapse = "; ")
[08:28:14.889]                           if (!has_future) {
[08:28:14.889]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.889]                               info)
[08:28:14.889]                           }
[08:28:14.889]                           else {
[08:28:14.889]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.889]                               info, version)
[08:28:14.889]                           }
[08:28:14.889]                           base::stop(msg)
[08:28:14.889]                         }
[08:28:14.889]                       })
[08:28:14.889]                     }
[08:28:14.889]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:14.889]                     base::options(mc.cores = 1L)
[08:28:14.889]                   }
[08:28:14.889]                   ...future.strategy.old <- future::plan("list")
[08:28:14.889]                   options(future.plan = NULL)
[08:28:14.889]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.889]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.889]                 }
[08:28:14.889]                 ...future.workdir <- getwd()
[08:28:14.889]             }
[08:28:14.889]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.889]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.889]         }
[08:28:14.889]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.889]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.889]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.889]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.889]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.889]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.889]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.889]             base::names(...future.oldOptions))
[08:28:14.889]     }
[08:28:14.889]     if (FALSE) {
[08:28:14.889]     }
[08:28:14.889]     else {
[08:28:14.889]         if (TRUE) {
[08:28:14.889]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.889]                 open = "w")
[08:28:14.889]         }
[08:28:14.889]         else {
[08:28:14.889]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.889]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.889]         }
[08:28:14.889]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.889]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.889]             base::sink(type = "output", split = FALSE)
[08:28:14.889]             base::close(...future.stdout)
[08:28:14.889]         }, add = TRUE)
[08:28:14.889]     }
[08:28:14.889]     ...future.frame <- base::sys.nframe()
[08:28:14.889]     ...future.conditions <- base::list()
[08:28:14.889]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.889]     if (FALSE) {
[08:28:14.889]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.889]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.889]     }
[08:28:14.889]     ...future.result <- base::tryCatch({
[08:28:14.889]         base::withCallingHandlers({
[08:28:14.889]             ...future.value <- base::withVisible(base::local({
[08:28:14.889]                 withCallingHandlers({
[08:28:14.889]                   {
[08:28:14.889]                     b <- a * ii
[08:28:14.889]                     a <- 0
[08:28:14.889]                     b
[08:28:14.889]                   }
[08:28:14.889]                 }, immediateCondition = function(cond) {
[08:28:14.889]                   save_rds <- function (object, pathname, ...) 
[08:28:14.889]                   {
[08:28:14.889]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:14.889]                     if (file_test("-f", pathname_tmp)) {
[08:28:14.889]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.889]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:14.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.889]                         fi_tmp[["mtime"]])
[08:28:14.889]                     }
[08:28:14.889]                     tryCatch({
[08:28:14.889]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:14.889]                     }, error = function(ex) {
[08:28:14.889]                       msg <- conditionMessage(ex)
[08:28:14.889]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.889]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:14.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.889]                         fi_tmp[["mtime"]], msg)
[08:28:14.889]                       ex$message <- msg
[08:28:14.889]                       stop(ex)
[08:28:14.889]                     })
[08:28:14.889]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:14.889]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:14.889]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:14.889]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.889]                       fi <- file.info(pathname)
[08:28:14.889]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:14.889]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.889]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:14.889]                         fi[["size"]], fi[["mtime"]])
[08:28:14.889]                       stop(msg)
[08:28:14.889]                     }
[08:28:14.889]                     invisible(pathname)
[08:28:14.889]                   }
[08:28:14.889]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:14.889]                     rootPath = tempdir()) 
[08:28:14.889]                   {
[08:28:14.889]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:14.889]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:14.889]                       tmpdir = path, fileext = ".rds")
[08:28:14.889]                     save_rds(obj, file)
[08:28:14.889]                   }
[08:28:14.889]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:14.889]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.889]                   {
[08:28:14.889]                     inherits <- base::inherits
[08:28:14.889]                     invokeRestart <- base::invokeRestart
[08:28:14.889]                     is.null <- base::is.null
[08:28:14.889]                     muffled <- FALSE
[08:28:14.889]                     if (inherits(cond, "message")) {
[08:28:14.889]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:14.889]                       if (muffled) 
[08:28:14.889]                         invokeRestart("muffleMessage")
[08:28:14.889]                     }
[08:28:14.889]                     else if (inherits(cond, "warning")) {
[08:28:14.889]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:14.889]                       if (muffled) 
[08:28:14.889]                         invokeRestart("muffleWarning")
[08:28:14.889]                     }
[08:28:14.889]                     else if (inherits(cond, "condition")) {
[08:28:14.889]                       if (!is.null(pattern)) {
[08:28:14.889]                         computeRestarts <- base::computeRestarts
[08:28:14.889]                         grepl <- base::grepl
[08:28:14.889]                         restarts <- computeRestarts(cond)
[08:28:14.889]                         for (restart in restarts) {
[08:28:14.889]                           name <- restart$name
[08:28:14.889]                           if (is.null(name)) 
[08:28:14.889]                             next
[08:28:14.889]                           if (!grepl(pattern, name)) 
[08:28:14.889]                             next
[08:28:14.889]                           invokeRestart(restart)
[08:28:14.889]                           muffled <- TRUE
[08:28:14.889]                           break
[08:28:14.889]                         }
[08:28:14.889]                       }
[08:28:14.889]                     }
[08:28:14.889]                     invisible(muffled)
[08:28:14.889]                   }
[08:28:14.889]                   muffleCondition(cond)
[08:28:14.889]                 })
[08:28:14.889]             }))
[08:28:14.889]             future::FutureResult(value = ...future.value$value, 
[08:28:14.889]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.889]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.889]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.889]                     ...future.globalenv.names))
[08:28:14.889]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.889]         }, condition = base::local({
[08:28:14.889]             c <- base::c
[08:28:14.889]             inherits <- base::inherits
[08:28:14.889]             invokeRestart <- base::invokeRestart
[08:28:14.889]             length <- base::length
[08:28:14.889]             list <- base::list
[08:28:14.889]             seq.int <- base::seq.int
[08:28:14.889]             signalCondition <- base::signalCondition
[08:28:14.889]             sys.calls <- base::sys.calls
[08:28:14.889]             `[[` <- base::`[[`
[08:28:14.889]             `+` <- base::`+`
[08:28:14.889]             `<<-` <- base::`<<-`
[08:28:14.889]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.889]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.889]                   3L)]
[08:28:14.889]             }
[08:28:14.889]             function(cond) {
[08:28:14.889]                 is_error <- inherits(cond, "error")
[08:28:14.889]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.889]                   NULL)
[08:28:14.889]                 if (is_error) {
[08:28:14.889]                   sessionInformation <- function() {
[08:28:14.889]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.889]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.889]                       search = base::search(), system = base::Sys.info())
[08:28:14.889]                   }
[08:28:14.889]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.889]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.889]                     cond$call), session = sessionInformation(), 
[08:28:14.889]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.889]                   signalCondition(cond)
[08:28:14.889]                 }
[08:28:14.889]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.889]                 "immediateCondition"))) {
[08:28:14.889]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.889]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.889]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.889]                   if (TRUE && !signal) {
[08:28:14.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.889]                     {
[08:28:14.889]                       inherits <- base::inherits
[08:28:14.889]                       invokeRestart <- base::invokeRestart
[08:28:14.889]                       is.null <- base::is.null
[08:28:14.889]                       muffled <- FALSE
[08:28:14.889]                       if (inherits(cond, "message")) {
[08:28:14.889]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.889]                         if (muffled) 
[08:28:14.889]                           invokeRestart("muffleMessage")
[08:28:14.889]                       }
[08:28:14.889]                       else if (inherits(cond, "warning")) {
[08:28:14.889]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.889]                         if (muffled) 
[08:28:14.889]                           invokeRestart("muffleWarning")
[08:28:14.889]                       }
[08:28:14.889]                       else if (inherits(cond, "condition")) {
[08:28:14.889]                         if (!is.null(pattern)) {
[08:28:14.889]                           computeRestarts <- base::computeRestarts
[08:28:14.889]                           grepl <- base::grepl
[08:28:14.889]                           restarts <- computeRestarts(cond)
[08:28:14.889]                           for (restart in restarts) {
[08:28:14.889]                             name <- restart$name
[08:28:14.889]                             if (is.null(name)) 
[08:28:14.889]                               next
[08:28:14.889]                             if (!grepl(pattern, name)) 
[08:28:14.889]                               next
[08:28:14.889]                             invokeRestart(restart)
[08:28:14.889]                             muffled <- TRUE
[08:28:14.889]                             break
[08:28:14.889]                           }
[08:28:14.889]                         }
[08:28:14.889]                       }
[08:28:14.889]                       invisible(muffled)
[08:28:14.889]                     }
[08:28:14.889]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.889]                   }
[08:28:14.889]                 }
[08:28:14.889]                 else {
[08:28:14.889]                   if (TRUE) {
[08:28:14.889]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.889]                     {
[08:28:14.889]                       inherits <- base::inherits
[08:28:14.889]                       invokeRestart <- base::invokeRestart
[08:28:14.889]                       is.null <- base::is.null
[08:28:14.889]                       muffled <- FALSE
[08:28:14.889]                       if (inherits(cond, "message")) {
[08:28:14.889]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.889]                         if (muffled) 
[08:28:14.889]                           invokeRestart("muffleMessage")
[08:28:14.889]                       }
[08:28:14.889]                       else if (inherits(cond, "warning")) {
[08:28:14.889]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.889]                         if (muffled) 
[08:28:14.889]                           invokeRestart("muffleWarning")
[08:28:14.889]                       }
[08:28:14.889]                       else if (inherits(cond, "condition")) {
[08:28:14.889]                         if (!is.null(pattern)) {
[08:28:14.889]                           computeRestarts <- base::computeRestarts
[08:28:14.889]                           grepl <- base::grepl
[08:28:14.889]                           restarts <- computeRestarts(cond)
[08:28:14.889]                           for (restart in restarts) {
[08:28:14.889]                             name <- restart$name
[08:28:14.889]                             if (is.null(name)) 
[08:28:14.889]                               next
[08:28:14.889]                             if (!grepl(pattern, name)) 
[08:28:14.889]                               next
[08:28:14.889]                             invokeRestart(restart)
[08:28:14.889]                             muffled <- TRUE
[08:28:14.889]                             break
[08:28:14.889]                           }
[08:28:14.889]                         }
[08:28:14.889]                       }
[08:28:14.889]                       invisible(muffled)
[08:28:14.889]                     }
[08:28:14.889]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.889]                   }
[08:28:14.889]                 }
[08:28:14.889]             }
[08:28:14.889]         }))
[08:28:14.889]     }, error = function(ex) {
[08:28:14.889]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.889]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.889]                 ...future.rng), started = ...future.startTime, 
[08:28:14.889]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.889]             version = "1.8"), class = "FutureResult")
[08:28:14.889]     }, finally = {
[08:28:14.889]         if (!identical(...future.workdir, getwd())) 
[08:28:14.889]             setwd(...future.workdir)
[08:28:14.889]         {
[08:28:14.889]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.889]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.889]             }
[08:28:14.889]             base::options(...future.oldOptions)
[08:28:14.889]             if (.Platform$OS.type == "windows") {
[08:28:14.889]                 old_names <- names(...future.oldEnvVars)
[08:28:14.889]                 envs <- base::Sys.getenv()
[08:28:14.889]                 names <- names(envs)
[08:28:14.889]                 common <- intersect(names, old_names)
[08:28:14.889]                 added <- setdiff(names, old_names)
[08:28:14.889]                 removed <- setdiff(old_names, names)
[08:28:14.889]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.889]                   envs[common]]
[08:28:14.889]                 NAMES <- toupper(changed)
[08:28:14.889]                 args <- list()
[08:28:14.889]                 for (kk in seq_along(NAMES)) {
[08:28:14.889]                   name <- changed[[kk]]
[08:28:14.889]                   NAME <- NAMES[[kk]]
[08:28:14.889]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.889]                     next
[08:28:14.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.889]                 }
[08:28:14.889]                 NAMES <- toupper(added)
[08:28:14.889]                 for (kk in seq_along(NAMES)) {
[08:28:14.889]                   name <- added[[kk]]
[08:28:14.889]                   NAME <- NAMES[[kk]]
[08:28:14.889]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.889]                     next
[08:28:14.889]                   args[[name]] <- ""
[08:28:14.889]                 }
[08:28:14.889]                 NAMES <- toupper(removed)
[08:28:14.889]                 for (kk in seq_along(NAMES)) {
[08:28:14.889]                   name <- removed[[kk]]
[08:28:14.889]                   NAME <- NAMES[[kk]]
[08:28:14.889]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.889]                     next
[08:28:14.889]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.889]                 }
[08:28:14.889]                 if (length(args) > 0) 
[08:28:14.889]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.889]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.889]             }
[08:28:14.889]             else {
[08:28:14.889]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.889]             }
[08:28:14.889]             {
[08:28:14.889]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.889]                   0L) {
[08:28:14.889]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.889]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.889]                   base::options(opts)
[08:28:14.889]                 }
[08:28:14.889]                 {
[08:28:14.889]                   {
[08:28:14.889]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:14.889]                     NULL
[08:28:14.889]                   }
[08:28:14.889]                   options(future.plan = NULL)
[08:28:14.889]                   if (is.na(NA_character_)) 
[08:28:14.889]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.889]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.889]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.889]                     .init = FALSE)
[08:28:14.889]                 }
[08:28:14.889]             }
[08:28:14.889]         }
[08:28:14.889]     })
[08:28:14.889]     if (TRUE) {
[08:28:14.889]         base::sink(type = "output", split = FALSE)
[08:28:14.889]         if (TRUE) {
[08:28:14.889]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.889]         }
[08:28:14.889]         else {
[08:28:14.889]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.889]         }
[08:28:14.889]         base::close(...future.stdout)
[08:28:14.889]         ...future.stdout <- NULL
[08:28:14.889]     }
[08:28:14.889]     ...future.result$conditions <- ...future.conditions
[08:28:14.889]     ...future.result$finished <- base::Sys.time()
[08:28:14.889]     ...future.result
[08:28:14.889] }
[08:28:14.891] assign_globals() ...
[08:28:14.891] List of 1
[08:28:14.891]  $ ii: int 2
[08:28:14.891]  - attr(*, "where")=List of 1
[08:28:14.891]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.891]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.891]  - attr(*, "resolved")= logi TRUE
[08:28:14.891]  - attr(*, "total_size")= num 35
[08:28:14.891]  - attr(*, "already-done")= logi TRUE
[08:28:14.895] - copied ‘ii’ to environment
[08:28:14.895] assign_globals() ... done
[08:28:14.895] requestCore(): workers = 2
[08:28:14.897] MulticoreFuture started
[08:28:14.898] - Launch lazy future ... done
[08:28:14.898] run() for ‘MulticoreFuture’ ... done
[08:28:14.898] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.899] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.899] List of future strategies:
[08:28:14.899] 1. sequential:
[08:28:14.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.899]    - tweaked: FALSE
[08:28:14.899]    - call: NULL
[08:28:14.899] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.900] plan(): nbrOfWorkers() = 1
[08:28:14.902] plan(): Setting new future strategy stack:
[08:28:14.902] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.902] Searching for globals ... DONE
[08:28:14.902] List of future strategies:
[08:28:14.902] 1. multicore:
[08:28:14.902]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:14.902]    - tweaked: FALSE
[08:28:14.902]    - call: plan(strategy)
[08:28:14.902] Resolving globals: TRUE
[08:28:14.903] Resolving any globals that are futures ...
[08:28:14.903] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.903] Resolving any globals that are futures ... DONE
[08:28:14.904] Resolving futures part of globals (recursively) ...
[08:28:14.904] resolve() on list ...
[08:28:14.904]  recursive: 99
[08:28:14.905]  length: 1
[08:28:14.905]  elements: ‘ii’
[08:28:14.905]  length: 0 (resolved future 1)
[08:28:14.905] plan(): nbrOfWorkers() = 2
[08:28:14.905] resolve() on list ... DONE
[08:28:14.905] - globals: [1] ‘ii’
[08:28:14.905] Resolving futures part of globals (recursively) ... DONE
[08:28:14.906] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.906] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.906] - globals: [1] ‘ii’
[08:28:14.906] 
[08:28:14.907] getGlobalsAndPackages() ... DONE
[08:28:14.907] run() for ‘Future’ ...
[08:28:14.907] - state: ‘created’
[08:28:14.907] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:14.910] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:14.910] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:14.910]   - Field: ‘label’
[08:28:14.910]   - Field: ‘local’
[08:28:14.910]   - Field: ‘owner’
[08:28:14.911]   - Field: ‘envir’
[08:28:14.911]   - Field: ‘workers’
[08:28:14.911]   - Field: ‘packages’
[08:28:14.911]   - Field: ‘gc’
[08:28:14.911]   - Field: ‘job’
[08:28:14.911]   - Field: ‘conditions’
[08:28:14.911]   - Field: ‘expr’
[08:28:14.911]   - Field: ‘uuid’
[08:28:14.912]   - Field: ‘seed’
[08:28:14.912]   - Field: ‘version’
[08:28:14.912]   - Field: ‘result’
[08:28:14.912]   - Field: ‘asynchronous’
[08:28:14.912]   - Field: ‘calls’
[08:28:14.912]   - Field: ‘globals’
[08:28:14.912]   - Field: ‘stdout’
[08:28:14.913]   - Field: ‘earlySignal’
[08:28:14.913]   - Field: ‘lazy’
[08:28:14.913]   - Field: ‘state’
[08:28:14.913] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:14.913] - Launch lazy future ...
[08:28:14.913] Packages needed by the future expression (n = 0): <none>
[08:28:14.914] Packages needed by future strategies (n = 0): <none>
[08:28:14.914] {
[08:28:14.914]     {
[08:28:14.914]         {
[08:28:14.914]             ...future.startTime <- base::Sys.time()
[08:28:14.914]             {
[08:28:14.914]                 {
[08:28:14.914]                   {
[08:28:14.914]                     {
[08:28:14.914]                       base::local({
[08:28:14.914]                         has_future <- base::requireNamespace("future", 
[08:28:14.914]                           quietly = TRUE)
[08:28:14.914]                         if (has_future) {
[08:28:14.914]                           ns <- base::getNamespace("future")
[08:28:14.914]                           version <- ns[[".package"]][["version"]]
[08:28:14.914]                           if (is.null(version)) 
[08:28:14.914]                             version <- utils::packageVersion("future")
[08:28:14.914]                         }
[08:28:14.914]                         else {
[08:28:14.914]                           version <- NULL
[08:28:14.914]                         }
[08:28:14.914]                         if (!has_future || version < "1.8.0") {
[08:28:14.914]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.914]                             "", base::R.version$version.string), 
[08:28:14.914]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.914]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.914]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.914]                               "release", "version")], collapse = " "), 
[08:28:14.914]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.914]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.914]                             info)
[08:28:14.914]                           info <- base::paste(info, collapse = "; ")
[08:28:14.914]                           if (!has_future) {
[08:28:14.914]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.914]                               info)
[08:28:14.914]                           }
[08:28:14.914]                           else {
[08:28:14.914]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.914]                               info, version)
[08:28:14.914]                           }
[08:28:14.914]                           base::stop(msg)
[08:28:14.914]                         }
[08:28:14.914]                       })
[08:28:14.914]                     }
[08:28:14.914]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:14.914]                     base::options(mc.cores = 1L)
[08:28:14.914]                   }
[08:28:14.914]                   ...future.strategy.old <- future::plan("list")
[08:28:14.914]                   options(future.plan = NULL)
[08:28:14.914]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.914]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.914]                 }
[08:28:14.914]                 ...future.workdir <- getwd()
[08:28:14.914]             }
[08:28:14.914]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.914]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.914]         }
[08:28:14.914]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.914]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.914]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.914]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.914]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.914]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.914]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.914]             base::names(...future.oldOptions))
[08:28:14.914]     }
[08:28:14.914]     if (FALSE) {
[08:28:14.914]     }
[08:28:14.914]     else {
[08:28:14.914]         if (TRUE) {
[08:28:14.914]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.914]                 open = "w")
[08:28:14.914]         }
[08:28:14.914]         else {
[08:28:14.914]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.914]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.914]         }
[08:28:14.914]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.914]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.914]             base::sink(type = "output", split = FALSE)
[08:28:14.914]             base::close(...future.stdout)
[08:28:14.914]         }, add = TRUE)
[08:28:14.914]     }
[08:28:14.914]     ...future.frame <- base::sys.nframe()
[08:28:14.914]     ...future.conditions <- base::list()
[08:28:14.914]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.914]     if (FALSE) {
[08:28:14.914]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.914]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.914]     }
[08:28:14.914]     ...future.result <- base::tryCatch({
[08:28:14.914]         base::withCallingHandlers({
[08:28:14.914]             ...future.value <- base::withVisible(base::local({
[08:28:14.914]                 withCallingHandlers({
[08:28:14.914]                   {
[08:28:14.914]                     b <- a * ii
[08:28:14.914]                     a <- 0
[08:28:14.914]                     b
[08:28:14.914]                   }
[08:28:14.914]                 }, immediateCondition = function(cond) {
[08:28:14.914]                   save_rds <- function (object, pathname, ...) 
[08:28:14.914]                   {
[08:28:14.914]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:14.914]                     if (file_test("-f", pathname_tmp)) {
[08:28:14.914]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.914]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:14.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.914]                         fi_tmp[["mtime"]])
[08:28:14.914]                     }
[08:28:14.914]                     tryCatch({
[08:28:14.914]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:14.914]                     }, error = function(ex) {
[08:28:14.914]                       msg <- conditionMessage(ex)
[08:28:14.914]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.914]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:14.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.914]                         fi_tmp[["mtime"]], msg)
[08:28:14.914]                       ex$message <- msg
[08:28:14.914]                       stop(ex)
[08:28:14.914]                     })
[08:28:14.914]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:14.914]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:14.914]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:14.914]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.914]                       fi <- file.info(pathname)
[08:28:14.914]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:14.914]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.914]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:14.914]                         fi[["size"]], fi[["mtime"]])
[08:28:14.914]                       stop(msg)
[08:28:14.914]                     }
[08:28:14.914]                     invisible(pathname)
[08:28:14.914]                   }
[08:28:14.914]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:14.914]                     rootPath = tempdir()) 
[08:28:14.914]                   {
[08:28:14.914]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:14.914]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:14.914]                       tmpdir = path, fileext = ".rds")
[08:28:14.914]                     save_rds(obj, file)
[08:28:14.914]                   }
[08:28:14.914]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:14.914]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.914]                   {
[08:28:14.914]                     inherits <- base::inherits
[08:28:14.914]                     invokeRestart <- base::invokeRestart
[08:28:14.914]                     is.null <- base::is.null
[08:28:14.914]                     muffled <- FALSE
[08:28:14.914]                     if (inherits(cond, "message")) {
[08:28:14.914]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:14.914]                       if (muffled) 
[08:28:14.914]                         invokeRestart("muffleMessage")
[08:28:14.914]                     }
[08:28:14.914]                     else if (inherits(cond, "warning")) {
[08:28:14.914]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:14.914]                       if (muffled) 
[08:28:14.914]                         invokeRestart("muffleWarning")
[08:28:14.914]                     }
[08:28:14.914]                     else if (inherits(cond, "condition")) {
[08:28:14.914]                       if (!is.null(pattern)) {
[08:28:14.914]                         computeRestarts <- base::computeRestarts
[08:28:14.914]                         grepl <- base::grepl
[08:28:14.914]                         restarts <- computeRestarts(cond)
[08:28:14.914]                         for (restart in restarts) {
[08:28:14.914]                           name <- restart$name
[08:28:14.914]                           if (is.null(name)) 
[08:28:14.914]                             next
[08:28:14.914]                           if (!grepl(pattern, name)) 
[08:28:14.914]                             next
[08:28:14.914]                           invokeRestart(restart)
[08:28:14.914]                           muffled <- TRUE
[08:28:14.914]                           break
[08:28:14.914]                         }
[08:28:14.914]                       }
[08:28:14.914]                     }
[08:28:14.914]                     invisible(muffled)
[08:28:14.914]                   }
[08:28:14.914]                   muffleCondition(cond)
[08:28:14.914]                 })
[08:28:14.914]             }))
[08:28:14.914]             future::FutureResult(value = ...future.value$value, 
[08:28:14.914]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.914]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.914]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.914]                     ...future.globalenv.names))
[08:28:14.914]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.914]         }, condition = base::local({
[08:28:14.914]             c <- base::c
[08:28:14.914]             inherits <- base::inherits
[08:28:14.914]             invokeRestart <- base::invokeRestart
[08:28:14.914]             length <- base::length
[08:28:14.914]             list <- base::list
[08:28:14.914]             seq.int <- base::seq.int
[08:28:14.914]             signalCondition <- base::signalCondition
[08:28:14.914]             sys.calls <- base::sys.calls
[08:28:14.914]             `[[` <- base::`[[`
[08:28:14.914]             `+` <- base::`+`
[08:28:14.914]             `<<-` <- base::`<<-`
[08:28:14.914]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.914]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.914]                   3L)]
[08:28:14.914]             }
[08:28:14.914]             function(cond) {
[08:28:14.914]                 is_error <- inherits(cond, "error")
[08:28:14.914]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.914]                   NULL)
[08:28:14.914]                 if (is_error) {
[08:28:14.914]                   sessionInformation <- function() {
[08:28:14.914]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.914]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.914]                       search = base::search(), system = base::Sys.info())
[08:28:14.914]                   }
[08:28:14.914]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.914]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.914]                     cond$call), session = sessionInformation(), 
[08:28:14.914]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.914]                   signalCondition(cond)
[08:28:14.914]                 }
[08:28:14.914]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.914]                 "immediateCondition"))) {
[08:28:14.914]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.914]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.914]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.914]                   if (TRUE && !signal) {
[08:28:14.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.914]                     {
[08:28:14.914]                       inherits <- base::inherits
[08:28:14.914]                       invokeRestart <- base::invokeRestart
[08:28:14.914]                       is.null <- base::is.null
[08:28:14.914]                       muffled <- FALSE
[08:28:14.914]                       if (inherits(cond, "message")) {
[08:28:14.914]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.914]                         if (muffled) 
[08:28:14.914]                           invokeRestart("muffleMessage")
[08:28:14.914]                       }
[08:28:14.914]                       else if (inherits(cond, "warning")) {
[08:28:14.914]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.914]                         if (muffled) 
[08:28:14.914]                           invokeRestart("muffleWarning")
[08:28:14.914]                       }
[08:28:14.914]                       else if (inherits(cond, "condition")) {
[08:28:14.914]                         if (!is.null(pattern)) {
[08:28:14.914]                           computeRestarts <- base::computeRestarts
[08:28:14.914]                           grepl <- base::grepl
[08:28:14.914]                           restarts <- computeRestarts(cond)
[08:28:14.914]                           for (restart in restarts) {
[08:28:14.914]                             name <- restart$name
[08:28:14.914]                             if (is.null(name)) 
[08:28:14.914]                               next
[08:28:14.914]                             if (!grepl(pattern, name)) 
[08:28:14.914]                               next
[08:28:14.914]                             invokeRestart(restart)
[08:28:14.914]                             muffled <- TRUE
[08:28:14.914]                             break
[08:28:14.914]                           }
[08:28:14.914]                         }
[08:28:14.914]                       }
[08:28:14.914]                       invisible(muffled)
[08:28:14.914]                     }
[08:28:14.914]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.914]                   }
[08:28:14.914]                 }
[08:28:14.914]                 else {
[08:28:14.914]                   if (TRUE) {
[08:28:14.914]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.914]                     {
[08:28:14.914]                       inherits <- base::inherits
[08:28:14.914]                       invokeRestart <- base::invokeRestart
[08:28:14.914]                       is.null <- base::is.null
[08:28:14.914]                       muffled <- FALSE
[08:28:14.914]                       if (inherits(cond, "message")) {
[08:28:14.914]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.914]                         if (muffled) 
[08:28:14.914]                           invokeRestart("muffleMessage")
[08:28:14.914]                       }
[08:28:14.914]                       else if (inherits(cond, "warning")) {
[08:28:14.914]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.914]                         if (muffled) 
[08:28:14.914]                           invokeRestart("muffleWarning")
[08:28:14.914]                       }
[08:28:14.914]                       else if (inherits(cond, "condition")) {
[08:28:14.914]                         if (!is.null(pattern)) {
[08:28:14.914]                           computeRestarts <- base::computeRestarts
[08:28:14.914]                           grepl <- base::grepl
[08:28:14.914]                           restarts <- computeRestarts(cond)
[08:28:14.914]                           for (restart in restarts) {
[08:28:14.914]                             name <- restart$name
[08:28:14.914]                             if (is.null(name)) 
[08:28:14.914]                               next
[08:28:14.914]                             if (!grepl(pattern, name)) 
[08:28:14.914]                               next
[08:28:14.914]                             invokeRestart(restart)
[08:28:14.914]                             muffled <- TRUE
[08:28:14.914]                             break
[08:28:14.914]                           }
[08:28:14.914]                         }
[08:28:14.914]                       }
[08:28:14.914]                       invisible(muffled)
[08:28:14.914]                     }
[08:28:14.914]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.914]                   }
[08:28:14.914]                 }
[08:28:14.914]             }
[08:28:14.914]         }))
[08:28:14.914]     }, error = function(ex) {
[08:28:14.914]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.914]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.914]                 ...future.rng), started = ...future.startTime, 
[08:28:14.914]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.914]             version = "1.8"), class = "FutureResult")
[08:28:14.914]     }, finally = {
[08:28:14.914]         if (!identical(...future.workdir, getwd())) 
[08:28:14.914]             setwd(...future.workdir)
[08:28:14.914]         {
[08:28:14.914]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.914]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.914]             }
[08:28:14.914]             base::options(...future.oldOptions)
[08:28:14.914]             if (.Platform$OS.type == "windows") {
[08:28:14.914]                 old_names <- names(...future.oldEnvVars)
[08:28:14.914]                 envs <- base::Sys.getenv()
[08:28:14.914]                 names <- names(envs)
[08:28:14.914]                 common <- intersect(names, old_names)
[08:28:14.914]                 added <- setdiff(names, old_names)
[08:28:14.914]                 removed <- setdiff(old_names, names)
[08:28:14.914]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.914]                   envs[common]]
[08:28:14.914]                 NAMES <- toupper(changed)
[08:28:14.914]                 args <- list()
[08:28:14.914]                 for (kk in seq_along(NAMES)) {
[08:28:14.914]                   name <- changed[[kk]]
[08:28:14.914]                   NAME <- NAMES[[kk]]
[08:28:14.914]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.914]                     next
[08:28:14.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.914]                 }
[08:28:14.914]                 NAMES <- toupper(added)
[08:28:14.914]                 for (kk in seq_along(NAMES)) {
[08:28:14.914]                   name <- added[[kk]]
[08:28:14.914]                   NAME <- NAMES[[kk]]
[08:28:14.914]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.914]                     next
[08:28:14.914]                   args[[name]] <- ""
[08:28:14.914]                 }
[08:28:14.914]                 NAMES <- toupper(removed)
[08:28:14.914]                 for (kk in seq_along(NAMES)) {
[08:28:14.914]                   name <- removed[[kk]]
[08:28:14.914]                   NAME <- NAMES[[kk]]
[08:28:14.914]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.914]                     next
[08:28:14.914]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.914]                 }
[08:28:14.914]                 if (length(args) > 0) 
[08:28:14.914]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.914]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.914]             }
[08:28:14.914]             else {
[08:28:14.914]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.914]             }
[08:28:14.914]             {
[08:28:14.914]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.914]                   0L) {
[08:28:14.914]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.914]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.914]                   base::options(opts)
[08:28:14.914]                 }
[08:28:14.914]                 {
[08:28:14.914]                   {
[08:28:14.914]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:14.914]                     NULL
[08:28:14.914]                   }
[08:28:14.914]                   options(future.plan = NULL)
[08:28:14.914]                   if (is.na(NA_character_)) 
[08:28:14.914]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.914]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.914]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.914]                     .init = FALSE)
[08:28:14.914]                 }
[08:28:14.914]             }
[08:28:14.914]         }
[08:28:14.914]     })
[08:28:14.914]     if (TRUE) {
[08:28:14.914]         base::sink(type = "output", split = FALSE)
[08:28:14.914]         if (TRUE) {
[08:28:14.914]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.914]         }
[08:28:14.914]         else {
[08:28:14.914]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.914]         }
[08:28:14.914]         base::close(...future.stdout)
[08:28:14.914]         ...future.stdout <- NULL
[08:28:14.914]     }
[08:28:14.914]     ...future.result$conditions <- ...future.conditions
[08:28:14.914]     ...future.result$finished <- base::Sys.time()
[08:28:14.914]     ...future.result
[08:28:14.914] }
[08:28:14.918] assign_globals() ...
[08:28:14.918] List of 1
[08:28:14.918]  $ ii: int 3
[08:28:14.918]  - attr(*, "where")=List of 1
[08:28:14.918]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.918]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.918]  - attr(*, "resolved")= logi TRUE
[08:28:14.918]  - attr(*, "total_size")= num 35
[08:28:14.918]  - attr(*, "already-done")= logi TRUE
[08:28:14.925] - copied ‘ii’ to environment
[08:28:14.925] assign_globals() ... done
[08:28:14.925] requestCore(): workers = 2
[08:28:14.926] Poll #1 (0): usedCores() = 2, workers = 2
[08:28:14.937] result() for MulticoreFuture ...
[08:28:14.938] result() for MulticoreFuture ...
[08:28:14.938] result() for MulticoreFuture ... done
[08:28:14.938] result() for MulticoreFuture ... done
[08:28:14.938] result() for MulticoreFuture ...
[08:28:14.939] result() for MulticoreFuture ... done
[08:28:14.941] MulticoreFuture started
[08:28:14.942] - Launch lazy future ... done
[08:28:14.942] run() for ‘MulticoreFuture’ ... done
[08:28:14.943] plan(): Setting new future strategy stack:
[08:28:14.943] result() for MulticoreFuture ...
[08:28:14.944] result() for MulticoreFuture ... done
[08:28:14.944] result() for MulticoreFuture ...
[08:28:14.943] List of future strategies:
[08:28:14.943] 1. sequential:
[08:28:14.943]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.943]    - tweaked: FALSE
[08:28:14.943]    - call: NULL
[08:28:14.944] result() for MulticoreFuture ... done
[08:28:14.945] plan(): nbrOfWorkers() = 1
[08:28:14.945] result() for MulticoreFuture ...
[08:28:14.946] result() for MulticoreFuture ...
[08:28:14.947] result() for MulticoreFuture ... done
[08:28:14.947] result() for MulticoreFuture ... done
[08:28:14.947] result() for MulticoreFuture ...
[08:28:14.948] result() for MulticoreFuture ... done
[08:28:14.948] plan(): Setting new future strategy stack:
[08:28:14.948] result() for MulticoreFuture ...
[08:28:14.948] List of future strategies:
[08:28:14.948] 1. multicore:
[08:28:14.948]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:14.948]    - tweaked: FALSE
[08:28:14.948]    - call: plan(strategy)
[08:28:14.951] plan(): nbrOfWorkers() = 2
[08:28:14.952] result() for MulticoreFuture ...
[08:28:14.952] result() for MulticoreFuture ... done
[08:28:14.952] result() for MulticoreFuture ... done
[08:28:14.952] result() for MulticoreFuture ...
[08:28:14.953] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.954] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.954] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.956] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.957] Searching for globals ... DONE
[08:28:14.957] Resolving globals: TRUE
[08:28:14.957] Resolving any globals that are futures ...
[08:28:14.957] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.957] Resolving any globals that are futures ... DONE
[08:28:14.957] Resolving futures part of globals (recursively) ...
[08:28:14.958] resolve() on list ...
[08:28:14.958]  recursive: 99
[08:28:14.958]  length: 1
[08:28:14.958]  elements: ‘ii’
[08:28:14.958]  length: 0 (resolved future 1)
[08:28:14.958] resolve() on list ... DONE
[08:28:14.959] - globals: [1] ‘ii’
[08:28:14.959] Resolving futures part of globals (recursively) ... DONE
[08:28:14.959] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.959] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.959] - globals: [1] ‘ii’
[08:28:14.960] 
[08:28:14.960] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.960] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.961] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.962] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.962] Searching for globals ... DONE
[08:28:14.962] Resolving globals: TRUE
[08:28:14.963] Resolving any globals that are futures ...
[08:28:14.963] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.963] Resolving any globals that are futures ... DONE
[08:28:14.963] Resolving futures part of globals (recursively) ...
[08:28:14.963] resolve() on list ...
[08:28:14.964]  recursive: 99
[08:28:14.964]  length: 1
[08:28:14.964]  elements: ‘ii’
[08:28:14.964]  length: 0 (resolved future 1)
[08:28:14.964] resolve() on list ... DONE
[08:28:14.964] - globals: [1] ‘ii’
[08:28:14.964] Resolving futures part of globals (recursively) ... DONE
[08:28:14.964] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.965] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.965] - globals: [1] ‘ii’
[08:28:14.965] 
[08:28:14.965] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:14.966] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:14.966] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:14.967] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.968] Searching for globals ... DONE
[08:28:14.968] Resolving globals: TRUE
[08:28:14.968] Resolving any globals that are futures ...
[08:28:14.968] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:14.968] Resolving any globals that are futures ... DONE
[08:28:14.968] Resolving futures part of globals (recursively) ...
[08:28:14.969] resolve() on list ...
[08:28:14.969]  recursive: 99
[08:28:14.969]  length: 1
[08:28:14.969]  elements: ‘ii’
[08:28:14.969]  length: 0 (resolved future 1)
[08:28:14.969] resolve() on list ... DONE
[08:28:14.969] - globals: [1] ‘ii’
[08:28:14.969] Resolving futures part of globals (recursively) ... DONE
[08:28:14.970] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:14.970] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:14.970] - globals: [1] ‘ii’
[08:28:14.970] 
[08:28:14.970] getGlobalsAndPackages() ... DONE
[08:28:14.971] run() for ‘Future’ ...
[08:28:14.971] - state: ‘created’
[08:28:14.971] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:14.975] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:14.975] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:14.975]   - Field: ‘label’
[08:28:14.975]   - Field: ‘local’
[08:28:14.975]   - Field: ‘owner’
[08:28:14.975]   - Field: ‘envir’
[08:28:14.976]   - Field: ‘workers’
[08:28:14.976]   - Field: ‘packages’
[08:28:14.976]   - Field: ‘gc’
[08:28:14.976]   - Field: ‘job’
[08:28:14.976]   - Field: ‘conditions’
[08:28:14.976]   - Field: ‘expr’
[08:28:14.976]   - Field: ‘uuid’
[08:28:14.976]   - Field: ‘seed’
[08:28:14.976]   - Field: ‘version’
[08:28:14.977]   - Field: ‘result’
[08:28:14.977]   - Field: ‘asynchronous’
[08:28:14.977]   - Field: ‘calls’
[08:28:14.977]   - Field: ‘globals’
[08:28:14.977]   - Field: ‘stdout’
[08:28:14.977]   - Field: ‘earlySignal’
[08:28:14.977]   - Field: ‘lazy’
[08:28:14.977]   - Field: ‘state’
[08:28:14.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:14.977] - Launch lazy future ...
[08:28:14.978] Packages needed by the future expression (n = 0): <none>
[08:28:14.978] Packages needed by future strategies (n = 0): <none>
[08:28:14.978] {
[08:28:14.978]     {
[08:28:14.978]         {
[08:28:14.978]             ...future.startTime <- base::Sys.time()
[08:28:14.978]             {
[08:28:14.978]                 {
[08:28:14.978]                   {
[08:28:14.978]                     {
[08:28:14.978]                       base::local({
[08:28:14.978]                         has_future <- base::requireNamespace("future", 
[08:28:14.978]                           quietly = TRUE)
[08:28:14.978]                         if (has_future) {
[08:28:14.978]                           ns <- base::getNamespace("future")
[08:28:14.978]                           version <- ns[[".package"]][["version"]]
[08:28:14.978]                           if (is.null(version)) 
[08:28:14.978]                             version <- utils::packageVersion("future")
[08:28:14.978]                         }
[08:28:14.978]                         else {
[08:28:14.978]                           version <- NULL
[08:28:14.978]                         }
[08:28:14.978]                         if (!has_future || version < "1.8.0") {
[08:28:14.978]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:14.978]                             "", base::R.version$version.string), 
[08:28:14.978]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:14.978]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:14.978]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:14.978]                               "release", "version")], collapse = " "), 
[08:28:14.978]                             hostname = base::Sys.info()[["nodename"]])
[08:28:14.978]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:14.978]                             info)
[08:28:14.978]                           info <- base::paste(info, collapse = "; ")
[08:28:14.978]                           if (!has_future) {
[08:28:14.978]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:14.978]                               info)
[08:28:14.978]                           }
[08:28:14.978]                           else {
[08:28:14.978]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:14.978]                               info, version)
[08:28:14.978]                           }
[08:28:14.978]                           base::stop(msg)
[08:28:14.978]                         }
[08:28:14.978]                       })
[08:28:14.978]                     }
[08:28:14.978]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:14.978]                     base::options(mc.cores = 1L)
[08:28:14.978]                   }
[08:28:14.978]                   ...future.strategy.old <- future::plan("list")
[08:28:14.978]                   options(future.plan = NULL)
[08:28:14.978]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.978]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:14.978]                 }
[08:28:14.978]                 ...future.workdir <- getwd()
[08:28:14.978]             }
[08:28:14.978]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:14.978]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:14.978]         }
[08:28:14.978]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:14.978]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:14.978]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:14.978]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:14.978]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:14.978]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:14.978]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:14.978]             base::names(...future.oldOptions))
[08:28:14.978]     }
[08:28:14.978]     if (FALSE) {
[08:28:14.978]     }
[08:28:14.978]     else {
[08:28:14.978]         if (TRUE) {
[08:28:14.978]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:14.978]                 open = "w")
[08:28:14.978]         }
[08:28:14.978]         else {
[08:28:14.978]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:14.978]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:14.978]         }
[08:28:14.978]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:14.978]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:14.978]             base::sink(type = "output", split = FALSE)
[08:28:14.978]             base::close(...future.stdout)
[08:28:14.978]         }, add = TRUE)
[08:28:14.978]     }
[08:28:14.978]     ...future.frame <- base::sys.nframe()
[08:28:14.978]     ...future.conditions <- base::list()
[08:28:14.978]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:14.978]     if (FALSE) {
[08:28:14.978]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:14.978]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:14.978]     }
[08:28:14.978]     ...future.result <- base::tryCatch({
[08:28:14.978]         base::withCallingHandlers({
[08:28:14.978]             ...future.value <- base::withVisible(base::local({
[08:28:14.978]                 withCallingHandlers({
[08:28:14.978]                   {
[08:28:14.978]                     b <- a * ii
[08:28:14.978]                     a <- 0
[08:28:14.978]                     b
[08:28:14.978]                   }
[08:28:14.978]                 }, immediateCondition = function(cond) {
[08:28:14.978]                   save_rds <- function (object, pathname, ...) 
[08:28:14.978]                   {
[08:28:14.978]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:14.978]                     if (file_test("-f", pathname_tmp)) {
[08:28:14.978]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.978]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:14.978]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.978]                         fi_tmp[["mtime"]])
[08:28:14.978]                     }
[08:28:14.978]                     tryCatch({
[08:28:14.978]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:14.978]                     }, error = function(ex) {
[08:28:14.978]                       msg <- conditionMessage(ex)
[08:28:14.978]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.978]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:14.978]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.978]                         fi_tmp[["mtime"]], msg)
[08:28:14.978]                       ex$message <- msg
[08:28:14.978]                       stop(ex)
[08:28:14.978]                     })
[08:28:14.978]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:14.978]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:14.978]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:14.978]                       fi_tmp <- file.info(pathname_tmp)
[08:28:14.978]                       fi <- file.info(pathname)
[08:28:14.978]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:14.978]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:14.978]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:14.978]                         fi[["size"]], fi[["mtime"]])
[08:28:14.978]                       stop(msg)
[08:28:14.978]                     }
[08:28:14.978]                     invisible(pathname)
[08:28:14.978]                   }
[08:28:14.978]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:14.978]                     rootPath = tempdir()) 
[08:28:14.978]                   {
[08:28:14.978]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:14.978]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:14.978]                       tmpdir = path, fileext = ".rds")
[08:28:14.978]                     save_rds(obj, file)
[08:28:14.978]                   }
[08:28:14.978]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:14.978]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.978]                   {
[08:28:14.978]                     inherits <- base::inherits
[08:28:14.978]                     invokeRestart <- base::invokeRestart
[08:28:14.978]                     is.null <- base::is.null
[08:28:14.978]                     muffled <- FALSE
[08:28:14.978]                     if (inherits(cond, "message")) {
[08:28:14.978]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:14.978]                       if (muffled) 
[08:28:14.978]                         invokeRestart("muffleMessage")
[08:28:14.978]                     }
[08:28:14.978]                     else if (inherits(cond, "warning")) {
[08:28:14.978]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:14.978]                       if (muffled) 
[08:28:14.978]                         invokeRestart("muffleWarning")
[08:28:14.978]                     }
[08:28:14.978]                     else if (inherits(cond, "condition")) {
[08:28:14.978]                       if (!is.null(pattern)) {
[08:28:14.978]                         computeRestarts <- base::computeRestarts
[08:28:14.978]                         grepl <- base::grepl
[08:28:14.978]                         restarts <- computeRestarts(cond)
[08:28:14.978]                         for (restart in restarts) {
[08:28:14.978]                           name <- restart$name
[08:28:14.978]                           if (is.null(name)) 
[08:28:14.978]                             next
[08:28:14.978]                           if (!grepl(pattern, name)) 
[08:28:14.978]                             next
[08:28:14.978]                           invokeRestart(restart)
[08:28:14.978]                           muffled <- TRUE
[08:28:14.978]                           break
[08:28:14.978]                         }
[08:28:14.978]                       }
[08:28:14.978]                     }
[08:28:14.978]                     invisible(muffled)
[08:28:14.978]                   }
[08:28:14.978]                   muffleCondition(cond)
[08:28:14.978]                 })
[08:28:14.978]             }))
[08:28:14.978]             future::FutureResult(value = ...future.value$value, 
[08:28:14.978]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.978]                   ...future.rng), globalenv = if (FALSE) 
[08:28:14.978]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:14.978]                     ...future.globalenv.names))
[08:28:14.978]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:14.978]         }, condition = base::local({
[08:28:14.978]             c <- base::c
[08:28:14.978]             inherits <- base::inherits
[08:28:14.978]             invokeRestart <- base::invokeRestart
[08:28:14.978]             length <- base::length
[08:28:14.978]             list <- base::list
[08:28:14.978]             seq.int <- base::seq.int
[08:28:14.978]             signalCondition <- base::signalCondition
[08:28:14.978]             sys.calls <- base::sys.calls
[08:28:14.978]             `[[` <- base::`[[`
[08:28:14.978]             `+` <- base::`+`
[08:28:14.978]             `<<-` <- base::`<<-`
[08:28:14.978]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:14.978]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:14.978]                   3L)]
[08:28:14.978]             }
[08:28:14.978]             function(cond) {
[08:28:14.978]                 is_error <- inherits(cond, "error")
[08:28:14.978]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:14.978]                   NULL)
[08:28:14.978]                 if (is_error) {
[08:28:14.978]                   sessionInformation <- function() {
[08:28:14.978]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:14.978]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:14.978]                       search = base::search(), system = base::Sys.info())
[08:28:14.978]                   }
[08:28:14.978]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.978]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:14.978]                     cond$call), session = sessionInformation(), 
[08:28:14.978]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:14.978]                   signalCondition(cond)
[08:28:14.978]                 }
[08:28:14.978]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:14.978]                 "immediateCondition"))) {
[08:28:14.978]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:14.978]                   ...future.conditions[[length(...future.conditions) + 
[08:28:14.978]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:14.978]                   if (TRUE && !signal) {
[08:28:14.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.978]                     {
[08:28:14.978]                       inherits <- base::inherits
[08:28:14.978]                       invokeRestart <- base::invokeRestart
[08:28:14.978]                       is.null <- base::is.null
[08:28:14.978]                       muffled <- FALSE
[08:28:14.978]                       if (inherits(cond, "message")) {
[08:28:14.978]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.978]                         if (muffled) 
[08:28:14.978]                           invokeRestart("muffleMessage")
[08:28:14.978]                       }
[08:28:14.978]                       else if (inherits(cond, "warning")) {
[08:28:14.978]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.978]                         if (muffled) 
[08:28:14.978]                           invokeRestart("muffleWarning")
[08:28:14.978]                       }
[08:28:14.978]                       else if (inherits(cond, "condition")) {
[08:28:14.978]                         if (!is.null(pattern)) {
[08:28:14.978]                           computeRestarts <- base::computeRestarts
[08:28:14.978]                           grepl <- base::grepl
[08:28:14.978]                           restarts <- computeRestarts(cond)
[08:28:14.978]                           for (restart in restarts) {
[08:28:14.978]                             name <- restart$name
[08:28:14.978]                             if (is.null(name)) 
[08:28:14.978]                               next
[08:28:14.978]                             if (!grepl(pattern, name)) 
[08:28:14.978]                               next
[08:28:14.978]                             invokeRestart(restart)
[08:28:14.978]                             muffled <- TRUE
[08:28:14.978]                             break
[08:28:14.978]                           }
[08:28:14.978]                         }
[08:28:14.978]                       }
[08:28:14.978]                       invisible(muffled)
[08:28:14.978]                     }
[08:28:14.978]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.978]                   }
[08:28:14.978]                 }
[08:28:14.978]                 else {
[08:28:14.978]                   if (TRUE) {
[08:28:14.978]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:14.978]                     {
[08:28:14.978]                       inherits <- base::inherits
[08:28:14.978]                       invokeRestart <- base::invokeRestart
[08:28:14.978]                       is.null <- base::is.null
[08:28:14.978]                       muffled <- FALSE
[08:28:14.978]                       if (inherits(cond, "message")) {
[08:28:14.978]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:14.978]                         if (muffled) 
[08:28:14.978]                           invokeRestart("muffleMessage")
[08:28:14.978]                       }
[08:28:14.978]                       else if (inherits(cond, "warning")) {
[08:28:14.978]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:14.978]                         if (muffled) 
[08:28:14.978]                           invokeRestart("muffleWarning")
[08:28:14.978]                       }
[08:28:14.978]                       else if (inherits(cond, "condition")) {
[08:28:14.978]                         if (!is.null(pattern)) {
[08:28:14.978]                           computeRestarts <- base::computeRestarts
[08:28:14.978]                           grepl <- base::grepl
[08:28:14.978]                           restarts <- computeRestarts(cond)
[08:28:14.978]                           for (restart in restarts) {
[08:28:14.978]                             name <- restart$name
[08:28:14.978]                             if (is.null(name)) 
[08:28:14.978]                               next
[08:28:14.978]                             if (!grepl(pattern, name)) 
[08:28:14.978]                               next
[08:28:14.978]                             invokeRestart(restart)
[08:28:14.978]                             muffled <- TRUE
[08:28:14.978]                             break
[08:28:14.978]                           }
[08:28:14.978]                         }
[08:28:14.978]                       }
[08:28:14.978]                       invisible(muffled)
[08:28:14.978]                     }
[08:28:14.978]                     muffleCondition(cond, pattern = "^muffle")
[08:28:14.978]                   }
[08:28:14.978]                 }
[08:28:14.978]             }
[08:28:14.978]         }))
[08:28:14.978]     }, error = function(ex) {
[08:28:14.978]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:14.978]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:14.978]                 ...future.rng), started = ...future.startTime, 
[08:28:14.978]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:14.978]             version = "1.8"), class = "FutureResult")
[08:28:14.978]     }, finally = {
[08:28:14.978]         if (!identical(...future.workdir, getwd())) 
[08:28:14.978]             setwd(...future.workdir)
[08:28:14.978]         {
[08:28:14.978]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:14.978]                 ...future.oldOptions$nwarnings <- NULL
[08:28:14.978]             }
[08:28:14.978]             base::options(...future.oldOptions)
[08:28:14.978]             if (.Platform$OS.type == "windows") {
[08:28:14.978]                 old_names <- names(...future.oldEnvVars)
[08:28:14.978]                 envs <- base::Sys.getenv()
[08:28:14.978]                 names <- names(envs)
[08:28:14.978]                 common <- intersect(names, old_names)
[08:28:14.978]                 added <- setdiff(names, old_names)
[08:28:14.978]                 removed <- setdiff(old_names, names)
[08:28:14.978]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:14.978]                   envs[common]]
[08:28:14.978]                 NAMES <- toupper(changed)
[08:28:14.978]                 args <- list()
[08:28:14.978]                 for (kk in seq_along(NAMES)) {
[08:28:14.978]                   name <- changed[[kk]]
[08:28:14.978]                   NAME <- NAMES[[kk]]
[08:28:14.978]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.978]                     next
[08:28:14.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.978]                 }
[08:28:14.978]                 NAMES <- toupper(added)
[08:28:14.978]                 for (kk in seq_along(NAMES)) {
[08:28:14.978]                   name <- added[[kk]]
[08:28:14.978]                   NAME <- NAMES[[kk]]
[08:28:14.978]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.978]                     next
[08:28:14.978]                   args[[name]] <- ""
[08:28:14.978]                 }
[08:28:14.978]                 NAMES <- toupper(removed)
[08:28:14.978]                 for (kk in seq_along(NAMES)) {
[08:28:14.978]                   name <- removed[[kk]]
[08:28:14.978]                   NAME <- NAMES[[kk]]
[08:28:14.978]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:14.978]                     next
[08:28:14.978]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:14.978]                 }
[08:28:14.978]                 if (length(args) > 0) 
[08:28:14.978]                   base::do.call(base::Sys.setenv, args = args)
[08:28:14.978]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:14.978]             }
[08:28:14.978]             else {
[08:28:14.978]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:14.978]             }
[08:28:14.978]             {
[08:28:14.978]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:14.978]                   0L) {
[08:28:14.978]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:14.978]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:14.978]                   base::options(opts)
[08:28:14.978]                 }
[08:28:14.978]                 {
[08:28:14.978]                   {
[08:28:14.978]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:14.978]                     NULL
[08:28:14.978]                   }
[08:28:14.978]                   options(future.plan = NULL)
[08:28:14.978]                   if (is.na(NA_character_)) 
[08:28:14.978]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:14.978]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:14.978]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:14.978]                     .init = FALSE)
[08:28:14.978]                 }
[08:28:14.978]             }
[08:28:14.978]         }
[08:28:14.978]     })
[08:28:14.978]     if (TRUE) {
[08:28:14.978]         base::sink(type = "output", split = FALSE)
[08:28:14.978]         if (TRUE) {
[08:28:14.978]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:14.978]         }
[08:28:14.978]         else {
[08:28:14.978]             ...future.result["stdout"] <- base::list(NULL)
[08:28:14.978]         }
[08:28:14.978]         base::close(...future.stdout)
[08:28:14.978]         ...future.stdout <- NULL
[08:28:14.978]     }
[08:28:14.978]     ...future.result$conditions <- ...future.conditions
[08:28:14.978]     ...future.result$finished <- base::Sys.time()
[08:28:14.978]     ...future.result
[08:28:14.978] }
[08:28:14.981] assign_globals() ...
[08:28:14.981] List of 1
[08:28:14.981]  $ ii: int 1
[08:28:14.981]  - attr(*, "where")=List of 1
[08:28:14.981]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:14.981]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:14.981]  - attr(*, "resolved")= logi TRUE
[08:28:14.981]  - attr(*, "total_size")= num 35
[08:28:14.981]  - attr(*, "already-done")= logi TRUE
[08:28:14.983] - copied ‘ii’ to environment
[08:28:14.983] assign_globals() ... done
[08:28:14.983] requestCore(): workers = 2
[08:28:14.985] MulticoreFuture started
[08:28:14.986] - Launch lazy future ... done
[08:28:14.986] run() for ‘MulticoreFuture’ ... done
[08:28:14.986] result() for MulticoreFuture ...
[08:28:14.986] plan(): Setting new future strategy stack:
[08:28:14.986] List of future strategies:
[08:28:14.986] 1. sequential:
[08:28:14.986]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:14.986]    - tweaked: FALSE
[08:28:14.986]    - call: NULL
[08:28:14.987] plan(): nbrOfWorkers() = 1
[08:28:14.989] plan(): Setting new future strategy stack:
[08:28:14.990] List of future strategies:
[08:28:14.990] 1. multicore:
[08:28:14.990]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:14.990]    - tweaked: FALSE
[08:28:14.990]    - call: plan(strategy)
[08:28:14.993] plan(): nbrOfWorkers() = 2
[08:28:14.999] result() for MulticoreFuture ...
[08:28:14.999] result() for MulticoreFuture ... done
[08:28:14.999] signalConditions() ...
[08:28:14.999]  - include = ‘immediateCondition’
[08:28:14.999]  - exclude = 
[08:28:14.999]  - resignal = FALSE
[08:28:14.999]  - Number of conditions: 1
[08:28:14.999] signalConditions() ... done
[08:28:15.000] result() for MulticoreFuture ... done
[08:28:15.000] result() for MulticoreFuture ...
[08:28:15.000] result() for MulticoreFuture ... done
[08:28:15.000] signalConditions() ...
[08:28:15.000]  - include = ‘immediateCondition’
[08:28:15.000]  - exclude = 
[08:28:15.000]  - resignal = FALSE
[08:28:15.000]  - Number of conditions: 1
[08:28:15.001] signalConditions() ... done
[08:28:15.001] Future state: ‘finished’
[08:28:15.001] result() for MulticoreFuture ...
[08:28:15.001] result() for MulticoreFuture ... done
[08:28:15.001] signalConditions() ...
[08:28:15.001]  - include = ‘condition’
[08:28:15.001]  - exclude = ‘immediateCondition’
[08:28:15.001]  - resignal = TRUE
[08:28:15.001]  - Number of conditions: 1
[08:28:15.002]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:15.002] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:14"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.029] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.029] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.030] 
[08:28:15.030] Searching for globals ... DONE
[08:28:15.030] - globals: [0] <none>
[08:28:15.030] getGlobalsAndPackages() ... DONE
[08:28:15.031] run() for ‘Future’ ...
[08:28:15.031] - state: ‘created’
[08:28:15.031] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.034] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.034] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.034]   - Field: ‘label’
[08:28:15.034]   - Field: ‘local’
[08:28:15.034]   - Field: ‘owner’
[08:28:15.034]   - Field: ‘envir’
[08:28:15.034]   - Field: ‘workers’
[08:28:15.034]   - Field: ‘packages’
[08:28:15.034]   - Field: ‘gc’
[08:28:15.034]   - Field: ‘job’
[08:28:15.034]   - Field: ‘conditions’
[08:28:15.035]   - Field: ‘expr’
[08:28:15.035]   - Field: ‘uuid’
[08:28:15.035]   - Field: ‘seed’
[08:28:15.035]   - Field: ‘version’
[08:28:15.035]   - Field: ‘result’
[08:28:15.035]   - Field: ‘asynchronous’
[08:28:15.035]   - Field: ‘calls’
[08:28:15.035]   - Field: ‘globals’
[08:28:15.035]   - Field: ‘stdout’
[08:28:15.035]   - Field: ‘earlySignal’
[08:28:15.035]   - Field: ‘lazy’
[08:28:15.035]   - Field: ‘state’
[08:28:15.036] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.036] - Launch lazy future ...
[08:28:15.036] Packages needed by the future expression (n = 0): <none>
[08:28:15.036] Packages needed by future strategies (n = 0): <none>
[08:28:15.036] {
[08:28:15.036]     {
[08:28:15.036]         {
[08:28:15.036]             ...future.startTime <- base::Sys.time()
[08:28:15.036]             {
[08:28:15.036]                 {
[08:28:15.036]                   {
[08:28:15.036]                     {
[08:28:15.036]                       base::local({
[08:28:15.036]                         has_future <- base::requireNamespace("future", 
[08:28:15.036]                           quietly = TRUE)
[08:28:15.036]                         if (has_future) {
[08:28:15.036]                           ns <- base::getNamespace("future")
[08:28:15.036]                           version <- ns[[".package"]][["version"]]
[08:28:15.036]                           if (is.null(version)) 
[08:28:15.036]                             version <- utils::packageVersion("future")
[08:28:15.036]                         }
[08:28:15.036]                         else {
[08:28:15.036]                           version <- NULL
[08:28:15.036]                         }
[08:28:15.036]                         if (!has_future || version < "1.8.0") {
[08:28:15.036]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.036]                             "", base::R.version$version.string), 
[08:28:15.036]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.036]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.036]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.036]                               "release", "version")], collapse = " "), 
[08:28:15.036]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.036]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.036]                             info)
[08:28:15.036]                           info <- base::paste(info, collapse = "; ")
[08:28:15.036]                           if (!has_future) {
[08:28:15.036]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.036]                               info)
[08:28:15.036]                           }
[08:28:15.036]                           else {
[08:28:15.036]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.036]                               info, version)
[08:28:15.036]                           }
[08:28:15.036]                           base::stop(msg)
[08:28:15.036]                         }
[08:28:15.036]                       })
[08:28:15.036]                     }
[08:28:15.036]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.036]                     base::options(mc.cores = 1L)
[08:28:15.036]                   }
[08:28:15.036]                   ...future.strategy.old <- future::plan("list")
[08:28:15.036]                   options(future.plan = NULL)
[08:28:15.036]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.036]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.036]                 }
[08:28:15.036]                 ...future.workdir <- getwd()
[08:28:15.036]             }
[08:28:15.036]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.036]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.036]         }
[08:28:15.036]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.036]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.036]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.036]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.036]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.036]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.036]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.036]             base::names(...future.oldOptions))
[08:28:15.036]     }
[08:28:15.036]     if (FALSE) {
[08:28:15.036]     }
[08:28:15.036]     else {
[08:28:15.036]         if (TRUE) {
[08:28:15.036]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.036]                 open = "w")
[08:28:15.036]         }
[08:28:15.036]         else {
[08:28:15.036]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.036]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.036]         }
[08:28:15.036]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.036]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.036]             base::sink(type = "output", split = FALSE)
[08:28:15.036]             base::close(...future.stdout)
[08:28:15.036]         }, add = TRUE)
[08:28:15.036]     }
[08:28:15.036]     ...future.frame <- base::sys.nframe()
[08:28:15.036]     ...future.conditions <- base::list()
[08:28:15.036]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.036]     if (FALSE) {
[08:28:15.036]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.036]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.036]     }
[08:28:15.036]     ...future.result <- base::tryCatch({
[08:28:15.036]         base::withCallingHandlers({
[08:28:15.036]             ...future.value <- base::withVisible(base::local({
[08:28:15.036]                 withCallingHandlers({
[08:28:15.036]                   1
[08:28:15.036]                 }, immediateCondition = function(cond) {
[08:28:15.036]                   save_rds <- function (object, pathname, ...) 
[08:28:15.036]                   {
[08:28:15.036]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.036]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.036]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.036]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.036]                         fi_tmp[["mtime"]])
[08:28:15.036]                     }
[08:28:15.036]                     tryCatch({
[08:28:15.036]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.036]                     }, error = function(ex) {
[08:28:15.036]                       msg <- conditionMessage(ex)
[08:28:15.036]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.036]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.036]                         fi_tmp[["mtime"]], msg)
[08:28:15.036]                       ex$message <- msg
[08:28:15.036]                       stop(ex)
[08:28:15.036]                     })
[08:28:15.036]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.036]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.036]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.036]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.036]                       fi <- file.info(pathname)
[08:28:15.036]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.036]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.036]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.036]                         fi[["size"]], fi[["mtime"]])
[08:28:15.036]                       stop(msg)
[08:28:15.036]                     }
[08:28:15.036]                     invisible(pathname)
[08:28:15.036]                   }
[08:28:15.036]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.036]                     rootPath = tempdir()) 
[08:28:15.036]                   {
[08:28:15.036]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.036]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.036]                       tmpdir = path, fileext = ".rds")
[08:28:15.036]                     save_rds(obj, file)
[08:28:15.036]                   }
[08:28:15.036]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.036]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.036]                   {
[08:28:15.036]                     inherits <- base::inherits
[08:28:15.036]                     invokeRestart <- base::invokeRestart
[08:28:15.036]                     is.null <- base::is.null
[08:28:15.036]                     muffled <- FALSE
[08:28:15.036]                     if (inherits(cond, "message")) {
[08:28:15.036]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.036]                       if (muffled) 
[08:28:15.036]                         invokeRestart("muffleMessage")
[08:28:15.036]                     }
[08:28:15.036]                     else if (inherits(cond, "warning")) {
[08:28:15.036]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.036]                       if (muffled) 
[08:28:15.036]                         invokeRestart("muffleWarning")
[08:28:15.036]                     }
[08:28:15.036]                     else if (inherits(cond, "condition")) {
[08:28:15.036]                       if (!is.null(pattern)) {
[08:28:15.036]                         computeRestarts <- base::computeRestarts
[08:28:15.036]                         grepl <- base::grepl
[08:28:15.036]                         restarts <- computeRestarts(cond)
[08:28:15.036]                         for (restart in restarts) {
[08:28:15.036]                           name <- restart$name
[08:28:15.036]                           if (is.null(name)) 
[08:28:15.036]                             next
[08:28:15.036]                           if (!grepl(pattern, name)) 
[08:28:15.036]                             next
[08:28:15.036]                           invokeRestart(restart)
[08:28:15.036]                           muffled <- TRUE
[08:28:15.036]                           break
[08:28:15.036]                         }
[08:28:15.036]                       }
[08:28:15.036]                     }
[08:28:15.036]                     invisible(muffled)
[08:28:15.036]                   }
[08:28:15.036]                   muffleCondition(cond)
[08:28:15.036]                 })
[08:28:15.036]             }))
[08:28:15.036]             future::FutureResult(value = ...future.value$value, 
[08:28:15.036]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.036]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.036]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.036]                     ...future.globalenv.names))
[08:28:15.036]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.036]         }, condition = base::local({
[08:28:15.036]             c <- base::c
[08:28:15.036]             inherits <- base::inherits
[08:28:15.036]             invokeRestart <- base::invokeRestart
[08:28:15.036]             length <- base::length
[08:28:15.036]             list <- base::list
[08:28:15.036]             seq.int <- base::seq.int
[08:28:15.036]             signalCondition <- base::signalCondition
[08:28:15.036]             sys.calls <- base::sys.calls
[08:28:15.036]             `[[` <- base::`[[`
[08:28:15.036]             `+` <- base::`+`
[08:28:15.036]             `<<-` <- base::`<<-`
[08:28:15.036]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.036]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.036]                   3L)]
[08:28:15.036]             }
[08:28:15.036]             function(cond) {
[08:28:15.036]                 is_error <- inherits(cond, "error")
[08:28:15.036]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.036]                   NULL)
[08:28:15.036]                 if (is_error) {
[08:28:15.036]                   sessionInformation <- function() {
[08:28:15.036]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.036]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.036]                       search = base::search(), system = base::Sys.info())
[08:28:15.036]                   }
[08:28:15.036]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.036]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.036]                     cond$call), session = sessionInformation(), 
[08:28:15.036]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.036]                   signalCondition(cond)
[08:28:15.036]                 }
[08:28:15.036]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.036]                 "immediateCondition"))) {
[08:28:15.036]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.036]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.036]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.036]                   if (TRUE && !signal) {
[08:28:15.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.036]                     {
[08:28:15.036]                       inherits <- base::inherits
[08:28:15.036]                       invokeRestart <- base::invokeRestart
[08:28:15.036]                       is.null <- base::is.null
[08:28:15.036]                       muffled <- FALSE
[08:28:15.036]                       if (inherits(cond, "message")) {
[08:28:15.036]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.036]                         if (muffled) 
[08:28:15.036]                           invokeRestart("muffleMessage")
[08:28:15.036]                       }
[08:28:15.036]                       else if (inherits(cond, "warning")) {
[08:28:15.036]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.036]                         if (muffled) 
[08:28:15.036]                           invokeRestart("muffleWarning")
[08:28:15.036]                       }
[08:28:15.036]                       else if (inherits(cond, "condition")) {
[08:28:15.036]                         if (!is.null(pattern)) {
[08:28:15.036]                           computeRestarts <- base::computeRestarts
[08:28:15.036]                           grepl <- base::grepl
[08:28:15.036]                           restarts <- computeRestarts(cond)
[08:28:15.036]                           for (restart in restarts) {
[08:28:15.036]                             name <- restart$name
[08:28:15.036]                             if (is.null(name)) 
[08:28:15.036]                               next
[08:28:15.036]                             if (!grepl(pattern, name)) 
[08:28:15.036]                               next
[08:28:15.036]                             invokeRestart(restart)
[08:28:15.036]                             muffled <- TRUE
[08:28:15.036]                             break
[08:28:15.036]                           }
[08:28:15.036]                         }
[08:28:15.036]                       }
[08:28:15.036]                       invisible(muffled)
[08:28:15.036]                     }
[08:28:15.036]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.036]                   }
[08:28:15.036]                 }
[08:28:15.036]                 else {
[08:28:15.036]                   if (TRUE) {
[08:28:15.036]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.036]                     {
[08:28:15.036]                       inherits <- base::inherits
[08:28:15.036]                       invokeRestart <- base::invokeRestart
[08:28:15.036]                       is.null <- base::is.null
[08:28:15.036]                       muffled <- FALSE
[08:28:15.036]                       if (inherits(cond, "message")) {
[08:28:15.036]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.036]                         if (muffled) 
[08:28:15.036]                           invokeRestart("muffleMessage")
[08:28:15.036]                       }
[08:28:15.036]                       else if (inherits(cond, "warning")) {
[08:28:15.036]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.036]                         if (muffled) 
[08:28:15.036]                           invokeRestart("muffleWarning")
[08:28:15.036]                       }
[08:28:15.036]                       else if (inherits(cond, "condition")) {
[08:28:15.036]                         if (!is.null(pattern)) {
[08:28:15.036]                           computeRestarts <- base::computeRestarts
[08:28:15.036]                           grepl <- base::grepl
[08:28:15.036]                           restarts <- computeRestarts(cond)
[08:28:15.036]                           for (restart in restarts) {
[08:28:15.036]                             name <- restart$name
[08:28:15.036]                             if (is.null(name)) 
[08:28:15.036]                               next
[08:28:15.036]                             if (!grepl(pattern, name)) 
[08:28:15.036]                               next
[08:28:15.036]                             invokeRestart(restart)
[08:28:15.036]                             muffled <- TRUE
[08:28:15.036]                             break
[08:28:15.036]                           }
[08:28:15.036]                         }
[08:28:15.036]                       }
[08:28:15.036]                       invisible(muffled)
[08:28:15.036]                     }
[08:28:15.036]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.036]                   }
[08:28:15.036]                 }
[08:28:15.036]             }
[08:28:15.036]         }))
[08:28:15.036]     }, error = function(ex) {
[08:28:15.036]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.036]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.036]                 ...future.rng), started = ...future.startTime, 
[08:28:15.036]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.036]             version = "1.8"), class = "FutureResult")
[08:28:15.036]     }, finally = {
[08:28:15.036]         if (!identical(...future.workdir, getwd())) 
[08:28:15.036]             setwd(...future.workdir)
[08:28:15.036]         {
[08:28:15.036]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.036]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.036]             }
[08:28:15.036]             base::options(...future.oldOptions)
[08:28:15.036]             if (.Platform$OS.type == "windows") {
[08:28:15.036]                 old_names <- names(...future.oldEnvVars)
[08:28:15.036]                 envs <- base::Sys.getenv()
[08:28:15.036]                 names <- names(envs)
[08:28:15.036]                 common <- intersect(names, old_names)
[08:28:15.036]                 added <- setdiff(names, old_names)
[08:28:15.036]                 removed <- setdiff(old_names, names)
[08:28:15.036]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.036]                   envs[common]]
[08:28:15.036]                 NAMES <- toupper(changed)
[08:28:15.036]                 args <- list()
[08:28:15.036]                 for (kk in seq_along(NAMES)) {
[08:28:15.036]                   name <- changed[[kk]]
[08:28:15.036]                   NAME <- NAMES[[kk]]
[08:28:15.036]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.036]                     next
[08:28:15.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.036]                 }
[08:28:15.036]                 NAMES <- toupper(added)
[08:28:15.036]                 for (kk in seq_along(NAMES)) {
[08:28:15.036]                   name <- added[[kk]]
[08:28:15.036]                   NAME <- NAMES[[kk]]
[08:28:15.036]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.036]                     next
[08:28:15.036]                   args[[name]] <- ""
[08:28:15.036]                 }
[08:28:15.036]                 NAMES <- toupper(removed)
[08:28:15.036]                 for (kk in seq_along(NAMES)) {
[08:28:15.036]                   name <- removed[[kk]]
[08:28:15.036]                   NAME <- NAMES[[kk]]
[08:28:15.036]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.036]                     next
[08:28:15.036]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.036]                 }
[08:28:15.036]                 if (length(args) > 0) 
[08:28:15.036]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.036]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.036]             }
[08:28:15.036]             else {
[08:28:15.036]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.036]             }
[08:28:15.036]             {
[08:28:15.036]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.036]                   0L) {
[08:28:15.036]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.036]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.036]                   base::options(opts)
[08:28:15.036]                 }
[08:28:15.036]                 {
[08:28:15.036]                   {
[08:28:15.036]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.036]                     NULL
[08:28:15.036]                   }
[08:28:15.036]                   options(future.plan = NULL)
[08:28:15.036]                   if (is.na(NA_character_)) 
[08:28:15.036]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.036]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.036]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.036]                     .init = FALSE)
[08:28:15.036]                 }
[08:28:15.036]             }
[08:28:15.036]         }
[08:28:15.036]     })
[08:28:15.036]     if (TRUE) {
[08:28:15.036]         base::sink(type = "output", split = FALSE)
[08:28:15.036]         if (TRUE) {
[08:28:15.036]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.036]         }
[08:28:15.036]         else {
[08:28:15.036]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.036]         }
[08:28:15.036]         base::close(...future.stdout)
[08:28:15.036]         ...future.stdout <- NULL
[08:28:15.036]     }
[08:28:15.036]     ...future.result$conditions <- ...future.conditions
[08:28:15.036]     ...future.result$finished <- base::Sys.time()
[08:28:15.036]     ...future.result
[08:28:15.036] }
[08:28:15.039] requestCore(): workers = 2
[08:28:15.041] MulticoreFuture started
[08:28:15.041] - Launch lazy future ... done
[08:28:15.041] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.042] plan(): Setting new future strategy stack:
[08:28:15.042] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.042] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.042] List of future strategies:
[08:28:15.042] 1. sequential:
[08:28:15.042]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.042]    - tweaked: FALSE
[08:28:15.042]    - call: NULL
[08:28:15.043] plan(): nbrOfWorkers() = 1
[08:28:15.044] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.044] Searching for globals ... DONE
[08:28:15.045] Resolving globals: TRUE
[08:28:15.045] plan(): Setting new future strategy stack:
[08:28:15.045] Resolving any globals that are futures ...
[08:28:15.045] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.045] Resolving any globals that are futures ... DONE
[08:28:15.045] List of future strategies:
[08:28:15.045] 1. multicore:
[08:28:15.045]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.045]    - tweaked: FALSE
[08:28:15.045]    - call: plan(strategy)
[08:28:15.046] Resolving futures part of globals (recursively) ...
[08:28:15.046] resolve() on list ...
[08:28:15.047]  recursive: 99
[08:28:15.047]  length: 1
[08:28:15.047]  elements: ‘a’
[08:28:15.048] plan(): nbrOfWorkers() = 2
[08:28:15.048] Future #1
[08:28:15.048] result() for MulticoreFuture ...
[08:28:15.049] result() for MulticoreFuture ...
[08:28:15.049] result() for MulticoreFuture ... done
[08:28:15.050] result() for MulticoreFuture ... done
[08:28:15.050] result() for MulticoreFuture ...
[08:28:15.050] result() for MulticoreFuture ... done
[08:28:15.050] A MulticoreFuture was resolved
[08:28:15.050]  length: 0 (resolved future 1)
[08:28:15.050] resolve() on list ... DONE
[08:28:15.050] - globals: [1] ‘a’
[08:28:15.051] Resolving futures part of globals (recursively) ... DONE
[08:28:15.051] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[08:28:15.051] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[08:28:15.051] - globals: [1] ‘a’
[08:28:15.052] - packages: [1] ‘future’
[08:28:15.052] getGlobalsAndPackages() ... DONE
[08:28:15.052] run() for ‘Future’ ...
[08:28:15.052] - state: ‘created’
[08:28:15.052] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.054] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.054] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.055]   - Field: ‘label’
[08:28:15.055]   - Field: ‘local’
[08:28:15.055]   - Field: ‘owner’
[08:28:15.055]   - Field: ‘envir’
[08:28:15.055]   - Field: ‘workers’
[08:28:15.055]   - Field: ‘packages’
[08:28:15.055]   - Field: ‘gc’
[08:28:15.055]   - Field: ‘job’
[08:28:15.055]   - Field: ‘conditions’
[08:28:15.056]   - Field: ‘expr’
[08:28:15.056]   - Field: ‘uuid’
[08:28:15.056]   - Field: ‘seed’
[08:28:15.056]   - Field: ‘version’
[08:28:15.056]   - Field: ‘result’
[08:28:15.056]   - Field: ‘asynchronous’
[08:28:15.056]   - Field: ‘calls’
[08:28:15.056]   - Field: ‘globals’
[08:28:15.056]   - Field: ‘stdout’
[08:28:15.056]   - Field: ‘earlySignal’
[08:28:15.057]   - Field: ‘lazy’
[08:28:15.057]   - Field: ‘state’
[08:28:15.057] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.057] - Launch lazy future ...
[08:28:15.057] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.057] Packages needed by future strategies (n = 0): <none>
[08:28:15.058] {
[08:28:15.058]     {
[08:28:15.058]         {
[08:28:15.058]             ...future.startTime <- base::Sys.time()
[08:28:15.058]             {
[08:28:15.058]                 {
[08:28:15.058]                   {
[08:28:15.058]                     {
[08:28:15.058]                       {
[08:28:15.058]                         base::local({
[08:28:15.058]                           has_future <- base::requireNamespace("future", 
[08:28:15.058]                             quietly = TRUE)
[08:28:15.058]                           if (has_future) {
[08:28:15.058]                             ns <- base::getNamespace("future")
[08:28:15.058]                             version <- ns[[".package"]][["version"]]
[08:28:15.058]                             if (is.null(version)) 
[08:28:15.058]                               version <- utils::packageVersion("future")
[08:28:15.058]                           }
[08:28:15.058]                           else {
[08:28:15.058]                             version <- NULL
[08:28:15.058]                           }
[08:28:15.058]                           if (!has_future || version < "1.8.0") {
[08:28:15.058]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.058]                               "", base::R.version$version.string), 
[08:28:15.058]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.058]                                 base::R.version$platform, 8 * 
[08:28:15.058]                                   base::.Machine$sizeof.pointer), 
[08:28:15.058]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.058]                                 "release", "version")], collapse = " "), 
[08:28:15.058]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.058]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.058]                               info)
[08:28:15.058]                             info <- base::paste(info, collapse = "; ")
[08:28:15.058]                             if (!has_future) {
[08:28:15.058]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.058]                                 info)
[08:28:15.058]                             }
[08:28:15.058]                             else {
[08:28:15.058]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.058]                                 info, version)
[08:28:15.058]                             }
[08:28:15.058]                             base::stop(msg)
[08:28:15.058]                           }
[08:28:15.058]                         })
[08:28:15.058]                       }
[08:28:15.058]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.058]                       base::options(mc.cores = 1L)
[08:28:15.058]                     }
[08:28:15.058]                     base::local({
[08:28:15.058]                       for (pkg in "future") {
[08:28:15.058]                         base::loadNamespace(pkg)
[08:28:15.058]                         base::library(pkg, character.only = TRUE)
[08:28:15.058]                       }
[08:28:15.058]                     })
[08:28:15.058]                   }
[08:28:15.058]                   ...future.strategy.old <- future::plan("list")
[08:28:15.058]                   options(future.plan = NULL)
[08:28:15.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.058]                 }
[08:28:15.058]                 ...future.workdir <- getwd()
[08:28:15.058]             }
[08:28:15.058]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.058]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.058]         }
[08:28:15.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.058]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.058]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.058]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.058]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.058]             base::names(...future.oldOptions))
[08:28:15.058]     }
[08:28:15.058]     if (FALSE) {
[08:28:15.058]     }
[08:28:15.058]     else {
[08:28:15.058]         if (TRUE) {
[08:28:15.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.058]                 open = "w")
[08:28:15.058]         }
[08:28:15.058]         else {
[08:28:15.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.058]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.058]         }
[08:28:15.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.058]             base::sink(type = "output", split = FALSE)
[08:28:15.058]             base::close(...future.stdout)
[08:28:15.058]         }, add = TRUE)
[08:28:15.058]     }
[08:28:15.058]     ...future.frame <- base::sys.nframe()
[08:28:15.058]     ...future.conditions <- base::list()
[08:28:15.058]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.058]     if (FALSE) {
[08:28:15.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.058]     }
[08:28:15.058]     ...future.result <- base::tryCatch({
[08:28:15.058]         base::withCallingHandlers({
[08:28:15.058]             ...future.value <- base::withVisible(base::local({
[08:28:15.058]                 withCallingHandlers({
[08:28:15.058]                   value(a) + 1
[08:28:15.058]                 }, immediateCondition = function(cond) {
[08:28:15.058]                   save_rds <- function (object, pathname, ...) 
[08:28:15.058]                   {
[08:28:15.058]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.058]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.058]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.058]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.058]                         fi_tmp[["mtime"]])
[08:28:15.058]                     }
[08:28:15.058]                     tryCatch({
[08:28:15.058]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.058]                     }, error = function(ex) {
[08:28:15.058]                       msg <- conditionMessage(ex)
[08:28:15.058]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.058]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.058]                         fi_tmp[["mtime"]], msg)
[08:28:15.058]                       ex$message <- msg
[08:28:15.058]                       stop(ex)
[08:28:15.058]                     })
[08:28:15.058]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.058]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.058]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.058]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.058]                       fi <- file.info(pathname)
[08:28:15.058]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.058]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.058]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.058]                         fi[["size"]], fi[["mtime"]])
[08:28:15.058]                       stop(msg)
[08:28:15.058]                     }
[08:28:15.058]                     invisible(pathname)
[08:28:15.058]                   }
[08:28:15.058]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.058]                     rootPath = tempdir()) 
[08:28:15.058]                   {
[08:28:15.058]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.058]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.058]                       tmpdir = path, fileext = ".rds")
[08:28:15.058]                     save_rds(obj, file)
[08:28:15.058]                   }
[08:28:15.058]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.058]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.058]                   {
[08:28:15.058]                     inherits <- base::inherits
[08:28:15.058]                     invokeRestart <- base::invokeRestart
[08:28:15.058]                     is.null <- base::is.null
[08:28:15.058]                     muffled <- FALSE
[08:28:15.058]                     if (inherits(cond, "message")) {
[08:28:15.058]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.058]                       if (muffled) 
[08:28:15.058]                         invokeRestart("muffleMessage")
[08:28:15.058]                     }
[08:28:15.058]                     else if (inherits(cond, "warning")) {
[08:28:15.058]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.058]                       if (muffled) 
[08:28:15.058]                         invokeRestart("muffleWarning")
[08:28:15.058]                     }
[08:28:15.058]                     else if (inherits(cond, "condition")) {
[08:28:15.058]                       if (!is.null(pattern)) {
[08:28:15.058]                         computeRestarts <- base::computeRestarts
[08:28:15.058]                         grepl <- base::grepl
[08:28:15.058]                         restarts <- computeRestarts(cond)
[08:28:15.058]                         for (restart in restarts) {
[08:28:15.058]                           name <- restart$name
[08:28:15.058]                           if (is.null(name)) 
[08:28:15.058]                             next
[08:28:15.058]                           if (!grepl(pattern, name)) 
[08:28:15.058]                             next
[08:28:15.058]                           invokeRestart(restart)
[08:28:15.058]                           muffled <- TRUE
[08:28:15.058]                           break
[08:28:15.058]                         }
[08:28:15.058]                       }
[08:28:15.058]                     }
[08:28:15.058]                     invisible(muffled)
[08:28:15.058]                   }
[08:28:15.058]                   muffleCondition(cond)
[08:28:15.058]                 })
[08:28:15.058]             }))
[08:28:15.058]             future::FutureResult(value = ...future.value$value, 
[08:28:15.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.058]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.058]                     ...future.globalenv.names))
[08:28:15.058]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.058]         }, condition = base::local({
[08:28:15.058]             c <- base::c
[08:28:15.058]             inherits <- base::inherits
[08:28:15.058]             invokeRestart <- base::invokeRestart
[08:28:15.058]             length <- base::length
[08:28:15.058]             list <- base::list
[08:28:15.058]             seq.int <- base::seq.int
[08:28:15.058]             signalCondition <- base::signalCondition
[08:28:15.058]             sys.calls <- base::sys.calls
[08:28:15.058]             `[[` <- base::`[[`
[08:28:15.058]             `+` <- base::`+`
[08:28:15.058]             `<<-` <- base::`<<-`
[08:28:15.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.058]                   3L)]
[08:28:15.058]             }
[08:28:15.058]             function(cond) {
[08:28:15.058]                 is_error <- inherits(cond, "error")
[08:28:15.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.058]                   NULL)
[08:28:15.058]                 if (is_error) {
[08:28:15.058]                   sessionInformation <- function() {
[08:28:15.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.058]                       search = base::search(), system = base::Sys.info())
[08:28:15.058]                   }
[08:28:15.058]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.058]                     cond$call), session = sessionInformation(), 
[08:28:15.058]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.058]                   signalCondition(cond)
[08:28:15.058]                 }
[08:28:15.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.058]                 "immediateCondition"))) {
[08:28:15.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.058]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.058]                   if (TRUE && !signal) {
[08:28:15.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.058]                     {
[08:28:15.058]                       inherits <- base::inherits
[08:28:15.058]                       invokeRestart <- base::invokeRestart
[08:28:15.058]                       is.null <- base::is.null
[08:28:15.058]                       muffled <- FALSE
[08:28:15.058]                       if (inherits(cond, "message")) {
[08:28:15.058]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.058]                         if (muffled) 
[08:28:15.058]                           invokeRestart("muffleMessage")
[08:28:15.058]                       }
[08:28:15.058]                       else if (inherits(cond, "warning")) {
[08:28:15.058]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.058]                         if (muffled) 
[08:28:15.058]                           invokeRestart("muffleWarning")
[08:28:15.058]                       }
[08:28:15.058]                       else if (inherits(cond, "condition")) {
[08:28:15.058]                         if (!is.null(pattern)) {
[08:28:15.058]                           computeRestarts <- base::computeRestarts
[08:28:15.058]                           grepl <- base::grepl
[08:28:15.058]                           restarts <- computeRestarts(cond)
[08:28:15.058]                           for (restart in restarts) {
[08:28:15.058]                             name <- restart$name
[08:28:15.058]                             if (is.null(name)) 
[08:28:15.058]                               next
[08:28:15.058]                             if (!grepl(pattern, name)) 
[08:28:15.058]                               next
[08:28:15.058]                             invokeRestart(restart)
[08:28:15.058]                             muffled <- TRUE
[08:28:15.058]                             break
[08:28:15.058]                           }
[08:28:15.058]                         }
[08:28:15.058]                       }
[08:28:15.058]                       invisible(muffled)
[08:28:15.058]                     }
[08:28:15.058]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.058]                   }
[08:28:15.058]                 }
[08:28:15.058]                 else {
[08:28:15.058]                   if (TRUE) {
[08:28:15.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.058]                     {
[08:28:15.058]                       inherits <- base::inherits
[08:28:15.058]                       invokeRestart <- base::invokeRestart
[08:28:15.058]                       is.null <- base::is.null
[08:28:15.058]                       muffled <- FALSE
[08:28:15.058]                       if (inherits(cond, "message")) {
[08:28:15.058]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.058]                         if (muffled) 
[08:28:15.058]                           invokeRestart("muffleMessage")
[08:28:15.058]                       }
[08:28:15.058]                       else if (inherits(cond, "warning")) {
[08:28:15.058]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.058]                         if (muffled) 
[08:28:15.058]                           invokeRestart("muffleWarning")
[08:28:15.058]                       }
[08:28:15.058]                       else if (inherits(cond, "condition")) {
[08:28:15.058]                         if (!is.null(pattern)) {
[08:28:15.058]                           computeRestarts <- base::computeRestarts
[08:28:15.058]                           grepl <- base::grepl
[08:28:15.058]                           restarts <- computeRestarts(cond)
[08:28:15.058]                           for (restart in restarts) {
[08:28:15.058]                             name <- restart$name
[08:28:15.058]                             if (is.null(name)) 
[08:28:15.058]                               next
[08:28:15.058]                             if (!grepl(pattern, name)) 
[08:28:15.058]                               next
[08:28:15.058]                             invokeRestart(restart)
[08:28:15.058]                             muffled <- TRUE
[08:28:15.058]                             break
[08:28:15.058]                           }
[08:28:15.058]                         }
[08:28:15.058]                       }
[08:28:15.058]                       invisible(muffled)
[08:28:15.058]                     }
[08:28:15.058]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.058]                   }
[08:28:15.058]                 }
[08:28:15.058]             }
[08:28:15.058]         }))
[08:28:15.058]     }, error = function(ex) {
[08:28:15.058]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.058]                 ...future.rng), started = ...future.startTime, 
[08:28:15.058]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.058]             version = "1.8"), class = "FutureResult")
[08:28:15.058]     }, finally = {
[08:28:15.058]         if (!identical(...future.workdir, getwd())) 
[08:28:15.058]             setwd(...future.workdir)
[08:28:15.058]         {
[08:28:15.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.058]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.058]             }
[08:28:15.058]             base::options(...future.oldOptions)
[08:28:15.058]             if (.Platform$OS.type == "windows") {
[08:28:15.058]                 old_names <- names(...future.oldEnvVars)
[08:28:15.058]                 envs <- base::Sys.getenv()
[08:28:15.058]                 names <- names(envs)
[08:28:15.058]                 common <- intersect(names, old_names)
[08:28:15.058]                 added <- setdiff(names, old_names)
[08:28:15.058]                 removed <- setdiff(old_names, names)
[08:28:15.058]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.058]                   envs[common]]
[08:28:15.058]                 NAMES <- toupper(changed)
[08:28:15.058]                 args <- list()
[08:28:15.058]                 for (kk in seq_along(NAMES)) {
[08:28:15.058]                   name <- changed[[kk]]
[08:28:15.058]                   NAME <- NAMES[[kk]]
[08:28:15.058]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.058]                     next
[08:28:15.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.058]                 }
[08:28:15.058]                 NAMES <- toupper(added)
[08:28:15.058]                 for (kk in seq_along(NAMES)) {
[08:28:15.058]                   name <- added[[kk]]
[08:28:15.058]                   NAME <- NAMES[[kk]]
[08:28:15.058]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.058]                     next
[08:28:15.058]                   args[[name]] <- ""
[08:28:15.058]                 }
[08:28:15.058]                 NAMES <- toupper(removed)
[08:28:15.058]                 for (kk in seq_along(NAMES)) {
[08:28:15.058]                   name <- removed[[kk]]
[08:28:15.058]                   NAME <- NAMES[[kk]]
[08:28:15.058]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.058]                     next
[08:28:15.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.058]                 }
[08:28:15.058]                 if (length(args) > 0) 
[08:28:15.058]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.058]             }
[08:28:15.058]             else {
[08:28:15.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.058]             }
[08:28:15.058]             {
[08:28:15.058]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.058]                   0L) {
[08:28:15.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.058]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.058]                   base::options(opts)
[08:28:15.058]                 }
[08:28:15.058]                 {
[08:28:15.058]                   {
[08:28:15.058]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.058]                     NULL
[08:28:15.058]                   }
[08:28:15.058]                   options(future.plan = NULL)
[08:28:15.058]                   if (is.na(NA_character_)) 
[08:28:15.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.058]                     .init = FALSE)
[08:28:15.058]                 }
[08:28:15.058]             }
[08:28:15.058]         }
[08:28:15.058]     })
[08:28:15.058]     if (TRUE) {
[08:28:15.058]         base::sink(type = "output", split = FALSE)
[08:28:15.058]         if (TRUE) {
[08:28:15.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.058]         }
[08:28:15.058]         else {
[08:28:15.058]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.058]         }
[08:28:15.058]         base::close(...future.stdout)
[08:28:15.058]         ...future.stdout <- NULL
[08:28:15.058]     }
[08:28:15.058]     ...future.result$conditions <- ...future.conditions
[08:28:15.058]     ...future.result$finished <- base::Sys.time()
[08:28:15.058]     ...future.result
[08:28:15.058] }
[08:28:15.061] assign_globals() ...
[08:28:15.061] List of 1
[08:28:15.061]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a109d8c090> 
[08:28:15.061]  - attr(*, "where")=List of 1
[08:28:15.061]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.061]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.061]  - attr(*, "resolved")= logi TRUE
[08:28:15.061]  - attr(*, "total_size")= num 3815
[08:28:15.061]  - attr(*, "already-done")= logi TRUE
[08:28:15.064] - copied ‘a’ to environment
[08:28:15.064] assign_globals() ... done
[08:28:15.064] requestCore(): workers = 2
[08:28:15.066] MulticoreFuture started
[08:28:15.066] - Launch lazy future ... done
[08:28:15.066] run() for ‘MulticoreFuture’ ... done
[08:28:15.066] result() for MulticoreFuture ...
[08:28:15.067] plan(): Setting new future strategy stack:
[08:28:15.067] List of future strategies:
[08:28:15.067] 1. sequential:
[08:28:15.067]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.067]    - tweaked: FALSE
[08:28:15.067]    - call: NULL
[08:28:15.073] plan(): nbrOfWorkers() = 1
[08:28:15.076] plan(): Setting new future strategy stack:
[08:28:15.077] List of future strategies:
[08:28:15.077] 1. multicore:
[08:28:15.077]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.077]    - tweaked: FALSE
[08:28:15.077]    - call: plan(strategy)
[08:28:15.080] plan(): nbrOfWorkers() = 2
[08:28:15.081] result() for MulticoreFuture ...
[08:28:15.081] result() for MulticoreFuture ... done
[08:28:15.081] signalConditions() ...
[08:28:15.082]  - include = ‘immediateCondition’
[08:28:15.082]  - exclude = 
[08:28:15.082]  - resignal = FALSE
[08:28:15.082]  - Number of conditions: 4
[08:28:15.082] signalConditions() ... done
[08:28:15.082] result() for MulticoreFuture ... done
[08:28:15.083] result() for MulticoreFuture ...
[08:28:15.083] result() for MulticoreFuture ... done
[08:28:15.083] signalConditions() ...
[08:28:15.083]  - include = ‘immediateCondition’
[08:28:15.083]  - exclude = 
[08:28:15.083]  - resignal = FALSE
[08:28:15.083]  - Number of conditions: 4
[08:28:15.084] signalConditions() ... done
[08:28:15.084] Future state: ‘finished’
[08:28:15.084] result() for MulticoreFuture ...
[08:28:15.084] result() for MulticoreFuture ... done
[08:28:15.084] signalConditions() ...
[08:28:15.084]  - include = ‘condition’
[08:28:15.084]  - exclude = ‘immediateCondition’
[08:28:15.084]  - resignal = TRUE
[08:28:15.085]  - Number of conditions: 4
[08:28:15.085]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.074] result() for MulticoreFuture ...
[08:28:15.085]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.075] result() for MulticoreFuture ... done
[08:28:15.085]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.075] result() for MulticoreFuture ...
[08:28:15.085]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.075] result() for MulticoreFuture ... done
[08:28:15.085] signalConditions() ... done
value(b) = 2
[08:28:15.086] result() for MulticoreFuture ...
[08:28:15.086] result() for MulticoreFuture ... done
[08:28:15.086] result() for MulticoreFuture ...
[08:28:15.086] result() for MulticoreFuture ... done
[08:28:15.086] signalConditions() ...
[08:28:15.086]  - include = ‘immediateCondition’
[08:28:15.086]  - exclude = 
[08:28:15.086]  - resignal = FALSE
[08:28:15.086]  - Number of conditions: 4
[08:28:15.087] signalConditions() ... done
[08:28:15.087] Future state: ‘finished’
[08:28:15.087] result() for MulticoreFuture ...
[08:28:15.087] result() for MulticoreFuture ... done
[08:28:15.087] signalConditions() ...
[08:28:15.087]  - include = ‘condition’
[08:28:15.087]  - exclude = ‘immediateCondition’
[08:28:15.087]  - resignal = TRUE
[08:28:15.087]  - Number of conditions: 4
[08:28:15.088]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.074] result() for MulticoreFuture ...
[08:28:15.088]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.075] result() for MulticoreFuture ... done
[08:28:15.088]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.075] result() for MulticoreFuture ...
[08:28:15.088]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.075] result() for MulticoreFuture ... done
[08:28:15.088] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.088] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.089] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.089] 
[08:28:15.090] Searching for globals ... DONE
[08:28:15.090] - globals: [0] <none>
[08:28:15.090] getGlobalsAndPackages() ... DONE
[08:28:15.090] run() for ‘Future’ ...
[08:28:15.090] - state: ‘created’
[08:28:15.090] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.092] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.092] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.092]   - Field: ‘label’
[08:28:15.093]   - Field: ‘local’
[08:28:15.093]   - Field: ‘owner’
[08:28:15.093]   - Field: ‘envir’
[08:28:15.093]   - Field: ‘workers’
[08:28:15.093]   - Field: ‘packages’
[08:28:15.093]   - Field: ‘gc’
[08:28:15.093]   - Field: ‘job’
[08:28:15.093]   - Field: ‘conditions’
[08:28:15.093]   - Field: ‘expr’
[08:28:15.094]   - Field: ‘uuid’
[08:28:15.094]   - Field: ‘seed’
[08:28:15.094]   - Field: ‘version’
[08:28:15.094]   - Field: ‘result’
[08:28:15.094]   - Field: ‘asynchronous’
[08:28:15.094]   - Field: ‘calls’
[08:28:15.094]   - Field: ‘globals’
[08:28:15.094]   - Field: ‘stdout’
[08:28:15.094]   - Field: ‘earlySignal’
[08:28:15.094]   - Field: ‘lazy’
[08:28:15.095]   - Field: ‘state’
[08:28:15.095] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.095] - Launch lazy future ...
[08:28:15.095] Packages needed by the future expression (n = 0): <none>
[08:28:15.095] Packages needed by future strategies (n = 0): <none>
[08:28:15.096] {
[08:28:15.096]     {
[08:28:15.096]         {
[08:28:15.096]             ...future.startTime <- base::Sys.time()
[08:28:15.096]             {
[08:28:15.096]                 {
[08:28:15.096]                   {
[08:28:15.096]                     {
[08:28:15.096]                       base::local({
[08:28:15.096]                         has_future <- base::requireNamespace("future", 
[08:28:15.096]                           quietly = TRUE)
[08:28:15.096]                         if (has_future) {
[08:28:15.096]                           ns <- base::getNamespace("future")
[08:28:15.096]                           version <- ns[[".package"]][["version"]]
[08:28:15.096]                           if (is.null(version)) 
[08:28:15.096]                             version <- utils::packageVersion("future")
[08:28:15.096]                         }
[08:28:15.096]                         else {
[08:28:15.096]                           version <- NULL
[08:28:15.096]                         }
[08:28:15.096]                         if (!has_future || version < "1.8.0") {
[08:28:15.096]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.096]                             "", base::R.version$version.string), 
[08:28:15.096]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.096]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.096]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.096]                               "release", "version")], collapse = " "), 
[08:28:15.096]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.096]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.096]                             info)
[08:28:15.096]                           info <- base::paste(info, collapse = "; ")
[08:28:15.096]                           if (!has_future) {
[08:28:15.096]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.096]                               info)
[08:28:15.096]                           }
[08:28:15.096]                           else {
[08:28:15.096]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.096]                               info, version)
[08:28:15.096]                           }
[08:28:15.096]                           base::stop(msg)
[08:28:15.096]                         }
[08:28:15.096]                       })
[08:28:15.096]                     }
[08:28:15.096]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.096]                     base::options(mc.cores = 1L)
[08:28:15.096]                   }
[08:28:15.096]                   ...future.strategy.old <- future::plan("list")
[08:28:15.096]                   options(future.plan = NULL)
[08:28:15.096]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.096]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.096]                 }
[08:28:15.096]                 ...future.workdir <- getwd()
[08:28:15.096]             }
[08:28:15.096]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.096]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.096]         }
[08:28:15.096]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.096]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.096]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.096]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.096]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.096]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.096]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.096]             base::names(...future.oldOptions))
[08:28:15.096]     }
[08:28:15.096]     if (FALSE) {
[08:28:15.096]     }
[08:28:15.096]     else {
[08:28:15.096]         if (TRUE) {
[08:28:15.096]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.096]                 open = "w")
[08:28:15.096]         }
[08:28:15.096]         else {
[08:28:15.096]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.096]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.096]         }
[08:28:15.096]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.096]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.096]             base::sink(type = "output", split = FALSE)
[08:28:15.096]             base::close(...future.stdout)
[08:28:15.096]         }, add = TRUE)
[08:28:15.096]     }
[08:28:15.096]     ...future.frame <- base::sys.nframe()
[08:28:15.096]     ...future.conditions <- base::list()
[08:28:15.096]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.096]     if (FALSE) {
[08:28:15.096]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.096]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.096]     }
[08:28:15.096]     ...future.result <- base::tryCatch({
[08:28:15.096]         base::withCallingHandlers({
[08:28:15.096]             ...future.value <- base::withVisible(base::local({
[08:28:15.096]                 withCallingHandlers({
[08:28:15.096]                   1
[08:28:15.096]                 }, immediateCondition = function(cond) {
[08:28:15.096]                   save_rds <- function (object, pathname, ...) 
[08:28:15.096]                   {
[08:28:15.096]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.096]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.096]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.096]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.096]                         fi_tmp[["mtime"]])
[08:28:15.096]                     }
[08:28:15.096]                     tryCatch({
[08:28:15.096]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.096]                     }, error = function(ex) {
[08:28:15.096]                       msg <- conditionMessage(ex)
[08:28:15.096]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.096]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.096]                         fi_tmp[["mtime"]], msg)
[08:28:15.096]                       ex$message <- msg
[08:28:15.096]                       stop(ex)
[08:28:15.096]                     })
[08:28:15.096]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.096]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.096]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.096]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.096]                       fi <- file.info(pathname)
[08:28:15.096]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.096]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.096]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.096]                         fi[["size"]], fi[["mtime"]])
[08:28:15.096]                       stop(msg)
[08:28:15.096]                     }
[08:28:15.096]                     invisible(pathname)
[08:28:15.096]                   }
[08:28:15.096]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.096]                     rootPath = tempdir()) 
[08:28:15.096]                   {
[08:28:15.096]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.096]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.096]                       tmpdir = path, fileext = ".rds")
[08:28:15.096]                     save_rds(obj, file)
[08:28:15.096]                   }
[08:28:15.096]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.096]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.096]                   {
[08:28:15.096]                     inherits <- base::inherits
[08:28:15.096]                     invokeRestart <- base::invokeRestart
[08:28:15.096]                     is.null <- base::is.null
[08:28:15.096]                     muffled <- FALSE
[08:28:15.096]                     if (inherits(cond, "message")) {
[08:28:15.096]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.096]                       if (muffled) 
[08:28:15.096]                         invokeRestart("muffleMessage")
[08:28:15.096]                     }
[08:28:15.096]                     else if (inherits(cond, "warning")) {
[08:28:15.096]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.096]                       if (muffled) 
[08:28:15.096]                         invokeRestart("muffleWarning")
[08:28:15.096]                     }
[08:28:15.096]                     else if (inherits(cond, "condition")) {
[08:28:15.096]                       if (!is.null(pattern)) {
[08:28:15.096]                         computeRestarts <- base::computeRestarts
[08:28:15.096]                         grepl <- base::grepl
[08:28:15.096]                         restarts <- computeRestarts(cond)
[08:28:15.096]                         for (restart in restarts) {
[08:28:15.096]                           name <- restart$name
[08:28:15.096]                           if (is.null(name)) 
[08:28:15.096]                             next
[08:28:15.096]                           if (!grepl(pattern, name)) 
[08:28:15.096]                             next
[08:28:15.096]                           invokeRestart(restart)
[08:28:15.096]                           muffled <- TRUE
[08:28:15.096]                           break
[08:28:15.096]                         }
[08:28:15.096]                       }
[08:28:15.096]                     }
[08:28:15.096]                     invisible(muffled)
[08:28:15.096]                   }
[08:28:15.096]                   muffleCondition(cond)
[08:28:15.096]                 })
[08:28:15.096]             }))
[08:28:15.096]             future::FutureResult(value = ...future.value$value, 
[08:28:15.096]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.096]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.096]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.096]                     ...future.globalenv.names))
[08:28:15.096]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.096]         }, condition = base::local({
[08:28:15.096]             c <- base::c
[08:28:15.096]             inherits <- base::inherits
[08:28:15.096]             invokeRestart <- base::invokeRestart
[08:28:15.096]             length <- base::length
[08:28:15.096]             list <- base::list
[08:28:15.096]             seq.int <- base::seq.int
[08:28:15.096]             signalCondition <- base::signalCondition
[08:28:15.096]             sys.calls <- base::sys.calls
[08:28:15.096]             `[[` <- base::`[[`
[08:28:15.096]             `+` <- base::`+`
[08:28:15.096]             `<<-` <- base::`<<-`
[08:28:15.096]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.096]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.096]                   3L)]
[08:28:15.096]             }
[08:28:15.096]             function(cond) {
[08:28:15.096]                 is_error <- inherits(cond, "error")
[08:28:15.096]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.096]                   NULL)
[08:28:15.096]                 if (is_error) {
[08:28:15.096]                   sessionInformation <- function() {
[08:28:15.096]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.096]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.096]                       search = base::search(), system = base::Sys.info())
[08:28:15.096]                   }
[08:28:15.096]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.096]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.096]                     cond$call), session = sessionInformation(), 
[08:28:15.096]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.096]                   signalCondition(cond)
[08:28:15.096]                 }
[08:28:15.096]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.096]                 "immediateCondition"))) {
[08:28:15.096]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.096]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.096]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.096]                   if (TRUE && !signal) {
[08:28:15.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.096]                     {
[08:28:15.096]                       inherits <- base::inherits
[08:28:15.096]                       invokeRestart <- base::invokeRestart
[08:28:15.096]                       is.null <- base::is.null
[08:28:15.096]                       muffled <- FALSE
[08:28:15.096]                       if (inherits(cond, "message")) {
[08:28:15.096]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.096]                         if (muffled) 
[08:28:15.096]                           invokeRestart("muffleMessage")
[08:28:15.096]                       }
[08:28:15.096]                       else if (inherits(cond, "warning")) {
[08:28:15.096]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.096]                         if (muffled) 
[08:28:15.096]                           invokeRestart("muffleWarning")
[08:28:15.096]                       }
[08:28:15.096]                       else if (inherits(cond, "condition")) {
[08:28:15.096]                         if (!is.null(pattern)) {
[08:28:15.096]                           computeRestarts <- base::computeRestarts
[08:28:15.096]                           grepl <- base::grepl
[08:28:15.096]                           restarts <- computeRestarts(cond)
[08:28:15.096]                           for (restart in restarts) {
[08:28:15.096]                             name <- restart$name
[08:28:15.096]                             if (is.null(name)) 
[08:28:15.096]                               next
[08:28:15.096]                             if (!grepl(pattern, name)) 
[08:28:15.096]                               next
[08:28:15.096]                             invokeRestart(restart)
[08:28:15.096]                             muffled <- TRUE
[08:28:15.096]                             break
[08:28:15.096]                           }
[08:28:15.096]                         }
[08:28:15.096]                       }
[08:28:15.096]                       invisible(muffled)
[08:28:15.096]                     }
[08:28:15.096]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.096]                   }
[08:28:15.096]                 }
[08:28:15.096]                 else {
[08:28:15.096]                   if (TRUE) {
[08:28:15.096]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.096]                     {
[08:28:15.096]                       inherits <- base::inherits
[08:28:15.096]                       invokeRestart <- base::invokeRestart
[08:28:15.096]                       is.null <- base::is.null
[08:28:15.096]                       muffled <- FALSE
[08:28:15.096]                       if (inherits(cond, "message")) {
[08:28:15.096]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.096]                         if (muffled) 
[08:28:15.096]                           invokeRestart("muffleMessage")
[08:28:15.096]                       }
[08:28:15.096]                       else if (inherits(cond, "warning")) {
[08:28:15.096]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.096]                         if (muffled) 
[08:28:15.096]                           invokeRestart("muffleWarning")
[08:28:15.096]                       }
[08:28:15.096]                       else if (inherits(cond, "condition")) {
[08:28:15.096]                         if (!is.null(pattern)) {
[08:28:15.096]                           computeRestarts <- base::computeRestarts
[08:28:15.096]                           grepl <- base::grepl
[08:28:15.096]                           restarts <- computeRestarts(cond)
[08:28:15.096]                           for (restart in restarts) {
[08:28:15.096]                             name <- restart$name
[08:28:15.096]                             if (is.null(name)) 
[08:28:15.096]                               next
[08:28:15.096]                             if (!grepl(pattern, name)) 
[08:28:15.096]                               next
[08:28:15.096]                             invokeRestart(restart)
[08:28:15.096]                             muffled <- TRUE
[08:28:15.096]                             break
[08:28:15.096]                           }
[08:28:15.096]                         }
[08:28:15.096]                       }
[08:28:15.096]                       invisible(muffled)
[08:28:15.096]                     }
[08:28:15.096]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.096]                   }
[08:28:15.096]                 }
[08:28:15.096]             }
[08:28:15.096]         }))
[08:28:15.096]     }, error = function(ex) {
[08:28:15.096]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.096]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.096]                 ...future.rng), started = ...future.startTime, 
[08:28:15.096]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.096]             version = "1.8"), class = "FutureResult")
[08:28:15.096]     }, finally = {
[08:28:15.096]         if (!identical(...future.workdir, getwd())) 
[08:28:15.096]             setwd(...future.workdir)
[08:28:15.096]         {
[08:28:15.096]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.096]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.096]             }
[08:28:15.096]             base::options(...future.oldOptions)
[08:28:15.096]             if (.Platform$OS.type == "windows") {
[08:28:15.096]                 old_names <- names(...future.oldEnvVars)
[08:28:15.096]                 envs <- base::Sys.getenv()
[08:28:15.096]                 names <- names(envs)
[08:28:15.096]                 common <- intersect(names, old_names)
[08:28:15.096]                 added <- setdiff(names, old_names)
[08:28:15.096]                 removed <- setdiff(old_names, names)
[08:28:15.096]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.096]                   envs[common]]
[08:28:15.096]                 NAMES <- toupper(changed)
[08:28:15.096]                 args <- list()
[08:28:15.096]                 for (kk in seq_along(NAMES)) {
[08:28:15.096]                   name <- changed[[kk]]
[08:28:15.096]                   NAME <- NAMES[[kk]]
[08:28:15.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.096]                     next
[08:28:15.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.096]                 }
[08:28:15.096]                 NAMES <- toupper(added)
[08:28:15.096]                 for (kk in seq_along(NAMES)) {
[08:28:15.096]                   name <- added[[kk]]
[08:28:15.096]                   NAME <- NAMES[[kk]]
[08:28:15.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.096]                     next
[08:28:15.096]                   args[[name]] <- ""
[08:28:15.096]                 }
[08:28:15.096]                 NAMES <- toupper(removed)
[08:28:15.096]                 for (kk in seq_along(NAMES)) {
[08:28:15.096]                   name <- removed[[kk]]
[08:28:15.096]                   NAME <- NAMES[[kk]]
[08:28:15.096]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.096]                     next
[08:28:15.096]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.096]                 }
[08:28:15.096]                 if (length(args) > 0) 
[08:28:15.096]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.096]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.096]             }
[08:28:15.096]             else {
[08:28:15.096]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.096]             }
[08:28:15.096]             {
[08:28:15.096]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.096]                   0L) {
[08:28:15.096]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.096]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.096]                   base::options(opts)
[08:28:15.096]                 }
[08:28:15.096]                 {
[08:28:15.096]                   {
[08:28:15.096]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.096]                     NULL
[08:28:15.096]                   }
[08:28:15.096]                   options(future.plan = NULL)
[08:28:15.096]                   if (is.na(NA_character_)) 
[08:28:15.096]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.096]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.096]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.096]                     .init = FALSE)
[08:28:15.096]                 }
[08:28:15.096]             }
[08:28:15.096]         }
[08:28:15.096]     })
[08:28:15.096]     if (TRUE) {
[08:28:15.096]         base::sink(type = "output", split = FALSE)
[08:28:15.096]         if (TRUE) {
[08:28:15.096]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.096]         }
[08:28:15.096]         else {
[08:28:15.096]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.096]         }
[08:28:15.096]         base::close(...future.stdout)
[08:28:15.096]         ...future.stdout <- NULL
[08:28:15.096]     }
[08:28:15.096]     ...future.result$conditions <- ...future.conditions
[08:28:15.096]     ...future.result$finished <- base::Sys.time()
[08:28:15.096]     ...future.result
[08:28:15.096] }
[08:28:15.098] requestCore(): workers = 2
[08:28:15.100] MulticoreFuture started
[08:28:15.100] - Launch lazy future ... done
[08:28:15.100] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes [08:28:15.101] plan(): Setting new future strategy stack:
how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.101] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.101] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.101] List of future strategies:
[08:28:15.101] 1. sequential:
[08:28:15.101]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.101]    - tweaked: FALSE
[08:28:15.101]    - call: NULL
[08:28:15.102] plan(): nbrOfWorkers() = 1
[08:28:15.103] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.103] Searching for globals ... DONE
[08:28:15.104] Resolving globals: TRUE
[08:28:15.104] Resolving any globals that are futures ...
[08:28:15.104] plan(): Setting new future strategy stack:
[08:28:15.104] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.104] Resolving any globals that are futures ... DONE
[08:28:15.104] List of future strategies:
[08:28:15.104] 1. multicore:
[08:28:15.104]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.104]    - tweaked: FALSE
[08:28:15.104]    - call: plan(strategy)
[08:28:15.104] Resolving futures part of globals (recursively) ...
[08:28:15.105] resolve() on list ...
[08:28:15.105]  recursive: 99
[08:28:15.105]  length: 1
[08:28:15.106]  elements: ‘a’
[08:28:15.107] plan(): nbrOfWorkers() = 2
[08:28:15.107] Future #1
[08:28:15.107] result() for MulticoreFuture ...
[08:28:15.108] result() for MulticoreFuture ...
[08:28:15.108] result() for MulticoreFuture ... done
[08:28:15.108] result() for MulticoreFuture ... done
[08:28:15.109] result() for MulticoreFuture ...
[08:28:15.109] result() for MulticoreFuture ... done
[08:28:15.109] A MulticoreFuture was resolved
[08:28:15.109]  length: 0 (resolved future 1)
[08:28:15.109] resolve() on list ... DONE
[08:28:15.109] - globals: [1] ‘a’
[08:28:15.110] Resolving futures part of globals (recursively) ... DONE
[08:28:15.110] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[08:28:15.110] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[08:28:15.110] - globals: [1] ‘a’
[08:28:15.111] - packages: [1] ‘future’
[08:28:15.111] getGlobalsAndPackages() ... DONE
[08:28:15.111] run() for ‘Future’ ...
[08:28:15.111] - state: ‘created’
[08:28:15.111] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.116] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.116] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.116]   - Field: ‘label’
[08:28:15.117]   - Field: ‘local’
[08:28:15.117]   - Field: ‘owner’
[08:28:15.117]   - Field: ‘envir’
[08:28:15.117]   - Field: ‘workers’
[08:28:15.117]   - Field: ‘packages’
[08:28:15.117]   - Field: ‘gc’
[08:28:15.117]   - Field: ‘job’
[08:28:15.117]   - Field: ‘conditions’
[08:28:15.118]   - Field: ‘expr’
[08:28:15.118]   - Field: ‘uuid’
[08:28:15.118]   - Field: ‘seed’
[08:28:15.118]   - Field: ‘version’
[08:28:15.118]   - Field: ‘result’
[08:28:15.118]   - Field: ‘asynchronous’
[08:28:15.118]   - Field: ‘calls’
[08:28:15.118]   - Field: ‘globals’
[08:28:15.118]   - Field: ‘stdout’
[08:28:15.119]   - Field: ‘earlySignal’
[08:28:15.119]   - Field: ‘lazy’
[08:28:15.119]   - Field: ‘state’
[08:28:15.119] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.119] - Launch lazy future ...
[08:28:15.119] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.119] Packages needed by future strategies (n = 0): <none>
[08:28:15.120] {
[08:28:15.120]     {
[08:28:15.120]         {
[08:28:15.120]             ...future.startTime <- base::Sys.time()
[08:28:15.120]             {
[08:28:15.120]                 {
[08:28:15.120]                   {
[08:28:15.120]                     {
[08:28:15.120]                       {
[08:28:15.120]                         base::local({
[08:28:15.120]                           has_future <- base::requireNamespace("future", 
[08:28:15.120]                             quietly = TRUE)
[08:28:15.120]                           if (has_future) {
[08:28:15.120]                             ns <- base::getNamespace("future")
[08:28:15.120]                             version <- ns[[".package"]][["version"]]
[08:28:15.120]                             if (is.null(version)) 
[08:28:15.120]                               version <- utils::packageVersion("future")
[08:28:15.120]                           }
[08:28:15.120]                           else {
[08:28:15.120]                             version <- NULL
[08:28:15.120]                           }
[08:28:15.120]                           if (!has_future || version < "1.8.0") {
[08:28:15.120]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.120]                               "", base::R.version$version.string), 
[08:28:15.120]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.120]                                 base::R.version$platform, 8 * 
[08:28:15.120]                                   base::.Machine$sizeof.pointer), 
[08:28:15.120]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.120]                                 "release", "version")], collapse = " "), 
[08:28:15.120]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.120]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.120]                               info)
[08:28:15.120]                             info <- base::paste(info, collapse = "; ")
[08:28:15.120]                             if (!has_future) {
[08:28:15.120]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.120]                                 info)
[08:28:15.120]                             }
[08:28:15.120]                             else {
[08:28:15.120]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.120]                                 info, version)
[08:28:15.120]                             }
[08:28:15.120]                             base::stop(msg)
[08:28:15.120]                           }
[08:28:15.120]                         })
[08:28:15.120]                       }
[08:28:15.120]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.120]                       base::options(mc.cores = 1L)
[08:28:15.120]                     }
[08:28:15.120]                     base::local({
[08:28:15.120]                       for (pkg in "future") {
[08:28:15.120]                         base::loadNamespace(pkg)
[08:28:15.120]                         base::library(pkg, character.only = TRUE)
[08:28:15.120]                       }
[08:28:15.120]                     })
[08:28:15.120]                   }
[08:28:15.120]                   ...future.strategy.old <- future::plan("list")
[08:28:15.120]                   options(future.plan = NULL)
[08:28:15.120]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.120]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.120]                 }
[08:28:15.120]                 ...future.workdir <- getwd()
[08:28:15.120]             }
[08:28:15.120]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.120]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.120]         }
[08:28:15.120]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.120]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.120]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.120]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.120]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.120]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.120]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.120]             base::names(...future.oldOptions))
[08:28:15.120]     }
[08:28:15.120]     if (FALSE) {
[08:28:15.120]     }
[08:28:15.120]     else {
[08:28:15.120]         if (TRUE) {
[08:28:15.120]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.120]                 open = "w")
[08:28:15.120]         }
[08:28:15.120]         else {
[08:28:15.120]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.120]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.120]         }
[08:28:15.120]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.120]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.120]             base::sink(type = "output", split = FALSE)
[08:28:15.120]             base::close(...future.stdout)
[08:28:15.120]         }, add = TRUE)
[08:28:15.120]     }
[08:28:15.120]     ...future.frame <- base::sys.nframe()
[08:28:15.120]     ...future.conditions <- base::list()
[08:28:15.120]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.120]     if (FALSE) {
[08:28:15.120]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.120]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.120]     }
[08:28:15.120]     ...future.result <- base::tryCatch({
[08:28:15.120]         base::withCallingHandlers({
[08:28:15.120]             ...future.value <- base::withVisible(base::local({
[08:28:15.120]                 withCallingHandlers({
[08:28:15.120]                   value(a) + 1
[08:28:15.120]                 }, immediateCondition = function(cond) {
[08:28:15.120]                   save_rds <- function (object, pathname, ...) 
[08:28:15.120]                   {
[08:28:15.120]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.120]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.120]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.120]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.120]                         fi_tmp[["mtime"]])
[08:28:15.120]                     }
[08:28:15.120]                     tryCatch({
[08:28:15.120]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.120]                     }, error = function(ex) {
[08:28:15.120]                       msg <- conditionMessage(ex)
[08:28:15.120]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.120]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.120]                         fi_tmp[["mtime"]], msg)
[08:28:15.120]                       ex$message <- msg
[08:28:15.120]                       stop(ex)
[08:28:15.120]                     })
[08:28:15.120]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.120]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.120]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.120]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.120]                       fi <- file.info(pathname)
[08:28:15.120]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.120]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.120]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.120]                         fi[["size"]], fi[["mtime"]])
[08:28:15.120]                       stop(msg)
[08:28:15.120]                     }
[08:28:15.120]                     invisible(pathname)
[08:28:15.120]                   }
[08:28:15.120]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.120]                     rootPath = tempdir()) 
[08:28:15.120]                   {
[08:28:15.120]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.120]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.120]                       tmpdir = path, fileext = ".rds")
[08:28:15.120]                     save_rds(obj, file)
[08:28:15.120]                   }
[08:28:15.120]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.120]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.120]                   {
[08:28:15.120]                     inherits <- base::inherits
[08:28:15.120]                     invokeRestart <- base::invokeRestart
[08:28:15.120]                     is.null <- base::is.null
[08:28:15.120]                     muffled <- FALSE
[08:28:15.120]                     if (inherits(cond, "message")) {
[08:28:15.120]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.120]                       if (muffled) 
[08:28:15.120]                         invokeRestart("muffleMessage")
[08:28:15.120]                     }
[08:28:15.120]                     else if (inherits(cond, "warning")) {
[08:28:15.120]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.120]                       if (muffled) 
[08:28:15.120]                         invokeRestart("muffleWarning")
[08:28:15.120]                     }
[08:28:15.120]                     else if (inherits(cond, "condition")) {
[08:28:15.120]                       if (!is.null(pattern)) {
[08:28:15.120]                         computeRestarts <- base::computeRestarts
[08:28:15.120]                         grepl <- base::grepl
[08:28:15.120]                         restarts <- computeRestarts(cond)
[08:28:15.120]                         for (restart in restarts) {
[08:28:15.120]                           name <- restart$name
[08:28:15.120]                           if (is.null(name)) 
[08:28:15.120]                             next
[08:28:15.120]                           if (!grepl(pattern, name)) 
[08:28:15.120]                             next
[08:28:15.120]                           invokeRestart(restart)
[08:28:15.120]                           muffled <- TRUE
[08:28:15.120]                           break
[08:28:15.120]                         }
[08:28:15.120]                       }
[08:28:15.120]                     }
[08:28:15.120]                     invisible(muffled)
[08:28:15.120]                   }
[08:28:15.120]                   muffleCondition(cond)
[08:28:15.120]                 })
[08:28:15.120]             }))
[08:28:15.120]             future::FutureResult(value = ...future.value$value, 
[08:28:15.120]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.120]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.120]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.120]                     ...future.globalenv.names))
[08:28:15.120]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.120]         }, condition = base::local({
[08:28:15.120]             c <- base::c
[08:28:15.120]             inherits <- base::inherits
[08:28:15.120]             invokeRestart <- base::invokeRestart
[08:28:15.120]             length <- base::length
[08:28:15.120]             list <- base::list
[08:28:15.120]             seq.int <- base::seq.int
[08:28:15.120]             signalCondition <- base::signalCondition
[08:28:15.120]             sys.calls <- base::sys.calls
[08:28:15.120]             `[[` <- base::`[[`
[08:28:15.120]             `+` <- base::`+`
[08:28:15.120]             `<<-` <- base::`<<-`
[08:28:15.120]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.120]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.120]                   3L)]
[08:28:15.120]             }
[08:28:15.120]             function(cond) {
[08:28:15.120]                 is_error <- inherits(cond, "error")
[08:28:15.120]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.120]                   NULL)
[08:28:15.120]                 if (is_error) {
[08:28:15.120]                   sessionInformation <- function() {
[08:28:15.120]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.120]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.120]                       search = base::search(), system = base::Sys.info())
[08:28:15.120]                   }
[08:28:15.120]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.120]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.120]                     cond$call), session = sessionInformation(), 
[08:28:15.120]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.120]                   signalCondition(cond)
[08:28:15.120]                 }
[08:28:15.120]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.120]                 "immediateCondition"))) {
[08:28:15.120]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.120]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.120]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.120]                   if (TRUE && !signal) {
[08:28:15.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.120]                     {
[08:28:15.120]                       inherits <- base::inherits
[08:28:15.120]                       invokeRestart <- base::invokeRestart
[08:28:15.120]                       is.null <- base::is.null
[08:28:15.120]                       muffled <- FALSE
[08:28:15.120]                       if (inherits(cond, "message")) {
[08:28:15.120]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.120]                         if (muffled) 
[08:28:15.120]                           invokeRestart("muffleMessage")
[08:28:15.120]                       }
[08:28:15.120]                       else if (inherits(cond, "warning")) {
[08:28:15.120]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.120]                         if (muffled) 
[08:28:15.120]                           invokeRestart("muffleWarning")
[08:28:15.120]                       }
[08:28:15.120]                       else if (inherits(cond, "condition")) {
[08:28:15.120]                         if (!is.null(pattern)) {
[08:28:15.120]                           computeRestarts <- base::computeRestarts
[08:28:15.120]                           grepl <- base::grepl
[08:28:15.120]                           restarts <- computeRestarts(cond)
[08:28:15.120]                           for (restart in restarts) {
[08:28:15.120]                             name <- restart$name
[08:28:15.120]                             if (is.null(name)) 
[08:28:15.120]                               next
[08:28:15.120]                             if (!grepl(pattern, name)) 
[08:28:15.120]                               next
[08:28:15.120]                             invokeRestart(restart)
[08:28:15.120]                             muffled <- TRUE
[08:28:15.120]                             break
[08:28:15.120]                           }
[08:28:15.120]                         }
[08:28:15.120]                       }
[08:28:15.120]                       invisible(muffled)
[08:28:15.120]                     }
[08:28:15.120]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.120]                   }
[08:28:15.120]                 }
[08:28:15.120]                 else {
[08:28:15.120]                   if (TRUE) {
[08:28:15.120]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.120]                     {
[08:28:15.120]                       inherits <- base::inherits
[08:28:15.120]                       invokeRestart <- base::invokeRestart
[08:28:15.120]                       is.null <- base::is.null
[08:28:15.120]                       muffled <- FALSE
[08:28:15.120]                       if (inherits(cond, "message")) {
[08:28:15.120]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.120]                         if (muffled) 
[08:28:15.120]                           invokeRestart("muffleMessage")
[08:28:15.120]                       }
[08:28:15.120]                       else if (inherits(cond, "warning")) {
[08:28:15.120]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.120]                         if (muffled) 
[08:28:15.120]                           invokeRestart("muffleWarning")
[08:28:15.120]                       }
[08:28:15.120]                       else if (inherits(cond, "condition")) {
[08:28:15.120]                         if (!is.null(pattern)) {
[08:28:15.120]                           computeRestarts <- base::computeRestarts
[08:28:15.120]                           grepl <- base::grepl
[08:28:15.120]                           restarts <- computeRestarts(cond)
[08:28:15.120]                           for (restart in restarts) {
[08:28:15.120]                             name <- restart$name
[08:28:15.120]                             if (is.null(name)) 
[08:28:15.120]                               next
[08:28:15.120]                             if (!grepl(pattern, name)) 
[08:28:15.120]                               next
[08:28:15.120]                             invokeRestart(restart)
[08:28:15.120]                             muffled <- TRUE
[08:28:15.120]                             break
[08:28:15.120]                           }
[08:28:15.120]                         }
[08:28:15.120]                       }
[08:28:15.120]                       invisible(muffled)
[08:28:15.120]                     }
[08:28:15.120]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.120]                   }
[08:28:15.120]                 }
[08:28:15.120]             }
[08:28:15.120]         }))
[08:28:15.120]     }, error = function(ex) {
[08:28:15.120]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.120]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.120]                 ...future.rng), started = ...future.startTime, 
[08:28:15.120]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.120]             version = "1.8"), class = "FutureResult")
[08:28:15.120]     }, finally = {
[08:28:15.120]         if (!identical(...future.workdir, getwd())) 
[08:28:15.120]             setwd(...future.workdir)
[08:28:15.120]         {
[08:28:15.120]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.120]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.120]             }
[08:28:15.120]             base::options(...future.oldOptions)
[08:28:15.120]             if (.Platform$OS.type == "windows") {
[08:28:15.120]                 old_names <- names(...future.oldEnvVars)
[08:28:15.120]                 envs <- base::Sys.getenv()
[08:28:15.120]                 names <- names(envs)
[08:28:15.120]                 common <- intersect(names, old_names)
[08:28:15.120]                 added <- setdiff(names, old_names)
[08:28:15.120]                 removed <- setdiff(old_names, names)
[08:28:15.120]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.120]                   envs[common]]
[08:28:15.120]                 NAMES <- toupper(changed)
[08:28:15.120]                 args <- list()
[08:28:15.120]                 for (kk in seq_along(NAMES)) {
[08:28:15.120]                   name <- changed[[kk]]
[08:28:15.120]                   NAME <- NAMES[[kk]]
[08:28:15.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.120]                     next
[08:28:15.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.120]                 }
[08:28:15.120]                 NAMES <- toupper(added)
[08:28:15.120]                 for (kk in seq_along(NAMES)) {
[08:28:15.120]                   name <- added[[kk]]
[08:28:15.120]                   NAME <- NAMES[[kk]]
[08:28:15.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.120]                     next
[08:28:15.120]                   args[[name]] <- ""
[08:28:15.120]                 }
[08:28:15.120]                 NAMES <- toupper(removed)
[08:28:15.120]                 for (kk in seq_along(NAMES)) {
[08:28:15.120]                   name <- removed[[kk]]
[08:28:15.120]                   NAME <- NAMES[[kk]]
[08:28:15.120]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.120]                     next
[08:28:15.120]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.120]                 }
[08:28:15.120]                 if (length(args) > 0) 
[08:28:15.120]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.120]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.120]             }
[08:28:15.120]             else {
[08:28:15.120]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.120]             }
[08:28:15.120]             {
[08:28:15.120]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.120]                   0L) {
[08:28:15.120]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.120]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.120]                   base::options(opts)
[08:28:15.120]                 }
[08:28:15.120]                 {
[08:28:15.120]                   {
[08:28:15.120]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.120]                     NULL
[08:28:15.120]                   }
[08:28:15.120]                   options(future.plan = NULL)
[08:28:15.120]                   if (is.na(NA_character_)) 
[08:28:15.120]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.120]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.120]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.120]                     .init = FALSE)
[08:28:15.120]                 }
[08:28:15.120]             }
[08:28:15.120]         }
[08:28:15.120]     })
[08:28:15.120]     if (TRUE) {
[08:28:15.120]         base::sink(type = "output", split = FALSE)
[08:28:15.120]         if (TRUE) {
[08:28:15.120]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.120]         }
[08:28:15.120]         else {
[08:28:15.120]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.120]         }
[08:28:15.120]         base::close(...future.stdout)
[08:28:15.120]         ...future.stdout <- NULL
[08:28:15.120]     }
[08:28:15.120]     ...future.result$conditions <- ...future.conditions
[08:28:15.120]     ...future.result$finished <- base::Sys.time()
[08:28:15.120]     ...future.result
[08:28:15.120] }
[08:28:15.122] assign_globals() ...
[08:28:15.123] List of 1
[08:28:15.123]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a108104cc8> 
[08:28:15.123]  - attr(*, "where")=List of 1
[08:28:15.123]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.123]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.123]  - attr(*, "resolved")= logi TRUE
[08:28:15.123]  - attr(*, "total_size")= num 3815
[08:28:15.123]  - attr(*, "already-done")= logi TRUE
[08:28:15.125] - copied ‘a’ to environment
[08:28:15.126] assign_globals() ... done
[08:28:15.126] requestCore(): workers = 2
[08:28:15.127] MulticoreFuture started
[08:28:15.128] - Launch lazy future ... done
[08:28:15.128] run() for ‘MulticoreFuture’ ... done
[08:28:15.128] result() for MulticoreFuture ...
[08:28:15.129] plan(): Setting new future strategy stack:
[08:28:15.129] List of future strategies:
[08:28:15.129] 1. sequential:
[08:28:15.129]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.129]    - tweaked: FALSE
[08:28:15.129]    - call: NULL
[08:28:15.130] plan(): nbrOfWorkers() = 1
[08:28:15.133] plan(): Setting new future strategy stack:
[08:28:15.133] List of future strategies:
[08:28:15.133] 1. multicore:
[08:28:15.133]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.133]    - tweaked: FALSE
[08:28:15.133]    - call: plan(strategy)
[08:28:15.136] plan(): nbrOfWorkers() = 2
[08:28:15.137] result() for MulticoreFuture ...
[08:28:15.137] result() for MulticoreFuture ... done
[08:28:15.137] signalConditions() ...
[08:28:15.137]  - include = ‘immediateCondition’
[08:28:15.138]  - exclude = 
[08:28:15.138]  - resignal = FALSE
[08:28:15.138]  - Number of conditions: 4
[08:28:15.138] signalConditions() ... done
[08:28:15.138] result() for MulticoreFuture ... done
[08:28:15.138] result() for MulticoreFuture ...
[08:28:15.138] result() for MulticoreFuture ... done
[08:28:15.138] signalConditions() ...
[08:28:15.139]  - include = ‘immediateCondition’
[08:28:15.139]  - exclude = 
[08:28:15.139]  - resignal = FALSE
[08:28:15.139]  - Number of conditions: 4
[08:28:15.139] signalConditions() ... done
[08:28:15.139] Future state: ‘finished’
[08:28:15.139] result() for MulticoreFuture ...
[08:28:15.139] result() for MulticoreFuture ... done
[08:28:15.139] signalConditions() ...
[08:28:15.140]  - include = ‘condition’
[08:28:15.140]  - exclude = ‘immediateCondition’
[08:28:15.140]  - resignal = TRUE
[08:28:15.140]  - Number of conditions: 4
[08:28:15.140]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.131] result() for MulticoreFuture ...
[08:28:15.140]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.132] result() for MulticoreFuture ... done
[08:28:15.140]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.132] result() for MulticoreFuture ...
[08:28:15.140]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.132] result() for MulticoreFuture ... done
[08:28:15.141] signalConditions() ... done
value(b) = 2
[08:28:15.141] result() for MulticoreFuture ...
[08:28:15.141] result() for MulticoreFuture ... done
[08:28:15.141] result() for MulticoreFuture ...
[08:28:15.141] result() for MulticoreFuture ... done
[08:28:15.141] signalConditions() ...
[08:28:15.141]  - include = ‘immediateCondition’
[08:28:15.141]  - exclude = 
[08:28:15.142]  - resignal = FALSE
[08:28:15.142]  - Number of conditions: 4
[08:28:15.142] signalConditions() ... done
[08:28:15.142] Future state: ‘finished’
[08:28:15.142] result() for MulticoreFuture ...
[08:28:15.142] result() for MulticoreFuture ... done
[08:28:15.142] signalConditions() ...
[08:28:15.142]  - include = ‘condition’
[08:28:15.142]  - exclude = ‘immediateCondition’
[08:28:15.143]  - resignal = TRUE
[08:28:15.143]  - Number of conditions: 4
[08:28:15.143]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.131] result() for MulticoreFuture ...
[08:28:15.143]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.132] result() for MulticoreFuture ... done
[08:28:15.143]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.132] result() for MulticoreFuture ...
[08:28:15.143]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.132] result() for MulticoreFuture ... done
[08:28:15.143] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.144] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.144] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.145] 
[08:28:15.145] Searching for globals ... DONE
[08:28:15.145] - globals: [0] <none>
[08:28:15.145] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.145] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.146] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.147] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.147] Searching for globals ... DONE
[08:28:15.147] Resolving globals: TRUE
[08:28:15.147] Resolving any globals that are futures ...
[08:28:15.147] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.147] Resolving any globals that are futures ... DONE
[08:28:15.148] Resolving futures part of globals (recursively) ...
[08:28:15.148] resolve() on list ...
[08:28:15.148]  recursive: 99
[08:28:15.148]  length: 1
[08:28:15.150]  elements: ‘a’
[08:28:15.150] run() for ‘Future’ ...
[08:28:15.151] - state: ‘created’
[08:28:15.151] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.153] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.153] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.153]   - Field: ‘label’
[08:28:15.154]   - Field: ‘local’
[08:28:15.154]   - Field: ‘owner’
[08:28:15.154]   - Field: ‘envir’
[08:28:15.154]   - Field: ‘workers’
[08:28:15.154]   - Field: ‘packages’
[08:28:15.154]   - Field: ‘gc’
[08:28:15.154]   - Field: ‘job’
[08:28:15.154]   - Field: ‘conditions’
[08:28:15.155]   - Field: ‘expr’
[08:28:15.155]   - Field: ‘uuid’
[08:28:15.155]   - Field: ‘seed’
[08:28:15.155]   - Field: ‘version’
[08:28:15.155]   - Field: ‘result’
[08:28:15.155]   - Field: ‘asynchronous’
[08:28:15.155]   - Field: ‘calls’
[08:28:15.155]   - Field: ‘globals’
[08:28:15.155]   - Field: ‘stdout’
[08:28:15.156]   - Field: ‘earlySignal’
[08:28:15.156]   - Field: ‘lazy’
[08:28:15.156]   - Field: ‘state’
[08:28:15.156] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.156] - Launch lazy future ...
[08:28:15.156] Packages needed by the future expression (n = 0): <none>
[08:28:15.156] Packages needed by future strategies (n = 0): <none>
[08:28:15.157] {
[08:28:15.157]     {
[08:28:15.157]         {
[08:28:15.157]             ...future.startTime <- base::Sys.time()
[08:28:15.157]             {
[08:28:15.157]                 {
[08:28:15.157]                   {
[08:28:15.157]                     {
[08:28:15.157]                       base::local({
[08:28:15.157]                         has_future <- base::requireNamespace("future", 
[08:28:15.157]                           quietly = TRUE)
[08:28:15.157]                         if (has_future) {
[08:28:15.157]                           ns <- base::getNamespace("future")
[08:28:15.157]                           version <- ns[[".package"]][["version"]]
[08:28:15.157]                           if (is.null(version)) 
[08:28:15.157]                             version <- utils::packageVersion("future")
[08:28:15.157]                         }
[08:28:15.157]                         else {
[08:28:15.157]                           version <- NULL
[08:28:15.157]                         }
[08:28:15.157]                         if (!has_future || version < "1.8.0") {
[08:28:15.157]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.157]                             "", base::R.version$version.string), 
[08:28:15.157]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.157]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.157]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.157]                               "release", "version")], collapse = " "), 
[08:28:15.157]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.157]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.157]                             info)
[08:28:15.157]                           info <- base::paste(info, collapse = "; ")
[08:28:15.157]                           if (!has_future) {
[08:28:15.157]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.157]                               info)
[08:28:15.157]                           }
[08:28:15.157]                           else {
[08:28:15.157]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.157]                               info, version)
[08:28:15.157]                           }
[08:28:15.157]                           base::stop(msg)
[08:28:15.157]                         }
[08:28:15.157]                       })
[08:28:15.157]                     }
[08:28:15.157]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.157]                     base::options(mc.cores = 1L)
[08:28:15.157]                   }
[08:28:15.157]                   ...future.strategy.old <- future::plan("list")
[08:28:15.157]                   options(future.plan = NULL)
[08:28:15.157]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.157]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.157]                 }
[08:28:15.157]                 ...future.workdir <- getwd()
[08:28:15.157]             }
[08:28:15.157]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.157]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.157]         }
[08:28:15.157]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.157]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.157]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.157]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.157]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.157]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.157]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.157]             base::names(...future.oldOptions))
[08:28:15.157]     }
[08:28:15.157]     if (FALSE) {
[08:28:15.157]     }
[08:28:15.157]     else {
[08:28:15.157]         if (TRUE) {
[08:28:15.157]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.157]                 open = "w")
[08:28:15.157]         }
[08:28:15.157]         else {
[08:28:15.157]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.157]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.157]         }
[08:28:15.157]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.157]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.157]             base::sink(type = "output", split = FALSE)
[08:28:15.157]             base::close(...future.stdout)
[08:28:15.157]         }, add = TRUE)
[08:28:15.157]     }
[08:28:15.157]     ...future.frame <- base::sys.nframe()
[08:28:15.157]     ...future.conditions <- base::list()
[08:28:15.157]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.157]     if (FALSE) {
[08:28:15.157]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.157]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.157]     }
[08:28:15.157]     ...future.result <- base::tryCatch({
[08:28:15.157]         base::withCallingHandlers({
[08:28:15.157]             ...future.value <- base::withVisible(base::local({
[08:28:15.157]                 withCallingHandlers({
[08:28:15.157]                   1
[08:28:15.157]                 }, immediateCondition = function(cond) {
[08:28:15.157]                   save_rds <- function (object, pathname, ...) 
[08:28:15.157]                   {
[08:28:15.157]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.157]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.157]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.157]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.157]                         fi_tmp[["mtime"]])
[08:28:15.157]                     }
[08:28:15.157]                     tryCatch({
[08:28:15.157]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.157]                     }, error = function(ex) {
[08:28:15.157]                       msg <- conditionMessage(ex)
[08:28:15.157]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.157]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.157]                         fi_tmp[["mtime"]], msg)
[08:28:15.157]                       ex$message <- msg
[08:28:15.157]                       stop(ex)
[08:28:15.157]                     })
[08:28:15.157]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.157]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.157]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.157]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.157]                       fi <- file.info(pathname)
[08:28:15.157]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.157]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.157]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.157]                         fi[["size"]], fi[["mtime"]])
[08:28:15.157]                       stop(msg)
[08:28:15.157]                     }
[08:28:15.157]                     invisible(pathname)
[08:28:15.157]                   }
[08:28:15.157]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.157]                     rootPath = tempdir()) 
[08:28:15.157]                   {
[08:28:15.157]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.157]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.157]                       tmpdir = path, fileext = ".rds")
[08:28:15.157]                     save_rds(obj, file)
[08:28:15.157]                   }
[08:28:15.157]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.157]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.157]                   {
[08:28:15.157]                     inherits <- base::inherits
[08:28:15.157]                     invokeRestart <- base::invokeRestart
[08:28:15.157]                     is.null <- base::is.null
[08:28:15.157]                     muffled <- FALSE
[08:28:15.157]                     if (inherits(cond, "message")) {
[08:28:15.157]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.157]                       if (muffled) 
[08:28:15.157]                         invokeRestart("muffleMessage")
[08:28:15.157]                     }
[08:28:15.157]                     else if (inherits(cond, "warning")) {
[08:28:15.157]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.157]                       if (muffled) 
[08:28:15.157]                         invokeRestart("muffleWarning")
[08:28:15.157]                     }
[08:28:15.157]                     else if (inherits(cond, "condition")) {
[08:28:15.157]                       if (!is.null(pattern)) {
[08:28:15.157]                         computeRestarts <- base::computeRestarts
[08:28:15.157]                         grepl <- base::grepl
[08:28:15.157]                         restarts <- computeRestarts(cond)
[08:28:15.157]                         for (restart in restarts) {
[08:28:15.157]                           name <- restart$name
[08:28:15.157]                           if (is.null(name)) 
[08:28:15.157]                             next
[08:28:15.157]                           if (!grepl(pattern, name)) 
[08:28:15.157]                             next
[08:28:15.157]                           invokeRestart(restart)
[08:28:15.157]                           muffled <- TRUE
[08:28:15.157]                           break
[08:28:15.157]                         }
[08:28:15.157]                       }
[08:28:15.157]                     }
[08:28:15.157]                     invisible(muffled)
[08:28:15.157]                   }
[08:28:15.157]                   muffleCondition(cond)
[08:28:15.157]                 })
[08:28:15.157]             }))
[08:28:15.157]             future::FutureResult(value = ...future.value$value, 
[08:28:15.157]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.157]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.157]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.157]                     ...future.globalenv.names))
[08:28:15.157]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.157]         }, condition = base::local({
[08:28:15.157]             c <- base::c
[08:28:15.157]             inherits <- base::inherits
[08:28:15.157]             invokeRestart <- base::invokeRestart
[08:28:15.157]             length <- base::length
[08:28:15.157]             list <- base::list
[08:28:15.157]             seq.int <- base::seq.int
[08:28:15.157]             signalCondition <- base::signalCondition
[08:28:15.157]             sys.calls <- base::sys.calls
[08:28:15.157]             `[[` <- base::`[[`
[08:28:15.157]             `+` <- base::`+`
[08:28:15.157]             `<<-` <- base::`<<-`
[08:28:15.157]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.157]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.157]                   3L)]
[08:28:15.157]             }
[08:28:15.157]             function(cond) {
[08:28:15.157]                 is_error <- inherits(cond, "error")
[08:28:15.157]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.157]                   NULL)
[08:28:15.157]                 if (is_error) {
[08:28:15.157]                   sessionInformation <- function() {
[08:28:15.157]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.157]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.157]                       search = base::search(), system = base::Sys.info())
[08:28:15.157]                   }
[08:28:15.157]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.157]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.157]                     cond$call), session = sessionInformation(), 
[08:28:15.157]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.157]                   signalCondition(cond)
[08:28:15.157]                 }
[08:28:15.157]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.157]                 "immediateCondition"))) {
[08:28:15.157]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.157]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.157]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.157]                   if (TRUE && !signal) {
[08:28:15.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.157]                     {
[08:28:15.157]                       inherits <- base::inherits
[08:28:15.157]                       invokeRestart <- base::invokeRestart
[08:28:15.157]                       is.null <- base::is.null
[08:28:15.157]                       muffled <- FALSE
[08:28:15.157]                       if (inherits(cond, "message")) {
[08:28:15.157]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.157]                         if (muffled) 
[08:28:15.157]                           invokeRestart("muffleMessage")
[08:28:15.157]                       }
[08:28:15.157]                       else if (inherits(cond, "warning")) {
[08:28:15.157]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.157]                         if (muffled) 
[08:28:15.157]                           invokeRestart("muffleWarning")
[08:28:15.157]                       }
[08:28:15.157]                       else if (inherits(cond, "condition")) {
[08:28:15.157]                         if (!is.null(pattern)) {
[08:28:15.157]                           computeRestarts <- base::computeRestarts
[08:28:15.157]                           grepl <- base::grepl
[08:28:15.157]                           restarts <- computeRestarts(cond)
[08:28:15.157]                           for (restart in restarts) {
[08:28:15.157]                             name <- restart$name
[08:28:15.157]                             if (is.null(name)) 
[08:28:15.157]                               next
[08:28:15.157]                             if (!grepl(pattern, name)) 
[08:28:15.157]                               next
[08:28:15.157]                             invokeRestart(restart)
[08:28:15.157]                             muffled <- TRUE
[08:28:15.157]                             break
[08:28:15.157]                           }
[08:28:15.157]                         }
[08:28:15.157]                       }
[08:28:15.157]                       invisible(muffled)
[08:28:15.157]                     }
[08:28:15.157]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.157]                   }
[08:28:15.157]                 }
[08:28:15.157]                 else {
[08:28:15.157]                   if (TRUE) {
[08:28:15.157]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.157]                     {
[08:28:15.157]                       inherits <- base::inherits
[08:28:15.157]                       invokeRestart <- base::invokeRestart
[08:28:15.157]                       is.null <- base::is.null
[08:28:15.157]                       muffled <- FALSE
[08:28:15.157]                       if (inherits(cond, "message")) {
[08:28:15.157]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.157]                         if (muffled) 
[08:28:15.157]                           invokeRestart("muffleMessage")
[08:28:15.157]                       }
[08:28:15.157]                       else if (inherits(cond, "warning")) {
[08:28:15.157]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.157]                         if (muffled) 
[08:28:15.157]                           invokeRestart("muffleWarning")
[08:28:15.157]                       }
[08:28:15.157]                       else if (inherits(cond, "condition")) {
[08:28:15.157]                         if (!is.null(pattern)) {
[08:28:15.157]                           computeRestarts <- base::computeRestarts
[08:28:15.157]                           grepl <- base::grepl
[08:28:15.157]                           restarts <- computeRestarts(cond)
[08:28:15.157]                           for (restart in restarts) {
[08:28:15.157]                             name <- restart$name
[08:28:15.157]                             if (is.null(name)) 
[08:28:15.157]                               next
[08:28:15.157]                             if (!grepl(pattern, name)) 
[08:28:15.157]                               next
[08:28:15.157]                             invokeRestart(restart)
[08:28:15.157]                             muffled <- TRUE
[08:28:15.157]                             break
[08:28:15.157]                           }
[08:28:15.157]                         }
[08:28:15.157]                       }
[08:28:15.157]                       invisible(muffled)
[08:28:15.157]                     }
[08:28:15.157]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.157]                   }
[08:28:15.157]                 }
[08:28:15.157]             }
[08:28:15.157]         }))
[08:28:15.157]     }, error = function(ex) {
[08:28:15.157]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.157]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.157]                 ...future.rng), started = ...future.startTime, 
[08:28:15.157]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.157]             version = "1.8"), class = "FutureResult")
[08:28:15.157]     }, finally = {
[08:28:15.157]         if (!identical(...future.workdir, getwd())) 
[08:28:15.157]             setwd(...future.workdir)
[08:28:15.157]         {
[08:28:15.157]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.157]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.157]             }
[08:28:15.157]             base::options(...future.oldOptions)
[08:28:15.157]             if (.Platform$OS.type == "windows") {
[08:28:15.157]                 old_names <- names(...future.oldEnvVars)
[08:28:15.157]                 envs <- base::Sys.getenv()
[08:28:15.157]                 names <- names(envs)
[08:28:15.157]                 common <- intersect(names, old_names)
[08:28:15.157]                 added <- setdiff(names, old_names)
[08:28:15.157]                 removed <- setdiff(old_names, names)
[08:28:15.157]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.157]                   envs[common]]
[08:28:15.157]                 NAMES <- toupper(changed)
[08:28:15.157]                 args <- list()
[08:28:15.157]                 for (kk in seq_along(NAMES)) {
[08:28:15.157]                   name <- changed[[kk]]
[08:28:15.157]                   NAME <- NAMES[[kk]]
[08:28:15.157]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.157]                     next
[08:28:15.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.157]                 }
[08:28:15.157]                 NAMES <- toupper(added)
[08:28:15.157]                 for (kk in seq_along(NAMES)) {
[08:28:15.157]                   name <- added[[kk]]
[08:28:15.157]                   NAME <- NAMES[[kk]]
[08:28:15.157]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.157]                     next
[08:28:15.157]                   args[[name]] <- ""
[08:28:15.157]                 }
[08:28:15.157]                 NAMES <- toupper(removed)
[08:28:15.157]                 for (kk in seq_along(NAMES)) {
[08:28:15.157]                   name <- removed[[kk]]
[08:28:15.157]                   NAME <- NAMES[[kk]]
[08:28:15.157]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.157]                     next
[08:28:15.157]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.157]                 }
[08:28:15.157]                 if (length(args) > 0) 
[08:28:15.157]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.157]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.157]             }
[08:28:15.157]             else {
[08:28:15.157]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.157]             }
[08:28:15.157]             {
[08:28:15.157]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.157]                   0L) {
[08:28:15.157]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.157]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.157]                   base::options(opts)
[08:28:15.157]                 }
[08:28:15.157]                 {
[08:28:15.157]                   {
[08:28:15.157]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.157]                     NULL
[08:28:15.157]                   }
[08:28:15.157]                   options(future.plan = NULL)
[08:28:15.157]                   if (is.na(NA_character_)) 
[08:28:15.157]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.157]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.157]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.157]                     .init = FALSE)
[08:28:15.157]                 }
[08:28:15.157]             }
[08:28:15.157]         }
[08:28:15.157]     })
[08:28:15.157]     if (TRUE) {
[08:28:15.157]         base::sink(type = "output", split = FALSE)
[08:28:15.157]         if (TRUE) {
[08:28:15.157]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.157]         }
[08:28:15.157]         else {
[08:28:15.157]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.157]         }
[08:28:15.157]         base::close(...future.stdout)
[08:28:15.157]         ...future.stdout <- NULL
[08:28:15.157]     }
[08:28:15.157]     ...future.result$conditions <- ...future.conditions
[08:28:15.157]     ...future.result$finished <- base::Sys.time()
[08:28:15.157]     ...future.result
[08:28:15.157] }
[08:28:15.159] requestCore(): workers = 2
[08:28:15.161] MulticoreFuture started
[08:28:15.161] - Launch lazy future ... done
[08:28:15.162] run() for ‘MulticoreFuture’ ... done
[08:28:15.162] plan(): Setting new future strategy stack:
[08:28:15.162] List of future strategies:
[08:28:15.162] 1. sequential:
[08:28:15.162]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.162]    - tweaked: FALSE
[08:28:15.162]    - call: NULL
[08:28:15.163] plan(): nbrOfWorkers() = 1
[08:28:15.165] plan(): Setting new future strategy stack:
[08:28:15.166] List of future strategies:
[08:28:15.166] 1. multicore:
[08:28:15.166]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.166]    - tweaked: FALSE
[08:28:15.166]    - call: plan(strategy)
[08:28:15.169] plan(): nbrOfWorkers() = 2
[08:28:15.169] Future #1
[08:28:15.170] result() for MulticoreFuture ...
[08:28:15.171] result() for MulticoreFuture ...
[08:28:15.171] result() for MulticoreFuture ... done
[08:28:15.171] result() for MulticoreFuture ... done
[08:28:15.171] result() for MulticoreFuture ...
[08:28:15.171] result() for MulticoreFuture ... done
[08:28:15.171] A MulticoreFuture was resolved
[08:28:15.172]  length: 0 (resolved future 1)
[08:28:15.172] resolve() on list ... DONE
[08:28:15.172] - globals: [1] ‘a’
[08:28:15.172] Resolving futures part of globals (recursively) ... DONE
[08:28:15.172] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[08:28:15.173] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[08:28:15.173] - globals: [1] ‘a’
[08:28:15.173] - packages: [1] ‘future’
[08:28:15.173] getGlobalsAndPackages() ... DONE
[08:28:15.173] run() for ‘Future’ ...
[08:28:15.174] - state: ‘created’
[08:28:15.174] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.176] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.176] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.176]   - Field: ‘label’
[08:28:15.176]   - Field: ‘local’
[08:28:15.176]   - Field: ‘owner’
[08:28:15.177]   - Field: ‘envir’
[08:28:15.177]   - Field: ‘workers’
[08:28:15.177]   - Field: ‘packages’
[08:28:15.177]   - Field: ‘gc’
[08:28:15.177]   - Field: ‘job’
[08:28:15.177]   - Field: ‘conditions’
[08:28:15.177]   - Field: ‘expr’
[08:28:15.177]   - Field: ‘uuid’
[08:28:15.177]   - Field: ‘seed’
[08:28:15.178]   - Field: ‘version’
[08:28:15.178]   - Field: ‘result’
[08:28:15.178]   - Field: ‘asynchronous’
[08:28:15.178]   - Field: ‘calls’
[08:28:15.178]   - Field: ‘globals’
[08:28:15.178]   - Field: ‘stdout’
[08:28:15.178]   - Field: ‘earlySignal’
[08:28:15.178]   - Field: ‘lazy’
[08:28:15.178]   - Field: ‘state’
[08:28:15.179] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.179] - Launch lazy future ...
[08:28:15.179] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.179] Packages needed by future strategies (n = 0): <none>
[08:28:15.180] {
[08:28:15.180]     {
[08:28:15.180]         {
[08:28:15.180]             ...future.startTime <- base::Sys.time()
[08:28:15.180]             {
[08:28:15.180]                 {
[08:28:15.180]                   {
[08:28:15.180]                     {
[08:28:15.180]                       {
[08:28:15.180]                         base::local({
[08:28:15.180]                           has_future <- base::requireNamespace("future", 
[08:28:15.180]                             quietly = TRUE)
[08:28:15.180]                           if (has_future) {
[08:28:15.180]                             ns <- base::getNamespace("future")
[08:28:15.180]                             version <- ns[[".package"]][["version"]]
[08:28:15.180]                             if (is.null(version)) 
[08:28:15.180]                               version <- utils::packageVersion("future")
[08:28:15.180]                           }
[08:28:15.180]                           else {
[08:28:15.180]                             version <- NULL
[08:28:15.180]                           }
[08:28:15.180]                           if (!has_future || version < "1.8.0") {
[08:28:15.180]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.180]                               "", base::R.version$version.string), 
[08:28:15.180]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.180]                                 base::R.version$platform, 8 * 
[08:28:15.180]                                   base::.Machine$sizeof.pointer), 
[08:28:15.180]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.180]                                 "release", "version")], collapse = " "), 
[08:28:15.180]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.180]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.180]                               info)
[08:28:15.180]                             info <- base::paste(info, collapse = "; ")
[08:28:15.180]                             if (!has_future) {
[08:28:15.180]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.180]                                 info)
[08:28:15.180]                             }
[08:28:15.180]                             else {
[08:28:15.180]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.180]                                 info, version)
[08:28:15.180]                             }
[08:28:15.180]                             base::stop(msg)
[08:28:15.180]                           }
[08:28:15.180]                         })
[08:28:15.180]                       }
[08:28:15.180]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.180]                       base::options(mc.cores = 1L)
[08:28:15.180]                     }
[08:28:15.180]                     base::local({
[08:28:15.180]                       for (pkg in "future") {
[08:28:15.180]                         base::loadNamespace(pkg)
[08:28:15.180]                         base::library(pkg, character.only = TRUE)
[08:28:15.180]                       }
[08:28:15.180]                     })
[08:28:15.180]                   }
[08:28:15.180]                   ...future.strategy.old <- future::plan("list")
[08:28:15.180]                   options(future.plan = NULL)
[08:28:15.180]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.180]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.180]                 }
[08:28:15.180]                 ...future.workdir <- getwd()
[08:28:15.180]             }
[08:28:15.180]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.180]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.180]         }
[08:28:15.180]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.180]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.180]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.180]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.180]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.180]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.180]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.180]             base::names(...future.oldOptions))
[08:28:15.180]     }
[08:28:15.180]     if (FALSE) {
[08:28:15.180]     }
[08:28:15.180]     else {
[08:28:15.180]         if (TRUE) {
[08:28:15.180]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.180]                 open = "w")
[08:28:15.180]         }
[08:28:15.180]         else {
[08:28:15.180]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.180]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.180]         }
[08:28:15.180]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.180]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.180]             base::sink(type = "output", split = FALSE)
[08:28:15.180]             base::close(...future.stdout)
[08:28:15.180]         }, add = TRUE)
[08:28:15.180]     }
[08:28:15.180]     ...future.frame <- base::sys.nframe()
[08:28:15.180]     ...future.conditions <- base::list()
[08:28:15.180]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.180]     if (FALSE) {
[08:28:15.180]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.180]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.180]     }
[08:28:15.180]     ...future.result <- base::tryCatch({
[08:28:15.180]         base::withCallingHandlers({
[08:28:15.180]             ...future.value <- base::withVisible(base::local({
[08:28:15.180]                 withCallingHandlers({
[08:28:15.180]                   value(a) + 1
[08:28:15.180]                 }, immediateCondition = function(cond) {
[08:28:15.180]                   save_rds <- function (object, pathname, ...) 
[08:28:15.180]                   {
[08:28:15.180]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.180]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.180]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.180]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.180]                         fi_tmp[["mtime"]])
[08:28:15.180]                     }
[08:28:15.180]                     tryCatch({
[08:28:15.180]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.180]                     }, error = function(ex) {
[08:28:15.180]                       msg <- conditionMessage(ex)
[08:28:15.180]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.180]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.180]                         fi_tmp[["mtime"]], msg)
[08:28:15.180]                       ex$message <- msg
[08:28:15.180]                       stop(ex)
[08:28:15.180]                     })
[08:28:15.180]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.180]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.180]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.180]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.180]                       fi <- file.info(pathname)
[08:28:15.180]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.180]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.180]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.180]                         fi[["size"]], fi[["mtime"]])
[08:28:15.180]                       stop(msg)
[08:28:15.180]                     }
[08:28:15.180]                     invisible(pathname)
[08:28:15.180]                   }
[08:28:15.180]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.180]                     rootPath = tempdir()) 
[08:28:15.180]                   {
[08:28:15.180]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.180]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.180]                       tmpdir = path, fileext = ".rds")
[08:28:15.180]                     save_rds(obj, file)
[08:28:15.180]                   }
[08:28:15.180]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.180]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.180]                   {
[08:28:15.180]                     inherits <- base::inherits
[08:28:15.180]                     invokeRestart <- base::invokeRestart
[08:28:15.180]                     is.null <- base::is.null
[08:28:15.180]                     muffled <- FALSE
[08:28:15.180]                     if (inherits(cond, "message")) {
[08:28:15.180]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.180]                       if (muffled) 
[08:28:15.180]                         invokeRestart("muffleMessage")
[08:28:15.180]                     }
[08:28:15.180]                     else if (inherits(cond, "warning")) {
[08:28:15.180]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.180]                       if (muffled) 
[08:28:15.180]                         invokeRestart("muffleWarning")
[08:28:15.180]                     }
[08:28:15.180]                     else if (inherits(cond, "condition")) {
[08:28:15.180]                       if (!is.null(pattern)) {
[08:28:15.180]                         computeRestarts <- base::computeRestarts
[08:28:15.180]                         grepl <- base::grepl
[08:28:15.180]                         restarts <- computeRestarts(cond)
[08:28:15.180]                         for (restart in restarts) {
[08:28:15.180]                           name <- restart$name
[08:28:15.180]                           if (is.null(name)) 
[08:28:15.180]                             next
[08:28:15.180]                           if (!grepl(pattern, name)) 
[08:28:15.180]                             next
[08:28:15.180]                           invokeRestart(restart)
[08:28:15.180]                           muffled <- TRUE
[08:28:15.180]                           break
[08:28:15.180]                         }
[08:28:15.180]                       }
[08:28:15.180]                     }
[08:28:15.180]                     invisible(muffled)
[08:28:15.180]                   }
[08:28:15.180]                   muffleCondition(cond)
[08:28:15.180]                 })
[08:28:15.180]             }))
[08:28:15.180]             future::FutureResult(value = ...future.value$value, 
[08:28:15.180]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.180]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.180]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.180]                     ...future.globalenv.names))
[08:28:15.180]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.180]         }, condition = base::local({
[08:28:15.180]             c <- base::c
[08:28:15.180]             inherits <- base::inherits
[08:28:15.180]             invokeRestart <- base::invokeRestart
[08:28:15.180]             length <- base::length
[08:28:15.180]             list <- base::list
[08:28:15.180]             seq.int <- base::seq.int
[08:28:15.180]             signalCondition <- base::signalCondition
[08:28:15.180]             sys.calls <- base::sys.calls
[08:28:15.180]             `[[` <- base::`[[`
[08:28:15.180]             `+` <- base::`+`
[08:28:15.180]             `<<-` <- base::`<<-`
[08:28:15.180]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.180]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.180]                   3L)]
[08:28:15.180]             }
[08:28:15.180]             function(cond) {
[08:28:15.180]                 is_error <- inherits(cond, "error")
[08:28:15.180]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.180]                   NULL)
[08:28:15.180]                 if (is_error) {
[08:28:15.180]                   sessionInformation <- function() {
[08:28:15.180]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.180]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.180]                       search = base::search(), system = base::Sys.info())
[08:28:15.180]                   }
[08:28:15.180]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.180]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.180]                     cond$call), session = sessionInformation(), 
[08:28:15.180]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.180]                   signalCondition(cond)
[08:28:15.180]                 }
[08:28:15.180]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.180]                 "immediateCondition"))) {
[08:28:15.180]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.180]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.180]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.180]                   if (TRUE && !signal) {
[08:28:15.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.180]                     {
[08:28:15.180]                       inherits <- base::inherits
[08:28:15.180]                       invokeRestart <- base::invokeRestart
[08:28:15.180]                       is.null <- base::is.null
[08:28:15.180]                       muffled <- FALSE
[08:28:15.180]                       if (inherits(cond, "message")) {
[08:28:15.180]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.180]                         if (muffled) 
[08:28:15.180]                           invokeRestart("muffleMessage")
[08:28:15.180]                       }
[08:28:15.180]                       else if (inherits(cond, "warning")) {
[08:28:15.180]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.180]                         if (muffled) 
[08:28:15.180]                           invokeRestart("muffleWarning")
[08:28:15.180]                       }
[08:28:15.180]                       else if (inherits(cond, "condition")) {
[08:28:15.180]                         if (!is.null(pattern)) {
[08:28:15.180]                           computeRestarts <- base::computeRestarts
[08:28:15.180]                           grepl <- base::grepl
[08:28:15.180]                           restarts <- computeRestarts(cond)
[08:28:15.180]                           for (restart in restarts) {
[08:28:15.180]                             name <- restart$name
[08:28:15.180]                             if (is.null(name)) 
[08:28:15.180]                               next
[08:28:15.180]                             if (!grepl(pattern, name)) 
[08:28:15.180]                               next
[08:28:15.180]                             invokeRestart(restart)
[08:28:15.180]                             muffled <- TRUE
[08:28:15.180]                             break
[08:28:15.180]                           }
[08:28:15.180]                         }
[08:28:15.180]                       }
[08:28:15.180]                       invisible(muffled)
[08:28:15.180]                     }
[08:28:15.180]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.180]                   }
[08:28:15.180]                 }
[08:28:15.180]                 else {
[08:28:15.180]                   if (TRUE) {
[08:28:15.180]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.180]                     {
[08:28:15.180]                       inherits <- base::inherits
[08:28:15.180]                       invokeRestart <- base::invokeRestart
[08:28:15.180]                       is.null <- base::is.null
[08:28:15.180]                       muffled <- FALSE
[08:28:15.180]                       if (inherits(cond, "message")) {
[08:28:15.180]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.180]                         if (muffled) 
[08:28:15.180]                           invokeRestart("muffleMessage")
[08:28:15.180]                       }
[08:28:15.180]                       else if (inherits(cond, "warning")) {
[08:28:15.180]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.180]                         if (muffled) 
[08:28:15.180]                           invokeRestart("muffleWarning")
[08:28:15.180]                       }
[08:28:15.180]                       else if (inherits(cond, "condition")) {
[08:28:15.180]                         if (!is.null(pattern)) {
[08:28:15.180]                           computeRestarts <- base::computeRestarts
[08:28:15.180]                           grepl <- base::grepl
[08:28:15.180]                           restarts <- computeRestarts(cond)
[08:28:15.180]                           for (restart in restarts) {
[08:28:15.180]                             name <- restart$name
[08:28:15.180]                             if (is.null(name)) 
[08:28:15.180]                               next
[08:28:15.180]                             if (!grepl(pattern, name)) 
[08:28:15.180]                               next
[08:28:15.180]                             invokeRestart(restart)
[08:28:15.180]                             muffled <- TRUE
[08:28:15.180]                             break
[08:28:15.180]                           }
[08:28:15.180]                         }
[08:28:15.180]                       }
[08:28:15.180]                       invisible(muffled)
[08:28:15.180]                     }
[08:28:15.180]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.180]                   }
[08:28:15.180]                 }
[08:28:15.180]             }
[08:28:15.180]         }))
[08:28:15.180]     }, error = function(ex) {
[08:28:15.180]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.180]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.180]                 ...future.rng), started = ...future.startTime, 
[08:28:15.180]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.180]             version = "1.8"), class = "FutureResult")
[08:28:15.180]     }, finally = {
[08:28:15.180]         if (!identical(...future.workdir, getwd())) 
[08:28:15.180]             setwd(...future.workdir)
[08:28:15.180]         {
[08:28:15.180]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.180]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.180]             }
[08:28:15.180]             base::options(...future.oldOptions)
[08:28:15.180]             if (.Platform$OS.type == "windows") {
[08:28:15.180]                 old_names <- names(...future.oldEnvVars)
[08:28:15.180]                 envs <- base::Sys.getenv()
[08:28:15.180]                 names <- names(envs)
[08:28:15.180]                 common <- intersect(names, old_names)
[08:28:15.180]                 added <- setdiff(names, old_names)
[08:28:15.180]                 removed <- setdiff(old_names, names)
[08:28:15.180]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.180]                   envs[common]]
[08:28:15.180]                 NAMES <- toupper(changed)
[08:28:15.180]                 args <- list()
[08:28:15.180]                 for (kk in seq_along(NAMES)) {
[08:28:15.180]                   name <- changed[[kk]]
[08:28:15.180]                   NAME <- NAMES[[kk]]
[08:28:15.180]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.180]                     next
[08:28:15.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.180]                 }
[08:28:15.180]                 NAMES <- toupper(added)
[08:28:15.180]                 for (kk in seq_along(NAMES)) {
[08:28:15.180]                   name <- added[[kk]]
[08:28:15.180]                   NAME <- NAMES[[kk]]
[08:28:15.180]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.180]                     next
[08:28:15.180]                   args[[name]] <- ""
[08:28:15.180]                 }
[08:28:15.180]                 NAMES <- toupper(removed)
[08:28:15.180]                 for (kk in seq_along(NAMES)) {
[08:28:15.180]                   name <- removed[[kk]]
[08:28:15.180]                   NAME <- NAMES[[kk]]
[08:28:15.180]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.180]                     next
[08:28:15.180]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.180]                 }
[08:28:15.180]                 if (length(args) > 0) 
[08:28:15.180]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.180]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.180]             }
[08:28:15.180]             else {
[08:28:15.180]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.180]             }
[08:28:15.180]             {
[08:28:15.180]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.180]                   0L) {
[08:28:15.180]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.180]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.180]                   base::options(opts)
[08:28:15.180]                 }
[08:28:15.180]                 {
[08:28:15.180]                   {
[08:28:15.180]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.180]                     NULL
[08:28:15.180]                   }
[08:28:15.180]                   options(future.plan = NULL)
[08:28:15.180]                   if (is.na(NA_character_)) 
[08:28:15.180]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.180]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.180]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.180]                     .init = FALSE)
[08:28:15.180]                 }
[08:28:15.180]             }
[08:28:15.180]         }
[08:28:15.180]     })
[08:28:15.180]     if (TRUE) {
[08:28:15.180]         base::sink(type = "output", split = FALSE)
[08:28:15.180]         if (TRUE) {
[08:28:15.180]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.180]         }
[08:28:15.180]         else {
[08:28:15.180]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.180]         }
[08:28:15.180]         base::close(...future.stdout)
[08:28:15.180]         ...future.stdout <- NULL
[08:28:15.180]     }
[08:28:15.180]     ...future.result$conditions <- ...future.conditions
[08:28:15.180]     ...future.result$finished <- base::Sys.time()
[08:28:15.180]     ...future.result
[08:28:15.180] }
[08:28:15.182] assign_globals() ...
[08:28:15.183] List of 1
[08:28:15.183]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a109b05c88> 
[08:28:15.183]  - attr(*, "where")=List of 1
[08:28:15.183]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.183]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.183]  - attr(*, "resolved")= logi TRUE
[08:28:15.183]  - attr(*, "total_size")= num 3835
[08:28:15.183]  - attr(*, "already-done")= logi TRUE
[08:28:15.186] - copied ‘a’ to environment
[08:28:15.186] assign_globals() ... done
[08:28:15.186] requestCore(): workers = 2
[08:28:15.187] MulticoreFuture started
[08:28:15.188] - Launch lazy future ... done
[08:28:15.188] run() for ‘MulticoreFuture’ ... done
[08:28:15.188] result() for MulticoreFuture ...
[08:28:15.189] plan(): Setting new future strategy stack:
[08:28:15.189] List of future strategies:
[08:28:15.189] 1. sequential:
[08:28:15.189]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.189]    - tweaked: FALSE
[08:28:15.189]    - call: NULL
[08:28:15.190] plan(): nbrOfWorkers() = 1
[08:28:15.197] plan(): Setting new future strategy stack:
[08:28:15.197] List of future strategies:
[08:28:15.197] 1. multicore:
[08:28:15.197]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.197]    - tweaked: FALSE
[08:28:15.197]    - call: plan(strategy)
[08:28:15.202] plan(): nbrOfWorkers() = 2
[08:28:15.203] result() for MulticoreFuture ...
[08:28:15.203] result() for MulticoreFuture ... done
[08:28:15.203] signalConditions() ...
[08:28:15.203]  - include = ‘immediateCondition’
[08:28:15.203]  - exclude = 
[08:28:15.203]  - resignal = FALSE
[08:28:15.203]  - Number of conditions: 4
[08:28:15.203] signalConditions() ... done
[08:28:15.204] result() for MulticoreFuture ... done
[08:28:15.204] result() for MulticoreFuture ...
[08:28:15.204] result() for MulticoreFuture ... done
[08:28:15.204] signalConditions() ...
[08:28:15.204]  - include = ‘immediateCondition’
[08:28:15.206]  - exclude = 
[08:28:15.207]  - resignal = FALSE
[08:28:15.207]  - Number of conditions: 4
[08:28:15.207] signalConditions() ... done
[08:28:15.207] Future state: ‘finished’
[08:28:15.208] result() for MulticoreFuture ...
[08:28:15.208] result() for MulticoreFuture ... done
[08:28:15.208] signalConditions() ...
[08:28:15.208]  - include = ‘condition’
[08:28:15.208]  - exclude = ‘immediateCondition’
[08:28:15.209]  - resignal = TRUE
[08:28:15.209]  - Number of conditions: 4
[08:28:15.209]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.191] result() for MulticoreFuture ...
[08:28:15.209]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.191] result() for MulticoreFuture ... done
[08:28:15.209]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.191] result() for MulticoreFuture ...
[08:28:15.209]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.192] result() for MulticoreFuture ... done
[08:28:15.210] signalConditions() ... done
value(b) = 2
[08:28:15.210] result() for MulticoreFuture ...
[08:28:15.210] result() for MulticoreFuture ... done
[08:28:15.210] result() for MulticoreFuture ...
[08:28:15.210] result() for MulticoreFuture ... done
[08:28:15.210] signalConditions() ...
[08:28:15.210]  - include = ‘immediateCondition’
[08:28:15.210]  - exclude = 
[08:28:15.211]  - resignal = FALSE
[08:28:15.211]  - Number of conditions: 4
[08:28:15.211] signalConditions() ... done
[08:28:15.211] Future state: ‘finished’
[08:28:15.211] result() for MulticoreFuture ...
[08:28:15.211] result() for MulticoreFuture ... done
[08:28:15.211] signalConditions() ...
[08:28:15.211]  - include = ‘condition’
[08:28:15.212]  - exclude = ‘immediateCondition’
[08:28:15.212]  - resignal = TRUE
[08:28:15.212]  - Number of conditions: 4
[08:28:15.212]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.191] result() for MulticoreFuture ...
[08:28:15.212]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.191] result() for MulticoreFuture ... done
[08:28:15.212]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.191] result() for MulticoreFuture ...
[08:28:15.212]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.192] result() for MulticoreFuture ... done
[08:28:15.212] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.213] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.213] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.214] 
[08:28:15.214] Searching for globals ... DONE
[08:28:15.214] - globals: [0] <none>
[08:28:15.214] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.214] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.215] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.216] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.216] Searching for globals ... DONE
[08:28:15.216] Resolving globals: TRUE
[08:28:15.216] Resolving any globals that are futures ...
[08:28:15.216] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.216] Resolving any globals that are futures ... DONE
[08:28:15.217] Resolving futures part of globals (recursively) ...
[08:28:15.217] resolve() on list ...
[08:28:15.217]  recursive: 99
[08:28:15.217]  length: 1
[08:28:15.217]  elements: ‘a’
[08:28:15.217] run() for ‘Future’ ...
[08:28:15.217] - state: ‘created’
[08:28:15.218] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.219] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.220] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.220]   - Field: ‘label’
[08:28:15.220]   - Field: ‘local’
[08:28:15.220]   - Field: ‘owner’
[08:28:15.220]   - Field: ‘envir’
[08:28:15.220]   - Field: ‘workers’
[08:28:15.220]   - Field: ‘packages’
[08:28:15.220]   - Field: ‘gc’
[08:28:15.220]   - Field: ‘job’
[08:28:15.221]   - Field: ‘conditions’
[08:28:15.221]   - Field: ‘expr’
[08:28:15.221]   - Field: ‘uuid’
[08:28:15.221]   - Field: ‘seed’
[08:28:15.221]   - Field: ‘version’
[08:28:15.221]   - Field: ‘result’
[08:28:15.221]   - Field: ‘asynchronous’
[08:28:15.221]   - Field: ‘calls’
[08:28:15.221]   - Field: ‘globals’
[08:28:15.221]   - Field: ‘stdout’
[08:28:15.222]   - Field: ‘earlySignal’
[08:28:15.222]   - Field: ‘lazy’
[08:28:15.222]   - Field: ‘state’
[08:28:15.222] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.222] - Launch lazy future ...
[08:28:15.222] Packages needed by the future expression (n = 0): <none>
[08:28:15.222] Packages needed by future strategies (n = 0): <none>
[08:28:15.223] {
[08:28:15.223]     {
[08:28:15.223]         {
[08:28:15.223]             ...future.startTime <- base::Sys.time()
[08:28:15.223]             {
[08:28:15.223]                 {
[08:28:15.223]                   {
[08:28:15.223]                     {
[08:28:15.223]                       base::local({
[08:28:15.223]                         has_future <- base::requireNamespace("future", 
[08:28:15.223]                           quietly = TRUE)
[08:28:15.223]                         if (has_future) {
[08:28:15.223]                           ns <- base::getNamespace("future")
[08:28:15.223]                           version <- ns[[".package"]][["version"]]
[08:28:15.223]                           if (is.null(version)) 
[08:28:15.223]                             version <- utils::packageVersion("future")
[08:28:15.223]                         }
[08:28:15.223]                         else {
[08:28:15.223]                           version <- NULL
[08:28:15.223]                         }
[08:28:15.223]                         if (!has_future || version < "1.8.0") {
[08:28:15.223]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.223]                             "", base::R.version$version.string), 
[08:28:15.223]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.223]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.223]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.223]                               "release", "version")], collapse = " "), 
[08:28:15.223]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.223]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.223]                             info)
[08:28:15.223]                           info <- base::paste(info, collapse = "; ")
[08:28:15.223]                           if (!has_future) {
[08:28:15.223]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.223]                               info)
[08:28:15.223]                           }
[08:28:15.223]                           else {
[08:28:15.223]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.223]                               info, version)
[08:28:15.223]                           }
[08:28:15.223]                           base::stop(msg)
[08:28:15.223]                         }
[08:28:15.223]                       })
[08:28:15.223]                     }
[08:28:15.223]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.223]                     base::options(mc.cores = 1L)
[08:28:15.223]                   }
[08:28:15.223]                   ...future.strategy.old <- future::plan("list")
[08:28:15.223]                   options(future.plan = NULL)
[08:28:15.223]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.223]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.223]                 }
[08:28:15.223]                 ...future.workdir <- getwd()
[08:28:15.223]             }
[08:28:15.223]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.223]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.223]         }
[08:28:15.223]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.223]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.223]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.223]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.223]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.223]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.223]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.223]             base::names(...future.oldOptions))
[08:28:15.223]     }
[08:28:15.223]     if (FALSE) {
[08:28:15.223]     }
[08:28:15.223]     else {
[08:28:15.223]         if (TRUE) {
[08:28:15.223]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.223]                 open = "w")
[08:28:15.223]         }
[08:28:15.223]         else {
[08:28:15.223]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.223]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.223]         }
[08:28:15.223]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.223]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.223]             base::sink(type = "output", split = FALSE)
[08:28:15.223]             base::close(...future.stdout)
[08:28:15.223]         }, add = TRUE)
[08:28:15.223]     }
[08:28:15.223]     ...future.frame <- base::sys.nframe()
[08:28:15.223]     ...future.conditions <- base::list()
[08:28:15.223]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.223]     if (FALSE) {
[08:28:15.223]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.223]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.223]     }
[08:28:15.223]     ...future.result <- base::tryCatch({
[08:28:15.223]         base::withCallingHandlers({
[08:28:15.223]             ...future.value <- base::withVisible(base::local({
[08:28:15.223]                 withCallingHandlers({
[08:28:15.223]                   1
[08:28:15.223]                 }, immediateCondition = function(cond) {
[08:28:15.223]                   save_rds <- function (object, pathname, ...) 
[08:28:15.223]                   {
[08:28:15.223]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.223]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.223]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.223]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.223]                         fi_tmp[["mtime"]])
[08:28:15.223]                     }
[08:28:15.223]                     tryCatch({
[08:28:15.223]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.223]                     }, error = function(ex) {
[08:28:15.223]                       msg <- conditionMessage(ex)
[08:28:15.223]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.223]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.223]                         fi_tmp[["mtime"]], msg)
[08:28:15.223]                       ex$message <- msg
[08:28:15.223]                       stop(ex)
[08:28:15.223]                     })
[08:28:15.223]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.223]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.223]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.223]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.223]                       fi <- file.info(pathname)
[08:28:15.223]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.223]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.223]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.223]                         fi[["size"]], fi[["mtime"]])
[08:28:15.223]                       stop(msg)
[08:28:15.223]                     }
[08:28:15.223]                     invisible(pathname)
[08:28:15.223]                   }
[08:28:15.223]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.223]                     rootPath = tempdir()) 
[08:28:15.223]                   {
[08:28:15.223]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.223]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.223]                       tmpdir = path, fileext = ".rds")
[08:28:15.223]                     save_rds(obj, file)
[08:28:15.223]                   }
[08:28:15.223]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.223]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.223]                   {
[08:28:15.223]                     inherits <- base::inherits
[08:28:15.223]                     invokeRestart <- base::invokeRestart
[08:28:15.223]                     is.null <- base::is.null
[08:28:15.223]                     muffled <- FALSE
[08:28:15.223]                     if (inherits(cond, "message")) {
[08:28:15.223]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.223]                       if (muffled) 
[08:28:15.223]                         invokeRestart("muffleMessage")
[08:28:15.223]                     }
[08:28:15.223]                     else if (inherits(cond, "warning")) {
[08:28:15.223]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.223]                       if (muffled) 
[08:28:15.223]                         invokeRestart("muffleWarning")
[08:28:15.223]                     }
[08:28:15.223]                     else if (inherits(cond, "condition")) {
[08:28:15.223]                       if (!is.null(pattern)) {
[08:28:15.223]                         computeRestarts <- base::computeRestarts
[08:28:15.223]                         grepl <- base::grepl
[08:28:15.223]                         restarts <- computeRestarts(cond)
[08:28:15.223]                         for (restart in restarts) {
[08:28:15.223]                           name <- restart$name
[08:28:15.223]                           if (is.null(name)) 
[08:28:15.223]                             next
[08:28:15.223]                           if (!grepl(pattern, name)) 
[08:28:15.223]                             next
[08:28:15.223]                           invokeRestart(restart)
[08:28:15.223]                           muffled <- TRUE
[08:28:15.223]                           break
[08:28:15.223]                         }
[08:28:15.223]                       }
[08:28:15.223]                     }
[08:28:15.223]                     invisible(muffled)
[08:28:15.223]                   }
[08:28:15.223]                   muffleCondition(cond)
[08:28:15.223]                 })
[08:28:15.223]             }))
[08:28:15.223]             future::FutureResult(value = ...future.value$value, 
[08:28:15.223]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.223]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.223]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.223]                     ...future.globalenv.names))
[08:28:15.223]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.223]         }, condition = base::local({
[08:28:15.223]             c <- base::c
[08:28:15.223]             inherits <- base::inherits
[08:28:15.223]             invokeRestart <- base::invokeRestart
[08:28:15.223]             length <- base::length
[08:28:15.223]             list <- base::list
[08:28:15.223]             seq.int <- base::seq.int
[08:28:15.223]             signalCondition <- base::signalCondition
[08:28:15.223]             sys.calls <- base::sys.calls
[08:28:15.223]             `[[` <- base::`[[`
[08:28:15.223]             `+` <- base::`+`
[08:28:15.223]             `<<-` <- base::`<<-`
[08:28:15.223]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.223]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.223]                   3L)]
[08:28:15.223]             }
[08:28:15.223]             function(cond) {
[08:28:15.223]                 is_error <- inherits(cond, "error")
[08:28:15.223]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.223]                   NULL)
[08:28:15.223]                 if (is_error) {
[08:28:15.223]                   sessionInformation <- function() {
[08:28:15.223]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.223]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.223]                       search = base::search(), system = base::Sys.info())
[08:28:15.223]                   }
[08:28:15.223]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.223]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.223]                     cond$call), session = sessionInformation(), 
[08:28:15.223]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.223]                   signalCondition(cond)
[08:28:15.223]                 }
[08:28:15.223]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.223]                 "immediateCondition"))) {
[08:28:15.223]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.223]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.223]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.223]                   if (TRUE && !signal) {
[08:28:15.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.223]                     {
[08:28:15.223]                       inherits <- base::inherits
[08:28:15.223]                       invokeRestart <- base::invokeRestart
[08:28:15.223]                       is.null <- base::is.null
[08:28:15.223]                       muffled <- FALSE
[08:28:15.223]                       if (inherits(cond, "message")) {
[08:28:15.223]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.223]                         if (muffled) 
[08:28:15.223]                           invokeRestart("muffleMessage")
[08:28:15.223]                       }
[08:28:15.223]                       else if (inherits(cond, "warning")) {
[08:28:15.223]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.223]                         if (muffled) 
[08:28:15.223]                           invokeRestart("muffleWarning")
[08:28:15.223]                       }
[08:28:15.223]                       else if (inherits(cond, "condition")) {
[08:28:15.223]                         if (!is.null(pattern)) {
[08:28:15.223]                           computeRestarts <- base::computeRestarts
[08:28:15.223]                           grepl <- base::grepl
[08:28:15.223]                           restarts <- computeRestarts(cond)
[08:28:15.223]                           for (restart in restarts) {
[08:28:15.223]                             name <- restart$name
[08:28:15.223]                             if (is.null(name)) 
[08:28:15.223]                               next
[08:28:15.223]                             if (!grepl(pattern, name)) 
[08:28:15.223]                               next
[08:28:15.223]                             invokeRestart(restart)
[08:28:15.223]                             muffled <- TRUE
[08:28:15.223]                             break
[08:28:15.223]                           }
[08:28:15.223]                         }
[08:28:15.223]                       }
[08:28:15.223]                       invisible(muffled)
[08:28:15.223]                     }
[08:28:15.223]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.223]                   }
[08:28:15.223]                 }
[08:28:15.223]                 else {
[08:28:15.223]                   if (TRUE) {
[08:28:15.223]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.223]                     {
[08:28:15.223]                       inherits <- base::inherits
[08:28:15.223]                       invokeRestart <- base::invokeRestart
[08:28:15.223]                       is.null <- base::is.null
[08:28:15.223]                       muffled <- FALSE
[08:28:15.223]                       if (inherits(cond, "message")) {
[08:28:15.223]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.223]                         if (muffled) 
[08:28:15.223]                           invokeRestart("muffleMessage")
[08:28:15.223]                       }
[08:28:15.223]                       else if (inherits(cond, "warning")) {
[08:28:15.223]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.223]                         if (muffled) 
[08:28:15.223]                           invokeRestart("muffleWarning")
[08:28:15.223]                       }
[08:28:15.223]                       else if (inherits(cond, "condition")) {
[08:28:15.223]                         if (!is.null(pattern)) {
[08:28:15.223]                           computeRestarts <- base::computeRestarts
[08:28:15.223]                           grepl <- base::grepl
[08:28:15.223]                           restarts <- computeRestarts(cond)
[08:28:15.223]                           for (restart in restarts) {
[08:28:15.223]                             name <- restart$name
[08:28:15.223]                             if (is.null(name)) 
[08:28:15.223]                               next
[08:28:15.223]                             if (!grepl(pattern, name)) 
[08:28:15.223]                               next
[08:28:15.223]                             invokeRestart(restart)
[08:28:15.223]                             muffled <- TRUE
[08:28:15.223]                             break
[08:28:15.223]                           }
[08:28:15.223]                         }
[08:28:15.223]                       }
[08:28:15.223]                       invisible(muffled)
[08:28:15.223]                     }
[08:28:15.223]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.223]                   }
[08:28:15.223]                 }
[08:28:15.223]             }
[08:28:15.223]         }))
[08:28:15.223]     }, error = function(ex) {
[08:28:15.223]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.223]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.223]                 ...future.rng), started = ...future.startTime, 
[08:28:15.223]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.223]             version = "1.8"), class = "FutureResult")
[08:28:15.223]     }, finally = {
[08:28:15.223]         if (!identical(...future.workdir, getwd())) 
[08:28:15.223]             setwd(...future.workdir)
[08:28:15.223]         {
[08:28:15.223]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.223]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.223]             }
[08:28:15.223]             base::options(...future.oldOptions)
[08:28:15.223]             if (.Platform$OS.type == "windows") {
[08:28:15.223]                 old_names <- names(...future.oldEnvVars)
[08:28:15.223]                 envs <- base::Sys.getenv()
[08:28:15.223]                 names <- names(envs)
[08:28:15.223]                 common <- intersect(names, old_names)
[08:28:15.223]                 added <- setdiff(names, old_names)
[08:28:15.223]                 removed <- setdiff(old_names, names)
[08:28:15.223]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.223]                   envs[common]]
[08:28:15.223]                 NAMES <- toupper(changed)
[08:28:15.223]                 args <- list()
[08:28:15.223]                 for (kk in seq_along(NAMES)) {
[08:28:15.223]                   name <- changed[[kk]]
[08:28:15.223]                   NAME <- NAMES[[kk]]
[08:28:15.223]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.223]                     next
[08:28:15.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.223]                 }
[08:28:15.223]                 NAMES <- toupper(added)
[08:28:15.223]                 for (kk in seq_along(NAMES)) {
[08:28:15.223]                   name <- added[[kk]]
[08:28:15.223]                   NAME <- NAMES[[kk]]
[08:28:15.223]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.223]                     next
[08:28:15.223]                   args[[name]] <- ""
[08:28:15.223]                 }
[08:28:15.223]                 NAMES <- toupper(removed)
[08:28:15.223]                 for (kk in seq_along(NAMES)) {
[08:28:15.223]                   name <- removed[[kk]]
[08:28:15.223]                   NAME <- NAMES[[kk]]
[08:28:15.223]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.223]                     next
[08:28:15.223]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.223]                 }
[08:28:15.223]                 if (length(args) > 0) 
[08:28:15.223]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.223]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.223]             }
[08:28:15.223]             else {
[08:28:15.223]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.223]             }
[08:28:15.223]             {
[08:28:15.223]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.223]                   0L) {
[08:28:15.223]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.223]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.223]                   base::options(opts)
[08:28:15.223]                 }
[08:28:15.223]                 {
[08:28:15.223]                   {
[08:28:15.223]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.223]                     NULL
[08:28:15.223]                   }
[08:28:15.223]                   options(future.plan = NULL)
[08:28:15.223]                   if (is.na(NA_character_)) 
[08:28:15.223]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.223]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.223]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.223]                     .init = FALSE)
[08:28:15.223]                 }
[08:28:15.223]             }
[08:28:15.223]         }
[08:28:15.223]     })
[08:28:15.223]     if (TRUE) {
[08:28:15.223]         base::sink(type = "output", split = FALSE)
[08:28:15.223]         if (TRUE) {
[08:28:15.223]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.223]         }
[08:28:15.223]         else {
[08:28:15.223]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.223]         }
[08:28:15.223]         base::close(...future.stdout)
[08:28:15.223]         ...future.stdout <- NULL
[08:28:15.223]     }
[08:28:15.223]     ...future.result$conditions <- ...future.conditions
[08:28:15.223]     ...future.result$finished <- base::Sys.time()
[08:28:15.223]     ...future.result
[08:28:15.223] }
[08:28:15.225] requestCore(): workers = 2
[08:28:15.227] MulticoreFuture started
[08:28:15.227] - Launch lazy future ... done
[08:28:15.228] run() for ‘MulticoreFuture’ ... done
[08:28:15.228] plan(): Setting new future strategy stack:
[08:28:15.228] List of future strategies:
[08:28:15.228] 1. sequential:
[08:28:15.228]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.228]    - tweaked: FALSE
[08:28:15.228]    - call: NULL
[08:28:15.229] plan(): nbrOfWorkers() = 1
[08:28:15.232] plan(): Setting new future strategy stack:
[08:28:15.232] List of future strategies:
[08:28:15.232] 1. multicore:
[08:28:15.232]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.232]    - tweaked: FALSE
[08:28:15.232]    - call: plan(strategy)
[08:28:15.235] plan(): nbrOfWorkers() = 2
[08:28:15.235] Future #1
[08:28:15.236] result() for MulticoreFuture ...
[08:28:15.237] result() for MulticoreFuture ...
[08:28:15.237] result() for MulticoreFuture ... done
[08:28:15.237] result() for MulticoreFuture ... done
[08:28:15.237] result() for MulticoreFuture ...
[08:28:15.237] result() for MulticoreFuture ... done
[08:28:15.237] A MulticoreFuture was resolved
[08:28:15.238]  length: 0 (resolved future 1)
[08:28:15.238] resolve() on list ... DONE
[08:28:15.238] - globals: [1] ‘a’
[08:28:15.238] Resolving futures part of globals (recursively) ... DONE
[08:28:15.238] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[08:28:15.239] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[08:28:15.239] - globals: [1] ‘a’
[08:28:15.239] - packages: [1] ‘future’
[08:28:15.239] getGlobalsAndPackages() ... DONE
[08:28:15.240] run() for ‘Future’ ...
[08:28:15.240] - state: ‘created’
[08:28:15.240] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.244] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.245] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.245]   - Field: ‘label’
[08:28:15.245]   - Field: ‘local’
[08:28:15.246]   - Field: ‘owner’
[08:28:15.246]   - Field: ‘envir’
[08:28:15.246]   - Field: ‘workers’
[08:28:15.246]   - Field: ‘packages’
[08:28:15.246]   - Field: ‘gc’
[08:28:15.246]   - Field: ‘job’
[08:28:15.247]   - Field: ‘conditions’
[08:28:15.247]   - Field: ‘expr’
[08:28:15.247]   - Field: ‘uuid’
[08:28:15.247]   - Field: ‘seed’
[08:28:15.247]   - Field: ‘version’
[08:28:15.247]   - Field: ‘result’
[08:28:15.247]   - Field: ‘asynchronous’
[08:28:15.247]   - Field: ‘calls’
[08:28:15.248]   - Field: ‘globals’
[08:28:15.248]   - Field: ‘stdout’
[08:28:15.248]   - Field: ‘earlySignal’
[08:28:15.248]   - Field: ‘lazy’
[08:28:15.248]   - Field: ‘state’
[08:28:15.248] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.248] - Launch lazy future ...
[08:28:15.249] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.249] Packages needed by future strategies (n = 0): <none>
[08:28:15.250] {
[08:28:15.250]     {
[08:28:15.250]         {
[08:28:15.250]             ...future.startTime <- base::Sys.time()
[08:28:15.250]             {
[08:28:15.250]                 {
[08:28:15.250]                   {
[08:28:15.250]                     {
[08:28:15.250]                       {
[08:28:15.250]                         base::local({
[08:28:15.250]                           has_future <- base::requireNamespace("future", 
[08:28:15.250]                             quietly = TRUE)
[08:28:15.250]                           if (has_future) {
[08:28:15.250]                             ns <- base::getNamespace("future")
[08:28:15.250]                             version <- ns[[".package"]][["version"]]
[08:28:15.250]                             if (is.null(version)) 
[08:28:15.250]                               version <- utils::packageVersion("future")
[08:28:15.250]                           }
[08:28:15.250]                           else {
[08:28:15.250]                             version <- NULL
[08:28:15.250]                           }
[08:28:15.250]                           if (!has_future || version < "1.8.0") {
[08:28:15.250]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.250]                               "", base::R.version$version.string), 
[08:28:15.250]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.250]                                 base::R.version$platform, 8 * 
[08:28:15.250]                                   base::.Machine$sizeof.pointer), 
[08:28:15.250]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.250]                                 "release", "version")], collapse = " "), 
[08:28:15.250]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.250]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.250]                               info)
[08:28:15.250]                             info <- base::paste(info, collapse = "; ")
[08:28:15.250]                             if (!has_future) {
[08:28:15.250]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.250]                                 info)
[08:28:15.250]                             }
[08:28:15.250]                             else {
[08:28:15.250]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.250]                                 info, version)
[08:28:15.250]                             }
[08:28:15.250]                             base::stop(msg)
[08:28:15.250]                           }
[08:28:15.250]                         })
[08:28:15.250]                       }
[08:28:15.250]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.250]                       base::options(mc.cores = 1L)
[08:28:15.250]                     }
[08:28:15.250]                     base::local({
[08:28:15.250]                       for (pkg in "future") {
[08:28:15.250]                         base::loadNamespace(pkg)
[08:28:15.250]                         base::library(pkg, character.only = TRUE)
[08:28:15.250]                       }
[08:28:15.250]                     })
[08:28:15.250]                   }
[08:28:15.250]                   ...future.strategy.old <- future::plan("list")
[08:28:15.250]                   options(future.plan = NULL)
[08:28:15.250]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.250]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.250]                 }
[08:28:15.250]                 ...future.workdir <- getwd()
[08:28:15.250]             }
[08:28:15.250]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.250]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.250]         }
[08:28:15.250]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.250]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.250]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.250]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.250]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.250]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.250]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.250]             base::names(...future.oldOptions))
[08:28:15.250]     }
[08:28:15.250]     if (FALSE) {
[08:28:15.250]     }
[08:28:15.250]     else {
[08:28:15.250]         if (TRUE) {
[08:28:15.250]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.250]                 open = "w")
[08:28:15.250]         }
[08:28:15.250]         else {
[08:28:15.250]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.250]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.250]         }
[08:28:15.250]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.250]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.250]             base::sink(type = "output", split = FALSE)
[08:28:15.250]             base::close(...future.stdout)
[08:28:15.250]         }, add = TRUE)
[08:28:15.250]     }
[08:28:15.250]     ...future.frame <- base::sys.nframe()
[08:28:15.250]     ...future.conditions <- base::list()
[08:28:15.250]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.250]     if (FALSE) {
[08:28:15.250]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.250]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.250]     }
[08:28:15.250]     ...future.result <- base::tryCatch({
[08:28:15.250]         base::withCallingHandlers({
[08:28:15.250]             ...future.value <- base::withVisible(base::local({
[08:28:15.250]                 withCallingHandlers({
[08:28:15.250]                   value(a) + 1
[08:28:15.250]                 }, immediateCondition = function(cond) {
[08:28:15.250]                   save_rds <- function (object, pathname, ...) 
[08:28:15.250]                   {
[08:28:15.250]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.250]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.250]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.250]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.250]                         fi_tmp[["mtime"]])
[08:28:15.250]                     }
[08:28:15.250]                     tryCatch({
[08:28:15.250]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.250]                     }, error = function(ex) {
[08:28:15.250]                       msg <- conditionMessage(ex)
[08:28:15.250]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.250]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.250]                         fi_tmp[["mtime"]], msg)
[08:28:15.250]                       ex$message <- msg
[08:28:15.250]                       stop(ex)
[08:28:15.250]                     })
[08:28:15.250]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.250]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.250]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.250]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.250]                       fi <- file.info(pathname)
[08:28:15.250]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.250]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.250]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.250]                         fi[["size"]], fi[["mtime"]])
[08:28:15.250]                       stop(msg)
[08:28:15.250]                     }
[08:28:15.250]                     invisible(pathname)
[08:28:15.250]                   }
[08:28:15.250]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.250]                     rootPath = tempdir()) 
[08:28:15.250]                   {
[08:28:15.250]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.250]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.250]                       tmpdir = path, fileext = ".rds")
[08:28:15.250]                     save_rds(obj, file)
[08:28:15.250]                   }
[08:28:15.250]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.250]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.250]                   {
[08:28:15.250]                     inherits <- base::inherits
[08:28:15.250]                     invokeRestart <- base::invokeRestart
[08:28:15.250]                     is.null <- base::is.null
[08:28:15.250]                     muffled <- FALSE
[08:28:15.250]                     if (inherits(cond, "message")) {
[08:28:15.250]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.250]                       if (muffled) 
[08:28:15.250]                         invokeRestart("muffleMessage")
[08:28:15.250]                     }
[08:28:15.250]                     else if (inherits(cond, "warning")) {
[08:28:15.250]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.250]                       if (muffled) 
[08:28:15.250]                         invokeRestart("muffleWarning")
[08:28:15.250]                     }
[08:28:15.250]                     else if (inherits(cond, "condition")) {
[08:28:15.250]                       if (!is.null(pattern)) {
[08:28:15.250]                         computeRestarts <- base::computeRestarts
[08:28:15.250]                         grepl <- base::grepl
[08:28:15.250]                         restarts <- computeRestarts(cond)
[08:28:15.250]                         for (restart in restarts) {
[08:28:15.250]                           name <- restart$name
[08:28:15.250]                           if (is.null(name)) 
[08:28:15.250]                             next
[08:28:15.250]                           if (!grepl(pattern, name)) 
[08:28:15.250]                             next
[08:28:15.250]                           invokeRestart(restart)
[08:28:15.250]                           muffled <- TRUE
[08:28:15.250]                           break
[08:28:15.250]                         }
[08:28:15.250]                       }
[08:28:15.250]                     }
[08:28:15.250]                     invisible(muffled)
[08:28:15.250]                   }
[08:28:15.250]                   muffleCondition(cond)
[08:28:15.250]                 })
[08:28:15.250]             }))
[08:28:15.250]             future::FutureResult(value = ...future.value$value, 
[08:28:15.250]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.250]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.250]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.250]                     ...future.globalenv.names))
[08:28:15.250]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.250]         }, condition = base::local({
[08:28:15.250]             c <- base::c
[08:28:15.250]             inherits <- base::inherits
[08:28:15.250]             invokeRestart <- base::invokeRestart
[08:28:15.250]             length <- base::length
[08:28:15.250]             list <- base::list
[08:28:15.250]             seq.int <- base::seq.int
[08:28:15.250]             signalCondition <- base::signalCondition
[08:28:15.250]             sys.calls <- base::sys.calls
[08:28:15.250]             `[[` <- base::`[[`
[08:28:15.250]             `+` <- base::`+`
[08:28:15.250]             `<<-` <- base::`<<-`
[08:28:15.250]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.250]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.250]                   3L)]
[08:28:15.250]             }
[08:28:15.250]             function(cond) {
[08:28:15.250]                 is_error <- inherits(cond, "error")
[08:28:15.250]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.250]                   NULL)
[08:28:15.250]                 if (is_error) {
[08:28:15.250]                   sessionInformation <- function() {
[08:28:15.250]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.250]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.250]                       search = base::search(), system = base::Sys.info())
[08:28:15.250]                   }
[08:28:15.250]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.250]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.250]                     cond$call), session = sessionInformation(), 
[08:28:15.250]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.250]                   signalCondition(cond)
[08:28:15.250]                 }
[08:28:15.250]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.250]                 "immediateCondition"))) {
[08:28:15.250]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.250]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.250]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.250]                   if (TRUE && !signal) {
[08:28:15.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.250]                     {
[08:28:15.250]                       inherits <- base::inherits
[08:28:15.250]                       invokeRestart <- base::invokeRestart
[08:28:15.250]                       is.null <- base::is.null
[08:28:15.250]                       muffled <- FALSE
[08:28:15.250]                       if (inherits(cond, "message")) {
[08:28:15.250]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.250]                         if (muffled) 
[08:28:15.250]                           invokeRestart("muffleMessage")
[08:28:15.250]                       }
[08:28:15.250]                       else if (inherits(cond, "warning")) {
[08:28:15.250]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.250]                         if (muffled) 
[08:28:15.250]                           invokeRestart("muffleWarning")
[08:28:15.250]                       }
[08:28:15.250]                       else if (inherits(cond, "condition")) {
[08:28:15.250]                         if (!is.null(pattern)) {
[08:28:15.250]                           computeRestarts <- base::computeRestarts
[08:28:15.250]                           grepl <- base::grepl
[08:28:15.250]                           restarts <- computeRestarts(cond)
[08:28:15.250]                           for (restart in restarts) {
[08:28:15.250]                             name <- restart$name
[08:28:15.250]                             if (is.null(name)) 
[08:28:15.250]                               next
[08:28:15.250]                             if (!grepl(pattern, name)) 
[08:28:15.250]                               next
[08:28:15.250]                             invokeRestart(restart)
[08:28:15.250]                             muffled <- TRUE
[08:28:15.250]                             break
[08:28:15.250]                           }
[08:28:15.250]                         }
[08:28:15.250]                       }
[08:28:15.250]                       invisible(muffled)
[08:28:15.250]                     }
[08:28:15.250]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.250]                   }
[08:28:15.250]                 }
[08:28:15.250]                 else {
[08:28:15.250]                   if (TRUE) {
[08:28:15.250]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.250]                     {
[08:28:15.250]                       inherits <- base::inherits
[08:28:15.250]                       invokeRestart <- base::invokeRestart
[08:28:15.250]                       is.null <- base::is.null
[08:28:15.250]                       muffled <- FALSE
[08:28:15.250]                       if (inherits(cond, "message")) {
[08:28:15.250]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.250]                         if (muffled) 
[08:28:15.250]                           invokeRestart("muffleMessage")
[08:28:15.250]                       }
[08:28:15.250]                       else if (inherits(cond, "warning")) {
[08:28:15.250]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.250]                         if (muffled) 
[08:28:15.250]                           invokeRestart("muffleWarning")
[08:28:15.250]                       }
[08:28:15.250]                       else if (inherits(cond, "condition")) {
[08:28:15.250]                         if (!is.null(pattern)) {
[08:28:15.250]                           computeRestarts <- base::computeRestarts
[08:28:15.250]                           grepl <- base::grepl
[08:28:15.250]                           restarts <- computeRestarts(cond)
[08:28:15.250]                           for (restart in restarts) {
[08:28:15.250]                             name <- restart$name
[08:28:15.250]                             if (is.null(name)) 
[08:28:15.250]                               next
[08:28:15.250]                             if (!grepl(pattern, name)) 
[08:28:15.250]                               next
[08:28:15.250]                             invokeRestart(restart)
[08:28:15.250]                             muffled <- TRUE
[08:28:15.250]                             break
[08:28:15.250]                           }
[08:28:15.250]                         }
[08:28:15.250]                       }
[08:28:15.250]                       invisible(muffled)
[08:28:15.250]                     }
[08:28:15.250]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.250]                   }
[08:28:15.250]                 }
[08:28:15.250]             }
[08:28:15.250]         }))
[08:28:15.250]     }, error = function(ex) {
[08:28:15.250]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.250]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.250]                 ...future.rng), started = ...future.startTime, 
[08:28:15.250]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.250]             version = "1.8"), class = "FutureResult")
[08:28:15.250]     }, finally = {
[08:28:15.250]         if (!identical(...future.workdir, getwd())) 
[08:28:15.250]             setwd(...future.workdir)
[08:28:15.250]         {
[08:28:15.250]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.250]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.250]             }
[08:28:15.250]             base::options(...future.oldOptions)
[08:28:15.250]             if (.Platform$OS.type == "windows") {
[08:28:15.250]                 old_names <- names(...future.oldEnvVars)
[08:28:15.250]                 envs <- base::Sys.getenv()
[08:28:15.250]                 names <- names(envs)
[08:28:15.250]                 common <- intersect(names, old_names)
[08:28:15.250]                 added <- setdiff(names, old_names)
[08:28:15.250]                 removed <- setdiff(old_names, names)
[08:28:15.250]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.250]                   envs[common]]
[08:28:15.250]                 NAMES <- toupper(changed)
[08:28:15.250]                 args <- list()
[08:28:15.250]                 for (kk in seq_along(NAMES)) {
[08:28:15.250]                   name <- changed[[kk]]
[08:28:15.250]                   NAME <- NAMES[[kk]]
[08:28:15.250]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.250]                     next
[08:28:15.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.250]                 }
[08:28:15.250]                 NAMES <- toupper(added)
[08:28:15.250]                 for (kk in seq_along(NAMES)) {
[08:28:15.250]                   name <- added[[kk]]
[08:28:15.250]                   NAME <- NAMES[[kk]]
[08:28:15.250]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.250]                     next
[08:28:15.250]                   args[[name]] <- ""
[08:28:15.250]                 }
[08:28:15.250]                 NAMES <- toupper(removed)
[08:28:15.250]                 for (kk in seq_along(NAMES)) {
[08:28:15.250]                   name <- removed[[kk]]
[08:28:15.250]                   NAME <- NAMES[[kk]]
[08:28:15.250]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.250]                     next
[08:28:15.250]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.250]                 }
[08:28:15.250]                 if (length(args) > 0) 
[08:28:15.250]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.250]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.250]             }
[08:28:15.250]             else {
[08:28:15.250]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.250]             }
[08:28:15.250]             {
[08:28:15.250]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.250]                   0L) {
[08:28:15.250]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.250]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.250]                   base::options(opts)
[08:28:15.250]                 }
[08:28:15.250]                 {
[08:28:15.250]                   {
[08:28:15.250]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.250]                     NULL
[08:28:15.250]                   }
[08:28:15.250]                   options(future.plan = NULL)
[08:28:15.250]                   if (is.na(NA_character_)) 
[08:28:15.250]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.250]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.250]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.250]                     .init = FALSE)
[08:28:15.250]                 }
[08:28:15.250]             }
[08:28:15.250]         }
[08:28:15.250]     })
[08:28:15.250]     if (TRUE) {
[08:28:15.250]         base::sink(type = "output", split = FALSE)
[08:28:15.250]         if (TRUE) {
[08:28:15.250]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.250]         }
[08:28:15.250]         else {
[08:28:15.250]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.250]         }
[08:28:15.250]         base::close(...future.stdout)
[08:28:15.250]         ...future.stdout <- NULL
[08:28:15.250]     }
[08:28:15.250]     ...future.result$conditions <- ...future.conditions
[08:28:15.250]     ...future.result$finished <- base::Sys.time()
[08:28:15.250]     ...future.result
[08:28:15.250] }
[08:28:15.252] assign_globals() ...
[08:28:15.252] List of 1
[08:28:15.252]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a108b70638> 
[08:28:15.252]  - attr(*, "where")=List of 1
[08:28:15.252]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.252]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.252]  - attr(*, "resolved")= logi TRUE
[08:28:15.252]  - attr(*, "total_size")= num 3835
[08:28:15.252]  - attr(*, "already-done")= logi TRUE
[08:28:15.256] - copied ‘a’ to environment
[08:28:15.256] assign_globals() ... done
[08:28:15.256] requestCore(): workers = 2
[08:28:15.258] MulticoreFuture started
[08:28:15.259] - Launch lazy future ... done
[08:28:15.259] run() for ‘MulticoreFuture’ ... done
[08:28:15.259] result() for MulticoreFuture ...
[08:28:15.260] plan(): Setting new future strategy stack:
[08:28:15.260] List of future strategies:
[08:28:15.260] 1. sequential:
[08:28:15.260]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.260]    - tweaked: FALSE
[08:28:15.260]    - call: NULL
[08:28:15.261] plan(): nbrOfWorkers() = 1
[08:28:15.264] plan(): Setting new future strategy stack:
[08:28:15.265] List of future strategies:
[08:28:15.265] 1. multicore:
[08:28:15.265]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.265]    - tweaked: FALSE
[08:28:15.265]    - call: plan(strategy)
[08:28:15.268] plan(): nbrOfWorkers() = 2
[08:28:15.269] result() for MulticoreFuture ...
[08:28:15.269] result() for MulticoreFuture ... done
[08:28:15.269] signalConditions() ...
[08:28:15.269]  - include = ‘immediateCondition’
[08:28:15.269]  - exclude = 
[08:28:15.269]  - resignal = FALSE
[08:28:15.270]  - Number of conditions: 4
[08:28:15.270] signalConditions() ... done
[08:28:15.270] result() for MulticoreFuture ... done
[08:28:15.270] result() for MulticoreFuture ...
[08:28:15.270] result() for MulticoreFuture ... done
[08:28:15.270] signalConditions() ...
[08:28:15.270]  - include = ‘immediateCondition’
[08:28:15.270]  - exclude = 
[08:28:15.271]  - resignal = FALSE
[08:28:15.271]  - Number of conditions: 4
[08:28:15.271] signalConditions() ... done
[08:28:15.271] Future state: ‘finished’
[08:28:15.271] result() for MulticoreFuture ...
[08:28:15.271] result() for MulticoreFuture ... done
[08:28:15.271] signalConditions() ...
[08:28:15.271]  - include = ‘condition’
[08:28:15.272]  - exclude = ‘immediateCondition’
[08:28:15.272]  - resignal = TRUE
[08:28:15.272]  - Number of conditions: 4
[08:28:15.272]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.262] result() for MulticoreFuture ...
[08:28:15.272]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.263] result() for MulticoreFuture ... done
[08:28:15.272]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.263] result() for MulticoreFuture ...
[08:28:15.272]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.263] result() for MulticoreFuture ... done
[08:28:15.273] signalConditions() ... done
value(b) = 2
[08:28:15.273] result() for MulticoreFuture ...
[08:28:15.273] result() for MulticoreFuture ... done
[08:28:15.273] result() for MulticoreFuture ...
[08:28:15.273] result() for MulticoreFuture ... done
[08:28:15.273] signalConditions() ...
[08:28:15.273]  - include = ‘immediateCondition’
[08:28:15.273]  - exclude = 
[08:28:15.274]  - resignal = FALSE
[08:28:15.274]  - Number of conditions: 4
[08:28:15.274] signalConditions() ... done
[08:28:15.274] Future state: ‘finished’
[08:28:15.274] result() for MulticoreFuture ...
[08:28:15.274] result() for MulticoreFuture ... done
[08:28:15.274] signalConditions() ...
[08:28:15.274]  - include = ‘condition’
[08:28:15.274]  - exclude = ‘immediateCondition’
[08:28:15.275]  - resignal = TRUE
[08:28:15.275]  - Number of conditions: 4
[08:28:15.275]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.262] result() for MulticoreFuture ...
[08:28:15.275]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.263] result() for MulticoreFuture ... done
[08:28:15.275]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.263] result() for MulticoreFuture ...
[08:28:15.275]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.263] result() for MulticoreFuture ... done
[08:28:15.275] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.276] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.276] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:15.277] - globals found: [2] ‘{’, ‘pkg’
[08:28:15.277] Searching for globals ... DONE
[08:28:15.277] Resolving globals: TRUE
[08:28:15.278] Resolving any globals that are futures ...
[08:28:15.278] - globals: [2] ‘{’, ‘pkg’
[08:28:15.278] Resolving any globals that are futures ... DONE
[08:28:15.278] Resolving futures part of globals (recursively) ...
[08:28:15.279] resolve() on list ...
[08:28:15.279]  recursive: 99
[08:28:15.279]  length: 1
[08:28:15.279]  elements: ‘pkg’
[08:28:15.279]  length: 0 (resolved future 1)
[08:28:15.279] resolve() on list ... DONE
[08:28:15.279] - globals: [1] ‘pkg’
[08:28:15.279] Resolving futures part of globals (recursively) ... DONE
[08:28:15.280] The total size of the 1 globals is 42 bytes (42 bytes)
[08:28:15.280] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[08:28:15.280] - globals: [1] ‘pkg’
[08:28:15.280] 
[08:28:15.280] getGlobalsAndPackages() ... DONE
[08:28:15.281] Packages needed by the future expression (n = 0): <none>
[08:28:15.281] Packages needed by future strategies (n = 0): <none>
[08:28:15.281] {
[08:28:15.281]     {
[08:28:15.281]         {
[08:28:15.281]             ...future.startTime <- base::Sys.time()
[08:28:15.281]             {
[08:28:15.281]                 {
[08:28:15.281]                   {
[08:28:15.281]                     base::local({
[08:28:15.281]                       has_future <- base::requireNamespace("future", 
[08:28:15.281]                         quietly = TRUE)
[08:28:15.281]                       if (has_future) {
[08:28:15.281]                         ns <- base::getNamespace("future")
[08:28:15.281]                         version <- ns[[".package"]][["version"]]
[08:28:15.281]                         if (is.null(version)) 
[08:28:15.281]                           version <- utils::packageVersion("future")
[08:28:15.281]                       }
[08:28:15.281]                       else {
[08:28:15.281]                         version <- NULL
[08:28:15.281]                       }
[08:28:15.281]                       if (!has_future || version < "1.8.0") {
[08:28:15.281]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.281]                           "", base::R.version$version.string), 
[08:28:15.281]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:15.281]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.281]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.281]                             "release", "version")], collapse = " "), 
[08:28:15.281]                           hostname = base::Sys.info()[["nodename"]])
[08:28:15.281]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.281]                           info)
[08:28:15.281]                         info <- base::paste(info, collapse = "; ")
[08:28:15.281]                         if (!has_future) {
[08:28:15.281]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.281]                             info)
[08:28:15.281]                         }
[08:28:15.281]                         else {
[08:28:15.281]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.281]                             info, version)
[08:28:15.281]                         }
[08:28:15.281]                         base::stop(msg)
[08:28:15.281]                       }
[08:28:15.281]                     })
[08:28:15.281]                   }
[08:28:15.281]                   ...future.strategy.old <- future::plan("list")
[08:28:15.281]                   options(future.plan = NULL)
[08:28:15.281]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.281]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.281]                 }
[08:28:15.281]                 ...future.workdir <- getwd()
[08:28:15.281]             }
[08:28:15.281]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.281]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.281]         }
[08:28:15.281]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.281]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:15.281]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.281]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.281]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.281]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.281]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.281]             base::names(...future.oldOptions))
[08:28:15.281]     }
[08:28:15.281]     if (FALSE) {
[08:28:15.281]     }
[08:28:15.281]     else {
[08:28:15.281]         if (TRUE) {
[08:28:15.281]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.281]                 open = "w")
[08:28:15.281]         }
[08:28:15.281]         else {
[08:28:15.281]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.281]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.281]         }
[08:28:15.281]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.281]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.281]             base::sink(type = "output", split = FALSE)
[08:28:15.281]             base::close(...future.stdout)
[08:28:15.281]         }, add = TRUE)
[08:28:15.281]     }
[08:28:15.281]     ...future.frame <- base::sys.nframe()
[08:28:15.281]     ...future.conditions <- base::list()
[08:28:15.281]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.281]     if (FALSE) {
[08:28:15.281]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.281]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.281]     }
[08:28:15.281]     ...future.result <- base::tryCatch({
[08:28:15.281]         base::withCallingHandlers({
[08:28:15.281]             ...future.value <- base::withVisible(base::local({
[08:28:15.281]                 pkg
[08:28:15.281]             }))
[08:28:15.281]             future::FutureResult(value = ...future.value$value, 
[08:28:15.281]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.281]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.281]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.281]                     ...future.globalenv.names))
[08:28:15.281]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.281]         }, condition = base::local({
[08:28:15.281]             c <- base::c
[08:28:15.281]             inherits <- base::inherits
[08:28:15.281]             invokeRestart <- base::invokeRestart
[08:28:15.281]             length <- base::length
[08:28:15.281]             list <- base::list
[08:28:15.281]             seq.int <- base::seq.int
[08:28:15.281]             signalCondition <- base::signalCondition
[08:28:15.281]             sys.calls <- base::sys.calls
[08:28:15.281]             `[[` <- base::`[[`
[08:28:15.281]             `+` <- base::`+`
[08:28:15.281]             `<<-` <- base::`<<-`
[08:28:15.281]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.281]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.281]                   3L)]
[08:28:15.281]             }
[08:28:15.281]             function(cond) {
[08:28:15.281]                 is_error <- inherits(cond, "error")
[08:28:15.281]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.281]                   NULL)
[08:28:15.281]                 if (is_error) {
[08:28:15.281]                   sessionInformation <- function() {
[08:28:15.281]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.281]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.281]                       search = base::search(), system = base::Sys.info())
[08:28:15.281]                   }
[08:28:15.281]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.281]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.281]                     cond$call), session = sessionInformation(), 
[08:28:15.281]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.281]                   signalCondition(cond)
[08:28:15.281]                 }
[08:28:15.281]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.281]                 "immediateCondition"))) {
[08:28:15.281]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.281]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.281]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.281]                   if (TRUE && !signal) {
[08:28:15.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.281]                     {
[08:28:15.281]                       inherits <- base::inherits
[08:28:15.281]                       invokeRestart <- base::invokeRestart
[08:28:15.281]                       is.null <- base::is.null
[08:28:15.281]                       muffled <- FALSE
[08:28:15.281]                       if (inherits(cond, "message")) {
[08:28:15.281]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.281]                         if (muffled) 
[08:28:15.281]                           invokeRestart("muffleMessage")
[08:28:15.281]                       }
[08:28:15.281]                       else if (inherits(cond, "warning")) {
[08:28:15.281]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.281]                         if (muffled) 
[08:28:15.281]                           invokeRestart("muffleWarning")
[08:28:15.281]                       }
[08:28:15.281]                       else if (inherits(cond, "condition")) {
[08:28:15.281]                         if (!is.null(pattern)) {
[08:28:15.281]                           computeRestarts <- base::computeRestarts
[08:28:15.281]                           grepl <- base::grepl
[08:28:15.281]                           restarts <- computeRestarts(cond)
[08:28:15.281]                           for (restart in restarts) {
[08:28:15.281]                             name <- restart$name
[08:28:15.281]                             if (is.null(name)) 
[08:28:15.281]                               next
[08:28:15.281]                             if (!grepl(pattern, name)) 
[08:28:15.281]                               next
[08:28:15.281]                             invokeRestart(restart)
[08:28:15.281]                             muffled <- TRUE
[08:28:15.281]                             break
[08:28:15.281]                           }
[08:28:15.281]                         }
[08:28:15.281]                       }
[08:28:15.281]                       invisible(muffled)
[08:28:15.281]                     }
[08:28:15.281]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.281]                   }
[08:28:15.281]                 }
[08:28:15.281]                 else {
[08:28:15.281]                   if (TRUE) {
[08:28:15.281]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.281]                     {
[08:28:15.281]                       inherits <- base::inherits
[08:28:15.281]                       invokeRestart <- base::invokeRestart
[08:28:15.281]                       is.null <- base::is.null
[08:28:15.281]                       muffled <- FALSE
[08:28:15.281]                       if (inherits(cond, "message")) {
[08:28:15.281]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.281]                         if (muffled) 
[08:28:15.281]                           invokeRestart("muffleMessage")
[08:28:15.281]                       }
[08:28:15.281]                       else if (inherits(cond, "warning")) {
[08:28:15.281]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.281]                         if (muffled) 
[08:28:15.281]                           invokeRestart("muffleWarning")
[08:28:15.281]                       }
[08:28:15.281]                       else if (inherits(cond, "condition")) {
[08:28:15.281]                         if (!is.null(pattern)) {
[08:28:15.281]                           computeRestarts <- base::computeRestarts
[08:28:15.281]                           grepl <- base::grepl
[08:28:15.281]                           restarts <- computeRestarts(cond)
[08:28:15.281]                           for (restart in restarts) {
[08:28:15.281]                             name <- restart$name
[08:28:15.281]                             if (is.null(name)) 
[08:28:15.281]                               next
[08:28:15.281]                             if (!grepl(pattern, name)) 
[08:28:15.281]                               next
[08:28:15.281]                             invokeRestart(restart)
[08:28:15.281]                             muffled <- TRUE
[08:28:15.281]                             break
[08:28:15.281]                           }
[08:28:15.281]                         }
[08:28:15.281]                       }
[08:28:15.281]                       invisible(muffled)
[08:28:15.281]                     }
[08:28:15.281]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.281]                   }
[08:28:15.281]                 }
[08:28:15.281]             }
[08:28:15.281]         }))
[08:28:15.281]     }, error = function(ex) {
[08:28:15.281]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.281]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.281]                 ...future.rng), started = ...future.startTime, 
[08:28:15.281]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.281]             version = "1.8"), class = "FutureResult")
[08:28:15.281]     }, finally = {
[08:28:15.281]         if (!identical(...future.workdir, getwd())) 
[08:28:15.281]             setwd(...future.workdir)
[08:28:15.281]         {
[08:28:15.281]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.281]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.281]             }
[08:28:15.281]             base::options(...future.oldOptions)
[08:28:15.281]             if (.Platform$OS.type == "windows") {
[08:28:15.281]                 old_names <- names(...future.oldEnvVars)
[08:28:15.281]                 envs <- base::Sys.getenv()
[08:28:15.281]                 names <- names(envs)
[08:28:15.281]                 common <- intersect(names, old_names)
[08:28:15.281]                 added <- setdiff(names, old_names)
[08:28:15.281]                 removed <- setdiff(old_names, names)
[08:28:15.281]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.281]                   envs[common]]
[08:28:15.281]                 NAMES <- toupper(changed)
[08:28:15.281]                 args <- list()
[08:28:15.281]                 for (kk in seq_along(NAMES)) {
[08:28:15.281]                   name <- changed[[kk]]
[08:28:15.281]                   NAME <- NAMES[[kk]]
[08:28:15.281]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.281]                     next
[08:28:15.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.281]                 }
[08:28:15.281]                 NAMES <- toupper(added)
[08:28:15.281]                 for (kk in seq_along(NAMES)) {
[08:28:15.281]                   name <- added[[kk]]
[08:28:15.281]                   NAME <- NAMES[[kk]]
[08:28:15.281]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.281]                     next
[08:28:15.281]                   args[[name]] <- ""
[08:28:15.281]                 }
[08:28:15.281]                 NAMES <- toupper(removed)
[08:28:15.281]                 for (kk in seq_along(NAMES)) {
[08:28:15.281]                   name <- removed[[kk]]
[08:28:15.281]                   NAME <- NAMES[[kk]]
[08:28:15.281]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.281]                     next
[08:28:15.281]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.281]                 }
[08:28:15.281]                 if (length(args) > 0) 
[08:28:15.281]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.281]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.281]             }
[08:28:15.281]             else {
[08:28:15.281]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.281]             }
[08:28:15.281]             {
[08:28:15.281]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.281]                   0L) {
[08:28:15.281]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.281]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.281]                   base::options(opts)
[08:28:15.281]                 }
[08:28:15.281]                 {
[08:28:15.281]                   {
[08:28:15.281]                     NULL
[08:28:15.281]                     RNGkind("Mersenne-Twister")
[08:28:15.281]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:15.281]                       inherits = FALSE)
[08:28:15.281]                   }
[08:28:15.281]                   options(future.plan = NULL)
[08:28:15.281]                   if (is.na(NA_character_)) 
[08:28:15.281]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.281]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.281]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.281]                     .init = FALSE)
[08:28:15.281]                 }
[08:28:15.281]             }
[08:28:15.281]         }
[08:28:15.281]     })
[08:28:15.281]     if (TRUE) {
[08:28:15.281]         base::sink(type = "output", split = FALSE)
[08:28:15.281]         if (TRUE) {
[08:28:15.281]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.281]         }
[08:28:15.281]         else {
[08:28:15.281]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.281]         }
[08:28:15.281]         base::close(...future.stdout)
[08:28:15.281]         ...future.stdout <- NULL
[08:28:15.281]     }
[08:28:15.281]     ...future.result$conditions <- ...future.conditions
[08:28:15.281]     ...future.result$finished <- base::Sys.time()
[08:28:15.281]     ...future.result
[08:28:15.281] }
[08:28:15.286] assign_globals() ...
[08:28:15.286] List of 1
[08:28:15.286]  $ pkg: chr "foo"
[08:28:15.286]  - attr(*, "where")=List of 1
[08:28:15.286]   ..$ pkg:<environment: R_EmptyEnv> 
[08:28:15.286]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.286]  - attr(*, "resolved")= logi TRUE
[08:28:15.286]  - attr(*, "total_size")= num 42
[08:28:15.290] - copied ‘pkg’ to environment
[08:28:15.290] assign_globals() ... done
[08:28:15.290] plan(): Setting new future strategy stack:
[08:28:15.290] List of future strategies:
[08:28:15.290] 1. sequential:
[08:28:15.290]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.290]    - tweaked: FALSE
[08:28:15.290]    - call: NULL
[08:28:15.291] plan(): nbrOfWorkers() = 1
[08:28:15.292] plan(): Setting new future strategy stack:
[08:28:15.292] List of future strategies:
[08:28:15.292] 1. multicore:
[08:28:15.292]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.292]    - tweaked: FALSE
[08:28:15.292]    - call: plan(strategy)
[08:28:15.294] plan(): nbrOfWorkers() = 2
[08:28:15.294] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.295] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.295] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.297] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:15.297] Searching for globals ... DONE
[08:28:15.298] Resolving globals: TRUE
[08:28:15.298] Resolving any globals that are futures ...
[08:28:15.298] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:15.298] Resolving any globals that are futures ... DONE
[08:28:15.298] Resolving futures part of globals (recursively) ...
[08:28:15.298] resolve() on list ...
[08:28:15.299]  recursive: 99
[08:28:15.299]  length: 1
[08:28:15.299]  elements: ‘a’
[08:28:15.299]  length: 0 (resolved future 1)
[08:28:15.299] resolve() on list ... DONE
[08:28:15.299] - globals: [1] ‘a’
[08:28:15.299] Resolving futures part of globals (recursively) ... DONE
[08:28:15.299] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:15.300] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:15.300] - globals: [1] ‘a’
[08:28:15.300] 
[08:28:15.300] getGlobalsAndPackages() ... DONE
[08:28:15.300] run() for ‘Future’ ...
[08:28:15.300] - state: ‘created’
[08:28:15.300] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.302] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.302] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.302]   - Field: ‘label’
[08:28:15.302]   - Field: ‘local’
[08:28:15.303]   - Field: ‘owner’
[08:28:15.303]   - Field: ‘envir’
[08:28:15.303]   - Field: ‘workers’
[08:28:15.303]   - Field: ‘packages’
[08:28:15.303]   - Field: ‘gc’
[08:28:15.303]   - Field: ‘job’
[08:28:15.303]   - Field: ‘conditions’
[08:28:15.303]   - Field: ‘expr’
[08:28:15.303]   - Field: ‘uuid’
[08:28:15.303]   - Field: ‘seed’
[08:28:15.303]   - Field: ‘version’
[08:28:15.304]   - Field: ‘result’
[08:28:15.304]   - Field: ‘asynchronous’
[08:28:15.304]   - Field: ‘calls’
[08:28:15.304]   - Field: ‘globals’
[08:28:15.304]   - Field: ‘stdout’
[08:28:15.304]   - Field: ‘earlySignal’
[08:28:15.304]   - Field: ‘lazy’
[08:28:15.304]   - Field: ‘state’
[08:28:15.304] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.304] - Launch lazy future ...
[08:28:15.305] Packages needed by the future expression (n = 0): <none>
[08:28:15.305] Packages needed by future strategies (n = 0): <none>
[08:28:15.305] {
[08:28:15.305]     {
[08:28:15.305]         {
[08:28:15.305]             ...future.startTime <- base::Sys.time()
[08:28:15.305]             {
[08:28:15.305]                 {
[08:28:15.305]                   {
[08:28:15.305]                     {
[08:28:15.305]                       base::local({
[08:28:15.305]                         has_future <- base::requireNamespace("future", 
[08:28:15.305]                           quietly = TRUE)
[08:28:15.305]                         if (has_future) {
[08:28:15.305]                           ns <- base::getNamespace("future")
[08:28:15.305]                           version <- ns[[".package"]][["version"]]
[08:28:15.305]                           if (is.null(version)) 
[08:28:15.305]                             version <- utils::packageVersion("future")
[08:28:15.305]                         }
[08:28:15.305]                         else {
[08:28:15.305]                           version <- NULL
[08:28:15.305]                         }
[08:28:15.305]                         if (!has_future || version < "1.8.0") {
[08:28:15.305]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.305]                             "", base::R.version$version.string), 
[08:28:15.305]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.305]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.305]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.305]                               "release", "version")], collapse = " "), 
[08:28:15.305]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.305]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.305]                             info)
[08:28:15.305]                           info <- base::paste(info, collapse = "; ")
[08:28:15.305]                           if (!has_future) {
[08:28:15.305]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.305]                               info)
[08:28:15.305]                           }
[08:28:15.305]                           else {
[08:28:15.305]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.305]                               info, version)
[08:28:15.305]                           }
[08:28:15.305]                           base::stop(msg)
[08:28:15.305]                         }
[08:28:15.305]                       })
[08:28:15.305]                     }
[08:28:15.305]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.305]                     base::options(mc.cores = 1L)
[08:28:15.305]                   }
[08:28:15.305]                   ...future.strategy.old <- future::plan("list")
[08:28:15.305]                   options(future.plan = NULL)
[08:28:15.305]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.305]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.305]                 }
[08:28:15.305]                 ...future.workdir <- getwd()
[08:28:15.305]             }
[08:28:15.305]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.305]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.305]         }
[08:28:15.305]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.305]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.305]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.305]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.305]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.305]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.305]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.305]             base::names(...future.oldOptions))
[08:28:15.305]     }
[08:28:15.305]     if (FALSE) {
[08:28:15.305]     }
[08:28:15.305]     else {
[08:28:15.305]         if (TRUE) {
[08:28:15.305]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.305]                 open = "w")
[08:28:15.305]         }
[08:28:15.305]         else {
[08:28:15.305]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.305]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.305]         }
[08:28:15.305]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.305]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.305]             base::sink(type = "output", split = FALSE)
[08:28:15.305]             base::close(...future.stdout)
[08:28:15.305]         }, add = TRUE)
[08:28:15.305]     }
[08:28:15.305]     ...future.frame <- base::sys.nframe()
[08:28:15.305]     ...future.conditions <- base::list()
[08:28:15.305]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.305]     if (FALSE) {
[08:28:15.305]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.305]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.305]     }
[08:28:15.305]     ...future.result <- base::tryCatch({
[08:28:15.305]         base::withCallingHandlers({
[08:28:15.305]             ...future.value <- base::withVisible(base::local({
[08:28:15.305]                 withCallingHandlers({
[08:28:15.305]                   {
[08:28:15.305]                     b <- a
[08:28:15.305]                     a <- 2
[08:28:15.305]                     a * b
[08:28:15.305]                   }
[08:28:15.305]                 }, immediateCondition = function(cond) {
[08:28:15.305]                   save_rds <- function (object, pathname, ...) 
[08:28:15.305]                   {
[08:28:15.305]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.305]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.305]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.305]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.305]                         fi_tmp[["mtime"]])
[08:28:15.305]                     }
[08:28:15.305]                     tryCatch({
[08:28:15.305]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.305]                     }, error = function(ex) {
[08:28:15.305]                       msg <- conditionMessage(ex)
[08:28:15.305]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.305]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.305]                         fi_tmp[["mtime"]], msg)
[08:28:15.305]                       ex$message <- msg
[08:28:15.305]                       stop(ex)
[08:28:15.305]                     })
[08:28:15.305]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.305]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.305]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.305]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.305]                       fi <- file.info(pathname)
[08:28:15.305]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.305]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.305]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.305]                         fi[["size"]], fi[["mtime"]])
[08:28:15.305]                       stop(msg)
[08:28:15.305]                     }
[08:28:15.305]                     invisible(pathname)
[08:28:15.305]                   }
[08:28:15.305]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.305]                     rootPath = tempdir()) 
[08:28:15.305]                   {
[08:28:15.305]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.305]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.305]                       tmpdir = path, fileext = ".rds")
[08:28:15.305]                     save_rds(obj, file)
[08:28:15.305]                   }
[08:28:15.305]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.305]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.305]                   {
[08:28:15.305]                     inherits <- base::inherits
[08:28:15.305]                     invokeRestart <- base::invokeRestart
[08:28:15.305]                     is.null <- base::is.null
[08:28:15.305]                     muffled <- FALSE
[08:28:15.305]                     if (inherits(cond, "message")) {
[08:28:15.305]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.305]                       if (muffled) 
[08:28:15.305]                         invokeRestart("muffleMessage")
[08:28:15.305]                     }
[08:28:15.305]                     else if (inherits(cond, "warning")) {
[08:28:15.305]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.305]                       if (muffled) 
[08:28:15.305]                         invokeRestart("muffleWarning")
[08:28:15.305]                     }
[08:28:15.305]                     else if (inherits(cond, "condition")) {
[08:28:15.305]                       if (!is.null(pattern)) {
[08:28:15.305]                         computeRestarts <- base::computeRestarts
[08:28:15.305]                         grepl <- base::grepl
[08:28:15.305]                         restarts <- computeRestarts(cond)
[08:28:15.305]                         for (restart in restarts) {
[08:28:15.305]                           name <- restart$name
[08:28:15.305]                           if (is.null(name)) 
[08:28:15.305]                             next
[08:28:15.305]                           if (!grepl(pattern, name)) 
[08:28:15.305]                             next
[08:28:15.305]                           invokeRestart(restart)
[08:28:15.305]                           muffled <- TRUE
[08:28:15.305]                           break
[08:28:15.305]                         }
[08:28:15.305]                       }
[08:28:15.305]                     }
[08:28:15.305]                     invisible(muffled)
[08:28:15.305]                   }
[08:28:15.305]                   muffleCondition(cond)
[08:28:15.305]                 })
[08:28:15.305]             }))
[08:28:15.305]             future::FutureResult(value = ...future.value$value, 
[08:28:15.305]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.305]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.305]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.305]                     ...future.globalenv.names))
[08:28:15.305]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.305]         }, condition = base::local({
[08:28:15.305]             c <- base::c
[08:28:15.305]             inherits <- base::inherits
[08:28:15.305]             invokeRestart <- base::invokeRestart
[08:28:15.305]             length <- base::length
[08:28:15.305]             list <- base::list
[08:28:15.305]             seq.int <- base::seq.int
[08:28:15.305]             signalCondition <- base::signalCondition
[08:28:15.305]             sys.calls <- base::sys.calls
[08:28:15.305]             `[[` <- base::`[[`
[08:28:15.305]             `+` <- base::`+`
[08:28:15.305]             `<<-` <- base::`<<-`
[08:28:15.305]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.305]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.305]                   3L)]
[08:28:15.305]             }
[08:28:15.305]             function(cond) {
[08:28:15.305]                 is_error <- inherits(cond, "error")
[08:28:15.305]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.305]                   NULL)
[08:28:15.305]                 if (is_error) {
[08:28:15.305]                   sessionInformation <- function() {
[08:28:15.305]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.305]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.305]                       search = base::search(), system = base::Sys.info())
[08:28:15.305]                   }
[08:28:15.305]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.305]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.305]                     cond$call), session = sessionInformation(), 
[08:28:15.305]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.305]                   signalCondition(cond)
[08:28:15.305]                 }
[08:28:15.305]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.305]                 "immediateCondition"))) {
[08:28:15.305]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.305]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.305]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.305]                   if (TRUE && !signal) {
[08:28:15.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.305]                     {
[08:28:15.305]                       inherits <- base::inherits
[08:28:15.305]                       invokeRestart <- base::invokeRestart
[08:28:15.305]                       is.null <- base::is.null
[08:28:15.305]                       muffled <- FALSE
[08:28:15.305]                       if (inherits(cond, "message")) {
[08:28:15.305]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.305]                         if (muffled) 
[08:28:15.305]                           invokeRestart("muffleMessage")
[08:28:15.305]                       }
[08:28:15.305]                       else if (inherits(cond, "warning")) {
[08:28:15.305]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.305]                         if (muffled) 
[08:28:15.305]                           invokeRestart("muffleWarning")
[08:28:15.305]                       }
[08:28:15.305]                       else if (inherits(cond, "condition")) {
[08:28:15.305]                         if (!is.null(pattern)) {
[08:28:15.305]                           computeRestarts <- base::computeRestarts
[08:28:15.305]                           grepl <- base::grepl
[08:28:15.305]                           restarts <- computeRestarts(cond)
[08:28:15.305]                           for (restart in restarts) {
[08:28:15.305]                             name <- restart$name
[08:28:15.305]                             if (is.null(name)) 
[08:28:15.305]                               next
[08:28:15.305]                             if (!grepl(pattern, name)) 
[08:28:15.305]                               next
[08:28:15.305]                             invokeRestart(restart)
[08:28:15.305]                             muffled <- TRUE
[08:28:15.305]                             break
[08:28:15.305]                           }
[08:28:15.305]                         }
[08:28:15.305]                       }
[08:28:15.305]                       invisible(muffled)
[08:28:15.305]                     }
[08:28:15.305]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.305]                   }
[08:28:15.305]                 }
[08:28:15.305]                 else {
[08:28:15.305]                   if (TRUE) {
[08:28:15.305]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.305]                     {
[08:28:15.305]                       inherits <- base::inherits
[08:28:15.305]                       invokeRestart <- base::invokeRestart
[08:28:15.305]                       is.null <- base::is.null
[08:28:15.305]                       muffled <- FALSE
[08:28:15.305]                       if (inherits(cond, "message")) {
[08:28:15.305]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.305]                         if (muffled) 
[08:28:15.305]                           invokeRestart("muffleMessage")
[08:28:15.305]                       }
[08:28:15.305]                       else if (inherits(cond, "warning")) {
[08:28:15.305]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.305]                         if (muffled) 
[08:28:15.305]                           invokeRestart("muffleWarning")
[08:28:15.305]                       }
[08:28:15.305]                       else if (inherits(cond, "condition")) {
[08:28:15.305]                         if (!is.null(pattern)) {
[08:28:15.305]                           computeRestarts <- base::computeRestarts
[08:28:15.305]                           grepl <- base::grepl
[08:28:15.305]                           restarts <- computeRestarts(cond)
[08:28:15.305]                           for (restart in restarts) {
[08:28:15.305]                             name <- restart$name
[08:28:15.305]                             if (is.null(name)) 
[08:28:15.305]                               next
[08:28:15.305]                             if (!grepl(pattern, name)) 
[08:28:15.305]                               next
[08:28:15.305]                             invokeRestart(restart)
[08:28:15.305]                             muffled <- TRUE
[08:28:15.305]                             break
[08:28:15.305]                           }
[08:28:15.305]                         }
[08:28:15.305]                       }
[08:28:15.305]                       invisible(muffled)
[08:28:15.305]                     }
[08:28:15.305]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.305]                   }
[08:28:15.305]                 }
[08:28:15.305]             }
[08:28:15.305]         }))
[08:28:15.305]     }, error = function(ex) {
[08:28:15.305]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.305]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.305]                 ...future.rng), started = ...future.startTime, 
[08:28:15.305]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.305]             version = "1.8"), class = "FutureResult")
[08:28:15.305]     }, finally = {
[08:28:15.305]         if (!identical(...future.workdir, getwd())) 
[08:28:15.305]             setwd(...future.workdir)
[08:28:15.305]         {
[08:28:15.305]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.305]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.305]             }
[08:28:15.305]             base::options(...future.oldOptions)
[08:28:15.305]             if (.Platform$OS.type == "windows") {
[08:28:15.305]                 old_names <- names(...future.oldEnvVars)
[08:28:15.305]                 envs <- base::Sys.getenv()
[08:28:15.305]                 names <- names(envs)
[08:28:15.305]                 common <- intersect(names, old_names)
[08:28:15.305]                 added <- setdiff(names, old_names)
[08:28:15.305]                 removed <- setdiff(old_names, names)
[08:28:15.305]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.305]                   envs[common]]
[08:28:15.305]                 NAMES <- toupper(changed)
[08:28:15.305]                 args <- list()
[08:28:15.305]                 for (kk in seq_along(NAMES)) {
[08:28:15.305]                   name <- changed[[kk]]
[08:28:15.305]                   NAME <- NAMES[[kk]]
[08:28:15.305]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.305]                     next
[08:28:15.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.305]                 }
[08:28:15.305]                 NAMES <- toupper(added)
[08:28:15.305]                 for (kk in seq_along(NAMES)) {
[08:28:15.305]                   name <- added[[kk]]
[08:28:15.305]                   NAME <- NAMES[[kk]]
[08:28:15.305]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.305]                     next
[08:28:15.305]                   args[[name]] <- ""
[08:28:15.305]                 }
[08:28:15.305]                 NAMES <- toupper(removed)
[08:28:15.305]                 for (kk in seq_along(NAMES)) {
[08:28:15.305]                   name <- removed[[kk]]
[08:28:15.305]                   NAME <- NAMES[[kk]]
[08:28:15.305]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.305]                     next
[08:28:15.305]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.305]                 }
[08:28:15.305]                 if (length(args) > 0) 
[08:28:15.305]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.305]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.305]             }
[08:28:15.305]             else {
[08:28:15.305]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.305]             }
[08:28:15.305]             {
[08:28:15.305]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.305]                   0L) {
[08:28:15.305]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.305]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.305]                   base::options(opts)
[08:28:15.305]                 }
[08:28:15.305]                 {
[08:28:15.305]                   {
[08:28:15.305]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.305]                     NULL
[08:28:15.305]                   }
[08:28:15.305]                   options(future.plan = NULL)
[08:28:15.305]                   if (is.na(NA_character_)) 
[08:28:15.305]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.305]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.305]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.305]                     .init = FALSE)
[08:28:15.305]                 }
[08:28:15.305]             }
[08:28:15.305]         }
[08:28:15.305]     })
[08:28:15.305]     if (TRUE) {
[08:28:15.305]         base::sink(type = "output", split = FALSE)
[08:28:15.305]         if (TRUE) {
[08:28:15.305]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.305]         }
[08:28:15.305]         else {
[08:28:15.305]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.305]         }
[08:28:15.305]         base::close(...future.stdout)
[08:28:15.305]         ...future.stdout <- NULL
[08:28:15.305]     }
[08:28:15.305]     ...future.result$conditions <- ...future.conditions
[08:28:15.305]     ...future.result$finished <- base::Sys.time()
[08:28:15.305]     ...future.result
[08:28:15.305] }
[08:28:15.308] assign_globals() ...
[08:28:15.308] List of 1
[08:28:15.308]  $ a: num 3
[08:28:15.308]  - attr(*, "where")=List of 1
[08:28:15.308]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.308]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.308]  - attr(*, "resolved")= logi TRUE
[08:28:15.308]  - attr(*, "total_size")= num 39
[08:28:15.308]  - attr(*, "already-done")= logi TRUE
[08:28:15.313] - copied ‘a’ to environment
[08:28:15.313] assign_globals() ... done
[08:28:15.313] requestCore(): workers = 2
[08:28:15.315] MulticoreFuture started
[08:28:15.316] - Launch lazy future ... done
[08:28:15.316] run() for ‘MulticoreFuture’ ... done
[08:28:15.316] plan(): Setting new future strategy stack:
[08:28:15.317] result() for MulticoreFuture ...
[08:28:15.317] List of future strategies:
[08:28:15.317] 1. sequential:
[08:28:15.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.317]    - tweaked: FALSE
[08:28:15.317]    - call: NULL
[08:28:15.318] plan(): nbrOfWorkers() = 1
[08:28:15.321] plan(): Setting new future strategy stack:
[08:28:15.321] List of future strategies:
[08:28:15.321] 1. multicore:
[08:28:15.321]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.321]    - tweaked: FALSE
[08:28:15.321]    - call: plan(strategy)
[08:28:15.324] plan(): nbrOfWorkers() = 2
[08:28:15.325] result() for MulticoreFuture ...
[08:28:15.325] result() for MulticoreFuture ... done
[08:28:15.326] result() for MulticoreFuture ... done
[08:28:15.326] result() for MulticoreFuture ...
[08:28:15.326] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.327] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.327] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.330] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:15.330] Searching for globals ... DONE
[08:28:15.330] Resolving globals: TRUE
[08:28:15.330] Resolving any globals that are futures ...
[08:28:15.330] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:15.331] Resolving any globals that are futures ... DONE
[08:28:15.331] Resolving futures part of globals (recursively) ...
[08:28:15.331] resolve() on list ...
[08:28:15.331]  recursive: 99
[08:28:15.332]  length: 1
[08:28:15.332]  elements: ‘a’
[08:28:15.332]  length: 0 (resolved future 1)
[08:28:15.332] resolve() on list ... DONE
[08:28:15.332] - globals: [1] ‘a’
[08:28:15.332] Resolving futures part of globals (recursively) ... DONE
[08:28:15.332] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:15.333] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:15.333] - globals: [1] ‘a’
[08:28:15.333] 
[08:28:15.333] getGlobalsAndPackages() ... DONE
[08:28:15.334] run() for ‘Future’ ...
[08:28:15.334] - state: ‘created’
[08:28:15.334] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.336] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.336] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.336]   - Field: ‘label’
[08:28:15.336]   - Field: ‘local’
[08:28:15.337]   - Field: ‘owner’
[08:28:15.337]   - Field: ‘envir’
[08:28:15.337]   - Field: ‘workers’
[08:28:15.337]   - Field: ‘packages’
[08:28:15.337]   - Field: ‘gc’
[08:28:15.337]   - Field: ‘job’
[08:28:15.337]   - Field: ‘conditions’
[08:28:15.337]   - Field: ‘expr’
[08:28:15.337]   - Field: ‘uuid’
[08:28:15.338]   - Field: ‘seed’
[08:28:15.338]   - Field: ‘version’
[08:28:15.338]   - Field: ‘result’
[08:28:15.338]   - Field: ‘asynchronous’
[08:28:15.338]   - Field: ‘calls’
[08:28:15.338]   - Field: ‘globals’
[08:28:15.338]   - Field: ‘stdout’
[08:28:15.338]   - Field: ‘earlySignal’
[08:28:15.338]   - Field: ‘lazy’
[08:28:15.339]   - Field: ‘state’
[08:28:15.339] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.339] - Launch lazy future ...
[08:28:15.339] Packages needed by the future expression (n = 0): <none>
[08:28:15.339] Packages needed by future strategies (n = 0): <none>
[08:28:15.340] {
[08:28:15.340]     {
[08:28:15.340]         {
[08:28:15.340]             ...future.startTime <- base::Sys.time()
[08:28:15.340]             {
[08:28:15.340]                 {
[08:28:15.340]                   {
[08:28:15.340]                     {
[08:28:15.340]                       base::local({
[08:28:15.340]                         has_future <- base::requireNamespace("future", 
[08:28:15.340]                           quietly = TRUE)
[08:28:15.340]                         if (has_future) {
[08:28:15.340]                           ns <- base::getNamespace("future")
[08:28:15.340]                           version <- ns[[".package"]][["version"]]
[08:28:15.340]                           if (is.null(version)) 
[08:28:15.340]                             version <- utils::packageVersion("future")
[08:28:15.340]                         }
[08:28:15.340]                         else {
[08:28:15.340]                           version <- NULL
[08:28:15.340]                         }
[08:28:15.340]                         if (!has_future || version < "1.8.0") {
[08:28:15.340]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.340]                             "", base::R.version$version.string), 
[08:28:15.340]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.340]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.340]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.340]                               "release", "version")], collapse = " "), 
[08:28:15.340]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.340]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.340]                             info)
[08:28:15.340]                           info <- base::paste(info, collapse = "; ")
[08:28:15.340]                           if (!has_future) {
[08:28:15.340]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.340]                               info)
[08:28:15.340]                           }
[08:28:15.340]                           else {
[08:28:15.340]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.340]                               info, version)
[08:28:15.340]                           }
[08:28:15.340]                           base::stop(msg)
[08:28:15.340]                         }
[08:28:15.340]                       })
[08:28:15.340]                     }
[08:28:15.340]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.340]                     base::options(mc.cores = 1L)
[08:28:15.340]                   }
[08:28:15.340]                   ...future.strategy.old <- future::plan("list")
[08:28:15.340]                   options(future.plan = NULL)
[08:28:15.340]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.340]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.340]                 }
[08:28:15.340]                 ...future.workdir <- getwd()
[08:28:15.340]             }
[08:28:15.340]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.340]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.340]         }
[08:28:15.340]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.340]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.340]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.340]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.340]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.340]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.340]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.340]             base::names(...future.oldOptions))
[08:28:15.340]     }
[08:28:15.340]     if (FALSE) {
[08:28:15.340]     }
[08:28:15.340]     else {
[08:28:15.340]         if (TRUE) {
[08:28:15.340]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.340]                 open = "w")
[08:28:15.340]         }
[08:28:15.340]         else {
[08:28:15.340]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.340]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.340]         }
[08:28:15.340]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.340]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.340]             base::sink(type = "output", split = FALSE)
[08:28:15.340]             base::close(...future.stdout)
[08:28:15.340]         }, add = TRUE)
[08:28:15.340]     }
[08:28:15.340]     ...future.frame <- base::sys.nframe()
[08:28:15.340]     ...future.conditions <- base::list()
[08:28:15.340]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.340]     if (FALSE) {
[08:28:15.340]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.340]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.340]     }
[08:28:15.340]     ...future.result <- base::tryCatch({
[08:28:15.340]         base::withCallingHandlers({
[08:28:15.340]             ...future.value <- base::withVisible(base::local({
[08:28:15.340]                 withCallingHandlers({
[08:28:15.340]                   {
[08:28:15.340]                     b <- a
[08:28:15.340]                     a <- 2
[08:28:15.340]                     a * b
[08:28:15.340]                   }
[08:28:15.340]                 }, immediateCondition = function(cond) {
[08:28:15.340]                   save_rds <- function (object, pathname, ...) 
[08:28:15.340]                   {
[08:28:15.340]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.340]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.340]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.340]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.340]                         fi_tmp[["mtime"]])
[08:28:15.340]                     }
[08:28:15.340]                     tryCatch({
[08:28:15.340]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.340]                     }, error = function(ex) {
[08:28:15.340]                       msg <- conditionMessage(ex)
[08:28:15.340]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.340]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.340]                         fi_tmp[["mtime"]], msg)
[08:28:15.340]                       ex$message <- msg
[08:28:15.340]                       stop(ex)
[08:28:15.340]                     })
[08:28:15.340]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.340]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.340]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.340]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.340]                       fi <- file.info(pathname)
[08:28:15.340]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.340]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.340]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.340]                         fi[["size"]], fi[["mtime"]])
[08:28:15.340]                       stop(msg)
[08:28:15.340]                     }
[08:28:15.340]                     invisible(pathname)
[08:28:15.340]                   }
[08:28:15.340]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.340]                     rootPath = tempdir()) 
[08:28:15.340]                   {
[08:28:15.340]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.340]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.340]                       tmpdir = path, fileext = ".rds")
[08:28:15.340]                     save_rds(obj, file)
[08:28:15.340]                   }
[08:28:15.340]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.340]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.340]                   {
[08:28:15.340]                     inherits <- base::inherits
[08:28:15.340]                     invokeRestart <- base::invokeRestart
[08:28:15.340]                     is.null <- base::is.null
[08:28:15.340]                     muffled <- FALSE
[08:28:15.340]                     if (inherits(cond, "message")) {
[08:28:15.340]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.340]                       if (muffled) 
[08:28:15.340]                         invokeRestart("muffleMessage")
[08:28:15.340]                     }
[08:28:15.340]                     else if (inherits(cond, "warning")) {
[08:28:15.340]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.340]                       if (muffled) 
[08:28:15.340]                         invokeRestart("muffleWarning")
[08:28:15.340]                     }
[08:28:15.340]                     else if (inherits(cond, "condition")) {
[08:28:15.340]                       if (!is.null(pattern)) {
[08:28:15.340]                         computeRestarts <- base::computeRestarts
[08:28:15.340]                         grepl <- base::grepl
[08:28:15.340]                         restarts <- computeRestarts(cond)
[08:28:15.340]                         for (restart in restarts) {
[08:28:15.340]                           name <- restart$name
[08:28:15.340]                           if (is.null(name)) 
[08:28:15.340]                             next
[08:28:15.340]                           if (!grepl(pattern, name)) 
[08:28:15.340]                             next
[08:28:15.340]                           invokeRestart(restart)
[08:28:15.340]                           muffled <- TRUE
[08:28:15.340]                           break
[08:28:15.340]                         }
[08:28:15.340]                       }
[08:28:15.340]                     }
[08:28:15.340]                     invisible(muffled)
[08:28:15.340]                   }
[08:28:15.340]                   muffleCondition(cond)
[08:28:15.340]                 })
[08:28:15.340]             }))
[08:28:15.340]             future::FutureResult(value = ...future.value$value, 
[08:28:15.340]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.340]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.340]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.340]                     ...future.globalenv.names))
[08:28:15.340]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.340]         }, condition = base::local({
[08:28:15.340]             c <- base::c
[08:28:15.340]             inherits <- base::inherits
[08:28:15.340]             invokeRestart <- base::invokeRestart
[08:28:15.340]             length <- base::length
[08:28:15.340]             list <- base::list
[08:28:15.340]             seq.int <- base::seq.int
[08:28:15.340]             signalCondition <- base::signalCondition
[08:28:15.340]             sys.calls <- base::sys.calls
[08:28:15.340]             `[[` <- base::`[[`
[08:28:15.340]             `+` <- base::`+`
[08:28:15.340]             `<<-` <- base::`<<-`
[08:28:15.340]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.340]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.340]                   3L)]
[08:28:15.340]             }
[08:28:15.340]             function(cond) {
[08:28:15.340]                 is_error <- inherits(cond, "error")
[08:28:15.340]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.340]                   NULL)
[08:28:15.340]                 if (is_error) {
[08:28:15.340]                   sessionInformation <- function() {
[08:28:15.340]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.340]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.340]                       search = base::search(), system = base::Sys.info())
[08:28:15.340]                   }
[08:28:15.340]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.340]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.340]                     cond$call), session = sessionInformation(), 
[08:28:15.340]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.340]                   signalCondition(cond)
[08:28:15.340]                 }
[08:28:15.340]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.340]                 "immediateCondition"))) {
[08:28:15.340]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.340]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.340]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.340]                   if (TRUE && !signal) {
[08:28:15.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.340]                     {
[08:28:15.340]                       inherits <- base::inherits
[08:28:15.340]                       invokeRestart <- base::invokeRestart
[08:28:15.340]                       is.null <- base::is.null
[08:28:15.340]                       muffled <- FALSE
[08:28:15.340]                       if (inherits(cond, "message")) {
[08:28:15.340]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.340]                         if (muffled) 
[08:28:15.340]                           invokeRestart("muffleMessage")
[08:28:15.340]                       }
[08:28:15.340]                       else if (inherits(cond, "warning")) {
[08:28:15.340]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.340]                         if (muffled) 
[08:28:15.340]                           invokeRestart("muffleWarning")
[08:28:15.340]                       }
[08:28:15.340]                       else if (inherits(cond, "condition")) {
[08:28:15.340]                         if (!is.null(pattern)) {
[08:28:15.340]                           computeRestarts <- base::computeRestarts
[08:28:15.340]                           grepl <- base::grepl
[08:28:15.340]                           restarts <- computeRestarts(cond)
[08:28:15.340]                           for (restart in restarts) {
[08:28:15.340]                             name <- restart$name
[08:28:15.340]                             if (is.null(name)) 
[08:28:15.340]                               next
[08:28:15.340]                             if (!grepl(pattern, name)) 
[08:28:15.340]                               next
[08:28:15.340]                             invokeRestart(restart)
[08:28:15.340]                             muffled <- TRUE
[08:28:15.340]                             break
[08:28:15.340]                           }
[08:28:15.340]                         }
[08:28:15.340]                       }
[08:28:15.340]                       invisible(muffled)
[08:28:15.340]                     }
[08:28:15.340]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.340]                   }
[08:28:15.340]                 }
[08:28:15.340]                 else {
[08:28:15.340]                   if (TRUE) {
[08:28:15.340]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.340]                     {
[08:28:15.340]                       inherits <- base::inherits
[08:28:15.340]                       invokeRestart <- base::invokeRestart
[08:28:15.340]                       is.null <- base::is.null
[08:28:15.340]                       muffled <- FALSE
[08:28:15.340]                       if (inherits(cond, "message")) {
[08:28:15.340]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.340]                         if (muffled) 
[08:28:15.340]                           invokeRestart("muffleMessage")
[08:28:15.340]                       }
[08:28:15.340]                       else if (inherits(cond, "warning")) {
[08:28:15.340]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.340]                         if (muffled) 
[08:28:15.340]                           invokeRestart("muffleWarning")
[08:28:15.340]                       }
[08:28:15.340]                       else if (inherits(cond, "condition")) {
[08:28:15.340]                         if (!is.null(pattern)) {
[08:28:15.340]                           computeRestarts <- base::computeRestarts
[08:28:15.340]                           grepl <- base::grepl
[08:28:15.340]                           restarts <- computeRestarts(cond)
[08:28:15.340]                           for (restart in restarts) {
[08:28:15.340]                             name <- restart$name
[08:28:15.340]                             if (is.null(name)) 
[08:28:15.340]                               next
[08:28:15.340]                             if (!grepl(pattern, name)) 
[08:28:15.340]                               next
[08:28:15.340]                             invokeRestart(restart)
[08:28:15.340]                             muffled <- TRUE
[08:28:15.340]                             break
[08:28:15.340]                           }
[08:28:15.340]                         }
[08:28:15.340]                       }
[08:28:15.340]                       invisible(muffled)
[08:28:15.340]                     }
[08:28:15.340]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.340]                   }
[08:28:15.340]                 }
[08:28:15.340]             }
[08:28:15.340]         }))
[08:28:15.340]     }, error = function(ex) {
[08:28:15.340]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.340]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.340]                 ...future.rng), started = ...future.startTime, 
[08:28:15.340]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.340]             version = "1.8"), class = "FutureResult")
[08:28:15.340]     }, finally = {
[08:28:15.340]         if (!identical(...future.workdir, getwd())) 
[08:28:15.340]             setwd(...future.workdir)
[08:28:15.340]         {
[08:28:15.340]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.340]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.340]             }
[08:28:15.340]             base::options(...future.oldOptions)
[08:28:15.340]             if (.Platform$OS.type == "windows") {
[08:28:15.340]                 old_names <- names(...future.oldEnvVars)
[08:28:15.340]                 envs <- base::Sys.getenv()
[08:28:15.340]                 names <- names(envs)
[08:28:15.340]                 common <- intersect(names, old_names)
[08:28:15.340]                 added <- setdiff(names, old_names)
[08:28:15.340]                 removed <- setdiff(old_names, names)
[08:28:15.340]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.340]                   envs[common]]
[08:28:15.340]                 NAMES <- toupper(changed)
[08:28:15.340]                 args <- list()
[08:28:15.340]                 for (kk in seq_along(NAMES)) {
[08:28:15.340]                   name <- changed[[kk]]
[08:28:15.340]                   NAME <- NAMES[[kk]]
[08:28:15.340]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.340]                     next
[08:28:15.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.340]                 }
[08:28:15.340]                 NAMES <- toupper(added)
[08:28:15.340]                 for (kk in seq_along(NAMES)) {
[08:28:15.340]                   name <- added[[kk]]
[08:28:15.340]                   NAME <- NAMES[[kk]]
[08:28:15.340]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.340]                     next
[08:28:15.340]                   args[[name]] <- ""
[08:28:15.340]                 }
[08:28:15.340]                 NAMES <- toupper(removed)
[08:28:15.340]                 for (kk in seq_along(NAMES)) {
[08:28:15.340]                   name <- removed[[kk]]
[08:28:15.340]                   NAME <- NAMES[[kk]]
[08:28:15.340]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.340]                     next
[08:28:15.340]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.340]                 }
[08:28:15.340]                 if (length(args) > 0) 
[08:28:15.340]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.340]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.340]             }
[08:28:15.340]             else {
[08:28:15.340]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.340]             }
[08:28:15.340]             {
[08:28:15.340]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.340]                   0L) {
[08:28:15.340]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.340]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.340]                   base::options(opts)
[08:28:15.340]                 }
[08:28:15.340]                 {
[08:28:15.340]                   {
[08:28:15.340]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.340]                     NULL
[08:28:15.340]                   }
[08:28:15.340]                   options(future.plan = NULL)
[08:28:15.340]                   if (is.na(NA_character_)) 
[08:28:15.340]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.340]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.340]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.340]                     .init = FALSE)
[08:28:15.340]                 }
[08:28:15.340]             }
[08:28:15.340]         }
[08:28:15.340]     })
[08:28:15.340]     if (TRUE) {
[08:28:15.340]         base::sink(type = "output", split = FALSE)
[08:28:15.340]         if (TRUE) {
[08:28:15.340]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.340]         }
[08:28:15.340]         else {
[08:28:15.340]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.340]         }
[08:28:15.340]         base::close(...future.stdout)
[08:28:15.340]         ...future.stdout <- NULL
[08:28:15.340]     }
[08:28:15.340]     ...future.result$conditions <- ...future.conditions
[08:28:15.340]     ...future.result$finished <- base::Sys.time()
[08:28:15.340]     ...future.result
[08:28:15.340] }
[08:28:15.342] assign_globals() ...
[08:28:15.343] List of 1
[08:28:15.343]  $ a: num 3
[08:28:15.343]  - attr(*, "where")=List of 1
[08:28:15.343]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.343]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.343]  - attr(*, "resolved")= logi TRUE
[08:28:15.343]  - attr(*, "total_size")= num 39
[08:28:15.343]  - attr(*, "already-done")= logi TRUE
[08:28:15.346] - copied ‘a’ to environment
[08:28:15.346] assign_globals() ... done
[08:28:15.346] requestCore(): workers = 2
[08:28:15.348] MulticoreFuture started
[08:28:15.349] - Launch lazy future ... done
[08:28:15.349] run() for ‘MulticoreFuture’ ... done
[08:28:15.349] result() for MulticoreFuture ...
[08:28:15.349] plan(): Setting new future strategy stack:
[08:28:15.350] List of future strategies:
[08:28:15.350] 1. sequential:
[08:28:15.350]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.350]    - tweaked: FALSE
[08:28:15.350]    - call: NULL
[08:28:15.351] plan(): nbrOfWorkers() = 1
[08:28:15.369] plan(): Setting new future strategy stack:
[08:28:15.369] List of future strategies:
[08:28:15.369] 1. multicore:
[08:28:15.369]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.369]    - tweaked: FALSE
[08:28:15.369]    - call: plan(strategy)
[08:28:15.372] plan(): nbrOfWorkers() = 2
[08:28:15.373] result() for MulticoreFuture ...
[08:28:15.373] result() for MulticoreFuture ... done
[08:28:15.373] result() for MulticoreFuture ... done
[08:28:15.373] result() for MulticoreFuture ...
[08:28:15.373] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.385] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.385] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.388] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.388] Searching for globals ... DONE
[08:28:15.388] Resolving globals: TRUE
[08:28:15.388] Resolving any globals that are futures ...
[08:28:15.388] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.388] Resolving any globals that are futures ... DONE
[08:28:15.389] Resolving futures part of globals (recursively) ...
[08:28:15.389] resolve() on list ...
[08:28:15.389]  recursive: 99
[08:28:15.389]  length: 2
[08:28:15.389]  elements: ‘a’, ‘ii’
[08:28:15.390]  length: 1 (resolved future 1)
[08:28:15.390]  length: 0 (resolved future 2)
[08:28:15.390] resolve() on list ... DONE
[08:28:15.390] - globals: [2] ‘a’, ‘ii’
[08:28:15.390] Resolving futures part of globals (recursively) ... DONE
[08:28:15.390] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:15.391] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:15.391] - globals: [2] ‘a’, ‘ii’
[08:28:15.391] 
[08:28:15.391] getGlobalsAndPackages() ... DONE
[08:28:15.392] run() for ‘Future’ ...
[08:28:15.392] - state: ‘created’
[08:28:15.392] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.394] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.394] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.394]   - Field: ‘label’
[08:28:15.394]   - Field: ‘local’
[08:28:15.394]   - Field: ‘owner’
[08:28:15.394]   - Field: ‘envir’
[08:28:15.395]   - Field: ‘workers’
[08:28:15.395]   - Field: ‘packages’
[08:28:15.395]   - Field: ‘gc’
[08:28:15.395]   - Field: ‘job’
[08:28:15.395]   - Field: ‘conditions’
[08:28:15.395]   - Field: ‘expr’
[08:28:15.395]   - Field: ‘uuid’
[08:28:15.395]   - Field: ‘seed’
[08:28:15.395]   - Field: ‘version’
[08:28:15.396]   - Field: ‘result’
[08:28:15.396]   - Field: ‘asynchronous’
[08:28:15.396]   - Field: ‘calls’
[08:28:15.396]   - Field: ‘globals’
[08:28:15.396]   - Field: ‘stdout’
[08:28:15.396]   - Field: ‘earlySignal’
[08:28:15.396]   - Field: ‘lazy’
[08:28:15.396]   - Field: ‘state’
[08:28:15.396] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.396] - Launch lazy future ...
[08:28:15.397] Packages needed by the future expression (n = 0): <none>
[08:28:15.397] Packages needed by future strategies (n = 0): <none>
[08:28:15.397] {
[08:28:15.397]     {
[08:28:15.397]         {
[08:28:15.397]             ...future.startTime <- base::Sys.time()
[08:28:15.397]             {
[08:28:15.397]                 {
[08:28:15.397]                   {
[08:28:15.397]                     {
[08:28:15.397]                       base::local({
[08:28:15.397]                         has_future <- base::requireNamespace("future", 
[08:28:15.397]                           quietly = TRUE)
[08:28:15.397]                         if (has_future) {
[08:28:15.397]                           ns <- base::getNamespace("future")
[08:28:15.397]                           version <- ns[[".package"]][["version"]]
[08:28:15.397]                           if (is.null(version)) 
[08:28:15.397]                             version <- utils::packageVersion("future")
[08:28:15.397]                         }
[08:28:15.397]                         else {
[08:28:15.397]                           version <- NULL
[08:28:15.397]                         }
[08:28:15.397]                         if (!has_future || version < "1.8.0") {
[08:28:15.397]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.397]                             "", base::R.version$version.string), 
[08:28:15.397]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.397]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.397]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.397]                               "release", "version")], collapse = " "), 
[08:28:15.397]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.397]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.397]                             info)
[08:28:15.397]                           info <- base::paste(info, collapse = "; ")
[08:28:15.397]                           if (!has_future) {
[08:28:15.397]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.397]                               info)
[08:28:15.397]                           }
[08:28:15.397]                           else {
[08:28:15.397]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.397]                               info, version)
[08:28:15.397]                           }
[08:28:15.397]                           base::stop(msg)
[08:28:15.397]                         }
[08:28:15.397]                       })
[08:28:15.397]                     }
[08:28:15.397]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.397]                     base::options(mc.cores = 1L)
[08:28:15.397]                   }
[08:28:15.397]                   ...future.strategy.old <- future::plan("list")
[08:28:15.397]                   options(future.plan = NULL)
[08:28:15.397]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.397]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.397]                 }
[08:28:15.397]                 ...future.workdir <- getwd()
[08:28:15.397]             }
[08:28:15.397]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.397]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.397]         }
[08:28:15.397]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.397]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.397]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.397]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.397]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.397]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.397]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.397]             base::names(...future.oldOptions))
[08:28:15.397]     }
[08:28:15.397]     if (FALSE) {
[08:28:15.397]     }
[08:28:15.397]     else {
[08:28:15.397]         if (TRUE) {
[08:28:15.397]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.397]                 open = "w")
[08:28:15.397]         }
[08:28:15.397]         else {
[08:28:15.397]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.397]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.397]         }
[08:28:15.397]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.397]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.397]             base::sink(type = "output", split = FALSE)
[08:28:15.397]             base::close(...future.stdout)
[08:28:15.397]         }, add = TRUE)
[08:28:15.397]     }
[08:28:15.397]     ...future.frame <- base::sys.nframe()
[08:28:15.397]     ...future.conditions <- base::list()
[08:28:15.397]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.397]     if (FALSE) {
[08:28:15.397]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.397]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.397]     }
[08:28:15.397]     ...future.result <- base::tryCatch({
[08:28:15.397]         base::withCallingHandlers({
[08:28:15.397]             ...future.value <- base::withVisible(base::local({
[08:28:15.397]                 withCallingHandlers({
[08:28:15.397]                   {
[08:28:15.397]                     b <- a * ii
[08:28:15.397]                     a <- 0
[08:28:15.397]                     b
[08:28:15.397]                   }
[08:28:15.397]                 }, immediateCondition = function(cond) {
[08:28:15.397]                   save_rds <- function (object, pathname, ...) 
[08:28:15.397]                   {
[08:28:15.397]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.397]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.397]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.397]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.397]                         fi_tmp[["mtime"]])
[08:28:15.397]                     }
[08:28:15.397]                     tryCatch({
[08:28:15.397]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.397]                     }, error = function(ex) {
[08:28:15.397]                       msg <- conditionMessage(ex)
[08:28:15.397]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.397]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.397]                         fi_tmp[["mtime"]], msg)
[08:28:15.397]                       ex$message <- msg
[08:28:15.397]                       stop(ex)
[08:28:15.397]                     })
[08:28:15.397]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.397]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.397]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.397]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.397]                       fi <- file.info(pathname)
[08:28:15.397]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.397]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.397]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.397]                         fi[["size"]], fi[["mtime"]])
[08:28:15.397]                       stop(msg)
[08:28:15.397]                     }
[08:28:15.397]                     invisible(pathname)
[08:28:15.397]                   }
[08:28:15.397]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.397]                     rootPath = tempdir()) 
[08:28:15.397]                   {
[08:28:15.397]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.397]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.397]                       tmpdir = path, fileext = ".rds")
[08:28:15.397]                     save_rds(obj, file)
[08:28:15.397]                   }
[08:28:15.397]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.397]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.397]                   {
[08:28:15.397]                     inherits <- base::inherits
[08:28:15.397]                     invokeRestart <- base::invokeRestart
[08:28:15.397]                     is.null <- base::is.null
[08:28:15.397]                     muffled <- FALSE
[08:28:15.397]                     if (inherits(cond, "message")) {
[08:28:15.397]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.397]                       if (muffled) 
[08:28:15.397]                         invokeRestart("muffleMessage")
[08:28:15.397]                     }
[08:28:15.397]                     else if (inherits(cond, "warning")) {
[08:28:15.397]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.397]                       if (muffled) 
[08:28:15.397]                         invokeRestart("muffleWarning")
[08:28:15.397]                     }
[08:28:15.397]                     else if (inherits(cond, "condition")) {
[08:28:15.397]                       if (!is.null(pattern)) {
[08:28:15.397]                         computeRestarts <- base::computeRestarts
[08:28:15.397]                         grepl <- base::grepl
[08:28:15.397]                         restarts <- computeRestarts(cond)
[08:28:15.397]                         for (restart in restarts) {
[08:28:15.397]                           name <- restart$name
[08:28:15.397]                           if (is.null(name)) 
[08:28:15.397]                             next
[08:28:15.397]                           if (!grepl(pattern, name)) 
[08:28:15.397]                             next
[08:28:15.397]                           invokeRestart(restart)
[08:28:15.397]                           muffled <- TRUE
[08:28:15.397]                           break
[08:28:15.397]                         }
[08:28:15.397]                       }
[08:28:15.397]                     }
[08:28:15.397]                     invisible(muffled)
[08:28:15.397]                   }
[08:28:15.397]                   muffleCondition(cond)
[08:28:15.397]                 })
[08:28:15.397]             }))
[08:28:15.397]             future::FutureResult(value = ...future.value$value, 
[08:28:15.397]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.397]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.397]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.397]                     ...future.globalenv.names))
[08:28:15.397]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.397]         }, condition = base::local({
[08:28:15.397]             c <- base::c
[08:28:15.397]             inherits <- base::inherits
[08:28:15.397]             invokeRestart <- base::invokeRestart
[08:28:15.397]             length <- base::length
[08:28:15.397]             list <- base::list
[08:28:15.397]             seq.int <- base::seq.int
[08:28:15.397]             signalCondition <- base::signalCondition
[08:28:15.397]             sys.calls <- base::sys.calls
[08:28:15.397]             `[[` <- base::`[[`
[08:28:15.397]             `+` <- base::`+`
[08:28:15.397]             `<<-` <- base::`<<-`
[08:28:15.397]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.397]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.397]                   3L)]
[08:28:15.397]             }
[08:28:15.397]             function(cond) {
[08:28:15.397]                 is_error <- inherits(cond, "error")
[08:28:15.397]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.397]                   NULL)
[08:28:15.397]                 if (is_error) {
[08:28:15.397]                   sessionInformation <- function() {
[08:28:15.397]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.397]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.397]                       search = base::search(), system = base::Sys.info())
[08:28:15.397]                   }
[08:28:15.397]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.397]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.397]                     cond$call), session = sessionInformation(), 
[08:28:15.397]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.397]                   signalCondition(cond)
[08:28:15.397]                 }
[08:28:15.397]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.397]                 "immediateCondition"))) {
[08:28:15.397]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.397]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.397]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.397]                   if (TRUE && !signal) {
[08:28:15.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.397]                     {
[08:28:15.397]                       inherits <- base::inherits
[08:28:15.397]                       invokeRestart <- base::invokeRestart
[08:28:15.397]                       is.null <- base::is.null
[08:28:15.397]                       muffled <- FALSE
[08:28:15.397]                       if (inherits(cond, "message")) {
[08:28:15.397]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.397]                         if (muffled) 
[08:28:15.397]                           invokeRestart("muffleMessage")
[08:28:15.397]                       }
[08:28:15.397]                       else if (inherits(cond, "warning")) {
[08:28:15.397]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.397]                         if (muffled) 
[08:28:15.397]                           invokeRestart("muffleWarning")
[08:28:15.397]                       }
[08:28:15.397]                       else if (inherits(cond, "condition")) {
[08:28:15.397]                         if (!is.null(pattern)) {
[08:28:15.397]                           computeRestarts <- base::computeRestarts
[08:28:15.397]                           grepl <- base::grepl
[08:28:15.397]                           restarts <- computeRestarts(cond)
[08:28:15.397]                           for (restart in restarts) {
[08:28:15.397]                             name <- restart$name
[08:28:15.397]                             if (is.null(name)) 
[08:28:15.397]                               next
[08:28:15.397]                             if (!grepl(pattern, name)) 
[08:28:15.397]                               next
[08:28:15.397]                             invokeRestart(restart)
[08:28:15.397]                             muffled <- TRUE
[08:28:15.397]                             break
[08:28:15.397]                           }
[08:28:15.397]                         }
[08:28:15.397]                       }
[08:28:15.397]                       invisible(muffled)
[08:28:15.397]                     }
[08:28:15.397]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.397]                   }
[08:28:15.397]                 }
[08:28:15.397]                 else {
[08:28:15.397]                   if (TRUE) {
[08:28:15.397]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.397]                     {
[08:28:15.397]                       inherits <- base::inherits
[08:28:15.397]                       invokeRestart <- base::invokeRestart
[08:28:15.397]                       is.null <- base::is.null
[08:28:15.397]                       muffled <- FALSE
[08:28:15.397]                       if (inherits(cond, "message")) {
[08:28:15.397]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.397]                         if (muffled) 
[08:28:15.397]                           invokeRestart("muffleMessage")
[08:28:15.397]                       }
[08:28:15.397]                       else if (inherits(cond, "warning")) {
[08:28:15.397]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.397]                         if (muffled) 
[08:28:15.397]                           invokeRestart("muffleWarning")
[08:28:15.397]                       }
[08:28:15.397]                       else if (inherits(cond, "condition")) {
[08:28:15.397]                         if (!is.null(pattern)) {
[08:28:15.397]                           computeRestarts <- base::computeRestarts
[08:28:15.397]                           grepl <- base::grepl
[08:28:15.397]                           restarts <- computeRestarts(cond)
[08:28:15.397]                           for (restart in restarts) {
[08:28:15.397]                             name <- restart$name
[08:28:15.397]                             if (is.null(name)) 
[08:28:15.397]                               next
[08:28:15.397]                             if (!grepl(pattern, name)) 
[08:28:15.397]                               next
[08:28:15.397]                             invokeRestart(restart)
[08:28:15.397]                             muffled <- TRUE
[08:28:15.397]                             break
[08:28:15.397]                           }
[08:28:15.397]                         }
[08:28:15.397]                       }
[08:28:15.397]                       invisible(muffled)
[08:28:15.397]                     }
[08:28:15.397]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.397]                   }
[08:28:15.397]                 }
[08:28:15.397]             }
[08:28:15.397]         }))
[08:28:15.397]     }, error = function(ex) {
[08:28:15.397]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.397]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.397]                 ...future.rng), started = ...future.startTime, 
[08:28:15.397]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.397]             version = "1.8"), class = "FutureResult")
[08:28:15.397]     }, finally = {
[08:28:15.397]         if (!identical(...future.workdir, getwd())) 
[08:28:15.397]             setwd(...future.workdir)
[08:28:15.397]         {
[08:28:15.397]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.397]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.397]             }
[08:28:15.397]             base::options(...future.oldOptions)
[08:28:15.397]             if (.Platform$OS.type == "windows") {
[08:28:15.397]                 old_names <- names(...future.oldEnvVars)
[08:28:15.397]                 envs <- base::Sys.getenv()
[08:28:15.397]                 names <- names(envs)
[08:28:15.397]                 common <- intersect(names, old_names)
[08:28:15.397]                 added <- setdiff(names, old_names)
[08:28:15.397]                 removed <- setdiff(old_names, names)
[08:28:15.397]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.397]                   envs[common]]
[08:28:15.397]                 NAMES <- toupper(changed)
[08:28:15.397]                 args <- list()
[08:28:15.397]                 for (kk in seq_along(NAMES)) {
[08:28:15.397]                   name <- changed[[kk]]
[08:28:15.397]                   NAME <- NAMES[[kk]]
[08:28:15.397]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.397]                     next
[08:28:15.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.397]                 }
[08:28:15.397]                 NAMES <- toupper(added)
[08:28:15.397]                 for (kk in seq_along(NAMES)) {
[08:28:15.397]                   name <- added[[kk]]
[08:28:15.397]                   NAME <- NAMES[[kk]]
[08:28:15.397]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.397]                     next
[08:28:15.397]                   args[[name]] <- ""
[08:28:15.397]                 }
[08:28:15.397]                 NAMES <- toupper(removed)
[08:28:15.397]                 for (kk in seq_along(NAMES)) {
[08:28:15.397]                   name <- removed[[kk]]
[08:28:15.397]                   NAME <- NAMES[[kk]]
[08:28:15.397]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.397]                     next
[08:28:15.397]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.397]                 }
[08:28:15.397]                 if (length(args) > 0) 
[08:28:15.397]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.397]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.397]             }
[08:28:15.397]             else {
[08:28:15.397]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.397]             }
[08:28:15.397]             {
[08:28:15.397]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.397]                   0L) {
[08:28:15.397]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.397]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.397]                   base::options(opts)
[08:28:15.397]                 }
[08:28:15.397]                 {
[08:28:15.397]                   {
[08:28:15.397]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.397]                     NULL
[08:28:15.397]                   }
[08:28:15.397]                   options(future.plan = NULL)
[08:28:15.397]                   if (is.na(NA_character_)) 
[08:28:15.397]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.397]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.397]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.397]                     .init = FALSE)
[08:28:15.397]                 }
[08:28:15.397]             }
[08:28:15.397]         }
[08:28:15.397]     })
[08:28:15.397]     if (TRUE) {
[08:28:15.397]         base::sink(type = "output", split = FALSE)
[08:28:15.397]         if (TRUE) {
[08:28:15.397]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.397]         }
[08:28:15.397]         else {
[08:28:15.397]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.397]         }
[08:28:15.397]         base::close(...future.stdout)
[08:28:15.397]         ...future.stdout <- NULL
[08:28:15.397]     }
[08:28:15.397]     ...future.result$conditions <- ...future.conditions
[08:28:15.397]     ...future.result$finished <- base::Sys.time()
[08:28:15.397]     ...future.result
[08:28:15.397] }
[08:28:15.400] assign_globals() ...
[08:28:15.400] List of 2
[08:28:15.400]  $ a : num 1
[08:28:15.400]  $ ii: int 1
[08:28:15.400]  - attr(*, "where")=List of 2
[08:28:15.400]   ..$ a :<environment: R_EmptyEnv> 
[08:28:15.400]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:15.400]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.400]  - attr(*, "resolved")= logi TRUE
[08:28:15.400]  - attr(*, "total_size")= num 74
[08:28:15.400]  - attr(*, "already-done")= logi TRUE
[08:28:15.403] - copied ‘a’ to environment
[08:28:15.403] - copied ‘ii’ to environment
[08:28:15.403] assign_globals() ... done
[08:28:15.404] requestCore(): workers = 2
[08:28:15.406] MulticoreFuture started
[08:28:15.406] - Launch lazy future ... done
[08:28:15.406] run() for ‘MulticoreFuture’ ... done
[08:28:15.407] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.408] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.407] List of future strategies:
[08:28:15.407] 1. sequential:
[08:28:15.407]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.407]    - tweaked: FALSE
[08:28:15.407]    - call: NULL
[08:28:15.408] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.408] plan(): nbrOfWorkers() = 1
[08:28:15.411] plan(): Setting new future strategy stack:
[08:28:15.411] List of future strategies:
[08:28:15.411] 1. multicore:
[08:28:15.411]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.411]    - tweaked: FALSE
[08:28:15.411]    - call: plan(strategy)
[08:28:15.412] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.412] Searching for globals ... DONE
[08:28:15.413] Resolving globals: TRUE
[08:28:15.413] Resolving any globals that are futures ...
[08:28:15.413] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.413] Resolving any globals that are futures ... DONE
[08:28:15.414] Resolving futures part of globals (recursively) ...
[08:28:15.414] plan(): nbrOfWorkers() = 2
[08:28:15.414] resolve() on list ...
[08:28:15.414]  recursive: 99
[08:28:15.415]  length: 2
[08:28:15.415]  elements: ‘a’, ‘ii’
[08:28:15.415]  length: 1 (resolved future 1)
[08:28:15.415]  length: 0 (resolved future 2)
[08:28:15.415] resolve() on list ... DONE
[08:28:15.415] - globals: [2] ‘a’, ‘ii’
[08:28:15.416] Resolving futures part of globals (recursively) ... DONE
[08:28:15.416] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:15.417] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:15.417] - globals: [2] ‘a’, ‘ii’
[08:28:15.417] 
[08:28:15.417] getGlobalsAndPackages() ... DONE
[08:28:15.418] run() for ‘Future’ ...
[08:28:15.418] - state: ‘created’
[08:28:15.418] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.421] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.421] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.421]   - Field: ‘label’
[08:28:15.421]   - Field: ‘local’
[08:28:15.422]   - Field: ‘owner’
[08:28:15.422]   - Field: ‘envir’
[08:28:15.422]   - Field: ‘workers’
[08:28:15.422]   - Field: ‘packages’
[08:28:15.422]   - Field: ‘gc’
[08:28:15.422]   - Field: ‘job’
[08:28:15.422]   - Field: ‘conditions’
[08:28:15.426]   - Field: ‘expr’
[08:28:15.426]   - Field: ‘uuid’
[08:28:15.426]   - Field: ‘seed’
[08:28:15.427]   - Field: ‘version’
[08:28:15.427]   - Field: ‘result’
[08:28:15.427]   - Field: ‘asynchronous’
[08:28:15.427]   - Field: ‘calls’
[08:28:15.427]   - Field: ‘globals’
[08:28:15.427]   - Field: ‘stdout’
[08:28:15.428]   - Field: ‘earlySignal’
[08:28:15.428]   - Field: ‘lazy’
[08:28:15.428]   - Field: ‘state’
[08:28:15.428] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.429] - Launch lazy future ...
[08:28:15.429] Packages needed by the future expression (n = 0): <none>
[08:28:15.429] Packages needed by future strategies (n = 0): <none>
[08:28:15.430] {
[08:28:15.430]     {
[08:28:15.430]         {
[08:28:15.430]             ...future.startTime <- base::Sys.time()
[08:28:15.430]             {
[08:28:15.430]                 {
[08:28:15.430]                   {
[08:28:15.430]                     {
[08:28:15.430]                       base::local({
[08:28:15.430]                         has_future <- base::requireNamespace("future", 
[08:28:15.430]                           quietly = TRUE)
[08:28:15.430]                         if (has_future) {
[08:28:15.430]                           ns <- base::getNamespace("future")
[08:28:15.430]                           version <- ns[[".package"]][["version"]]
[08:28:15.430]                           if (is.null(version)) 
[08:28:15.430]                             version <- utils::packageVersion("future")
[08:28:15.430]                         }
[08:28:15.430]                         else {
[08:28:15.430]                           version <- NULL
[08:28:15.430]                         }
[08:28:15.430]                         if (!has_future || version < "1.8.0") {
[08:28:15.430]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.430]                             "", base::R.version$version.string), 
[08:28:15.430]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.430]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.430]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.430]                               "release", "version")], collapse = " "), 
[08:28:15.430]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.430]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.430]                             info)
[08:28:15.430]                           info <- base::paste(info, collapse = "; ")
[08:28:15.430]                           if (!has_future) {
[08:28:15.430]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.430]                               info)
[08:28:15.430]                           }
[08:28:15.430]                           else {
[08:28:15.430]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.430]                               info, version)
[08:28:15.430]                           }
[08:28:15.430]                           base::stop(msg)
[08:28:15.430]                         }
[08:28:15.430]                       })
[08:28:15.430]                     }
[08:28:15.430]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.430]                     base::options(mc.cores = 1L)
[08:28:15.430]                   }
[08:28:15.430]                   ...future.strategy.old <- future::plan("list")
[08:28:15.430]                   options(future.plan = NULL)
[08:28:15.430]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.430]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.430]                 }
[08:28:15.430]                 ...future.workdir <- getwd()
[08:28:15.430]             }
[08:28:15.430]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.430]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.430]         }
[08:28:15.430]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.430]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.430]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.430]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.430]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.430]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.430]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.430]             base::names(...future.oldOptions))
[08:28:15.430]     }
[08:28:15.430]     if (FALSE) {
[08:28:15.430]     }
[08:28:15.430]     else {
[08:28:15.430]         if (TRUE) {
[08:28:15.430]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.430]                 open = "w")
[08:28:15.430]         }
[08:28:15.430]         else {
[08:28:15.430]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.430]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.430]         }
[08:28:15.430]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.430]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.430]             base::sink(type = "output", split = FALSE)
[08:28:15.430]             base::close(...future.stdout)
[08:28:15.430]         }, add = TRUE)
[08:28:15.430]     }
[08:28:15.430]     ...future.frame <- base::sys.nframe()
[08:28:15.430]     ...future.conditions <- base::list()
[08:28:15.430]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.430]     if (FALSE) {
[08:28:15.430]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.430]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.430]     }
[08:28:15.430]     ...future.result <- base::tryCatch({
[08:28:15.430]         base::withCallingHandlers({
[08:28:15.430]             ...future.value <- base::withVisible(base::local({
[08:28:15.430]                 withCallingHandlers({
[08:28:15.430]                   {
[08:28:15.430]                     b <- a * ii
[08:28:15.430]                     a <- 0
[08:28:15.430]                     b
[08:28:15.430]                   }
[08:28:15.430]                 }, immediateCondition = function(cond) {
[08:28:15.430]                   save_rds <- function (object, pathname, ...) 
[08:28:15.430]                   {
[08:28:15.430]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.430]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.430]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.430]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.430]                         fi_tmp[["mtime"]])
[08:28:15.430]                     }
[08:28:15.430]                     tryCatch({
[08:28:15.430]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.430]                     }, error = function(ex) {
[08:28:15.430]                       msg <- conditionMessage(ex)
[08:28:15.430]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.430]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.430]                         fi_tmp[["mtime"]], msg)
[08:28:15.430]                       ex$message <- msg
[08:28:15.430]                       stop(ex)
[08:28:15.430]                     })
[08:28:15.430]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.430]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.430]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.430]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.430]                       fi <- file.info(pathname)
[08:28:15.430]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.430]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.430]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.430]                         fi[["size"]], fi[["mtime"]])
[08:28:15.430]                       stop(msg)
[08:28:15.430]                     }
[08:28:15.430]                     invisible(pathname)
[08:28:15.430]                   }
[08:28:15.430]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.430]                     rootPath = tempdir()) 
[08:28:15.430]                   {
[08:28:15.430]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.430]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.430]                       tmpdir = path, fileext = ".rds")
[08:28:15.430]                     save_rds(obj, file)
[08:28:15.430]                   }
[08:28:15.430]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.430]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.430]                   {
[08:28:15.430]                     inherits <- base::inherits
[08:28:15.430]                     invokeRestart <- base::invokeRestart
[08:28:15.430]                     is.null <- base::is.null
[08:28:15.430]                     muffled <- FALSE
[08:28:15.430]                     if (inherits(cond, "message")) {
[08:28:15.430]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.430]                       if (muffled) 
[08:28:15.430]                         invokeRestart("muffleMessage")
[08:28:15.430]                     }
[08:28:15.430]                     else if (inherits(cond, "warning")) {
[08:28:15.430]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.430]                       if (muffled) 
[08:28:15.430]                         invokeRestart("muffleWarning")
[08:28:15.430]                     }
[08:28:15.430]                     else if (inherits(cond, "condition")) {
[08:28:15.430]                       if (!is.null(pattern)) {
[08:28:15.430]                         computeRestarts <- base::computeRestarts
[08:28:15.430]                         grepl <- base::grepl
[08:28:15.430]                         restarts <- computeRestarts(cond)
[08:28:15.430]                         for (restart in restarts) {
[08:28:15.430]                           name <- restart$name
[08:28:15.430]                           if (is.null(name)) 
[08:28:15.430]                             next
[08:28:15.430]                           if (!grepl(pattern, name)) 
[08:28:15.430]                             next
[08:28:15.430]                           invokeRestart(restart)
[08:28:15.430]                           muffled <- TRUE
[08:28:15.430]                           break
[08:28:15.430]                         }
[08:28:15.430]                       }
[08:28:15.430]                     }
[08:28:15.430]                     invisible(muffled)
[08:28:15.430]                   }
[08:28:15.430]                   muffleCondition(cond)
[08:28:15.430]                 })
[08:28:15.430]             }))
[08:28:15.430]             future::FutureResult(value = ...future.value$value, 
[08:28:15.430]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.430]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.430]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.430]                     ...future.globalenv.names))
[08:28:15.430]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.430]         }, condition = base::local({
[08:28:15.430]             c <- base::c
[08:28:15.430]             inherits <- base::inherits
[08:28:15.430]             invokeRestart <- base::invokeRestart
[08:28:15.430]             length <- base::length
[08:28:15.430]             list <- base::list
[08:28:15.430]             seq.int <- base::seq.int
[08:28:15.430]             signalCondition <- base::signalCondition
[08:28:15.430]             sys.calls <- base::sys.calls
[08:28:15.430]             `[[` <- base::`[[`
[08:28:15.430]             `+` <- base::`+`
[08:28:15.430]             `<<-` <- base::`<<-`
[08:28:15.430]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.430]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.430]                   3L)]
[08:28:15.430]             }
[08:28:15.430]             function(cond) {
[08:28:15.430]                 is_error <- inherits(cond, "error")
[08:28:15.430]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.430]                   NULL)
[08:28:15.430]                 if (is_error) {
[08:28:15.430]                   sessionInformation <- function() {
[08:28:15.430]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.430]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.430]                       search = base::search(), system = base::Sys.info())
[08:28:15.430]                   }
[08:28:15.430]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.430]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.430]                     cond$call), session = sessionInformation(), 
[08:28:15.430]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.430]                   signalCondition(cond)
[08:28:15.430]                 }
[08:28:15.430]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.430]                 "immediateCondition"))) {
[08:28:15.430]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.430]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.430]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.430]                   if (TRUE && !signal) {
[08:28:15.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.430]                     {
[08:28:15.430]                       inherits <- base::inherits
[08:28:15.430]                       invokeRestart <- base::invokeRestart
[08:28:15.430]                       is.null <- base::is.null
[08:28:15.430]                       muffled <- FALSE
[08:28:15.430]                       if (inherits(cond, "message")) {
[08:28:15.430]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.430]                         if (muffled) 
[08:28:15.430]                           invokeRestart("muffleMessage")
[08:28:15.430]                       }
[08:28:15.430]                       else if (inherits(cond, "warning")) {
[08:28:15.430]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.430]                         if (muffled) 
[08:28:15.430]                           invokeRestart("muffleWarning")
[08:28:15.430]                       }
[08:28:15.430]                       else if (inherits(cond, "condition")) {
[08:28:15.430]                         if (!is.null(pattern)) {
[08:28:15.430]                           computeRestarts <- base::computeRestarts
[08:28:15.430]                           grepl <- base::grepl
[08:28:15.430]                           restarts <- computeRestarts(cond)
[08:28:15.430]                           for (restart in restarts) {
[08:28:15.430]                             name <- restart$name
[08:28:15.430]                             if (is.null(name)) 
[08:28:15.430]                               next
[08:28:15.430]                             if (!grepl(pattern, name)) 
[08:28:15.430]                               next
[08:28:15.430]                             invokeRestart(restart)
[08:28:15.430]                             muffled <- TRUE
[08:28:15.430]                             break
[08:28:15.430]                           }
[08:28:15.430]                         }
[08:28:15.430]                       }
[08:28:15.430]                       invisible(muffled)
[08:28:15.430]                     }
[08:28:15.430]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.430]                   }
[08:28:15.430]                 }
[08:28:15.430]                 else {
[08:28:15.430]                   if (TRUE) {
[08:28:15.430]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.430]                     {
[08:28:15.430]                       inherits <- base::inherits
[08:28:15.430]                       invokeRestart <- base::invokeRestart
[08:28:15.430]                       is.null <- base::is.null
[08:28:15.430]                       muffled <- FALSE
[08:28:15.430]                       if (inherits(cond, "message")) {
[08:28:15.430]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.430]                         if (muffled) 
[08:28:15.430]                           invokeRestart("muffleMessage")
[08:28:15.430]                       }
[08:28:15.430]                       else if (inherits(cond, "warning")) {
[08:28:15.430]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.430]                         if (muffled) 
[08:28:15.430]                           invokeRestart("muffleWarning")
[08:28:15.430]                       }
[08:28:15.430]                       else if (inherits(cond, "condition")) {
[08:28:15.430]                         if (!is.null(pattern)) {
[08:28:15.430]                           computeRestarts <- base::computeRestarts
[08:28:15.430]                           grepl <- base::grepl
[08:28:15.430]                           restarts <- computeRestarts(cond)
[08:28:15.430]                           for (restart in restarts) {
[08:28:15.430]                             name <- restart$name
[08:28:15.430]                             if (is.null(name)) 
[08:28:15.430]                               next
[08:28:15.430]                             if (!grepl(pattern, name)) 
[08:28:15.430]                               next
[08:28:15.430]                             invokeRestart(restart)
[08:28:15.430]                             muffled <- TRUE
[08:28:15.430]                             break
[08:28:15.430]                           }
[08:28:15.430]                         }
[08:28:15.430]                       }
[08:28:15.430]                       invisible(muffled)
[08:28:15.430]                     }
[08:28:15.430]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.430]                   }
[08:28:15.430]                 }
[08:28:15.430]             }
[08:28:15.430]         }))
[08:28:15.430]     }, error = function(ex) {
[08:28:15.430]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.430]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.430]                 ...future.rng), started = ...future.startTime, 
[08:28:15.430]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.430]             version = "1.8"), class = "FutureResult")
[08:28:15.430]     }, finally = {
[08:28:15.430]         if (!identical(...future.workdir, getwd())) 
[08:28:15.430]             setwd(...future.workdir)
[08:28:15.430]         {
[08:28:15.430]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.430]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.430]             }
[08:28:15.430]             base::options(...future.oldOptions)
[08:28:15.430]             if (.Platform$OS.type == "windows") {
[08:28:15.430]                 old_names <- names(...future.oldEnvVars)
[08:28:15.430]                 envs <- base::Sys.getenv()
[08:28:15.430]                 names <- names(envs)
[08:28:15.430]                 common <- intersect(names, old_names)
[08:28:15.430]                 added <- setdiff(names, old_names)
[08:28:15.430]                 removed <- setdiff(old_names, names)
[08:28:15.430]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.430]                   envs[common]]
[08:28:15.430]                 NAMES <- toupper(changed)
[08:28:15.430]                 args <- list()
[08:28:15.430]                 for (kk in seq_along(NAMES)) {
[08:28:15.430]                   name <- changed[[kk]]
[08:28:15.430]                   NAME <- NAMES[[kk]]
[08:28:15.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.430]                     next
[08:28:15.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.430]                 }
[08:28:15.430]                 NAMES <- toupper(added)
[08:28:15.430]                 for (kk in seq_along(NAMES)) {
[08:28:15.430]                   name <- added[[kk]]
[08:28:15.430]                   NAME <- NAMES[[kk]]
[08:28:15.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.430]                     next
[08:28:15.430]                   args[[name]] <- ""
[08:28:15.430]                 }
[08:28:15.430]                 NAMES <- toupper(removed)
[08:28:15.430]                 for (kk in seq_along(NAMES)) {
[08:28:15.430]                   name <- removed[[kk]]
[08:28:15.430]                   NAME <- NAMES[[kk]]
[08:28:15.430]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.430]                     next
[08:28:15.430]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.430]                 }
[08:28:15.430]                 if (length(args) > 0) 
[08:28:15.430]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.430]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.430]             }
[08:28:15.430]             else {
[08:28:15.430]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.430]             }
[08:28:15.430]             {
[08:28:15.430]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.430]                   0L) {
[08:28:15.430]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.430]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.430]                   base::options(opts)
[08:28:15.430]                 }
[08:28:15.430]                 {
[08:28:15.430]                   {
[08:28:15.430]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.430]                     NULL
[08:28:15.430]                   }
[08:28:15.430]                   options(future.plan = NULL)
[08:28:15.430]                   if (is.na(NA_character_)) 
[08:28:15.430]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.430]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.430]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.430]                     .init = FALSE)
[08:28:15.430]                 }
[08:28:15.430]             }
[08:28:15.430]         }
[08:28:15.430]     })
[08:28:15.430]     if (TRUE) {
[08:28:15.430]         base::sink(type = "output", split = FALSE)
[08:28:15.430]         if (TRUE) {
[08:28:15.430]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.430]         }
[08:28:15.430]         else {
[08:28:15.430]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.430]         }
[08:28:15.430]         base::close(...future.stdout)
[08:28:15.430]         ...future.stdout <- NULL
[08:28:15.430]     }
[08:28:15.430]     ...future.result$conditions <- ...future.conditions
[08:28:15.430]     ...future.result$finished <- base::Sys.time()
[08:28:15.430]     ...future.result
[08:28:15.430] }
[08:28:15.433] assign_globals() ...
[08:28:15.433] List of 2
[08:28:15.433]  $ a : num 1
[08:28:15.433]  $ ii: int 2
[08:28:15.433]  - attr(*, "where")=List of 2
[08:28:15.433]   ..$ a :<environment: R_EmptyEnv> 
[08:28:15.433]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:15.433]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.433]  - attr(*, "resolved")= logi TRUE
[08:28:15.433]  - attr(*, "total_size")= num 74
[08:28:15.433]  - attr(*, "already-done")= logi TRUE
[08:28:15.438] - copied ‘a’ to environment
[08:28:15.438] - copied ‘ii’ to environment
[08:28:15.439] assign_globals() ... done
[08:28:15.439] requestCore(): workers = 2
[08:28:15.441] MulticoreFuture started
[08:28:15.442] - Launch lazy future ... done
[08:28:15.442] run() for ‘MulticoreFuture’ ... done
[08:28:15.442] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.443] List of future strategies:
[08:28:15.443] 1. sequential:
[08:28:15.443]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.443]    - tweaked: FALSE
[08:28:15.443]    - call: NULL
[08:28:15.444] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.444] plan(): nbrOfWorkers() = 1
[08:28:15.444] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.446] plan(): Setting new future strategy stack:
[08:28:15.447] List of future strategies:
[08:28:15.447] 1. multicore:
[08:28:15.447]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.447]    - tweaked: FALSE
[08:28:15.447]    - call: plan(strategy)
[08:28:15.449] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.449] Searching for globals ... DONE
[08:28:15.449] Resolving globals: TRUE
[08:28:15.449] Resolving any globals that are futures ...
[08:28:15.450] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.450] Resolving any globals that are futures ... DONE
[08:28:15.450] plan(): nbrOfWorkers() = 2
[08:28:15.451] Resolving futures part of globals (recursively) ...
[08:28:15.451] resolve() on list ...
[08:28:15.451]  recursive: 99
[08:28:15.452]  length: 2
[08:28:15.452]  elements: ‘a’, ‘ii’
[08:28:15.452]  length: 1 (resolved future 1)
[08:28:15.452]  length: 0 (resolved future 2)
[08:28:15.452] resolve() on list ... DONE
[08:28:15.452] - globals: [2] ‘a’, ‘ii’
[08:28:15.452] Resolving futures part of globals (recursively) ... DONE
[08:28:15.453] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:15.453] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:15.454] - globals: [2] ‘a’, ‘ii’
[08:28:15.454] 
[08:28:15.454] getGlobalsAndPackages() ... DONE
[08:28:15.454] run() for ‘Future’ ...
[08:28:15.454] - state: ‘created’
[08:28:15.455] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.457] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.458]   - Field: ‘label’
[08:28:15.458]   - Field: ‘local’
[08:28:15.458]   - Field: ‘owner’
[08:28:15.458]   - Field: ‘envir’
[08:28:15.458]   - Field: ‘workers’
[08:28:15.458]   - Field: ‘packages’
[08:28:15.458]   - Field: ‘gc’
[08:28:15.459]   - Field: ‘job’
[08:28:15.459]   - Field: ‘conditions’
[08:28:15.459]   - Field: ‘expr’
[08:28:15.459]   - Field: ‘uuid’
[08:28:15.459]   - Field: ‘seed’
[08:28:15.459]   - Field: ‘version’
[08:28:15.459]   - Field: ‘result’
[08:28:15.459]   - Field: ‘asynchronous’
[08:28:15.460]   - Field: ‘calls’
[08:28:15.460]   - Field: ‘globals’
[08:28:15.460]   - Field: ‘stdout’
[08:28:15.460]   - Field: ‘earlySignal’
[08:28:15.460]   - Field: ‘lazy’
[08:28:15.460]   - Field: ‘state’
[08:28:15.460] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.461] - Launch lazy future ...
[08:28:15.461] Packages needed by the future expression (n = 0): <none>
[08:28:15.461] Packages needed by future strategies (n = 0): <none>
[08:28:15.462] {
[08:28:15.462]     {
[08:28:15.462]         {
[08:28:15.462]             ...future.startTime <- base::Sys.time()
[08:28:15.462]             {
[08:28:15.462]                 {
[08:28:15.462]                   {
[08:28:15.462]                     {
[08:28:15.462]                       base::local({
[08:28:15.462]                         has_future <- base::requireNamespace("future", 
[08:28:15.462]                           quietly = TRUE)
[08:28:15.462]                         if (has_future) {
[08:28:15.462]                           ns <- base::getNamespace("future")
[08:28:15.462]                           version <- ns[[".package"]][["version"]]
[08:28:15.462]                           if (is.null(version)) 
[08:28:15.462]                             version <- utils::packageVersion("future")
[08:28:15.462]                         }
[08:28:15.462]                         else {
[08:28:15.462]                           version <- NULL
[08:28:15.462]                         }
[08:28:15.462]                         if (!has_future || version < "1.8.0") {
[08:28:15.462]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.462]                             "", base::R.version$version.string), 
[08:28:15.462]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.462]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.462]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.462]                               "release", "version")], collapse = " "), 
[08:28:15.462]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.462]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.462]                             info)
[08:28:15.462]                           info <- base::paste(info, collapse = "; ")
[08:28:15.462]                           if (!has_future) {
[08:28:15.462]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.462]                               info)
[08:28:15.462]                           }
[08:28:15.462]                           else {
[08:28:15.462]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.462]                               info, version)
[08:28:15.462]                           }
[08:28:15.462]                           base::stop(msg)
[08:28:15.462]                         }
[08:28:15.462]                       })
[08:28:15.462]                     }
[08:28:15.462]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.462]                     base::options(mc.cores = 1L)
[08:28:15.462]                   }
[08:28:15.462]                   ...future.strategy.old <- future::plan("list")
[08:28:15.462]                   options(future.plan = NULL)
[08:28:15.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.462]                 }
[08:28:15.462]                 ...future.workdir <- getwd()
[08:28:15.462]             }
[08:28:15.462]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.462]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.462]         }
[08:28:15.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.462]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.462]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.462]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.462]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.462]             base::names(...future.oldOptions))
[08:28:15.462]     }
[08:28:15.462]     if (FALSE) {
[08:28:15.462]     }
[08:28:15.462]     else {
[08:28:15.462]         if (TRUE) {
[08:28:15.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.462]                 open = "w")
[08:28:15.462]         }
[08:28:15.462]         else {
[08:28:15.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.462]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.462]         }
[08:28:15.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.462]             base::sink(type = "output", split = FALSE)
[08:28:15.462]             base::close(...future.stdout)
[08:28:15.462]         }, add = TRUE)
[08:28:15.462]     }
[08:28:15.462]     ...future.frame <- base::sys.nframe()
[08:28:15.462]     ...future.conditions <- base::list()
[08:28:15.462]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.462]     if (FALSE) {
[08:28:15.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.462]     }
[08:28:15.462]     ...future.result <- base::tryCatch({
[08:28:15.462]         base::withCallingHandlers({
[08:28:15.462]             ...future.value <- base::withVisible(base::local({
[08:28:15.462]                 withCallingHandlers({
[08:28:15.462]                   {
[08:28:15.462]                     b <- a * ii
[08:28:15.462]                     a <- 0
[08:28:15.462]                     b
[08:28:15.462]                   }
[08:28:15.462]                 }, immediateCondition = function(cond) {
[08:28:15.462]                   save_rds <- function (object, pathname, ...) 
[08:28:15.462]                   {
[08:28:15.462]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.462]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.462]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.462]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.462]                         fi_tmp[["mtime"]])
[08:28:15.462]                     }
[08:28:15.462]                     tryCatch({
[08:28:15.462]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.462]                     }, error = function(ex) {
[08:28:15.462]                       msg <- conditionMessage(ex)
[08:28:15.462]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.462]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.462]                         fi_tmp[["mtime"]], msg)
[08:28:15.462]                       ex$message <- msg
[08:28:15.462]                       stop(ex)
[08:28:15.462]                     })
[08:28:15.462]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.462]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.462]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.462]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.462]                       fi <- file.info(pathname)
[08:28:15.462]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.462]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.462]                         fi[["size"]], fi[["mtime"]])
[08:28:15.462]                       stop(msg)
[08:28:15.462]                     }
[08:28:15.462]                     invisible(pathname)
[08:28:15.462]                   }
[08:28:15.462]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.462]                     rootPath = tempdir()) 
[08:28:15.462]                   {
[08:28:15.462]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.462]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.462]                       tmpdir = path, fileext = ".rds")
[08:28:15.462]                     save_rds(obj, file)
[08:28:15.462]                   }
[08:28:15.462]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.462]                   {
[08:28:15.462]                     inherits <- base::inherits
[08:28:15.462]                     invokeRestart <- base::invokeRestart
[08:28:15.462]                     is.null <- base::is.null
[08:28:15.462]                     muffled <- FALSE
[08:28:15.462]                     if (inherits(cond, "message")) {
[08:28:15.462]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.462]                       if (muffled) 
[08:28:15.462]                         invokeRestart("muffleMessage")
[08:28:15.462]                     }
[08:28:15.462]                     else if (inherits(cond, "warning")) {
[08:28:15.462]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.462]                       if (muffled) 
[08:28:15.462]                         invokeRestart("muffleWarning")
[08:28:15.462]                     }
[08:28:15.462]                     else if (inherits(cond, "condition")) {
[08:28:15.462]                       if (!is.null(pattern)) {
[08:28:15.462]                         computeRestarts <- base::computeRestarts
[08:28:15.462]                         grepl <- base::grepl
[08:28:15.462]                         restarts <- computeRestarts(cond)
[08:28:15.462]                         for (restart in restarts) {
[08:28:15.462]                           name <- restart$name
[08:28:15.462]                           if (is.null(name)) 
[08:28:15.462]                             next
[08:28:15.462]                           if (!grepl(pattern, name)) 
[08:28:15.462]                             next
[08:28:15.462]                           invokeRestart(restart)
[08:28:15.462]                           muffled <- TRUE
[08:28:15.462]                           break
[08:28:15.462]                         }
[08:28:15.462]                       }
[08:28:15.462]                     }
[08:28:15.462]                     invisible(muffled)
[08:28:15.462]                   }
[08:28:15.462]                   muffleCondition(cond)
[08:28:15.462]                 })
[08:28:15.462]             }))
[08:28:15.462]             future::FutureResult(value = ...future.value$value, 
[08:28:15.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.462]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.462]                     ...future.globalenv.names))
[08:28:15.462]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.462]         }, condition = base::local({
[08:28:15.462]             c <- base::c
[08:28:15.462]             inherits <- base::inherits
[08:28:15.462]             invokeRestart <- base::invokeRestart
[08:28:15.462]             length <- base::length
[08:28:15.462]             list <- base::list
[08:28:15.462]             seq.int <- base::seq.int
[08:28:15.462]             signalCondition <- base::signalCondition
[08:28:15.462]             sys.calls <- base::sys.calls
[08:28:15.462]             `[[` <- base::`[[`
[08:28:15.462]             `+` <- base::`+`
[08:28:15.462]             `<<-` <- base::`<<-`
[08:28:15.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.462]                   3L)]
[08:28:15.462]             }
[08:28:15.462]             function(cond) {
[08:28:15.462]                 is_error <- inherits(cond, "error")
[08:28:15.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.462]                   NULL)
[08:28:15.462]                 if (is_error) {
[08:28:15.462]                   sessionInformation <- function() {
[08:28:15.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.462]                       search = base::search(), system = base::Sys.info())
[08:28:15.462]                   }
[08:28:15.462]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.462]                     cond$call), session = sessionInformation(), 
[08:28:15.462]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.462]                   signalCondition(cond)
[08:28:15.462]                 }
[08:28:15.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.462]                 "immediateCondition"))) {
[08:28:15.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.462]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.462]                   if (TRUE && !signal) {
[08:28:15.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.462]                     {
[08:28:15.462]                       inherits <- base::inherits
[08:28:15.462]                       invokeRestart <- base::invokeRestart
[08:28:15.462]                       is.null <- base::is.null
[08:28:15.462]                       muffled <- FALSE
[08:28:15.462]                       if (inherits(cond, "message")) {
[08:28:15.462]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.462]                         if (muffled) 
[08:28:15.462]                           invokeRestart("muffleMessage")
[08:28:15.462]                       }
[08:28:15.462]                       else if (inherits(cond, "warning")) {
[08:28:15.462]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.462]                         if (muffled) 
[08:28:15.462]                           invokeRestart("muffleWarning")
[08:28:15.462]                       }
[08:28:15.462]                       else if (inherits(cond, "condition")) {
[08:28:15.462]                         if (!is.null(pattern)) {
[08:28:15.462]                           computeRestarts <- base::computeRestarts
[08:28:15.462]                           grepl <- base::grepl
[08:28:15.462]                           restarts <- computeRestarts(cond)
[08:28:15.462]                           for (restart in restarts) {
[08:28:15.462]                             name <- restart$name
[08:28:15.462]                             if (is.null(name)) 
[08:28:15.462]                               next
[08:28:15.462]                             if (!grepl(pattern, name)) 
[08:28:15.462]                               next
[08:28:15.462]                             invokeRestart(restart)
[08:28:15.462]                             muffled <- TRUE
[08:28:15.462]                             break
[08:28:15.462]                           }
[08:28:15.462]                         }
[08:28:15.462]                       }
[08:28:15.462]                       invisible(muffled)
[08:28:15.462]                     }
[08:28:15.462]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.462]                   }
[08:28:15.462]                 }
[08:28:15.462]                 else {
[08:28:15.462]                   if (TRUE) {
[08:28:15.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.462]                     {
[08:28:15.462]                       inherits <- base::inherits
[08:28:15.462]                       invokeRestart <- base::invokeRestart
[08:28:15.462]                       is.null <- base::is.null
[08:28:15.462]                       muffled <- FALSE
[08:28:15.462]                       if (inherits(cond, "message")) {
[08:28:15.462]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.462]                         if (muffled) 
[08:28:15.462]                           invokeRestart("muffleMessage")
[08:28:15.462]                       }
[08:28:15.462]                       else if (inherits(cond, "warning")) {
[08:28:15.462]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.462]                         if (muffled) 
[08:28:15.462]                           invokeRestart("muffleWarning")
[08:28:15.462]                       }
[08:28:15.462]                       else if (inherits(cond, "condition")) {
[08:28:15.462]                         if (!is.null(pattern)) {
[08:28:15.462]                           computeRestarts <- base::computeRestarts
[08:28:15.462]                           grepl <- base::grepl
[08:28:15.462]                           restarts <- computeRestarts(cond)
[08:28:15.462]                           for (restart in restarts) {
[08:28:15.462]                             name <- restart$name
[08:28:15.462]                             if (is.null(name)) 
[08:28:15.462]                               next
[08:28:15.462]                             if (!grepl(pattern, name)) 
[08:28:15.462]                               next
[08:28:15.462]                             invokeRestart(restart)
[08:28:15.462]                             muffled <- TRUE
[08:28:15.462]                             break
[08:28:15.462]                           }
[08:28:15.462]                         }
[08:28:15.462]                       }
[08:28:15.462]                       invisible(muffled)
[08:28:15.462]                     }
[08:28:15.462]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.462]                   }
[08:28:15.462]                 }
[08:28:15.462]             }
[08:28:15.462]         }))
[08:28:15.462]     }, error = function(ex) {
[08:28:15.462]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.462]                 ...future.rng), started = ...future.startTime, 
[08:28:15.462]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.462]             version = "1.8"), class = "FutureResult")
[08:28:15.462]     }, finally = {
[08:28:15.462]         if (!identical(...future.workdir, getwd())) 
[08:28:15.462]             setwd(...future.workdir)
[08:28:15.462]         {
[08:28:15.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.462]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.462]             }
[08:28:15.462]             base::options(...future.oldOptions)
[08:28:15.462]             if (.Platform$OS.type == "windows") {
[08:28:15.462]                 old_names <- names(...future.oldEnvVars)
[08:28:15.462]                 envs <- base::Sys.getenv()
[08:28:15.462]                 names <- names(envs)
[08:28:15.462]                 common <- intersect(names, old_names)
[08:28:15.462]                 added <- setdiff(names, old_names)
[08:28:15.462]                 removed <- setdiff(old_names, names)
[08:28:15.462]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.462]                   envs[common]]
[08:28:15.462]                 NAMES <- toupper(changed)
[08:28:15.462]                 args <- list()
[08:28:15.462]                 for (kk in seq_along(NAMES)) {
[08:28:15.462]                   name <- changed[[kk]]
[08:28:15.462]                   NAME <- NAMES[[kk]]
[08:28:15.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.462]                     next
[08:28:15.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.462]                 }
[08:28:15.462]                 NAMES <- toupper(added)
[08:28:15.462]                 for (kk in seq_along(NAMES)) {
[08:28:15.462]                   name <- added[[kk]]
[08:28:15.462]                   NAME <- NAMES[[kk]]
[08:28:15.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.462]                     next
[08:28:15.462]                   args[[name]] <- ""
[08:28:15.462]                 }
[08:28:15.462]                 NAMES <- toupper(removed)
[08:28:15.462]                 for (kk in seq_along(NAMES)) {
[08:28:15.462]                   name <- removed[[kk]]
[08:28:15.462]                   NAME <- NAMES[[kk]]
[08:28:15.462]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.462]                     next
[08:28:15.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.462]                 }
[08:28:15.462]                 if (length(args) > 0) 
[08:28:15.462]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.462]             }
[08:28:15.462]             else {
[08:28:15.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.462]             }
[08:28:15.462]             {
[08:28:15.462]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.462]                   0L) {
[08:28:15.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.462]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.462]                   base::options(opts)
[08:28:15.462]                 }
[08:28:15.462]                 {
[08:28:15.462]                   {
[08:28:15.462]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.462]                     NULL
[08:28:15.462]                   }
[08:28:15.462]                   options(future.plan = NULL)
[08:28:15.462]                   if (is.na(NA_character_)) 
[08:28:15.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.462]                     .init = FALSE)
[08:28:15.462]                 }
[08:28:15.462]             }
[08:28:15.462]         }
[08:28:15.462]     })
[08:28:15.462]     if (TRUE) {
[08:28:15.462]         base::sink(type = "output", split = FALSE)
[08:28:15.462]         if (TRUE) {
[08:28:15.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.462]         }
[08:28:15.462]         else {
[08:28:15.462]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.462]         }
[08:28:15.462]         base::close(...future.stdout)
[08:28:15.462]         ...future.stdout <- NULL
[08:28:15.462]     }
[08:28:15.462]     ...future.result$conditions <- ...future.conditions
[08:28:15.462]     ...future.result$finished <- base::Sys.time()
[08:28:15.462]     ...future.result
[08:28:15.462] }
[08:28:15.465] assign_globals() ...
[08:28:15.465] List of 2
[08:28:15.465]  $ a : num 1
[08:28:15.465]  $ ii: int 3
[08:28:15.465]  - attr(*, "where")=List of 2
[08:28:15.465]   ..$ a :<environment: R_EmptyEnv> 
[08:28:15.465]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:15.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.465]  - attr(*, "resolved")= logi TRUE
[08:28:15.465]  - attr(*, "total_size")= num 74
[08:28:15.465]  - attr(*, "already-done")= logi TRUE
[08:28:15.470] - copied ‘a’ to environment
[08:28:15.470] - copied ‘ii’ to environment
[08:28:15.470] assign_globals() ... done
[08:28:15.470] requestCore(): workers = 2
[08:28:15.471] Poll #1 (0): usedCores() = 2, workers = 2
[08:28:15.496] result() for MulticoreFuture ...
[08:28:15.497] result() for MulticoreFuture ...
[08:28:15.497] result() for MulticoreFuture ... done
[08:28:15.497] result() for MulticoreFuture ... done
[08:28:15.497] result() for MulticoreFuture ...
[08:28:15.497] result() for MulticoreFuture ... done
[08:28:15.500] MulticoreFuture started
[08:28:15.500] - Launch lazy future ... done
[08:28:15.500] run() for ‘MulticoreFuture’ ... done
[08:28:15.501] plan(): Setting new future strategy stack:
[08:28:15.502] result() for MulticoreFuture ...
[08:28:15.502] result() for MulticoreFuture ... done
[08:28:15.502] result() for MulticoreFuture ...
[08:28:15.503] result() for MulticoreFuture ... done
[08:28:15.501] List of future strategies:
[08:28:15.501] 1. sequential:
[08:28:15.501]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.501]    - tweaked: FALSE
[08:28:15.501]    - call: NULL
[08:28:15.503] plan(): nbrOfWorkers() = 1
[08:28:15.503] result() for MulticoreFuture ...
[08:28:15.505] result() for MulticoreFuture ...
[08:28:15.505] result() for MulticoreFuture ... done
[08:28:15.505] result() for MulticoreFuture ... done
[08:28:15.505] result() for MulticoreFuture ...
[08:28:15.506] result() for MulticoreFuture ... done
[08:28:15.506] plan(): Setting new future strategy stack:
[08:28:15.506] result() for MulticoreFuture ...
[08:28:15.506] List of future strategies:
[08:28:15.506] 1. multicore:
[08:28:15.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.506]    - tweaked: FALSE
[08:28:15.506]    - call: plan(strategy)
[08:28:15.509] plan(): nbrOfWorkers() = 2
[08:28:15.510] result() for MulticoreFuture ...
[08:28:15.510] result() for MulticoreFuture ... done
[08:28:15.510] result() for MulticoreFuture ... done
[08:28:15.511] result() for MulticoreFuture ...
[08:28:15.511] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.512] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.513] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.515] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.516] Searching for globals ... DONE
[08:28:15.516] Resolving globals: TRUE
[08:28:15.516] Resolving any globals that are futures ...
[08:28:15.516] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.516] Resolving any globals that are futures ... DONE
[08:28:15.516] Resolving futures part of globals (recursively) ...
[08:28:15.517] resolve() on list ...
[08:28:15.517]  recursive: 99
[08:28:15.517]  length: 2
[08:28:15.517]  elements: ‘a’, ‘ii’
[08:28:15.517]  length: 1 (resolved future 1)
[08:28:15.518]  length: 0 (resolved future 2)
[08:28:15.518] resolve() on list ... DONE
[08:28:15.518] - globals: [2] ‘a’, ‘ii’
[08:28:15.518] Resolving futures part of globals (recursively) ... DONE
[08:28:15.518] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:15.519] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:15.519] - globals: [2] ‘a’, ‘ii’
[08:28:15.519] 
[08:28:15.519] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.520] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.520] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.522] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.523] Searching for globals ... DONE
[08:28:15.523] Resolving globals: TRUE
[08:28:15.523] Resolving any globals that are futures ...
[08:28:15.523] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.523] Resolving any globals that are futures ... DONE
[08:28:15.523] Resolving futures part of globals (recursively) ...
[08:28:15.524] resolve() on list ...
[08:28:15.524]  recursive: 99
[08:28:15.524]  length: 2
[08:28:15.524]  elements: ‘a’, ‘ii’
[08:28:15.524]  length: 1 (resolved future 1)
[08:28:15.524]  length: 0 (resolved future 2)
[08:28:15.524] resolve() on list ... DONE
[08:28:15.525] - globals: [2] ‘a’, ‘ii’
[08:28:15.525] Resolving futures part of globals (recursively) ... DONE
[08:28:15.527] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:15.528] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:15.528] - globals: [2] ‘a’, ‘ii’
[08:28:15.528] 
[08:28:15.528] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.529] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.529] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.532] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.532] Searching for globals ... DONE
[08:28:15.532] Resolving globals: TRUE
[08:28:15.532] Resolving any globals that are futures ...
[08:28:15.533] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:15.533] Resolving any globals that are futures ... DONE
[08:28:15.533] Resolving futures part of globals (recursively) ...
[08:28:15.533] resolve() on list ...
[08:28:15.533]  recursive: 99
[08:28:15.534]  length: 2
[08:28:15.534]  elements: ‘a’, ‘ii’
[08:28:15.534]  length: 1 (resolved future 1)
[08:28:15.534]  length: 0 (resolved future 2)
[08:28:15.534] resolve() on list ... DONE
[08:28:15.534] - globals: [2] ‘a’, ‘ii’
[08:28:15.534] Resolving futures part of globals (recursively) ... DONE
[08:28:15.535] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:15.535] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:15.535] - globals: [2] ‘a’, ‘ii’
[08:28:15.535] 
[08:28:15.535] getGlobalsAndPackages() ... DONE
[08:28:15.536] run() for ‘Future’ ...
[08:28:15.536] - state: ‘created’
[08:28:15.536] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.538] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.538] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.538]   - Field: ‘label’
[08:28:15.538]   - Field: ‘local’
[08:28:15.539]   - Field: ‘owner’
[08:28:15.539]   - Field: ‘envir’
[08:28:15.539]   - Field: ‘workers’
[08:28:15.539]   - Field: ‘packages’
[08:28:15.539]   - Field: ‘gc’
[08:28:15.539]   - Field: ‘job’
[08:28:15.539]   - Field: ‘conditions’
[08:28:15.539]   - Field: ‘expr’
[08:28:15.539]   - Field: ‘uuid’
[08:28:15.539]   - Field: ‘seed’
[08:28:15.540]   - Field: ‘version’
[08:28:15.540]   - Field: ‘result’
[08:28:15.540]   - Field: ‘asynchronous’
[08:28:15.540]   - Field: ‘calls’
[08:28:15.540]   - Field: ‘globals’
[08:28:15.540]   - Field: ‘stdout’
[08:28:15.540]   - Field: ‘earlySignal’
[08:28:15.540]   - Field: ‘lazy’
[08:28:15.540]   - Field: ‘state’
[08:28:15.540] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.540] - Launch lazy future ...
[08:28:15.541] Packages needed by the future expression (n = 0): <none>
[08:28:15.541] Packages needed by future strategies (n = 0): <none>
[08:28:15.541] {
[08:28:15.541]     {
[08:28:15.541]         {
[08:28:15.541]             ...future.startTime <- base::Sys.time()
[08:28:15.541]             {
[08:28:15.541]                 {
[08:28:15.541]                   {
[08:28:15.541]                     {
[08:28:15.541]                       base::local({
[08:28:15.541]                         has_future <- base::requireNamespace("future", 
[08:28:15.541]                           quietly = TRUE)
[08:28:15.541]                         if (has_future) {
[08:28:15.541]                           ns <- base::getNamespace("future")
[08:28:15.541]                           version <- ns[[".package"]][["version"]]
[08:28:15.541]                           if (is.null(version)) 
[08:28:15.541]                             version <- utils::packageVersion("future")
[08:28:15.541]                         }
[08:28:15.541]                         else {
[08:28:15.541]                           version <- NULL
[08:28:15.541]                         }
[08:28:15.541]                         if (!has_future || version < "1.8.0") {
[08:28:15.541]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.541]                             "", base::R.version$version.string), 
[08:28:15.541]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.541]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.541]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.541]                               "release", "version")], collapse = " "), 
[08:28:15.541]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.541]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.541]                             info)
[08:28:15.541]                           info <- base::paste(info, collapse = "; ")
[08:28:15.541]                           if (!has_future) {
[08:28:15.541]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.541]                               info)
[08:28:15.541]                           }
[08:28:15.541]                           else {
[08:28:15.541]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.541]                               info, version)
[08:28:15.541]                           }
[08:28:15.541]                           base::stop(msg)
[08:28:15.541]                         }
[08:28:15.541]                       })
[08:28:15.541]                     }
[08:28:15.541]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.541]                     base::options(mc.cores = 1L)
[08:28:15.541]                   }
[08:28:15.541]                   ...future.strategy.old <- future::plan("list")
[08:28:15.541]                   options(future.plan = NULL)
[08:28:15.541]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.541]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.541]                 }
[08:28:15.541]                 ...future.workdir <- getwd()
[08:28:15.541]             }
[08:28:15.541]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.541]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.541]         }
[08:28:15.541]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.541]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.541]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.541]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.541]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.541]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.541]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.541]             base::names(...future.oldOptions))
[08:28:15.541]     }
[08:28:15.541]     if (FALSE) {
[08:28:15.541]     }
[08:28:15.541]     else {
[08:28:15.541]         if (TRUE) {
[08:28:15.541]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.541]                 open = "w")
[08:28:15.541]         }
[08:28:15.541]         else {
[08:28:15.541]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.541]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.541]         }
[08:28:15.541]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.541]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.541]             base::sink(type = "output", split = FALSE)
[08:28:15.541]             base::close(...future.stdout)
[08:28:15.541]         }, add = TRUE)
[08:28:15.541]     }
[08:28:15.541]     ...future.frame <- base::sys.nframe()
[08:28:15.541]     ...future.conditions <- base::list()
[08:28:15.541]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.541]     if (FALSE) {
[08:28:15.541]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.541]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.541]     }
[08:28:15.541]     ...future.result <- base::tryCatch({
[08:28:15.541]         base::withCallingHandlers({
[08:28:15.541]             ...future.value <- base::withVisible(base::local({
[08:28:15.541]                 withCallingHandlers({
[08:28:15.541]                   {
[08:28:15.541]                     b <- a * ii
[08:28:15.541]                     a <- 0
[08:28:15.541]                     b
[08:28:15.541]                   }
[08:28:15.541]                 }, immediateCondition = function(cond) {
[08:28:15.541]                   save_rds <- function (object, pathname, ...) 
[08:28:15.541]                   {
[08:28:15.541]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.541]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.541]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.541]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.541]                         fi_tmp[["mtime"]])
[08:28:15.541]                     }
[08:28:15.541]                     tryCatch({
[08:28:15.541]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.541]                     }, error = function(ex) {
[08:28:15.541]                       msg <- conditionMessage(ex)
[08:28:15.541]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.541]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.541]                         fi_tmp[["mtime"]], msg)
[08:28:15.541]                       ex$message <- msg
[08:28:15.541]                       stop(ex)
[08:28:15.541]                     })
[08:28:15.541]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.541]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.541]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.541]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.541]                       fi <- file.info(pathname)
[08:28:15.541]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.541]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.541]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.541]                         fi[["size"]], fi[["mtime"]])
[08:28:15.541]                       stop(msg)
[08:28:15.541]                     }
[08:28:15.541]                     invisible(pathname)
[08:28:15.541]                   }
[08:28:15.541]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.541]                     rootPath = tempdir()) 
[08:28:15.541]                   {
[08:28:15.541]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.541]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.541]                       tmpdir = path, fileext = ".rds")
[08:28:15.541]                     save_rds(obj, file)
[08:28:15.541]                   }
[08:28:15.541]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.541]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.541]                   {
[08:28:15.541]                     inherits <- base::inherits
[08:28:15.541]                     invokeRestart <- base::invokeRestart
[08:28:15.541]                     is.null <- base::is.null
[08:28:15.541]                     muffled <- FALSE
[08:28:15.541]                     if (inherits(cond, "message")) {
[08:28:15.541]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.541]                       if (muffled) 
[08:28:15.541]                         invokeRestart("muffleMessage")
[08:28:15.541]                     }
[08:28:15.541]                     else if (inherits(cond, "warning")) {
[08:28:15.541]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.541]                       if (muffled) 
[08:28:15.541]                         invokeRestart("muffleWarning")
[08:28:15.541]                     }
[08:28:15.541]                     else if (inherits(cond, "condition")) {
[08:28:15.541]                       if (!is.null(pattern)) {
[08:28:15.541]                         computeRestarts <- base::computeRestarts
[08:28:15.541]                         grepl <- base::grepl
[08:28:15.541]                         restarts <- computeRestarts(cond)
[08:28:15.541]                         for (restart in restarts) {
[08:28:15.541]                           name <- restart$name
[08:28:15.541]                           if (is.null(name)) 
[08:28:15.541]                             next
[08:28:15.541]                           if (!grepl(pattern, name)) 
[08:28:15.541]                             next
[08:28:15.541]                           invokeRestart(restart)
[08:28:15.541]                           muffled <- TRUE
[08:28:15.541]                           break
[08:28:15.541]                         }
[08:28:15.541]                       }
[08:28:15.541]                     }
[08:28:15.541]                     invisible(muffled)
[08:28:15.541]                   }
[08:28:15.541]                   muffleCondition(cond)
[08:28:15.541]                 })
[08:28:15.541]             }))
[08:28:15.541]             future::FutureResult(value = ...future.value$value, 
[08:28:15.541]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.541]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.541]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.541]                     ...future.globalenv.names))
[08:28:15.541]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.541]         }, condition = base::local({
[08:28:15.541]             c <- base::c
[08:28:15.541]             inherits <- base::inherits
[08:28:15.541]             invokeRestart <- base::invokeRestart
[08:28:15.541]             length <- base::length
[08:28:15.541]             list <- base::list
[08:28:15.541]             seq.int <- base::seq.int
[08:28:15.541]             signalCondition <- base::signalCondition
[08:28:15.541]             sys.calls <- base::sys.calls
[08:28:15.541]             `[[` <- base::`[[`
[08:28:15.541]             `+` <- base::`+`
[08:28:15.541]             `<<-` <- base::`<<-`
[08:28:15.541]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.541]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.541]                   3L)]
[08:28:15.541]             }
[08:28:15.541]             function(cond) {
[08:28:15.541]                 is_error <- inherits(cond, "error")
[08:28:15.541]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.541]                   NULL)
[08:28:15.541]                 if (is_error) {
[08:28:15.541]                   sessionInformation <- function() {
[08:28:15.541]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.541]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.541]                       search = base::search(), system = base::Sys.info())
[08:28:15.541]                   }
[08:28:15.541]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.541]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.541]                     cond$call), session = sessionInformation(), 
[08:28:15.541]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.541]                   signalCondition(cond)
[08:28:15.541]                 }
[08:28:15.541]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.541]                 "immediateCondition"))) {
[08:28:15.541]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.541]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.541]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.541]                   if (TRUE && !signal) {
[08:28:15.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.541]                     {
[08:28:15.541]                       inherits <- base::inherits
[08:28:15.541]                       invokeRestart <- base::invokeRestart
[08:28:15.541]                       is.null <- base::is.null
[08:28:15.541]                       muffled <- FALSE
[08:28:15.541]                       if (inherits(cond, "message")) {
[08:28:15.541]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.541]                         if (muffled) 
[08:28:15.541]                           invokeRestart("muffleMessage")
[08:28:15.541]                       }
[08:28:15.541]                       else if (inherits(cond, "warning")) {
[08:28:15.541]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.541]                         if (muffled) 
[08:28:15.541]                           invokeRestart("muffleWarning")
[08:28:15.541]                       }
[08:28:15.541]                       else if (inherits(cond, "condition")) {
[08:28:15.541]                         if (!is.null(pattern)) {
[08:28:15.541]                           computeRestarts <- base::computeRestarts
[08:28:15.541]                           grepl <- base::grepl
[08:28:15.541]                           restarts <- computeRestarts(cond)
[08:28:15.541]                           for (restart in restarts) {
[08:28:15.541]                             name <- restart$name
[08:28:15.541]                             if (is.null(name)) 
[08:28:15.541]                               next
[08:28:15.541]                             if (!grepl(pattern, name)) 
[08:28:15.541]                               next
[08:28:15.541]                             invokeRestart(restart)
[08:28:15.541]                             muffled <- TRUE
[08:28:15.541]                             break
[08:28:15.541]                           }
[08:28:15.541]                         }
[08:28:15.541]                       }
[08:28:15.541]                       invisible(muffled)
[08:28:15.541]                     }
[08:28:15.541]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.541]                   }
[08:28:15.541]                 }
[08:28:15.541]                 else {
[08:28:15.541]                   if (TRUE) {
[08:28:15.541]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.541]                     {
[08:28:15.541]                       inherits <- base::inherits
[08:28:15.541]                       invokeRestart <- base::invokeRestart
[08:28:15.541]                       is.null <- base::is.null
[08:28:15.541]                       muffled <- FALSE
[08:28:15.541]                       if (inherits(cond, "message")) {
[08:28:15.541]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.541]                         if (muffled) 
[08:28:15.541]                           invokeRestart("muffleMessage")
[08:28:15.541]                       }
[08:28:15.541]                       else if (inherits(cond, "warning")) {
[08:28:15.541]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.541]                         if (muffled) 
[08:28:15.541]                           invokeRestart("muffleWarning")
[08:28:15.541]                       }
[08:28:15.541]                       else if (inherits(cond, "condition")) {
[08:28:15.541]                         if (!is.null(pattern)) {
[08:28:15.541]                           computeRestarts <- base::computeRestarts
[08:28:15.541]                           grepl <- base::grepl
[08:28:15.541]                           restarts <- computeRestarts(cond)
[08:28:15.541]                           for (restart in restarts) {
[08:28:15.541]                             name <- restart$name
[08:28:15.541]                             if (is.null(name)) 
[08:28:15.541]                               next
[08:28:15.541]                             if (!grepl(pattern, name)) 
[08:28:15.541]                               next
[08:28:15.541]                             invokeRestart(restart)
[08:28:15.541]                             muffled <- TRUE
[08:28:15.541]                             break
[08:28:15.541]                           }
[08:28:15.541]                         }
[08:28:15.541]                       }
[08:28:15.541]                       invisible(muffled)
[08:28:15.541]                     }
[08:28:15.541]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.541]                   }
[08:28:15.541]                 }
[08:28:15.541]             }
[08:28:15.541]         }))
[08:28:15.541]     }, error = function(ex) {
[08:28:15.541]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.541]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.541]                 ...future.rng), started = ...future.startTime, 
[08:28:15.541]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.541]             version = "1.8"), class = "FutureResult")
[08:28:15.541]     }, finally = {
[08:28:15.541]         if (!identical(...future.workdir, getwd())) 
[08:28:15.541]             setwd(...future.workdir)
[08:28:15.541]         {
[08:28:15.541]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.541]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.541]             }
[08:28:15.541]             base::options(...future.oldOptions)
[08:28:15.541]             if (.Platform$OS.type == "windows") {
[08:28:15.541]                 old_names <- names(...future.oldEnvVars)
[08:28:15.541]                 envs <- base::Sys.getenv()
[08:28:15.541]                 names <- names(envs)
[08:28:15.541]                 common <- intersect(names, old_names)
[08:28:15.541]                 added <- setdiff(names, old_names)
[08:28:15.541]                 removed <- setdiff(old_names, names)
[08:28:15.541]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.541]                   envs[common]]
[08:28:15.541]                 NAMES <- toupper(changed)
[08:28:15.541]                 args <- list()
[08:28:15.541]                 for (kk in seq_along(NAMES)) {
[08:28:15.541]                   name <- changed[[kk]]
[08:28:15.541]                   NAME <- NAMES[[kk]]
[08:28:15.541]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.541]                     next
[08:28:15.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.541]                 }
[08:28:15.541]                 NAMES <- toupper(added)
[08:28:15.541]                 for (kk in seq_along(NAMES)) {
[08:28:15.541]                   name <- added[[kk]]
[08:28:15.541]                   NAME <- NAMES[[kk]]
[08:28:15.541]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.541]                     next
[08:28:15.541]                   args[[name]] <- ""
[08:28:15.541]                 }
[08:28:15.541]                 NAMES <- toupper(removed)
[08:28:15.541]                 for (kk in seq_along(NAMES)) {
[08:28:15.541]                   name <- removed[[kk]]
[08:28:15.541]                   NAME <- NAMES[[kk]]
[08:28:15.541]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.541]                     next
[08:28:15.541]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.541]                 }
[08:28:15.541]                 if (length(args) > 0) 
[08:28:15.541]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.541]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.541]             }
[08:28:15.541]             else {
[08:28:15.541]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.541]             }
[08:28:15.541]             {
[08:28:15.541]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.541]                   0L) {
[08:28:15.541]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.541]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.541]                   base::options(opts)
[08:28:15.541]                 }
[08:28:15.541]                 {
[08:28:15.541]                   {
[08:28:15.541]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.541]                     NULL
[08:28:15.541]                   }
[08:28:15.541]                   options(future.plan = NULL)
[08:28:15.541]                   if (is.na(NA_character_)) 
[08:28:15.541]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.541]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.541]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.541]                     .init = FALSE)
[08:28:15.541]                 }
[08:28:15.541]             }
[08:28:15.541]         }
[08:28:15.541]     })
[08:28:15.541]     if (TRUE) {
[08:28:15.541]         base::sink(type = "output", split = FALSE)
[08:28:15.541]         if (TRUE) {
[08:28:15.541]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.541]         }
[08:28:15.541]         else {
[08:28:15.541]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.541]         }
[08:28:15.541]         base::close(...future.stdout)
[08:28:15.541]         ...future.stdout <- NULL
[08:28:15.541]     }
[08:28:15.541]     ...future.result$conditions <- ...future.conditions
[08:28:15.541]     ...future.result$finished <- base::Sys.time()
[08:28:15.541]     ...future.result
[08:28:15.541] }
[08:28:15.544] assign_globals() ...
[08:28:15.544] List of 2
[08:28:15.544]  $ a : num 1
[08:28:15.544]  $ ii: int 1
[08:28:15.544]  - attr(*, "where")=List of 2
[08:28:15.544]   ..$ a :<environment: R_EmptyEnv> 
[08:28:15.544]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:15.544]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.544]  - attr(*, "resolved")= logi TRUE
[08:28:15.544]  - attr(*, "total_size")= num 74
[08:28:15.544]  - attr(*, "already-done")= logi TRUE
[08:28:15.547] - copied ‘a’ to environment
[08:28:15.547] - copied ‘ii’ to environment
[08:28:15.547] assign_globals() ... done
[08:28:15.548] requestCore(): workers = 2
[08:28:15.550] MulticoreFuture started
[08:28:15.551] - Launch lazy future ... done
[08:28:15.551] run() for ‘MulticoreFuture’ ... done
[08:28:15.551] result() for MulticoreFuture ...
[08:28:15.551] plan(): Setting new future strategy stack:
[08:28:15.551] List of future strategies:
[08:28:15.551] 1. sequential:
[08:28:15.551]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.551]    - tweaked: FALSE
[08:28:15.551]    - call: NULL
[08:28:15.553] plan(): nbrOfWorkers() = 1
[08:28:15.555] plan(): Setting new future strategy stack:
[08:28:15.555] List of future strategies:
[08:28:15.555] 1. multicore:
[08:28:15.555]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.555]    - tweaked: FALSE
[08:28:15.555]    - call: plan(strategy)
[08:28:15.558] plan(): nbrOfWorkers() = 2
[08:28:15.559] result() for MulticoreFuture ...
[08:28:15.559] result() for MulticoreFuture ... done
[08:28:15.559] result() for MulticoreFuture ... done
[08:28:15.560] result() for MulticoreFuture ...
[08:28:15.560] result() for MulticoreFuture ... done
[08:28:15.560] run() for ‘Future’ ...
[08:28:15.560] - state: ‘created’
[08:28:15.560] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.563] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.563] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.563]   - Field: ‘label’
[08:28:15.563]   - Field: ‘local’
[08:28:15.563]   - Field: ‘owner’
[08:28:15.563]   - Field: ‘envir’
[08:28:15.563]   - Field: ‘workers’
[08:28:15.564]   - Field: ‘packages’
[08:28:15.564]   - Field: ‘gc’
[08:28:15.564]   - Field: ‘job’
[08:28:15.564]   - Field: ‘conditions’
[08:28:15.564]   - Field: ‘expr’
[08:28:15.564]   - Field: ‘uuid’
[08:28:15.564]   - Field: ‘seed’
[08:28:15.564]   - Field: ‘version’
[08:28:15.564]   - Field: ‘result’
[08:28:15.565]   - Field: ‘asynchronous’
[08:28:15.565]   - Field: ‘calls’
[08:28:15.565]   - Field: ‘globals’
[08:28:15.565]   - Field: ‘stdout’
[08:28:15.565]   - Field: ‘earlySignal’
[08:28:15.565]   - Field: ‘lazy’
[08:28:15.565]   - Field: ‘state’
[08:28:15.565] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.565] - Launch lazy future ...
[08:28:15.566] Packages needed by the future expression (n = 0): <none>
[08:28:15.566] Packages needed by future strategies (n = 0): <none>
[08:28:15.567] {
[08:28:15.567]     {
[08:28:15.567]         {
[08:28:15.567]             ...future.startTime <- base::Sys.time()
[08:28:15.567]             {
[08:28:15.567]                 {
[08:28:15.567]                   {
[08:28:15.567]                     {
[08:28:15.567]                       base::local({
[08:28:15.567]                         has_future <- base::requireNamespace("future", 
[08:28:15.567]                           quietly = TRUE)
[08:28:15.567]                         if (has_future) {
[08:28:15.567]                           ns <- base::getNamespace("future")
[08:28:15.567]                           version <- ns[[".package"]][["version"]]
[08:28:15.567]                           if (is.null(version)) 
[08:28:15.567]                             version <- utils::packageVersion("future")
[08:28:15.567]                         }
[08:28:15.567]                         else {
[08:28:15.567]                           version <- NULL
[08:28:15.567]                         }
[08:28:15.567]                         if (!has_future || version < "1.8.0") {
[08:28:15.567]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.567]                             "", base::R.version$version.string), 
[08:28:15.567]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.567]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.567]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.567]                               "release", "version")], collapse = " "), 
[08:28:15.567]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.567]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.567]                             info)
[08:28:15.567]                           info <- base::paste(info, collapse = "; ")
[08:28:15.567]                           if (!has_future) {
[08:28:15.567]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.567]                               info)
[08:28:15.567]                           }
[08:28:15.567]                           else {
[08:28:15.567]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.567]                               info, version)
[08:28:15.567]                           }
[08:28:15.567]                           base::stop(msg)
[08:28:15.567]                         }
[08:28:15.567]                       })
[08:28:15.567]                     }
[08:28:15.567]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.567]                     base::options(mc.cores = 1L)
[08:28:15.567]                   }
[08:28:15.567]                   ...future.strategy.old <- future::plan("list")
[08:28:15.567]                   options(future.plan = NULL)
[08:28:15.567]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.567]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.567]                 }
[08:28:15.567]                 ...future.workdir <- getwd()
[08:28:15.567]             }
[08:28:15.567]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.567]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.567]         }
[08:28:15.567]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.567]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.567]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.567]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.567]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.567]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.567]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.567]             base::names(...future.oldOptions))
[08:28:15.567]     }
[08:28:15.567]     if (FALSE) {
[08:28:15.567]     }
[08:28:15.567]     else {
[08:28:15.567]         if (TRUE) {
[08:28:15.567]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.567]                 open = "w")
[08:28:15.567]         }
[08:28:15.567]         else {
[08:28:15.567]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.567]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.567]         }
[08:28:15.567]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.567]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.567]             base::sink(type = "output", split = FALSE)
[08:28:15.567]             base::close(...future.stdout)
[08:28:15.567]         }, add = TRUE)
[08:28:15.567]     }
[08:28:15.567]     ...future.frame <- base::sys.nframe()
[08:28:15.567]     ...future.conditions <- base::list()
[08:28:15.567]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.567]     if (FALSE) {
[08:28:15.567]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.567]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.567]     }
[08:28:15.567]     ...future.result <- base::tryCatch({
[08:28:15.567]         base::withCallingHandlers({
[08:28:15.567]             ...future.value <- base::withVisible(base::local({
[08:28:15.567]                 withCallingHandlers({
[08:28:15.567]                   {
[08:28:15.567]                     b <- a * ii
[08:28:15.567]                     a <- 0
[08:28:15.567]                     b
[08:28:15.567]                   }
[08:28:15.567]                 }, immediateCondition = function(cond) {
[08:28:15.567]                   save_rds <- function (object, pathname, ...) 
[08:28:15.567]                   {
[08:28:15.567]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.567]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.567]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.567]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.567]                         fi_tmp[["mtime"]])
[08:28:15.567]                     }
[08:28:15.567]                     tryCatch({
[08:28:15.567]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.567]                     }, error = function(ex) {
[08:28:15.567]                       msg <- conditionMessage(ex)
[08:28:15.567]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.567]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.567]                         fi_tmp[["mtime"]], msg)
[08:28:15.567]                       ex$message <- msg
[08:28:15.567]                       stop(ex)
[08:28:15.567]                     })
[08:28:15.567]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.567]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.567]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.567]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.567]                       fi <- file.info(pathname)
[08:28:15.567]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.567]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.567]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.567]                         fi[["size"]], fi[["mtime"]])
[08:28:15.567]                       stop(msg)
[08:28:15.567]                     }
[08:28:15.567]                     invisible(pathname)
[08:28:15.567]                   }
[08:28:15.567]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.567]                     rootPath = tempdir()) 
[08:28:15.567]                   {
[08:28:15.567]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.567]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.567]                       tmpdir = path, fileext = ".rds")
[08:28:15.567]                     save_rds(obj, file)
[08:28:15.567]                   }
[08:28:15.567]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.567]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.567]                   {
[08:28:15.567]                     inherits <- base::inherits
[08:28:15.567]                     invokeRestart <- base::invokeRestart
[08:28:15.567]                     is.null <- base::is.null
[08:28:15.567]                     muffled <- FALSE
[08:28:15.567]                     if (inherits(cond, "message")) {
[08:28:15.567]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.567]                       if (muffled) 
[08:28:15.567]                         invokeRestart("muffleMessage")
[08:28:15.567]                     }
[08:28:15.567]                     else if (inherits(cond, "warning")) {
[08:28:15.567]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.567]                       if (muffled) 
[08:28:15.567]                         invokeRestart("muffleWarning")
[08:28:15.567]                     }
[08:28:15.567]                     else if (inherits(cond, "condition")) {
[08:28:15.567]                       if (!is.null(pattern)) {
[08:28:15.567]                         computeRestarts <- base::computeRestarts
[08:28:15.567]                         grepl <- base::grepl
[08:28:15.567]                         restarts <- computeRestarts(cond)
[08:28:15.567]                         for (restart in restarts) {
[08:28:15.567]                           name <- restart$name
[08:28:15.567]                           if (is.null(name)) 
[08:28:15.567]                             next
[08:28:15.567]                           if (!grepl(pattern, name)) 
[08:28:15.567]                             next
[08:28:15.567]                           invokeRestart(restart)
[08:28:15.567]                           muffled <- TRUE
[08:28:15.567]                           break
[08:28:15.567]                         }
[08:28:15.567]                       }
[08:28:15.567]                     }
[08:28:15.567]                     invisible(muffled)
[08:28:15.567]                   }
[08:28:15.567]                   muffleCondition(cond)
[08:28:15.567]                 })
[08:28:15.567]             }))
[08:28:15.567]             future::FutureResult(value = ...future.value$value, 
[08:28:15.567]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.567]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.567]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.567]                     ...future.globalenv.names))
[08:28:15.567]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.567]         }, condition = base::local({
[08:28:15.567]             c <- base::c
[08:28:15.567]             inherits <- base::inherits
[08:28:15.567]             invokeRestart <- base::invokeRestart
[08:28:15.567]             length <- base::length
[08:28:15.567]             list <- base::list
[08:28:15.567]             seq.int <- base::seq.int
[08:28:15.567]             signalCondition <- base::signalCondition
[08:28:15.567]             sys.calls <- base::sys.calls
[08:28:15.567]             `[[` <- base::`[[`
[08:28:15.567]             `+` <- base::`+`
[08:28:15.567]             `<<-` <- base::`<<-`
[08:28:15.567]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.567]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.567]                   3L)]
[08:28:15.567]             }
[08:28:15.567]             function(cond) {
[08:28:15.567]                 is_error <- inherits(cond, "error")
[08:28:15.567]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.567]                   NULL)
[08:28:15.567]                 if (is_error) {
[08:28:15.567]                   sessionInformation <- function() {
[08:28:15.567]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.567]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.567]                       search = base::search(), system = base::Sys.info())
[08:28:15.567]                   }
[08:28:15.567]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.567]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.567]                     cond$call), session = sessionInformation(), 
[08:28:15.567]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.567]                   signalCondition(cond)
[08:28:15.567]                 }
[08:28:15.567]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.567]                 "immediateCondition"))) {
[08:28:15.567]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.567]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.567]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.567]                   if (TRUE && !signal) {
[08:28:15.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.567]                     {
[08:28:15.567]                       inherits <- base::inherits
[08:28:15.567]                       invokeRestart <- base::invokeRestart
[08:28:15.567]                       is.null <- base::is.null
[08:28:15.567]                       muffled <- FALSE
[08:28:15.567]                       if (inherits(cond, "message")) {
[08:28:15.567]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.567]                         if (muffled) 
[08:28:15.567]                           invokeRestart("muffleMessage")
[08:28:15.567]                       }
[08:28:15.567]                       else if (inherits(cond, "warning")) {
[08:28:15.567]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.567]                         if (muffled) 
[08:28:15.567]                           invokeRestart("muffleWarning")
[08:28:15.567]                       }
[08:28:15.567]                       else if (inherits(cond, "condition")) {
[08:28:15.567]                         if (!is.null(pattern)) {
[08:28:15.567]                           computeRestarts <- base::computeRestarts
[08:28:15.567]                           grepl <- base::grepl
[08:28:15.567]                           restarts <- computeRestarts(cond)
[08:28:15.567]                           for (restart in restarts) {
[08:28:15.567]                             name <- restart$name
[08:28:15.567]                             if (is.null(name)) 
[08:28:15.567]                               next
[08:28:15.567]                             if (!grepl(pattern, name)) 
[08:28:15.567]                               next
[08:28:15.567]                             invokeRestart(restart)
[08:28:15.567]                             muffled <- TRUE
[08:28:15.567]                             break
[08:28:15.567]                           }
[08:28:15.567]                         }
[08:28:15.567]                       }
[08:28:15.567]                       invisible(muffled)
[08:28:15.567]                     }
[08:28:15.567]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.567]                   }
[08:28:15.567]                 }
[08:28:15.567]                 else {
[08:28:15.567]                   if (TRUE) {
[08:28:15.567]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.567]                     {
[08:28:15.567]                       inherits <- base::inherits
[08:28:15.567]                       invokeRestart <- base::invokeRestart
[08:28:15.567]                       is.null <- base::is.null
[08:28:15.567]                       muffled <- FALSE
[08:28:15.567]                       if (inherits(cond, "message")) {
[08:28:15.567]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.567]                         if (muffled) 
[08:28:15.567]                           invokeRestart("muffleMessage")
[08:28:15.567]                       }
[08:28:15.567]                       else if (inherits(cond, "warning")) {
[08:28:15.567]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.567]                         if (muffled) 
[08:28:15.567]                           invokeRestart("muffleWarning")
[08:28:15.567]                       }
[08:28:15.567]                       else if (inherits(cond, "condition")) {
[08:28:15.567]                         if (!is.null(pattern)) {
[08:28:15.567]                           computeRestarts <- base::computeRestarts
[08:28:15.567]                           grepl <- base::grepl
[08:28:15.567]                           restarts <- computeRestarts(cond)
[08:28:15.567]                           for (restart in restarts) {
[08:28:15.567]                             name <- restart$name
[08:28:15.567]                             if (is.null(name)) 
[08:28:15.567]                               next
[08:28:15.567]                             if (!grepl(pattern, name)) 
[08:28:15.567]                               next
[08:28:15.567]                             invokeRestart(restart)
[08:28:15.567]                             muffled <- TRUE
[08:28:15.567]                             break
[08:28:15.567]                           }
[08:28:15.567]                         }
[08:28:15.567]                       }
[08:28:15.567]                       invisible(muffled)
[08:28:15.567]                     }
[08:28:15.567]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.567]                   }
[08:28:15.567]                 }
[08:28:15.567]             }
[08:28:15.567]         }))
[08:28:15.567]     }, error = function(ex) {
[08:28:15.567]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.567]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.567]                 ...future.rng), started = ...future.startTime, 
[08:28:15.567]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.567]             version = "1.8"), class = "FutureResult")
[08:28:15.567]     }, finally = {
[08:28:15.567]         if (!identical(...future.workdir, getwd())) 
[08:28:15.567]             setwd(...future.workdir)
[08:28:15.567]         {
[08:28:15.567]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.567]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.567]             }
[08:28:15.567]             base::options(...future.oldOptions)
[08:28:15.567]             if (.Platform$OS.type == "windows") {
[08:28:15.567]                 old_names <- names(...future.oldEnvVars)
[08:28:15.567]                 envs <- base::Sys.getenv()
[08:28:15.567]                 names <- names(envs)
[08:28:15.567]                 common <- intersect(names, old_names)
[08:28:15.567]                 added <- setdiff(names, old_names)
[08:28:15.567]                 removed <- setdiff(old_names, names)
[08:28:15.567]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.567]                   envs[common]]
[08:28:15.567]                 NAMES <- toupper(changed)
[08:28:15.567]                 args <- list()
[08:28:15.567]                 for (kk in seq_along(NAMES)) {
[08:28:15.567]                   name <- changed[[kk]]
[08:28:15.567]                   NAME <- NAMES[[kk]]
[08:28:15.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.567]                     next
[08:28:15.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.567]                 }
[08:28:15.567]                 NAMES <- toupper(added)
[08:28:15.567]                 for (kk in seq_along(NAMES)) {
[08:28:15.567]                   name <- added[[kk]]
[08:28:15.567]                   NAME <- NAMES[[kk]]
[08:28:15.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.567]                     next
[08:28:15.567]                   args[[name]] <- ""
[08:28:15.567]                 }
[08:28:15.567]                 NAMES <- toupper(removed)
[08:28:15.567]                 for (kk in seq_along(NAMES)) {
[08:28:15.567]                   name <- removed[[kk]]
[08:28:15.567]                   NAME <- NAMES[[kk]]
[08:28:15.567]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.567]                     next
[08:28:15.567]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.567]                 }
[08:28:15.567]                 if (length(args) > 0) 
[08:28:15.567]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.567]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.567]             }
[08:28:15.567]             else {
[08:28:15.567]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.567]             }
[08:28:15.567]             {
[08:28:15.567]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.567]                   0L) {
[08:28:15.567]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.567]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.567]                   base::options(opts)
[08:28:15.567]                 }
[08:28:15.567]                 {
[08:28:15.567]                   {
[08:28:15.567]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.567]                     NULL
[08:28:15.567]                   }
[08:28:15.567]                   options(future.plan = NULL)
[08:28:15.567]                   if (is.na(NA_character_)) 
[08:28:15.567]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.567]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.567]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.567]                     .init = FALSE)
[08:28:15.567]                 }
[08:28:15.567]             }
[08:28:15.567]         }
[08:28:15.567]     })
[08:28:15.567]     if (TRUE) {
[08:28:15.567]         base::sink(type = "output", split = FALSE)
[08:28:15.567]         if (TRUE) {
[08:28:15.567]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.567]         }
[08:28:15.567]         else {
[08:28:15.567]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.567]         }
[08:28:15.567]         base::close(...future.stdout)
[08:28:15.567]         ...future.stdout <- NULL
[08:28:15.567]     }
[08:28:15.567]     ...future.result$conditions <- ...future.conditions
[08:28:15.567]     ...future.result$finished <- base::Sys.time()
[08:28:15.567]     ...future.result
[08:28:15.567] }
[08:28:15.569] assign_globals() ...
[08:28:15.570] List of 2
[08:28:15.570]  $ a : num 1
[08:28:15.570]  $ ii: int 2
[08:28:15.570]  - attr(*, "where")=List of 2
[08:28:15.570]   ..$ a :<environment: R_EmptyEnv> 
[08:28:15.570]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:15.570]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.570]  - attr(*, "resolved")= logi TRUE
[08:28:15.570]  - attr(*, "total_size")= num 74
[08:28:15.570]  - attr(*, "already-done")= logi TRUE
[08:28:15.577] - copied ‘a’ to environment
[08:28:15.577] - copied ‘ii’ to environment
[08:28:15.577] assign_globals() ... done
[08:28:15.577] requestCore(): workers = 2
[08:28:15.579] MulticoreFuture started
[08:28:15.580] - Launch lazy future ... done
[08:28:15.580] plan(): Setting new future strategy stack:
[08:28:15.580] run() for ‘MulticoreFuture’ ... done
[08:28:15.581] result() for MulticoreFuture ...
[08:28:15.581] List of future strategies:
[08:28:15.581] 1. sequential:
[08:28:15.581]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.581]    - tweaked: FALSE
[08:28:15.581]    - call: NULL
[08:28:15.582] plan(): nbrOfWorkers() = 1
[08:28:15.585] plan(): Setting new future strategy stack:
[08:28:15.585] List of future strategies:
[08:28:15.585] 1. multicore:
[08:28:15.585]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.585]    - tweaked: FALSE
[08:28:15.585]    - call: plan(strategy)
[08:28:15.588] plan(): nbrOfWorkers() = 2
[08:28:15.589] result() for MulticoreFuture ...
[08:28:15.589] result() for MulticoreFuture ... done
[08:28:15.589] result() for MulticoreFuture ... done
[08:28:15.589] result() for MulticoreFuture ...
[08:28:15.590] result() for MulticoreFuture ... done
[08:28:15.590] run() for ‘Future’ ...
[08:28:15.590] - state: ‘created’
[08:28:15.590] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.592] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.593] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.593]   - Field: ‘label’
[08:28:15.593]   - Field: ‘local’
[08:28:15.593]   - Field: ‘owner’
[08:28:15.594]   - Field: ‘envir’
[08:28:15.594]   - Field: ‘workers’
[08:28:15.594]   - Field: ‘packages’
[08:28:15.594]   - Field: ‘gc’
[08:28:15.594]   - Field: ‘job’
[08:28:15.595]   - Field: ‘conditions’
[08:28:15.595]   - Field: ‘expr’
[08:28:15.595]   - Field: ‘uuid’
[08:28:15.595]   - Field: ‘seed’
[08:28:15.595]   - Field: ‘version’
[08:28:15.595]   - Field: ‘result’
[08:28:15.595]   - Field: ‘asynchronous’
[08:28:15.595]   - Field: ‘calls’
[08:28:15.596]   - Field: ‘globals’
[08:28:15.596]   - Field: ‘stdout’
[08:28:15.596]   - Field: ‘earlySignal’
[08:28:15.596]   - Field: ‘lazy’
[08:28:15.596]   - Field: ‘state’
[08:28:15.596] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.596] - Launch lazy future ...
[08:28:15.597] Packages needed by the future expression (n = 0): <none>
[08:28:15.597] Packages needed by future strategies (n = 0): <none>
[08:28:15.597] {
[08:28:15.597]     {
[08:28:15.597]         {
[08:28:15.597]             ...future.startTime <- base::Sys.time()
[08:28:15.597]             {
[08:28:15.597]                 {
[08:28:15.597]                   {
[08:28:15.597]                     {
[08:28:15.597]                       base::local({
[08:28:15.597]                         has_future <- base::requireNamespace("future", 
[08:28:15.597]                           quietly = TRUE)
[08:28:15.597]                         if (has_future) {
[08:28:15.597]                           ns <- base::getNamespace("future")
[08:28:15.597]                           version <- ns[[".package"]][["version"]]
[08:28:15.597]                           if (is.null(version)) 
[08:28:15.597]                             version <- utils::packageVersion("future")
[08:28:15.597]                         }
[08:28:15.597]                         else {
[08:28:15.597]                           version <- NULL
[08:28:15.597]                         }
[08:28:15.597]                         if (!has_future || version < "1.8.0") {
[08:28:15.597]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.597]                             "", base::R.version$version.string), 
[08:28:15.597]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.597]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.597]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.597]                               "release", "version")], collapse = " "), 
[08:28:15.597]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.597]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.597]                             info)
[08:28:15.597]                           info <- base::paste(info, collapse = "; ")
[08:28:15.597]                           if (!has_future) {
[08:28:15.597]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.597]                               info)
[08:28:15.597]                           }
[08:28:15.597]                           else {
[08:28:15.597]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.597]                               info, version)
[08:28:15.597]                           }
[08:28:15.597]                           base::stop(msg)
[08:28:15.597]                         }
[08:28:15.597]                       })
[08:28:15.597]                     }
[08:28:15.597]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.597]                     base::options(mc.cores = 1L)
[08:28:15.597]                   }
[08:28:15.597]                   ...future.strategy.old <- future::plan("list")
[08:28:15.597]                   options(future.plan = NULL)
[08:28:15.597]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.597]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.597]                 }
[08:28:15.597]                 ...future.workdir <- getwd()
[08:28:15.597]             }
[08:28:15.597]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.597]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.597]         }
[08:28:15.597]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.597]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.597]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.597]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.597]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.597]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.597]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.597]             base::names(...future.oldOptions))
[08:28:15.597]     }
[08:28:15.597]     if (FALSE) {
[08:28:15.597]     }
[08:28:15.597]     else {
[08:28:15.597]         if (TRUE) {
[08:28:15.597]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.597]                 open = "w")
[08:28:15.597]         }
[08:28:15.597]         else {
[08:28:15.597]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.597]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.597]         }
[08:28:15.597]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.597]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.597]             base::sink(type = "output", split = FALSE)
[08:28:15.597]             base::close(...future.stdout)
[08:28:15.597]         }, add = TRUE)
[08:28:15.597]     }
[08:28:15.597]     ...future.frame <- base::sys.nframe()
[08:28:15.597]     ...future.conditions <- base::list()
[08:28:15.597]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.597]     if (FALSE) {
[08:28:15.597]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.597]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.597]     }
[08:28:15.597]     ...future.result <- base::tryCatch({
[08:28:15.597]         base::withCallingHandlers({
[08:28:15.597]             ...future.value <- base::withVisible(base::local({
[08:28:15.597]                 withCallingHandlers({
[08:28:15.597]                   {
[08:28:15.597]                     b <- a * ii
[08:28:15.597]                     a <- 0
[08:28:15.597]                     b
[08:28:15.597]                   }
[08:28:15.597]                 }, immediateCondition = function(cond) {
[08:28:15.597]                   save_rds <- function (object, pathname, ...) 
[08:28:15.597]                   {
[08:28:15.597]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.597]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.597]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.597]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.597]                         fi_tmp[["mtime"]])
[08:28:15.597]                     }
[08:28:15.597]                     tryCatch({
[08:28:15.597]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.597]                     }, error = function(ex) {
[08:28:15.597]                       msg <- conditionMessage(ex)
[08:28:15.597]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.597]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.597]                         fi_tmp[["mtime"]], msg)
[08:28:15.597]                       ex$message <- msg
[08:28:15.597]                       stop(ex)
[08:28:15.597]                     })
[08:28:15.597]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.597]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.597]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.597]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.597]                       fi <- file.info(pathname)
[08:28:15.597]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.597]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.597]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.597]                         fi[["size"]], fi[["mtime"]])
[08:28:15.597]                       stop(msg)
[08:28:15.597]                     }
[08:28:15.597]                     invisible(pathname)
[08:28:15.597]                   }
[08:28:15.597]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.597]                     rootPath = tempdir()) 
[08:28:15.597]                   {
[08:28:15.597]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.597]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.597]                       tmpdir = path, fileext = ".rds")
[08:28:15.597]                     save_rds(obj, file)
[08:28:15.597]                   }
[08:28:15.597]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.597]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.597]                   {
[08:28:15.597]                     inherits <- base::inherits
[08:28:15.597]                     invokeRestart <- base::invokeRestart
[08:28:15.597]                     is.null <- base::is.null
[08:28:15.597]                     muffled <- FALSE
[08:28:15.597]                     if (inherits(cond, "message")) {
[08:28:15.597]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.597]                       if (muffled) 
[08:28:15.597]                         invokeRestart("muffleMessage")
[08:28:15.597]                     }
[08:28:15.597]                     else if (inherits(cond, "warning")) {
[08:28:15.597]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.597]                       if (muffled) 
[08:28:15.597]                         invokeRestart("muffleWarning")
[08:28:15.597]                     }
[08:28:15.597]                     else if (inherits(cond, "condition")) {
[08:28:15.597]                       if (!is.null(pattern)) {
[08:28:15.597]                         computeRestarts <- base::computeRestarts
[08:28:15.597]                         grepl <- base::grepl
[08:28:15.597]                         restarts <- computeRestarts(cond)
[08:28:15.597]                         for (restart in restarts) {
[08:28:15.597]                           name <- restart$name
[08:28:15.597]                           if (is.null(name)) 
[08:28:15.597]                             next
[08:28:15.597]                           if (!grepl(pattern, name)) 
[08:28:15.597]                             next
[08:28:15.597]                           invokeRestart(restart)
[08:28:15.597]                           muffled <- TRUE
[08:28:15.597]                           break
[08:28:15.597]                         }
[08:28:15.597]                       }
[08:28:15.597]                     }
[08:28:15.597]                     invisible(muffled)
[08:28:15.597]                   }
[08:28:15.597]                   muffleCondition(cond)
[08:28:15.597]                 })
[08:28:15.597]             }))
[08:28:15.597]             future::FutureResult(value = ...future.value$value, 
[08:28:15.597]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.597]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.597]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.597]                     ...future.globalenv.names))
[08:28:15.597]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.597]         }, condition = base::local({
[08:28:15.597]             c <- base::c
[08:28:15.597]             inherits <- base::inherits
[08:28:15.597]             invokeRestart <- base::invokeRestart
[08:28:15.597]             length <- base::length
[08:28:15.597]             list <- base::list
[08:28:15.597]             seq.int <- base::seq.int
[08:28:15.597]             signalCondition <- base::signalCondition
[08:28:15.597]             sys.calls <- base::sys.calls
[08:28:15.597]             `[[` <- base::`[[`
[08:28:15.597]             `+` <- base::`+`
[08:28:15.597]             `<<-` <- base::`<<-`
[08:28:15.597]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.597]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.597]                   3L)]
[08:28:15.597]             }
[08:28:15.597]             function(cond) {
[08:28:15.597]                 is_error <- inherits(cond, "error")
[08:28:15.597]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.597]                   NULL)
[08:28:15.597]                 if (is_error) {
[08:28:15.597]                   sessionInformation <- function() {
[08:28:15.597]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.597]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.597]                       search = base::search(), system = base::Sys.info())
[08:28:15.597]                   }
[08:28:15.597]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.597]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.597]                     cond$call), session = sessionInformation(), 
[08:28:15.597]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.597]                   signalCondition(cond)
[08:28:15.597]                 }
[08:28:15.597]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.597]                 "immediateCondition"))) {
[08:28:15.597]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.597]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.597]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.597]                   if (TRUE && !signal) {
[08:28:15.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.597]                     {
[08:28:15.597]                       inherits <- base::inherits
[08:28:15.597]                       invokeRestart <- base::invokeRestart
[08:28:15.597]                       is.null <- base::is.null
[08:28:15.597]                       muffled <- FALSE
[08:28:15.597]                       if (inherits(cond, "message")) {
[08:28:15.597]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.597]                         if (muffled) 
[08:28:15.597]                           invokeRestart("muffleMessage")
[08:28:15.597]                       }
[08:28:15.597]                       else if (inherits(cond, "warning")) {
[08:28:15.597]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.597]                         if (muffled) 
[08:28:15.597]                           invokeRestart("muffleWarning")
[08:28:15.597]                       }
[08:28:15.597]                       else if (inherits(cond, "condition")) {
[08:28:15.597]                         if (!is.null(pattern)) {
[08:28:15.597]                           computeRestarts <- base::computeRestarts
[08:28:15.597]                           grepl <- base::grepl
[08:28:15.597]                           restarts <- computeRestarts(cond)
[08:28:15.597]                           for (restart in restarts) {
[08:28:15.597]                             name <- restart$name
[08:28:15.597]                             if (is.null(name)) 
[08:28:15.597]                               next
[08:28:15.597]                             if (!grepl(pattern, name)) 
[08:28:15.597]                               next
[08:28:15.597]                             invokeRestart(restart)
[08:28:15.597]                             muffled <- TRUE
[08:28:15.597]                             break
[08:28:15.597]                           }
[08:28:15.597]                         }
[08:28:15.597]                       }
[08:28:15.597]                       invisible(muffled)
[08:28:15.597]                     }
[08:28:15.597]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.597]                   }
[08:28:15.597]                 }
[08:28:15.597]                 else {
[08:28:15.597]                   if (TRUE) {
[08:28:15.597]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.597]                     {
[08:28:15.597]                       inherits <- base::inherits
[08:28:15.597]                       invokeRestart <- base::invokeRestart
[08:28:15.597]                       is.null <- base::is.null
[08:28:15.597]                       muffled <- FALSE
[08:28:15.597]                       if (inherits(cond, "message")) {
[08:28:15.597]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.597]                         if (muffled) 
[08:28:15.597]                           invokeRestart("muffleMessage")
[08:28:15.597]                       }
[08:28:15.597]                       else if (inherits(cond, "warning")) {
[08:28:15.597]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.597]                         if (muffled) 
[08:28:15.597]                           invokeRestart("muffleWarning")
[08:28:15.597]                       }
[08:28:15.597]                       else if (inherits(cond, "condition")) {
[08:28:15.597]                         if (!is.null(pattern)) {
[08:28:15.597]                           computeRestarts <- base::computeRestarts
[08:28:15.597]                           grepl <- base::grepl
[08:28:15.597]                           restarts <- computeRestarts(cond)
[08:28:15.597]                           for (restart in restarts) {
[08:28:15.597]                             name <- restart$name
[08:28:15.597]                             if (is.null(name)) 
[08:28:15.597]                               next
[08:28:15.597]                             if (!grepl(pattern, name)) 
[08:28:15.597]                               next
[08:28:15.597]                             invokeRestart(restart)
[08:28:15.597]                             muffled <- TRUE
[08:28:15.597]                             break
[08:28:15.597]                           }
[08:28:15.597]                         }
[08:28:15.597]                       }
[08:28:15.597]                       invisible(muffled)
[08:28:15.597]                     }
[08:28:15.597]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.597]                   }
[08:28:15.597]                 }
[08:28:15.597]             }
[08:28:15.597]         }))
[08:28:15.597]     }, error = function(ex) {
[08:28:15.597]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.597]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.597]                 ...future.rng), started = ...future.startTime, 
[08:28:15.597]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.597]             version = "1.8"), class = "FutureResult")
[08:28:15.597]     }, finally = {
[08:28:15.597]         if (!identical(...future.workdir, getwd())) 
[08:28:15.597]             setwd(...future.workdir)
[08:28:15.597]         {
[08:28:15.597]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.597]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.597]             }
[08:28:15.597]             base::options(...future.oldOptions)
[08:28:15.597]             if (.Platform$OS.type == "windows") {
[08:28:15.597]                 old_names <- names(...future.oldEnvVars)
[08:28:15.597]                 envs <- base::Sys.getenv()
[08:28:15.597]                 names <- names(envs)
[08:28:15.597]                 common <- intersect(names, old_names)
[08:28:15.597]                 added <- setdiff(names, old_names)
[08:28:15.597]                 removed <- setdiff(old_names, names)
[08:28:15.597]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.597]                   envs[common]]
[08:28:15.597]                 NAMES <- toupper(changed)
[08:28:15.597]                 args <- list()
[08:28:15.597]                 for (kk in seq_along(NAMES)) {
[08:28:15.597]                   name <- changed[[kk]]
[08:28:15.597]                   NAME <- NAMES[[kk]]
[08:28:15.597]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.597]                     next
[08:28:15.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.597]                 }
[08:28:15.597]                 NAMES <- toupper(added)
[08:28:15.597]                 for (kk in seq_along(NAMES)) {
[08:28:15.597]                   name <- added[[kk]]
[08:28:15.597]                   NAME <- NAMES[[kk]]
[08:28:15.597]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.597]                     next
[08:28:15.597]                   args[[name]] <- ""
[08:28:15.597]                 }
[08:28:15.597]                 NAMES <- toupper(removed)
[08:28:15.597]                 for (kk in seq_along(NAMES)) {
[08:28:15.597]                   name <- removed[[kk]]
[08:28:15.597]                   NAME <- NAMES[[kk]]
[08:28:15.597]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.597]                     next
[08:28:15.597]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.597]                 }
[08:28:15.597]                 if (length(args) > 0) 
[08:28:15.597]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.597]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.597]             }
[08:28:15.597]             else {
[08:28:15.597]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.597]             }
[08:28:15.597]             {
[08:28:15.597]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.597]                   0L) {
[08:28:15.597]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.597]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.597]                   base::options(opts)
[08:28:15.597]                 }
[08:28:15.597]                 {
[08:28:15.597]                   {
[08:28:15.597]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.597]                     NULL
[08:28:15.597]                   }
[08:28:15.597]                   options(future.plan = NULL)
[08:28:15.597]                   if (is.na(NA_character_)) 
[08:28:15.597]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.597]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.597]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.597]                     .init = FALSE)
[08:28:15.597]                 }
[08:28:15.597]             }
[08:28:15.597]         }
[08:28:15.597]     })
[08:28:15.597]     if (TRUE) {
[08:28:15.597]         base::sink(type = "output", split = FALSE)
[08:28:15.597]         if (TRUE) {
[08:28:15.597]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.597]         }
[08:28:15.597]         else {
[08:28:15.597]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.597]         }
[08:28:15.597]         base::close(...future.stdout)
[08:28:15.597]         ...future.stdout <- NULL
[08:28:15.597]     }
[08:28:15.597]     ...future.result$conditions <- ...future.conditions
[08:28:15.597]     ...future.result$finished <- base::Sys.time()
[08:28:15.597]     ...future.result
[08:28:15.597] }
[08:28:15.600] assign_globals() ...
[08:28:15.600] List of 2
[08:28:15.600]  $ a : num 1
[08:28:15.600]  $ ii: int 3
[08:28:15.600]  - attr(*, "where")=List of 2
[08:28:15.600]   ..$ a :<environment: R_EmptyEnv> 
[08:28:15.600]   ..$ ii:<environment: R_EmptyEnv> 
[08:28:15.600]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.600]  - attr(*, "resolved")= logi TRUE
[08:28:15.600]  - attr(*, "total_size")= num 74
[08:28:15.600]  - attr(*, "already-done")= logi TRUE
[08:28:15.604] - copied ‘a’ to environment
[08:28:15.604] - copied ‘ii’ to environment
[08:28:15.604] assign_globals() ... done
[08:28:15.604] requestCore(): workers = 2
[08:28:15.606] MulticoreFuture started
[08:28:15.606] - Launch lazy future ... done
[08:28:15.607] run() for ‘MulticoreFuture’ ... done
[08:28:15.607] result() for MulticoreFuture ...
[08:28:15.607] plan(): Setting new future strategy stack:
[08:28:15.607] List of future strategies:
[08:28:15.607] 1. sequential:
[08:28:15.607]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.607]    - tweaked: FALSE
[08:28:15.607]    - call: NULL
[08:28:15.608] plan(): nbrOfWorkers() = 1
[08:28:15.611] plan(): Setting new future strategy stack:
[08:28:15.611] List of future strategies:
[08:28:15.611] 1. multicore:
[08:28:15.611]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.611]    - tweaked: FALSE
[08:28:15.611]    - call: plan(strategy)
[08:28:15.614] plan(): nbrOfWorkers() = 2
[08:28:15.615] result() for MulticoreFuture ...
[08:28:15.615] result() for MulticoreFuture ... done
[08:28:15.615] result() for MulticoreFuture ... done
[08:28:15.615] result() for MulticoreFuture ...
[08:28:15.615] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.616] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.616] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.617] 
[08:28:15.617] Searching for globals ... DONE
[08:28:15.617] - globals: [0] <none>
[08:28:15.617] getGlobalsAndPackages() ... DONE
[08:28:15.617] run() for ‘Future’ ...
[08:28:15.618] - state: ‘created’
[08:28:15.618] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.620] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.620] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.620]   - Field: ‘label’
[08:28:15.620]   - Field: ‘local’
[08:28:15.620]   - Field: ‘owner’
[08:28:15.621]   - Field: ‘envir’
[08:28:15.621]   - Field: ‘workers’
[08:28:15.621]   - Field: ‘packages’
[08:28:15.621]   - Field: ‘gc’
[08:28:15.621]   - Field: ‘job’
[08:28:15.621]   - Field: ‘conditions’
[08:28:15.621]   - Field: ‘expr’
[08:28:15.621]   - Field: ‘uuid’
[08:28:15.621]   - Field: ‘seed’
[08:28:15.622]   - Field: ‘version’
[08:28:15.622]   - Field: ‘result’
[08:28:15.622]   - Field: ‘asynchronous’
[08:28:15.622]   - Field: ‘calls’
[08:28:15.622]   - Field: ‘globals’
[08:28:15.622]   - Field: ‘stdout’
[08:28:15.622]   - Field: ‘earlySignal’
[08:28:15.622]   - Field: ‘lazy’
[08:28:15.622]   - Field: ‘state’
[08:28:15.623] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.623] - Launch lazy future ...
[08:28:15.623] Packages needed by the future expression (n = 0): <none>
[08:28:15.623] Packages needed by future strategies (n = 0): <none>
[08:28:15.624] {
[08:28:15.624]     {
[08:28:15.624]         {
[08:28:15.624]             ...future.startTime <- base::Sys.time()
[08:28:15.624]             {
[08:28:15.624]                 {
[08:28:15.624]                   {
[08:28:15.624]                     {
[08:28:15.624]                       base::local({
[08:28:15.624]                         has_future <- base::requireNamespace("future", 
[08:28:15.624]                           quietly = TRUE)
[08:28:15.624]                         if (has_future) {
[08:28:15.624]                           ns <- base::getNamespace("future")
[08:28:15.624]                           version <- ns[[".package"]][["version"]]
[08:28:15.624]                           if (is.null(version)) 
[08:28:15.624]                             version <- utils::packageVersion("future")
[08:28:15.624]                         }
[08:28:15.624]                         else {
[08:28:15.624]                           version <- NULL
[08:28:15.624]                         }
[08:28:15.624]                         if (!has_future || version < "1.8.0") {
[08:28:15.624]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.624]                             "", base::R.version$version.string), 
[08:28:15.624]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.624]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.624]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.624]                               "release", "version")], collapse = " "), 
[08:28:15.624]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.624]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.624]                             info)
[08:28:15.624]                           info <- base::paste(info, collapse = "; ")
[08:28:15.624]                           if (!has_future) {
[08:28:15.624]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.624]                               info)
[08:28:15.624]                           }
[08:28:15.624]                           else {
[08:28:15.624]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.624]                               info, version)
[08:28:15.624]                           }
[08:28:15.624]                           base::stop(msg)
[08:28:15.624]                         }
[08:28:15.624]                       })
[08:28:15.624]                     }
[08:28:15.624]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.624]                     base::options(mc.cores = 1L)
[08:28:15.624]                   }
[08:28:15.624]                   ...future.strategy.old <- future::plan("list")
[08:28:15.624]                   options(future.plan = NULL)
[08:28:15.624]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.624]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.624]                 }
[08:28:15.624]                 ...future.workdir <- getwd()
[08:28:15.624]             }
[08:28:15.624]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.624]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.624]         }
[08:28:15.624]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.624]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.624]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.624]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.624]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.624]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.624]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.624]             base::names(...future.oldOptions))
[08:28:15.624]     }
[08:28:15.624]     if (FALSE) {
[08:28:15.624]     }
[08:28:15.624]     else {
[08:28:15.624]         if (TRUE) {
[08:28:15.624]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.624]                 open = "w")
[08:28:15.624]         }
[08:28:15.624]         else {
[08:28:15.624]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.624]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.624]         }
[08:28:15.624]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.624]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.624]             base::sink(type = "output", split = FALSE)
[08:28:15.624]             base::close(...future.stdout)
[08:28:15.624]         }, add = TRUE)
[08:28:15.624]     }
[08:28:15.624]     ...future.frame <- base::sys.nframe()
[08:28:15.624]     ...future.conditions <- base::list()
[08:28:15.624]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.624]     if (FALSE) {
[08:28:15.624]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.624]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.624]     }
[08:28:15.624]     ...future.result <- base::tryCatch({
[08:28:15.624]         base::withCallingHandlers({
[08:28:15.624]             ...future.value <- base::withVisible(base::local({
[08:28:15.624]                 withCallingHandlers({
[08:28:15.624]                   1
[08:28:15.624]                 }, immediateCondition = function(cond) {
[08:28:15.624]                   save_rds <- function (object, pathname, ...) 
[08:28:15.624]                   {
[08:28:15.624]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.624]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.624]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.624]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.624]                         fi_tmp[["mtime"]])
[08:28:15.624]                     }
[08:28:15.624]                     tryCatch({
[08:28:15.624]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.624]                     }, error = function(ex) {
[08:28:15.624]                       msg <- conditionMessage(ex)
[08:28:15.624]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.624]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.624]                         fi_tmp[["mtime"]], msg)
[08:28:15.624]                       ex$message <- msg
[08:28:15.624]                       stop(ex)
[08:28:15.624]                     })
[08:28:15.624]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.624]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.624]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.624]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.624]                       fi <- file.info(pathname)
[08:28:15.624]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.624]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.624]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.624]                         fi[["size"]], fi[["mtime"]])
[08:28:15.624]                       stop(msg)
[08:28:15.624]                     }
[08:28:15.624]                     invisible(pathname)
[08:28:15.624]                   }
[08:28:15.624]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.624]                     rootPath = tempdir()) 
[08:28:15.624]                   {
[08:28:15.624]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.624]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.624]                       tmpdir = path, fileext = ".rds")
[08:28:15.624]                     save_rds(obj, file)
[08:28:15.624]                   }
[08:28:15.624]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.624]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.624]                   {
[08:28:15.624]                     inherits <- base::inherits
[08:28:15.624]                     invokeRestart <- base::invokeRestart
[08:28:15.624]                     is.null <- base::is.null
[08:28:15.624]                     muffled <- FALSE
[08:28:15.624]                     if (inherits(cond, "message")) {
[08:28:15.624]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.624]                       if (muffled) 
[08:28:15.624]                         invokeRestart("muffleMessage")
[08:28:15.624]                     }
[08:28:15.624]                     else if (inherits(cond, "warning")) {
[08:28:15.624]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.624]                       if (muffled) 
[08:28:15.624]                         invokeRestart("muffleWarning")
[08:28:15.624]                     }
[08:28:15.624]                     else if (inherits(cond, "condition")) {
[08:28:15.624]                       if (!is.null(pattern)) {
[08:28:15.624]                         computeRestarts <- base::computeRestarts
[08:28:15.624]                         grepl <- base::grepl
[08:28:15.624]                         restarts <- computeRestarts(cond)
[08:28:15.624]                         for (restart in restarts) {
[08:28:15.624]                           name <- restart$name
[08:28:15.624]                           if (is.null(name)) 
[08:28:15.624]                             next
[08:28:15.624]                           if (!grepl(pattern, name)) 
[08:28:15.624]                             next
[08:28:15.624]                           invokeRestart(restart)
[08:28:15.624]                           muffled <- TRUE
[08:28:15.624]                           break
[08:28:15.624]                         }
[08:28:15.624]                       }
[08:28:15.624]                     }
[08:28:15.624]                     invisible(muffled)
[08:28:15.624]                   }
[08:28:15.624]                   muffleCondition(cond)
[08:28:15.624]                 })
[08:28:15.624]             }))
[08:28:15.624]             future::FutureResult(value = ...future.value$value, 
[08:28:15.624]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.624]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.624]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.624]                     ...future.globalenv.names))
[08:28:15.624]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.624]         }, condition = base::local({
[08:28:15.624]             c <- base::c
[08:28:15.624]             inherits <- base::inherits
[08:28:15.624]             invokeRestart <- base::invokeRestart
[08:28:15.624]             length <- base::length
[08:28:15.624]             list <- base::list
[08:28:15.624]             seq.int <- base::seq.int
[08:28:15.624]             signalCondition <- base::signalCondition
[08:28:15.624]             sys.calls <- base::sys.calls
[08:28:15.624]             `[[` <- base::`[[`
[08:28:15.624]             `+` <- base::`+`
[08:28:15.624]             `<<-` <- base::`<<-`
[08:28:15.624]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.624]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.624]                   3L)]
[08:28:15.624]             }
[08:28:15.624]             function(cond) {
[08:28:15.624]                 is_error <- inherits(cond, "error")
[08:28:15.624]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.624]                   NULL)
[08:28:15.624]                 if (is_error) {
[08:28:15.624]                   sessionInformation <- function() {
[08:28:15.624]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.624]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.624]                       search = base::search(), system = base::Sys.info())
[08:28:15.624]                   }
[08:28:15.624]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.624]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.624]                     cond$call), session = sessionInformation(), 
[08:28:15.624]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.624]                   signalCondition(cond)
[08:28:15.624]                 }
[08:28:15.624]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.624]                 "immediateCondition"))) {
[08:28:15.624]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.624]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.624]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.624]                   if (TRUE && !signal) {
[08:28:15.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.624]                     {
[08:28:15.624]                       inherits <- base::inherits
[08:28:15.624]                       invokeRestart <- base::invokeRestart
[08:28:15.624]                       is.null <- base::is.null
[08:28:15.624]                       muffled <- FALSE
[08:28:15.624]                       if (inherits(cond, "message")) {
[08:28:15.624]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.624]                         if (muffled) 
[08:28:15.624]                           invokeRestart("muffleMessage")
[08:28:15.624]                       }
[08:28:15.624]                       else if (inherits(cond, "warning")) {
[08:28:15.624]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.624]                         if (muffled) 
[08:28:15.624]                           invokeRestart("muffleWarning")
[08:28:15.624]                       }
[08:28:15.624]                       else if (inherits(cond, "condition")) {
[08:28:15.624]                         if (!is.null(pattern)) {
[08:28:15.624]                           computeRestarts <- base::computeRestarts
[08:28:15.624]                           grepl <- base::grepl
[08:28:15.624]                           restarts <- computeRestarts(cond)
[08:28:15.624]                           for (restart in restarts) {
[08:28:15.624]                             name <- restart$name
[08:28:15.624]                             if (is.null(name)) 
[08:28:15.624]                               next
[08:28:15.624]                             if (!grepl(pattern, name)) 
[08:28:15.624]                               next
[08:28:15.624]                             invokeRestart(restart)
[08:28:15.624]                             muffled <- TRUE
[08:28:15.624]                             break
[08:28:15.624]                           }
[08:28:15.624]                         }
[08:28:15.624]                       }
[08:28:15.624]                       invisible(muffled)
[08:28:15.624]                     }
[08:28:15.624]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.624]                   }
[08:28:15.624]                 }
[08:28:15.624]                 else {
[08:28:15.624]                   if (TRUE) {
[08:28:15.624]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.624]                     {
[08:28:15.624]                       inherits <- base::inherits
[08:28:15.624]                       invokeRestart <- base::invokeRestart
[08:28:15.624]                       is.null <- base::is.null
[08:28:15.624]                       muffled <- FALSE
[08:28:15.624]                       if (inherits(cond, "message")) {
[08:28:15.624]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.624]                         if (muffled) 
[08:28:15.624]                           invokeRestart("muffleMessage")
[08:28:15.624]                       }
[08:28:15.624]                       else if (inherits(cond, "warning")) {
[08:28:15.624]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.624]                         if (muffled) 
[08:28:15.624]                           invokeRestart("muffleWarning")
[08:28:15.624]                       }
[08:28:15.624]                       else if (inherits(cond, "condition")) {
[08:28:15.624]                         if (!is.null(pattern)) {
[08:28:15.624]                           computeRestarts <- base::computeRestarts
[08:28:15.624]                           grepl <- base::grepl
[08:28:15.624]                           restarts <- computeRestarts(cond)
[08:28:15.624]                           for (restart in restarts) {
[08:28:15.624]                             name <- restart$name
[08:28:15.624]                             if (is.null(name)) 
[08:28:15.624]                               next
[08:28:15.624]                             if (!grepl(pattern, name)) 
[08:28:15.624]                               next
[08:28:15.624]                             invokeRestart(restart)
[08:28:15.624]                             muffled <- TRUE
[08:28:15.624]                             break
[08:28:15.624]                           }
[08:28:15.624]                         }
[08:28:15.624]                       }
[08:28:15.624]                       invisible(muffled)
[08:28:15.624]                     }
[08:28:15.624]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.624]                   }
[08:28:15.624]                 }
[08:28:15.624]             }
[08:28:15.624]         }))
[08:28:15.624]     }, error = function(ex) {
[08:28:15.624]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.624]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.624]                 ...future.rng), started = ...future.startTime, 
[08:28:15.624]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.624]             version = "1.8"), class = "FutureResult")
[08:28:15.624]     }, finally = {
[08:28:15.624]         if (!identical(...future.workdir, getwd())) 
[08:28:15.624]             setwd(...future.workdir)
[08:28:15.624]         {
[08:28:15.624]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.624]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.624]             }
[08:28:15.624]             base::options(...future.oldOptions)
[08:28:15.624]             if (.Platform$OS.type == "windows") {
[08:28:15.624]                 old_names <- names(...future.oldEnvVars)
[08:28:15.624]                 envs <- base::Sys.getenv()
[08:28:15.624]                 names <- names(envs)
[08:28:15.624]                 common <- intersect(names, old_names)
[08:28:15.624]                 added <- setdiff(names, old_names)
[08:28:15.624]                 removed <- setdiff(old_names, names)
[08:28:15.624]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.624]                   envs[common]]
[08:28:15.624]                 NAMES <- toupper(changed)
[08:28:15.624]                 args <- list()
[08:28:15.624]                 for (kk in seq_along(NAMES)) {
[08:28:15.624]                   name <- changed[[kk]]
[08:28:15.624]                   NAME <- NAMES[[kk]]
[08:28:15.624]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.624]                     next
[08:28:15.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.624]                 }
[08:28:15.624]                 NAMES <- toupper(added)
[08:28:15.624]                 for (kk in seq_along(NAMES)) {
[08:28:15.624]                   name <- added[[kk]]
[08:28:15.624]                   NAME <- NAMES[[kk]]
[08:28:15.624]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.624]                     next
[08:28:15.624]                   args[[name]] <- ""
[08:28:15.624]                 }
[08:28:15.624]                 NAMES <- toupper(removed)
[08:28:15.624]                 for (kk in seq_along(NAMES)) {
[08:28:15.624]                   name <- removed[[kk]]
[08:28:15.624]                   NAME <- NAMES[[kk]]
[08:28:15.624]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.624]                     next
[08:28:15.624]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.624]                 }
[08:28:15.624]                 if (length(args) > 0) 
[08:28:15.624]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.624]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.624]             }
[08:28:15.624]             else {
[08:28:15.624]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.624]             }
[08:28:15.624]             {
[08:28:15.624]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.624]                   0L) {
[08:28:15.624]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.624]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.624]                   base::options(opts)
[08:28:15.624]                 }
[08:28:15.624]                 {
[08:28:15.624]                   {
[08:28:15.624]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.624]                     NULL
[08:28:15.624]                   }
[08:28:15.624]                   options(future.plan = NULL)
[08:28:15.624]                   if (is.na(NA_character_)) 
[08:28:15.624]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.624]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.624]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.624]                     .init = FALSE)
[08:28:15.624]                 }
[08:28:15.624]             }
[08:28:15.624]         }
[08:28:15.624]     })
[08:28:15.624]     if (TRUE) {
[08:28:15.624]         base::sink(type = "output", split = FALSE)
[08:28:15.624]         if (TRUE) {
[08:28:15.624]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.624]         }
[08:28:15.624]         else {
[08:28:15.624]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.624]         }
[08:28:15.624]         base::close(...future.stdout)
[08:28:15.624]         ...future.stdout <- NULL
[08:28:15.624]     }
[08:28:15.624]     ...future.result$conditions <- ...future.conditions
[08:28:15.624]     ...future.result$finished <- base::Sys.time()
[08:28:15.624]     ...future.result
[08:28:15.624] }
[08:28:15.626] requestCore(): workers = 2
[08:28:15.628] MulticoreFuture started
[08:28:15.628] - Launch lazy future ... done
[08:28:15.629] run() for ‘MulticoreFuture’ ... done
[08:28:15.629] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.629] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.630] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.629] List of future strategies:
[08:28:15.629] 1. sequential:
[08:28:15.629]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.629]    - tweaked: FALSE
[08:28:15.629]    - call: NULL
[08:28:15.630] plan(): nbrOfWorkers() = 1
[08:28:15.631] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.632] Searching for globals ... DONE
[08:28:15.632] Resolving globals: TRUE
[08:28:15.632] Resolving any globals that are futures ...
[08:28:15.632] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.632] plan(): Setting new future strategy stack:
[08:28:15.632] Resolving any globals that are futures ... DONE
[08:28:15.632] List of future strategies:
[08:28:15.632] 1. multicore:
[08:28:15.632]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.632]    - tweaked: FALSE
[08:28:15.632]    - call: plan(strategy)
[08:28:15.633] Resolving futures part of globals (recursively) ...
[08:28:15.634] resolve() on list ...
[08:28:15.634]  recursive: 99
[08:28:15.634]  length: 1
[08:28:15.634]  elements: ‘a’
[08:28:15.635] plan(): nbrOfWorkers() = 2
[08:28:15.640] Future #1
[08:28:15.640] result() for MulticoreFuture ...
[08:28:15.642] result() for MulticoreFuture ...
[08:28:15.642] result() for MulticoreFuture ... done
[08:28:15.642] result() for MulticoreFuture ... done
[08:28:15.643] result() for MulticoreFuture ...
[08:28:15.643] result() for MulticoreFuture ... done
[08:28:15.643] A MulticoreFuture was resolved
[08:28:15.643]  length: 0 (resolved future 1)
[08:28:15.643] resolve() on list ... DONE
[08:28:15.643] - globals: [1] ‘a’
[08:28:15.644] Resolving futures part of globals (recursively) ... DONE
[08:28:15.644] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[08:28:15.645] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[08:28:15.645] - globals: [1] ‘a’
[08:28:15.645] - packages: [1] ‘future’
[08:28:15.645] getGlobalsAndPackages() ... DONE
[08:28:15.646] run() for ‘Future’ ...
[08:28:15.646] - state: ‘created’
[08:28:15.646] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.648] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.648] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.648]   - Field: ‘label’
[08:28:15.649]   - Field: ‘local’
[08:28:15.649]   - Field: ‘owner’
[08:28:15.649]   - Field: ‘envir’
[08:28:15.649]   - Field: ‘workers’
[08:28:15.649]   - Field: ‘packages’
[08:28:15.649]   - Field: ‘gc’
[08:28:15.649]   - Field: ‘job’
[08:28:15.649]   - Field: ‘conditions’
[08:28:15.650]   - Field: ‘expr’
[08:28:15.650]   - Field: ‘uuid’
[08:28:15.650]   - Field: ‘seed’
[08:28:15.650]   - Field: ‘version’
[08:28:15.650]   - Field: ‘result’
[08:28:15.650]   - Field: ‘asynchronous’
[08:28:15.650]   - Field: ‘calls’
[08:28:15.650]   - Field: ‘globals’
[08:28:15.651]   - Field: ‘stdout’
[08:28:15.651]   - Field: ‘earlySignal’
[08:28:15.651]   - Field: ‘lazy’
[08:28:15.651]   - Field: ‘state’
[08:28:15.651] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.651] - Launch lazy future ...
[08:28:15.652] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.652] Packages needed by future strategies (n = 0): <none>
[08:28:15.652] {
[08:28:15.652]     {
[08:28:15.652]         {
[08:28:15.652]             ...future.startTime <- base::Sys.time()
[08:28:15.652]             {
[08:28:15.652]                 {
[08:28:15.652]                   {
[08:28:15.652]                     {
[08:28:15.652]                       {
[08:28:15.652]                         base::local({
[08:28:15.652]                           has_future <- base::requireNamespace("future", 
[08:28:15.652]                             quietly = TRUE)
[08:28:15.652]                           if (has_future) {
[08:28:15.652]                             ns <- base::getNamespace("future")
[08:28:15.652]                             version <- ns[[".package"]][["version"]]
[08:28:15.652]                             if (is.null(version)) 
[08:28:15.652]                               version <- utils::packageVersion("future")
[08:28:15.652]                           }
[08:28:15.652]                           else {
[08:28:15.652]                             version <- NULL
[08:28:15.652]                           }
[08:28:15.652]                           if (!has_future || version < "1.8.0") {
[08:28:15.652]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.652]                               "", base::R.version$version.string), 
[08:28:15.652]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.652]                                 base::R.version$platform, 8 * 
[08:28:15.652]                                   base::.Machine$sizeof.pointer), 
[08:28:15.652]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.652]                                 "release", "version")], collapse = " "), 
[08:28:15.652]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.652]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.652]                               info)
[08:28:15.652]                             info <- base::paste(info, collapse = "; ")
[08:28:15.652]                             if (!has_future) {
[08:28:15.652]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.652]                                 info)
[08:28:15.652]                             }
[08:28:15.652]                             else {
[08:28:15.652]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.652]                                 info, version)
[08:28:15.652]                             }
[08:28:15.652]                             base::stop(msg)
[08:28:15.652]                           }
[08:28:15.652]                         })
[08:28:15.652]                       }
[08:28:15.652]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.652]                       base::options(mc.cores = 1L)
[08:28:15.652]                     }
[08:28:15.652]                     base::local({
[08:28:15.652]                       for (pkg in "future") {
[08:28:15.652]                         base::loadNamespace(pkg)
[08:28:15.652]                         base::library(pkg, character.only = TRUE)
[08:28:15.652]                       }
[08:28:15.652]                     })
[08:28:15.652]                   }
[08:28:15.652]                   ...future.strategy.old <- future::plan("list")
[08:28:15.652]                   options(future.plan = NULL)
[08:28:15.652]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.652]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.652]                 }
[08:28:15.652]                 ...future.workdir <- getwd()
[08:28:15.652]             }
[08:28:15.652]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.652]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.652]         }
[08:28:15.652]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.652]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.652]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.652]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.652]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.652]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.652]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.652]             base::names(...future.oldOptions))
[08:28:15.652]     }
[08:28:15.652]     if (FALSE) {
[08:28:15.652]     }
[08:28:15.652]     else {
[08:28:15.652]         if (TRUE) {
[08:28:15.652]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.652]                 open = "w")
[08:28:15.652]         }
[08:28:15.652]         else {
[08:28:15.652]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.652]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.652]         }
[08:28:15.652]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.652]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.652]             base::sink(type = "output", split = FALSE)
[08:28:15.652]             base::close(...future.stdout)
[08:28:15.652]         }, add = TRUE)
[08:28:15.652]     }
[08:28:15.652]     ...future.frame <- base::sys.nframe()
[08:28:15.652]     ...future.conditions <- base::list()
[08:28:15.652]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.652]     if (FALSE) {
[08:28:15.652]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.652]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.652]     }
[08:28:15.652]     ...future.result <- base::tryCatch({
[08:28:15.652]         base::withCallingHandlers({
[08:28:15.652]             ...future.value <- base::withVisible(base::local({
[08:28:15.652]                 withCallingHandlers({
[08:28:15.652]                   value(a) + 1
[08:28:15.652]                 }, immediateCondition = function(cond) {
[08:28:15.652]                   save_rds <- function (object, pathname, ...) 
[08:28:15.652]                   {
[08:28:15.652]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.652]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.652]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.652]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.652]                         fi_tmp[["mtime"]])
[08:28:15.652]                     }
[08:28:15.652]                     tryCatch({
[08:28:15.652]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.652]                     }, error = function(ex) {
[08:28:15.652]                       msg <- conditionMessage(ex)
[08:28:15.652]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.652]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.652]                         fi_tmp[["mtime"]], msg)
[08:28:15.652]                       ex$message <- msg
[08:28:15.652]                       stop(ex)
[08:28:15.652]                     })
[08:28:15.652]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.652]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.652]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.652]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.652]                       fi <- file.info(pathname)
[08:28:15.652]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.652]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.652]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.652]                         fi[["size"]], fi[["mtime"]])
[08:28:15.652]                       stop(msg)
[08:28:15.652]                     }
[08:28:15.652]                     invisible(pathname)
[08:28:15.652]                   }
[08:28:15.652]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.652]                     rootPath = tempdir()) 
[08:28:15.652]                   {
[08:28:15.652]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.652]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.652]                       tmpdir = path, fileext = ".rds")
[08:28:15.652]                     save_rds(obj, file)
[08:28:15.652]                   }
[08:28:15.652]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.652]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.652]                   {
[08:28:15.652]                     inherits <- base::inherits
[08:28:15.652]                     invokeRestart <- base::invokeRestart
[08:28:15.652]                     is.null <- base::is.null
[08:28:15.652]                     muffled <- FALSE
[08:28:15.652]                     if (inherits(cond, "message")) {
[08:28:15.652]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.652]                       if (muffled) 
[08:28:15.652]                         invokeRestart("muffleMessage")
[08:28:15.652]                     }
[08:28:15.652]                     else if (inherits(cond, "warning")) {
[08:28:15.652]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.652]                       if (muffled) 
[08:28:15.652]                         invokeRestart("muffleWarning")
[08:28:15.652]                     }
[08:28:15.652]                     else if (inherits(cond, "condition")) {
[08:28:15.652]                       if (!is.null(pattern)) {
[08:28:15.652]                         computeRestarts <- base::computeRestarts
[08:28:15.652]                         grepl <- base::grepl
[08:28:15.652]                         restarts <- computeRestarts(cond)
[08:28:15.652]                         for (restart in restarts) {
[08:28:15.652]                           name <- restart$name
[08:28:15.652]                           if (is.null(name)) 
[08:28:15.652]                             next
[08:28:15.652]                           if (!grepl(pattern, name)) 
[08:28:15.652]                             next
[08:28:15.652]                           invokeRestart(restart)
[08:28:15.652]                           muffled <- TRUE
[08:28:15.652]                           break
[08:28:15.652]                         }
[08:28:15.652]                       }
[08:28:15.652]                     }
[08:28:15.652]                     invisible(muffled)
[08:28:15.652]                   }
[08:28:15.652]                   muffleCondition(cond)
[08:28:15.652]                 })
[08:28:15.652]             }))
[08:28:15.652]             future::FutureResult(value = ...future.value$value, 
[08:28:15.652]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.652]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.652]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.652]                     ...future.globalenv.names))
[08:28:15.652]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.652]         }, condition = base::local({
[08:28:15.652]             c <- base::c
[08:28:15.652]             inherits <- base::inherits
[08:28:15.652]             invokeRestart <- base::invokeRestart
[08:28:15.652]             length <- base::length
[08:28:15.652]             list <- base::list
[08:28:15.652]             seq.int <- base::seq.int
[08:28:15.652]             signalCondition <- base::signalCondition
[08:28:15.652]             sys.calls <- base::sys.calls
[08:28:15.652]             `[[` <- base::`[[`
[08:28:15.652]             `+` <- base::`+`
[08:28:15.652]             `<<-` <- base::`<<-`
[08:28:15.652]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.652]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.652]                   3L)]
[08:28:15.652]             }
[08:28:15.652]             function(cond) {
[08:28:15.652]                 is_error <- inherits(cond, "error")
[08:28:15.652]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.652]                   NULL)
[08:28:15.652]                 if (is_error) {
[08:28:15.652]                   sessionInformation <- function() {
[08:28:15.652]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.652]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.652]                       search = base::search(), system = base::Sys.info())
[08:28:15.652]                   }
[08:28:15.652]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.652]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.652]                     cond$call), session = sessionInformation(), 
[08:28:15.652]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.652]                   signalCondition(cond)
[08:28:15.652]                 }
[08:28:15.652]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.652]                 "immediateCondition"))) {
[08:28:15.652]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.652]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.652]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.652]                   if (TRUE && !signal) {
[08:28:15.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.652]                     {
[08:28:15.652]                       inherits <- base::inherits
[08:28:15.652]                       invokeRestart <- base::invokeRestart
[08:28:15.652]                       is.null <- base::is.null
[08:28:15.652]                       muffled <- FALSE
[08:28:15.652]                       if (inherits(cond, "message")) {
[08:28:15.652]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.652]                         if (muffled) 
[08:28:15.652]                           invokeRestart("muffleMessage")
[08:28:15.652]                       }
[08:28:15.652]                       else if (inherits(cond, "warning")) {
[08:28:15.652]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.652]                         if (muffled) 
[08:28:15.652]                           invokeRestart("muffleWarning")
[08:28:15.652]                       }
[08:28:15.652]                       else if (inherits(cond, "condition")) {
[08:28:15.652]                         if (!is.null(pattern)) {
[08:28:15.652]                           computeRestarts <- base::computeRestarts
[08:28:15.652]                           grepl <- base::grepl
[08:28:15.652]                           restarts <- computeRestarts(cond)
[08:28:15.652]                           for (restart in restarts) {
[08:28:15.652]                             name <- restart$name
[08:28:15.652]                             if (is.null(name)) 
[08:28:15.652]                               next
[08:28:15.652]                             if (!grepl(pattern, name)) 
[08:28:15.652]                               next
[08:28:15.652]                             invokeRestart(restart)
[08:28:15.652]                             muffled <- TRUE
[08:28:15.652]                             break
[08:28:15.652]                           }
[08:28:15.652]                         }
[08:28:15.652]                       }
[08:28:15.652]                       invisible(muffled)
[08:28:15.652]                     }
[08:28:15.652]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.652]                   }
[08:28:15.652]                 }
[08:28:15.652]                 else {
[08:28:15.652]                   if (TRUE) {
[08:28:15.652]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.652]                     {
[08:28:15.652]                       inherits <- base::inherits
[08:28:15.652]                       invokeRestart <- base::invokeRestart
[08:28:15.652]                       is.null <- base::is.null
[08:28:15.652]                       muffled <- FALSE
[08:28:15.652]                       if (inherits(cond, "message")) {
[08:28:15.652]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.652]                         if (muffled) 
[08:28:15.652]                           invokeRestart("muffleMessage")
[08:28:15.652]                       }
[08:28:15.652]                       else if (inherits(cond, "warning")) {
[08:28:15.652]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.652]                         if (muffled) 
[08:28:15.652]                           invokeRestart("muffleWarning")
[08:28:15.652]                       }
[08:28:15.652]                       else if (inherits(cond, "condition")) {
[08:28:15.652]                         if (!is.null(pattern)) {
[08:28:15.652]                           computeRestarts <- base::computeRestarts
[08:28:15.652]                           grepl <- base::grepl
[08:28:15.652]                           restarts <- computeRestarts(cond)
[08:28:15.652]                           for (restart in restarts) {
[08:28:15.652]                             name <- restart$name
[08:28:15.652]                             if (is.null(name)) 
[08:28:15.652]                               next
[08:28:15.652]                             if (!grepl(pattern, name)) 
[08:28:15.652]                               next
[08:28:15.652]                             invokeRestart(restart)
[08:28:15.652]                             muffled <- TRUE
[08:28:15.652]                             break
[08:28:15.652]                           }
[08:28:15.652]                         }
[08:28:15.652]                       }
[08:28:15.652]                       invisible(muffled)
[08:28:15.652]                     }
[08:28:15.652]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.652]                   }
[08:28:15.652]                 }
[08:28:15.652]             }
[08:28:15.652]         }))
[08:28:15.652]     }, error = function(ex) {
[08:28:15.652]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.652]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.652]                 ...future.rng), started = ...future.startTime, 
[08:28:15.652]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.652]             version = "1.8"), class = "FutureResult")
[08:28:15.652]     }, finally = {
[08:28:15.652]         if (!identical(...future.workdir, getwd())) 
[08:28:15.652]             setwd(...future.workdir)
[08:28:15.652]         {
[08:28:15.652]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.652]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.652]             }
[08:28:15.652]             base::options(...future.oldOptions)
[08:28:15.652]             if (.Platform$OS.type == "windows") {
[08:28:15.652]                 old_names <- names(...future.oldEnvVars)
[08:28:15.652]                 envs <- base::Sys.getenv()
[08:28:15.652]                 names <- names(envs)
[08:28:15.652]                 common <- intersect(names, old_names)
[08:28:15.652]                 added <- setdiff(names, old_names)
[08:28:15.652]                 removed <- setdiff(old_names, names)
[08:28:15.652]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.652]                   envs[common]]
[08:28:15.652]                 NAMES <- toupper(changed)
[08:28:15.652]                 args <- list()
[08:28:15.652]                 for (kk in seq_along(NAMES)) {
[08:28:15.652]                   name <- changed[[kk]]
[08:28:15.652]                   NAME <- NAMES[[kk]]
[08:28:15.652]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.652]                     next
[08:28:15.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.652]                 }
[08:28:15.652]                 NAMES <- toupper(added)
[08:28:15.652]                 for (kk in seq_along(NAMES)) {
[08:28:15.652]                   name <- added[[kk]]
[08:28:15.652]                   NAME <- NAMES[[kk]]
[08:28:15.652]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.652]                     next
[08:28:15.652]                   args[[name]] <- ""
[08:28:15.652]                 }
[08:28:15.652]                 NAMES <- toupper(removed)
[08:28:15.652]                 for (kk in seq_along(NAMES)) {
[08:28:15.652]                   name <- removed[[kk]]
[08:28:15.652]                   NAME <- NAMES[[kk]]
[08:28:15.652]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.652]                     next
[08:28:15.652]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.652]                 }
[08:28:15.652]                 if (length(args) > 0) 
[08:28:15.652]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.652]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.652]             }
[08:28:15.652]             else {
[08:28:15.652]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.652]             }
[08:28:15.652]             {
[08:28:15.652]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.652]                   0L) {
[08:28:15.652]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.652]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.652]                   base::options(opts)
[08:28:15.652]                 }
[08:28:15.652]                 {
[08:28:15.652]                   {
[08:28:15.652]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.652]                     NULL
[08:28:15.652]                   }
[08:28:15.652]                   options(future.plan = NULL)
[08:28:15.652]                   if (is.na(NA_character_)) 
[08:28:15.652]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.652]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.652]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.652]                     .init = FALSE)
[08:28:15.652]                 }
[08:28:15.652]             }
[08:28:15.652]         }
[08:28:15.652]     })
[08:28:15.652]     if (TRUE) {
[08:28:15.652]         base::sink(type = "output", split = FALSE)
[08:28:15.652]         if (TRUE) {
[08:28:15.652]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.652]         }
[08:28:15.652]         else {
[08:28:15.652]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.652]         }
[08:28:15.652]         base::close(...future.stdout)
[08:28:15.652]         ...future.stdout <- NULL
[08:28:15.652]     }
[08:28:15.652]     ...future.result$conditions <- ...future.conditions
[08:28:15.652]     ...future.result$finished <- base::Sys.time()
[08:28:15.652]     ...future.result
[08:28:15.652] }
[08:28:15.655] assign_globals() ...
[08:28:15.655] List of 1
[08:28:15.655]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a10968cf98> 
[08:28:15.655]  - attr(*, "where")=List of 1
[08:28:15.655]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.655]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.655]  - attr(*, "resolved")= logi TRUE
[08:28:15.655]  - attr(*, "total_size")= num 3815
[08:28:15.655]  - attr(*, "already-done")= logi TRUE
[08:28:15.658] - copied ‘a’ to environment
[08:28:15.658] assign_globals() ... done
[08:28:15.658] requestCore(): workers = 2
[08:28:15.660] MulticoreFuture started
[08:28:15.660] - Launch lazy future ... done
[08:28:15.661] run() for ‘MulticoreFuture’ ... done
[08:28:15.661] result() for MulticoreFuture ...
[08:28:15.661] plan(): Setting new future strategy stack:
[08:28:15.661] List of future strategies:
[08:28:15.661] 1. sequential:
[08:28:15.661]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.661]    - tweaked: FALSE
[08:28:15.661]    - call: NULL
[08:28:15.663] plan(): nbrOfWorkers() = 1
[08:28:15.666] plan(): Setting new future strategy stack:
[08:28:15.666] List of future strategies:
[08:28:15.666] 1. multicore:
[08:28:15.666]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.666]    - tweaked: FALSE
[08:28:15.666]    - call: plan(strategy)
[08:28:15.669] plan(): nbrOfWorkers() = 2
[08:28:15.670] result() for MulticoreFuture ...
[08:28:15.670] result() for MulticoreFuture ... done
[08:28:15.670] signalConditions() ...
[08:28:15.670]  - include = ‘immediateCondition’
[08:28:15.670]  - exclude = 
[08:28:15.671]  - resignal = FALSE
[08:28:15.671]  - Number of conditions: 4
[08:28:15.671] signalConditions() ... done
[08:28:15.671] result() for MulticoreFuture ... done
[08:28:15.671] result() for MulticoreFuture ...
[08:28:15.671] result() for MulticoreFuture ... done
[08:28:15.671] signalConditions() ...
[08:28:15.671]  - include = ‘immediateCondition’
[08:28:15.672]  - exclude = 
[08:28:15.672]  - resignal = FALSE
[08:28:15.672]  - Number of conditions: 4
[08:28:15.672] signalConditions() ... done
[08:28:15.672] Future state: ‘finished’
[08:28:15.672] result() for MulticoreFuture ...
[08:28:15.672] result() for MulticoreFuture ... done
[08:28:15.672] signalConditions() ...
[08:28:15.672]  - include = ‘condition’
[08:28:15.673]  - exclude = ‘immediateCondition’
[08:28:15.673]  - resignal = TRUE
[08:28:15.673]  - Number of conditions: 4
[08:28:15.673]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.664] result() for MulticoreFuture ...
[08:28:15.673]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.664] result() for MulticoreFuture ... done
[08:28:15.673]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.664] result() for MulticoreFuture ...
[08:28:15.673]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.665] result() for MulticoreFuture ... done
[08:28:15.674] signalConditions() ... done
value(b) = 2
[08:28:15.674] result() for MulticoreFuture ...
[08:28:15.674] result() for MulticoreFuture ... done
[08:28:15.674] result() for MulticoreFuture ...
[08:28:15.674] result() for MulticoreFuture ... done
[08:28:15.674] signalConditions() ...
[08:28:15.674]  - include = ‘immediateCondition’
[08:28:15.674]  - exclude = 
[08:28:15.675]  - resignal = FALSE
[08:28:15.675]  - Number of conditions: 4
[08:28:15.675] signalConditions() ... done
[08:28:15.675] Future state: ‘finished’
[08:28:15.675] result() for MulticoreFuture ...
[08:28:15.675] result() for MulticoreFuture ... done
[08:28:15.675] signalConditions() ...
[08:28:15.675]  - include = ‘condition’
[08:28:15.675]  - exclude = ‘immediateCondition’
[08:28:15.676]  - resignal = TRUE
[08:28:15.676]  - Number of conditions: 4
[08:28:15.676]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.664] result() for MulticoreFuture ...
[08:28:15.676]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.664] result() for MulticoreFuture ... done
[08:28:15.676]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.664] result() for MulticoreFuture ...
[08:28:15.676]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.665] result() for MulticoreFuture ... done
[08:28:15.676] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.677] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.677] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.677] 
[08:28:15.678] Searching for globals ... DONE
[08:28:15.678] - globals: [0] <none>
[08:28:15.678] getGlobalsAndPackages() ... DONE
[08:28:15.678] run() for ‘Future’ ...
[08:28:15.678] - state: ‘created’
[08:28:15.678] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.680] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.681] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.681]   - Field: ‘label’
[08:28:15.681]   - Field: ‘local’
[08:28:15.681]   - Field: ‘owner’
[08:28:15.681]   - Field: ‘envir’
[08:28:15.681]   - Field: ‘workers’
[08:28:15.681]   - Field: ‘packages’
[08:28:15.681]   - Field: ‘gc’
[08:28:15.682]   - Field: ‘job’
[08:28:15.682]   - Field: ‘conditions’
[08:28:15.682]   - Field: ‘expr’
[08:28:15.682]   - Field: ‘uuid’
[08:28:15.682]   - Field: ‘seed’
[08:28:15.682]   - Field: ‘version’
[08:28:15.682]   - Field: ‘result’
[08:28:15.682]   - Field: ‘asynchronous’
[08:28:15.682]   - Field: ‘calls’
[08:28:15.683]   - Field: ‘globals’
[08:28:15.683]   - Field: ‘stdout’
[08:28:15.683]   - Field: ‘earlySignal’
[08:28:15.683]   - Field: ‘lazy’
[08:28:15.683]   - Field: ‘state’
[08:28:15.683] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.683] - Launch lazy future ...
[08:28:15.684] Packages needed by the future expression (n = 0): <none>
[08:28:15.684] Packages needed by future strategies (n = 0): <none>
[08:28:15.684] {
[08:28:15.684]     {
[08:28:15.684]         {
[08:28:15.684]             ...future.startTime <- base::Sys.time()
[08:28:15.684]             {
[08:28:15.684]                 {
[08:28:15.684]                   {
[08:28:15.684]                     {
[08:28:15.684]                       base::local({
[08:28:15.684]                         has_future <- base::requireNamespace("future", 
[08:28:15.684]                           quietly = TRUE)
[08:28:15.684]                         if (has_future) {
[08:28:15.684]                           ns <- base::getNamespace("future")
[08:28:15.684]                           version <- ns[[".package"]][["version"]]
[08:28:15.684]                           if (is.null(version)) 
[08:28:15.684]                             version <- utils::packageVersion("future")
[08:28:15.684]                         }
[08:28:15.684]                         else {
[08:28:15.684]                           version <- NULL
[08:28:15.684]                         }
[08:28:15.684]                         if (!has_future || version < "1.8.0") {
[08:28:15.684]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.684]                             "", base::R.version$version.string), 
[08:28:15.684]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.684]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.684]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.684]                               "release", "version")], collapse = " "), 
[08:28:15.684]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.684]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.684]                             info)
[08:28:15.684]                           info <- base::paste(info, collapse = "; ")
[08:28:15.684]                           if (!has_future) {
[08:28:15.684]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.684]                               info)
[08:28:15.684]                           }
[08:28:15.684]                           else {
[08:28:15.684]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.684]                               info, version)
[08:28:15.684]                           }
[08:28:15.684]                           base::stop(msg)
[08:28:15.684]                         }
[08:28:15.684]                       })
[08:28:15.684]                     }
[08:28:15.684]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.684]                     base::options(mc.cores = 1L)
[08:28:15.684]                   }
[08:28:15.684]                   ...future.strategy.old <- future::plan("list")
[08:28:15.684]                   options(future.plan = NULL)
[08:28:15.684]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.684]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.684]                 }
[08:28:15.684]                 ...future.workdir <- getwd()
[08:28:15.684]             }
[08:28:15.684]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.684]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.684]         }
[08:28:15.684]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.684]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.684]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.684]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.684]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.684]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.684]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.684]             base::names(...future.oldOptions))
[08:28:15.684]     }
[08:28:15.684]     if (FALSE) {
[08:28:15.684]     }
[08:28:15.684]     else {
[08:28:15.684]         if (TRUE) {
[08:28:15.684]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.684]                 open = "w")
[08:28:15.684]         }
[08:28:15.684]         else {
[08:28:15.684]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.684]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.684]         }
[08:28:15.684]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.684]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.684]             base::sink(type = "output", split = FALSE)
[08:28:15.684]             base::close(...future.stdout)
[08:28:15.684]         }, add = TRUE)
[08:28:15.684]     }
[08:28:15.684]     ...future.frame <- base::sys.nframe()
[08:28:15.684]     ...future.conditions <- base::list()
[08:28:15.684]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.684]     if (FALSE) {
[08:28:15.684]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.684]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.684]     }
[08:28:15.684]     ...future.result <- base::tryCatch({
[08:28:15.684]         base::withCallingHandlers({
[08:28:15.684]             ...future.value <- base::withVisible(base::local({
[08:28:15.684]                 withCallingHandlers({
[08:28:15.684]                   1
[08:28:15.684]                 }, immediateCondition = function(cond) {
[08:28:15.684]                   save_rds <- function (object, pathname, ...) 
[08:28:15.684]                   {
[08:28:15.684]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.684]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.684]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.684]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.684]                         fi_tmp[["mtime"]])
[08:28:15.684]                     }
[08:28:15.684]                     tryCatch({
[08:28:15.684]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.684]                     }, error = function(ex) {
[08:28:15.684]                       msg <- conditionMessage(ex)
[08:28:15.684]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.684]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.684]                         fi_tmp[["mtime"]], msg)
[08:28:15.684]                       ex$message <- msg
[08:28:15.684]                       stop(ex)
[08:28:15.684]                     })
[08:28:15.684]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.684]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.684]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.684]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.684]                       fi <- file.info(pathname)
[08:28:15.684]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.684]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.684]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.684]                         fi[["size"]], fi[["mtime"]])
[08:28:15.684]                       stop(msg)
[08:28:15.684]                     }
[08:28:15.684]                     invisible(pathname)
[08:28:15.684]                   }
[08:28:15.684]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.684]                     rootPath = tempdir()) 
[08:28:15.684]                   {
[08:28:15.684]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.684]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.684]                       tmpdir = path, fileext = ".rds")
[08:28:15.684]                     save_rds(obj, file)
[08:28:15.684]                   }
[08:28:15.684]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.684]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.684]                   {
[08:28:15.684]                     inherits <- base::inherits
[08:28:15.684]                     invokeRestart <- base::invokeRestart
[08:28:15.684]                     is.null <- base::is.null
[08:28:15.684]                     muffled <- FALSE
[08:28:15.684]                     if (inherits(cond, "message")) {
[08:28:15.684]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.684]                       if (muffled) 
[08:28:15.684]                         invokeRestart("muffleMessage")
[08:28:15.684]                     }
[08:28:15.684]                     else if (inherits(cond, "warning")) {
[08:28:15.684]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.684]                       if (muffled) 
[08:28:15.684]                         invokeRestart("muffleWarning")
[08:28:15.684]                     }
[08:28:15.684]                     else if (inherits(cond, "condition")) {
[08:28:15.684]                       if (!is.null(pattern)) {
[08:28:15.684]                         computeRestarts <- base::computeRestarts
[08:28:15.684]                         grepl <- base::grepl
[08:28:15.684]                         restarts <- computeRestarts(cond)
[08:28:15.684]                         for (restart in restarts) {
[08:28:15.684]                           name <- restart$name
[08:28:15.684]                           if (is.null(name)) 
[08:28:15.684]                             next
[08:28:15.684]                           if (!grepl(pattern, name)) 
[08:28:15.684]                             next
[08:28:15.684]                           invokeRestart(restart)
[08:28:15.684]                           muffled <- TRUE
[08:28:15.684]                           break
[08:28:15.684]                         }
[08:28:15.684]                       }
[08:28:15.684]                     }
[08:28:15.684]                     invisible(muffled)
[08:28:15.684]                   }
[08:28:15.684]                   muffleCondition(cond)
[08:28:15.684]                 })
[08:28:15.684]             }))
[08:28:15.684]             future::FutureResult(value = ...future.value$value, 
[08:28:15.684]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.684]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.684]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.684]                     ...future.globalenv.names))
[08:28:15.684]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.684]         }, condition = base::local({
[08:28:15.684]             c <- base::c
[08:28:15.684]             inherits <- base::inherits
[08:28:15.684]             invokeRestart <- base::invokeRestart
[08:28:15.684]             length <- base::length
[08:28:15.684]             list <- base::list
[08:28:15.684]             seq.int <- base::seq.int
[08:28:15.684]             signalCondition <- base::signalCondition
[08:28:15.684]             sys.calls <- base::sys.calls
[08:28:15.684]             `[[` <- base::`[[`
[08:28:15.684]             `+` <- base::`+`
[08:28:15.684]             `<<-` <- base::`<<-`
[08:28:15.684]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.684]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.684]                   3L)]
[08:28:15.684]             }
[08:28:15.684]             function(cond) {
[08:28:15.684]                 is_error <- inherits(cond, "error")
[08:28:15.684]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.684]                   NULL)
[08:28:15.684]                 if (is_error) {
[08:28:15.684]                   sessionInformation <- function() {
[08:28:15.684]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.684]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.684]                       search = base::search(), system = base::Sys.info())
[08:28:15.684]                   }
[08:28:15.684]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.684]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.684]                     cond$call), session = sessionInformation(), 
[08:28:15.684]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.684]                   signalCondition(cond)
[08:28:15.684]                 }
[08:28:15.684]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.684]                 "immediateCondition"))) {
[08:28:15.684]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.684]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.684]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.684]                   if (TRUE && !signal) {
[08:28:15.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.684]                     {
[08:28:15.684]                       inherits <- base::inherits
[08:28:15.684]                       invokeRestart <- base::invokeRestart
[08:28:15.684]                       is.null <- base::is.null
[08:28:15.684]                       muffled <- FALSE
[08:28:15.684]                       if (inherits(cond, "message")) {
[08:28:15.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.684]                         if (muffled) 
[08:28:15.684]                           invokeRestart("muffleMessage")
[08:28:15.684]                       }
[08:28:15.684]                       else if (inherits(cond, "warning")) {
[08:28:15.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.684]                         if (muffled) 
[08:28:15.684]                           invokeRestart("muffleWarning")
[08:28:15.684]                       }
[08:28:15.684]                       else if (inherits(cond, "condition")) {
[08:28:15.684]                         if (!is.null(pattern)) {
[08:28:15.684]                           computeRestarts <- base::computeRestarts
[08:28:15.684]                           grepl <- base::grepl
[08:28:15.684]                           restarts <- computeRestarts(cond)
[08:28:15.684]                           for (restart in restarts) {
[08:28:15.684]                             name <- restart$name
[08:28:15.684]                             if (is.null(name)) 
[08:28:15.684]                               next
[08:28:15.684]                             if (!grepl(pattern, name)) 
[08:28:15.684]                               next
[08:28:15.684]                             invokeRestart(restart)
[08:28:15.684]                             muffled <- TRUE
[08:28:15.684]                             break
[08:28:15.684]                           }
[08:28:15.684]                         }
[08:28:15.684]                       }
[08:28:15.684]                       invisible(muffled)
[08:28:15.684]                     }
[08:28:15.684]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.684]                   }
[08:28:15.684]                 }
[08:28:15.684]                 else {
[08:28:15.684]                   if (TRUE) {
[08:28:15.684]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.684]                     {
[08:28:15.684]                       inherits <- base::inherits
[08:28:15.684]                       invokeRestart <- base::invokeRestart
[08:28:15.684]                       is.null <- base::is.null
[08:28:15.684]                       muffled <- FALSE
[08:28:15.684]                       if (inherits(cond, "message")) {
[08:28:15.684]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.684]                         if (muffled) 
[08:28:15.684]                           invokeRestart("muffleMessage")
[08:28:15.684]                       }
[08:28:15.684]                       else if (inherits(cond, "warning")) {
[08:28:15.684]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.684]                         if (muffled) 
[08:28:15.684]                           invokeRestart("muffleWarning")
[08:28:15.684]                       }
[08:28:15.684]                       else if (inherits(cond, "condition")) {
[08:28:15.684]                         if (!is.null(pattern)) {
[08:28:15.684]                           computeRestarts <- base::computeRestarts
[08:28:15.684]                           grepl <- base::grepl
[08:28:15.684]                           restarts <- computeRestarts(cond)
[08:28:15.684]                           for (restart in restarts) {
[08:28:15.684]                             name <- restart$name
[08:28:15.684]                             if (is.null(name)) 
[08:28:15.684]                               next
[08:28:15.684]                             if (!grepl(pattern, name)) 
[08:28:15.684]                               next
[08:28:15.684]                             invokeRestart(restart)
[08:28:15.684]                             muffled <- TRUE
[08:28:15.684]                             break
[08:28:15.684]                           }
[08:28:15.684]                         }
[08:28:15.684]                       }
[08:28:15.684]                       invisible(muffled)
[08:28:15.684]                     }
[08:28:15.684]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.684]                   }
[08:28:15.684]                 }
[08:28:15.684]             }
[08:28:15.684]         }))
[08:28:15.684]     }, error = function(ex) {
[08:28:15.684]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.684]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.684]                 ...future.rng), started = ...future.startTime, 
[08:28:15.684]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.684]             version = "1.8"), class = "FutureResult")
[08:28:15.684]     }, finally = {
[08:28:15.684]         if (!identical(...future.workdir, getwd())) 
[08:28:15.684]             setwd(...future.workdir)
[08:28:15.684]         {
[08:28:15.684]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.684]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.684]             }
[08:28:15.684]             base::options(...future.oldOptions)
[08:28:15.684]             if (.Platform$OS.type == "windows") {
[08:28:15.684]                 old_names <- names(...future.oldEnvVars)
[08:28:15.684]                 envs <- base::Sys.getenv()
[08:28:15.684]                 names <- names(envs)
[08:28:15.684]                 common <- intersect(names, old_names)
[08:28:15.684]                 added <- setdiff(names, old_names)
[08:28:15.684]                 removed <- setdiff(old_names, names)
[08:28:15.684]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.684]                   envs[common]]
[08:28:15.684]                 NAMES <- toupper(changed)
[08:28:15.684]                 args <- list()
[08:28:15.684]                 for (kk in seq_along(NAMES)) {
[08:28:15.684]                   name <- changed[[kk]]
[08:28:15.684]                   NAME <- NAMES[[kk]]
[08:28:15.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.684]                     next
[08:28:15.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.684]                 }
[08:28:15.684]                 NAMES <- toupper(added)
[08:28:15.684]                 for (kk in seq_along(NAMES)) {
[08:28:15.684]                   name <- added[[kk]]
[08:28:15.684]                   NAME <- NAMES[[kk]]
[08:28:15.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.684]                     next
[08:28:15.684]                   args[[name]] <- ""
[08:28:15.684]                 }
[08:28:15.684]                 NAMES <- toupper(removed)
[08:28:15.684]                 for (kk in seq_along(NAMES)) {
[08:28:15.684]                   name <- removed[[kk]]
[08:28:15.684]                   NAME <- NAMES[[kk]]
[08:28:15.684]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.684]                     next
[08:28:15.684]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.684]                 }
[08:28:15.684]                 if (length(args) > 0) 
[08:28:15.684]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.684]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.684]             }
[08:28:15.684]             else {
[08:28:15.684]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.684]             }
[08:28:15.684]             {
[08:28:15.684]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.684]                   0L) {
[08:28:15.684]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.684]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.684]                   base::options(opts)
[08:28:15.684]                 }
[08:28:15.684]                 {
[08:28:15.684]                   {
[08:28:15.684]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.684]                     NULL
[08:28:15.684]                   }
[08:28:15.684]                   options(future.plan = NULL)
[08:28:15.684]                   if (is.na(NA_character_)) 
[08:28:15.684]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.684]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.684]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.684]                     .init = FALSE)
[08:28:15.684]                 }
[08:28:15.684]             }
[08:28:15.684]         }
[08:28:15.684]     })
[08:28:15.684]     if (TRUE) {
[08:28:15.684]         base::sink(type = "output", split = FALSE)
[08:28:15.684]         if (TRUE) {
[08:28:15.684]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.684]         }
[08:28:15.684]         else {
[08:28:15.684]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.684]         }
[08:28:15.684]         base::close(...future.stdout)
[08:28:15.684]         ...future.stdout <- NULL
[08:28:15.684]     }
[08:28:15.684]     ...future.result$conditions <- ...future.conditions
[08:28:15.684]     ...future.result$finished <- base::Sys.time()
[08:28:15.684]     ...future.result
[08:28:15.684] }
[08:28:15.689] requestCore(): workers = 2
[08:28:15.691] MulticoreFuture started
[08:28:15.692] - Launch lazy future ... done
[08:28:15.692] run() for ‘MulticoreFuture’ ... done
[08:28:15.692] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.693] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.693] List of future strategies:
[08:28:15.693] 1. sequential:
[08:28:15.693]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.693]    - tweaked: FALSE
[08:28:15.693]    - call: NULL
[08:28:15.693] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.694] plan(): nbrOfWorkers() = 1
[08:28:15.696] plan(): Setting new future strategy stack:
[08:28:15.696] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.697] Searching for globals ... DONE
[08:28:15.697] Resolving globals: TRUE
[08:28:15.696] List of future strategies:
[08:28:15.696] 1. multicore:
[08:28:15.696]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.696]    - tweaked: FALSE
[08:28:15.696]    - call: plan(strategy)
[08:28:15.697] Resolving any globals that are futures ...
[08:28:15.697] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.697] Resolving any globals that are futures ... DONE
[08:28:15.698] Resolving futures part of globals (recursively) ...
[08:28:15.699] resolve() on list ...
[08:28:15.700]  recursive: 99
[08:28:15.700] plan(): nbrOfWorkers() = 2
[08:28:15.700]  length: 1
[08:28:15.700]  elements: ‘a’
[08:28:15.700] Future #1
[08:28:15.701] result() for MulticoreFuture ...
[08:28:15.701] result() for MulticoreFuture ...
[08:28:15.702] result() for MulticoreFuture ... done
[08:28:15.702] result() for MulticoreFuture ... done
[08:28:15.702] result() for MulticoreFuture ...
[08:28:15.702] result() for MulticoreFuture ... done
[08:28:15.702] A MulticoreFuture was resolved
[08:28:15.702]  length: 0 (resolved future 1)
[08:28:15.703] resolve() on list ... DONE
[08:28:15.703] - globals: [1] ‘a’
[08:28:15.703] Resolving futures part of globals (recursively) ... DONE
[08:28:15.703] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[08:28:15.704] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[08:28:15.704] - globals: [1] ‘a’
[08:28:15.704] - packages: [1] ‘future’
[08:28:15.704] getGlobalsAndPackages() ... DONE
[08:28:15.705] run() for ‘Future’ ...
[08:28:15.705] - state: ‘created’
[08:28:15.705] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.707] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.707] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.707]   - Field: ‘label’
[08:28:15.708]   - Field: ‘local’
[08:28:15.708]   - Field: ‘owner’
[08:28:15.708]   - Field: ‘envir’
[08:28:15.708]   - Field: ‘workers’
[08:28:15.708]   - Field: ‘packages’
[08:28:15.708]   - Field: ‘gc’
[08:28:15.708]   - Field: ‘job’
[08:28:15.708]   - Field: ‘conditions’
[08:28:15.708]   - Field: ‘expr’
[08:28:15.709]   - Field: ‘uuid’
[08:28:15.709]   - Field: ‘seed’
[08:28:15.709]   - Field: ‘version’
[08:28:15.709]   - Field: ‘result’
[08:28:15.709]   - Field: ‘asynchronous’
[08:28:15.709]   - Field: ‘calls’
[08:28:15.709]   - Field: ‘globals’
[08:28:15.709]   - Field: ‘stdout’
[08:28:15.709]   - Field: ‘earlySignal’
[08:28:15.709]   - Field: ‘lazy’
[08:28:15.710]   - Field: ‘state’
[08:28:15.710] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.710] - Launch lazy future ...
[08:28:15.710] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.710] Packages needed by future strategies (n = 0): <none>
[08:28:15.711] {
[08:28:15.711]     {
[08:28:15.711]         {
[08:28:15.711]             ...future.startTime <- base::Sys.time()
[08:28:15.711]             {
[08:28:15.711]                 {
[08:28:15.711]                   {
[08:28:15.711]                     {
[08:28:15.711]                       {
[08:28:15.711]                         base::local({
[08:28:15.711]                           has_future <- base::requireNamespace("future", 
[08:28:15.711]                             quietly = TRUE)
[08:28:15.711]                           if (has_future) {
[08:28:15.711]                             ns <- base::getNamespace("future")
[08:28:15.711]                             version <- ns[[".package"]][["version"]]
[08:28:15.711]                             if (is.null(version)) 
[08:28:15.711]                               version <- utils::packageVersion("future")
[08:28:15.711]                           }
[08:28:15.711]                           else {
[08:28:15.711]                             version <- NULL
[08:28:15.711]                           }
[08:28:15.711]                           if (!has_future || version < "1.8.0") {
[08:28:15.711]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.711]                               "", base::R.version$version.string), 
[08:28:15.711]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.711]                                 base::R.version$platform, 8 * 
[08:28:15.711]                                   base::.Machine$sizeof.pointer), 
[08:28:15.711]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.711]                                 "release", "version")], collapse = " "), 
[08:28:15.711]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.711]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.711]                               info)
[08:28:15.711]                             info <- base::paste(info, collapse = "; ")
[08:28:15.711]                             if (!has_future) {
[08:28:15.711]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.711]                                 info)
[08:28:15.711]                             }
[08:28:15.711]                             else {
[08:28:15.711]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.711]                                 info, version)
[08:28:15.711]                             }
[08:28:15.711]                             base::stop(msg)
[08:28:15.711]                           }
[08:28:15.711]                         })
[08:28:15.711]                       }
[08:28:15.711]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.711]                       base::options(mc.cores = 1L)
[08:28:15.711]                     }
[08:28:15.711]                     base::local({
[08:28:15.711]                       for (pkg in "future") {
[08:28:15.711]                         base::loadNamespace(pkg)
[08:28:15.711]                         base::library(pkg, character.only = TRUE)
[08:28:15.711]                       }
[08:28:15.711]                     })
[08:28:15.711]                   }
[08:28:15.711]                   ...future.strategy.old <- future::plan("list")
[08:28:15.711]                   options(future.plan = NULL)
[08:28:15.711]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.711]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.711]                 }
[08:28:15.711]                 ...future.workdir <- getwd()
[08:28:15.711]             }
[08:28:15.711]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.711]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.711]         }
[08:28:15.711]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.711]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.711]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.711]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.711]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.711]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.711]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.711]             base::names(...future.oldOptions))
[08:28:15.711]     }
[08:28:15.711]     if (FALSE) {
[08:28:15.711]     }
[08:28:15.711]     else {
[08:28:15.711]         if (TRUE) {
[08:28:15.711]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.711]                 open = "w")
[08:28:15.711]         }
[08:28:15.711]         else {
[08:28:15.711]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.711]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.711]         }
[08:28:15.711]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.711]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.711]             base::sink(type = "output", split = FALSE)
[08:28:15.711]             base::close(...future.stdout)
[08:28:15.711]         }, add = TRUE)
[08:28:15.711]     }
[08:28:15.711]     ...future.frame <- base::sys.nframe()
[08:28:15.711]     ...future.conditions <- base::list()
[08:28:15.711]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.711]     if (FALSE) {
[08:28:15.711]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.711]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.711]     }
[08:28:15.711]     ...future.result <- base::tryCatch({
[08:28:15.711]         base::withCallingHandlers({
[08:28:15.711]             ...future.value <- base::withVisible(base::local({
[08:28:15.711]                 withCallingHandlers({
[08:28:15.711]                   value(a) + 1
[08:28:15.711]                 }, immediateCondition = function(cond) {
[08:28:15.711]                   save_rds <- function (object, pathname, ...) 
[08:28:15.711]                   {
[08:28:15.711]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.711]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.711]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.711]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.711]                         fi_tmp[["mtime"]])
[08:28:15.711]                     }
[08:28:15.711]                     tryCatch({
[08:28:15.711]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.711]                     }, error = function(ex) {
[08:28:15.711]                       msg <- conditionMessage(ex)
[08:28:15.711]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.711]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.711]                         fi_tmp[["mtime"]], msg)
[08:28:15.711]                       ex$message <- msg
[08:28:15.711]                       stop(ex)
[08:28:15.711]                     })
[08:28:15.711]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.711]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.711]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.711]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.711]                       fi <- file.info(pathname)
[08:28:15.711]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.711]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.711]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.711]                         fi[["size"]], fi[["mtime"]])
[08:28:15.711]                       stop(msg)
[08:28:15.711]                     }
[08:28:15.711]                     invisible(pathname)
[08:28:15.711]                   }
[08:28:15.711]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.711]                     rootPath = tempdir()) 
[08:28:15.711]                   {
[08:28:15.711]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.711]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.711]                       tmpdir = path, fileext = ".rds")
[08:28:15.711]                     save_rds(obj, file)
[08:28:15.711]                   }
[08:28:15.711]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.711]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.711]                   {
[08:28:15.711]                     inherits <- base::inherits
[08:28:15.711]                     invokeRestart <- base::invokeRestart
[08:28:15.711]                     is.null <- base::is.null
[08:28:15.711]                     muffled <- FALSE
[08:28:15.711]                     if (inherits(cond, "message")) {
[08:28:15.711]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.711]                       if (muffled) 
[08:28:15.711]                         invokeRestart("muffleMessage")
[08:28:15.711]                     }
[08:28:15.711]                     else if (inherits(cond, "warning")) {
[08:28:15.711]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.711]                       if (muffled) 
[08:28:15.711]                         invokeRestart("muffleWarning")
[08:28:15.711]                     }
[08:28:15.711]                     else if (inherits(cond, "condition")) {
[08:28:15.711]                       if (!is.null(pattern)) {
[08:28:15.711]                         computeRestarts <- base::computeRestarts
[08:28:15.711]                         grepl <- base::grepl
[08:28:15.711]                         restarts <- computeRestarts(cond)
[08:28:15.711]                         for (restart in restarts) {
[08:28:15.711]                           name <- restart$name
[08:28:15.711]                           if (is.null(name)) 
[08:28:15.711]                             next
[08:28:15.711]                           if (!grepl(pattern, name)) 
[08:28:15.711]                             next
[08:28:15.711]                           invokeRestart(restart)
[08:28:15.711]                           muffled <- TRUE
[08:28:15.711]                           break
[08:28:15.711]                         }
[08:28:15.711]                       }
[08:28:15.711]                     }
[08:28:15.711]                     invisible(muffled)
[08:28:15.711]                   }
[08:28:15.711]                   muffleCondition(cond)
[08:28:15.711]                 })
[08:28:15.711]             }))
[08:28:15.711]             future::FutureResult(value = ...future.value$value, 
[08:28:15.711]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.711]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.711]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.711]                     ...future.globalenv.names))
[08:28:15.711]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.711]         }, condition = base::local({
[08:28:15.711]             c <- base::c
[08:28:15.711]             inherits <- base::inherits
[08:28:15.711]             invokeRestart <- base::invokeRestart
[08:28:15.711]             length <- base::length
[08:28:15.711]             list <- base::list
[08:28:15.711]             seq.int <- base::seq.int
[08:28:15.711]             signalCondition <- base::signalCondition
[08:28:15.711]             sys.calls <- base::sys.calls
[08:28:15.711]             `[[` <- base::`[[`
[08:28:15.711]             `+` <- base::`+`
[08:28:15.711]             `<<-` <- base::`<<-`
[08:28:15.711]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.711]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.711]                   3L)]
[08:28:15.711]             }
[08:28:15.711]             function(cond) {
[08:28:15.711]                 is_error <- inherits(cond, "error")
[08:28:15.711]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.711]                   NULL)
[08:28:15.711]                 if (is_error) {
[08:28:15.711]                   sessionInformation <- function() {
[08:28:15.711]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.711]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.711]                       search = base::search(), system = base::Sys.info())
[08:28:15.711]                   }
[08:28:15.711]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.711]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.711]                     cond$call), session = sessionInformation(), 
[08:28:15.711]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.711]                   signalCondition(cond)
[08:28:15.711]                 }
[08:28:15.711]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.711]                 "immediateCondition"))) {
[08:28:15.711]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.711]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.711]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.711]                   if (TRUE && !signal) {
[08:28:15.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.711]                     {
[08:28:15.711]                       inherits <- base::inherits
[08:28:15.711]                       invokeRestart <- base::invokeRestart
[08:28:15.711]                       is.null <- base::is.null
[08:28:15.711]                       muffled <- FALSE
[08:28:15.711]                       if (inherits(cond, "message")) {
[08:28:15.711]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.711]                         if (muffled) 
[08:28:15.711]                           invokeRestart("muffleMessage")
[08:28:15.711]                       }
[08:28:15.711]                       else if (inherits(cond, "warning")) {
[08:28:15.711]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.711]                         if (muffled) 
[08:28:15.711]                           invokeRestart("muffleWarning")
[08:28:15.711]                       }
[08:28:15.711]                       else if (inherits(cond, "condition")) {
[08:28:15.711]                         if (!is.null(pattern)) {
[08:28:15.711]                           computeRestarts <- base::computeRestarts
[08:28:15.711]                           grepl <- base::grepl
[08:28:15.711]                           restarts <- computeRestarts(cond)
[08:28:15.711]                           for (restart in restarts) {
[08:28:15.711]                             name <- restart$name
[08:28:15.711]                             if (is.null(name)) 
[08:28:15.711]                               next
[08:28:15.711]                             if (!grepl(pattern, name)) 
[08:28:15.711]                               next
[08:28:15.711]                             invokeRestart(restart)
[08:28:15.711]                             muffled <- TRUE
[08:28:15.711]                             break
[08:28:15.711]                           }
[08:28:15.711]                         }
[08:28:15.711]                       }
[08:28:15.711]                       invisible(muffled)
[08:28:15.711]                     }
[08:28:15.711]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.711]                   }
[08:28:15.711]                 }
[08:28:15.711]                 else {
[08:28:15.711]                   if (TRUE) {
[08:28:15.711]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.711]                     {
[08:28:15.711]                       inherits <- base::inherits
[08:28:15.711]                       invokeRestart <- base::invokeRestart
[08:28:15.711]                       is.null <- base::is.null
[08:28:15.711]                       muffled <- FALSE
[08:28:15.711]                       if (inherits(cond, "message")) {
[08:28:15.711]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.711]                         if (muffled) 
[08:28:15.711]                           invokeRestart("muffleMessage")
[08:28:15.711]                       }
[08:28:15.711]                       else if (inherits(cond, "warning")) {
[08:28:15.711]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.711]                         if (muffled) 
[08:28:15.711]                           invokeRestart("muffleWarning")
[08:28:15.711]                       }
[08:28:15.711]                       else if (inherits(cond, "condition")) {
[08:28:15.711]                         if (!is.null(pattern)) {
[08:28:15.711]                           computeRestarts <- base::computeRestarts
[08:28:15.711]                           grepl <- base::grepl
[08:28:15.711]                           restarts <- computeRestarts(cond)
[08:28:15.711]                           for (restart in restarts) {
[08:28:15.711]                             name <- restart$name
[08:28:15.711]                             if (is.null(name)) 
[08:28:15.711]                               next
[08:28:15.711]                             if (!grepl(pattern, name)) 
[08:28:15.711]                               next
[08:28:15.711]                             invokeRestart(restart)
[08:28:15.711]                             muffled <- TRUE
[08:28:15.711]                             break
[08:28:15.711]                           }
[08:28:15.711]                         }
[08:28:15.711]                       }
[08:28:15.711]                       invisible(muffled)
[08:28:15.711]                     }
[08:28:15.711]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.711]                   }
[08:28:15.711]                 }
[08:28:15.711]             }
[08:28:15.711]         }))
[08:28:15.711]     }, error = function(ex) {
[08:28:15.711]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.711]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.711]                 ...future.rng), started = ...future.startTime, 
[08:28:15.711]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.711]             version = "1.8"), class = "FutureResult")
[08:28:15.711]     }, finally = {
[08:28:15.711]         if (!identical(...future.workdir, getwd())) 
[08:28:15.711]             setwd(...future.workdir)
[08:28:15.711]         {
[08:28:15.711]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.711]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.711]             }
[08:28:15.711]             base::options(...future.oldOptions)
[08:28:15.711]             if (.Platform$OS.type == "windows") {
[08:28:15.711]                 old_names <- names(...future.oldEnvVars)
[08:28:15.711]                 envs <- base::Sys.getenv()
[08:28:15.711]                 names <- names(envs)
[08:28:15.711]                 common <- intersect(names, old_names)
[08:28:15.711]                 added <- setdiff(names, old_names)
[08:28:15.711]                 removed <- setdiff(old_names, names)
[08:28:15.711]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.711]                   envs[common]]
[08:28:15.711]                 NAMES <- toupper(changed)
[08:28:15.711]                 args <- list()
[08:28:15.711]                 for (kk in seq_along(NAMES)) {
[08:28:15.711]                   name <- changed[[kk]]
[08:28:15.711]                   NAME <- NAMES[[kk]]
[08:28:15.711]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.711]                     next
[08:28:15.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.711]                 }
[08:28:15.711]                 NAMES <- toupper(added)
[08:28:15.711]                 for (kk in seq_along(NAMES)) {
[08:28:15.711]                   name <- added[[kk]]
[08:28:15.711]                   NAME <- NAMES[[kk]]
[08:28:15.711]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.711]                     next
[08:28:15.711]                   args[[name]] <- ""
[08:28:15.711]                 }
[08:28:15.711]                 NAMES <- toupper(removed)
[08:28:15.711]                 for (kk in seq_along(NAMES)) {
[08:28:15.711]                   name <- removed[[kk]]
[08:28:15.711]                   NAME <- NAMES[[kk]]
[08:28:15.711]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.711]                     next
[08:28:15.711]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.711]                 }
[08:28:15.711]                 if (length(args) > 0) 
[08:28:15.711]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.711]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.711]             }
[08:28:15.711]             else {
[08:28:15.711]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.711]             }
[08:28:15.711]             {
[08:28:15.711]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.711]                   0L) {
[08:28:15.711]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.711]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.711]                   base::options(opts)
[08:28:15.711]                 }
[08:28:15.711]                 {
[08:28:15.711]                   {
[08:28:15.711]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.711]                     NULL
[08:28:15.711]                   }
[08:28:15.711]                   options(future.plan = NULL)
[08:28:15.711]                   if (is.na(NA_character_)) 
[08:28:15.711]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.711]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.711]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.711]                     .init = FALSE)
[08:28:15.711]                 }
[08:28:15.711]             }
[08:28:15.711]         }
[08:28:15.711]     })
[08:28:15.711]     if (TRUE) {
[08:28:15.711]         base::sink(type = "output", split = FALSE)
[08:28:15.711]         if (TRUE) {
[08:28:15.711]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.711]         }
[08:28:15.711]         else {
[08:28:15.711]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.711]         }
[08:28:15.711]         base::close(...future.stdout)
[08:28:15.711]         ...future.stdout <- NULL
[08:28:15.711]     }
[08:28:15.711]     ...future.result$conditions <- ...future.conditions
[08:28:15.711]     ...future.result$finished <- base::Sys.time()
[08:28:15.711]     ...future.result
[08:28:15.711] }
[08:28:15.713] assign_globals() ...
[08:28:15.714] List of 1
[08:28:15.714]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a1099be1c0> 
[08:28:15.714]  - attr(*, "where")=List of 1
[08:28:15.714]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.714]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.714]  - attr(*, "resolved")= logi TRUE
[08:28:15.714]  - attr(*, "total_size")= num 3815
[08:28:15.714]  - attr(*, "already-done")= logi TRUE
[08:28:15.716] - copied ‘a’ to environment
[08:28:15.717] assign_globals() ... done
[08:28:15.717] requestCore(): workers = 2
[08:28:15.718] MulticoreFuture started
[08:28:15.719] - Launch lazy future ... done
[08:28:15.719] run() for ‘MulticoreFuture’ ... done
[08:28:15.719] result() for MulticoreFuture ...
[08:28:15.720] plan(): Setting new future strategy stack:
[08:28:15.720] List of future strategies:
[08:28:15.720] 1. sequential:
[08:28:15.720]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.720]    - tweaked: FALSE
[08:28:15.720]    - call: NULL
[08:28:15.721] plan(): nbrOfWorkers() = 1
[08:28:15.724] plan(): Setting new future strategy stack:
[08:28:15.724] List of future strategies:
[08:28:15.724] 1. multicore:
[08:28:15.724]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.724]    - tweaked: FALSE
[08:28:15.724]    - call: plan(strategy)
[08:28:15.728] plan(): nbrOfWorkers() = 2
[08:28:15.728] result() for MulticoreFuture ...
[08:28:15.729] result() for MulticoreFuture ... done
[08:28:15.729] signalConditions() ...
[08:28:15.729]  - include = ‘immediateCondition’
[08:28:15.729]  - exclude = 
[08:28:15.729]  - resignal = FALSE
[08:28:15.729]  - Number of conditions: 4
[08:28:15.729] signalConditions() ... done
[08:28:15.729] result() for MulticoreFuture ... done
[08:28:15.729] result() for MulticoreFuture ...
[08:28:15.730] result() for MulticoreFuture ... done
[08:28:15.730] signalConditions() ...
[08:28:15.730]  - include = ‘immediateCondition’
[08:28:15.730]  - exclude = 
[08:28:15.730]  - resignal = FALSE
[08:28:15.730]  - Number of conditions: 4
[08:28:15.730] signalConditions() ... done
[08:28:15.730] Future state: ‘finished’
[08:28:15.731] result() for MulticoreFuture ...
[08:28:15.731] result() for MulticoreFuture ... done
[08:28:15.731] signalConditions() ...
[08:28:15.731]  - include = ‘condition’
[08:28:15.731]  - exclude = ‘immediateCondition’
[08:28:15.731]  - resignal = TRUE
[08:28:15.731]  - Number of conditions: 4
[08:28:15.731]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.722] result() for MulticoreFuture ...
[08:28:15.731]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.723] result() for MulticoreFuture ... done
[08:28:15.732]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.723] result() for MulticoreFuture ...
[08:28:15.732]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.723] result() for MulticoreFuture ... done
[08:28:15.732] signalConditions() ... done
value(b) = 2
[08:28:15.732] result() for MulticoreFuture ...
[08:28:15.732] result() for MulticoreFuture ... done
[08:28:15.732] result() for MulticoreFuture ...
[08:28:15.732] result() for MulticoreFuture ... done
[08:28:15.733] signalConditions() ...
[08:28:15.733]  - include = ‘immediateCondition’
[08:28:15.733]  - exclude = 
[08:28:15.733]  - resignal = FALSE
[08:28:15.733]  - Number of conditions: 4
[08:28:15.733] signalConditions() ... done
[08:28:15.733] Future state: ‘finished’
[08:28:15.733] result() for MulticoreFuture ...
[08:28:15.733] result() for MulticoreFuture ... done
[08:28:15.734] signalConditions() ...
[08:28:15.734]  - include = ‘condition’
[08:28:15.734]  - exclude = ‘immediateCondition’
[08:28:15.734]  - resignal = TRUE
[08:28:15.734]  - Number of conditions: 4
[08:28:15.734]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.722] result() for MulticoreFuture ...
[08:28:15.734]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.723] result() for MulticoreFuture ... done
[08:28:15.734]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.723] result() for MulticoreFuture ...
[08:28:15.734]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.723] result() for MulticoreFuture ... done
[08:28:15.735] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.735] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.735] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.736] 
[08:28:15.736] Searching for globals ... DONE
[08:28:15.736] - globals: [0] <none>
[08:28:15.736] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.737] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.737] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.740] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.741] Searching for globals ... DONE
[08:28:15.741] Resolving globals: TRUE
[08:28:15.741] Resolving any globals that are futures ...
[08:28:15.741] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.741] Resolving any globals that are futures ... DONE
[08:28:15.742] Resolving futures part of globals (recursively) ...
[08:28:15.742] resolve() on list ...
[08:28:15.742]  recursive: 99
[08:28:15.742]  length: 1
[08:28:15.742]  elements: ‘a’
[08:28:15.743] run() for ‘Future’ ...
[08:28:15.743] - state: ‘created’
[08:28:15.743] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.745] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.745] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.746]   - Field: ‘label’
[08:28:15.746]   - Field: ‘local’
[08:28:15.746]   - Field: ‘owner’
[08:28:15.746]   - Field: ‘envir’
[08:28:15.746]   - Field: ‘workers’
[08:28:15.746]   - Field: ‘packages’
[08:28:15.746]   - Field: ‘gc’
[08:28:15.746]   - Field: ‘job’
[08:28:15.746]   - Field: ‘conditions’
[08:28:15.747]   - Field: ‘expr’
[08:28:15.747]   - Field: ‘uuid’
[08:28:15.747]   - Field: ‘seed’
[08:28:15.747]   - Field: ‘version’
[08:28:15.747]   - Field: ‘result’
[08:28:15.747]   - Field: ‘asynchronous’
[08:28:15.747]   - Field: ‘calls’
[08:28:15.747]   - Field: ‘globals’
[08:28:15.747]   - Field: ‘stdout’
[08:28:15.748]   - Field: ‘earlySignal’
[08:28:15.748]   - Field: ‘lazy’
[08:28:15.748]   - Field: ‘state’
[08:28:15.748] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.748] - Launch lazy future ...
[08:28:15.748] Packages needed by the future expression (n = 0): <none>
[08:28:15.748] Packages needed by future strategies (n = 0): <none>
[08:28:15.749] {
[08:28:15.749]     {
[08:28:15.749]         {
[08:28:15.749]             ...future.startTime <- base::Sys.time()
[08:28:15.749]             {
[08:28:15.749]                 {
[08:28:15.749]                   {
[08:28:15.749]                     {
[08:28:15.749]                       base::local({
[08:28:15.749]                         has_future <- base::requireNamespace("future", 
[08:28:15.749]                           quietly = TRUE)
[08:28:15.749]                         if (has_future) {
[08:28:15.749]                           ns <- base::getNamespace("future")
[08:28:15.749]                           version <- ns[[".package"]][["version"]]
[08:28:15.749]                           if (is.null(version)) 
[08:28:15.749]                             version <- utils::packageVersion("future")
[08:28:15.749]                         }
[08:28:15.749]                         else {
[08:28:15.749]                           version <- NULL
[08:28:15.749]                         }
[08:28:15.749]                         if (!has_future || version < "1.8.0") {
[08:28:15.749]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.749]                             "", base::R.version$version.string), 
[08:28:15.749]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.749]                               "release", "version")], collapse = " "), 
[08:28:15.749]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.749]                             info)
[08:28:15.749]                           info <- base::paste(info, collapse = "; ")
[08:28:15.749]                           if (!has_future) {
[08:28:15.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.749]                               info)
[08:28:15.749]                           }
[08:28:15.749]                           else {
[08:28:15.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.749]                               info, version)
[08:28:15.749]                           }
[08:28:15.749]                           base::stop(msg)
[08:28:15.749]                         }
[08:28:15.749]                       })
[08:28:15.749]                     }
[08:28:15.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.749]                     base::options(mc.cores = 1L)
[08:28:15.749]                   }
[08:28:15.749]                   ...future.strategy.old <- future::plan("list")
[08:28:15.749]                   options(future.plan = NULL)
[08:28:15.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.749]                 }
[08:28:15.749]                 ...future.workdir <- getwd()
[08:28:15.749]             }
[08:28:15.749]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.749]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.749]         }
[08:28:15.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.749]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.749]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.749]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.749]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.749]             base::names(...future.oldOptions))
[08:28:15.749]     }
[08:28:15.749]     if (FALSE) {
[08:28:15.749]     }
[08:28:15.749]     else {
[08:28:15.749]         if (TRUE) {
[08:28:15.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.749]                 open = "w")
[08:28:15.749]         }
[08:28:15.749]         else {
[08:28:15.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.749]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.749]         }
[08:28:15.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.749]             base::sink(type = "output", split = FALSE)
[08:28:15.749]             base::close(...future.stdout)
[08:28:15.749]         }, add = TRUE)
[08:28:15.749]     }
[08:28:15.749]     ...future.frame <- base::sys.nframe()
[08:28:15.749]     ...future.conditions <- base::list()
[08:28:15.749]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.749]     if (FALSE) {
[08:28:15.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.749]     }
[08:28:15.749]     ...future.result <- base::tryCatch({
[08:28:15.749]         base::withCallingHandlers({
[08:28:15.749]             ...future.value <- base::withVisible(base::local({
[08:28:15.749]                 withCallingHandlers({
[08:28:15.749]                   1
[08:28:15.749]                 }, immediateCondition = function(cond) {
[08:28:15.749]                   save_rds <- function (object, pathname, ...) 
[08:28:15.749]                   {
[08:28:15.749]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.749]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.749]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.749]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.749]                         fi_tmp[["mtime"]])
[08:28:15.749]                     }
[08:28:15.749]                     tryCatch({
[08:28:15.749]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.749]                     }, error = function(ex) {
[08:28:15.749]                       msg <- conditionMessage(ex)
[08:28:15.749]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.749]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.749]                         fi_tmp[["mtime"]], msg)
[08:28:15.749]                       ex$message <- msg
[08:28:15.749]                       stop(ex)
[08:28:15.749]                     })
[08:28:15.749]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.749]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.749]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.749]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.749]                       fi <- file.info(pathname)
[08:28:15.749]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.749]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.749]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.749]                         fi[["size"]], fi[["mtime"]])
[08:28:15.749]                       stop(msg)
[08:28:15.749]                     }
[08:28:15.749]                     invisible(pathname)
[08:28:15.749]                   }
[08:28:15.749]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.749]                     rootPath = tempdir()) 
[08:28:15.749]                   {
[08:28:15.749]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.749]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.749]                       tmpdir = path, fileext = ".rds")
[08:28:15.749]                     save_rds(obj, file)
[08:28:15.749]                   }
[08:28:15.749]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.749]                   {
[08:28:15.749]                     inherits <- base::inherits
[08:28:15.749]                     invokeRestart <- base::invokeRestart
[08:28:15.749]                     is.null <- base::is.null
[08:28:15.749]                     muffled <- FALSE
[08:28:15.749]                     if (inherits(cond, "message")) {
[08:28:15.749]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.749]                       if (muffled) 
[08:28:15.749]                         invokeRestart("muffleMessage")
[08:28:15.749]                     }
[08:28:15.749]                     else if (inherits(cond, "warning")) {
[08:28:15.749]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.749]                       if (muffled) 
[08:28:15.749]                         invokeRestart("muffleWarning")
[08:28:15.749]                     }
[08:28:15.749]                     else if (inherits(cond, "condition")) {
[08:28:15.749]                       if (!is.null(pattern)) {
[08:28:15.749]                         computeRestarts <- base::computeRestarts
[08:28:15.749]                         grepl <- base::grepl
[08:28:15.749]                         restarts <- computeRestarts(cond)
[08:28:15.749]                         for (restart in restarts) {
[08:28:15.749]                           name <- restart$name
[08:28:15.749]                           if (is.null(name)) 
[08:28:15.749]                             next
[08:28:15.749]                           if (!grepl(pattern, name)) 
[08:28:15.749]                             next
[08:28:15.749]                           invokeRestart(restart)
[08:28:15.749]                           muffled <- TRUE
[08:28:15.749]                           break
[08:28:15.749]                         }
[08:28:15.749]                       }
[08:28:15.749]                     }
[08:28:15.749]                     invisible(muffled)
[08:28:15.749]                   }
[08:28:15.749]                   muffleCondition(cond)
[08:28:15.749]                 })
[08:28:15.749]             }))
[08:28:15.749]             future::FutureResult(value = ...future.value$value, 
[08:28:15.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.749]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.749]                     ...future.globalenv.names))
[08:28:15.749]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.749]         }, condition = base::local({
[08:28:15.749]             c <- base::c
[08:28:15.749]             inherits <- base::inherits
[08:28:15.749]             invokeRestart <- base::invokeRestart
[08:28:15.749]             length <- base::length
[08:28:15.749]             list <- base::list
[08:28:15.749]             seq.int <- base::seq.int
[08:28:15.749]             signalCondition <- base::signalCondition
[08:28:15.749]             sys.calls <- base::sys.calls
[08:28:15.749]             `[[` <- base::`[[`
[08:28:15.749]             `+` <- base::`+`
[08:28:15.749]             `<<-` <- base::`<<-`
[08:28:15.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.749]                   3L)]
[08:28:15.749]             }
[08:28:15.749]             function(cond) {
[08:28:15.749]                 is_error <- inherits(cond, "error")
[08:28:15.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.749]                   NULL)
[08:28:15.749]                 if (is_error) {
[08:28:15.749]                   sessionInformation <- function() {
[08:28:15.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.749]                       search = base::search(), system = base::Sys.info())
[08:28:15.749]                   }
[08:28:15.749]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.749]                     cond$call), session = sessionInformation(), 
[08:28:15.749]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.749]                   signalCondition(cond)
[08:28:15.749]                 }
[08:28:15.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.749]                 "immediateCondition"))) {
[08:28:15.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.749]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.749]                   if (TRUE && !signal) {
[08:28:15.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.749]                     {
[08:28:15.749]                       inherits <- base::inherits
[08:28:15.749]                       invokeRestart <- base::invokeRestart
[08:28:15.749]                       is.null <- base::is.null
[08:28:15.749]                       muffled <- FALSE
[08:28:15.749]                       if (inherits(cond, "message")) {
[08:28:15.749]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.749]                         if (muffled) 
[08:28:15.749]                           invokeRestart("muffleMessage")
[08:28:15.749]                       }
[08:28:15.749]                       else if (inherits(cond, "warning")) {
[08:28:15.749]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.749]                         if (muffled) 
[08:28:15.749]                           invokeRestart("muffleWarning")
[08:28:15.749]                       }
[08:28:15.749]                       else if (inherits(cond, "condition")) {
[08:28:15.749]                         if (!is.null(pattern)) {
[08:28:15.749]                           computeRestarts <- base::computeRestarts
[08:28:15.749]                           grepl <- base::grepl
[08:28:15.749]                           restarts <- computeRestarts(cond)
[08:28:15.749]                           for (restart in restarts) {
[08:28:15.749]                             name <- restart$name
[08:28:15.749]                             if (is.null(name)) 
[08:28:15.749]                               next
[08:28:15.749]                             if (!grepl(pattern, name)) 
[08:28:15.749]                               next
[08:28:15.749]                             invokeRestart(restart)
[08:28:15.749]                             muffled <- TRUE
[08:28:15.749]                             break
[08:28:15.749]                           }
[08:28:15.749]                         }
[08:28:15.749]                       }
[08:28:15.749]                       invisible(muffled)
[08:28:15.749]                     }
[08:28:15.749]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.749]                   }
[08:28:15.749]                 }
[08:28:15.749]                 else {
[08:28:15.749]                   if (TRUE) {
[08:28:15.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.749]                     {
[08:28:15.749]                       inherits <- base::inherits
[08:28:15.749]                       invokeRestart <- base::invokeRestart
[08:28:15.749]                       is.null <- base::is.null
[08:28:15.749]                       muffled <- FALSE
[08:28:15.749]                       if (inherits(cond, "message")) {
[08:28:15.749]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.749]                         if (muffled) 
[08:28:15.749]                           invokeRestart("muffleMessage")
[08:28:15.749]                       }
[08:28:15.749]                       else if (inherits(cond, "warning")) {
[08:28:15.749]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.749]                         if (muffled) 
[08:28:15.749]                           invokeRestart("muffleWarning")
[08:28:15.749]                       }
[08:28:15.749]                       else if (inherits(cond, "condition")) {
[08:28:15.749]                         if (!is.null(pattern)) {
[08:28:15.749]                           computeRestarts <- base::computeRestarts
[08:28:15.749]                           grepl <- base::grepl
[08:28:15.749]                           restarts <- computeRestarts(cond)
[08:28:15.749]                           for (restart in restarts) {
[08:28:15.749]                             name <- restart$name
[08:28:15.749]                             if (is.null(name)) 
[08:28:15.749]                               next
[08:28:15.749]                             if (!grepl(pattern, name)) 
[08:28:15.749]                               next
[08:28:15.749]                             invokeRestart(restart)
[08:28:15.749]                             muffled <- TRUE
[08:28:15.749]                             break
[08:28:15.749]                           }
[08:28:15.749]                         }
[08:28:15.749]                       }
[08:28:15.749]                       invisible(muffled)
[08:28:15.749]                     }
[08:28:15.749]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.749]                   }
[08:28:15.749]                 }
[08:28:15.749]             }
[08:28:15.749]         }))
[08:28:15.749]     }, error = function(ex) {
[08:28:15.749]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.749]                 ...future.rng), started = ...future.startTime, 
[08:28:15.749]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.749]             version = "1.8"), class = "FutureResult")
[08:28:15.749]     }, finally = {
[08:28:15.749]         if (!identical(...future.workdir, getwd())) 
[08:28:15.749]             setwd(...future.workdir)
[08:28:15.749]         {
[08:28:15.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.749]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.749]             }
[08:28:15.749]             base::options(...future.oldOptions)
[08:28:15.749]             if (.Platform$OS.type == "windows") {
[08:28:15.749]                 old_names <- names(...future.oldEnvVars)
[08:28:15.749]                 envs <- base::Sys.getenv()
[08:28:15.749]                 names <- names(envs)
[08:28:15.749]                 common <- intersect(names, old_names)
[08:28:15.749]                 added <- setdiff(names, old_names)
[08:28:15.749]                 removed <- setdiff(old_names, names)
[08:28:15.749]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.749]                   envs[common]]
[08:28:15.749]                 NAMES <- toupper(changed)
[08:28:15.749]                 args <- list()
[08:28:15.749]                 for (kk in seq_along(NAMES)) {
[08:28:15.749]                   name <- changed[[kk]]
[08:28:15.749]                   NAME <- NAMES[[kk]]
[08:28:15.749]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.749]                     next
[08:28:15.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.749]                 }
[08:28:15.749]                 NAMES <- toupper(added)
[08:28:15.749]                 for (kk in seq_along(NAMES)) {
[08:28:15.749]                   name <- added[[kk]]
[08:28:15.749]                   NAME <- NAMES[[kk]]
[08:28:15.749]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.749]                     next
[08:28:15.749]                   args[[name]] <- ""
[08:28:15.749]                 }
[08:28:15.749]                 NAMES <- toupper(removed)
[08:28:15.749]                 for (kk in seq_along(NAMES)) {
[08:28:15.749]                   name <- removed[[kk]]
[08:28:15.749]                   NAME <- NAMES[[kk]]
[08:28:15.749]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.749]                     next
[08:28:15.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.749]                 }
[08:28:15.749]                 if (length(args) > 0) 
[08:28:15.749]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.749]             }
[08:28:15.749]             else {
[08:28:15.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.749]             }
[08:28:15.749]             {
[08:28:15.749]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.749]                   0L) {
[08:28:15.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.749]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.749]                   base::options(opts)
[08:28:15.749]                 }
[08:28:15.749]                 {
[08:28:15.749]                   {
[08:28:15.749]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.749]                     NULL
[08:28:15.749]                   }
[08:28:15.749]                   options(future.plan = NULL)
[08:28:15.749]                   if (is.na(NA_character_)) 
[08:28:15.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.749]                     .init = FALSE)
[08:28:15.749]                 }
[08:28:15.749]             }
[08:28:15.749]         }
[08:28:15.749]     })
[08:28:15.749]     if (TRUE) {
[08:28:15.749]         base::sink(type = "output", split = FALSE)
[08:28:15.749]         if (TRUE) {
[08:28:15.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.749]         }
[08:28:15.749]         else {
[08:28:15.749]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.749]         }
[08:28:15.749]         base::close(...future.stdout)
[08:28:15.749]         ...future.stdout <- NULL
[08:28:15.749]     }
[08:28:15.749]     ...future.result$conditions <- ...future.conditions
[08:28:15.749]     ...future.result$finished <- base::Sys.time()
[08:28:15.749]     ...future.result
[08:28:15.749] }
[08:28:15.751] requestCore(): workers = 2
[08:28:15.753] MulticoreFuture started
[08:28:15.754] - Launch lazy future ... done
[08:28:15.754] run() for ‘MulticoreFuture’ ... done
[08:28:15.754] plan(): Setting new future strategy stack:
[08:28:15.754] List of future strategies:
[08:28:15.754] 1. sequential:
[08:28:15.754]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.754]    - tweaked: FALSE
[08:28:15.754]    - call: NULL
[08:28:15.756] plan(): nbrOfWorkers() = 1
[08:28:15.758] plan(): Setting new future strategy stack:
[08:28:15.758] List of future strategies:
[08:28:15.758] 1. multicore:
[08:28:15.758]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.758]    - tweaked: FALSE
[08:28:15.758]    - call: plan(strategy)
[08:28:15.762] plan(): nbrOfWorkers() = 2
[08:28:15.762] Future #1
[08:28:15.763] result() for MulticoreFuture ...
[08:28:15.764] result() for MulticoreFuture ...
[08:28:15.764] result() for MulticoreFuture ... done
[08:28:15.764] result() for MulticoreFuture ... done
[08:28:15.764] result() for MulticoreFuture ...
[08:28:15.764] result() for MulticoreFuture ... done
[08:28:15.765] A MulticoreFuture was resolved
[08:28:15.765]  length: 0 (resolved future 1)
[08:28:15.765] resolve() on list ... DONE
[08:28:15.765] - globals: [1] ‘a’
[08:28:15.765] Resolving futures part of globals (recursively) ... DONE
[08:28:15.765] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[08:28:15.766] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[08:28:15.766] - globals: [1] ‘a’
[08:28:15.766] - packages: [1] ‘future’
[08:28:15.766] getGlobalsAndPackages() ... DONE
[08:28:15.767] run() for ‘Future’ ...
[08:28:15.767] - state: ‘created’
[08:28:15.767] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.769] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.769] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.770]   - Field: ‘label’
[08:28:15.770]   - Field: ‘local’
[08:28:15.770]   - Field: ‘owner’
[08:28:15.770]   - Field: ‘envir’
[08:28:15.770]   - Field: ‘workers’
[08:28:15.770]   - Field: ‘packages’
[08:28:15.770]   - Field: ‘gc’
[08:28:15.770]   - Field: ‘job’
[08:28:15.770]   - Field: ‘conditions’
[08:28:15.771]   - Field: ‘expr’
[08:28:15.771]   - Field: ‘uuid’
[08:28:15.771]   - Field: ‘seed’
[08:28:15.771]   - Field: ‘version’
[08:28:15.771]   - Field: ‘result’
[08:28:15.771]   - Field: ‘asynchronous’
[08:28:15.771]   - Field: ‘calls’
[08:28:15.771]   - Field: ‘globals’
[08:28:15.771]   - Field: ‘stdout’
[08:28:15.772]   - Field: ‘earlySignal’
[08:28:15.772]   - Field: ‘lazy’
[08:28:15.772]   - Field: ‘state’
[08:28:15.772] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.772] - Launch lazy future ...
[08:28:15.772] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.772] Packages needed by future strategies (n = 0): <none>
[08:28:15.773] {
[08:28:15.773]     {
[08:28:15.773]         {
[08:28:15.773]             ...future.startTime <- base::Sys.time()
[08:28:15.773]             {
[08:28:15.773]                 {
[08:28:15.773]                   {
[08:28:15.773]                     {
[08:28:15.773]                       {
[08:28:15.773]                         base::local({
[08:28:15.773]                           has_future <- base::requireNamespace("future", 
[08:28:15.773]                             quietly = TRUE)
[08:28:15.773]                           if (has_future) {
[08:28:15.773]                             ns <- base::getNamespace("future")
[08:28:15.773]                             version <- ns[[".package"]][["version"]]
[08:28:15.773]                             if (is.null(version)) 
[08:28:15.773]                               version <- utils::packageVersion("future")
[08:28:15.773]                           }
[08:28:15.773]                           else {
[08:28:15.773]                             version <- NULL
[08:28:15.773]                           }
[08:28:15.773]                           if (!has_future || version < "1.8.0") {
[08:28:15.773]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.773]                               "", base::R.version$version.string), 
[08:28:15.773]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.773]                                 base::R.version$platform, 8 * 
[08:28:15.773]                                   base::.Machine$sizeof.pointer), 
[08:28:15.773]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.773]                                 "release", "version")], collapse = " "), 
[08:28:15.773]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.773]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.773]                               info)
[08:28:15.773]                             info <- base::paste(info, collapse = "; ")
[08:28:15.773]                             if (!has_future) {
[08:28:15.773]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.773]                                 info)
[08:28:15.773]                             }
[08:28:15.773]                             else {
[08:28:15.773]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.773]                                 info, version)
[08:28:15.773]                             }
[08:28:15.773]                             base::stop(msg)
[08:28:15.773]                           }
[08:28:15.773]                         })
[08:28:15.773]                       }
[08:28:15.773]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.773]                       base::options(mc.cores = 1L)
[08:28:15.773]                     }
[08:28:15.773]                     base::local({
[08:28:15.773]                       for (pkg in "future") {
[08:28:15.773]                         base::loadNamespace(pkg)
[08:28:15.773]                         base::library(pkg, character.only = TRUE)
[08:28:15.773]                       }
[08:28:15.773]                     })
[08:28:15.773]                   }
[08:28:15.773]                   ...future.strategy.old <- future::plan("list")
[08:28:15.773]                   options(future.plan = NULL)
[08:28:15.773]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.773]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.773]                 }
[08:28:15.773]                 ...future.workdir <- getwd()
[08:28:15.773]             }
[08:28:15.773]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.773]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.773]         }
[08:28:15.773]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.773]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.773]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.773]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.773]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.773]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.773]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.773]             base::names(...future.oldOptions))
[08:28:15.773]     }
[08:28:15.773]     if (FALSE) {
[08:28:15.773]     }
[08:28:15.773]     else {
[08:28:15.773]         if (TRUE) {
[08:28:15.773]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.773]                 open = "w")
[08:28:15.773]         }
[08:28:15.773]         else {
[08:28:15.773]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.773]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.773]         }
[08:28:15.773]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.773]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.773]             base::sink(type = "output", split = FALSE)
[08:28:15.773]             base::close(...future.stdout)
[08:28:15.773]         }, add = TRUE)
[08:28:15.773]     }
[08:28:15.773]     ...future.frame <- base::sys.nframe()
[08:28:15.773]     ...future.conditions <- base::list()
[08:28:15.773]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.773]     if (FALSE) {
[08:28:15.773]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.773]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.773]     }
[08:28:15.773]     ...future.result <- base::tryCatch({
[08:28:15.773]         base::withCallingHandlers({
[08:28:15.773]             ...future.value <- base::withVisible(base::local({
[08:28:15.773]                 withCallingHandlers({
[08:28:15.773]                   value(a) + 1
[08:28:15.773]                 }, immediateCondition = function(cond) {
[08:28:15.773]                   save_rds <- function (object, pathname, ...) 
[08:28:15.773]                   {
[08:28:15.773]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.773]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.773]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.773]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.773]                         fi_tmp[["mtime"]])
[08:28:15.773]                     }
[08:28:15.773]                     tryCatch({
[08:28:15.773]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.773]                     }, error = function(ex) {
[08:28:15.773]                       msg <- conditionMessage(ex)
[08:28:15.773]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.773]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.773]                         fi_tmp[["mtime"]], msg)
[08:28:15.773]                       ex$message <- msg
[08:28:15.773]                       stop(ex)
[08:28:15.773]                     })
[08:28:15.773]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.773]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.773]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.773]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.773]                       fi <- file.info(pathname)
[08:28:15.773]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.773]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.773]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.773]                         fi[["size"]], fi[["mtime"]])
[08:28:15.773]                       stop(msg)
[08:28:15.773]                     }
[08:28:15.773]                     invisible(pathname)
[08:28:15.773]                   }
[08:28:15.773]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.773]                     rootPath = tempdir()) 
[08:28:15.773]                   {
[08:28:15.773]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.773]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.773]                       tmpdir = path, fileext = ".rds")
[08:28:15.773]                     save_rds(obj, file)
[08:28:15.773]                   }
[08:28:15.773]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.773]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.773]                   {
[08:28:15.773]                     inherits <- base::inherits
[08:28:15.773]                     invokeRestart <- base::invokeRestart
[08:28:15.773]                     is.null <- base::is.null
[08:28:15.773]                     muffled <- FALSE
[08:28:15.773]                     if (inherits(cond, "message")) {
[08:28:15.773]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.773]                       if (muffled) 
[08:28:15.773]                         invokeRestart("muffleMessage")
[08:28:15.773]                     }
[08:28:15.773]                     else if (inherits(cond, "warning")) {
[08:28:15.773]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.773]                       if (muffled) 
[08:28:15.773]                         invokeRestart("muffleWarning")
[08:28:15.773]                     }
[08:28:15.773]                     else if (inherits(cond, "condition")) {
[08:28:15.773]                       if (!is.null(pattern)) {
[08:28:15.773]                         computeRestarts <- base::computeRestarts
[08:28:15.773]                         grepl <- base::grepl
[08:28:15.773]                         restarts <- computeRestarts(cond)
[08:28:15.773]                         for (restart in restarts) {
[08:28:15.773]                           name <- restart$name
[08:28:15.773]                           if (is.null(name)) 
[08:28:15.773]                             next
[08:28:15.773]                           if (!grepl(pattern, name)) 
[08:28:15.773]                             next
[08:28:15.773]                           invokeRestart(restart)
[08:28:15.773]                           muffled <- TRUE
[08:28:15.773]                           break
[08:28:15.773]                         }
[08:28:15.773]                       }
[08:28:15.773]                     }
[08:28:15.773]                     invisible(muffled)
[08:28:15.773]                   }
[08:28:15.773]                   muffleCondition(cond)
[08:28:15.773]                 })
[08:28:15.773]             }))
[08:28:15.773]             future::FutureResult(value = ...future.value$value, 
[08:28:15.773]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.773]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.773]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.773]                     ...future.globalenv.names))
[08:28:15.773]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.773]         }, condition = base::local({
[08:28:15.773]             c <- base::c
[08:28:15.773]             inherits <- base::inherits
[08:28:15.773]             invokeRestart <- base::invokeRestart
[08:28:15.773]             length <- base::length
[08:28:15.773]             list <- base::list
[08:28:15.773]             seq.int <- base::seq.int
[08:28:15.773]             signalCondition <- base::signalCondition
[08:28:15.773]             sys.calls <- base::sys.calls
[08:28:15.773]             `[[` <- base::`[[`
[08:28:15.773]             `+` <- base::`+`
[08:28:15.773]             `<<-` <- base::`<<-`
[08:28:15.773]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.773]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.773]                   3L)]
[08:28:15.773]             }
[08:28:15.773]             function(cond) {
[08:28:15.773]                 is_error <- inherits(cond, "error")
[08:28:15.773]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.773]                   NULL)
[08:28:15.773]                 if (is_error) {
[08:28:15.773]                   sessionInformation <- function() {
[08:28:15.773]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.773]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.773]                       search = base::search(), system = base::Sys.info())
[08:28:15.773]                   }
[08:28:15.773]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.773]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.773]                     cond$call), session = sessionInformation(), 
[08:28:15.773]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.773]                   signalCondition(cond)
[08:28:15.773]                 }
[08:28:15.773]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.773]                 "immediateCondition"))) {
[08:28:15.773]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.773]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.773]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.773]                   if (TRUE && !signal) {
[08:28:15.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.773]                     {
[08:28:15.773]                       inherits <- base::inherits
[08:28:15.773]                       invokeRestart <- base::invokeRestart
[08:28:15.773]                       is.null <- base::is.null
[08:28:15.773]                       muffled <- FALSE
[08:28:15.773]                       if (inherits(cond, "message")) {
[08:28:15.773]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.773]                         if (muffled) 
[08:28:15.773]                           invokeRestart("muffleMessage")
[08:28:15.773]                       }
[08:28:15.773]                       else if (inherits(cond, "warning")) {
[08:28:15.773]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.773]                         if (muffled) 
[08:28:15.773]                           invokeRestart("muffleWarning")
[08:28:15.773]                       }
[08:28:15.773]                       else if (inherits(cond, "condition")) {
[08:28:15.773]                         if (!is.null(pattern)) {
[08:28:15.773]                           computeRestarts <- base::computeRestarts
[08:28:15.773]                           grepl <- base::grepl
[08:28:15.773]                           restarts <- computeRestarts(cond)
[08:28:15.773]                           for (restart in restarts) {
[08:28:15.773]                             name <- restart$name
[08:28:15.773]                             if (is.null(name)) 
[08:28:15.773]                               next
[08:28:15.773]                             if (!grepl(pattern, name)) 
[08:28:15.773]                               next
[08:28:15.773]                             invokeRestart(restart)
[08:28:15.773]                             muffled <- TRUE
[08:28:15.773]                             break
[08:28:15.773]                           }
[08:28:15.773]                         }
[08:28:15.773]                       }
[08:28:15.773]                       invisible(muffled)
[08:28:15.773]                     }
[08:28:15.773]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.773]                   }
[08:28:15.773]                 }
[08:28:15.773]                 else {
[08:28:15.773]                   if (TRUE) {
[08:28:15.773]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.773]                     {
[08:28:15.773]                       inherits <- base::inherits
[08:28:15.773]                       invokeRestart <- base::invokeRestart
[08:28:15.773]                       is.null <- base::is.null
[08:28:15.773]                       muffled <- FALSE
[08:28:15.773]                       if (inherits(cond, "message")) {
[08:28:15.773]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.773]                         if (muffled) 
[08:28:15.773]                           invokeRestart("muffleMessage")
[08:28:15.773]                       }
[08:28:15.773]                       else if (inherits(cond, "warning")) {
[08:28:15.773]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.773]                         if (muffled) 
[08:28:15.773]                           invokeRestart("muffleWarning")
[08:28:15.773]                       }
[08:28:15.773]                       else if (inherits(cond, "condition")) {
[08:28:15.773]                         if (!is.null(pattern)) {
[08:28:15.773]                           computeRestarts <- base::computeRestarts
[08:28:15.773]                           grepl <- base::grepl
[08:28:15.773]                           restarts <- computeRestarts(cond)
[08:28:15.773]                           for (restart in restarts) {
[08:28:15.773]                             name <- restart$name
[08:28:15.773]                             if (is.null(name)) 
[08:28:15.773]                               next
[08:28:15.773]                             if (!grepl(pattern, name)) 
[08:28:15.773]                               next
[08:28:15.773]                             invokeRestart(restart)
[08:28:15.773]                             muffled <- TRUE
[08:28:15.773]                             break
[08:28:15.773]                           }
[08:28:15.773]                         }
[08:28:15.773]                       }
[08:28:15.773]                       invisible(muffled)
[08:28:15.773]                     }
[08:28:15.773]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.773]                   }
[08:28:15.773]                 }
[08:28:15.773]             }
[08:28:15.773]         }))
[08:28:15.773]     }, error = function(ex) {
[08:28:15.773]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.773]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.773]                 ...future.rng), started = ...future.startTime, 
[08:28:15.773]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.773]             version = "1.8"), class = "FutureResult")
[08:28:15.773]     }, finally = {
[08:28:15.773]         if (!identical(...future.workdir, getwd())) 
[08:28:15.773]             setwd(...future.workdir)
[08:28:15.773]         {
[08:28:15.773]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.773]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.773]             }
[08:28:15.773]             base::options(...future.oldOptions)
[08:28:15.773]             if (.Platform$OS.type == "windows") {
[08:28:15.773]                 old_names <- names(...future.oldEnvVars)
[08:28:15.773]                 envs <- base::Sys.getenv()
[08:28:15.773]                 names <- names(envs)
[08:28:15.773]                 common <- intersect(names, old_names)
[08:28:15.773]                 added <- setdiff(names, old_names)
[08:28:15.773]                 removed <- setdiff(old_names, names)
[08:28:15.773]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.773]                   envs[common]]
[08:28:15.773]                 NAMES <- toupper(changed)
[08:28:15.773]                 args <- list()
[08:28:15.773]                 for (kk in seq_along(NAMES)) {
[08:28:15.773]                   name <- changed[[kk]]
[08:28:15.773]                   NAME <- NAMES[[kk]]
[08:28:15.773]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.773]                     next
[08:28:15.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.773]                 }
[08:28:15.773]                 NAMES <- toupper(added)
[08:28:15.773]                 for (kk in seq_along(NAMES)) {
[08:28:15.773]                   name <- added[[kk]]
[08:28:15.773]                   NAME <- NAMES[[kk]]
[08:28:15.773]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.773]                     next
[08:28:15.773]                   args[[name]] <- ""
[08:28:15.773]                 }
[08:28:15.773]                 NAMES <- toupper(removed)
[08:28:15.773]                 for (kk in seq_along(NAMES)) {
[08:28:15.773]                   name <- removed[[kk]]
[08:28:15.773]                   NAME <- NAMES[[kk]]
[08:28:15.773]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.773]                     next
[08:28:15.773]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.773]                 }
[08:28:15.773]                 if (length(args) > 0) 
[08:28:15.773]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.773]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.773]             }
[08:28:15.773]             else {
[08:28:15.773]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.773]             }
[08:28:15.773]             {
[08:28:15.773]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.773]                   0L) {
[08:28:15.773]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.773]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.773]                   base::options(opts)
[08:28:15.773]                 }
[08:28:15.773]                 {
[08:28:15.773]                   {
[08:28:15.773]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.773]                     NULL
[08:28:15.773]                   }
[08:28:15.773]                   options(future.plan = NULL)
[08:28:15.773]                   if (is.na(NA_character_)) 
[08:28:15.773]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.773]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.773]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.773]                     .init = FALSE)
[08:28:15.773]                 }
[08:28:15.773]             }
[08:28:15.773]         }
[08:28:15.773]     })
[08:28:15.773]     if (TRUE) {
[08:28:15.773]         base::sink(type = "output", split = FALSE)
[08:28:15.773]         if (TRUE) {
[08:28:15.773]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.773]         }
[08:28:15.773]         else {
[08:28:15.773]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.773]         }
[08:28:15.773]         base::close(...future.stdout)
[08:28:15.773]         ...future.stdout <- NULL
[08:28:15.773]     }
[08:28:15.773]     ...future.result$conditions <- ...future.conditions
[08:28:15.773]     ...future.result$finished <- base::Sys.time()
[08:28:15.773]     ...future.result
[08:28:15.773] }
[08:28:15.776] assign_globals() ...
[08:28:15.776] List of 1
[08:28:15.776]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a109cec3a0> 
[08:28:15.776]  - attr(*, "where")=List of 1
[08:28:15.776]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.776]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.776]  - attr(*, "resolved")= logi TRUE
[08:28:15.776]  - attr(*, "total_size")= num 3835
[08:28:15.776]  - attr(*, "already-done")= logi TRUE
[08:28:15.779] - copied ‘a’ to environment
[08:28:15.779] assign_globals() ... done
[08:28:15.779] requestCore(): workers = 2
[08:28:15.781] MulticoreFuture started
[08:28:15.781] - Launch lazy future ... done
[08:28:15.781] run() for ‘MulticoreFuture’ ... done
[08:28:15.782] result() for MulticoreFuture ...
[08:28:15.782] plan(): Setting new future strategy stack:
[08:28:15.782] List of future strategies:
[08:28:15.782] 1. sequential:
[08:28:15.782]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.782]    - tweaked: FALSE
[08:28:15.782]    - call: NULL
[08:28:15.783] plan(): nbrOfWorkers() = 1
[08:28:15.786] plan(): Setting new future strategy stack:
[08:28:15.787] List of future strategies:
[08:28:15.787] 1. multicore:
[08:28:15.787]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.787]    - tweaked: FALSE
[08:28:15.787]    - call: plan(strategy)
[08:28:15.790] plan(): nbrOfWorkers() = 2
[08:28:15.791] result() for MulticoreFuture ...
[08:28:15.791] result() for MulticoreFuture ... done
[08:28:15.791] signalConditions() ...
[08:28:15.791]  - include = ‘immediateCondition’
[08:28:15.791]  - exclude = 
[08:28:15.791]  - resignal = FALSE
[08:28:15.791]  - Number of conditions: 4
[08:28:15.791] signalConditions() ... done
[08:28:15.792] result() for MulticoreFuture ... done
[08:28:15.792] result() for MulticoreFuture ...
[08:28:15.792] result() for MulticoreFuture ... done
[08:28:15.792] signalConditions() ...
[08:28:15.792]  - include = ‘immediateCondition’
[08:28:15.792]  - exclude = 
[08:28:15.792]  - resignal = FALSE
[08:28:15.792]  - Number of conditions: 4
[08:28:15.792] signalConditions() ... done
[08:28:15.793] Future state: ‘finished’
[08:28:15.793] result() for MulticoreFuture ...
[08:28:15.793] result() for MulticoreFuture ... done
[08:28:15.793] signalConditions() ...
[08:28:15.793]  - include = ‘condition’
[08:28:15.793]  - exclude = ‘immediateCondition’
[08:28:15.793]  - resignal = TRUE
[08:28:15.793]  - Number of conditions: 4
[08:28:15.793]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ...
[08:28:15.794]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ... done
[08:28:15.794]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ...
[08:28:15.794]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ... done
[08:28:15.794] signalConditions() ... done
value(b) = 2
[08:28:15.794] result() for MulticoreFuture ...
[08:28:15.794] result() for MulticoreFuture ... done
[08:28:15.795] result() for MulticoreFuture ...
[08:28:15.795] result() for MulticoreFuture ... done
[08:28:15.795] signalConditions() ...
[08:28:15.795]  - include = ‘immediateCondition’
[08:28:15.795]  - exclude = 
[08:28:15.795]  - resignal = FALSE
[08:28:15.795]  - Number of conditions: 4
[08:28:15.798] signalConditions() ... done
[08:28:15.798] Future state: ‘finished’
[08:28:15.798] result() for MulticoreFuture ...
[08:28:15.799] result() for MulticoreFuture ... done
[08:28:15.799] signalConditions() ...
[08:28:15.799]  - include = ‘condition’
[08:28:15.799]  - exclude = ‘immediateCondition’
[08:28:15.799]  - resignal = TRUE
[08:28:15.799]  - Number of conditions: 4
[08:28:15.800]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ...
[08:28:15.800]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ... done
[08:28:15.800]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ...
[08:28:15.800]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.785] result() for MulticoreFuture ... done
[08:28:15.800] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.801] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.801] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.802] 
[08:28:15.802] Searching for globals ... DONE
[08:28:15.802] - globals: [0] <none>
[08:28:15.802] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.803] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.803] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.804] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:15.804] Searching for globals ... DONE
[08:28:15.804] Resolving globals: TRUE
[08:28:15.804] Resolving any globals that are futures ...
[08:28:15.804] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:15.805] Resolving any globals that are futures ... DONE
[08:28:15.805] Resolving futures part of globals (recursively) ...
[08:28:15.805] resolve() on list ...
[08:28:15.805]  recursive: 99
[08:28:15.805]  length: 1
[08:28:15.806]  elements: ‘a’
[08:28:15.806] run() for ‘Future’ ...
[08:28:15.806] - state: ‘created’
[08:28:15.806] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.808] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.808] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.808]   - Field: ‘label’
[08:28:15.808]   - Field: ‘local’
[08:28:15.808]   - Field: ‘owner’
[08:28:15.809]   - Field: ‘envir’
[08:28:15.809]   - Field: ‘workers’
[08:28:15.809]   - Field: ‘packages’
[08:28:15.809]   - Field: ‘gc’
[08:28:15.809]   - Field: ‘job’
[08:28:15.809]   - Field: ‘conditions’
[08:28:15.809]   - Field: ‘expr’
[08:28:15.809]   - Field: ‘uuid’
[08:28:15.809]   - Field: ‘seed’
[08:28:15.810]   - Field: ‘version’
[08:28:15.810]   - Field: ‘result’
[08:28:15.810]   - Field: ‘asynchronous’
[08:28:15.810]   - Field: ‘calls’
[08:28:15.810]   - Field: ‘globals’
[08:28:15.810]   - Field: ‘stdout’
[08:28:15.810]   - Field: ‘earlySignal’
[08:28:15.810]   - Field: ‘lazy’
[08:28:15.810]   - Field: ‘state’
[08:28:15.810] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.811] - Launch lazy future ...
[08:28:15.811] Packages needed by the future expression (n = 0): <none>
[08:28:15.811] Packages needed by future strategies (n = 0): <none>
[08:28:15.811] {
[08:28:15.811]     {
[08:28:15.811]         {
[08:28:15.811]             ...future.startTime <- base::Sys.time()
[08:28:15.811]             {
[08:28:15.811]                 {
[08:28:15.811]                   {
[08:28:15.811]                     {
[08:28:15.811]                       base::local({
[08:28:15.811]                         has_future <- base::requireNamespace("future", 
[08:28:15.811]                           quietly = TRUE)
[08:28:15.811]                         if (has_future) {
[08:28:15.811]                           ns <- base::getNamespace("future")
[08:28:15.811]                           version <- ns[[".package"]][["version"]]
[08:28:15.811]                           if (is.null(version)) 
[08:28:15.811]                             version <- utils::packageVersion("future")
[08:28:15.811]                         }
[08:28:15.811]                         else {
[08:28:15.811]                           version <- NULL
[08:28:15.811]                         }
[08:28:15.811]                         if (!has_future || version < "1.8.0") {
[08:28:15.811]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.811]                             "", base::R.version$version.string), 
[08:28:15.811]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.811]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.811]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.811]                               "release", "version")], collapse = " "), 
[08:28:15.811]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.811]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.811]                             info)
[08:28:15.811]                           info <- base::paste(info, collapse = "; ")
[08:28:15.811]                           if (!has_future) {
[08:28:15.811]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.811]                               info)
[08:28:15.811]                           }
[08:28:15.811]                           else {
[08:28:15.811]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.811]                               info, version)
[08:28:15.811]                           }
[08:28:15.811]                           base::stop(msg)
[08:28:15.811]                         }
[08:28:15.811]                       })
[08:28:15.811]                     }
[08:28:15.811]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.811]                     base::options(mc.cores = 1L)
[08:28:15.811]                   }
[08:28:15.811]                   ...future.strategy.old <- future::plan("list")
[08:28:15.811]                   options(future.plan = NULL)
[08:28:15.811]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.811]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.811]                 }
[08:28:15.811]                 ...future.workdir <- getwd()
[08:28:15.811]             }
[08:28:15.811]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.811]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.811]         }
[08:28:15.811]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.811]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.811]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.811]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.811]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.811]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.811]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.811]             base::names(...future.oldOptions))
[08:28:15.811]     }
[08:28:15.811]     if (FALSE) {
[08:28:15.811]     }
[08:28:15.811]     else {
[08:28:15.811]         if (TRUE) {
[08:28:15.811]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.811]                 open = "w")
[08:28:15.811]         }
[08:28:15.811]         else {
[08:28:15.811]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.811]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.811]         }
[08:28:15.811]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.811]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.811]             base::sink(type = "output", split = FALSE)
[08:28:15.811]             base::close(...future.stdout)
[08:28:15.811]         }, add = TRUE)
[08:28:15.811]     }
[08:28:15.811]     ...future.frame <- base::sys.nframe()
[08:28:15.811]     ...future.conditions <- base::list()
[08:28:15.811]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.811]     if (FALSE) {
[08:28:15.811]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.811]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.811]     }
[08:28:15.811]     ...future.result <- base::tryCatch({
[08:28:15.811]         base::withCallingHandlers({
[08:28:15.811]             ...future.value <- base::withVisible(base::local({
[08:28:15.811]                 withCallingHandlers({
[08:28:15.811]                   1
[08:28:15.811]                 }, immediateCondition = function(cond) {
[08:28:15.811]                   save_rds <- function (object, pathname, ...) 
[08:28:15.811]                   {
[08:28:15.811]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.811]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.811]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.811]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.811]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.811]                         fi_tmp[["mtime"]])
[08:28:15.811]                     }
[08:28:15.811]                     tryCatch({
[08:28:15.811]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.811]                     }, error = function(ex) {
[08:28:15.811]                       msg <- conditionMessage(ex)
[08:28:15.811]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.811]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.811]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.811]                         fi_tmp[["mtime"]], msg)
[08:28:15.811]                       ex$message <- msg
[08:28:15.811]                       stop(ex)
[08:28:15.811]                     })
[08:28:15.811]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.811]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.811]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.811]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.811]                       fi <- file.info(pathname)
[08:28:15.811]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.811]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.811]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.811]                         fi[["size"]], fi[["mtime"]])
[08:28:15.811]                       stop(msg)
[08:28:15.811]                     }
[08:28:15.811]                     invisible(pathname)
[08:28:15.811]                   }
[08:28:15.811]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.811]                     rootPath = tempdir()) 
[08:28:15.811]                   {
[08:28:15.811]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.811]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.811]                       tmpdir = path, fileext = ".rds")
[08:28:15.811]                     save_rds(obj, file)
[08:28:15.811]                   }
[08:28:15.811]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.811]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.811]                   {
[08:28:15.811]                     inherits <- base::inherits
[08:28:15.811]                     invokeRestart <- base::invokeRestart
[08:28:15.811]                     is.null <- base::is.null
[08:28:15.811]                     muffled <- FALSE
[08:28:15.811]                     if (inherits(cond, "message")) {
[08:28:15.811]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.811]                       if (muffled) 
[08:28:15.811]                         invokeRestart("muffleMessage")
[08:28:15.811]                     }
[08:28:15.811]                     else if (inherits(cond, "warning")) {
[08:28:15.811]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.811]                       if (muffled) 
[08:28:15.811]                         invokeRestart("muffleWarning")
[08:28:15.811]                     }
[08:28:15.811]                     else if (inherits(cond, "condition")) {
[08:28:15.811]                       if (!is.null(pattern)) {
[08:28:15.811]                         computeRestarts <- base::computeRestarts
[08:28:15.811]                         grepl <- base::grepl
[08:28:15.811]                         restarts <- computeRestarts(cond)
[08:28:15.811]                         for (restart in restarts) {
[08:28:15.811]                           name <- restart$name
[08:28:15.811]                           if (is.null(name)) 
[08:28:15.811]                             next
[08:28:15.811]                           if (!grepl(pattern, name)) 
[08:28:15.811]                             next
[08:28:15.811]                           invokeRestart(restart)
[08:28:15.811]                           muffled <- TRUE
[08:28:15.811]                           break
[08:28:15.811]                         }
[08:28:15.811]                       }
[08:28:15.811]                     }
[08:28:15.811]                     invisible(muffled)
[08:28:15.811]                   }
[08:28:15.811]                   muffleCondition(cond)
[08:28:15.811]                 })
[08:28:15.811]             }))
[08:28:15.811]             future::FutureResult(value = ...future.value$value, 
[08:28:15.811]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.811]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.811]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.811]                     ...future.globalenv.names))
[08:28:15.811]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.811]         }, condition = base::local({
[08:28:15.811]             c <- base::c
[08:28:15.811]             inherits <- base::inherits
[08:28:15.811]             invokeRestart <- base::invokeRestart
[08:28:15.811]             length <- base::length
[08:28:15.811]             list <- base::list
[08:28:15.811]             seq.int <- base::seq.int
[08:28:15.811]             signalCondition <- base::signalCondition
[08:28:15.811]             sys.calls <- base::sys.calls
[08:28:15.811]             `[[` <- base::`[[`
[08:28:15.811]             `+` <- base::`+`
[08:28:15.811]             `<<-` <- base::`<<-`
[08:28:15.811]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.811]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.811]                   3L)]
[08:28:15.811]             }
[08:28:15.811]             function(cond) {
[08:28:15.811]                 is_error <- inherits(cond, "error")
[08:28:15.811]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.811]                   NULL)
[08:28:15.811]                 if (is_error) {
[08:28:15.811]                   sessionInformation <- function() {
[08:28:15.811]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.811]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.811]                       search = base::search(), system = base::Sys.info())
[08:28:15.811]                   }
[08:28:15.811]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.811]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.811]                     cond$call), session = sessionInformation(), 
[08:28:15.811]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.811]                   signalCondition(cond)
[08:28:15.811]                 }
[08:28:15.811]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.811]                 "immediateCondition"))) {
[08:28:15.811]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.811]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.811]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.811]                   if (TRUE && !signal) {
[08:28:15.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.811]                     {
[08:28:15.811]                       inherits <- base::inherits
[08:28:15.811]                       invokeRestart <- base::invokeRestart
[08:28:15.811]                       is.null <- base::is.null
[08:28:15.811]                       muffled <- FALSE
[08:28:15.811]                       if (inherits(cond, "message")) {
[08:28:15.811]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.811]                         if (muffled) 
[08:28:15.811]                           invokeRestart("muffleMessage")
[08:28:15.811]                       }
[08:28:15.811]                       else if (inherits(cond, "warning")) {
[08:28:15.811]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.811]                         if (muffled) 
[08:28:15.811]                           invokeRestart("muffleWarning")
[08:28:15.811]                       }
[08:28:15.811]                       else if (inherits(cond, "condition")) {
[08:28:15.811]                         if (!is.null(pattern)) {
[08:28:15.811]                           computeRestarts <- base::computeRestarts
[08:28:15.811]                           grepl <- base::grepl
[08:28:15.811]                           restarts <- computeRestarts(cond)
[08:28:15.811]                           for (restart in restarts) {
[08:28:15.811]                             name <- restart$name
[08:28:15.811]                             if (is.null(name)) 
[08:28:15.811]                               next
[08:28:15.811]                             if (!grepl(pattern, name)) 
[08:28:15.811]                               next
[08:28:15.811]                             invokeRestart(restart)
[08:28:15.811]                             muffled <- TRUE
[08:28:15.811]                             break
[08:28:15.811]                           }
[08:28:15.811]                         }
[08:28:15.811]                       }
[08:28:15.811]                       invisible(muffled)
[08:28:15.811]                     }
[08:28:15.811]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.811]                   }
[08:28:15.811]                 }
[08:28:15.811]                 else {
[08:28:15.811]                   if (TRUE) {
[08:28:15.811]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.811]                     {
[08:28:15.811]                       inherits <- base::inherits
[08:28:15.811]                       invokeRestart <- base::invokeRestart
[08:28:15.811]                       is.null <- base::is.null
[08:28:15.811]                       muffled <- FALSE
[08:28:15.811]                       if (inherits(cond, "message")) {
[08:28:15.811]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.811]                         if (muffled) 
[08:28:15.811]                           invokeRestart("muffleMessage")
[08:28:15.811]                       }
[08:28:15.811]                       else if (inherits(cond, "warning")) {
[08:28:15.811]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.811]                         if (muffled) 
[08:28:15.811]                           invokeRestart("muffleWarning")
[08:28:15.811]                       }
[08:28:15.811]                       else if (inherits(cond, "condition")) {
[08:28:15.811]                         if (!is.null(pattern)) {
[08:28:15.811]                           computeRestarts <- base::computeRestarts
[08:28:15.811]                           grepl <- base::grepl
[08:28:15.811]                           restarts <- computeRestarts(cond)
[08:28:15.811]                           for (restart in restarts) {
[08:28:15.811]                             name <- restart$name
[08:28:15.811]                             if (is.null(name)) 
[08:28:15.811]                               next
[08:28:15.811]                             if (!grepl(pattern, name)) 
[08:28:15.811]                               next
[08:28:15.811]                             invokeRestart(restart)
[08:28:15.811]                             muffled <- TRUE
[08:28:15.811]                             break
[08:28:15.811]                           }
[08:28:15.811]                         }
[08:28:15.811]                       }
[08:28:15.811]                       invisible(muffled)
[08:28:15.811]                     }
[08:28:15.811]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.811]                   }
[08:28:15.811]                 }
[08:28:15.811]             }
[08:28:15.811]         }))
[08:28:15.811]     }, error = function(ex) {
[08:28:15.811]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.811]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.811]                 ...future.rng), started = ...future.startTime, 
[08:28:15.811]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.811]             version = "1.8"), class = "FutureResult")
[08:28:15.811]     }, finally = {
[08:28:15.811]         if (!identical(...future.workdir, getwd())) 
[08:28:15.811]             setwd(...future.workdir)
[08:28:15.811]         {
[08:28:15.811]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.811]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.811]             }
[08:28:15.811]             base::options(...future.oldOptions)
[08:28:15.811]             if (.Platform$OS.type == "windows") {
[08:28:15.811]                 old_names <- names(...future.oldEnvVars)
[08:28:15.811]                 envs <- base::Sys.getenv()
[08:28:15.811]                 names <- names(envs)
[08:28:15.811]                 common <- intersect(names, old_names)
[08:28:15.811]                 added <- setdiff(names, old_names)
[08:28:15.811]                 removed <- setdiff(old_names, names)
[08:28:15.811]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.811]                   envs[common]]
[08:28:15.811]                 NAMES <- toupper(changed)
[08:28:15.811]                 args <- list()
[08:28:15.811]                 for (kk in seq_along(NAMES)) {
[08:28:15.811]                   name <- changed[[kk]]
[08:28:15.811]                   NAME <- NAMES[[kk]]
[08:28:15.811]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.811]                     next
[08:28:15.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.811]                 }
[08:28:15.811]                 NAMES <- toupper(added)
[08:28:15.811]                 for (kk in seq_along(NAMES)) {
[08:28:15.811]                   name <- added[[kk]]
[08:28:15.811]                   NAME <- NAMES[[kk]]
[08:28:15.811]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.811]                     next
[08:28:15.811]                   args[[name]] <- ""
[08:28:15.811]                 }
[08:28:15.811]                 NAMES <- toupper(removed)
[08:28:15.811]                 for (kk in seq_along(NAMES)) {
[08:28:15.811]                   name <- removed[[kk]]
[08:28:15.811]                   NAME <- NAMES[[kk]]
[08:28:15.811]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.811]                     next
[08:28:15.811]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.811]                 }
[08:28:15.811]                 if (length(args) > 0) 
[08:28:15.811]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.811]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.811]             }
[08:28:15.811]             else {
[08:28:15.811]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.811]             }
[08:28:15.811]             {
[08:28:15.811]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.811]                   0L) {
[08:28:15.811]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.811]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.811]                   base::options(opts)
[08:28:15.811]                 }
[08:28:15.811]                 {
[08:28:15.811]                   {
[08:28:15.811]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.811]                     NULL
[08:28:15.811]                   }
[08:28:15.811]                   options(future.plan = NULL)
[08:28:15.811]                   if (is.na(NA_character_)) 
[08:28:15.811]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.811]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.811]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.811]                     .init = FALSE)
[08:28:15.811]                 }
[08:28:15.811]             }
[08:28:15.811]         }
[08:28:15.811]     })
[08:28:15.811]     if (TRUE) {
[08:28:15.811]         base::sink(type = "output", split = FALSE)
[08:28:15.811]         if (TRUE) {
[08:28:15.811]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.811]         }
[08:28:15.811]         else {
[08:28:15.811]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.811]         }
[08:28:15.811]         base::close(...future.stdout)
[08:28:15.811]         ...future.stdout <- NULL
[08:28:15.811]     }
[08:28:15.811]     ...future.result$conditions <- ...future.conditions
[08:28:15.811]     ...future.result$finished <- base::Sys.time()
[08:28:15.811]     ...future.result
[08:28:15.811] }
[08:28:15.814] requestCore(): workers = 2
[08:28:15.815] MulticoreFuture started
[08:28:15.816] - Launch lazy future ... done
[08:28:15.816] run() for ‘MulticoreFuture’ ... done
[08:28:15.816] plan(): Setting new future strategy stack:
[08:28:15.816] List of future strategies:
[08:28:15.816] 1. sequential:
[08:28:15.816]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.816]    - tweaked: FALSE
[08:28:15.816]    - call: NULL
[08:28:15.818] plan(): nbrOfWorkers() = 1
[08:28:15.820] plan(): Setting new future strategy stack:
[08:28:15.820] List of future strategies:
[08:28:15.820] 1. multicore:
[08:28:15.820]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.820]    - tweaked: FALSE
[08:28:15.820]    - call: plan(strategy)
[08:28:15.823] plan(): nbrOfWorkers() = 2
[08:28:15.824] Future #1
[08:28:15.824] result() for MulticoreFuture ...
[08:28:15.825] result() for MulticoreFuture ...
[08:28:15.825] result() for MulticoreFuture ... done
[08:28:15.825] result() for MulticoreFuture ... done
[08:28:15.825] result() for MulticoreFuture ...
[08:28:15.825] result() for MulticoreFuture ... done
[08:28:15.826] A MulticoreFuture was resolved
[08:28:15.826]  length: 0 (resolved future 1)
[08:28:15.826] resolve() on list ... DONE
[08:28:15.826] - globals: [1] ‘a’
[08:28:15.826] Resolving futures part of globals (recursively) ... DONE
[08:28:15.826] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[08:28:15.827] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[08:28:15.827] - globals: [1] ‘a’
[08:28:15.827] - packages: [1] ‘future’
[08:28:15.827] getGlobalsAndPackages() ... DONE
[08:28:15.828] run() for ‘Future’ ...
[08:28:15.828] - state: ‘created’
[08:28:15.828] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.830]   - Field: ‘label’
[08:28:15.831]   - Field: ‘local’
[08:28:15.831]   - Field: ‘owner’
[08:28:15.831]   - Field: ‘envir’
[08:28:15.831]   - Field: ‘workers’
[08:28:15.831]   - Field: ‘packages’
[08:28:15.831]   - Field: ‘gc’
[08:28:15.831]   - Field: ‘job’
[08:28:15.831]   - Field: ‘conditions’
[08:28:15.831]   - Field: ‘expr’
[08:28:15.832]   - Field: ‘uuid’
[08:28:15.832]   - Field: ‘seed’
[08:28:15.832]   - Field: ‘version’
[08:28:15.832]   - Field: ‘result’
[08:28:15.832]   - Field: ‘asynchronous’
[08:28:15.832]   - Field: ‘calls’
[08:28:15.832]   - Field: ‘globals’
[08:28:15.832]   - Field: ‘stdout’
[08:28:15.832]   - Field: ‘earlySignal’
[08:28:15.833]   - Field: ‘lazy’
[08:28:15.833]   - Field: ‘state’
[08:28:15.833] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.833] - Launch lazy future ...
[08:28:15.833] Packages needed by the future expression (n = 1): ‘future’
[08:28:15.833] Packages needed by future strategies (n = 0): <none>
[08:28:15.834] {
[08:28:15.834]     {
[08:28:15.834]         {
[08:28:15.834]             ...future.startTime <- base::Sys.time()
[08:28:15.834]             {
[08:28:15.834]                 {
[08:28:15.834]                   {
[08:28:15.834]                     {
[08:28:15.834]                       {
[08:28:15.834]                         base::local({
[08:28:15.834]                           has_future <- base::requireNamespace("future", 
[08:28:15.834]                             quietly = TRUE)
[08:28:15.834]                           if (has_future) {
[08:28:15.834]                             ns <- base::getNamespace("future")
[08:28:15.834]                             version <- ns[[".package"]][["version"]]
[08:28:15.834]                             if (is.null(version)) 
[08:28:15.834]                               version <- utils::packageVersion("future")
[08:28:15.834]                           }
[08:28:15.834]                           else {
[08:28:15.834]                             version <- NULL
[08:28:15.834]                           }
[08:28:15.834]                           if (!has_future || version < "1.8.0") {
[08:28:15.834]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.834]                               "", base::R.version$version.string), 
[08:28:15.834]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:15.834]                                 base::R.version$platform, 8 * 
[08:28:15.834]                                   base::.Machine$sizeof.pointer), 
[08:28:15.834]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.834]                                 "release", "version")], collapse = " "), 
[08:28:15.834]                               hostname = base::Sys.info()[["nodename"]])
[08:28:15.834]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.834]                               info)
[08:28:15.834]                             info <- base::paste(info, collapse = "; ")
[08:28:15.834]                             if (!has_future) {
[08:28:15.834]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.834]                                 info)
[08:28:15.834]                             }
[08:28:15.834]                             else {
[08:28:15.834]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.834]                                 info, version)
[08:28:15.834]                             }
[08:28:15.834]                             base::stop(msg)
[08:28:15.834]                           }
[08:28:15.834]                         })
[08:28:15.834]                       }
[08:28:15.834]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.834]                       base::options(mc.cores = 1L)
[08:28:15.834]                     }
[08:28:15.834]                     base::local({
[08:28:15.834]                       for (pkg in "future") {
[08:28:15.834]                         base::loadNamespace(pkg)
[08:28:15.834]                         base::library(pkg, character.only = TRUE)
[08:28:15.834]                       }
[08:28:15.834]                     })
[08:28:15.834]                   }
[08:28:15.834]                   ...future.strategy.old <- future::plan("list")
[08:28:15.834]                   options(future.plan = NULL)
[08:28:15.834]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.834]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.834]                 }
[08:28:15.834]                 ...future.workdir <- getwd()
[08:28:15.834]             }
[08:28:15.834]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.834]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.834]         }
[08:28:15.834]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.834]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.834]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.834]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.834]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.834]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.834]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.834]             base::names(...future.oldOptions))
[08:28:15.834]     }
[08:28:15.834]     if (FALSE) {
[08:28:15.834]     }
[08:28:15.834]     else {
[08:28:15.834]         if (TRUE) {
[08:28:15.834]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.834]                 open = "w")
[08:28:15.834]         }
[08:28:15.834]         else {
[08:28:15.834]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.834]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.834]         }
[08:28:15.834]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.834]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.834]             base::sink(type = "output", split = FALSE)
[08:28:15.834]             base::close(...future.stdout)
[08:28:15.834]         }, add = TRUE)
[08:28:15.834]     }
[08:28:15.834]     ...future.frame <- base::sys.nframe()
[08:28:15.834]     ...future.conditions <- base::list()
[08:28:15.834]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.834]     if (FALSE) {
[08:28:15.834]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.834]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.834]     }
[08:28:15.834]     ...future.result <- base::tryCatch({
[08:28:15.834]         base::withCallingHandlers({
[08:28:15.834]             ...future.value <- base::withVisible(base::local({
[08:28:15.834]                 withCallingHandlers({
[08:28:15.834]                   value(a) + 1
[08:28:15.834]                 }, immediateCondition = function(cond) {
[08:28:15.834]                   save_rds <- function (object, pathname, ...) 
[08:28:15.834]                   {
[08:28:15.834]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.834]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.834]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.834]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.834]                         fi_tmp[["mtime"]])
[08:28:15.834]                     }
[08:28:15.834]                     tryCatch({
[08:28:15.834]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.834]                     }, error = function(ex) {
[08:28:15.834]                       msg <- conditionMessage(ex)
[08:28:15.834]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.834]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.834]                         fi_tmp[["mtime"]], msg)
[08:28:15.834]                       ex$message <- msg
[08:28:15.834]                       stop(ex)
[08:28:15.834]                     })
[08:28:15.834]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.834]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.834]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.834]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.834]                       fi <- file.info(pathname)
[08:28:15.834]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.834]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.834]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.834]                         fi[["size"]], fi[["mtime"]])
[08:28:15.834]                       stop(msg)
[08:28:15.834]                     }
[08:28:15.834]                     invisible(pathname)
[08:28:15.834]                   }
[08:28:15.834]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.834]                     rootPath = tempdir()) 
[08:28:15.834]                   {
[08:28:15.834]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.834]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.834]                       tmpdir = path, fileext = ".rds")
[08:28:15.834]                     save_rds(obj, file)
[08:28:15.834]                   }
[08:28:15.834]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.834]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.834]                   {
[08:28:15.834]                     inherits <- base::inherits
[08:28:15.834]                     invokeRestart <- base::invokeRestart
[08:28:15.834]                     is.null <- base::is.null
[08:28:15.834]                     muffled <- FALSE
[08:28:15.834]                     if (inherits(cond, "message")) {
[08:28:15.834]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.834]                       if (muffled) 
[08:28:15.834]                         invokeRestart("muffleMessage")
[08:28:15.834]                     }
[08:28:15.834]                     else if (inherits(cond, "warning")) {
[08:28:15.834]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.834]                       if (muffled) 
[08:28:15.834]                         invokeRestart("muffleWarning")
[08:28:15.834]                     }
[08:28:15.834]                     else if (inherits(cond, "condition")) {
[08:28:15.834]                       if (!is.null(pattern)) {
[08:28:15.834]                         computeRestarts <- base::computeRestarts
[08:28:15.834]                         grepl <- base::grepl
[08:28:15.834]                         restarts <- computeRestarts(cond)
[08:28:15.834]                         for (restart in restarts) {
[08:28:15.834]                           name <- restart$name
[08:28:15.834]                           if (is.null(name)) 
[08:28:15.834]                             next
[08:28:15.834]                           if (!grepl(pattern, name)) 
[08:28:15.834]                             next
[08:28:15.834]                           invokeRestart(restart)
[08:28:15.834]                           muffled <- TRUE
[08:28:15.834]                           break
[08:28:15.834]                         }
[08:28:15.834]                       }
[08:28:15.834]                     }
[08:28:15.834]                     invisible(muffled)
[08:28:15.834]                   }
[08:28:15.834]                   muffleCondition(cond)
[08:28:15.834]                 })
[08:28:15.834]             }))
[08:28:15.834]             future::FutureResult(value = ...future.value$value, 
[08:28:15.834]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.834]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.834]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.834]                     ...future.globalenv.names))
[08:28:15.834]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.834]         }, condition = base::local({
[08:28:15.834]             c <- base::c
[08:28:15.834]             inherits <- base::inherits
[08:28:15.834]             invokeRestart <- base::invokeRestart
[08:28:15.834]             length <- base::length
[08:28:15.834]             list <- base::list
[08:28:15.834]             seq.int <- base::seq.int
[08:28:15.834]             signalCondition <- base::signalCondition
[08:28:15.834]             sys.calls <- base::sys.calls
[08:28:15.834]             `[[` <- base::`[[`
[08:28:15.834]             `+` <- base::`+`
[08:28:15.834]             `<<-` <- base::`<<-`
[08:28:15.834]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.834]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.834]                   3L)]
[08:28:15.834]             }
[08:28:15.834]             function(cond) {
[08:28:15.834]                 is_error <- inherits(cond, "error")
[08:28:15.834]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.834]                   NULL)
[08:28:15.834]                 if (is_error) {
[08:28:15.834]                   sessionInformation <- function() {
[08:28:15.834]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.834]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.834]                       search = base::search(), system = base::Sys.info())
[08:28:15.834]                   }
[08:28:15.834]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.834]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.834]                     cond$call), session = sessionInformation(), 
[08:28:15.834]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.834]                   signalCondition(cond)
[08:28:15.834]                 }
[08:28:15.834]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.834]                 "immediateCondition"))) {
[08:28:15.834]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.834]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.834]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.834]                   if (TRUE && !signal) {
[08:28:15.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.834]                     {
[08:28:15.834]                       inherits <- base::inherits
[08:28:15.834]                       invokeRestart <- base::invokeRestart
[08:28:15.834]                       is.null <- base::is.null
[08:28:15.834]                       muffled <- FALSE
[08:28:15.834]                       if (inherits(cond, "message")) {
[08:28:15.834]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.834]                         if (muffled) 
[08:28:15.834]                           invokeRestart("muffleMessage")
[08:28:15.834]                       }
[08:28:15.834]                       else if (inherits(cond, "warning")) {
[08:28:15.834]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.834]                         if (muffled) 
[08:28:15.834]                           invokeRestart("muffleWarning")
[08:28:15.834]                       }
[08:28:15.834]                       else if (inherits(cond, "condition")) {
[08:28:15.834]                         if (!is.null(pattern)) {
[08:28:15.834]                           computeRestarts <- base::computeRestarts
[08:28:15.834]                           grepl <- base::grepl
[08:28:15.834]                           restarts <- computeRestarts(cond)
[08:28:15.834]                           for (restart in restarts) {
[08:28:15.834]                             name <- restart$name
[08:28:15.834]                             if (is.null(name)) 
[08:28:15.834]                               next
[08:28:15.834]                             if (!grepl(pattern, name)) 
[08:28:15.834]                               next
[08:28:15.834]                             invokeRestart(restart)
[08:28:15.834]                             muffled <- TRUE
[08:28:15.834]                             break
[08:28:15.834]                           }
[08:28:15.834]                         }
[08:28:15.834]                       }
[08:28:15.834]                       invisible(muffled)
[08:28:15.834]                     }
[08:28:15.834]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.834]                   }
[08:28:15.834]                 }
[08:28:15.834]                 else {
[08:28:15.834]                   if (TRUE) {
[08:28:15.834]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.834]                     {
[08:28:15.834]                       inherits <- base::inherits
[08:28:15.834]                       invokeRestart <- base::invokeRestart
[08:28:15.834]                       is.null <- base::is.null
[08:28:15.834]                       muffled <- FALSE
[08:28:15.834]                       if (inherits(cond, "message")) {
[08:28:15.834]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.834]                         if (muffled) 
[08:28:15.834]                           invokeRestart("muffleMessage")
[08:28:15.834]                       }
[08:28:15.834]                       else if (inherits(cond, "warning")) {
[08:28:15.834]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.834]                         if (muffled) 
[08:28:15.834]                           invokeRestart("muffleWarning")
[08:28:15.834]                       }
[08:28:15.834]                       else if (inherits(cond, "condition")) {
[08:28:15.834]                         if (!is.null(pattern)) {
[08:28:15.834]                           computeRestarts <- base::computeRestarts
[08:28:15.834]                           grepl <- base::grepl
[08:28:15.834]                           restarts <- computeRestarts(cond)
[08:28:15.834]                           for (restart in restarts) {
[08:28:15.834]                             name <- restart$name
[08:28:15.834]                             if (is.null(name)) 
[08:28:15.834]                               next
[08:28:15.834]                             if (!grepl(pattern, name)) 
[08:28:15.834]                               next
[08:28:15.834]                             invokeRestart(restart)
[08:28:15.834]                             muffled <- TRUE
[08:28:15.834]                             break
[08:28:15.834]                           }
[08:28:15.834]                         }
[08:28:15.834]                       }
[08:28:15.834]                       invisible(muffled)
[08:28:15.834]                     }
[08:28:15.834]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.834]                   }
[08:28:15.834]                 }
[08:28:15.834]             }
[08:28:15.834]         }))
[08:28:15.834]     }, error = function(ex) {
[08:28:15.834]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.834]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.834]                 ...future.rng), started = ...future.startTime, 
[08:28:15.834]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.834]             version = "1.8"), class = "FutureResult")
[08:28:15.834]     }, finally = {
[08:28:15.834]         if (!identical(...future.workdir, getwd())) 
[08:28:15.834]             setwd(...future.workdir)
[08:28:15.834]         {
[08:28:15.834]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.834]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.834]             }
[08:28:15.834]             base::options(...future.oldOptions)
[08:28:15.834]             if (.Platform$OS.type == "windows") {
[08:28:15.834]                 old_names <- names(...future.oldEnvVars)
[08:28:15.834]                 envs <- base::Sys.getenv()
[08:28:15.834]                 names <- names(envs)
[08:28:15.834]                 common <- intersect(names, old_names)
[08:28:15.834]                 added <- setdiff(names, old_names)
[08:28:15.834]                 removed <- setdiff(old_names, names)
[08:28:15.834]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.834]                   envs[common]]
[08:28:15.834]                 NAMES <- toupper(changed)
[08:28:15.834]                 args <- list()
[08:28:15.834]                 for (kk in seq_along(NAMES)) {
[08:28:15.834]                   name <- changed[[kk]]
[08:28:15.834]                   NAME <- NAMES[[kk]]
[08:28:15.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.834]                     next
[08:28:15.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.834]                 }
[08:28:15.834]                 NAMES <- toupper(added)
[08:28:15.834]                 for (kk in seq_along(NAMES)) {
[08:28:15.834]                   name <- added[[kk]]
[08:28:15.834]                   NAME <- NAMES[[kk]]
[08:28:15.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.834]                     next
[08:28:15.834]                   args[[name]] <- ""
[08:28:15.834]                 }
[08:28:15.834]                 NAMES <- toupper(removed)
[08:28:15.834]                 for (kk in seq_along(NAMES)) {
[08:28:15.834]                   name <- removed[[kk]]
[08:28:15.834]                   NAME <- NAMES[[kk]]
[08:28:15.834]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.834]                     next
[08:28:15.834]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.834]                 }
[08:28:15.834]                 if (length(args) > 0) 
[08:28:15.834]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.834]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.834]             }
[08:28:15.834]             else {
[08:28:15.834]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.834]             }
[08:28:15.834]             {
[08:28:15.834]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.834]                   0L) {
[08:28:15.834]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.834]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.834]                   base::options(opts)
[08:28:15.834]                 }
[08:28:15.834]                 {
[08:28:15.834]                   {
[08:28:15.834]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.834]                     NULL
[08:28:15.834]                   }
[08:28:15.834]                   options(future.plan = NULL)
[08:28:15.834]                   if (is.na(NA_character_)) 
[08:28:15.834]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.834]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.834]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.834]                     .init = FALSE)
[08:28:15.834]                 }
[08:28:15.834]             }
[08:28:15.834]         }
[08:28:15.834]     })
[08:28:15.834]     if (TRUE) {
[08:28:15.834]         base::sink(type = "output", split = FALSE)
[08:28:15.834]         if (TRUE) {
[08:28:15.834]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.834]         }
[08:28:15.834]         else {
[08:28:15.834]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.834]         }
[08:28:15.834]         base::close(...future.stdout)
[08:28:15.834]         ...future.stdout <- NULL
[08:28:15.834]     }
[08:28:15.834]     ...future.result$conditions <- ...future.conditions
[08:28:15.834]     ...future.result$finished <- base::Sys.time()
[08:28:15.834]     ...future.result
[08:28:15.834] }
[08:28:15.837] assign_globals() ...
[08:28:15.837] List of 1
[08:28:15.837]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55a109ba4398> 
[08:28:15.837]  - attr(*, "where")=List of 1
[08:28:15.837]   ..$ a:<environment: R_EmptyEnv> 
[08:28:15.837]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.837]  - attr(*, "resolved")= logi TRUE
[08:28:15.837]  - attr(*, "total_size")= num 3835
[08:28:15.837]  - attr(*, "already-done")= logi TRUE
[08:28:15.840] - copied ‘a’ to environment
[08:28:15.840] assign_globals() ... done
[08:28:15.840] requestCore(): workers = 2
[08:28:15.842] MulticoreFuture started
[08:28:15.842] - Launch lazy future ... done
[08:28:15.842] run() for ‘MulticoreFuture’ ... done
[08:28:15.843] result() for MulticoreFuture ...
[08:28:15.843] plan(): Setting new future strategy stack:
[08:28:15.843] List of future strategies:
[08:28:15.843] 1. sequential:
[08:28:15.843]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.843]    - tweaked: FALSE
[08:28:15.843]    - call: NULL
[08:28:15.849] plan(): nbrOfWorkers() = 1
[08:28:15.853] plan(): Setting new future strategy stack:
[08:28:15.854] List of future strategies:
[08:28:15.854] 1. multicore:
[08:28:15.854]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.854]    - tweaked: FALSE
[08:28:15.854]    - call: plan(strategy)
[08:28:15.857] plan(): nbrOfWorkers() = 2
[08:28:15.858] result() for MulticoreFuture ...
[08:28:15.858] result() for MulticoreFuture ... done
[08:28:15.861] signalConditions() ...
[08:28:15.861]  - include = ‘immediateCondition’
[08:28:15.862]  - exclude = 
[08:28:15.862]  - resignal = FALSE
[08:28:15.862]  - Number of conditions: 4
[08:28:15.862] signalConditions() ... done
[08:28:15.862] result() for MulticoreFuture ... done
[08:28:15.863] result() for MulticoreFuture ...
[08:28:15.863] result() for MulticoreFuture ... done
[08:28:15.863] signalConditions() ...
[08:28:15.863]  - include = ‘immediateCondition’
[08:28:15.863]  - exclude = 
[08:28:15.863]  - resignal = FALSE
[08:28:15.863]  - Number of conditions: 4
[08:28:15.864] signalConditions() ... done
[08:28:15.864] Future state: ‘finished’
[08:28:15.864] result() for MulticoreFuture ...
[08:28:15.864] result() for MulticoreFuture ... done
[08:28:15.864] signalConditions() ...
[08:28:15.865]  - include = ‘condition’
[08:28:15.865]  - exclude = ‘immediateCondition’
[08:28:15.865]  - resignal = TRUE
[08:28:15.865]  - Number of conditions: 4
[08:28:15.865]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.851] result() for MulticoreFuture ...
[08:28:15.865]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.851] result() for MulticoreFuture ... done
[08:28:15.866]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.852] result() for MulticoreFuture ...
[08:28:15.866]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.852] result() for MulticoreFuture ... done
[08:28:15.866] signalConditions() ... done
value(b) = 2
[08:28:15.866] result() for MulticoreFuture ...
[08:28:15.866] result() for MulticoreFuture ... done
[08:28:15.866] result() for MulticoreFuture ...
[08:28:15.867] result() for MulticoreFuture ... done
[08:28:15.867] signalConditions() ...
[08:28:15.867]  - include = ‘immediateCondition’
[08:28:15.867]  - exclude = 
[08:28:15.867]  - resignal = FALSE
[08:28:15.867]  - Number of conditions: 4
[08:28:15.867] signalConditions() ... done
[08:28:15.867] Future state: ‘finished’
[08:28:15.867] result() for MulticoreFuture ...
[08:28:15.868] result() for MulticoreFuture ... done
[08:28:15.868] signalConditions() ...
[08:28:15.868]  - include = ‘condition’
[08:28:15.868]  - exclude = ‘immediateCondition’
[08:28:15.868]  - resignal = TRUE
[08:28:15.868]  - Number of conditions: 4
[08:28:15.868]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.851] result() for MulticoreFuture ...
[08:28:15.868]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.851] result() for MulticoreFuture ... done
[08:28:15.869]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.852] result() for MulticoreFuture ...
[08:28:15.869]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[08:28:15.852] result() for MulticoreFuture ... done
[08:28:15.869] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.869] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.870] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.871] - globals found: [2] ‘{’, ‘pkg’
[08:28:15.871] Searching for globals ... DONE
[08:28:15.871] Resolving globals: TRUE
[08:28:15.871] Resolving any globals that are futures ...
[08:28:15.871] - globals: [2] ‘{’, ‘pkg’
[08:28:15.871] Resolving any globals that are futures ... DONE
[08:28:15.872] Resolving futures part of globals (recursively) ...
[08:28:15.872] resolve() on list ...
[08:28:15.872]  recursive: 99
[08:28:15.872]  length: 1
[08:28:15.872]  elements: ‘pkg’
[08:28:15.872]  length: 0 (resolved future 1)
[08:28:15.873] resolve() on list ... DONE
[08:28:15.873] - globals: [1] ‘pkg’
[08:28:15.873] Resolving futures part of globals (recursively) ... DONE
[08:28:15.873] The total size of the 1 globals is 42 bytes (42 bytes)
[08:28:15.873] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[08:28:15.873] - globals: [1] ‘pkg’
[08:28:15.874] 
[08:28:15.874] getGlobalsAndPackages() ... DONE
[08:28:15.874] Packages needed by the future expression (n = 0): <none>
[08:28:15.874] Packages needed by future strategies (n = 0): <none>
[08:28:15.875] {
[08:28:15.875]     {
[08:28:15.875]         {
[08:28:15.875]             ...future.startTime <- base::Sys.time()
[08:28:15.875]             {
[08:28:15.875]                 {
[08:28:15.875]                   {
[08:28:15.875]                     base::local({
[08:28:15.875]                       has_future <- base::requireNamespace("future", 
[08:28:15.875]                         quietly = TRUE)
[08:28:15.875]                       if (has_future) {
[08:28:15.875]                         ns <- base::getNamespace("future")
[08:28:15.875]                         version <- ns[[".package"]][["version"]]
[08:28:15.875]                         if (is.null(version)) 
[08:28:15.875]                           version <- utils::packageVersion("future")
[08:28:15.875]                       }
[08:28:15.875]                       else {
[08:28:15.875]                         version <- NULL
[08:28:15.875]                       }
[08:28:15.875]                       if (!has_future || version < "1.8.0") {
[08:28:15.875]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.875]                           "", base::R.version$version.string), 
[08:28:15.875]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:15.875]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.875]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.875]                             "release", "version")], collapse = " "), 
[08:28:15.875]                           hostname = base::Sys.info()[["nodename"]])
[08:28:15.875]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.875]                           info)
[08:28:15.875]                         info <- base::paste(info, collapse = "; ")
[08:28:15.875]                         if (!has_future) {
[08:28:15.875]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.875]                             info)
[08:28:15.875]                         }
[08:28:15.875]                         else {
[08:28:15.875]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.875]                             info, version)
[08:28:15.875]                         }
[08:28:15.875]                         base::stop(msg)
[08:28:15.875]                       }
[08:28:15.875]                     })
[08:28:15.875]                   }
[08:28:15.875]                   ...future.strategy.old <- future::plan("list")
[08:28:15.875]                   options(future.plan = NULL)
[08:28:15.875]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.875]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.875]                 }
[08:28:15.875]                 ...future.workdir <- getwd()
[08:28:15.875]             }
[08:28:15.875]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.875]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.875]         }
[08:28:15.875]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.875]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.875]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.875]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.875]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.875]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.875]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.875]             base::names(...future.oldOptions))
[08:28:15.875]     }
[08:28:15.875]     if (FALSE) {
[08:28:15.875]     }
[08:28:15.875]     else {
[08:28:15.875]         if (TRUE) {
[08:28:15.875]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.875]                 open = "w")
[08:28:15.875]         }
[08:28:15.875]         else {
[08:28:15.875]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.875]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.875]         }
[08:28:15.875]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.875]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.875]             base::sink(type = "output", split = FALSE)
[08:28:15.875]             base::close(...future.stdout)
[08:28:15.875]         }, add = TRUE)
[08:28:15.875]     }
[08:28:15.875]     ...future.frame <- base::sys.nframe()
[08:28:15.875]     ...future.conditions <- base::list()
[08:28:15.875]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.875]     if (FALSE) {
[08:28:15.875]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.875]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.875]     }
[08:28:15.875]     ...future.result <- base::tryCatch({
[08:28:15.875]         base::withCallingHandlers({
[08:28:15.875]             ...future.value <- base::withVisible(base::local({
[08:28:15.875]                 pkg
[08:28:15.875]             }))
[08:28:15.875]             future::FutureResult(value = ...future.value$value, 
[08:28:15.875]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.875]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.875]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.875]                     ...future.globalenv.names))
[08:28:15.875]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.875]         }, condition = base::local({
[08:28:15.875]             c <- base::c
[08:28:15.875]             inherits <- base::inherits
[08:28:15.875]             invokeRestart <- base::invokeRestart
[08:28:15.875]             length <- base::length
[08:28:15.875]             list <- base::list
[08:28:15.875]             seq.int <- base::seq.int
[08:28:15.875]             signalCondition <- base::signalCondition
[08:28:15.875]             sys.calls <- base::sys.calls
[08:28:15.875]             `[[` <- base::`[[`
[08:28:15.875]             `+` <- base::`+`
[08:28:15.875]             `<<-` <- base::`<<-`
[08:28:15.875]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.875]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.875]                   3L)]
[08:28:15.875]             }
[08:28:15.875]             function(cond) {
[08:28:15.875]                 is_error <- inherits(cond, "error")
[08:28:15.875]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.875]                   NULL)
[08:28:15.875]                 if (is_error) {
[08:28:15.875]                   sessionInformation <- function() {
[08:28:15.875]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.875]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.875]                       search = base::search(), system = base::Sys.info())
[08:28:15.875]                   }
[08:28:15.875]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.875]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.875]                     cond$call), session = sessionInformation(), 
[08:28:15.875]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.875]                   signalCondition(cond)
[08:28:15.875]                 }
[08:28:15.875]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.875]                 "immediateCondition"))) {
[08:28:15.875]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.875]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.875]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.875]                   if (TRUE && !signal) {
[08:28:15.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.875]                     {
[08:28:15.875]                       inherits <- base::inherits
[08:28:15.875]                       invokeRestart <- base::invokeRestart
[08:28:15.875]                       is.null <- base::is.null
[08:28:15.875]                       muffled <- FALSE
[08:28:15.875]                       if (inherits(cond, "message")) {
[08:28:15.875]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.875]                         if (muffled) 
[08:28:15.875]                           invokeRestart("muffleMessage")
[08:28:15.875]                       }
[08:28:15.875]                       else if (inherits(cond, "warning")) {
[08:28:15.875]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.875]                         if (muffled) 
[08:28:15.875]                           invokeRestart("muffleWarning")
[08:28:15.875]                       }
[08:28:15.875]                       else if (inherits(cond, "condition")) {
[08:28:15.875]                         if (!is.null(pattern)) {
[08:28:15.875]                           computeRestarts <- base::computeRestarts
[08:28:15.875]                           grepl <- base::grepl
[08:28:15.875]                           restarts <- computeRestarts(cond)
[08:28:15.875]                           for (restart in restarts) {
[08:28:15.875]                             name <- restart$name
[08:28:15.875]                             if (is.null(name)) 
[08:28:15.875]                               next
[08:28:15.875]                             if (!grepl(pattern, name)) 
[08:28:15.875]                               next
[08:28:15.875]                             invokeRestart(restart)
[08:28:15.875]                             muffled <- TRUE
[08:28:15.875]                             break
[08:28:15.875]                           }
[08:28:15.875]                         }
[08:28:15.875]                       }
[08:28:15.875]                       invisible(muffled)
[08:28:15.875]                     }
[08:28:15.875]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.875]                   }
[08:28:15.875]                 }
[08:28:15.875]                 else {
[08:28:15.875]                   if (TRUE) {
[08:28:15.875]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.875]                     {
[08:28:15.875]                       inherits <- base::inherits
[08:28:15.875]                       invokeRestart <- base::invokeRestart
[08:28:15.875]                       is.null <- base::is.null
[08:28:15.875]                       muffled <- FALSE
[08:28:15.875]                       if (inherits(cond, "message")) {
[08:28:15.875]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.875]                         if (muffled) 
[08:28:15.875]                           invokeRestart("muffleMessage")
[08:28:15.875]                       }
[08:28:15.875]                       else if (inherits(cond, "warning")) {
[08:28:15.875]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.875]                         if (muffled) 
[08:28:15.875]                           invokeRestart("muffleWarning")
[08:28:15.875]                       }
[08:28:15.875]                       else if (inherits(cond, "condition")) {
[08:28:15.875]                         if (!is.null(pattern)) {
[08:28:15.875]                           computeRestarts <- base::computeRestarts
[08:28:15.875]                           grepl <- base::grepl
[08:28:15.875]                           restarts <- computeRestarts(cond)
[08:28:15.875]                           for (restart in restarts) {
[08:28:15.875]                             name <- restart$name
[08:28:15.875]                             if (is.null(name)) 
[08:28:15.875]                               next
[08:28:15.875]                             if (!grepl(pattern, name)) 
[08:28:15.875]                               next
[08:28:15.875]                             invokeRestart(restart)
[08:28:15.875]                             muffled <- TRUE
[08:28:15.875]                             break
[08:28:15.875]                           }
[08:28:15.875]                         }
[08:28:15.875]                       }
[08:28:15.875]                       invisible(muffled)
[08:28:15.875]                     }
[08:28:15.875]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.875]                   }
[08:28:15.875]                 }
[08:28:15.875]             }
[08:28:15.875]         }))
[08:28:15.875]     }, error = function(ex) {
[08:28:15.875]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.875]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.875]                 ...future.rng), started = ...future.startTime, 
[08:28:15.875]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.875]             version = "1.8"), class = "FutureResult")
[08:28:15.875]     }, finally = {
[08:28:15.875]         if (!identical(...future.workdir, getwd())) 
[08:28:15.875]             setwd(...future.workdir)
[08:28:15.875]         {
[08:28:15.875]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.875]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.875]             }
[08:28:15.875]             base::options(...future.oldOptions)
[08:28:15.875]             if (.Platform$OS.type == "windows") {
[08:28:15.875]                 old_names <- names(...future.oldEnvVars)
[08:28:15.875]                 envs <- base::Sys.getenv()
[08:28:15.875]                 names <- names(envs)
[08:28:15.875]                 common <- intersect(names, old_names)
[08:28:15.875]                 added <- setdiff(names, old_names)
[08:28:15.875]                 removed <- setdiff(old_names, names)
[08:28:15.875]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.875]                   envs[common]]
[08:28:15.875]                 NAMES <- toupper(changed)
[08:28:15.875]                 args <- list()
[08:28:15.875]                 for (kk in seq_along(NAMES)) {
[08:28:15.875]                   name <- changed[[kk]]
[08:28:15.875]                   NAME <- NAMES[[kk]]
[08:28:15.875]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.875]                     next
[08:28:15.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.875]                 }
[08:28:15.875]                 NAMES <- toupper(added)
[08:28:15.875]                 for (kk in seq_along(NAMES)) {
[08:28:15.875]                   name <- added[[kk]]
[08:28:15.875]                   NAME <- NAMES[[kk]]
[08:28:15.875]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.875]                     next
[08:28:15.875]                   args[[name]] <- ""
[08:28:15.875]                 }
[08:28:15.875]                 NAMES <- toupper(removed)
[08:28:15.875]                 for (kk in seq_along(NAMES)) {
[08:28:15.875]                   name <- removed[[kk]]
[08:28:15.875]                   NAME <- NAMES[[kk]]
[08:28:15.875]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.875]                     next
[08:28:15.875]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.875]                 }
[08:28:15.875]                 if (length(args) > 0) 
[08:28:15.875]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.875]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.875]             }
[08:28:15.875]             else {
[08:28:15.875]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.875]             }
[08:28:15.875]             {
[08:28:15.875]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.875]                   0L) {
[08:28:15.875]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.875]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.875]                   base::options(opts)
[08:28:15.875]                 }
[08:28:15.875]                 {
[08:28:15.875]                   {
[08:28:15.875]                     NULL
[08:28:15.875]                     RNGkind("Mersenne-Twister")
[08:28:15.875]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:15.875]                       inherits = FALSE)
[08:28:15.875]                   }
[08:28:15.875]                   options(future.plan = NULL)
[08:28:15.875]                   if (is.na(NA_character_)) 
[08:28:15.875]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.875]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.875]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.875]                     .init = FALSE)
[08:28:15.875]                 }
[08:28:15.875]             }
[08:28:15.875]         }
[08:28:15.875]     })
[08:28:15.875]     if (TRUE) {
[08:28:15.875]         base::sink(type = "output", split = FALSE)
[08:28:15.875]         if (TRUE) {
[08:28:15.875]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.875]         }
[08:28:15.875]         else {
[08:28:15.875]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.875]         }
[08:28:15.875]         base::close(...future.stdout)
[08:28:15.875]         ...future.stdout <- NULL
[08:28:15.875]     }
[08:28:15.875]     ...future.result$conditions <- ...future.conditions
[08:28:15.875]     ...future.result$finished <- base::Sys.time()
[08:28:15.875]     ...future.result
[08:28:15.875] }
[08:28:15.876] assign_globals() ...
[08:28:15.877] List of 1
[08:28:15.877]  $ pkg: chr "foo"
[08:28:15.877]  - attr(*, "where")=List of 1
[08:28:15.877]   ..$ pkg:<environment: R_EmptyEnv> 
[08:28:15.877]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.877]  - attr(*, "resolved")= logi TRUE
[08:28:15.877]  - attr(*, "total_size")= num 42
[08:28:15.879] - copied ‘pkg’ to environment
[08:28:15.879] assign_globals() ... done
[08:28:15.879] plan(): Setting new future strategy stack:
[08:28:15.879] List of future strategies:
[08:28:15.879] 1. sequential:
[08:28:15.879]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.879]    - tweaked: FALSE
[08:28:15.879]    - call: NULL
[08:28:15.880] plan(): nbrOfWorkers() = 1
[08:28:15.881] plan(): Setting new future strategy stack:
[08:28:15.881] List of future strategies:
[08:28:15.881] 1. multicore:
[08:28:15.881]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.881]    - tweaked: FALSE
[08:28:15.881]    - call: plan(strategy)
[08:28:15.883] plan(): nbrOfWorkers() = 2
[08:28:15.883] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.883] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.883] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.885] - globals found: [3] ‘{’, ‘<-’, ‘+’
[08:28:15.885] Searching for globals ... DONE
[08:28:15.885] Resolving globals: TRUE
[08:28:15.886] Resolving any globals that are futures ...
[08:28:15.886] - globals: [3] ‘{’, ‘<-’, ‘+’
[08:28:15.886] Resolving any globals that are futures ... DONE
[08:28:15.886] 
[08:28:15.886] 
[08:28:15.886] getGlobalsAndPackages() ... DONE
[08:28:15.886] run() for ‘Future’ ...
[08:28:15.887] - state: ‘created’
[08:28:15.887] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.888] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.888] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.889]   - Field: ‘label’
[08:28:15.889]   - Field: ‘local’
[08:28:15.889]   - Field: ‘owner’
[08:28:15.889]   - Field: ‘envir’
[08:28:15.889]   - Field: ‘workers’
[08:28:15.889]   - Field: ‘packages’
[08:28:15.889]   - Field: ‘gc’
[08:28:15.889]   - Field: ‘job’
[08:28:15.889]   - Field: ‘conditions’
[08:28:15.889]   - Field: ‘expr’
[08:28:15.889]   - Field: ‘uuid’
[08:28:15.891]   - Field: ‘seed’
[08:28:15.891]   - Field: ‘version’
[08:28:15.891]   - Field: ‘result’
[08:28:15.891]   - Field: ‘asynchronous’
[08:28:15.891]   - Field: ‘calls’
[08:28:15.892]   - Field: ‘globals’
[08:28:15.892]   - Field: ‘stdout’
[08:28:15.892]   - Field: ‘earlySignal’
[08:28:15.892]   - Field: ‘lazy’
[08:28:15.892]   - Field: ‘state’
[08:28:15.892] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.892] - Launch lazy future ...
[08:28:15.892] Packages needed by the future expression (n = 0): <none>
[08:28:15.893] Packages needed by future strategies (n = 0): <none>
[08:28:15.893] {
[08:28:15.893]     {
[08:28:15.893]         {
[08:28:15.893]             ...future.startTime <- base::Sys.time()
[08:28:15.893]             {
[08:28:15.893]                 {
[08:28:15.893]                   {
[08:28:15.893]                     {
[08:28:15.893]                       base::local({
[08:28:15.893]                         has_future <- base::requireNamespace("future", 
[08:28:15.893]                           quietly = TRUE)
[08:28:15.893]                         if (has_future) {
[08:28:15.893]                           ns <- base::getNamespace("future")
[08:28:15.893]                           version <- ns[[".package"]][["version"]]
[08:28:15.893]                           if (is.null(version)) 
[08:28:15.893]                             version <- utils::packageVersion("future")
[08:28:15.893]                         }
[08:28:15.893]                         else {
[08:28:15.893]                           version <- NULL
[08:28:15.893]                         }
[08:28:15.893]                         if (!has_future || version < "1.8.0") {
[08:28:15.893]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.893]                             "", base::R.version$version.string), 
[08:28:15.893]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.893]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.893]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.893]                               "release", "version")], collapse = " "), 
[08:28:15.893]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.893]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.893]                             info)
[08:28:15.893]                           info <- base::paste(info, collapse = "; ")
[08:28:15.893]                           if (!has_future) {
[08:28:15.893]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.893]                               info)
[08:28:15.893]                           }
[08:28:15.893]                           else {
[08:28:15.893]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.893]                               info, version)
[08:28:15.893]                           }
[08:28:15.893]                           base::stop(msg)
[08:28:15.893]                         }
[08:28:15.893]                       })
[08:28:15.893]                     }
[08:28:15.893]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.893]                     base::options(mc.cores = 1L)
[08:28:15.893]                   }
[08:28:15.893]                   ...future.strategy.old <- future::plan("list")
[08:28:15.893]                   options(future.plan = NULL)
[08:28:15.893]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.893]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.893]                 }
[08:28:15.893]                 ...future.workdir <- getwd()
[08:28:15.893]             }
[08:28:15.893]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.893]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.893]         }
[08:28:15.893]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.893]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.893]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.893]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.893]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.893]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.893]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.893]             base::names(...future.oldOptions))
[08:28:15.893]     }
[08:28:15.893]     if (FALSE) {
[08:28:15.893]     }
[08:28:15.893]     else {
[08:28:15.893]         if (TRUE) {
[08:28:15.893]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.893]                 open = "w")
[08:28:15.893]         }
[08:28:15.893]         else {
[08:28:15.893]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.893]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.893]         }
[08:28:15.893]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.893]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.893]             base::sink(type = "output", split = FALSE)
[08:28:15.893]             base::close(...future.stdout)
[08:28:15.893]         }, add = TRUE)
[08:28:15.893]     }
[08:28:15.893]     ...future.frame <- base::sys.nframe()
[08:28:15.893]     ...future.conditions <- base::list()
[08:28:15.893]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.893]     if (FALSE) {
[08:28:15.893]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.893]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.893]     }
[08:28:15.893]     ...future.result <- base::tryCatch({
[08:28:15.893]         base::withCallingHandlers({
[08:28:15.893]             ...future.value <- base::withVisible(base::local({
[08:28:15.893]                 withCallingHandlers({
[08:28:15.893]                   {
[08:28:15.893]                     x <- 0
[08:28:15.893]                     x <- x + 1
[08:28:15.893]                     x
[08:28:15.893]                   }
[08:28:15.893]                 }, immediateCondition = function(cond) {
[08:28:15.893]                   save_rds <- function (object, pathname, ...) 
[08:28:15.893]                   {
[08:28:15.893]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.893]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.893]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.893]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.893]                         fi_tmp[["mtime"]])
[08:28:15.893]                     }
[08:28:15.893]                     tryCatch({
[08:28:15.893]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.893]                     }, error = function(ex) {
[08:28:15.893]                       msg <- conditionMessage(ex)
[08:28:15.893]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.893]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.893]                         fi_tmp[["mtime"]], msg)
[08:28:15.893]                       ex$message <- msg
[08:28:15.893]                       stop(ex)
[08:28:15.893]                     })
[08:28:15.893]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.893]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.893]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.893]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.893]                       fi <- file.info(pathname)
[08:28:15.893]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.893]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.893]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.893]                         fi[["size"]], fi[["mtime"]])
[08:28:15.893]                       stop(msg)
[08:28:15.893]                     }
[08:28:15.893]                     invisible(pathname)
[08:28:15.893]                   }
[08:28:15.893]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.893]                     rootPath = tempdir()) 
[08:28:15.893]                   {
[08:28:15.893]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.893]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.893]                       tmpdir = path, fileext = ".rds")
[08:28:15.893]                     save_rds(obj, file)
[08:28:15.893]                   }
[08:28:15.893]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.893]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.893]                   {
[08:28:15.893]                     inherits <- base::inherits
[08:28:15.893]                     invokeRestart <- base::invokeRestart
[08:28:15.893]                     is.null <- base::is.null
[08:28:15.893]                     muffled <- FALSE
[08:28:15.893]                     if (inherits(cond, "message")) {
[08:28:15.893]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.893]                       if (muffled) 
[08:28:15.893]                         invokeRestart("muffleMessage")
[08:28:15.893]                     }
[08:28:15.893]                     else if (inherits(cond, "warning")) {
[08:28:15.893]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.893]                       if (muffled) 
[08:28:15.893]                         invokeRestart("muffleWarning")
[08:28:15.893]                     }
[08:28:15.893]                     else if (inherits(cond, "condition")) {
[08:28:15.893]                       if (!is.null(pattern)) {
[08:28:15.893]                         computeRestarts <- base::computeRestarts
[08:28:15.893]                         grepl <- base::grepl
[08:28:15.893]                         restarts <- computeRestarts(cond)
[08:28:15.893]                         for (restart in restarts) {
[08:28:15.893]                           name <- restart$name
[08:28:15.893]                           if (is.null(name)) 
[08:28:15.893]                             next
[08:28:15.893]                           if (!grepl(pattern, name)) 
[08:28:15.893]                             next
[08:28:15.893]                           invokeRestart(restart)
[08:28:15.893]                           muffled <- TRUE
[08:28:15.893]                           break
[08:28:15.893]                         }
[08:28:15.893]                       }
[08:28:15.893]                     }
[08:28:15.893]                     invisible(muffled)
[08:28:15.893]                   }
[08:28:15.893]                   muffleCondition(cond)
[08:28:15.893]                 })
[08:28:15.893]             }))
[08:28:15.893]             future::FutureResult(value = ...future.value$value, 
[08:28:15.893]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.893]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.893]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.893]                     ...future.globalenv.names))
[08:28:15.893]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.893]         }, condition = base::local({
[08:28:15.893]             c <- base::c
[08:28:15.893]             inherits <- base::inherits
[08:28:15.893]             invokeRestart <- base::invokeRestart
[08:28:15.893]             length <- base::length
[08:28:15.893]             list <- base::list
[08:28:15.893]             seq.int <- base::seq.int
[08:28:15.893]             signalCondition <- base::signalCondition
[08:28:15.893]             sys.calls <- base::sys.calls
[08:28:15.893]             `[[` <- base::`[[`
[08:28:15.893]             `+` <- base::`+`
[08:28:15.893]             `<<-` <- base::`<<-`
[08:28:15.893]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.893]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.893]                   3L)]
[08:28:15.893]             }
[08:28:15.893]             function(cond) {
[08:28:15.893]                 is_error <- inherits(cond, "error")
[08:28:15.893]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.893]                   NULL)
[08:28:15.893]                 if (is_error) {
[08:28:15.893]                   sessionInformation <- function() {
[08:28:15.893]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.893]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.893]                       search = base::search(), system = base::Sys.info())
[08:28:15.893]                   }
[08:28:15.893]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.893]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.893]                     cond$call), session = sessionInformation(), 
[08:28:15.893]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.893]                   signalCondition(cond)
[08:28:15.893]                 }
[08:28:15.893]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.893]                 "immediateCondition"))) {
[08:28:15.893]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.893]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.893]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.893]                   if (TRUE && !signal) {
[08:28:15.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.893]                     {
[08:28:15.893]                       inherits <- base::inherits
[08:28:15.893]                       invokeRestart <- base::invokeRestart
[08:28:15.893]                       is.null <- base::is.null
[08:28:15.893]                       muffled <- FALSE
[08:28:15.893]                       if (inherits(cond, "message")) {
[08:28:15.893]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.893]                         if (muffled) 
[08:28:15.893]                           invokeRestart("muffleMessage")
[08:28:15.893]                       }
[08:28:15.893]                       else if (inherits(cond, "warning")) {
[08:28:15.893]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.893]                         if (muffled) 
[08:28:15.893]                           invokeRestart("muffleWarning")
[08:28:15.893]                       }
[08:28:15.893]                       else if (inherits(cond, "condition")) {
[08:28:15.893]                         if (!is.null(pattern)) {
[08:28:15.893]                           computeRestarts <- base::computeRestarts
[08:28:15.893]                           grepl <- base::grepl
[08:28:15.893]                           restarts <- computeRestarts(cond)
[08:28:15.893]                           for (restart in restarts) {
[08:28:15.893]                             name <- restart$name
[08:28:15.893]                             if (is.null(name)) 
[08:28:15.893]                               next
[08:28:15.893]                             if (!grepl(pattern, name)) 
[08:28:15.893]                               next
[08:28:15.893]                             invokeRestart(restart)
[08:28:15.893]                             muffled <- TRUE
[08:28:15.893]                             break
[08:28:15.893]                           }
[08:28:15.893]                         }
[08:28:15.893]                       }
[08:28:15.893]                       invisible(muffled)
[08:28:15.893]                     }
[08:28:15.893]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.893]                   }
[08:28:15.893]                 }
[08:28:15.893]                 else {
[08:28:15.893]                   if (TRUE) {
[08:28:15.893]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.893]                     {
[08:28:15.893]                       inherits <- base::inherits
[08:28:15.893]                       invokeRestart <- base::invokeRestart
[08:28:15.893]                       is.null <- base::is.null
[08:28:15.893]                       muffled <- FALSE
[08:28:15.893]                       if (inherits(cond, "message")) {
[08:28:15.893]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.893]                         if (muffled) 
[08:28:15.893]                           invokeRestart("muffleMessage")
[08:28:15.893]                       }
[08:28:15.893]                       else if (inherits(cond, "warning")) {
[08:28:15.893]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.893]                         if (muffled) 
[08:28:15.893]                           invokeRestart("muffleWarning")
[08:28:15.893]                       }
[08:28:15.893]                       else if (inherits(cond, "condition")) {
[08:28:15.893]                         if (!is.null(pattern)) {
[08:28:15.893]                           computeRestarts <- base::computeRestarts
[08:28:15.893]                           grepl <- base::grepl
[08:28:15.893]                           restarts <- computeRestarts(cond)
[08:28:15.893]                           for (restart in restarts) {
[08:28:15.893]                             name <- restart$name
[08:28:15.893]                             if (is.null(name)) 
[08:28:15.893]                               next
[08:28:15.893]                             if (!grepl(pattern, name)) 
[08:28:15.893]                               next
[08:28:15.893]                             invokeRestart(restart)
[08:28:15.893]                             muffled <- TRUE
[08:28:15.893]                             break
[08:28:15.893]                           }
[08:28:15.893]                         }
[08:28:15.893]                       }
[08:28:15.893]                       invisible(muffled)
[08:28:15.893]                     }
[08:28:15.893]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.893]                   }
[08:28:15.893]                 }
[08:28:15.893]             }
[08:28:15.893]         }))
[08:28:15.893]     }, error = function(ex) {
[08:28:15.893]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.893]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.893]                 ...future.rng), started = ...future.startTime, 
[08:28:15.893]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.893]             version = "1.8"), class = "FutureResult")
[08:28:15.893]     }, finally = {
[08:28:15.893]         if (!identical(...future.workdir, getwd())) 
[08:28:15.893]             setwd(...future.workdir)
[08:28:15.893]         {
[08:28:15.893]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.893]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.893]             }
[08:28:15.893]             base::options(...future.oldOptions)
[08:28:15.893]             if (.Platform$OS.type == "windows") {
[08:28:15.893]                 old_names <- names(...future.oldEnvVars)
[08:28:15.893]                 envs <- base::Sys.getenv()
[08:28:15.893]                 names <- names(envs)
[08:28:15.893]                 common <- intersect(names, old_names)
[08:28:15.893]                 added <- setdiff(names, old_names)
[08:28:15.893]                 removed <- setdiff(old_names, names)
[08:28:15.893]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.893]                   envs[common]]
[08:28:15.893]                 NAMES <- toupper(changed)
[08:28:15.893]                 args <- list()
[08:28:15.893]                 for (kk in seq_along(NAMES)) {
[08:28:15.893]                   name <- changed[[kk]]
[08:28:15.893]                   NAME <- NAMES[[kk]]
[08:28:15.893]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.893]                     next
[08:28:15.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.893]                 }
[08:28:15.893]                 NAMES <- toupper(added)
[08:28:15.893]                 for (kk in seq_along(NAMES)) {
[08:28:15.893]                   name <- added[[kk]]
[08:28:15.893]                   NAME <- NAMES[[kk]]
[08:28:15.893]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.893]                     next
[08:28:15.893]                   args[[name]] <- ""
[08:28:15.893]                 }
[08:28:15.893]                 NAMES <- toupper(removed)
[08:28:15.893]                 for (kk in seq_along(NAMES)) {
[08:28:15.893]                   name <- removed[[kk]]
[08:28:15.893]                   NAME <- NAMES[[kk]]
[08:28:15.893]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.893]                     next
[08:28:15.893]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.893]                 }
[08:28:15.893]                 if (length(args) > 0) 
[08:28:15.893]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.893]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.893]             }
[08:28:15.893]             else {
[08:28:15.893]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.893]             }
[08:28:15.893]             {
[08:28:15.893]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.893]                   0L) {
[08:28:15.893]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.893]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.893]                   base::options(opts)
[08:28:15.893]                 }
[08:28:15.893]                 {
[08:28:15.893]                   {
[08:28:15.893]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.893]                     NULL
[08:28:15.893]                   }
[08:28:15.893]                   options(future.plan = NULL)
[08:28:15.893]                   if (is.na(NA_character_)) 
[08:28:15.893]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.893]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.893]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.893]                     .init = FALSE)
[08:28:15.893]                 }
[08:28:15.893]             }
[08:28:15.893]         }
[08:28:15.893]     })
[08:28:15.893]     if (TRUE) {
[08:28:15.893]         base::sink(type = "output", split = FALSE)
[08:28:15.893]         if (TRUE) {
[08:28:15.893]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.893]         }
[08:28:15.893]         else {
[08:28:15.893]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.893]         }
[08:28:15.893]         base::close(...future.stdout)
[08:28:15.893]         ...future.stdout <- NULL
[08:28:15.893]     }
[08:28:15.893]     ...future.result$conditions <- ...future.conditions
[08:28:15.893]     ...future.result$finished <- base::Sys.time()
[08:28:15.893]     ...future.result
[08:28:15.893] }
[08:28:15.895] requestCore(): workers = 2
[08:28:15.897] MulticoreFuture started
[08:28:15.898] - Launch lazy future ... done
[08:28:15.898] plan(): Setting new future strategy stack:
[08:28:15.898] run() for ‘MulticoreFuture’ ... done
[08:28:15.899] result() for MulticoreFuture ...
[08:28:15.899] List of future strategies:
[08:28:15.899] 1. sequential:
[08:28:15.899]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.899]    - tweaked: FALSE
[08:28:15.899]    - call: NULL
[08:28:15.900] plan(): nbrOfWorkers() = 1
[08:28:15.903] plan(): Setting new future strategy stack:
[08:28:15.903] List of future strategies:
[08:28:15.903] 1. multicore:
[08:28:15.903]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.903]    - tweaked: FALSE
[08:28:15.903]    - call: plan(strategy)
[08:28:15.906] plan(): nbrOfWorkers() = 2
[08:28:15.907] result() for MulticoreFuture ...
[08:28:15.907] result() for MulticoreFuture ... done
[08:28:15.907] result() for MulticoreFuture ... done
[08:28:15.907] result() for MulticoreFuture ...
[08:28:15.907] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.908] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.908] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.911] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[08:28:15.911] Searching for globals ... DONE
[08:28:15.911] Resolving globals: TRUE
[08:28:15.911] Resolving any globals that are futures ...
[08:28:15.912] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[08:28:15.912] Resolving any globals that are futures ... DONE
[08:28:15.912] Resolving futures part of globals (recursively) ...
[08:28:15.912] resolve() on list ...
[08:28:15.913]  recursive: 99
[08:28:15.913]  length: 1
[08:28:15.913]  elements: ‘x’
[08:28:15.913]  length: 0 (resolved future 1)
[08:28:15.913] resolve() on list ... DONE
[08:28:15.913] - globals: [1] ‘x’
[08:28:15.913] Resolving futures part of globals (recursively) ... DONE
[08:28:15.913] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:15.914] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[08:28:15.914] - globals: [1] ‘x’
[08:28:15.914] 
[08:28:15.914] getGlobalsAndPackages() ... DONE
[08:28:15.915] run() for ‘Future’ ...
[08:28:15.915] - state: ‘created’
[08:28:15.915] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.917] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.917] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.917]   - Field: ‘label’
[08:28:15.917]   - Field: ‘local’
[08:28:15.917]   - Field: ‘owner’
[08:28:15.917]   - Field: ‘envir’
[08:28:15.918]   - Field: ‘workers’
[08:28:15.918]   - Field: ‘packages’
[08:28:15.918]   - Field: ‘gc’
[08:28:15.918]   - Field: ‘job’
[08:28:15.918]   - Field: ‘conditions’
[08:28:15.918]   - Field: ‘expr’
[08:28:15.918]   - Field: ‘uuid’
[08:28:15.918]   - Field: ‘seed’
[08:28:15.918]   - Field: ‘version’
[08:28:15.918]   - Field: ‘result’
[08:28:15.919]   - Field: ‘asynchronous’
[08:28:15.919]   - Field: ‘calls’
[08:28:15.919]   - Field: ‘globals’
[08:28:15.919]   - Field: ‘stdout’
[08:28:15.919]   - Field: ‘earlySignal’
[08:28:15.919]   - Field: ‘lazy’
[08:28:15.919]   - Field: ‘state’
[08:28:15.919] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.919] - Launch lazy future ...
[08:28:15.920] Packages needed by the future expression (n = 0): <none>
[08:28:15.920] Packages needed by future strategies (n = 0): <none>
[08:28:15.920] {
[08:28:15.920]     {
[08:28:15.920]         {
[08:28:15.920]             ...future.startTime <- base::Sys.time()
[08:28:15.920]             {
[08:28:15.920]                 {
[08:28:15.920]                   {
[08:28:15.920]                     {
[08:28:15.920]                       base::local({
[08:28:15.920]                         has_future <- base::requireNamespace("future", 
[08:28:15.920]                           quietly = TRUE)
[08:28:15.920]                         if (has_future) {
[08:28:15.920]                           ns <- base::getNamespace("future")
[08:28:15.920]                           version <- ns[[".package"]][["version"]]
[08:28:15.920]                           if (is.null(version)) 
[08:28:15.920]                             version <- utils::packageVersion("future")
[08:28:15.920]                         }
[08:28:15.920]                         else {
[08:28:15.920]                           version <- NULL
[08:28:15.920]                         }
[08:28:15.920]                         if (!has_future || version < "1.8.0") {
[08:28:15.920]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.920]                             "", base::R.version$version.string), 
[08:28:15.920]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.920]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.920]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.920]                               "release", "version")], collapse = " "), 
[08:28:15.920]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.920]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.920]                             info)
[08:28:15.920]                           info <- base::paste(info, collapse = "; ")
[08:28:15.920]                           if (!has_future) {
[08:28:15.920]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.920]                               info)
[08:28:15.920]                           }
[08:28:15.920]                           else {
[08:28:15.920]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.920]                               info, version)
[08:28:15.920]                           }
[08:28:15.920]                           base::stop(msg)
[08:28:15.920]                         }
[08:28:15.920]                       })
[08:28:15.920]                     }
[08:28:15.920]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.920]                     base::options(mc.cores = 1L)
[08:28:15.920]                   }
[08:28:15.920]                   ...future.strategy.old <- future::plan("list")
[08:28:15.920]                   options(future.plan = NULL)
[08:28:15.920]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.920]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.920]                 }
[08:28:15.920]                 ...future.workdir <- getwd()
[08:28:15.920]             }
[08:28:15.920]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.920]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.920]         }
[08:28:15.920]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.920]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.920]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.920]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.920]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.920]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.920]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.920]             base::names(...future.oldOptions))
[08:28:15.920]     }
[08:28:15.920]     if (FALSE) {
[08:28:15.920]     }
[08:28:15.920]     else {
[08:28:15.920]         if (TRUE) {
[08:28:15.920]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.920]                 open = "w")
[08:28:15.920]         }
[08:28:15.920]         else {
[08:28:15.920]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.920]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.920]         }
[08:28:15.920]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.920]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.920]             base::sink(type = "output", split = FALSE)
[08:28:15.920]             base::close(...future.stdout)
[08:28:15.920]         }, add = TRUE)
[08:28:15.920]     }
[08:28:15.920]     ...future.frame <- base::sys.nframe()
[08:28:15.920]     ...future.conditions <- base::list()
[08:28:15.920]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.920]     if (FALSE) {
[08:28:15.920]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.920]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.920]     }
[08:28:15.920]     ...future.result <- base::tryCatch({
[08:28:15.920]         base::withCallingHandlers({
[08:28:15.920]             ...future.value <- base::withVisible(base::local({
[08:28:15.920]                 withCallingHandlers({
[08:28:15.920]                   {
[08:28:15.920]                     x <- x + 1
[08:28:15.920]                     x
[08:28:15.920]                   }
[08:28:15.920]                 }, immediateCondition = function(cond) {
[08:28:15.920]                   save_rds <- function (object, pathname, ...) 
[08:28:15.920]                   {
[08:28:15.920]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.920]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.920]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.920]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.920]                         fi_tmp[["mtime"]])
[08:28:15.920]                     }
[08:28:15.920]                     tryCatch({
[08:28:15.920]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.920]                     }, error = function(ex) {
[08:28:15.920]                       msg <- conditionMessage(ex)
[08:28:15.920]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.920]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.920]                         fi_tmp[["mtime"]], msg)
[08:28:15.920]                       ex$message <- msg
[08:28:15.920]                       stop(ex)
[08:28:15.920]                     })
[08:28:15.920]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.920]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.920]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.920]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.920]                       fi <- file.info(pathname)
[08:28:15.920]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.920]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.920]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.920]                         fi[["size"]], fi[["mtime"]])
[08:28:15.920]                       stop(msg)
[08:28:15.920]                     }
[08:28:15.920]                     invisible(pathname)
[08:28:15.920]                   }
[08:28:15.920]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.920]                     rootPath = tempdir()) 
[08:28:15.920]                   {
[08:28:15.920]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.920]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.920]                       tmpdir = path, fileext = ".rds")
[08:28:15.920]                     save_rds(obj, file)
[08:28:15.920]                   }
[08:28:15.920]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.920]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.920]                   {
[08:28:15.920]                     inherits <- base::inherits
[08:28:15.920]                     invokeRestart <- base::invokeRestart
[08:28:15.920]                     is.null <- base::is.null
[08:28:15.920]                     muffled <- FALSE
[08:28:15.920]                     if (inherits(cond, "message")) {
[08:28:15.920]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.920]                       if (muffled) 
[08:28:15.920]                         invokeRestart("muffleMessage")
[08:28:15.920]                     }
[08:28:15.920]                     else if (inherits(cond, "warning")) {
[08:28:15.920]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.920]                       if (muffled) 
[08:28:15.920]                         invokeRestart("muffleWarning")
[08:28:15.920]                     }
[08:28:15.920]                     else if (inherits(cond, "condition")) {
[08:28:15.920]                       if (!is.null(pattern)) {
[08:28:15.920]                         computeRestarts <- base::computeRestarts
[08:28:15.920]                         grepl <- base::grepl
[08:28:15.920]                         restarts <- computeRestarts(cond)
[08:28:15.920]                         for (restart in restarts) {
[08:28:15.920]                           name <- restart$name
[08:28:15.920]                           if (is.null(name)) 
[08:28:15.920]                             next
[08:28:15.920]                           if (!grepl(pattern, name)) 
[08:28:15.920]                             next
[08:28:15.920]                           invokeRestart(restart)
[08:28:15.920]                           muffled <- TRUE
[08:28:15.920]                           break
[08:28:15.920]                         }
[08:28:15.920]                       }
[08:28:15.920]                     }
[08:28:15.920]                     invisible(muffled)
[08:28:15.920]                   }
[08:28:15.920]                   muffleCondition(cond)
[08:28:15.920]                 })
[08:28:15.920]             }))
[08:28:15.920]             future::FutureResult(value = ...future.value$value, 
[08:28:15.920]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.920]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.920]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.920]                     ...future.globalenv.names))
[08:28:15.920]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.920]         }, condition = base::local({
[08:28:15.920]             c <- base::c
[08:28:15.920]             inherits <- base::inherits
[08:28:15.920]             invokeRestart <- base::invokeRestart
[08:28:15.920]             length <- base::length
[08:28:15.920]             list <- base::list
[08:28:15.920]             seq.int <- base::seq.int
[08:28:15.920]             signalCondition <- base::signalCondition
[08:28:15.920]             sys.calls <- base::sys.calls
[08:28:15.920]             `[[` <- base::`[[`
[08:28:15.920]             `+` <- base::`+`
[08:28:15.920]             `<<-` <- base::`<<-`
[08:28:15.920]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.920]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.920]                   3L)]
[08:28:15.920]             }
[08:28:15.920]             function(cond) {
[08:28:15.920]                 is_error <- inherits(cond, "error")
[08:28:15.920]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.920]                   NULL)
[08:28:15.920]                 if (is_error) {
[08:28:15.920]                   sessionInformation <- function() {
[08:28:15.920]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.920]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.920]                       search = base::search(), system = base::Sys.info())
[08:28:15.920]                   }
[08:28:15.920]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.920]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.920]                     cond$call), session = sessionInformation(), 
[08:28:15.920]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.920]                   signalCondition(cond)
[08:28:15.920]                 }
[08:28:15.920]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.920]                 "immediateCondition"))) {
[08:28:15.920]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.920]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.920]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.920]                   if (TRUE && !signal) {
[08:28:15.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.920]                     {
[08:28:15.920]                       inherits <- base::inherits
[08:28:15.920]                       invokeRestart <- base::invokeRestart
[08:28:15.920]                       is.null <- base::is.null
[08:28:15.920]                       muffled <- FALSE
[08:28:15.920]                       if (inherits(cond, "message")) {
[08:28:15.920]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.920]                         if (muffled) 
[08:28:15.920]                           invokeRestart("muffleMessage")
[08:28:15.920]                       }
[08:28:15.920]                       else if (inherits(cond, "warning")) {
[08:28:15.920]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.920]                         if (muffled) 
[08:28:15.920]                           invokeRestart("muffleWarning")
[08:28:15.920]                       }
[08:28:15.920]                       else if (inherits(cond, "condition")) {
[08:28:15.920]                         if (!is.null(pattern)) {
[08:28:15.920]                           computeRestarts <- base::computeRestarts
[08:28:15.920]                           grepl <- base::grepl
[08:28:15.920]                           restarts <- computeRestarts(cond)
[08:28:15.920]                           for (restart in restarts) {
[08:28:15.920]                             name <- restart$name
[08:28:15.920]                             if (is.null(name)) 
[08:28:15.920]                               next
[08:28:15.920]                             if (!grepl(pattern, name)) 
[08:28:15.920]                               next
[08:28:15.920]                             invokeRestart(restart)
[08:28:15.920]                             muffled <- TRUE
[08:28:15.920]                             break
[08:28:15.920]                           }
[08:28:15.920]                         }
[08:28:15.920]                       }
[08:28:15.920]                       invisible(muffled)
[08:28:15.920]                     }
[08:28:15.920]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.920]                   }
[08:28:15.920]                 }
[08:28:15.920]                 else {
[08:28:15.920]                   if (TRUE) {
[08:28:15.920]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.920]                     {
[08:28:15.920]                       inherits <- base::inherits
[08:28:15.920]                       invokeRestart <- base::invokeRestart
[08:28:15.920]                       is.null <- base::is.null
[08:28:15.920]                       muffled <- FALSE
[08:28:15.920]                       if (inherits(cond, "message")) {
[08:28:15.920]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.920]                         if (muffled) 
[08:28:15.920]                           invokeRestart("muffleMessage")
[08:28:15.920]                       }
[08:28:15.920]                       else if (inherits(cond, "warning")) {
[08:28:15.920]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.920]                         if (muffled) 
[08:28:15.920]                           invokeRestart("muffleWarning")
[08:28:15.920]                       }
[08:28:15.920]                       else if (inherits(cond, "condition")) {
[08:28:15.920]                         if (!is.null(pattern)) {
[08:28:15.920]                           computeRestarts <- base::computeRestarts
[08:28:15.920]                           grepl <- base::grepl
[08:28:15.920]                           restarts <- computeRestarts(cond)
[08:28:15.920]                           for (restart in restarts) {
[08:28:15.920]                             name <- restart$name
[08:28:15.920]                             if (is.null(name)) 
[08:28:15.920]                               next
[08:28:15.920]                             if (!grepl(pattern, name)) 
[08:28:15.920]                               next
[08:28:15.920]                             invokeRestart(restart)
[08:28:15.920]                             muffled <- TRUE
[08:28:15.920]                             break
[08:28:15.920]                           }
[08:28:15.920]                         }
[08:28:15.920]                       }
[08:28:15.920]                       invisible(muffled)
[08:28:15.920]                     }
[08:28:15.920]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.920]                   }
[08:28:15.920]                 }
[08:28:15.920]             }
[08:28:15.920]         }))
[08:28:15.920]     }, error = function(ex) {
[08:28:15.920]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.920]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.920]                 ...future.rng), started = ...future.startTime, 
[08:28:15.920]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.920]             version = "1.8"), class = "FutureResult")
[08:28:15.920]     }, finally = {
[08:28:15.920]         if (!identical(...future.workdir, getwd())) 
[08:28:15.920]             setwd(...future.workdir)
[08:28:15.920]         {
[08:28:15.920]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.920]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.920]             }
[08:28:15.920]             base::options(...future.oldOptions)
[08:28:15.920]             if (.Platform$OS.type == "windows") {
[08:28:15.920]                 old_names <- names(...future.oldEnvVars)
[08:28:15.920]                 envs <- base::Sys.getenv()
[08:28:15.920]                 names <- names(envs)
[08:28:15.920]                 common <- intersect(names, old_names)
[08:28:15.920]                 added <- setdiff(names, old_names)
[08:28:15.920]                 removed <- setdiff(old_names, names)
[08:28:15.920]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.920]                   envs[common]]
[08:28:15.920]                 NAMES <- toupper(changed)
[08:28:15.920]                 args <- list()
[08:28:15.920]                 for (kk in seq_along(NAMES)) {
[08:28:15.920]                   name <- changed[[kk]]
[08:28:15.920]                   NAME <- NAMES[[kk]]
[08:28:15.920]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.920]                     next
[08:28:15.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.920]                 }
[08:28:15.920]                 NAMES <- toupper(added)
[08:28:15.920]                 for (kk in seq_along(NAMES)) {
[08:28:15.920]                   name <- added[[kk]]
[08:28:15.920]                   NAME <- NAMES[[kk]]
[08:28:15.920]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.920]                     next
[08:28:15.920]                   args[[name]] <- ""
[08:28:15.920]                 }
[08:28:15.920]                 NAMES <- toupper(removed)
[08:28:15.920]                 for (kk in seq_along(NAMES)) {
[08:28:15.920]                   name <- removed[[kk]]
[08:28:15.920]                   NAME <- NAMES[[kk]]
[08:28:15.920]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.920]                     next
[08:28:15.920]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.920]                 }
[08:28:15.920]                 if (length(args) > 0) 
[08:28:15.920]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.920]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.920]             }
[08:28:15.920]             else {
[08:28:15.920]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.920]             }
[08:28:15.920]             {
[08:28:15.920]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.920]                   0L) {
[08:28:15.920]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.920]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.920]                   base::options(opts)
[08:28:15.920]                 }
[08:28:15.920]                 {
[08:28:15.920]                   {
[08:28:15.920]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.920]                     NULL
[08:28:15.920]                   }
[08:28:15.920]                   options(future.plan = NULL)
[08:28:15.920]                   if (is.na(NA_character_)) 
[08:28:15.920]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.920]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.920]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.920]                     .init = FALSE)
[08:28:15.920]                 }
[08:28:15.920]             }
[08:28:15.920]         }
[08:28:15.920]     })
[08:28:15.920]     if (TRUE) {
[08:28:15.920]         base::sink(type = "output", split = FALSE)
[08:28:15.920]         if (TRUE) {
[08:28:15.920]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.920]         }
[08:28:15.920]         else {
[08:28:15.920]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.920]         }
[08:28:15.920]         base::close(...future.stdout)
[08:28:15.920]         ...future.stdout <- NULL
[08:28:15.920]     }
[08:28:15.920]     ...future.result$conditions <- ...future.conditions
[08:28:15.920]     ...future.result$finished <- base::Sys.time()
[08:28:15.920]     ...future.result
[08:28:15.920] }
[08:28:15.923] assign_globals() ...
[08:28:15.923] List of 1
[08:28:15.923]  $ x: num 1
[08:28:15.923]  - attr(*, "where")=List of 1
[08:28:15.923]   ..$ x:<environment: R_EmptyEnv> 
[08:28:15.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.923]  - attr(*, "resolved")= logi TRUE
[08:28:15.923]  - attr(*, "total_size")= num 39
[08:28:15.923]  - attr(*, "already-done")= logi TRUE
[08:28:15.926] - copied ‘x’ to environment
[08:28:15.926] assign_globals() ... done
[08:28:15.926] requestCore(): workers = 2
[08:28:15.928] MulticoreFuture started
[08:28:15.928] - Launch lazy future ... done
[08:28:15.928] run() for ‘MulticoreFuture’ ... done
[08:28:15.929] result() for MulticoreFuture ...
[08:28:15.929] plan(): Setting new future strategy stack:
[08:28:15.929] List of future strategies:
[08:28:15.929] 1. sequential:
[08:28:15.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.929]    - tweaked: FALSE
[08:28:15.929]    - call: NULL
[08:28:15.930] plan(): nbrOfWorkers() = 1
[08:28:15.932] plan(): Setting new future strategy stack:
[08:28:15.932] List of future strategies:
[08:28:15.932] 1. multicore:
[08:28:15.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.932]    - tweaked: FALSE
[08:28:15.932]    - call: plan(strategy)
[08:28:15.935] plan(): nbrOfWorkers() = 2
[08:28:15.936] result() for MulticoreFuture ...
[08:28:15.936] result() for MulticoreFuture ... done
[08:28:15.936] result() for MulticoreFuture ... done
[08:28:15.937] result() for MulticoreFuture ...
[08:28:15.937] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.937] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.937] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:15.940] - globals found: [3] ‘{’, ‘<-’, ‘x’
[08:28:15.940] Searching for globals ... DONE
[08:28:15.940] Resolving globals: TRUE
[08:28:15.940] Resolving any globals that are futures ...
[08:28:15.940] - globals: [3] ‘{’, ‘<-’, ‘x’
[08:28:15.940] Resolving any globals that are futures ... DONE
[08:28:15.941] Resolving futures part of globals (recursively) ...
[08:28:15.941] resolve() on list ...
[08:28:15.941]  recursive: 99
[08:28:15.941]  length: 1
[08:28:15.941]  elements: ‘x’
[08:28:15.942]  length: 0 (resolved future 1)
[08:28:15.942] resolve() on list ... DONE
[08:28:15.942] - globals: [1] ‘x’
[08:28:15.945] Resolving futures part of globals (recursively) ... DONE
[08:28:15.945] The total size of the 1 globals is 260 bytes (260 bytes)
[08:28:15.945] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[08:28:15.946] - globals: [1] ‘x’
[08:28:15.946] 
[08:28:15.946] getGlobalsAndPackages() ... DONE
[08:28:15.946] run() for ‘Future’ ...
[08:28:15.946] - state: ‘created’
[08:28:15.947] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[08:28:15.949] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:15.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[08:28:15.949]   - Field: ‘label’
[08:28:15.949]   - Field: ‘local’
[08:28:15.950]   - Field: ‘owner’
[08:28:15.950]   - Field: ‘envir’
[08:28:15.950]   - Field: ‘workers’
[08:28:15.950]   - Field: ‘packages’
[08:28:15.950]   - Field: ‘gc’
[08:28:15.950]   - Field: ‘job’
[08:28:15.950]   - Field: ‘conditions’
[08:28:15.950]   - Field: ‘expr’
[08:28:15.951]   - Field: ‘uuid’
[08:28:15.951]   - Field: ‘seed’
[08:28:15.951]   - Field: ‘version’
[08:28:15.951]   - Field: ‘result’
[08:28:15.951]   - Field: ‘asynchronous’
[08:28:15.951]   - Field: ‘calls’
[08:28:15.951]   - Field: ‘globals’
[08:28:15.951]   - Field: ‘stdout’
[08:28:15.951]   - Field: ‘earlySignal’
[08:28:15.951]   - Field: ‘lazy’
[08:28:15.952]   - Field: ‘state’
[08:28:15.952] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[08:28:15.952] - Launch lazy future ...
[08:28:15.952] Packages needed by the future expression (n = 0): <none>
[08:28:15.952] Packages needed by future strategies (n = 0): <none>
[08:28:15.953] {
[08:28:15.953]     {
[08:28:15.953]         {
[08:28:15.953]             ...future.startTime <- base::Sys.time()
[08:28:15.953]             {
[08:28:15.953]                 {
[08:28:15.953]                   {
[08:28:15.953]                     {
[08:28:15.953]                       base::local({
[08:28:15.953]                         has_future <- base::requireNamespace("future", 
[08:28:15.953]                           quietly = TRUE)
[08:28:15.953]                         if (has_future) {
[08:28:15.953]                           ns <- base::getNamespace("future")
[08:28:15.953]                           version <- ns[[".package"]][["version"]]
[08:28:15.953]                           if (is.null(version)) 
[08:28:15.953]                             version <- utils::packageVersion("future")
[08:28:15.953]                         }
[08:28:15.953]                         else {
[08:28:15.953]                           version <- NULL
[08:28:15.953]                         }
[08:28:15.953]                         if (!has_future || version < "1.8.0") {
[08:28:15.953]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:15.953]                             "", base::R.version$version.string), 
[08:28:15.953]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:15.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:15.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:15.953]                               "release", "version")], collapse = " "), 
[08:28:15.953]                             hostname = base::Sys.info()[["nodename"]])
[08:28:15.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:15.953]                             info)
[08:28:15.953]                           info <- base::paste(info, collapse = "; ")
[08:28:15.953]                           if (!has_future) {
[08:28:15.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:15.953]                               info)
[08:28:15.953]                           }
[08:28:15.953]                           else {
[08:28:15.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:15.953]                               info, version)
[08:28:15.953]                           }
[08:28:15.953]                           base::stop(msg)
[08:28:15.953]                         }
[08:28:15.953]                       })
[08:28:15.953]                     }
[08:28:15.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:15.953]                     base::options(mc.cores = 1L)
[08:28:15.953]                   }
[08:28:15.953]                   ...future.strategy.old <- future::plan("list")
[08:28:15.953]                   options(future.plan = NULL)
[08:28:15.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:15.953]                 }
[08:28:15.953]                 ...future.workdir <- getwd()
[08:28:15.953]             }
[08:28:15.953]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:15.953]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:15.953]         }
[08:28:15.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:15.953]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:15.953]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:15.953]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:15.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:15.953]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:15.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:15.953]             base::names(...future.oldOptions))
[08:28:15.953]     }
[08:28:15.953]     if (FALSE) {
[08:28:15.953]     }
[08:28:15.953]     else {
[08:28:15.953]         if (TRUE) {
[08:28:15.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:15.953]                 open = "w")
[08:28:15.953]         }
[08:28:15.953]         else {
[08:28:15.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:15.953]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:15.953]         }
[08:28:15.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:15.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:15.953]             base::sink(type = "output", split = FALSE)
[08:28:15.953]             base::close(...future.stdout)
[08:28:15.953]         }, add = TRUE)
[08:28:15.953]     }
[08:28:15.953]     ...future.frame <- base::sys.nframe()
[08:28:15.953]     ...future.conditions <- base::list()
[08:28:15.953]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:15.953]     if (FALSE) {
[08:28:15.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:15.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:15.953]     }
[08:28:15.953]     ...future.result <- base::tryCatch({
[08:28:15.953]         base::withCallingHandlers({
[08:28:15.953]             ...future.value <- base::withVisible(base::local({
[08:28:15.953]                 withCallingHandlers({
[08:28:15.953]                   {
[08:28:15.953]                     x <- x()
[08:28:15.953]                     x
[08:28:15.953]                   }
[08:28:15.953]                 }, immediateCondition = function(cond) {
[08:28:15.953]                   save_rds <- function (object, pathname, ...) 
[08:28:15.953]                   {
[08:28:15.953]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[08:28:15.953]                     if (file_test("-f", pathname_tmp)) {
[08:28:15.953]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.953]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[08:28:15.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.953]                         fi_tmp[["mtime"]])
[08:28:15.953]                     }
[08:28:15.953]                     tryCatch({
[08:28:15.953]                       saveRDS(object, file = pathname_tmp, ...)
[08:28:15.953]                     }, error = function(ex) {
[08:28:15.953]                       msg <- conditionMessage(ex)
[08:28:15.953]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.953]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[08:28:15.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.953]                         fi_tmp[["mtime"]], msg)
[08:28:15.953]                       ex$message <- msg
[08:28:15.953]                       stop(ex)
[08:28:15.953]                     })
[08:28:15.953]                     stopifnot(file_test("-f", pathname_tmp))
[08:28:15.953]                     res <- file.rename(from = pathname_tmp, to = pathname)
[08:28:15.953]                     if (!res || file_test("-f", pathname_tmp)) {
[08:28:15.953]                       fi_tmp <- file.info(pathname_tmp)
[08:28:15.953]                       fi <- file.info(pathname)
[08:28:15.953]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[08:28:15.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[08:28:15.953]                         fi_tmp[["mtime"]], sQuote(pathname), 
[08:28:15.953]                         fi[["size"]], fi[["mtime"]])
[08:28:15.953]                       stop(msg)
[08:28:15.953]                     }
[08:28:15.953]                     invisible(pathname)
[08:28:15.953]                   }
[08:28:15.953]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[08:28:15.953]                     rootPath = tempdir()) 
[08:28:15.953]                   {
[08:28:15.953]                     obj <- list(time = Sys.time(), condition = cond)
[08:28:15.953]                     file <- tempfile(pattern = class(cond)[1], 
[08:28:15.953]                       tmpdir = path, fileext = ".rds")
[08:28:15.953]                     save_rds(obj, file)
[08:28:15.953]                   }
[08:28:15.953]                   saveImmediateCondition(cond, path = "/tmp/RtmpfoiXBq/.future/immediateConditions")
[08:28:15.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.953]                   {
[08:28:15.953]                     inherits <- base::inherits
[08:28:15.953]                     invokeRestart <- base::invokeRestart
[08:28:15.953]                     is.null <- base::is.null
[08:28:15.953]                     muffled <- FALSE
[08:28:15.953]                     if (inherits(cond, "message")) {
[08:28:15.953]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:15.953]                       if (muffled) 
[08:28:15.953]                         invokeRestart("muffleMessage")
[08:28:15.953]                     }
[08:28:15.953]                     else if (inherits(cond, "warning")) {
[08:28:15.953]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:15.953]                       if (muffled) 
[08:28:15.953]                         invokeRestart("muffleWarning")
[08:28:15.953]                     }
[08:28:15.953]                     else if (inherits(cond, "condition")) {
[08:28:15.953]                       if (!is.null(pattern)) {
[08:28:15.953]                         computeRestarts <- base::computeRestarts
[08:28:15.953]                         grepl <- base::grepl
[08:28:15.953]                         restarts <- computeRestarts(cond)
[08:28:15.953]                         for (restart in restarts) {
[08:28:15.953]                           name <- restart$name
[08:28:15.953]                           if (is.null(name)) 
[08:28:15.953]                             next
[08:28:15.953]                           if (!grepl(pattern, name)) 
[08:28:15.953]                             next
[08:28:15.953]                           invokeRestart(restart)
[08:28:15.953]                           muffled <- TRUE
[08:28:15.953]                           break
[08:28:15.953]                         }
[08:28:15.953]                       }
[08:28:15.953]                     }
[08:28:15.953]                     invisible(muffled)
[08:28:15.953]                   }
[08:28:15.953]                   muffleCondition(cond)
[08:28:15.953]                 })
[08:28:15.953]             }))
[08:28:15.953]             future::FutureResult(value = ...future.value$value, 
[08:28:15.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.953]                   ...future.rng), globalenv = if (FALSE) 
[08:28:15.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:15.953]                     ...future.globalenv.names))
[08:28:15.953]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:15.953]         }, condition = base::local({
[08:28:15.953]             c <- base::c
[08:28:15.953]             inherits <- base::inherits
[08:28:15.953]             invokeRestart <- base::invokeRestart
[08:28:15.953]             length <- base::length
[08:28:15.953]             list <- base::list
[08:28:15.953]             seq.int <- base::seq.int
[08:28:15.953]             signalCondition <- base::signalCondition
[08:28:15.953]             sys.calls <- base::sys.calls
[08:28:15.953]             `[[` <- base::`[[`
[08:28:15.953]             `+` <- base::`+`
[08:28:15.953]             `<<-` <- base::`<<-`
[08:28:15.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:15.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:15.953]                   3L)]
[08:28:15.953]             }
[08:28:15.953]             function(cond) {
[08:28:15.953]                 is_error <- inherits(cond, "error")
[08:28:15.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:15.953]                   NULL)
[08:28:15.953]                 if (is_error) {
[08:28:15.953]                   sessionInformation <- function() {
[08:28:15.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:15.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:15.953]                       search = base::search(), system = base::Sys.info())
[08:28:15.953]                   }
[08:28:15.953]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:15.953]                     cond$call), session = sessionInformation(), 
[08:28:15.953]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:15.953]                   signalCondition(cond)
[08:28:15.953]                 }
[08:28:15.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:15.953]                 "immediateCondition"))) {
[08:28:15.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:15.953]                   ...future.conditions[[length(...future.conditions) + 
[08:28:15.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:15.953]                   if (TRUE && !signal) {
[08:28:15.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.953]                     {
[08:28:15.953]                       inherits <- base::inherits
[08:28:15.953]                       invokeRestart <- base::invokeRestart
[08:28:15.953]                       is.null <- base::is.null
[08:28:15.953]                       muffled <- FALSE
[08:28:15.953]                       if (inherits(cond, "message")) {
[08:28:15.953]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.953]                         if (muffled) 
[08:28:15.953]                           invokeRestart("muffleMessage")
[08:28:15.953]                       }
[08:28:15.953]                       else if (inherits(cond, "warning")) {
[08:28:15.953]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.953]                         if (muffled) 
[08:28:15.953]                           invokeRestart("muffleWarning")
[08:28:15.953]                       }
[08:28:15.953]                       else if (inherits(cond, "condition")) {
[08:28:15.953]                         if (!is.null(pattern)) {
[08:28:15.953]                           computeRestarts <- base::computeRestarts
[08:28:15.953]                           grepl <- base::grepl
[08:28:15.953]                           restarts <- computeRestarts(cond)
[08:28:15.953]                           for (restart in restarts) {
[08:28:15.953]                             name <- restart$name
[08:28:15.953]                             if (is.null(name)) 
[08:28:15.953]                               next
[08:28:15.953]                             if (!grepl(pattern, name)) 
[08:28:15.953]                               next
[08:28:15.953]                             invokeRestart(restart)
[08:28:15.953]                             muffled <- TRUE
[08:28:15.953]                             break
[08:28:15.953]                           }
[08:28:15.953]                         }
[08:28:15.953]                       }
[08:28:15.953]                       invisible(muffled)
[08:28:15.953]                     }
[08:28:15.953]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.953]                   }
[08:28:15.953]                 }
[08:28:15.953]                 else {
[08:28:15.953]                   if (TRUE) {
[08:28:15.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:15.953]                     {
[08:28:15.953]                       inherits <- base::inherits
[08:28:15.953]                       invokeRestart <- base::invokeRestart
[08:28:15.953]                       is.null <- base::is.null
[08:28:15.953]                       muffled <- FALSE
[08:28:15.953]                       if (inherits(cond, "message")) {
[08:28:15.953]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:15.953]                         if (muffled) 
[08:28:15.953]                           invokeRestart("muffleMessage")
[08:28:15.953]                       }
[08:28:15.953]                       else if (inherits(cond, "warning")) {
[08:28:15.953]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:15.953]                         if (muffled) 
[08:28:15.953]                           invokeRestart("muffleWarning")
[08:28:15.953]                       }
[08:28:15.953]                       else if (inherits(cond, "condition")) {
[08:28:15.953]                         if (!is.null(pattern)) {
[08:28:15.953]                           computeRestarts <- base::computeRestarts
[08:28:15.953]                           grepl <- base::grepl
[08:28:15.953]                           restarts <- computeRestarts(cond)
[08:28:15.953]                           for (restart in restarts) {
[08:28:15.953]                             name <- restart$name
[08:28:15.953]                             if (is.null(name)) 
[08:28:15.953]                               next
[08:28:15.953]                             if (!grepl(pattern, name)) 
[08:28:15.953]                               next
[08:28:15.953]                             invokeRestart(restart)
[08:28:15.953]                             muffled <- TRUE
[08:28:15.953]                             break
[08:28:15.953]                           }
[08:28:15.953]                         }
[08:28:15.953]                       }
[08:28:15.953]                       invisible(muffled)
[08:28:15.953]                     }
[08:28:15.953]                     muffleCondition(cond, pattern = "^muffle")
[08:28:15.953]                   }
[08:28:15.953]                 }
[08:28:15.953]             }
[08:28:15.953]         }))
[08:28:15.953]     }, error = function(ex) {
[08:28:15.953]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:15.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:15.953]                 ...future.rng), started = ...future.startTime, 
[08:28:15.953]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:15.953]             version = "1.8"), class = "FutureResult")
[08:28:15.953]     }, finally = {
[08:28:15.953]         if (!identical(...future.workdir, getwd())) 
[08:28:15.953]             setwd(...future.workdir)
[08:28:15.953]         {
[08:28:15.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:15.953]                 ...future.oldOptions$nwarnings <- NULL
[08:28:15.953]             }
[08:28:15.953]             base::options(...future.oldOptions)
[08:28:15.953]             if (.Platform$OS.type == "windows") {
[08:28:15.953]                 old_names <- names(...future.oldEnvVars)
[08:28:15.953]                 envs <- base::Sys.getenv()
[08:28:15.953]                 names <- names(envs)
[08:28:15.953]                 common <- intersect(names, old_names)
[08:28:15.953]                 added <- setdiff(names, old_names)
[08:28:15.953]                 removed <- setdiff(old_names, names)
[08:28:15.953]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:15.953]                   envs[common]]
[08:28:15.953]                 NAMES <- toupper(changed)
[08:28:15.953]                 args <- list()
[08:28:15.953]                 for (kk in seq_along(NAMES)) {
[08:28:15.953]                   name <- changed[[kk]]
[08:28:15.953]                   NAME <- NAMES[[kk]]
[08:28:15.953]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.953]                     next
[08:28:15.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.953]                 }
[08:28:15.953]                 NAMES <- toupper(added)
[08:28:15.953]                 for (kk in seq_along(NAMES)) {
[08:28:15.953]                   name <- added[[kk]]
[08:28:15.953]                   NAME <- NAMES[[kk]]
[08:28:15.953]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.953]                     next
[08:28:15.953]                   args[[name]] <- ""
[08:28:15.953]                 }
[08:28:15.953]                 NAMES <- toupper(removed)
[08:28:15.953]                 for (kk in seq_along(NAMES)) {
[08:28:15.953]                   name <- removed[[kk]]
[08:28:15.953]                   NAME <- NAMES[[kk]]
[08:28:15.953]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:15.953]                     next
[08:28:15.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:15.953]                 }
[08:28:15.953]                 if (length(args) > 0) 
[08:28:15.953]                   base::do.call(base::Sys.setenv, args = args)
[08:28:15.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:15.953]             }
[08:28:15.953]             else {
[08:28:15.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:15.953]             }
[08:28:15.953]             {
[08:28:15.953]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:15.953]                   0L) {
[08:28:15.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:15.953]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:15.953]                   base::options(opts)
[08:28:15.953]                 }
[08:28:15.953]                 {
[08:28:15.953]                   {
[08:28:15.953]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:15.953]                     NULL
[08:28:15.953]                   }
[08:28:15.953]                   options(future.plan = NULL)
[08:28:15.953]                   if (is.na(NA_character_)) 
[08:28:15.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:15.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:15.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:15.953]                     .init = FALSE)
[08:28:15.953]                 }
[08:28:15.953]             }
[08:28:15.953]         }
[08:28:15.953]     })
[08:28:15.953]     if (TRUE) {
[08:28:15.953]         base::sink(type = "output", split = FALSE)
[08:28:15.953]         if (TRUE) {
[08:28:15.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:15.953]         }
[08:28:15.953]         else {
[08:28:15.953]             ...future.result["stdout"] <- base::list(NULL)
[08:28:15.953]         }
[08:28:15.953]         base::close(...future.stdout)
[08:28:15.953]         ...future.stdout <- NULL
[08:28:15.953]     }
[08:28:15.953]     ...future.result$conditions <- ...future.conditions
[08:28:15.953]     ...future.result$finished <- base::Sys.time()
[08:28:15.953]     ...future.result
[08:28:15.953] }
[08:28:15.955] assign_globals() ...
[08:28:15.955] List of 1
[08:28:15.955]  $ x:function ()  
[08:28:15.955]  - attr(*, "where")=List of 1
[08:28:15.955]   ..$ x:<environment: R_EmptyEnv> 
[08:28:15.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:15.955]  - attr(*, "resolved")= logi TRUE
[08:28:15.955]  - attr(*, "total_size")= num 260
[08:28:15.955]  - attr(*, "already-done")= logi TRUE
[08:28:15.958] - reassign environment for ‘x’
[08:28:15.958] - copied ‘x’ to environment
[08:28:15.958] assign_globals() ... done
[08:28:15.959] requestCore(): workers = 2
[08:28:15.960] MulticoreFuture started
[08:28:15.961] - Launch lazy future ... done
[08:28:15.961] run() for ‘MulticoreFuture’ ... done
[08:28:15.961] result() for MulticoreFuture ...
[08:28:15.961] plan(): Setting new future strategy stack:
[08:28:15.961] List of future strategies:
[08:28:15.961] 1. sequential:
[08:28:15.961]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:15.961]    - tweaked: FALSE
[08:28:15.961]    - call: NULL
[08:28:15.963] plan(): nbrOfWorkers() = 1
[08:28:15.965] plan(): Setting new future strategy stack:
[08:28:15.965] List of future strategies:
[08:28:15.965] 1. multicore:
[08:28:15.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[08:28:15.965]    - tweaked: FALSE
[08:28:15.965]    - call: plan(strategy)
[08:28:15.968] plan(): nbrOfWorkers() = 2
[08:28:15.969] result() for MulticoreFuture ...
[08:28:15.969] result() for MulticoreFuture ... done
[08:28:15.969] result() for MulticoreFuture ... done
[08:28:15.969] result() for MulticoreFuture ...
[08:28:15.969] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[08:28:15.970] plan(): Setting new future strategy stack:
[08:28:15.970] List of future strategies:
[08:28:15.970] 1. multisession:
[08:28:15.970]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:15.970]    - tweaked: FALSE
[08:28:15.970]    - call: plan(strategy)
[08:28:15.971] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[08:28:15.971] multisession:
[08:28:15.971] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:15.971] - tweaked: FALSE
[08:28:15.971] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:15.976] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:15.976] Not searching for globals
[08:28:15.976] - globals: [0] <none>
[08:28:15.976] getGlobalsAndPackages() ... DONE
[08:28:16.462] Packages needed by the future expression (n = 0): <none>
[08:28:16.462] Packages needed by future strategies (n = 0): <none>
[08:28:16.463] {
[08:28:16.463]     {
[08:28:16.463]         {
[08:28:16.463]             ...future.startTime <- base::Sys.time()
[08:28:16.463]             {
[08:28:16.463]                 {
[08:28:16.463]                   {
[08:28:16.463]                     {
[08:28:16.463]                       base::local({
[08:28:16.463]                         has_future <- base::requireNamespace("future", 
[08:28:16.463]                           quietly = TRUE)
[08:28:16.463]                         if (has_future) {
[08:28:16.463]                           ns <- base::getNamespace("future")
[08:28:16.463]                           version <- ns[[".package"]][["version"]]
[08:28:16.463]                           if (is.null(version)) 
[08:28:16.463]                             version <- utils::packageVersion("future")
[08:28:16.463]                         }
[08:28:16.463]                         else {
[08:28:16.463]                           version <- NULL
[08:28:16.463]                         }
[08:28:16.463]                         if (!has_future || version < "1.8.0") {
[08:28:16.463]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:16.463]                             "", base::R.version$version.string), 
[08:28:16.463]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:16.463]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:16.463]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:16.463]                               "release", "version")], collapse = " "), 
[08:28:16.463]                             hostname = base::Sys.info()[["nodename"]])
[08:28:16.463]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:16.463]                             info)
[08:28:16.463]                           info <- base::paste(info, collapse = "; ")
[08:28:16.463]                           if (!has_future) {
[08:28:16.463]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:16.463]                               info)
[08:28:16.463]                           }
[08:28:16.463]                           else {
[08:28:16.463]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:16.463]                               info, version)
[08:28:16.463]                           }
[08:28:16.463]                           base::stop(msg)
[08:28:16.463]                         }
[08:28:16.463]                       })
[08:28:16.463]                     }
[08:28:16.463]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:16.463]                     base::options(mc.cores = 1L)
[08:28:16.463]                   }
[08:28:16.463]                   ...future.strategy.old <- future::plan("list")
[08:28:16.463]                   options(future.plan = NULL)
[08:28:16.463]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.463]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:16.463]                 }
[08:28:16.463]                 ...future.workdir <- getwd()
[08:28:16.463]             }
[08:28:16.463]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:16.463]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:16.463]         }
[08:28:16.463]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:16.463]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:16.463]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:16.463]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:16.463]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:16.463]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:16.463]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:16.463]             base::names(...future.oldOptions))
[08:28:16.463]     }
[08:28:16.463]     if (FALSE) {
[08:28:16.463]     }
[08:28:16.463]     else {
[08:28:16.463]         if (TRUE) {
[08:28:16.463]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:16.463]                 open = "w")
[08:28:16.463]         }
[08:28:16.463]         else {
[08:28:16.463]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:16.463]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:16.463]         }
[08:28:16.463]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:16.463]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:16.463]             base::sink(type = "output", split = FALSE)
[08:28:16.463]             base::close(...future.stdout)
[08:28:16.463]         }, add = TRUE)
[08:28:16.463]     }
[08:28:16.463]     ...future.frame <- base::sys.nframe()
[08:28:16.463]     ...future.conditions <- base::list()
[08:28:16.463]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:16.463]     if (FALSE) {
[08:28:16.463]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:16.463]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:16.463]     }
[08:28:16.463]     ...future.result <- base::tryCatch({
[08:28:16.463]         base::withCallingHandlers({
[08:28:16.463]             ...future.value <- base::withVisible(base::local({
[08:28:16.463]                 ...future.makeSendCondition <- base::local({
[08:28:16.463]                   sendCondition <- NULL
[08:28:16.463]                   function(frame = 1L) {
[08:28:16.463]                     if (is.function(sendCondition)) 
[08:28:16.463]                       return(sendCondition)
[08:28:16.463]                     ns <- getNamespace("parallel")
[08:28:16.463]                     if (exists("sendData", mode = "function", 
[08:28:16.463]                       envir = ns)) {
[08:28:16.463]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:16.463]                         envir = ns)
[08:28:16.463]                       envir <- sys.frame(frame)
[08:28:16.463]                       master <- NULL
[08:28:16.463]                       while (!identical(envir, .GlobalEnv) && 
[08:28:16.463]                         !identical(envir, emptyenv())) {
[08:28:16.463]                         if (exists("master", mode = "list", envir = envir, 
[08:28:16.463]                           inherits = FALSE)) {
[08:28:16.463]                           master <- get("master", mode = "list", 
[08:28:16.463]                             envir = envir, inherits = FALSE)
[08:28:16.463]                           if (inherits(master, c("SOCKnode", 
[08:28:16.463]                             "SOCK0node"))) {
[08:28:16.463]                             sendCondition <<- function(cond) {
[08:28:16.463]                               data <- list(type = "VALUE", value = cond, 
[08:28:16.463]                                 success = TRUE)
[08:28:16.463]                               parallel_sendData(master, data)
[08:28:16.463]                             }
[08:28:16.463]                             return(sendCondition)
[08:28:16.463]                           }
[08:28:16.463]                         }
[08:28:16.463]                         frame <- frame + 1L
[08:28:16.463]                         envir <- sys.frame(frame)
[08:28:16.463]                       }
[08:28:16.463]                     }
[08:28:16.463]                     sendCondition <<- function(cond) NULL
[08:28:16.463]                   }
[08:28:16.463]                 })
[08:28:16.463]                 withCallingHandlers({
[08:28:16.463]                   NA
[08:28:16.463]                 }, immediateCondition = function(cond) {
[08:28:16.463]                   sendCondition <- ...future.makeSendCondition()
[08:28:16.463]                   sendCondition(cond)
[08:28:16.463]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.463]                   {
[08:28:16.463]                     inherits <- base::inherits
[08:28:16.463]                     invokeRestart <- base::invokeRestart
[08:28:16.463]                     is.null <- base::is.null
[08:28:16.463]                     muffled <- FALSE
[08:28:16.463]                     if (inherits(cond, "message")) {
[08:28:16.463]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:16.463]                       if (muffled) 
[08:28:16.463]                         invokeRestart("muffleMessage")
[08:28:16.463]                     }
[08:28:16.463]                     else if (inherits(cond, "warning")) {
[08:28:16.463]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:16.463]                       if (muffled) 
[08:28:16.463]                         invokeRestart("muffleWarning")
[08:28:16.463]                     }
[08:28:16.463]                     else if (inherits(cond, "condition")) {
[08:28:16.463]                       if (!is.null(pattern)) {
[08:28:16.463]                         computeRestarts <- base::computeRestarts
[08:28:16.463]                         grepl <- base::grepl
[08:28:16.463]                         restarts <- computeRestarts(cond)
[08:28:16.463]                         for (restart in restarts) {
[08:28:16.463]                           name <- restart$name
[08:28:16.463]                           if (is.null(name)) 
[08:28:16.463]                             next
[08:28:16.463]                           if (!grepl(pattern, name)) 
[08:28:16.463]                             next
[08:28:16.463]                           invokeRestart(restart)
[08:28:16.463]                           muffled <- TRUE
[08:28:16.463]                           break
[08:28:16.463]                         }
[08:28:16.463]                       }
[08:28:16.463]                     }
[08:28:16.463]                     invisible(muffled)
[08:28:16.463]                   }
[08:28:16.463]                   muffleCondition(cond)
[08:28:16.463]                 })
[08:28:16.463]             }))
[08:28:16.463]             future::FutureResult(value = ...future.value$value, 
[08:28:16.463]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.463]                   ...future.rng), globalenv = if (FALSE) 
[08:28:16.463]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:16.463]                     ...future.globalenv.names))
[08:28:16.463]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:16.463]         }, condition = base::local({
[08:28:16.463]             c <- base::c
[08:28:16.463]             inherits <- base::inherits
[08:28:16.463]             invokeRestart <- base::invokeRestart
[08:28:16.463]             length <- base::length
[08:28:16.463]             list <- base::list
[08:28:16.463]             seq.int <- base::seq.int
[08:28:16.463]             signalCondition <- base::signalCondition
[08:28:16.463]             sys.calls <- base::sys.calls
[08:28:16.463]             `[[` <- base::`[[`
[08:28:16.463]             `+` <- base::`+`
[08:28:16.463]             `<<-` <- base::`<<-`
[08:28:16.463]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:16.463]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:16.463]                   3L)]
[08:28:16.463]             }
[08:28:16.463]             function(cond) {
[08:28:16.463]                 is_error <- inherits(cond, "error")
[08:28:16.463]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:16.463]                   NULL)
[08:28:16.463]                 if (is_error) {
[08:28:16.463]                   sessionInformation <- function() {
[08:28:16.463]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:16.463]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:16.463]                       search = base::search(), system = base::Sys.info())
[08:28:16.463]                   }
[08:28:16.463]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.463]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:16.463]                     cond$call), session = sessionInformation(), 
[08:28:16.463]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:16.463]                   signalCondition(cond)
[08:28:16.463]                 }
[08:28:16.463]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:16.463]                 "immediateCondition"))) {
[08:28:16.463]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:16.463]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.463]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:16.463]                   if (TRUE && !signal) {
[08:28:16.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.463]                     {
[08:28:16.463]                       inherits <- base::inherits
[08:28:16.463]                       invokeRestart <- base::invokeRestart
[08:28:16.463]                       is.null <- base::is.null
[08:28:16.463]                       muffled <- FALSE
[08:28:16.463]                       if (inherits(cond, "message")) {
[08:28:16.463]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.463]                         if (muffled) 
[08:28:16.463]                           invokeRestart("muffleMessage")
[08:28:16.463]                       }
[08:28:16.463]                       else if (inherits(cond, "warning")) {
[08:28:16.463]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.463]                         if (muffled) 
[08:28:16.463]                           invokeRestart("muffleWarning")
[08:28:16.463]                       }
[08:28:16.463]                       else if (inherits(cond, "condition")) {
[08:28:16.463]                         if (!is.null(pattern)) {
[08:28:16.463]                           computeRestarts <- base::computeRestarts
[08:28:16.463]                           grepl <- base::grepl
[08:28:16.463]                           restarts <- computeRestarts(cond)
[08:28:16.463]                           for (restart in restarts) {
[08:28:16.463]                             name <- restart$name
[08:28:16.463]                             if (is.null(name)) 
[08:28:16.463]                               next
[08:28:16.463]                             if (!grepl(pattern, name)) 
[08:28:16.463]                               next
[08:28:16.463]                             invokeRestart(restart)
[08:28:16.463]                             muffled <- TRUE
[08:28:16.463]                             break
[08:28:16.463]                           }
[08:28:16.463]                         }
[08:28:16.463]                       }
[08:28:16.463]                       invisible(muffled)
[08:28:16.463]                     }
[08:28:16.463]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.463]                   }
[08:28:16.463]                 }
[08:28:16.463]                 else {
[08:28:16.463]                   if (TRUE) {
[08:28:16.463]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.463]                     {
[08:28:16.463]                       inherits <- base::inherits
[08:28:16.463]                       invokeRestart <- base::invokeRestart
[08:28:16.463]                       is.null <- base::is.null
[08:28:16.463]                       muffled <- FALSE
[08:28:16.463]                       if (inherits(cond, "message")) {
[08:28:16.463]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.463]                         if (muffled) 
[08:28:16.463]                           invokeRestart("muffleMessage")
[08:28:16.463]                       }
[08:28:16.463]                       else if (inherits(cond, "warning")) {
[08:28:16.463]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.463]                         if (muffled) 
[08:28:16.463]                           invokeRestart("muffleWarning")
[08:28:16.463]                       }
[08:28:16.463]                       else if (inherits(cond, "condition")) {
[08:28:16.463]                         if (!is.null(pattern)) {
[08:28:16.463]                           computeRestarts <- base::computeRestarts
[08:28:16.463]                           grepl <- base::grepl
[08:28:16.463]                           restarts <- computeRestarts(cond)
[08:28:16.463]                           for (restart in restarts) {
[08:28:16.463]                             name <- restart$name
[08:28:16.463]                             if (is.null(name)) 
[08:28:16.463]                               next
[08:28:16.463]                             if (!grepl(pattern, name)) 
[08:28:16.463]                               next
[08:28:16.463]                             invokeRestart(restart)
[08:28:16.463]                             muffled <- TRUE
[08:28:16.463]                             break
[08:28:16.463]                           }
[08:28:16.463]                         }
[08:28:16.463]                       }
[08:28:16.463]                       invisible(muffled)
[08:28:16.463]                     }
[08:28:16.463]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.463]                   }
[08:28:16.463]                 }
[08:28:16.463]             }
[08:28:16.463]         }))
[08:28:16.463]     }, error = function(ex) {
[08:28:16.463]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:16.463]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.463]                 ...future.rng), started = ...future.startTime, 
[08:28:16.463]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:16.463]             version = "1.8"), class = "FutureResult")
[08:28:16.463]     }, finally = {
[08:28:16.463]         if (!identical(...future.workdir, getwd())) 
[08:28:16.463]             setwd(...future.workdir)
[08:28:16.463]         {
[08:28:16.463]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:16.463]                 ...future.oldOptions$nwarnings <- NULL
[08:28:16.463]             }
[08:28:16.463]             base::options(...future.oldOptions)
[08:28:16.463]             if (.Platform$OS.type == "windows") {
[08:28:16.463]                 old_names <- names(...future.oldEnvVars)
[08:28:16.463]                 envs <- base::Sys.getenv()
[08:28:16.463]                 names <- names(envs)
[08:28:16.463]                 common <- intersect(names, old_names)
[08:28:16.463]                 added <- setdiff(names, old_names)
[08:28:16.463]                 removed <- setdiff(old_names, names)
[08:28:16.463]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:16.463]                   envs[common]]
[08:28:16.463]                 NAMES <- toupper(changed)
[08:28:16.463]                 args <- list()
[08:28:16.463]                 for (kk in seq_along(NAMES)) {
[08:28:16.463]                   name <- changed[[kk]]
[08:28:16.463]                   NAME <- NAMES[[kk]]
[08:28:16.463]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.463]                     next
[08:28:16.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.463]                 }
[08:28:16.463]                 NAMES <- toupper(added)
[08:28:16.463]                 for (kk in seq_along(NAMES)) {
[08:28:16.463]                   name <- added[[kk]]
[08:28:16.463]                   NAME <- NAMES[[kk]]
[08:28:16.463]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.463]                     next
[08:28:16.463]                   args[[name]] <- ""
[08:28:16.463]                 }
[08:28:16.463]                 NAMES <- toupper(removed)
[08:28:16.463]                 for (kk in seq_along(NAMES)) {
[08:28:16.463]                   name <- removed[[kk]]
[08:28:16.463]                   NAME <- NAMES[[kk]]
[08:28:16.463]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.463]                     next
[08:28:16.463]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.463]                 }
[08:28:16.463]                 if (length(args) > 0) 
[08:28:16.463]                   base::do.call(base::Sys.setenv, args = args)
[08:28:16.463]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:16.463]             }
[08:28:16.463]             else {
[08:28:16.463]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:16.463]             }
[08:28:16.463]             {
[08:28:16.463]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:16.463]                   0L) {
[08:28:16.463]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:16.463]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:16.463]                   base::options(opts)
[08:28:16.463]                 }
[08:28:16.463]                 {
[08:28:16.463]                   {
[08:28:16.463]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:16.463]                     NULL
[08:28:16.463]                   }
[08:28:16.463]                   options(future.plan = NULL)
[08:28:16.463]                   if (is.na(NA_character_)) 
[08:28:16.463]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.463]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:16.463]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:16.463]                     .init = FALSE)
[08:28:16.463]                 }
[08:28:16.463]             }
[08:28:16.463]         }
[08:28:16.463]     })
[08:28:16.463]     if (TRUE) {
[08:28:16.463]         base::sink(type = "output", split = FALSE)
[08:28:16.463]         if (TRUE) {
[08:28:16.463]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:16.463]         }
[08:28:16.463]         else {
[08:28:16.463]             ...future.result["stdout"] <- base::list(NULL)
[08:28:16.463]         }
[08:28:16.463]         base::close(...future.stdout)
[08:28:16.463]         ...future.stdout <- NULL
[08:28:16.463]     }
[08:28:16.463]     ...future.result$conditions <- ...future.conditions
[08:28:16.463]     ...future.result$finished <- base::Sys.time()
[08:28:16.463]     ...future.result
[08:28:16.463] }
[08:28:16.516] MultisessionFuture started
[08:28:16.516] result() for ClusterFuture ...
[08:28:16.516] receiveMessageFromWorker() for ClusterFuture ...
[08:28:16.516] - Validating connection of MultisessionFuture
[08:28:16.547] - received message: FutureResult
[08:28:16.547] - Received FutureResult
[08:28:16.547] - Erased future from FutureRegistry
[08:28:16.548] result() for ClusterFuture ...
[08:28:16.548] - result already collected: FutureResult
[08:28:16.548] result() for ClusterFuture ... done
[08:28:16.548] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:16.548] result() for ClusterFuture ... done
[08:28:16.548] result() for ClusterFuture ...
[08:28:16.548] - result already collected: FutureResult
[08:28:16.548] result() for ClusterFuture ... done
[08:28:16.548] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[08:28:16.550] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.551] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.551] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.553] - globals found: [3] ‘{’, ‘<-’, ‘*’
[08:28:16.553] Searching for globals ... DONE
[08:28:16.553] Resolving globals: TRUE
[08:28:16.553] Resolving any globals that are futures ...
[08:28:16.553] - globals: [3] ‘{’, ‘<-’, ‘*’
[08:28:16.553] Resolving any globals that are futures ... DONE
[08:28:16.553] 
[08:28:16.553] 
[08:28:16.554] getGlobalsAndPackages() ... DONE
[08:28:16.554] run() for ‘Future’ ...
[08:28:16.554] - state: ‘created’
[08:28:16.554] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:16.568] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:16.568] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:16.568]   - Field: ‘node’
[08:28:16.568]   - Field: ‘label’
[08:28:16.568]   - Field: ‘local’
[08:28:16.568]   - Field: ‘owner’
[08:28:16.568]   - Field: ‘envir’
[08:28:16.568]   - Field: ‘workers’
[08:28:16.568]   - Field: ‘packages’
[08:28:16.569]   - Field: ‘gc’
[08:28:16.569]   - Field: ‘conditions’
[08:28:16.569]   - Field: ‘persistent’
[08:28:16.569]   - Field: ‘expr’
[08:28:16.569]   - Field: ‘uuid’
[08:28:16.569]   - Field: ‘seed’
[08:28:16.569]   - Field: ‘version’
[08:28:16.569]   - Field: ‘result’
[08:28:16.569]   - Field: ‘asynchronous’
[08:28:16.569]   - Field: ‘calls’
[08:28:16.569]   - Field: ‘globals’
[08:28:16.569]   - Field: ‘stdout’
[08:28:16.569]   - Field: ‘earlySignal’
[08:28:16.570]   - Field: ‘lazy’
[08:28:16.570]   - Field: ‘state’
[08:28:16.570] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:16.570] - Launch lazy future ...
[08:28:16.570] Packages needed by the future expression (n = 0): <none>
[08:28:16.570] Packages needed by future strategies (n = 0): <none>
[08:28:16.571] {
[08:28:16.571]     {
[08:28:16.571]         {
[08:28:16.571]             ...future.startTime <- base::Sys.time()
[08:28:16.571]             {
[08:28:16.571]                 {
[08:28:16.571]                   {
[08:28:16.571]                     {
[08:28:16.571]                       base::local({
[08:28:16.571]                         has_future <- base::requireNamespace("future", 
[08:28:16.571]                           quietly = TRUE)
[08:28:16.571]                         if (has_future) {
[08:28:16.571]                           ns <- base::getNamespace("future")
[08:28:16.571]                           version <- ns[[".package"]][["version"]]
[08:28:16.571]                           if (is.null(version)) 
[08:28:16.571]                             version <- utils::packageVersion("future")
[08:28:16.571]                         }
[08:28:16.571]                         else {
[08:28:16.571]                           version <- NULL
[08:28:16.571]                         }
[08:28:16.571]                         if (!has_future || version < "1.8.0") {
[08:28:16.571]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:16.571]                             "", base::R.version$version.string), 
[08:28:16.571]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:16.571]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:16.571]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:16.571]                               "release", "version")], collapse = " "), 
[08:28:16.571]                             hostname = base::Sys.info()[["nodename"]])
[08:28:16.571]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:16.571]                             info)
[08:28:16.571]                           info <- base::paste(info, collapse = "; ")
[08:28:16.571]                           if (!has_future) {
[08:28:16.571]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:16.571]                               info)
[08:28:16.571]                           }
[08:28:16.571]                           else {
[08:28:16.571]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:16.571]                               info, version)
[08:28:16.571]                           }
[08:28:16.571]                           base::stop(msg)
[08:28:16.571]                         }
[08:28:16.571]                       })
[08:28:16.571]                     }
[08:28:16.571]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:16.571]                     base::options(mc.cores = 1L)
[08:28:16.571]                   }
[08:28:16.571]                   ...future.strategy.old <- future::plan("list")
[08:28:16.571]                   options(future.plan = NULL)
[08:28:16.571]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.571]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:16.571]                 }
[08:28:16.571]                 ...future.workdir <- getwd()
[08:28:16.571]             }
[08:28:16.571]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:16.571]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:16.571]         }
[08:28:16.571]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:16.571]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:16.571]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:16.571]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:16.571]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:16.571]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:16.571]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:16.571]             base::names(...future.oldOptions))
[08:28:16.571]     }
[08:28:16.571]     if (FALSE) {
[08:28:16.571]     }
[08:28:16.571]     else {
[08:28:16.571]         if (TRUE) {
[08:28:16.571]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:16.571]                 open = "w")
[08:28:16.571]         }
[08:28:16.571]         else {
[08:28:16.571]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:16.571]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:16.571]         }
[08:28:16.571]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:16.571]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:16.571]             base::sink(type = "output", split = FALSE)
[08:28:16.571]             base::close(...future.stdout)
[08:28:16.571]         }, add = TRUE)
[08:28:16.571]     }
[08:28:16.571]     ...future.frame <- base::sys.nframe()
[08:28:16.571]     ...future.conditions <- base::list()
[08:28:16.571]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:16.571]     if (FALSE) {
[08:28:16.571]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:16.571]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:16.571]     }
[08:28:16.571]     ...future.result <- base::tryCatch({
[08:28:16.571]         base::withCallingHandlers({
[08:28:16.571]             ...future.value <- base::withVisible(base::local({
[08:28:16.571]                 ...future.makeSendCondition <- base::local({
[08:28:16.571]                   sendCondition <- NULL
[08:28:16.571]                   function(frame = 1L) {
[08:28:16.571]                     if (is.function(sendCondition)) 
[08:28:16.571]                       return(sendCondition)
[08:28:16.571]                     ns <- getNamespace("parallel")
[08:28:16.571]                     if (exists("sendData", mode = "function", 
[08:28:16.571]                       envir = ns)) {
[08:28:16.571]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:16.571]                         envir = ns)
[08:28:16.571]                       envir <- sys.frame(frame)
[08:28:16.571]                       master <- NULL
[08:28:16.571]                       while (!identical(envir, .GlobalEnv) && 
[08:28:16.571]                         !identical(envir, emptyenv())) {
[08:28:16.571]                         if (exists("master", mode = "list", envir = envir, 
[08:28:16.571]                           inherits = FALSE)) {
[08:28:16.571]                           master <- get("master", mode = "list", 
[08:28:16.571]                             envir = envir, inherits = FALSE)
[08:28:16.571]                           if (inherits(master, c("SOCKnode", 
[08:28:16.571]                             "SOCK0node"))) {
[08:28:16.571]                             sendCondition <<- function(cond) {
[08:28:16.571]                               data <- list(type = "VALUE", value = cond, 
[08:28:16.571]                                 success = TRUE)
[08:28:16.571]                               parallel_sendData(master, data)
[08:28:16.571]                             }
[08:28:16.571]                             return(sendCondition)
[08:28:16.571]                           }
[08:28:16.571]                         }
[08:28:16.571]                         frame <- frame + 1L
[08:28:16.571]                         envir <- sys.frame(frame)
[08:28:16.571]                       }
[08:28:16.571]                     }
[08:28:16.571]                     sendCondition <<- function(cond) NULL
[08:28:16.571]                   }
[08:28:16.571]                 })
[08:28:16.571]                 withCallingHandlers({
[08:28:16.571]                   {
[08:28:16.571]                     b <- a
[08:28:16.571]                     a <- 2
[08:28:16.571]                     a * b
[08:28:16.571]                   }
[08:28:16.571]                 }, immediateCondition = function(cond) {
[08:28:16.571]                   sendCondition <- ...future.makeSendCondition()
[08:28:16.571]                   sendCondition(cond)
[08:28:16.571]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.571]                   {
[08:28:16.571]                     inherits <- base::inherits
[08:28:16.571]                     invokeRestart <- base::invokeRestart
[08:28:16.571]                     is.null <- base::is.null
[08:28:16.571]                     muffled <- FALSE
[08:28:16.571]                     if (inherits(cond, "message")) {
[08:28:16.571]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:16.571]                       if (muffled) 
[08:28:16.571]                         invokeRestart("muffleMessage")
[08:28:16.571]                     }
[08:28:16.571]                     else if (inherits(cond, "warning")) {
[08:28:16.571]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:16.571]                       if (muffled) 
[08:28:16.571]                         invokeRestart("muffleWarning")
[08:28:16.571]                     }
[08:28:16.571]                     else if (inherits(cond, "condition")) {
[08:28:16.571]                       if (!is.null(pattern)) {
[08:28:16.571]                         computeRestarts <- base::computeRestarts
[08:28:16.571]                         grepl <- base::grepl
[08:28:16.571]                         restarts <- computeRestarts(cond)
[08:28:16.571]                         for (restart in restarts) {
[08:28:16.571]                           name <- restart$name
[08:28:16.571]                           if (is.null(name)) 
[08:28:16.571]                             next
[08:28:16.571]                           if (!grepl(pattern, name)) 
[08:28:16.571]                             next
[08:28:16.571]                           invokeRestart(restart)
[08:28:16.571]                           muffled <- TRUE
[08:28:16.571]                           break
[08:28:16.571]                         }
[08:28:16.571]                       }
[08:28:16.571]                     }
[08:28:16.571]                     invisible(muffled)
[08:28:16.571]                   }
[08:28:16.571]                   muffleCondition(cond)
[08:28:16.571]                 })
[08:28:16.571]             }))
[08:28:16.571]             future::FutureResult(value = ...future.value$value, 
[08:28:16.571]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.571]                   ...future.rng), globalenv = if (FALSE) 
[08:28:16.571]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:16.571]                     ...future.globalenv.names))
[08:28:16.571]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:16.571]         }, condition = base::local({
[08:28:16.571]             c <- base::c
[08:28:16.571]             inherits <- base::inherits
[08:28:16.571]             invokeRestart <- base::invokeRestart
[08:28:16.571]             length <- base::length
[08:28:16.571]             list <- base::list
[08:28:16.571]             seq.int <- base::seq.int
[08:28:16.571]             signalCondition <- base::signalCondition
[08:28:16.571]             sys.calls <- base::sys.calls
[08:28:16.571]             `[[` <- base::`[[`
[08:28:16.571]             `+` <- base::`+`
[08:28:16.571]             `<<-` <- base::`<<-`
[08:28:16.571]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:16.571]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:16.571]                   3L)]
[08:28:16.571]             }
[08:28:16.571]             function(cond) {
[08:28:16.571]                 is_error <- inherits(cond, "error")
[08:28:16.571]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:16.571]                   NULL)
[08:28:16.571]                 if (is_error) {
[08:28:16.571]                   sessionInformation <- function() {
[08:28:16.571]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:16.571]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:16.571]                       search = base::search(), system = base::Sys.info())
[08:28:16.571]                   }
[08:28:16.571]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.571]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:16.571]                     cond$call), session = sessionInformation(), 
[08:28:16.571]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:16.571]                   signalCondition(cond)
[08:28:16.571]                 }
[08:28:16.571]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:16.571]                 "immediateCondition"))) {
[08:28:16.571]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:16.571]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.571]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:16.571]                   if (TRUE && !signal) {
[08:28:16.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.571]                     {
[08:28:16.571]                       inherits <- base::inherits
[08:28:16.571]                       invokeRestart <- base::invokeRestart
[08:28:16.571]                       is.null <- base::is.null
[08:28:16.571]                       muffled <- FALSE
[08:28:16.571]                       if (inherits(cond, "message")) {
[08:28:16.571]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.571]                         if (muffled) 
[08:28:16.571]                           invokeRestart("muffleMessage")
[08:28:16.571]                       }
[08:28:16.571]                       else if (inherits(cond, "warning")) {
[08:28:16.571]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.571]                         if (muffled) 
[08:28:16.571]                           invokeRestart("muffleWarning")
[08:28:16.571]                       }
[08:28:16.571]                       else if (inherits(cond, "condition")) {
[08:28:16.571]                         if (!is.null(pattern)) {
[08:28:16.571]                           computeRestarts <- base::computeRestarts
[08:28:16.571]                           grepl <- base::grepl
[08:28:16.571]                           restarts <- computeRestarts(cond)
[08:28:16.571]                           for (restart in restarts) {
[08:28:16.571]                             name <- restart$name
[08:28:16.571]                             if (is.null(name)) 
[08:28:16.571]                               next
[08:28:16.571]                             if (!grepl(pattern, name)) 
[08:28:16.571]                               next
[08:28:16.571]                             invokeRestart(restart)
[08:28:16.571]                             muffled <- TRUE
[08:28:16.571]                             break
[08:28:16.571]                           }
[08:28:16.571]                         }
[08:28:16.571]                       }
[08:28:16.571]                       invisible(muffled)
[08:28:16.571]                     }
[08:28:16.571]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.571]                   }
[08:28:16.571]                 }
[08:28:16.571]                 else {
[08:28:16.571]                   if (TRUE) {
[08:28:16.571]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.571]                     {
[08:28:16.571]                       inherits <- base::inherits
[08:28:16.571]                       invokeRestart <- base::invokeRestart
[08:28:16.571]                       is.null <- base::is.null
[08:28:16.571]                       muffled <- FALSE
[08:28:16.571]                       if (inherits(cond, "message")) {
[08:28:16.571]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.571]                         if (muffled) 
[08:28:16.571]                           invokeRestart("muffleMessage")
[08:28:16.571]                       }
[08:28:16.571]                       else if (inherits(cond, "warning")) {
[08:28:16.571]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.571]                         if (muffled) 
[08:28:16.571]                           invokeRestart("muffleWarning")
[08:28:16.571]                       }
[08:28:16.571]                       else if (inherits(cond, "condition")) {
[08:28:16.571]                         if (!is.null(pattern)) {
[08:28:16.571]                           computeRestarts <- base::computeRestarts
[08:28:16.571]                           grepl <- base::grepl
[08:28:16.571]                           restarts <- computeRestarts(cond)
[08:28:16.571]                           for (restart in restarts) {
[08:28:16.571]                             name <- restart$name
[08:28:16.571]                             if (is.null(name)) 
[08:28:16.571]                               next
[08:28:16.571]                             if (!grepl(pattern, name)) 
[08:28:16.571]                               next
[08:28:16.571]                             invokeRestart(restart)
[08:28:16.571]                             muffled <- TRUE
[08:28:16.571]                             break
[08:28:16.571]                           }
[08:28:16.571]                         }
[08:28:16.571]                       }
[08:28:16.571]                       invisible(muffled)
[08:28:16.571]                     }
[08:28:16.571]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.571]                   }
[08:28:16.571]                 }
[08:28:16.571]             }
[08:28:16.571]         }))
[08:28:16.571]     }, error = function(ex) {
[08:28:16.571]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:16.571]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.571]                 ...future.rng), started = ...future.startTime, 
[08:28:16.571]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:16.571]             version = "1.8"), class = "FutureResult")
[08:28:16.571]     }, finally = {
[08:28:16.571]         if (!identical(...future.workdir, getwd())) 
[08:28:16.571]             setwd(...future.workdir)
[08:28:16.571]         {
[08:28:16.571]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:16.571]                 ...future.oldOptions$nwarnings <- NULL
[08:28:16.571]             }
[08:28:16.571]             base::options(...future.oldOptions)
[08:28:16.571]             if (.Platform$OS.type == "windows") {
[08:28:16.571]                 old_names <- names(...future.oldEnvVars)
[08:28:16.571]                 envs <- base::Sys.getenv()
[08:28:16.571]                 names <- names(envs)
[08:28:16.571]                 common <- intersect(names, old_names)
[08:28:16.571]                 added <- setdiff(names, old_names)
[08:28:16.571]                 removed <- setdiff(old_names, names)
[08:28:16.571]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:16.571]                   envs[common]]
[08:28:16.571]                 NAMES <- toupper(changed)
[08:28:16.571]                 args <- list()
[08:28:16.571]                 for (kk in seq_along(NAMES)) {
[08:28:16.571]                   name <- changed[[kk]]
[08:28:16.571]                   NAME <- NAMES[[kk]]
[08:28:16.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.571]                     next
[08:28:16.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.571]                 }
[08:28:16.571]                 NAMES <- toupper(added)
[08:28:16.571]                 for (kk in seq_along(NAMES)) {
[08:28:16.571]                   name <- added[[kk]]
[08:28:16.571]                   NAME <- NAMES[[kk]]
[08:28:16.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.571]                     next
[08:28:16.571]                   args[[name]] <- ""
[08:28:16.571]                 }
[08:28:16.571]                 NAMES <- toupper(removed)
[08:28:16.571]                 for (kk in seq_along(NAMES)) {
[08:28:16.571]                   name <- removed[[kk]]
[08:28:16.571]                   NAME <- NAMES[[kk]]
[08:28:16.571]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.571]                     next
[08:28:16.571]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.571]                 }
[08:28:16.571]                 if (length(args) > 0) 
[08:28:16.571]                   base::do.call(base::Sys.setenv, args = args)
[08:28:16.571]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:16.571]             }
[08:28:16.571]             else {
[08:28:16.571]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:16.571]             }
[08:28:16.571]             {
[08:28:16.571]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:16.571]                   0L) {
[08:28:16.571]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:16.571]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:16.571]                   base::options(opts)
[08:28:16.571]                 }
[08:28:16.571]                 {
[08:28:16.571]                   {
[08:28:16.571]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:16.571]                     NULL
[08:28:16.571]                   }
[08:28:16.571]                   options(future.plan = NULL)
[08:28:16.571]                   if (is.na(NA_character_)) 
[08:28:16.571]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.571]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:16.571]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:16.571]                     .init = FALSE)
[08:28:16.571]                 }
[08:28:16.571]             }
[08:28:16.571]         }
[08:28:16.571]     })
[08:28:16.571]     if (TRUE) {
[08:28:16.571]         base::sink(type = "output", split = FALSE)
[08:28:16.571]         if (TRUE) {
[08:28:16.571]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:16.571]         }
[08:28:16.571]         else {
[08:28:16.571]             ...future.result["stdout"] <- base::list(NULL)
[08:28:16.571]         }
[08:28:16.571]         base::close(...future.stdout)
[08:28:16.571]         ...future.stdout <- NULL
[08:28:16.571]     }
[08:28:16.571]     ...future.result$conditions <- ...future.conditions
[08:28:16.571]     ...future.result$finished <- base::Sys.time()
[08:28:16.571]     ...future.result
[08:28:16.571] }
[08:28:16.574] MultisessionFuture started
[08:28:16.574] - Launch lazy future ... done
[08:28:16.574] run() for ‘MultisessionFuture’ ... done
[08:28:16.574] result() for ClusterFuture ...
[08:28:16.574] receiveMessageFromWorker() for ClusterFuture ...
[08:28:16.574] - Validating connection of MultisessionFuture
[08:28:16.620] - received message: FutureResult
[08:28:16.620] - Received FutureResult
[08:28:16.621] - Erased future from FutureRegistry
[08:28:16.621] result() for ClusterFuture ...
[08:28:16.621] - result already collected: FutureResult
[08:28:16.621] result() for ClusterFuture ... done
[08:28:16.621] signalConditions() ...
[08:28:16.621]  - include = ‘immediateCondition’
[08:28:16.621]  - exclude = 
[08:28:16.621]  - resignal = FALSE
[08:28:16.621]  - Number of conditions: 1
[08:28:16.621] signalConditions() ... done
[08:28:16.621] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:16.622] result() for ClusterFuture ... done
[08:28:16.622] result() for ClusterFuture ...
[08:28:16.622] - result already collected: FutureResult
[08:28:16.622] result() for ClusterFuture ... done
[08:28:16.622] signalConditions() ...
[08:28:16.622]  - include = ‘immediateCondition’
[08:28:16.622]  - exclude = 
[08:28:16.622]  - resignal = FALSE
[08:28:16.622]  - Number of conditions: 1
[08:28:16.622] signalConditions() ... done
[08:28:16.622] Future state: ‘finished’
[08:28:16.623] result() for ClusterFuture ...
[08:28:16.623] - result already collected: FutureResult
[08:28:16.623] result() for ClusterFuture ... done
[08:28:16.623] signalConditions() ...
[08:28:16.623]  - include = ‘condition’
[08:28:16.623]  - exclude = ‘immediateCondition’
[08:28:16.623]  - resignal = TRUE
[08:28:16.623]  - Number of conditions: 1
[08:28:16.623]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:16.623] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:16"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.638] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.638] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.640] - globals found: [3] ‘{’, ‘<-’, ‘*’
[08:28:16.640] Searching for globals ... DONE
[08:28:16.640] Resolving globals: TRUE
[08:28:16.640] Resolving any globals that are futures ...
[08:28:16.641] - globals: [3] ‘{’, ‘<-’, ‘*’
[08:28:16.641] Resolving any globals that are futures ... DONE
[08:28:16.641] 
[08:28:16.641] 
[08:28:16.641] getGlobalsAndPackages() ... DONE
[08:28:16.642] run() for ‘Future’ ...
[08:28:16.642] - state: ‘created’
[08:28:16.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:16.657] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:16.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:16.657]   - Field: ‘node’
[08:28:16.657]   - Field: ‘label’
[08:28:16.657]   - Field: ‘local’
[08:28:16.657]   - Field: ‘owner’
[08:28:16.657]   - Field: ‘envir’
[08:28:16.657]   - Field: ‘workers’
[08:28:16.657]   - Field: ‘packages’
[08:28:16.657]   - Field: ‘gc’
[08:28:16.658]   - Field: ‘conditions’
[08:28:16.658]   - Field: ‘persistent’
[08:28:16.658]   - Field: ‘expr’
[08:28:16.658]   - Field: ‘uuid’
[08:28:16.658]   - Field: ‘seed’
[08:28:16.658]   - Field: ‘version’
[08:28:16.658]   - Field: ‘result’
[08:28:16.658]   - Field: ‘asynchronous’
[08:28:16.658]   - Field: ‘calls’
[08:28:16.659]   - Field: ‘globals’
[08:28:16.659]   - Field: ‘stdout’
[08:28:16.659]   - Field: ‘earlySignal’
[08:28:16.659]   - Field: ‘lazy’
[08:28:16.659]   - Field: ‘state’
[08:28:16.659] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:16.659] - Launch lazy future ...
[08:28:16.659] Packages needed by the future expression (n = 0): <none>
[08:28:16.660] Packages needed by future strategies (n = 0): <none>
[08:28:16.660] {
[08:28:16.660]     {
[08:28:16.660]         {
[08:28:16.660]             ...future.startTime <- base::Sys.time()
[08:28:16.660]             {
[08:28:16.660]                 {
[08:28:16.660]                   {
[08:28:16.660]                     {
[08:28:16.660]                       base::local({
[08:28:16.660]                         has_future <- base::requireNamespace("future", 
[08:28:16.660]                           quietly = TRUE)
[08:28:16.660]                         if (has_future) {
[08:28:16.660]                           ns <- base::getNamespace("future")
[08:28:16.660]                           version <- ns[[".package"]][["version"]]
[08:28:16.660]                           if (is.null(version)) 
[08:28:16.660]                             version <- utils::packageVersion("future")
[08:28:16.660]                         }
[08:28:16.660]                         else {
[08:28:16.660]                           version <- NULL
[08:28:16.660]                         }
[08:28:16.660]                         if (!has_future || version < "1.8.0") {
[08:28:16.660]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:16.660]                             "", base::R.version$version.string), 
[08:28:16.660]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:16.660]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:16.660]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:16.660]                               "release", "version")], collapse = " "), 
[08:28:16.660]                             hostname = base::Sys.info()[["nodename"]])
[08:28:16.660]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:16.660]                             info)
[08:28:16.660]                           info <- base::paste(info, collapse = "; ")
[08:28:16.660]                           if (!has_future) {
[08:28:16.660]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:16.660]                               info)
[08:28:16.660]                           }
[08:28:16.660]                           else {
[08:28:16.660]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:16.660]                               info, version)
[08:28:16.660]                           }
[08:28:16.660]                           base::stop(msg)
[08:28:16.660]                         }
[08:28:16.660]                       })
[08:28:16.660]                     }
[08:28:16.660]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:16.660]                     base::options(mc.cores = 1L)
[08:28:16.660]                   }
[08:28:16.660]                   ...future.strategy.old <- future::plan("list")
[08:28:16.660]                   options(future.plan = NULL)
[08:28:16.660]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.660]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:16.660]                 }
[08:28:16.660]                 ...future.workdir <- getwd()
[08:28:16.660]             }
[08:28:16.660]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:16.660]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:16.660]         }
[08:28:16.660]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:16.660]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:16.660]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:16.660]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:16.660]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:16.660]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:16.660]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:16.660]             base::names(...future.oldOptions))
[08:28:16.660]     }
[08:28:16.660]     if (FALSE) {
[08:28:16.660]     }
[08:28:16.660]     else {
[08:28:16.660]         if (TRUE) {
[08:28:16.660]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:16.660]                 open = "w")
[08:28:16.660]         }
[08:28:16.660]         else {
[08:28:16.660]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:16.660]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:16.660]         }
[08:28:16.660]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:16.660]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:16.660]             base::sink(type = "output", split = FALSE)
[08:28:16.660]             base::close(...future.stdout)
[08:28:16.660]         }, add = TRUE)
[08:28:16.660]     }
[08:28:16.660]     ...future.frame <- base::sys.nframe()
[08:28:16.660]     ...future.conditions <- base::list()
[08:28:16.660]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:16.660]     if (FALSE) {
[08:28:16.660]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:16.660]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:16.660]     }
[08:28:16.660]     ...future.result <- base::tryCatch({
[08:28:16.660]         base::withCallingHandlers({
[08:28:16.660]             ...future.value <- base::withVisible(base::local({
[08:28:16.660]                 ...future.makeSendCondition <- base::local({
[08:28:16.660]                   sendCondition <- NULL
[08:28:16.660]                   function(frame = 1L) {
[08:28:16.660]                     if (is.function(sendCondition)) 
[08:28:16.660]                       return(sendCondition)
[08:28:16.660]                     ns <- getNamespace("parallel")
[08:28:16.660]                     if (exists("sendData", mode = "function", 
[08:28:16.660]                       envir = ns)) {
[08:28:16.660]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:16.660]                         envir = ns)
[08:28:16.660]                       envir <- sys.frame(frame)
[08:28:16.660]                       master <- NULL
[08:28:16.660]                       while (!identical(envir, .GlobalEnv) && 
[08:28:16.660]                         !identical(envir, emptyenv())) {
[08:28:16.660]                         if (exists("master", mode = "list", envir = envir, 
[08:28:16.660]                           inherits = FALSE)) {
[08:28:16.660]                           master <- get("master", mode = "list", 
[08:28:16.660]                             envir = envir, inherits = FALSE)
[08:28:16.660]                           if (inherits(master, c("SOCKnode", 
[08:28:16.660]                             "SOCK0node"))) {
[08:28:16.660]                             sendCondition <<- function(cond) {
[08:28:16.660]                               data <- list(type = "VALUE", value = cond, 
[08:28:16.660]                                 success = TRUE)
[08:28:16.660]                               parallel_sendData(master, data)
[08:28:16.660]                             }
[08:28:16.660]                             return(sendCondition)
[08:28:16.660]                           }
[08:28:16.660]                         }
[08:28:16.660]                         frame <- frame + 1L
[08:28:16.660]                         envir <- sys.frame(frame)
[08:28:16.660]                       }
[08:28:16.660]                     }
[08:28:16.660]                     sendCondition <<- function(cond) NULL
[08:28:16.660]                   }
[08:28:16.660]                 })
[08:28:16.660]                 withCallingHandlers({
[08:28:16.660]                   {
[08:28:16.660]                     b <- a
[08:28:16.660]                     a <- 2
[08:28:16.660]                     a * b
[08:28:16.660]                   }
[08:28:16.660]                 }, immediateCondition = function(cond) {
[08:28:16.660]                   sendCondition <- ...future.makeSendCondition()
[08:28:16.660]                   sendCondition(cond)
[08:28:16.660]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.660]                   {
[08:28:16.660]                     inherits <- base::inherits
[08:28:16.660]                     invokeRestart <- base::invokeRestart
[08:28:16.660]                     is.null <- base::is.null
[08:28:16.660]                     muffled <- FALSE
[08:28:16.660]                     if (inherits(cond, "message")) {
[08:28:16.660]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:16.660]                       if (muffled) 
[08:28:16.660]                         invokeRestart("muffleMessage")
[08:28:16.660]                     }
[08:28:16.660]                     else if (inherits(cond, "warning")) {
[08:28:16.660]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:16.660]                       if (muffled) 
[08:28:16.660]                         invokeRestart("muffleWarning")
[08:28:16.660]                     }
[08:28:16.660]                     else if (inherits(cond, "condition")) {
[08:28:16.660]                       if (!is.null(pattern)) {
[08:28:16.660]                         computeRestarts <- base::computeRestarts
[08:28:16.660]                         grepl <- base::grepl
[08:28:16.660]                         restarts <- computeRestarts(cond)
[08:28:16.660]                         for (restart in restarts) {
[08:28:16.660]                           name <- restart$name
[08:28:16.660]                           if (is.null(name)) 
[08:28:16.660]                             next
[08:28:16.660]                           if (!grepl(pattern, name)) 
[08:28:16.660]                             next
[08:28:16.660]                           invokeRestart(restart)
[08:28:16.660]                           muffled <- TRUE
[08:28:16.660]                           break
[08:28:16.660]                         }
[08:28:16.660]                       }
[08:28:16.660]                     }
[08:28:16.660]                     invisible(muffled)
[08:28:16.660]                   }
[08:28:16.660]                   muffleCondition(cond)
[08:28:16.660]                 })
[08:28:16.660]             }))
[08:28:16.660]             future::FutureResult(value = ...future.value$value, 
[08:28:16.660]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.660]                   ...future.rng), globalenv = if (FALSE) 
[08:28:16.660]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:16.660]                     ...future.globalenv.names))
[08:28:16.660]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:16.660]         }, condition = base::local({
[08:28:16.660]             c <- base::c
[08:28:16.660]             inherits <- base::inherits
[08:28:16.660]             invokeRestart <- base::invokeRestart
[08:28:16.660]             length <- base::length
[08:28:16.660]             list <- base::list
[08:28:16.660]             seq.int <- base::seq.int
[08:28:16.660]             signalCondition <- base::signalCondition
[08:28:16.660]             sys.calls <- base::sys.calls
[08:28:16.660]             `[[` <- base::`[[`
[08:28:16.660]             `+` <- base::`+`
[08:28:16.660]             `<<-` <- base::`<<-`
[08:28:16.660]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:16.660]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:16.660]                   3L)]
[08:28:16.660]             }
[08:28:16.660]             function(cond) {
[08:28:16.660]                 is_error <- inherits(cond, "error")
[08:28:16.660]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:16.660]                   NULL)
[08:28:16.660]                 if (is_error) {
[08:28:16.660]                   sessionInformation <- function() {
[08:28:16.660]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:16.660]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:16.660]                       search = base::search(), system = base::Sys.info())
[08:28:16.660]                   }
[08:28:16.660]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.660]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:16.660]                     cond$call), session = sessionInformation(), 
[08:28:16.660]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:16.660]                   signalCondition(cond)
[08:28:16.660]                 }
[08:28:16.660]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:16.660]                 "immediateCondition"))) {
[08:28:16.660]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:16.660]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.660]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:16.660]                   if (TRUE && !signal) {
[08:28:16.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.660]                     {
[08:28:16.660]                       inherits <- base::inherits
[08:28:16.660]                       invokeRestart <- base::invokeRestart
[08:28:16.660]                       is.null <- base::is.null
[08:28:16.660]                       muffled <- FALSE
[08:28:16.660]                       if (inherits(cond, "message")) {
[08:28:16.660]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.660]                         if (muffled) 
[08:28:16.660]                           invokeRestart("muffleMessage")
[08:28:16.660]                       }
[08:28:16.660]                       else if (inherits(cond, "warning")) {
[08:28:16.660]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.660]                         if (muffled) 
[08:28:16.660]                           invokeRestart("muffleWarning")
[08:28:16.660]                       }
[08:28:16.660]                       else if (inherits(cond, "condition")) {
[08:28:16.660]                         if (!is.null(pattern)) {
[08:28:16.660]                           computeRestarts <- base::computeRestarts
[08:28:16.660]                           grepl <- base::grepl
[08:28:16.660]                           restarts <- computeRestarts(cond)
[08:28:16.660]                           for (restart in restarts) {
[08:28:16.660]                             name <- restart$name
[08:28:16.660]                             if (is.null(name)) 
[08:28:16.660]                               next
[08:28:16.660]                             if (!grepl(pattern, name)) 
[08:28:16.660]                               next
[08:28:16.660]                             invokeRestart(restart)
[08:28:16.660]                             muffled <- TRUE
[08:28:16.660]                             break
[08:28:16.660]                           }
[08:28:16.660]                         }
[08:28:16.660]                       }
[08:28:16.660]                       invisible(muffled)
[08:28:16.660]                     }
[08:28:16.660]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.660]                   }
[08:28:16.660]                 }
[08:28:16.660]                 else {
[08:28:16.660]                   if (TRUE) {
[08:28:16.660]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.660]                     {
[08:28:16.660]                       inherits <- base::inherits
[08:28:16.660]                       invokeRestart <- base::invokeRestart
[08:28:16.660]                       is.null <- base::is.null
[08:28:16.660]                       muffled <- FALSE
[08:28:16.660]                       if (inherits(cond, "message")) {
[08:28:16.660]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.660]                         if (muffled) 
[08:28:16.660]                           invokeRestart("muffleMessage")
[08:28:16.660]                       }
[08:28:16.660]                       else if (inherits(cond, "warning")) {
[08:28:16.660]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.660]                         if (muffled) 
[08:28:16.660]                           invokeRestart("muffleWarning")
[08:28:16.660]                       }
[08:28:16.660]                       else if (inherits(cond, "condition")) {
[08:28:16.660]                         if (!is.null(pattern)) {
[08:28:16.660]                           computeRestarts <- base::computeRestarts
[08:28:16.660]                           grepl <- base::grepl
[08:28:16.660]                           restarts <- computeRestarts(cond)
[08:28:16.660]                           for (restart in restarts) {
[08:28:16.660]                             name <- restart$name
[08:28:16.660]                             if (is.null(name)) 
[08:28:16.660]                               next
[08:28:16.660]                             if (!grepl(pattern, name)) 
[08:28:16.660]                               next
[08:28:16.660]                             invokeRestart(restart)
[08:28:16.660]                             muffled <- TRUE
[08:28:16.660]                             break
[08:28:16.660]                           }
[08:28:16.660]                         }
[08:28:16.660]                       }
[08:28:16.660]                       invisible(muffled)
[08:28:16.660]                     }
[08:28:16.660]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.660]                   }
[08:28:16.660]                 }
[08:28:16.660]             }
[08:28:16.660]         }))
[08:28:16.660]     }, error = function(ex) {
[08:28:16.660]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:16.660]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.660]                 ...future.rng), started = ...future.startTime, 
[08:28:16.660]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:16.660]             version = "1.8"), class = "FutureResult")
[08:28:16.660]     }, finally = {
[08:28:16.660]         if (!identical(...future.workdir, getwd())) 
[08:28:16.660]             setwd(...future.workdir)
[08:28:16.660]         {
[08:28:16.660]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:16.660]                 ...future.oldOptions$nwarnings <- NULL
[08:28:16.660]             }
[08:28:16.660]             base::options(...future.oldOptions)
[08:28:16.660]             if (.Platform$OS.type == "windows") {
[08:28:16.660]                 old_names <- names(...future.oldEnvVars)
[08:28:16.660]                 envs <- base::Sys.getenv()
[08:28:16.660]                 names <- names(envs)
[08:28:16.660]                 common <- intersect(names, old_names)
[08:28:16.660]                 added <- setdiff(names, old_names)
[08:28:16.660]                 removed <- setdiff(old_names, names)
[08:28:16.660]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:16.660]                   envs[common]]
[08:28:16.660]                 NAMES <- toupper(changed)
[08:28:16.660]                 args <- list()
[08:28:16.660]                 for (kk in seq_along(NAMES)) {
[08:28:16.660]                   name <- changed[[kk]]
[08:28:16.660]                   NAME <- NAMES[[kk]]
[08:28:16.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.660]                     next
[08:28:16.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.660]                 }
[08:28:16.660]                 NAMES <- toupper(added)
[08:28:16.660]                 for (kk in seq_along(NAMES)) {
[08:28:16.660]                   name <- added[[kk]]
[08:28:16.660]                   NAME <- NAMES[[kk]]
[08:28:16.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.660]                     next
[08:28:16.660]                   args[[name]] <- ""
[08:28:16.660]                 }
[08:28:16.660]                 NAMES <- toupper(removed)
[08:28:16.660]                 for (kk in seq_along(NAMES)) {
[08:28:16.660]                   name <- removed[[kk]]
[08:28:16.660]                   NAME <- NAMES[[kk]]
[08:28:16.660]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.660]                     next
[08:28:16.660]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.660]                 }
[08:28:16.660]                 if (length(args) > 0) 
[08:28:16.660]                   base::do.call(base::Sys.setenv, args = args)
[08:28:16.660]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:16.660]             }
[08:28:16.660]             else {
[08:28:16.660]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:16.660]             }
[08:28:16.660]             {
[08:28:16.660]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:16.660]                   0L) {
[08:28:16.660]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:16.660]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:16.660]                   base::options(opts)
[08:28:16.660]                 }
[08:28:16.660]                 {
[08:28:16.660]                   {
[08:28:16.660]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:16.660]                     NULL
[08:28:16.660]                   }
[08:28:16.660]                   options(future.plan = NULL)
[08:28:16.660]                   if (is.na(NA_character_)) 
[08:28:16.660]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.660]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:16.660]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:16.660]                     .init = FALSE)
[08:28:16.660]                 }
[08:28:16.660]             }
[08:28:16.660]         }
[08:28:16.660]     })
[08:28:16.660]     if (TRUE) {
[08:28:16.660]         base::sink(type = "output", split = FALSE)
[08:28:16.660]         if (TRUE) {
[08:28:16.660]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:16.660]         }
[08:28:16.660]         else {
[08:28:16.660]             ...future.result["stdout"] <- base::list(NULL)
[08:28:16.660]         }
[08:28:16.660]         base::close(...future.stdout)
[08:28:16.660]         ...future.stdout <- NULL
[08:28:16.660]     }
[08:28:16.660]     ...future.result$conditions <- ...future.conditions
[08:28:16.660]     ...future.result$finished <- base::Sys.time()
[08:28:16.660]     ...future.result
[08:28:16.660] }
[08:28:16.663] MultisessionFuture started
[08:28:16.664] - Launch lazy future ... done
[08:28:16.664] run() for ‘MultisessionFuture’ ... done
[08:28:16.664] result() for ClusterFuture ...
[08:28:16.664] receiveMessageFromWorker() for ClusterFuture ...
[08:28:16.664] - Validating connection of MultisessionFuture
[08:28:16.706] - received message: FutureResult
[08:28:16.706] - Received FutureResult
[08:28:16.706] - Erased future from FutureRegistry
[08:28:16.706] result() for ClusterFuture ...
[08:28:16.706] - result already collected: FutureResult
[08:28:16.706] result() for ClusterFuture ... done
[08:28:16.706] signalConditions() ...
[08:28:16.706]  - include = ‘immediateCondition’
[08:28:16.707]  - exclude = 
[08:28:16.707]  - resignal = FALSE
[08:28:16.707]  - Number of conditions: 1
[08:28:16.707] signalConditions() ... done
[08:28:16.707] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:16.707] result() for ClusterFuture ... done
[08:28:16.707] result() for ClusterFuture ...
[08:28:16.707] - result already collected: FutureResult
[08:28:16.707] result() for ClusterFuture ... done
[08:28:16.708] signalConditions() ...
[08:28:16.708]  - include = ‘immediateCondition’
[08:28:16.708]  - exclude = 
[08:28:16.708]  - resignal = FALSE
[08:28:16.708]  - Number of conditions: 1
[08:28:16.708] signalConditions() ... done
[08:28:16.708] Future state: ‘finished’
[08:28:16.708] result() for ClusterFuture ...
[08:28:16.708] - result already collected: FutureResult
[08:28:16.708] result() for ClusterFuture ... done
[08:28:16.709] signalConditions() ...
[08:28:16.709]  - include = ‘condition’
[08:28:16.709]  - exclude = ‘immediateCondition’
[08:28:16.709]  - resignal = TRUE
[08:28:16.709]  - Number of conditions: 1
[08:28:16.709]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:16.709] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:16"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.726] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.726] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.728] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.728] Searching for globals ... DONE
[08:28:16.728] Resolving globals: TRUE
[08:28:16.728] Resolving any globals that are futures ...
[08:28:16.728] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.728] Resolving any globals that are futures ... DONE
[08:28:16.729] Resolving futures part of globals (recursively) ...
[08:28:16.729] resolve() on list ...
[08:28:16.729]  recursive: 99
[08:28:16.729]  length: 1
[08:28:16.729]  elements: ‘ii’
[08:28:16.730]  length: 0 (resolved future 1)
[08:28:16.730] resolve() on list ... DONE
[08:28:16.730] - globals: [1] ‘ii’
[08:28:16.730] Resolving futures part of globals (recursively) ... DONE
[08:28:16.730] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:16.730] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:16.731] - globals: [1] ‘ii’
[08:28:16.731] 
[08:28:16.731] getGlobalsAndPackages() ... DONE
[08:28:16.731] run() for ‘Future’ ...
[08:28:16.731] - state: ‘created’
[08:28:16.731] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:16.748] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:16.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:16.748]   - Field: ‘node’
[08:28:16.748]   - Field: ‘label’
[08:28:16.748]   - Field: ‘local’
[08:28:16.748]   - Field: ‘owner’
[08:28:16.749]   - Field: ‘envir’
[08:28:16.749]   - Field: ‘workers’
[08:28:16.749]   - Field: ‘packages’
[08:28:16.749]   - Field: ‘gc’
[08:28:16.749]   - Field: ‘conditions’
[08:28:16.749]   - Field: ‘persistent’
[08:28:16.749]   - Field: ‘expr’
[08:28:16.749]   - Field: ‘uuid’
[08:28:16.749]   - Field: ‘seed’
[08:28:16.749]   - Field: ‘version’
[08:28:16.749]   - Field: ‘result’
[08:28:16.749]   - Field: ‘asynchronous’
[08:28:16.750]   - Field: ‘calls’
[08:28:16.750]   - Field: ‘globals’
[08:28:16.750]   - Field: ‘stdout’
[08:28:16.750]   - Field: ‘earlySignal’
[08:28:16.750]   - Field: ‘lazy’
[08:28:16.750]   - Field: ‘state’
[08:28:16.750] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:16.750] - Launch lazy future ...
[08:28:16.750] Packages needed by the future expression (n = 0): <none>
[08:28:16.751] Packages needed by future strategies (n = 0): <none>
[08:28:16.751] {
[08:28:16.751]     {
[08:28:16.751]         {
[08:28:16.751]             ...future.startTime <- base::Sys.time()
[08:28:16.751]             {
[08:28:16.751]                 {
[08:28:16.751]                   {
[08:28:16.751]                     {
[08:28:16.751]                       base::local({
[08:28:16.751]                         has_future <- base::requireNamespace("future", 
[08:28:16.751]                           quietly = TRUE)
[08:28:16.751]                         if (has_future) {
[08:28:16.751]                           ns <- base::getNamespace("future")
[08:28:16.751]                           version <- ns[[".package"]][["version"]]
[08:28:16.751]                           if (is.null(version)) 
[08:28:16.751]                             version <- utils::packageVersion("future")
[08:28:16.751]                         }
[08:28:16.751]                         else {
[08:28:16.751]                           version <- NULL
[08:28:16.751]                         }
[08:28:16.751]                         if (!has_future || version < "1.8.0") {
[08:28:16.751]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:16.751]                             "", base::R.version$version.string), 
[08:28:16.751]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:16.751]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:16.751]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:16.751]                               "release", "version")], collapse = " "), 
[08:28:16.751]                             hostname = base::Sys.info()[["nodename"]])
[08:28:16.751]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:16.751]                             info)
[08:28:16.751]                           info <- base::paste(info, collapse = "; ")
[08:28:16.751]                           if (!has_future) {
[08:28:16.751]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:16.751]                               info)
[08:28:16.751]                           }
[08:28:16.751]                           else {
[08:28:16.751]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:16.751]                               info, version)
[08:28:16.751]                           }
[08:28:16.751]                           base::stop(msg)
[08:28:16.751]                         }
[08:28:16.751]                       })
[08:28:16.751]                     }
[08:28:16.751]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:16.751]                     base::options(mc.cores = 1L)
[08:28:16.751]                   }
[08:28:16.751]                   ...future.strategy.old <- future::plan("list")
[08:28:16.751]                   options(future.plan = NULL)
[08:28:16.751]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.751]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:16.751]                 }
[08:28:16.751]                 ...future.workdir <- getwd()
[08:28:16.751]             }
[08:28:16.751]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:16.751]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:16.751]         }
[08:28:16.751]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:16.751]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:16.751]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:16.751]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:16.751]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:16.751]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:16.751]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:16.751]             base::names(...future.oldOptions))
[08:28:16.751]     }
[08:28:16.751]     if (FALSE) {
[08:28:16.751]     }
[08:28:16.751]     else {
[08:28:16.751]         if (TRUE) {
[08:28:16.751]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:16.751]                 open = "w")
[08:28:16.751]         }
[08:28:16.751]         else {
[08:28:16.751]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:16.751]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:16.751]         }
[08:28:16.751]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:16.751]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:16.751]             base::sink(type = "output", split = FALSE)
[08:28:16.751]             base::close(...future.stdout)
[08:28:16.751]         }, add = TRUE)
[08:28:16.751]     }
[08:28:16.751]     ...future.frame <- base::sys.nframe()
[08:28:16.751]     ...future.conditions <- base::list()
[08:28:16.751]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:16.751]     if (FALSE) {
[08:28:16.751]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:16.751]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:16.751]     }
[08:28:16.751]     ...future.result <- base::tryCatch({
[08:28:16.751]         base::withCallingHandlers({
[08:28:16.751]             ...future.value <- base::withVisible(base::local({
[08:28:16.751]                 ...future.makeSendCondition <- base::local({
[08:28:16.751]                   sendCondition <- NULL
[08:28:16.751]                   function(frame = 1L) {
[08:28:16.751]                     if (is.function(sendCondition)) 
[08:28:16.751]                       return(sendCondition)
[08:28:16.751]                     ns <- getNamespace("parallel")
[08:28:16.751]                     if (exists("sendData", mode = "function", 
[08:28:16.751]                       envir = ns)) {
[08:28:16.751]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:16.751]                         envir = ns)
[08:28:16.751]                       envir <- sys.frame(frame)
[08:28:16.751]                       master <- NULL
[08:28:16.751]                       while (!identical(envir, .GlobalEnv) && 
[08:28:16.751]                         !identical(envir, emptyenv())) {
[08:28:16.751]                         if (exists("master", mode = "list", envir = envir, 
[08:28:16.751]                           inherits = FALSE)) {
[08:28:16.751]                           master <- get("master", mode = "list", 
[08:28:16.751]                             envir = envir, inherits = FALSE)
[08:28:16.751]                           if (inherits(master, c("SOCKnode", 
[08:28:16.751]                             "SOCK0node"))) {
[08:28:16.751]                             sendCondition <<- function(cond) {
[08:28:16.751]                               data <- list(type = "VALUE", value = cond, 
[08:28:16.751]                                 success = TRUE)
[08:28:16.751]                               parallel_sendData(master, data)
[08:28:16.751]                             }
[08:28:16.751]                             return(sendCondition)
[08:28:16.751]                           }
[08:28:16.751]                         }
[08:28:16.751]                         frame <- frame + 1L
[08:28:16.751]                         envir <- sys.frame(frame)
[08:28:16.751]                       }
[08:28:16.751]                     }
[08:28:16.751]                     sendCondition <<- function(cond) NULL
[08:28:16.751]                   }
[08:28:16.751]                 })
[08:28:16.751]                 withCallingHandlers({
[08:28:16.751]                   {
[08:28:16.751]                     b <- a * ii
[08:28:16.751]                     a <- 0
[08:28:16.751]                     b
[08:28:16.751]                   }
[08:28:16.751]                 }, immediateCondition = function(cond) {
[08:28:16.751]                   sendCondition <- ...future.makeSendCondition()
[08:28:16.751]                   sendCondition(cond)
[08:28:16.751]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.751]                   {
[08:28:16.751]                     inherits <- base::inherits
[08:28:16.751]                     invokeRestart <- base::invokeRestart
[08:28:16.751]                     is.null <- base::is.null
[08:28:16.751]                     muffled <- FALSE
[08:28:16.751]                     if (inherits(cond, "message")) {
[08:28:16.751]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:16.751]                       if (muffled) 
[08:28:16.751]                         invokeRestart("muffleMessage")
[08:28:16.751]                     }
[08:28:16.751]                     else if (inherits(cond, "warning")) {
[08:28:16.751]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:16.751]                       if (muffled) 
[08:28:16.751]                         invokeRestart("muffleWarning")
[08:28:16.751]                     }
[08:28:16.751]                     else if (inherits(cond, "condition")) {
[08:28:16.751]                       if (!is.null(pattern)) {
[08:28:16.751]                         computeRestarts <- base::computeRestarts
[08:28:16.751]                         grepl <- base::grepl
[08:28:16.751]                         restarts <- computeRestarts(cond)
[08:28:16.751]                         for (restart in restarts) {
[08:28:16.751]                           name <- restart$name
[08:28:16.751]                           if (is.null(name)) 
[08:28:16.751]                             next
[08:28:16.751]                           if (!grepl(pattern, name)) 
[08:28:16.751]                             next
[08:28:16.751]                           invokeRestart(restart)
[08:28:16.751]                           muffled <- TRUE
[08:28:16.751]                           break
[08:28:16.751]                         }
[08:28:16.751]                       }
[08:28:16.751]                     }
[08:28:16.751]                     invisible(muffled)
[08:28:16.751]                   }
[08:28:16.751]                   muffleCondition(cond)
[08:28:16.751]                 })
[08:28:16.751]             }))
[08:28:16.751]             future::FutureResult(value = ...future.value$value, 
[08:28:16.751]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.751]                   ...future.rng), globalenv = if (FALSE) 
[08:28:16.751]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:16.751]                     ...future.globalenv.names))
[08:28:16.751]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:16.751]         }, condition = base::local({
[08:28:16.751]             c <- base::c
[08:28:16.751]             inherits <- base::inherits
[08:28:16.751]             invokeRestart <- base::invokeRestart
[08:28:16.751]             length <- base::length
[08:28:16.751]             list <- base::list
[08:28:16.751]             seq.int <- base::seq.int
[08:28:16.751]             signalCondition <- base::signalCondition
[08:28:16.751]             sys.calls <- base::sys.calls
[08:28:16.751]             `[[` <- base::`[[`
[08:28:16.751]             `+` <- base::`+`
[08:28:16.751]             `<<-` <- base::`<<-`
[08:28:16.751]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:16.751]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:16.751]                   3L)]
[08:28:16.751]             }
[08:28:16.751]             function(cond) {
[08:28:16.751]                 is_error <- inherits(cond, "error")
[08:28:16.751]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:16.751]                   NULL)
[08:28:16.751]                 if (is_error) {
[08:28:16.751]                   sessionInformation <- function() {
[08:28:16.751]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:16.751]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:16.751]                       search = base::search(), system = base::Sys.info())
[08:28:16.751]                   }
[08:28:16.751]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.751]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:16.751]                     cond$call), session = sessionInformation(), 
[08:28:16.751]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:16.751]                   signalCondition(cond)
[08:28:16.751]                 }
[08:28:16.751]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:16.751]                 "immediateCondition"))) {
[08:28:16.751]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:16.751]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.751]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:16.751]                   if (TRUE && !signal) {
[08:28:16.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.751]                     {
[08:28:16.751]                       inherits <- base::inherits
[08:28:16.751]                       invokeRestart <- base::invokeRestart
[08:28:16.751]                       is.null <- base::is.null
[08:28:16.751]                       muffled <- FALSE
[08:28:16.751]                       if (inherits(cond, "message")) {
[08:28:16.751]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.751]                         if (muffled) 
[08:28:16.751]                           invokeRestart("muffleMessage")
[08:28:16.751]                       }
[08:28:16.751]                       else if (inherits(cond, "warning")) {
[08:28:16.751]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.751]                         if (muffled) 
[08:28:16.751]                           invokeRestart("muffleWarning")
[08:28:16.751]                       }
[08:28:16.751]                       else if (inherits(cond, "condition")) {
[08:28:16.751]                         if (!is.null(pattern)) {
[08:28:16.751]                           computeRestarts <- base::computeRestarts
[08:28:16.751]                           grepl <- base::grepl
[08:28:16.751]                           restarts <- computeRestarts(cond)
[08:28:16.751]                           for (restart in restarts) {
[08:28:16.751]                             name <- restart$name
[08:28:16.751]                             if (is.null(name)) 
[08:28:16.751]                               next
[08:28:16.751]                             if (!grepl(pattern, name)) 
[08:28:16.751]                               next
[08:28:16.751]                             invokeRestart(restart)
[08:28:16.751]                             muffled <- TRUE
[08:28:16.751]                             break
[08:28:16.751]                           }
[08:28:16.751]                         }
[08:28:16.751]                       }
[08:28:16.751]                       invisible(muffled)
[08:28:16.751]                     }
[08:28:16.751]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.751]                   }
[08:28:16.751]                 }
[08:28:16.751]                 else {
[08:28:16.751]                   if (TRUE) {
[08:28:16.751]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.751]                     {
[08:28:16.751]                       inherits <- base::inherits
[08:28:16.751]                       invokeRestart <- base::invokeRestart
[08:28:16.751]                       is.null <- base::is.null
[08:28:16.751]                       muffled <- FALSE
[08:28:16.751]                       if (inherits(cond, "message")) {
[08:28:16.751]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.751]                         if (muffled) 
[08:28:16.751]                           invokeRestart("muffleMessage")
[08:28:16.751]                       }
[08:28:16.751]                       else if (inherits(cond, "warning")) {
[08:28:16.751]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.751]                         if (muffled) 
[08:28:16.751]                           invokeRestart("muffleWarning")
[08:28:16.751]                       }
[08:28:16.751]                       else if (inherits(cond, "condition")) {
[08:28:16.751]                         if (!is.null(pattern)) {
[08:28:16.751]                           computeRestarts <- base::computeRestarts
[08:28:16.751]                           grepl <- base::grepl
[08:28:16.751]                           restarts <- computeRestarts(cond)
[08:28:16.751]                           for (restart in restarts) {
[08:28:16.751]                             name <- restart$name
[08:28:16.751]                             if (is.null(name)) 
[08:28:16.751]                               next
[08:28:16.751]                             if (!grepl(pattern, name)) 
[08:28:16.751]                               next
[08:28:16.751]                             invokeRestart(restart)
[08:28:16.751]                             muffled <- TRUE
[08:28:16.751]                             break
[08:28:16.751]                           }
[08:28:16.751]                         }
[08:28:16.751]                       }
[08:28:16.751]                       invisible(muffled)
[08:28:16.751]                     }
[08:28:16.751]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.751]                   }
[08:28:16.751]                 }
[08:28:16.751]             }
[08:28:16.751]         }))
[08:28:16.751]     }, error = function(ex) {
[08:28:16.751]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:16.751]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.751]                 ...future.rng), started = ...future.startTime, 
[08:28:16.751]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:16.751]             version = "1.8"), class = "FutureResult")
[08:28:16.751]     }, finally = {
[08:28:16.751]         if (!identical(...future.workdir, getwd())) 
[08:28:16.751]             setwd(...future.workdir)
[08:28:16.751]         {
[08:28:16.751]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:16.751]                 ...future.oldOptions$nwarnings <- NULL
[08:28:16.751]             }
[08:28:16.751]             base::options(...future.oldOptions)
[08:28:16.751]             if (.Platform$OS.type == "windows") {
[08:28:16.751]                 old_names <- names(...future.oldEnvVars)
[08:28:16.751]                 envs <- base::Sys.getenv()
[08:28:16.751]                 names <- names(envs)
[08:28:16.751]                 common <- intersect(names, old_names)
[08:28:16.751]                 added <- setdiff(names, old_names)
[08:28:16.751]                 removed <- setdiff(old_names, names)
[08:28:16.751]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:16.751]                   envs[common]]
[08:28:16.751]                 NAMES <- toupper(changed)
[08:28:16.751]                 args <- list()
[08:28:16.751]                 for (kk in seq_along(NAMES)) {
[08:28:16.751]                   name <- changed[[kk]]
[08:28:16.751]                   NAME <- NAMES[[kk]]
[08:28:16.751]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.751]                     next
[08:28:16.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.751]                 }
[08:28:16.751]                 NAMES <- toupper(added)
[08:28:16.751]                 for (kk in seq_along(NAMES)) {
[08:28:16.751]                   name <- added[[kk]]
[08:28:16.751]                   NAME <- NAMES[[kk]]
[08:28:16.751]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.751]                     next
[08:28:16.751]                   args[[name]] <- ""
[08:28:16.751]                 }
[08:28:16.751]                 NAMES <- toupper(removed)
[08:28:16.751]                 for (kk in seq_along(NAMES)) {
[08:28:16.751]                   name <- removed[[kk]]
[08:28:16.751]                   NAME <- NAMES[[kk]]
[08:28:16.751]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.751]                     next
[08:28:16.751]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.751]                 }
[08:28:16.751]                 if (length(args) > 0) 
[08:28:16.751]                   base::do.call(base::Sys.setenv, args = args)
[08:28:16.751]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:16.751]             }
[08:28:16.751]             else {
[08:28:16.751]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:16.751]             }
[08:28:16.751]             {
[08:28:16.751]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:16.751]                   0L) {
[08:28:16.751]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:16.751]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:16.751]                   base::options(opts)
[08:28:16.751]                 }
[08:28:16.751]                 {
[08:28:16.751]                   {
[08:28:16.751]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:16.751]                     NULL
[08:28:16.751]                   }
[08:28:16.751]                   options(future.plan = NULL)
[08:28:16.751]                   if (is.na(NA_character_)) 
[08:28:16.751]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.751]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:16.751]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:16.751]                     .init = FALSE)
[08:28:16.751]                 }
[08:28:16.751]             }
[08:28:16.751]         }
[08:28:16.751]     })
[08:28:16.751]     if (TRUE) {
[08:28:16.751]         base::sink(type = "output", split = FALSE)
[08:28:16.751]         if (TRUE) {
[08:28:16.751]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:16.751]         }
[08:28:16.751]         else {
[08:28:16.751]             ...future.result["stdout"] <- base::list(NULL)
[08:28:16.751]         }
[08:28:16.751]         base::close(...future.stdout)
[08:28:16.751]         ...future.stdout <- NULL
[08:28:16.751]     }
[08:28:16.751]     ...future.result$conditions <- ...future.conditions
[08:28:16.751]     ...future.result$finished <- base::Sys.time()
[08:28:16.751]     ...future.result
[08:28:16.751] }
[08:28:16.753] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:28:16.754] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:28:16.754] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:28:16.754] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:28:16.754] MultisessionFuture started
[08:28:16.755] - Launch lazy future ... done
[08:28:16.755] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.755] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.755] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.757] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.757] Searching for globals ... DONE
[08:28:16.757] Resolving globals: TRUE
[08:28:16.757] Resolving any globals that are futures ...
[08:28:16.757] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.757] Resolving any globals that are futures ... DONE
[08:28:16.757] Resolving futures part of globals (recursively) ...
[08:28:16.758] resolve() on list ...
[08:28:16.758]  recursive: 99
[08:28:16.758]  length: 1
[08:28:16.758]  elements: ‘ii’
[08:28:16.758]  length: 0 (resolved future 1)
[08:28:16.758] resolve() on list ... DONE
[08:28:16.758] - globals: [1] ‘ii’
[08:28:16.758] Resolving futures part of globals (recursively) ... DONE
[08:28:16.758] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:16.759] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:16.759] - globals: [1] ‘ii’
[08:28:16.759] 
[08:28:16.759] getGlobalsAndPackages() ... DONE
[08:28:16.759] run() for ‘Future’ ...
[08:28:16.759] - state: ‘created’
[08:28:16.759] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:16.773] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:16.773] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:16.773]   - Field: ‘node’
[08:28:16.773]   - Field: ‘label’
[08:28:16.773]   - Field: ‘local’
[08:28:16.773]   - Field: ‘owner’
[08:28:16.773]   - Field: ‘envir’
[08:28:16.773]   - Field: ‘workers’
[08:28:16.773]   - Field: ‘packages’
[08:28:16.773]   - Field: ‘gc’
[08:28:16.774]   - Field: ‘conditions’
[08:28:16.774]   - Field: ‘persistent’
[08:28:16.774]   - Field: ‘expr’
[08:28:16.774]   - Field: ‘uuid’
[08:28:16.774]   - Field: ‘seed’
[08:28:16.774]   - Field: ‘version’
[08:28:16.774]   - Field: ‘result’
[08:28:16.774]   - Field: ‘asynchronous’
[08:28:16.774]   - Field: ‘calls’
[08:28:16.774]   - Field: ‘globals’
[08:28:16.774]   - Field: ‘stdout’
[08:28:16.774]   - Field: ‘earlySignal’
[08:28:16.775]   - Field: ‘lazy’
[08:28:16.775]   - Field: ‘state’
[08:28:16.775] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:16.775] - Launch lazy future ...
[08:28:16.775] Packages needed by the future expression (n = 0): <none>
[08:28:16.775] Packages needed by future strategies (n = 0): <none>
[08:28:16.776] {
[08:28:16.776]     {
[08:28:16.776]         {
[08:28:16.776]             ...future.startTime <- base::Sys.time()
[08:28:16.776]             {
[08:28:16.776]                 {
[08:28:16.776]                   {
[08:28:16.776]                     {
[08:28:16.776]                       base::local({
[08:28:16.776]                         has_future <- base::requireNamespace("future", 
[08:28:16.776]                           quietly = TRUE)
[08:28:16.776]                         if (has_future) {
[08:28:16.776]                           ns <- base::getNamespace("future")
[08:28:16.776]                           version <- ns[[".package"]][["version"]]
[08:28:16.776]                           if (is.null(version)) 
[08:28:16.776]                             version <- utils::packageVersion("future")
[08:28:16.776]                         }
[08:28:16.776]                         else {
[08:28:16.776]                           version <- NULL
[08:28:16.776]                         }
[08:28:16.776]                         if (!has_future || version < "1.8.0") {
[08:28:16.776]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:16.776]                             "", base::R.version$version.string), 
[08:28:16.776]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:16.776]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:16.776]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:16.776]                               "release", "version")], collapse = " "), 
[08:28:16.776]                             hostname = base::Sys.info()[["nodename"]])
[08:28:16.776]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:16.776]                             info)
[08:28:16.776]                           info <- base::paste(info, collapse = "; ")
[08:28:16.776]                           if (!has_future) {
[08:28:16.776]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:16.776]                               info)
[08:28:16.776]                           }
[08:28:16.776]                           else {
[08:28:16.776]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:16.776]                               info, version)
[08:28:16.776]                           }
[08:28:16.776]                           base::stop(msg)
[08:28:16.776]                         }
[08:28:16.776]                       })
[08:28:16.776]                     }
[08:28:16.776]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:16.776]                     base::options(mc.cores = 1L)
[08:28:16.776]                   }
[08:28:16.776]                   ...future.strategy.old <- future::plan("list")
[08:28:16.776]                   options(future.plan = NULL)
[08:28:16.776]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.776]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:16.776]                 }
[08:28:16.776]                 ...future.workdir <- getwd()
[08:28:16.776]             }
[08:28:16.776]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:16.776]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:16.776]         }
[08:28:16.776]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:16.776]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:16.776]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:16.776]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:16.776]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:16.776]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:16.776]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:16.776]             base::names(...future.oldOptions))
[08:28:16.776]     }
[08:28:16.776]     if (FALSE) {
[08:28:16.776]     }
[08:28:16.776]     else {
[08:28:16.776]         if (TRUE) {
[08:28:16.776]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:16.776]                 open = "w")
[08:28:16.776]         }
[08:28:16.776]         else {
[08:28:16.776]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:16.776]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:16.776]         }
[08:28:16.776]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:16.776]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:16.776]             base::sink(type = "output", split = FALSE)
[08:28:16.776]             base::close(...future.stdout)
[08:28:16.776]         }, add = TRUE)
[08:28:16.776]     }
[08:28:16.776]     ...future.frame <- base::sys.nframe()
[08:28:16.776]     ...future.conditions <- base::list()
[08:28:16.776]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:16.776]     if (FALSE) {
[08:28:16.776]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:16.776]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:16.776]     }
[08:28:16.776]     ...future.result <- base::tryCatch({
[08:28:16.776]         base::withCallingHandlers({
[08:28:16.776]             ...future.value <- base::withVisible(base::local({
[08:28:16.776]                 ...future.makeSendCondition <- base::local({
[08:28:16.776]                   sendCondition <- NULL
[08:28:16.776]                   function(frame = 1L) {
[08:28:16.776]                     if (is.function(sendCondition)) 
[08:28:16.776]                       return(sendCondition)
[08:28:16.776]                     ns <- getNamespace("parallel")
[08:28:16.776]                     if (exists("sendData", mode = "function", 
[08:28:16.776]                       envir = ns)) {
[08:28:16.776]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:16.776]                         envir = ns)
[08:28:16.776]                       envir <- sys.frame(frame)
[08:28:16.776]                       master <- NULL
[08:28:16.776]                       while (!identical(envir, .GlobalEnv) && 
[08:28:16.776]                         !identical(envir, emptyenv())) {
[08:28:16.776]                         if (exists("master", mode = "list", envir = envir, 
[08:28:16.776]                           inherits = FALSE)) {
[08:28:16.776]                           master <- get("master", mode = "list", 
[08:28:16.776]                             envir = envir, inherits = FALSE)
[08:28:16.776]                           if (inherits(master, c("SOCKnode", 
[08:28:16.776]                             "SOCK0node"))) {
[08:28:16.776]                             sendCondition <<- function(cond) {
[08:28:16.776]                               data <- list(type = "VALUE", value = cond, 
[08:28:16.776]                                 success = TRUE)
[08:28:16.776]                               parallel_sendData(master, data)
[08:28:16.776]                             }
[08:28:16.776]                             return(sendCondition)
[08:28:16.776]                           }
[08:28:16.776]                         }
[08:28:16.776]                         frame <- frame + 1L
[08:28:16.776]                         envir <- sys.frame(frame)
[08:28:16.776]                       }
[08:28:16.776]                     }
[08:28:16.776]                     sendCondition <<- function(cond) NULL
[08:28:16.776]                   }
[08:28:16.776]                 })
[08:28:16.776]                 withCallingHandlers({
[08:28:16.776]                   {
[08:28:16.776]                     b <- a * ii
[08:28:16.776]                     a <- 0
[08:28:16.776]                     b
[08:28:16.776]                   }
[08:28:16.776]                 }, immediateCondition = function(cond) {
[08:28:16.776]                   sendCondition <- ...future.makeSendCondition()
[08:28:16.776]                   sendCondition(cond)
[08:28:16.776]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.776]                   {
[08:28:16.776]                     inherits <- base::inherits
[08:28:16.776]                     invokeRestart <- base::invokeRestart
[08:28:16.776]                     is.null <- base::is.null
[08:28:16.776]                     muffled <- FALSE
[08:28:16.776]                     if (inherits(cond, "message")) {
[08:28:16.776]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:16.776]                       if (muffled) 
[08:28:16.776]                         invokeRestart("muffleMessage")
[08:28:16.776]                     }
[08:28:16.776]                     else if (inherits(cond, "warning")) {
[08:28:16.776]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:16.776]                       if (muffled) 
[08:28:16.776]                         invokeRestart("muffleWarning")
[08:28:16.776]                     }
[08:28:16.776]                     else if (inherits(cond, "condition")) {
[08:28:16.776]                       if (!is.null(pattern)) {
[08:28:16.776]                         computeRestarts <- base::computeRestarts
[08:28:16.776]                         grepl <- base::grepl
[08:28:16.776]                         restarts <- computeRestarts(cond)
[08:28:16.776]                         for (restart in restarts) {
[08:28:16.776]                           name <- restart$name
[08:28:16.776]                           if (is.null(name)) 
[08:28:16.776]                             next
[08:28:16.776]                           if (!grepl(pattern, name)) 
[08:28:16.776]                             next
[08:28:16.776]                           invokeRestart(restart)
[08:28:16.776]                           muffled <- TRUE
[08:28:16.776]                           break
[08:28:16.776]                         }
[08:28:16.776]                       }
[08:28:16.776]                     }
[08:28:16.776]                     invisible(muffled)
[08:28:16.776]                   }
[08:28:16.776]                   muffleCondition(cond)
[08:28:16.776]                 })
[08:28:16.776]             }))
[08:28:16.776]             future::FutureResult(value = ...future.value$value, 
[08:28:16.776]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.776]                   ...future.rng), globalenv = if (FALSE) 
[08:28:16.776]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:16.776]                     ...future.globalenv.names))
[08:28:16.776]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:16.776]         }, condition = base::local({
[08:28:16.776]             c <- base::c
[08:28:16.776]             inherits <- base::inherits
[08:28:16.776]             invokeRestart <- base::invokeRestart
[08:28:16.776]             length <- base::length
[08:28:16.776]             list <- base::list
[08:28:16.776]             seq.int <- base::seq.int
[08:28:16.776]             signalCondition <- base::signalCondition
[08:28:16.776]             sys.calls <- base::sys.calls
[08:28:16.776]             `[[` <- base::`[[`
[08:28:16.776]             `+` <- base::`+`
[08:28:16.776]             `<<-` <- base::`<<-`
[08:28:16.776]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:16.776]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:16.776]                   3L)]
[08:28:16.776]             }
[08:28:16.776]             function(cond) {
[08:28:16.776]                 is_error <- inherits(cond, "error")
[08:28:16.776]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:16.776]                   NULL)
[08:28:16.776]                 if (is_error) {
[08:28:16.776]                   sessionInformation <- function() {
[08:28:16.776]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:16.776]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:16.776]                       search = base::search(), system = base::Sys.info())
[08:28:16.776]                   }
[08:28:16.776]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.776]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:16.776]                     cond$call), session = sessionInformation(), 
[08:28:16.776]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:16.776]                   signalCondition(cond)
[08:28:16.776]                 }
[08:28:16.776]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:16.776]                 "immediateCondition"))) {
[08:28:16.776]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:16.776]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.776]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:16.776]                   if (TRUE && !signal) {
[08:28:16.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.776]                     {
[08:28:16.776]                       inherits <- base::inherits
[08:28:16.776]                       invokeRestart <- base::invokeRestart
[08:28:16.776]                       is.null <- base::is.null
[08:28:16.776]                       muffled <- FALSE
[08:28:16.776]                       if (inherits(cond, "message")) {
[08:28:16.776]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.776]                         if (muffled) 
[08:28:16.776]                           invokeRestart("muffleMessage")
[08:28:16.776]                       }
[08:28:16.776]                       else if (inherits(cond, "warning")) {
[08:28:16.776]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.776]                         if (muffled) 
[08:28:16.776]                           invokeRestart("muffleWarning")
[08:28:16.776]                       }
[08:28:16.776]                       else if (inherits(cond, "condition")) {
[08:28:16.776]                         if (!is.null(pattern)) {
[08:28:16.776]                           computeRestarts <- base::computeRestarts
[08:28:16.776]                           grepl <- base::grepl
[08:28:16.776]                           restarts <- computeRestarts(cond)
[08:28:16.776]                           for (restart in restarts) {
[08:28:16.776]                             name <- restart$name
[08:28:16.776]                             if (is.null(name)) 
[08:28:16.776]                               next
[08:28:16.776]                             if (!grepl(pattern, name)) 
[08:28:16.776]                               next
[08:28:16.776]                             invokeRestart(restart)
[08:28:16.776]                             muffled <- TRUE
[08:28:16.776]                             break
[08:28:16.776]                           }
[08:28:16.776]                         }
[08:28:16.776]                       }
[08:28:16.776]                       invisible(muffled)
[08:28:16.776]                     }
[08:28:16.776]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.776]                   }
[08:28:16.776]                 }
[08:28:16.776]                 else {
[08:28:16.776]                   if (TRUE) {
[08:28:16.776]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.776]                     {
[08:28:16.776]                       inherits <- base::inherits
[08:28:16.776]                       invokeRestart <- base::invokeRestart
[08:28:16.776]                       is.null <- base::is.null
[08:28:16.776]                       muffled <- FALSE
[08:28:16.776]                       if (inherits(cond, "message")) {
[08:28:16.776]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.776]                         if (muffled) 
[08:28:16.776]                           invokeRestart("muffleMessage")
[08:28:16.776]                       }
[08:28:16.776]                       else if (inherits(cond, "warning")) {
[08:28:16.776]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.776]                         if (muffled) 
[08:28:16.776]                           invokeRestart("muffleWarning")
[08:28:16.776]                       }
[08:28:16.776]                       else if (inherits(cond, "condition")) {
[08:28:16.776]                         if (!is.null(pattern)) {
[08:28:16.776]                           computeRestarts <- base::computeRestarts
[08:28:16.776]                           grepl <- base::grepl
[08:28:16.776]                           restarts <- computeRestarts(cond)
[08:28:16.776]                           for (restart in restarts) {
[08:28:16.776]                             name <- restart$name
[08:28:16.776]                             if (is.null(name)) 
[08:28:16.776]                               next
[08:28:16.776]                             if (!grepl(pattern, name)) 
[08:28:16.776]                               next
[08:28:16.776]                             invokeRestart(restart)
[08:28:16.776]                             muffled <- TRUE
[08:28:16.776]                             break
[08:28:16.776]                           }
[08:28:16.776]                         }
[08:28:16.776]                       }
[08:28:16.776]                       invisible(muffled)
[08:28:16.776]                     }
[08:28:16.776]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.776]                   }
[08:28:16.776]                 }
[08:28:16.776]             }
[08:28:16.776]         }))
[08:28:16.776]     }, error = function(ex) {
[08:28:16.776]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:16.776]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.776]                 ...future.rng), started = ...future.startTime, 
[08:28:16.776]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:16.776]             version = "1.8"), class = "FutureResult")
[08:28:16.776]     }, finally = {
[08:28:16.776]         if (!identical(...future.workdir, getwd())) 
[08:28:16.776]             setwd(...future.workdir)
[08:28:16.776]         {
[08:28:16.776]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:16.776]                 ...future.oldOptions$nwarnings <- NULL
[08:28:16.776]             }
[08:28:16.776]             base::options(...future.oldOptions)
[08:28:16.776]             if (.Platform$OS.type == "windows") {
[08:28:16.776]                 old_names <- names(...future.oldEnvVars)
[08:28:16.776]                 envs <- base::Sys.getenv()
[08:28:16.776]                 names <- names(envs)
[08:28:16.776]                 common <- intersect(names, old_names)
[08:28:16.776]                 added <- setdiff(names, old_names)
[08:28:16.776]                 removed <- setdiff(old_names, names)
[08:28:16.776]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:16.776]                   envs[common]]
[08:28:16.776]                 NAMES <- toupper(changed)
[08:28:16.776]                 args <- list()
[08:28:16.776]                 for (kk in seq_along(NAMES)) {
[08:28:16.776]                   name <- changed[[kk]]
[08:28:16.776]                   NAME <- NAMES[[kk]]
[08:28:16.776]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.776]                     next
[08:28:16.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.776]                 }
[08:28:16.776]                 NAMES <- toupper(added)
[08:28:16.776]                 for (kk in seq_along(NAMES)) {
[08:28:16.776]                   name <- added[[kk]]
[08:28:16.776]                   NAME <- NAMES[[kk]]
[08:28:16.776]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.776]                     next
[08:28:16.776]                   args[[name]] <- ""
[08:28:16.776]                 }
[08:28:16.776]                 NAMES <- toupper(removed)
[08:28:16.776]                 for (kk in seq_along(NAMES)) {
[08:28:16.776]                   name <- removed[[kk]]
[08:28:16.776]                   NAME <- NAMES[[kk]]
[08:28:16.776]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.776]                     next
[08:28:16.776]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.776]                 }
[08:28:16.776]                 if (length(args) > 0) 
[08:28:16.776]                   base::do.call(base::Sys.setenv, args = args)
[08:28:16.776]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:16.776]             }
[08:28:16.776]             else {
[08:28:16.776]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:16.776]             }
[08:28:16.776]             {
[08:28:16.776]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:16.776]                   0L) {
[08:28:16.776]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:16.776]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:16.776]                   base::options(opts)
[08:28:16.776]                 }
[08:28:16.776]                 {
[08:28:16.776]                   {
[08:28:16.776]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:16.776]                     NULL
[08:28:16.776]                   }
[08:28:16.776]                   options(future.plan = NULL)
[08:28:16.776]                   if (is.na(NA_character_)) 
[08:28:16.776]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.776]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:16.776]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:16.776]                     .init = FALSE)
[08:28:16.776]                 }
[08:28:16.776]             }
[08:28:16.776]         }
[08:28:16.776]     })
[08:28:16.776]     if (TRUE) {
[08:28:16.776]         base::sink(type = "output", split = FALSE)
[08:28:16.776]         if (TRUE) {
[08:28:16.776]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:16.776]         }
[08:28:16.776]         else {
[08:28:16.776]             ...future.result["stdout"] <- base::list(NULL)
[08:28:16.776]         }
[08:28:16.776]         base::close(...future.stdout)
[08:28:16.776]         ...future.stdout <- NULL
[08:28:16.776]     }
[08:28:16.776]     ...future.result$conditions <- ...future.conditions
[08:28:16.776]     ...future.result$finished <- base::Sys.time()
[08:28:16.776]     ...future.result
[08:28:16.776] }
[08:28:16.828] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[08:28:16.828] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:28:16.829] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:28:16.829] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[08:28:16.830] MultisessionFuture started
[08:28:16.830] - Launch lazy future ... done
[08:28:16.830] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.830] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.831] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.832] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.832] Searching for globals ... DONE
[08:28:16.832] Resolving globals: TRUE
[08:28:16.832] Resolving any globals that are futures ...
[08:28:16.832] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.833] Resolving any globals that are futures ... DONE
[08:28:16.833] Resolving futures part of globals (recursively) ...
[08:28:16.833] resolve() on list ...
[08:28:16.833]  recursive: 99
[08:28:16.833]  length: 1
[08:28:16.833]  elements: ‘ii’
[08:28:16.834]  length: 0 (resolved future 1)
[08:28:16.834] resolve() on list ... DONE
[08:28:16.834] - globals: [1] ‘ii’
[08:28:16.834] Resolving futures part of globals (recursively) ... DONE
[08:28:16.834] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:16.834] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:16.834] - globals: [1] ‘ii’
[08:28:16.834] 
[08:28:16.835] getGlobalsAndPackages() ... DONE
[08:28:16.835] run() for ‘Future’ ...
[08:28:16.835] - state: ‘created’
[08:28:16.835] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:16.849] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:16.849] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:16.849]   - Field: ‘node’
[08:28:16.849]   - Field: ‘label’
[08:28:16.849]   - Field: ‘local’
[08:28:16.850]   - Field: ‘owner’
[08:28:16.850]   - Field: ‘envir’
[08:28:16.850]   - Field: ‘workers’
[08:28:16.850]   - Field: ‘packages’
[08:28:16.850]   - Field: ‘gc’
[08:28:16.850]   - Field: ‘conditions’
[08:28:16.850]   - Field: ‘persistent’
[08:28:16.850]   - Field: ‘expr’
[08:28:16.850]   - Field: ‘uuid’
[08:28:16.850]   - Field: ‘seed’
[08:28:16.851]   - Field: ‘version’
[08:28:16.851]   - Field: ‘result’
[08:28:16.851]   - Field: ‘asynchronous’
[08:28:16.851]   - Field: ‘calls’
[08:28:16.851]   - Field: ‘globals’
[08:28:16.851]   - Field: ‘stdout’
[08:28:16.851]   - Field: ‘earlySignal’
[08:28:16.851]   - Field: ‘lazy’
[08:28:16.851]   - Field: ‘state’
[08:28:16.851] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:16.851] - Launch lazy future ...
[08:28:16.852] Packages needed by the future expression (n = 0): <none>
[08:28:16.852] Packages needed by future strategies (n = 0): <none>
[08:28:16.852] {
[08:28:16.852]     {
[08:28:16.852]         {
[08:28:16.852]             ...future.startTime <- base::Sys.time()
[08:28:16.852]             {
[08:28:16.852]                 {
[08:28:16.852]                   {
[08:28:16.852]                     {
[08:28:16.852]                       base::local({
[08:28:16.852]                         has_future <- base::requireNamespace("future", 
[08:28:16.852]                           quietly = TRUE)
[08:28:16.852]                         if (has_future) {
[08:28:16.852]                           ns <- base::getNamespace("future")
[08:28:16.852]                           version <- ns[[".package"]][["version"]]
[08:28:16.852]                           if (is.null(version)) 
[08:28:16.852]                             version <- utils::packageVersion("future")
[08:28:16.852]                         }
[08:28:16.852]                         else {
[08:28:16.852]                           version <- NULL
[08:28:16.852]                         }
[08:28:16.852]                         if (!has_future || version < "1.8.0") {
[08:28:16.852]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:16.852]                             "", base::R.version$version.string), 
[08:28:16.852]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:16.852]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:16.852]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:16.852]                               "release", "version")], collapse = " "), 
[08:28:16.852]                             hostname = base::Sys.info()[["nodename"]])
[08:28:16.852]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:16.852]                             info)
[08:28:16.852]                           info <- base::paste(info, collapse = "; ")
[08:28:16.852]                           if (!has_future) {
[08:28:16.852]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:16.852]                               info)
[08:28:16.852]                           }
[08:28:16.852]                           else {
[08:28:16.852]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:16.852]                               info, version)
[08:28:16.852]                           }
[08:28:16.852]                           base::stop(msg)
[08:28:16.852]                         }
[08:28:16.852]                       })
[08:28:16.852]                     }
[08:28:16.852]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:16.852]                     base::options(mc.cores = 1L)
[08:28:16.852]                   }
[08:28:16.852]                   ...future.strategy.old <- future::plan("list")
[08:28:16.852]                   options(future.plan = NULL)
[08:28:16.852]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.852]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:16.852]                 }
[08:28:16.852]                 ...future.workdir <- getwd()
[08:28:16.852]             }
[08:28:16.852]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:16.852]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:16.852]         }
[08:28:16.852]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:16.852]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:16.852]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:16.852]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:16.852]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:16.852]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:16.852]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:16.852]             base::names(...future.oldOptions))
[08:28:16.852]     }
[08:28:16.852]     if (FALSE) {
[08:28:16.852]     }
[08:28:16.852]     else {
[08:28:16.852]         if (TRUE) {
[08:28:16.852]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:16.852]                 open = "w")
[08:28:16.852]         }
[08:28:16.852]         else {
[08:28:16.852]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:16.852]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:16.852]         }
[08:28:16.852]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:16.852]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:16.852]             base::sink(type = "output", split = FALSE)
[08:28:16.852]             base::close(...future.stdout)
[08:28:16.852]         }, add = TRUE)
[08:28:16.852]     }
[08:28:16.852]     ...future.frame <- base::sys.nframe()
[08:28:16.852]     ...future.conditions <- base::list()
[08:28:16.852]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:16.852]     if (FALSE) {
[08:28:16.852]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:16.852]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:16.852]     }
[08:28:16.852]     ...future.result <- base::tryCatch({
[08:28:16.852]         base::withCallingHandlers({
[08:28:16.852]             ...future.value <- base::withVisible(base::local({
[08:28:16.852]                 ...future.makeSendCondition <- base::local({
[08:28:16.852]                   sendCondition <- NULL
[08:28:16.852]                   function(frame = 1L) {
[08:28:16.852]                     if (is.function(sendCondition)) 
[08:28:16.852]                       return(sendCondition)
[08:28:16.852]                     ns <- getNamespace("parallel")
[08:28:16.852]                     if (exists("sendData", mode = "function", 
[08:28:16.852]                       envir = ns)) {
[08:28:16.852]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:16.852]                         envir = ns)
[08:28:16.852]                       envir <- sys.frame(frame)
[08:28:16.852]                       master <- NULL
[08:28:16.852]                       while (!identical(envir, .GlobalEnv) && 
[08:28:16.852]                         !identical(envir, emptyenv())) {
[08:28:16.852]                         if (exists("master", mode = "list", envir = envir, 
[08:28:16.852]                           inherits = FALSE)) {
[08:28:16.852]                           master <- get("master", mode = "list", 
[08:28:16.852]                             envir = envir, inherits = FALSE)
[08:28:16.852]                           if (inherits(master, c("SOCKnode", 
[08:28:16.852]                             "SOCK0node"))) {
[08:28:16.852]                             sendCondition <<- function(cond) {
[08:28:16.852]                               data <- list(type = "VALUE", value = cond, 
[08:28:16.852]                                 success = TRUE)
[08:28:16.852]                               parallel_sendData(master, data)
[08:28:16.852]                             }
[08:28:16.852]                             return(sendCondition)
[08:28:16.852]                           }
[08:28:16.852]                         }
[08:28:16.852]                         frame <- frame + 1L
[08:28:16.852]                         envir <- sys.frame(frame)
[08:28:16.852]                       }
[08:28:16.852]                     }
[08:28:16.852]                     sendCondition <<- function(cond) NULL
[08:28:16.852]                   }
[08:28:16.852]                 })
[08:28:16.852]                 withCallingHandlers({
[08:28:16.852]                   {
[08:28:16.852]                     b <- a * ii
[08:28:16.852]                     a <- 0
[08:28:16.852]                     b
[08:28:16.852]                   }
[08:28:16.852]                 }, immediateCondition = function(cond) {
[08:28:16.852]                   sendCondition <- ...future.makeSendCondition()
[08:28:16.852]                   sendCondition(cond)
[08:28:16.852]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.852]                   {
[08:28:16.852]                     inherits <- base::inherits
[08:28:16.852]                     invokeRestart <- base::invokeRestart
[08:28:16.852]                     is.null <- base::is.null
[08:28:16.852]                     muffled <- FALSE
[08:28:16.852]                     if (inherits(cond, "message")) {
[08:28:16.852]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:16.852]                       if (muffled) 
[08:28:16.852]                         invokeRestart("muffleMessage")
[08:28:16.852]                     }
[08:28:16.852]                     else if (inherits(cond, "warning")) {
[08:28:16.852]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:16.852]                       if (muffled) 
[08:28:16.852]                         invokeRestart("muffleWarning")
[08:28:16.852]                     }
[08:28:16.852]                     else if (inherits(cond, "condition")) {
[08:28:16.852]                       if (!is.null(pattern)) {
[08:28:16.852]                         computeRestarts <- base::computeRestarts
[08:28:16.852]                         grepl <- base::grepl
[08:28:16.852]                         restarts <- computeRestarts(cond)
[08:28:16.852]                         for (restart in restarts) {
[08:28:16.852]                           name <- restart$name
[08:28:16.852]                           if (is.null(name)) 
[08:28:16.852]                             next
[08:28:16.852]                           if (!grepl(pattern, name)) 
[08:28:16.852]                             next
[08:28:16.852]                           invokeRestart(restart)
[08:28:16.852]                           muffled <- TRUE
[08:28:16.852]                           break
[08:28:16.852]                         }
[08:28:16.852]                       }
[08:28:16.852]                     }
[08:28:16.852]                     invisible(muffled)
[08:28:16.852]                   }
[08:28:16.852]                   muffleCondition(cond)
[08:28:16.852]                 })
[08:28:16.852]             }))
[08:28:16.852]             future::FutureResult(value = ...future.value$value, 
[08:28:16.852]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.852]                   ...future.rng), globalenv = if (FALSE) 
[08:28:16.852]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:16.852]                     ...future.globalenv.names))
[08:28:16.852]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:16.852]         }, condition = base::local({
[08:28:16.852]             c <- base::c
[08:28:16.852]             inherits <- base::inherits
[08:28:16.852]             invokeRestart <- base::invokeRestart
[08:28:16.852]             length <- base::length
[08:28:16.852]             list <- base::list
[08:28:16.852]             seq.int <- base::seq.int
[08:28:16.852]             signalCondition <- base::signalCondition
[08:28:16.852]             sys.calls <- base::sys.calls
[08:28:16.852]             `[[` <- base::`[[`
[08:28:16.852]             `+` <- base::`+`
[08:28:16.852]             `<<-` <- base::`<<-`
[08:28:16.852]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:16.852]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:16.852]                   3L)]
[08:28:16.852]             }
[08:28:16.852]             function(cond) {
[08:28:16.852]                 is_error <- inherits(cond, "error")
[08:28:16.852]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:16.852]                   NULL)
[08:28:16.852]                 if (is_error) {
[08:28:16.852]                   sessionInformation <- function() {
[08:28:16.852]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:16.852]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:16.852]                       search = base::search(), system = base::Sys.info())
[08:28:16.852]                   }
[08:28:16.852]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.852]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:16.852]                     cond$call), session = sessionInformation(), 
[08:28:16.852]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:16.852]                   signalCondition(cond)
[08:28:16.852]                 }
[08:28:16.852]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:16.852]                 "immediateCondition"))) {
[08:28:16.852]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:16.852]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.852]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:16.852]                   if (TRUE && !signal) {
[08:28:16.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.852]                     {
[08:28:16.852]                       inherits <- base::inherits
[08:28:16.852]                       invokeRestart <- base::invokeRestart
[08:28:16.852]                       is.null <- base::is.null
[08:28:16.852]                       muffled <- FALSE
[08:28:16.852]                       if (inherits(cond, "message")) {
[08:28:16.852]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.852]                         if (muffled) 
[08:28:16.852]                           invokeRestart("muffleMessage")
[08:28:16.852]                       }
[08:28:16.852]                       else if (inherits(cond, "warning")) {
[08:28:16.852]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.852]                         if (muffled) 
[08:28:16.852]                           invokeRestart("muffleWarning")
[08:28:16.852]                       }
[08:28:16.852]                       else if (inherits(cond, "condition")) {
[08:28:16.852]                         if (!is.null(pattern)) {
[08:28:16.852]                           computeRestarts <- base::computeRestarts
[08:28:16.852]                           grepl <- base::grepl
[08:28:16.852]                           restarts <- computeRestarts(cond)
[08:28:16.852]                           for (restart in restarts) {
[08:28:16.852]                             name <- restart$name
[08:28:16.852]                             if (is.null(name)) 
[08:28:16.852]                               next
[08:28:16.852]                             if (!grepl(pattern, name)) 
[08:28:16.852]                               next
[08:28:16.852]                             invokeRestart(restart)
[08:28:16.852]                             muffled <- TRUE
[08:28:16.852]                             break
[08:28:16.852]                           }
[08:28:16.852]                         }
[08:28:16.852]                       }
[08:28:16.852]                       invisible(muffled)
[08:28:16.852]                     }
[08:28:16.852]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.852]                   }
[08:28:16.852]                 }
[08:28:16.852]                 else {
[08:28:16.852]                   if (TRUE) {
[08:28:16.852]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.852]                     {
[08:28:16.852]                       inherits <- base::inherits
[08:28:16.852]                       invokeRestart <- base::invokeRestart
[08:28:16.852]                       is.null <- base::is.null
[08:28:16.852]                       muffled <- FALSE
[08:28:16.852]                       if (inherits(cond, "message")) {
[08:28:16.852]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.852]                         if (muffled) 
[08:28:16.852]                           invokeRestart("muffleMessage")
[08:28:16.852]                       }
[08:28:16.852]                       else if (inherits(cond, "warning")) {
[08:28:16.852]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.852]                         if (muffled) 
[08:28:16.852]                           invokeRestart("muffleWarning")
[08:28:16.852]                       }
[08:28:16.852]                       else if (inherits(cond, "condition")) {
[08:28:16.852]                         if (!is.null(pattern)) {
[08:28:16.852]                           computeRestarts <- base::computeRestarts
[08:28:16.852]                           grepl <- base::grepl
[08:28:16.852]                           restarts <- computeRestarts(cond)
[08:28:16.852]                           for (restart in restarts) {
[08:28:16.852]                             name <- restart$name
[08:28:16.852]                             if (is.null(name)) 
[08:28:16.852]                               next
[08:28:16.852]                             if (!grepl(pattern, name)) 
[08:28:16.852]                               next
[08:28:16.852]                             invokeRestart(restart)
[08:28:16.852]                             muffled <- TRUE
[08:28:16.852]                             break
[08:28:16.852]                           }
[08:28:16.852]                         }
[08:28:16.852]                       }
[08:28:16.852]                       invisible(muffled)
[08:28:16.852]                     }
[08:28:16.852]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.852]                   }
[08:28:16.852]                 }
[08:28:16.852]             }
[08:28:16.852]         }))
[08:28:16.852]     }, error = function(ex) {
[08:28:16.852]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:16.852]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.852]                 ...future.rng), started = ...future.startTime, 
[08:28:16.852]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:16.852]             version = "1.8"), class = "FutureResult")
[08:28:16.852]     }, finally = {
[08:28:16.852]         if (!identical(...future.workdir, getwd())) 
[08:28:16.852]             setwd(...future.workdir)
[08:28:16.852]         {
[08:28:16.852]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:16.852]                 ...future.oldOptions$nwarnings <- NULL
[08:28:16.852]             }
[08:28:16.852]             base::options(...future.oldOptions)
[08:28:16.852]             if (.Platform$OS.type == "windows") {
[08:28:16.852]                 old_names <- names(...future.oldEnvVars)
[08:28:16.852]                 envs <- base::Sys.getenv()
[08:28:16.852]                 names <- names(envs)
[08:28:16.852]                 common <- intersect(names, old_names)
[08:28:16.852]                 added <- setdiff(names, old_names)
[08:28:16.852]                 removed <- setdiff(old_names, names)
[08:28:16.852]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:16.852]                   envs[common]]
[08:28:16.852]                 NAMES <- toupper(changed)
[08:28:16.852]                 args <- list()
[08:28:16.852]                 for (kk in seq_along(NAMES)) {
[08:28:16.852]                   name <- changed[[kk]]
[08:28:16.852]                   NAME <- NAMES[[kk]]
[08:28:16.852]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.852]                     next
[08:28:16.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.852]                 }
[08:28:16.852]                 NAMES <- toupper(added)
[08:28:16.852]                 for (kk in seq_along(NAMES)) {
[08:28:16.852]                   name <- added[[kk]]
[08:28:16.852]                   NAME <- NAMES[[kk]]
[08:28:16.852]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.852]                     next
[08:28:16.852]                   args[[name]] <- ""
[08:28:16.852]                 }
[08:28:16.852]                 NAMES <- toupper(removed)
[08:28:16.852]                 for (kk in seq_along(NAMES)) {
[08:28:16.852]                   name <- removed[[kk]]
[08:28:16.852]                   NAME <- NAMES[[kk]]
[08:28:16.852]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.852]                     next
[08:28:16.852]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.852]                 }
[08:28:16.852]                 if (length(args) > 0) 
[08:28:16.852]                   base::do.call(base::Sys.setenv, args = args)
[08:28:16.852]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:16.852]             }
[08:28:16.852]             else {
[08:28:16.852]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:16.852]             }
[08:28:16.852]             {
[08:28:16.852]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:16.852]                   0L) {
[08:28:16.852]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:16.852]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:16.852]                   base::options(opts)
[08:28:16.852]                 }
[08:28:16.852]                 {
[08:28:16.852]                   {
[08:28:16.852]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:16.852]                     NULL
[08:28:16.852]                   }
[08:28:16.852]                   options(future.plan = NULL)
[08:28:16.852]                   if (is.na(NA_character_)) 
[08:28:16.852]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.852]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:16.852]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:16.852]                     .init = FALSE)
[08:28:16.852]                 }
[08:28:16.852]             }
[08:28:16.852]         }
[08:28:16.852]     })
[08:28:16.852]     if (TRUE) {
[08:28:16.852]         base::sink(type = "output", split = FALSE)
[08:28:16.852]         if (TRUE) {
[08:28:16.852]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:16.852]         }
[08:28:16.852]         else {
[08:28:16.852]             ...future.result["stdout"] <- base::list(NULL)
[08:28:16.852]         }
[08:28:16.852]         base::close(...future.stdout)
[08:28:16.852]         ...future.stdout <- NULL
[08:28:16.852]     }
[08:28:16.852]     ...future.result$conditions <- ...future.conditions
[08:28:16.852]     ...future.result$finished <- base::Sys.time()
[08:28:16.852]     ...future.result
[08:28:16.852] }
[08:28:16.855] Poll #1 (0): usedNodes() = 2, workers = 2
[08:28:16.866] receiveMessageFromWorker() for ClusterFuture ...
[08:28:16.866] - Validating connection of MultisessionFuture
[08:28:16.866] - received message: FutureResult
[08:28:16.866] - Received FutureResult
[08:28:16.866] - Erased future from FutureRegistry
[08:28:16.867] result() for ClusterFuture ...
[08:28:16.867] - result already collected: FutureResult
[08:28:16.867] result() for ClusterFuture ... done
[08:28:16.867] signalConditions() ...
[08:28:16.867]  - include = ‘immediateCondition’
[08:28:16.867]  - exclude = 
[08:28:16.867]  - resignal = FALSE
[08:28:16.867]  - Number of conditions: 1
[08:28:16.867] signalConditions() ... done
[08:28:16.867] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:16.867] result() for ClusterFuture ...
[08:28:16.867] - result already collected: FutureResult
[08:28:16.868] result() for ClusterFuture ... done
[08:28:16.868] result() for ClusterFuture ...
[08:28:16.868] - result already collected: FutureResult
[08:28:16.868] result() for ClusterFuture ... done
[08:28:16.868] signalConditions() ...
[08:28:16.868]  - include = ‘immediateCondition’
[08:28:16.868]  - exclude = 
[08:28:16.868]  - resignal = FALSE
[08:28:16.868]  - Number of conditions: 1
[08:28:16.868] signalConditions() ... done
[08:28:16.869] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[08:28:16.869] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:28:16.870] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:28:16.870] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[08:28:16.870] MultisessionFuture started
[08:28:16.871] - Launch lazy future ... done
[08:28:16.871] run() for ‘MultisessionFuture’ ... done
[08:28:16.871] result() for ClusterFuture ...
[08:28:16.871] - result already collected: FutureResult
[08:28:16.871] result() for ClusterFuture ... done
[08:28:16.871] result() for ClusterFuture ...
[08:28:16.872] - result already collected: FutureResult
[08:28:16.872] result() for ClusterFuture ... done
[08:28:16.872] signalConditions() ...
[08:28:16.872]  - include = ‘immediateCondition’
[08:28:16.872]  - exclude = 
[08:28:16.872]  - resignal = FALSE
[08:28:16.872]  - Number of conditions: 1
[08:28:16.873] signalConditions() ... done
[08:28:16.873] Future state: ‘finished’
[08:28:16.873] result() for ClusterFuture ...
[08:28:16.873] - result already collected: FutureResult
[08:28:16.873] result() for ClusterFuture ... done
[08:28:16.873] signalConditions() ...
[08:28:16.873]  - include = ‘condition’
[08:28:16.874]  - exclude = ‘immediateCondition’
[08:28:16.874]  - resignal = TRUE
[08:28:16.874]  - Number of conditions: 1
[08:28:16.874]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:16.874] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:16"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.893] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.893] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.895] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.895] Searching for globals ... DONE
[08:28:16.895] Resolving globals: TRUE
[08:28:16.895] Resolving any globals that are futures ...
[08:28:16.895] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.895] Resolving any globals that are futures ... DONE
[08:28:16.896] Resolving futures part of globals (recursively) ...
[08:28:16.896] resolve() on list ...
[08:28:16.896]  recursive: 99
[08:28:16.896]  length: 1
[08:28:16.896]  elements: ‘ii’
[08:28:16.896]  length: 0 (resolved future 1)
[08:28:16.896] resolve() on list ... DONE
[08:28:16.896] - globals: [1] ‘ii’
[08:28:16.896] Resolving futures part of globals (recursively) ... DONE
[08:28:16.897] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:16.897] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:16.897] - globals: [1] ‘ii’
[08:28:16.897] 
[08:28:16.897] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.898] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.898] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.899] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.899] Searching for globals ... DONE
[08:28:16.899] Resolving globals: TRUE
[08:28:16.899] Resolving any globals that are futures ...
[08:28:16.900] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.900] Resolving any globals that are futures ... DONE
[08:28:16.900] Resolving futures part of globals (recursively) ...
[08:28:16.900] resolve() on list ...
[08:28:16.900]  recursive: 99
[08:28:16.900]  length: 1
[08:28:16.900]  elements: ‘ii’
[08:28:16.901]  length: 0 (resolved future 1)
[08:28:16.901] resolve() on list ... DONE
[08:28:16.901] - globals: [1] ‘ii’
[08:28:16.901] Resolving futures part of globals (recursively) ... DONE
[08:28:16.901] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:16.901] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:16.901] - globals: [1] ‘ii’
[08:28:16.901] 
[08:28:16.902] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:16.902] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:16.902] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:16.903] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.904] Searching for globals ... DONE
[08:28:16.904] Resolving globals: TRUE
[08:28:16.904] Resolving any globals that are futures ...
[08:28:16.904] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[08:28:16.904] Resolving any globals that are futures ... DONE
[08:28:16.904] Resolving futures part of globals (recursively) ...
[08:28:16.904] resolve() on list ...
[08:28:16.905]  recursive: 99
[08:28:16.905]  length: 1
[08:28:16.905]  elements: ‘ii’
[08:28:16.905]  length: 0 (resolved future 1)
[08:28:16.905] resolve() on list ... DONE
[08:28:16.905] - globals: [1] ‘ii’
[08:28:16.905] Resolving futures part of globals (recursively) ... DONE
[08:28:16.905] The total size of the 1 globals is 35 bytes (35 bytes)
[08:28:16.905] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[08:28:16.906] - globals: [1] ‘ii’
[08:28:16.906] 
[08:28:16.906] getGlobalsAndPackages() ... DONE
[08:28:16.906] run() for ‘Future’ ...
[08:28:16.906] - state: ‘created’
[08:28:16.906] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:16.921] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:16.921] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:16.921]   - Field: ‘node’
[08:28:16.921]   - Field: ‘label’
[08:28:16.922]   - Field: ‘local’
[08:28:16.922]   - Field: ‘owner’
[08:28:16.922]   - Field: ‘envir’
[08:28:16.922]   - Field: ‘workers’
[08:28:16.922]   - Field: ‘packages’
[08:28:16.922]   - Field: ‘gc’
[08:28:16.922]   - Field: ‘conditions’
[08:28:16.922]   - Field: ‘persistent’
[08:28:16.922]   - Field: ‘expr’
[08:28:16.922]   - Field: ‘uuid’
[08:28:16.922]   - Field: ‘seed’
[08:28:16.922]   - Field: ‘version’
[08:28:16.923]   - Field: ‘result’
[08:28:16.923]   - Field: ‘asynchronous’
[08:28:16.923]   - Field: ‘calls’
[08:28:16.923]   - Field: ‘globals’
[08:28:16.923]   - Field: ‘stdout’
[08:28:16.923]   - Field: ‘earlySignal’
[08:28:16.923]   - Field: ‘lazy’
[08:28:16.923]   - Field: ‘state’
[08:28:16.923] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:16.923] - Launch lazy future ...
[08:28:16.924] Packages needed by the future expression (n = 0): <none>
[08:28:16.924] Packages needed by future strategies (n = 0): <none>
[08:28:16.924] {
[08:28:16.924]     {
[08:28:16.924]         {
[08:28:16.924]             ...future.startTime <- base::Sys.time()
[08:28:16.924]             {
[08:28:16.924]                 {
[08:28:16.924]                   {
[08:28:16.924]                     {
[08:28:16.924]                       base::local({
[08:28:16.924]                         has_future <- base::requireNamespace("future", 
[08:28:16.924]                           quietly = TRUE)
[08:28:16.924]                         if (has_future) {
[08:28:16.924]                           ns <- base::getNamespace("future")
[08:28:16.924]                           version <- ns[[".package"]][["version"]]
[08:28:16.924]                           if (is.null(version)) 
[08:28:16.924]                             version <- utils::packageVersion("future")
[08:28:16.924]                         }
[08:28:16.924]                         else {
[08:28:16.924]                           version <- NULL
[08:28:16.924]                         }
[08:28:16.924]                         if (!has_future || version < "1.8.0") {
[08:28:16.924]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:16.924]                             "", base::R.version$version.string), 
[08:28:16.924]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:16.924]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:16.924]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:16.924]                               "release", "version")], collapse = " "), 
[08:28:16.924]                             hostname = base::Sys.info()[["nodename"]])
[08:28:16.924]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:16.924]                             info)
[08:28:16.924]                           info <- base::paste(info, collapse = "; ")
[08:28:16.924]                           if (!has_future) {
[08:28:16.924]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:16.924]                               info)
[08:28:16.924]                           }
[08:28:16.924]                           else {
[08:28:16.924]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:16.924]                               info, version)
[08:28:16.924]                           }
[08:28:16.924]                           base::stop(msg)
[08:28:16.924]                         }
[08:28:16.924]                       })
[08:28:16.924]                     }
[08:28:16.924]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:16.924]                     base::options(mc.cores = 1L)
[08:28:16.924]                   }
[08:28:16.924]                   ...future.strategy.old <- future::plan("list")
[08:28:16.924]                   options(future.plan = NULL)
[08:28:16.924]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.924]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:16.924]                 }
[08:28:16.924]                 ...future.workdir <- getwd()
[08:28:16.924]             }
[08:28:16.924]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:16.924]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:16.924]         }
[08:28:16.924]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:16.924]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:16.924]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:16.924]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:16.924]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:16.924]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:16.924]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:16.924]             base::names(...future.oldOptions))
[08:28:16.924]     }
[08:28:16.924]     if (FALSE) {
[08:28:16.924]     }
[08:28:16.924]     else {
[08:28:16.924]         if (TRUE) {
[08:28:16.924]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:16.924]                 open = "w")
[08:28:16.924]         }
[08:28:16.924]         else {
[08:28:16.924]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:16.924]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:16.924]         }
[08:28:16.924]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:16.924]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:16.924]             base::sink(type = "output", split = FALSE)
[08:28:16.924]             base::close(...future.stdout)
[08:28:16.924]         }, add = TRUE)
[08:28:16.924]     }
[08:28:16.924]     ...future.frame <- base::sys.nframe()
[08:28:16.924]     ...future.conditions <- base::list()
[08:28:16.924]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:16.924]     if (FALSE) {
[08:28:16.924]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:16.924]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:16.924]     }
[08:28:16.924]     ...future.result <- base::tryCatch({
[08:28:16.924]         base::withCallingHandlers({
[08:28:16.924]             ...future.value <- base::withVisible(base::local({
[08:28:16.924]                 ...future.makeSendCondition <- base::local({
[08:28:16.924]                   sendCondition <- NULL
[08:28:16.924]                   function(frame = 1L) {
[08:28:16.924]                     if (is.function(sendCondition)) 
[08:28:16.924]                       return(sendCondition)
[08:28:16.924]                     ns <- getNamespace("parallel")
[08:28:16.924]                     if (exists("sendData", mode = "function", 
[08:28:16.924]                       envir = ns)) {
[08:28:16.924]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:16.924]                         envir = ns)
[08:28:16.924]                       envir <- sys.frame(frame)
[08:28:16.924]                       master <- NULL
[08:28:16.924]                       while (!identical(envir, .GlobalEnv) && 
[08:28:16.924]                         !identical(envir, emptyenv())) {
[08:28:16.924]                         if (exists("master", mode = "list", envir = envir, 
[08:28:16.924]                           inherits = FALSE)) {
[08:28:16.924]                           master <- get("master", mode = "list", 
[08:28:16.924]                             envir = envir, inherits = FALSE)
[08:28:16.924]                           if (inherits(master, c("SOCKnode", 
[08:28:16.924]                             "SOCK0node"))) {
[08:28:16.924]                             sendCondition <<- function(cond) {
[08:28:16.924]                               data <- list(type = "VALUE", value = cond, 
[08:28:16.924]                                 success = TRUE)
[08:28:16.924]                               parallel_sendData(master, data)
[08:28:16.924]                             }
[08:28:16.924]                             return(sendCondition)
[08:28:16.924]                           }
[08:28:16.924]                         }
[08:28:16.924]                         frame <- frame + 1L
[08:28:16.924]                         envir <- sys.frame(frame)
[08:28:16.924]                       }
[08:28:16.924]                     }
[08:28:16.924]                     sendCondition <<- function(cond) NULL
[08:28:16.924]                   }
[08:28:16.924]                 })
[08:28:16.924]                 withCallingHandlers({
[08:28:16.924]                   {
[08:28:16.924]                     b <- a * ii
[08:28:16.924]                     a <- 0
[08:28:16.924]                     b
[08:28:16.924]                   }
[08:28:16.924]                 }, immediateCondition = function(cond) {
[08:28:16.924]                   sendCondition <- ...future.makeSendCondition()
[08:28:16.924]                   sendCondition(cond)
[08:28:16.924]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.924]                   {
[08:28:16.924]                     inherits <- base::inherits
[08:28:16.924]                     invokeRestart <- base::invokeRestart
[08:28:16.924]                     is.null <- base::is.null
[08:28:16.924]                     muffled <- FALSE
[08:28:16.924]                     if (inherits(cond, "message")) {
[08:28:16.924]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:16.924]                       if (muffled) 
[08:28:16.924]                         invokeRestart("muffleMessage")
[08:28:16.924]                     }
[08:28:16.924]                     else if (inherits(cond, "warning")) {
[08:28:16.924]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:16.924]                       if (muffled) 
[08:28:16.924]                         invokeRestart("muffleWarning")
[08:28:16.924]                     }
[08:28:16.924]                     else if (inherits(cond, "condition")) {
[08:28:16.924]                       if (!is.null(pattern)) {
[08:28:16.924]                         computeRestarts <- base::computeRestarts
[08:28:16.924]                         grepl <- base::grepl
[08:28:16.924]                         restarts <- computeRestarts(cond)
[08:28:16.924]                         for (restart in restarts) {
[08:28:16.924]                           name <- restart$name
[08:28:16.924]                           if (is.null(name)) 
[08:28:16.924]                             next
[08:28:16.924]                           if (!grepl(pattern, name)) 
[08:28:16.924]                             next
[08:28:16.924]                           invokeRestart(restart)
[08:28:16.924]                           muffled <- TRUE
[08:28:16.924]                           break
[08:28:16.924]                         }
[08:28:16.924]                       }
[08:28:16.924]                     }
[08:28:16.924]                     invisible(muffled)
[08:28:16.924]                   }
[08:28:16.924]                   muffleCondition(cond)
[08:28:16.924]                 })
[08:28:16.924]             }))
[08:28:16.924]             future::FutureResult(value = ...future.value$value, 
[08:28:16.924]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.924]                   ...future.rng), globalenv = if (FALSE) 
[08:28:16.924]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:16.924]                     ...future.globalenv.names))
[08:28:16.924]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:16.924]         }, condition = base::local({
[08:28:16.924]             c <- base::c
[08:28:16.924]             inherits <- base::inherits
[08:28:16.924]             invokeRestart <- base::invokeRestart
[08:28:16.924]             length <- base::length
[08:28:16.924]             list <- base::list
[08:28:16.924]             seq.int <- base::seq.int
[08:28:16.924]             signalCondition <- base::signalCondition
[08:28:16.924]             sys.calls <- base::sys.calls
[08:28:16.924]             `[[` <- base::`[[`
[08:28:16.924]             `+` <- base::`+`
[08:28:16.924]             `<<-` <- base::`<<-`
[08:28:16.924]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:16.924]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:16.924]                   3L)]
[08:28:16.924]             }
[08:28:16.924]             function(cond) {
[08:28:16.924]                 is_error <- inherits(cond, "error")
[08:28:16.924]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:16.924]                   NULL)
[08:28:16.924]                 if (is_error) {
[08:28:16.924]                   sessionInformation <- function() {
[08:28:16.924]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:16.924]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:16.924]                       search = base::search(), system = base::Sys.info())
[08:28:16.924]                   }
[08:28:16.924]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.924]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:16.924]                     cond$call), session = sessionInformation(), 
[08:28:16.924]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:16.924]                   signalCondition(cond)
[08:28:16.924]                 }
[08:28:16.924]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:16.924]                 "immediateCondition"))) {
[08:28:16.924]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:16.924]                   ...future.conditions[[length(...future.conditions) + 
[08:28:16.924]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:16.924]                   if (TRUE && !signal) {
[08:28:16.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.924]                     {
[08:28:16.924]                       inherits <- base::inherits
[08:28:16.924]                       invokeRestart <- base::invokeRestart
[08:28:16.924]                       is.null <- base::is.null
[08:28:16.924]                       muffled <- FALSE
[08:28:16.924]                       if (inherits(cond, "message")) {
[08:28:16.924]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.924]                         if (muffled) 
[08:28:16.924]                           invokeRestart("muffleMessage")
[08:28:16.924]                       }
[08:28:16.924]                       else if (inherits(cond, "warning")) {
[08:28:16.924]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.924]                         if (muffled) 
[08:28:16.924]                           invokeRestart("muffleWarning")
[08:28:16.924]                       }
[08:28:16.924]                       else if (inherits(cond, "condition")) {
[08:28:16.924]                         if (!is.null(pattern)) {
[08:28:16.924]                           computeRestarts <- base::computeRestarts
[08:28:16.924]                           grepl <- base::grepl
[08:28:16.924]                           restarts <- computeRestarts(cond)
[08:28:16.924]                           for (restart in restarts) {
[08:28:16.924]                             name <- restart$name
[08:28:16.924]                             if (is.null(name)) 
[08:28:16.924]                               next
[08:28:16.924]                             if (!grepl(pattern, name)) 
[08:28:16.924]                               next
[08:28:16.924]                             invokeRestart(restart)
[08:28:16.924]                             muffled <- TRUE
[08:28:16.924]                             break
[08:28:16.924]                           }
[08:28:16.924]                         }
[08:28:16.924]                       }
[08:28:16.924]                       invisible(muffled)
[08:28:16.924]                     }
[08:28:16.924]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.924]                   }
[08:28:16.924]                 }
[08:28:16.924]                 else {
[08:28:16.924]                   if (TRUE) {
[08:28:16.924]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:16.924]                     {
[08:28:16.924]                       inherits <- base::inherits
[08:28:16.924]                       invokeRestart <- base::invokeRestart
[08:28:16.924]                       is.null <- base::is.null
[08:28:16.924]                       muffled <- FALSE
[08:28:16.924]                       if (inherits(cond, "message")) {
[08:28:16.924]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:16.924]                         if (muffled) 
[08:28:16.924]                           invokeRestart("muffleMessage")
[08:28:16.924]                       }
[08:28:16.924]                       else if (inherits(cond, "warning")) {
[08:28:16.924]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:16.924]                         if (muffled) 
[08:28:16.924]                           invokeRestart("muffleWarning")
[08:28:16.924]                       }
[08:28:16.924]                       else if (inherits(cond, "condition")) {
[08:28:16.924]                         if (!is.null(pattern)) {
[08:28:16.924]                           computeRestarts <- base::computeRestarts
[08:28:16.924]                           grepl <- base::grepl
[08:28:16.924]                           restarts <- computeRestarts(cond)
[08:28:16.924]                           for (restart in restarts) {
[08:28:16.924]                             name <- restart$name
[08:28:16.924]                             if (is.null(name)) 
[08:28:16.924]                               next
[08:28:16.924]                             if (!grepl(pattern, name)) 
[08:28:16.924]                               next
[08:28:16.924]                             invokeRestart(restart)
[08:28:16.924]                             muffled <- TRUE
[08:28:16.924]                             break
[08:28:16.924]                           }
[08:28:16.924]                         }
[08:28:16.924]                       }
[08:28:16.924]                       invisible(muffled)
[08:28:16.924]                     }
[08:28:16.924]                     muffleCondition(cond, pattern = "^muffle")
[08:28:16.924]                   }
[08:28:16.924]                 }
[08:28:16.924]             }
[08:28:16.924]         }))
[08:28:16.924]     }, error = function(ex) {
[08:28:16.924]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:16.924]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:16.924]                 ...future.rng), started = ...future.startTime, 
[08:28:16.924]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:16.924]             version = "1.8"), class = "FutureResult")
[08:28:16.924]     }, finally = {
[08:28:16.924]         if (!identical(...future.workdir, getwd())) 
[08:28:16.924]             setwd(...future.workdir)
[08:28:16.924]         {
[08:28:16.924]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:16.924]                 ...future.oldOptions$nwarnings <- NULL
[08:28:16.924]             }
[08:28:16.924]             base::options(...future.oldOptions)
[08:28:16.924]             if (.Platform$OS.type == "windows") {
[08:28:16.924]                 old_names <- names(...future.oldEnvVars)
[08:28:16.924]                 envs <- base::Sys.getenv()
[08:28:16.924]                 names <- names(envs)
[08:28:16.924]                 common <- intersect(names, old_names)
[08:28:16.924]                 added <- setdiff(names, old_names)
[08:28:16.924]                 removed <- setdiff(old_names, names)
[08:28:16.924]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:16.924]                   envs[common]]
[08:28:16.924]                 NAMES <- toupper(changed)
[08:28:16.924]                 args <- list()
[08:28:16.924]                 for (kk in seq_along(NAMES)) {
[08:28:16.924]                   name <- changed[[kk]]
[08:28:16.924]                   NAME <- NAMES[[kk]]
[08:28:16.924]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.924]                     next
[08:28:16.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.924]                 }
[08:28:16.924]                 NAMES <- toupper(added)
[08:28:16.924]                 for (kk in seq_along(NAMES)) {
[08:28:16.924]                   name <- added[[kk]]
[08:28:16.924]                   NAME <- NAMES[[kk]]
[08:28:16.924]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.924]                     next
[08:28:16.924]                   args[[name]] <- ""
[08:28:16.924]                 }
[08:28:16.924]                 NAMES <- toupper(removed)
[08:28:16.924]                 for (kk in seq_along(NAMES)) {
[08:28:16.924]                   name <- removed[[kk]]
[08:28:16.924]                   NAME <- NAMES[[kk]]
[08:28:16.924]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:16.924]                     next
[08:28:16.924]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:16.924]                 }
[08:28:16.924]                 if (length(args) > 0) 
[08:28:16.924]                   base::do.call(base::Sys.setenv, args = args)
[08:28:16.924]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:16.924]             }
[08:28:16.924]             else {
[08:28:16.924]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:16.924]             }
[08:28:16.924]             {
[08:28:16.924]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:16.924]                   0L) {
[08:28:16.924]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:16.924]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:16.924]                   base::options(opts)
[08:28:16.924]                 }
[08:28:16.924]                 {
[08:28:16.924]                   {
[08:28:16.924]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:16.924]                     NULL
[08:28:16.924]                   }
[08:28:16.924]                   options(future.plan = NULL)
[08:28:16.924]                   if (is.na(NA_character_)) 
[08:28:16.924]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:16.924]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:16.924]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:16.924]                     .init = FALSE)
[08:28:16.924]                 }
[08:28:16.924]             }
[08:28:16.924]         }
[08:28:16.924]     })
[08:28:16.924]     if (TRUE) {
[08:28:16.924]         base::sink(type = "output", split = FALSE)
[08:28:16.924]         if (TRUE) {
[08:28:16.924]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:16.924]         }
[08:28:16.924]         else {
[08:28:16.924]             ...future.result["stdout"] <- base::list(NULL)
[08:28:16.924]         }
[08:28:16.924]         base::close(...future.stdout)
[08:28:16.924]         ...future.stdout <- NULL
[08:28:16.924]     }
[08:28:16.924]     ...future.result$conditions <- ...future.conditions
[08:28:16.924]     ...future.result$finished <- base::Sys.time()
[08:28:16.924]     ...future.result
[08:28:16.924] }
[08:28:16.926] Poll #1 (0): usedNodes() = 2, workers = 2
[08:28:16.937] receiveMessageFromWorker() for ClusterFuture ...
[08:28:16.937] - Validating connection of MultisessionFuture
[08:28:16.938] - received message: FutureResult
[08:28:16.938] - Received FutureResult
[08:28:16.938] - Erased future from FutureRegistry
[08:28:16.938] result() for ClusterFuture ...
[08:28:16.938] - result already collected: FutureResult
[08:28:16.938] result() for ClusterFuture ... done
[08:28:16.938] signalConditions() ...
[08:28:16.939]  - include = ‘immediateCondition’
[08:28:16.939]  - exclude = 
[08:28:16.939]  - resignal = FALSE
[08:28:16.941]  - Number of conditions: 1
[08:28:16.941] signalConditions() ... done
[08:28:16.941] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:16.941] result() for ClusterFuture ...
[08:28:16.941] - result already collected: FutureResult
[08:28:16.941] result() for ClusterFuture ... done
[08:28:16.941] result() for ClusterFuture ...
[08:28:16.941] - result already collected: FutureResult
[08:28:16.942] result() for ClusterFuture ... done
[08:28:16.942] signalConditions() ...
[08:28:16.942]  - include = ‘immediateCondition’
[08:28:16.942]  - exclude = 
[08:28:16.942]  - resignal = FALSE
[08:28:16.942]  - Number of conditions: 1
[08:28:16.942] signalConditions() ... done
[08:28:16.943] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[08:28:16.943] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:28:16.943] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:28:16.943] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[08:28:16.944] MultisessionFuture started
[08:28:16.944] - Launch lazy future ... done
[08:28:16.944] run() for ‘MultisessionFuture’ ... done
[08:28:16.944] result() for ClusterFuture ...
[08:28:16.944] receiveMessageFromWorker() for ClusterFuture ...
[08:28:16.944] - Validating connection of MultisessionFuture
[08:28:16.990] - received message: FutureResult
[08:28:16.990] - Received FutureResult
[08:28:16.991] - Erased future from FutureRegistry
[08:28:16.991] result() for ClusterFuture ...
[08:28:16.991] - result already collected: FutureResult
[08:28:16.991] result() for ClusterFuture ... done
[08:28:16.991] signalConditions() ...
[08:28:16.991]  - include = ‘immediateCondition’
[08:28:16.991]  - exclude = 
[08:28:16.991]  - resignal = FALSE
[08:28:16.991]  - Number of conditions: 1
[08:28:16.991] signalConditions() ... done
[08:28:16.991] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:16.991] result() for ClusterFuture ... done
[08:28:16.992] result() for ClusterFuture ...
[08:28:16.992] - result already collected: FutureResult
[08:28:16.992] result() for ClusterFuture ... done
[08:28:16.992] signalConditions() ...
[08:28:16.992]  - include = ‘immediateCondition’
[08:28:16.992]  - exclude = 
[08:28:16.992]  - resignal = FALSE
[08:28:16.992]  - Number of conditions: 1
[08:28:16.992] signalConditions() ... done
[08:28:16.992] Future state: ‘finished’
[08:28:16.992] result() for ClusterFuture ...
[08:28:16.992] - result already collected: FutureResult
[08:28:16.993] result() for ClusterFuture ... done
[08:28:16.993] signalConditions() ...
[08:28:16.993]  - include = ‘condition’
[08:28:16.993]  - exclude = ‘immediateCondition’
[08:28:16.993]  - resignal = TRUE
[08:28:16.993]  - Number of conditions: 1
[08:28:16.993]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[08:28:16.993] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1015-azure" "#15~24.04.1-Ubuntu SMP Thu May  1 02:52:08 UTC 2025" "e9e776910d73" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-06-17 08:28:16"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.006] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.006] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.007] 
[08:28:17.007] Searching for globals ... DONE
[08:28:17.007] - globals: [0] <none>
[08:28:17.007] getGlobalsAndPackages() ... DONE
[08:28:17.007] run() for ‘Future’ ...
[08:28:17.008] - state: ‘created’
[08:28:17.008] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.022] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.022] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.022]   - Field: ‘node’
[08:28:17.022]   - Field: ‘label’
[08:28:17.022]   - Field: ‘local’
[08:28:17.022]   - Field: ‘owner’
[08:28:17.022]   - Field: ‘envir’
[08:28:17.023]   - Field: ‘workers’
[08:28:17.023]   - Field: ‘packages’
[08:28:17.023]   - Field: ‘gc’
[08:28:17.023]   - Field: ‘conditions’
[08:28:17.023]   - Field: ‘persistent’
[08:28:17.023]   - Field: ‘expr’
[08:28:17.023]   - Field: ‘uuid’
[08:28:17.023]   - Field: ‘seed’
[08:28:17.023]   - Field: ‘version’
[08:28:17.023]   - Field: ‘result’
[08:28:17.023]   - Field: ‘asynchronous’
[08:28:17.023]   - Field: ‘calls’
[08:28:17.024]   - Field: ‘globals’
[08:28:17.024]   - Field: ‘stdout’
[08:28:17.024]   - Field: ‘earlySignal’
[08:28:17.024]   - Field: ‘lazy’
[08:28:17.024]   - Field: ‘state’
[08:28:17.024] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.024] - Launch lazy future ...
[08:28:17.024] Packages needed by the future expression (n = 0): <none>
[08:28:17.024] Packages needed by future strategies (n = 0): <none>
[08:28:17.025] {
[08:28:17.025]     {
[08:28:17.025]         {
[08:28:17.025]             ...future.startTime <- base::Sys.time()
[08:28:17.025]             {
[08:28:17.025]                 {
[08:28:17.025]                   {
[08:28:17.025]                     {
[08:28:17.025]                       base::local({
[08:28:17.025]                         has_future <- base::requireNamespace("future", 
[08:28:17.025]                           quietly = TRUE)
[08:28:17.025]                         if (has_future) {
[08:28:17.025]                           ns <- base::getNamespace("future")
[08:28:17.025]                           version <- ns[[".package"]][["version"]]
[08:28:17.025]                           if (is.null(version)) 
[08:28:17.025]                             version <- utils::packageVersion("future")
[08:28:17.025]                         }
[08:28:17.025]                         else {
[08:28:17.025]                           version <- NULL
[08:28:17.025]                         }
[08:28:17.025]                         if (!has_future || version < "1.8.0") {
[08:28:17.025]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.025]                             "", base::R.version$version.string), 
[08:28:17.025]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:17.025]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:17.025]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.025]                               "release", "version")], collapse = " "), 
[08:28:17.025]                             hostname = base::Sys.info()[["nodename"]])
[08:28:17.025]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.025]                             info)
[08:28:17.025]                           info <- base::paste(info, collapse = "; ")
[08:28:17.025]                           if (!has_future) {
[08:28:17.025]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.025]                               info)
[08:28:17.025]                           }
[08:28:17.025]                           else {
[08:28:17.025]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.025]                               info, version)
[08:28:17.025]                           }
[08:28:17.025]                           base::stop(msg)
[08:28:17.025]                         }
[08:28:17.025]                       })
[08:28:17.025]                     }
[08:28:17.025]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.025]                     base::options(mc.cores = 1L)
[08:28:17.025]                   }
[08:28:17.025]                   ...future.strategy.old <- future::plan("list")
[08:28:17.025]                   options(future.plan = NULL)
[08:28:17.025]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.025]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.025]                 }
[08:28:17.025]                 ...future.workdir <- getwd()
[08:28:17.025]             }
[08:28:17.025]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.025]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.025]         }
[08:28:17.025]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.025]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.025]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.025]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.025]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.025]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.025]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.025]             base::names(...future.oldOptions))
[08:28:17.025]     }
[08:28:17.025]     if (FALSE) {
[08:28:17.025]     }
[08:28:17.025]     else {
[08:28:17.025]         if (TRUE) {
[08:28:17.025]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.025]                 open = "w")
[08:28:17.025]         }
[08:28:17.025]         else {
[08:28:17.025]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.025]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.025]         }
[08:28:17.025]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.025]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.025]             base::sink(type = "output", split = FALSE)
[08:28:17.025]             base::close(...future.stdout)
[08:28:17.025]         }, add = TRUE)
[08:28:17.025]     }
[08:28:17.025]     ...future.frame <- base::sys.nframe()
[08:28:17.025]     ...future.conditions <- base::list()
[08:28:17.025]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.025]     if (FALSE) {
[08:28:17.025]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.025]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.025]     }
[08:28:17.025]     ...future.result <- base::tryCatch({
[08:28:17.025]         base::withCallingHandlers({
[08:28:17.025]             ...future.value <- base::withVisible(base::local({
[08:28:17.025]                 ...future.makeSendCondition <- base::local({
[08:28:17.025]                   sendCondition <- NULL
[08:28:17.025]                   function(frame = 1L) {
[08:28:17.025]                     if (is.function(sendCondition)) 
[08:28:17.025]                       return(sendCondition)
[08:28:17.025]                     ns <- getNamespace("parallel")
[08:28:17.025]                     if (exists("sendData", mode = "function", 
[08:28:17.025]                       envir = ns)) {
[08:28:17.025]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.025]                         envir = ns)
[08:28:17.025]                       envir <- sys.frame(frame)
[08:28:17.025]                       master <- NULL
[08:28:17.025]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.025]                         !identical(envir, emptyenv())) {
[08:28:17.025]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.025]                           inherits = FALSE)) {
[08:28:17.025]                           master <- get("master", mode = "list", 
[08:28:17.025]                             envir = envir, inherits = FALSE)
[08:28:17.025]                           if (inherits(master, c("SOCKnode", 
[08:28:17.025]                             "SOCK0node"))) {
[08:28:17.025]                             sendCondition <<- function(cond) {
[08:28:17.025]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.025]                                 success = TRUE)
[08:28:17.025]                               parallel_sendData(master, data)
[08:28:17.025]                             }
[08:28:17.025]                             return(sendCondition)
[08:28:17.025]                           }
[08:28:17.025]                         }
[08:28:17.025]                         frame <- frame + 1L
[08:28:17.025]                         envir <- sys.frame(frame)
[08:28:17.025]                       }
[08:28:17.025]                     }
[08:28:17.025]                     sendCondition <<- function(cond) NULL
[08:28:17.025]                   }
[08:28:17.025]                 })
[08:28:17.025]                 withCallingHandlers({
[08:28:17.025]                   1
[08:28:17.025]                 }, immediateCondition = function(cond) {
[08:28:17.025]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.025]                   sendCondition(cond)
[08:28:17.025]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.025]                   {
[08:28:17.025]                     inherits <- base::inherits
[08:28:17.025]                     invokeRestart <- base::invokeRestart
[08:28:17.025]                     is.null <- base::is.null
[08:28:17.025]                     muffled <- FALSE
[08:28:17.025]                     if (inherits(cond, "message")) {
[08:28:17.025]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.025]                       if (muffled) 
[08:28:17.025]                         invokeRestart("muffleMessage")
[08:28:17.025]                     }
[08:28:17.025]                     else if (inherits(cond, "warning")) {
[08:28:17.025]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.025]                       if (muffled) 
[08:28:17.025]                         invokeRestart("muffleWarning")
[08:28:17.025]                     }
[08:28:17.025]                     else if (inherits(cond, "condition")) {
[08:28:17.025]                       if (!is.null(pattern)) {
[08:28:17.025]                         computeRestarts <- base::computeRestarts
[08:28:17.025]                         grepl <- base::grepl
[08:28:17.025]                         restarts <- computeRestarts(cond)
[08:28:17.025]                         for (restart in restarts) {
[08:28:17.025]                           name <- restart$name
[08:28:17.025]                           if (is.null(name)) 
[08:28:17.025]                             next
[08:28:17.025]                           if (!grepl(pattern, name)) 
[08:28:17.025]                             next
[08:28:17.025]                           invokeRestart(restart)
[08:28:17.025]                           muffled <- TRUE
[08:28:17.025]                           break
[08:28:17.025]                         }
[08:28:17.025]                       }
[08:28:17.025]                     }
[08:28:17.025]                     invisible(muffled)
[08:28:17.025]                   }
[08:28:17.025]                   muffleCondition(cond)
[08:28:17.025]                 })
[08:28:17.025]             }))
[08:28:17.025]             future::FutureResult(value = ...future.value$value, 
[08:28:17.025]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.025]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.025]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.025]                     ...future.globalenv.names))
[08:28:17.025]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.025]         }, condition = base::local({
[08:28:17.025]             c <- base::c
[08:28:17.025]             inherits <- base::inherits
[08:28:17.025]             invokeRestart <- base::invokeRestart
[08:28:17.025]             length <- base::length
[08:28:17.025]             list <- base::list
[08:28:17.025]             seq.int <- base::seq.int
[08:28:17.025]             signalCondition <- base::signalCondition
[08:28:17.025]             sys.calls <- base::sys.calls
[08:28:17.025]             `[[` <- base::`[[`
[08:28:17.025]             `+` <- base::`+`
[08:28:17.025]             `<<-` <- base::`<<-`
[08:28:17.025]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.025]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.025]                   3L)]
[08:28:17.025]             }
[08:28:17.025]             function(cond) {
[08:28:17.025]                 is_error <- inherits(cond, "error")
[08:28:17.025]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.025]                   NULL)
[08:28:17.025]                 if (is_error) {
[08:28:17.025]                   sessionInformation <- function() {
[08:28:17.025]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.025]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.025]                       search = base::search(), system = base::Sys.info())
[08:28:17.025]                   }
[08:28:17.025]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.025]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.025]                     cond$call), session = sessionInformation(), 
[08:28:17.025]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.025]                   signalCondition(cond)
[08:28:17.025]                 }
[08:28:17.025]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.025]                 "immediateCondition"))) {
[08:28:17.025]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.025]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.025]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.025]                   if (TRUE && !signal) {
[08:28:17.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.025]                     {
[08:28:17.025]                       inherits <- base::inherits
[08:28:17.025]                       invokeRestart <- base::invokeRestart
[08:28:17.025]                       is.null <- base::is.null
[08:28:17.025]                       muffled <- FALSE
[08:28:17.025]                       if (inherits(cond, "message")) {
[08:28:17.025]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.025]                         if (muffled) 
[08:28:17.025]                           invokeRestart("muffleMessage")
[08:28:17.025]                       }
[08:28:17.025]                       else if (inherits(cond, "warning")) {
[08:28:17.025]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.025]                         if (muffled) 
[08:28:17.025]                           invokeRestart("muffleWarning")
[08:28:17.025]                       }
[08:28:17.025]                       else if (inherits(cond, "condition")) {
[08:28:17.025]                         if (!is.null(pattern)) {
[08:28:17.025]                           computeRestarts <- base::computeRestarts
[08:28:17.025]                           grepl <- base::grepl
[08:28:17.025]                           restarts <- computeRestarts(cond)
[08:28:17.025]                           for (restart in restarts) {
[08:28:17.025]                             name <- restart$name
[08:28:17.025]                             if (is.null(name)) 
[08:28:17.025]                               next
[08:28:17.025]                             if (!grepl(pattern, name)) 
[08:28:17.025]                               next
[08:28:17.025]                             invokeRestart(restart)
[08:28:17.025]                             muffled <- TRUE
[08:28:17.025]                             break
[08:28:17.025]                           }
[08:28:17.025]                         }
[08:28:17.025]                       }
[08:28:17.025]                       invisible(muffled)
[08:28:17.025]                     }
[08:28:17.025]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.025]                   }
[08:28:17.025]                 }
[08:28:17.025]                 else {
[08:28:17.025]                   if (TRUE) {
[08:28:17.025]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.025]                     {
[08:28:17.025]                       inherits <- base::inherits
[08:28:17.025]                       invokeRestart <- base::invokeRestart
[08:28:17.025]                       is.null <- base::is.null
[08:28:17.025]                       muffled <- FALSE
[08:28:17.025]                       if (inherits(cond, "message")) {
[08:28:17.025]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.025]                         if (muffled) 
[08:28:17.025]                           invokeRestart("muffleMessage")
[08:28:17.025]                       }
[08:28:17.025]                       else if (inherits(cond, "warning")) {
[08:28:17.025]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.025]                         if (muffled) 
[08:28:17.025]                           invokeRestart("muffleWarning")
[08:28:17.025]                       }
[08:28:17.025]                       else if (inherits(cond, "condition")) {
[08:28:17.025]                         if (!is.null(pattern)) {
[08:28:17.025]                           computeRestarts <- base::computeRestarts
[08:28:17.025]                           grepl <- base::grepl
[08:28:17.025]                           restarts <- computeRestarts(cond)
[08:28:17.025]                           for (restart in restarts) {
[08:28:17.025]                             name <- restart$name
[08:28:17.025]                             if (is.null(name)) 
[08:28:17.025]                               next
[08:28:17.025]                             if (!grepl(pattern, name)) 
[08:28:17.025]                               next
[08:28:17.025]                             invokeRestart(restart)
[08:28:17.025]                             muffled <- TRUE
[08:28:17.025]                             break
[08:28:17.025]                           }
[08:28:17.025]                         }
[08:28:17.025]                       }
[08:28:17.025]                       invisible(muffled)
[08:28:17.025]                     }
[08:28:17.025]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.025]                   }
[08:28:17.025]                 }
[08:28:17.025]             }
[08:28:17.025]         }))
[08:28:17.025]     }, error = function(ex) {
[08:28:17.025]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.025]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.025]                 ...future.rng), started = ...future.startTime, 
[08:28:17.025]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.025]             version = "1.8"), class = "FutureResult")
[08:28:17.025]     }, finally = {
[08:28:17.025]         if (!identical(...future.workdir, getwd())) 
[08:28:17.025]             setwd(...future.workdir)
[08:28:17.025]         {
[08:28:17.025]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.025]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.025]             }
[08:28:17.025]             base::options(...future.oldOptions)
[08:28:17.025]             if (.Platform$OS.type == "windows") {
[08:28:17.025]                 old_names <- names(...future.oldEnvVars)
[08:28:17.025]                 envs <- base::Sys.getenv()
[08:28:17.025]                 names <- names(envs)
[08:28:17.025]                 common <- intersect(names, old_names)
[08:28:17.025]                 added <- setdiff(names, old_names)
[08:28:17.025]                 removed <- setdiff(old_names, names)
[08:28:17.025]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.025]                   envs[common]]
[08:28:17.025]                 NAMES <- toupper(changed)
[08:28:17.025]                 args <- list()
[08:28:17.025]                 for (kk in seq_along(NAMES)) {
[08:28:17.025]                   name <- changed[[kk]]
[08:28:17.025]                   NAME <- NAMES[[kk]]
[08:28:17.025]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.025]                     next
[08:28:17.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.025]                 }
[08:28:17.025]                 NAMES <- toupper(added)
[08:28:17.025]                 for (kk in seq_along(NAMES)) {
[08:28:17.025]                   name <- added[[kk]]
[08:28:17.025]                   NAME <- NAMES[[kk]]
[08:28:17.025]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.025]                     next
[08:28:17.025]                   args[[name]] <- ""
[08:28:17.025]                 }
[08:28:17.025]                 NAMES <- toupper(removed)
[08:28:17.025]                 for (kk in seq_along(NAMES)) {
[08:28:17.025]                   name <- removed[[kk]]
[08:28:17.025]                   NAME <- NAMES[[kk]]
[08:28:17.025]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.025]                     next
[08:28:17.025]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.025]                 }
[08:28:17.025]                 if (length(args) > 0) 
[08:28:17.025]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.025]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.025]             }
[08:28:17.025]             else {
[08:28:17.025]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.025]             }
[08:28:17.025]             {
[08:28:17.025]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.025]                   0L) {
[08:28:17.025]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.025]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.025]                   base::options(opts)
[08:28:17.025]                 }
[08:28:17.025]                 {
[08:28:17.025]                   {
[08:28:17.025]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.025]                     NULL
[08:28:17.025]                   }
[08:28:17.025]                   options(future.plan = NULL)
[08:28:17.025]                   if (is.na(NA_character_)) 
[08:28:17.025]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.025]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.025]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.025]                     .init = FALSE)
[08:28:17.025]                 }
[08:28:17.025]             }
[08:28:17.025]         }
[08:28:17.025]     })
[08:28:17.025]     if (TRUE) {
[08:28:17.025]         base::sink(type = "output", split = FALSE)
[08:28:17.025]         if (TRUE) {
[08:28:17.025]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.025]         }
[08:28:17.025]         else {
[08:28:17.025]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.025]         }
[08:28:17.025]         base::close(...future.stdout)
[08:28:17.025]         ...future.stdout <- NULL
[08:28:17.025]     }
[08:28:17.025]     ...future.result$conditions <- ...future.conditions
[08:28:17.025]     ...future.result$finished <- base::Sys.time()
[08:28:17.025]     ...future.result
[08:28:17.025] }
[08:28:17.028] MultisessionFuture started
[08:28:17.028] - Launch lazy future ... done
[08:28:17.028] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.028] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.029] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.029] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:17.030] Searching for globals ... DONE
[08:28:17.030] Resolving globals: TRUE
[08:28:17.030] Resolving any globals that are futures ...
[08:28:17.030] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:17.030] Resolving any globals that are futures ... DONE
[08:28:17.030] Resolving futures part of globals (recursively) ...
[08:28:17.031] resolve() on list ...
[08:28:17.031]  recursive: 99
[08:28:17.031]  length: 1
[08:28:17.031]  elements: ‘a’
[08:28:17.072] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.073] - Validating connection of MultisessionFuture
[08:28:17.073] - received message: FutureResult
[08:28:17.073] - Received FutureResult
[08:28:17.073] - Erased future from FutureRegistry
[08:28:17.073] result() for ClusterFuture ...
[08:28:17.073] - result already collected: FutureResult
[08:28:17.073] result() for ClusterFuture ... done
[08:28:17.073] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.074] Future #1
[08:28:17.074] result() for ClusterFuture ...
[08:28:17.074] - result already collected: FutureResult
[08:28:17.074] result() for ClusterFuture ... done
[08:28:17.074] result() for ClusterFuture ...
[08:28:17.074] - result already collected: FutureResult
[08:28:17.074] result() for ClusterFuture ... done
[08:28:17.074] A MultisessionFuture was resolved
[08:28:17.074]  length: 0 (resolved future 1)
[08:28:17.074] resolve() on list ... DONE
[08:28:17.074] - globals: [1] ‘a’
[08:28:17.075] Resolving futures part of globals (recursively) ... DONE
[08:28:17.086] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[08:28:17.086] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[08:28:17.086] - globals: [1] ‘a’
[08:28:17.086] - packages: [1] ‘future’
[08:28:17.086] getGlobalsAndPackages() ... DONE
[08:28:17.087] run() for ‘Future’ ...
[08:28:17.087] - state: ‘created’
[08:28:17.087] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.101] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.101] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.101]   - Field: ‘node’
[08:28:17.101]   - Field: ‘label’
[08:28:17.101]   - Field: ‘local’
[08:28:17.101]   - Field: ‘owner’
[08:28:17.101]   - Field: ‘envir’
[08:28:17.102]   - Field: ‘workers’
[08:28:17.102]   - Field: ‘packages’
[08:28:17.102]   - Field: ‘gc’
[08:28:17.102]   - Field: ‘conditions’
[08:28:17.102]   - Field: ‘persistent’
[08:28:17.102]   - Field: ‘expr’
[08:28:17.102]   - Field: ‘uuid’
[08:28:17.102]   - Field: ‘seed’
[08:28:17.102]   - Field: ‘version’
[08:28:17.102]   - Field: ‘result’
[08:28:17.102]   - Field: ‘asynchronous’
[08:28:17.102]   - Field: ‘calls’
[08:28:17.103]   - Field: ‘globals’
[08:28:17.103]   - Field: ‘stdout’
[08:28:17.103]   - Field: ‘earlySignal’
[08:28:17.103]   - Field: ‘lazy’
[08:28:17.103]   - Field: ‘state’
[08:28:17.103] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.103] - Launch lazy future ...
[08:28:17.103] Packages needed by the future expression (n = 1): ‘future’
[08:28:17.103] Packages needed by future strategies (n = 0): <none>
[08:28:17.104] {
[08:28:17.104]     {
[08:28:17.104]         {
[08:28:17.104]             ...future.startTime <- base::Sys.time()
[08:28:17.104]             {
[08:28:17.104]                 {
[08:28:17.104]                   {
[08:28:17.104]                     {
[08:28:17.104]                       {
[08:28:17.104]                         base::local({
[08:28:17.104]                           has_future <- base::requireNamespace("future", 
[08:28:17.104]                             quietly = TRUE)
[08:28:17.104]                           if (has_future) {
[08:28:17.104]                             ns <- base::getNamespace("future")
[08:28:17.104]                             version <- ns[[".package"]][["version"]]
[08:28:17.104]                             if (is.null(version)) 
[08:28:17.104]                               version <- utils::packageVersion("future")
[08:28:17.104]                           }
[08:28:17.104]                           else {
[08:28:17.104]                             version <- NULL
[08:28:17.104]                           }
[08:28:17.104]                           if (!has_future || version < "1.8.0") {
[08:28:17.104]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.104]                               "", base::R.version$version.string), 
[08:28:17.104]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:17.104]                                 base::R.version$platform, 8 * 
[08:28:17.104]                                   base::.Machine$sizeof.pointer), 
[08:28:17.104]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.104]                                 "release", "version")], collapse = " "), 
[08:28:17.104]                               hostname = base::Sys.info()[["nodename"]])
[08:28:17.104]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.104]                               info)
[08:28:17.104]                             info <- base::paste(info, collapse = "; ")
[08:28:17.104]                             if (!has_future) {
[08:28:17.104]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.104]                                 info)
[08:28:17.104]                             }
[08:28:17.104]                             else {
[08:28:17.104]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.104]                                 info, version)
[08:28:17.104]                             }
[08:28:17.104]                             base::stop(msg)
[08:28:17.104]                           }
[08:28:17.104]                         })
[08:28:17.104]                       }
[08:28:17.104]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.104]                       base::options(mc.cores = 1L)
[08:28:17.104]                     }
[08:28:17.104]                     base::local({
[08:28:17.104]                       for (pkg in "future") {
[08:28:17.104]                         base::loadNamespace(pkg)
[08:28:17.104]                         base::library(pkg, character.only = TRUE)
[08:28:17.104]                       }
[08:28:17.104]                     })
[08:28:17.104]                   }
[08:28:17.104]                   ...future.strategy.old <- future::plan("list")
[08:28:17.104]                   options(future.plan = NULL)
[08:28:17.104]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.104]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.104]                 }
[08:28:17.104]                 ...future.workdir <- getwd()
[08:28:17.104]             }
[08:28:17.104]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.104]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.104]         }
[08:28:17.104]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.104]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.104]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.104]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.104]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.104]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.104]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.104]             base::names(...future.oldOptions))
[08:28:17.104]     }
[08:28:17.104]     if (FALSE) {
[08:28:17.104]     }
[08:28:17.104]     else {
[08:28:17.104]         if (TRUE) {
[08:28:17.104]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.104]                 open = "w")
[08:28:17.104]         }
[08:28:17.104]         else {
[08:28:17.104]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.104]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.104]         }
[08:28:17.104]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.104]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.104]             base::sink(type = "output", split = FALSE)
[08:28:17.104]             base::close(...future.stdout)
[08:28:17.104]         }, add = TRUE)
[08:28:17.104]     }
[08:28:17.104]     ...future.frame <- base::sys.nframe()
[08:28:17.104]     ...future.conditions <- base::list()
[08:28:17.104]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.104]     if (FALSE) {
[08:28:17.104]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.104]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.104]     }
[08:28:17.104]     ...future.result <- base::tryCatch({
[08:28:17.104]         base::withCallingHandlers({
[08:28:17.104]             ...future.value <- base::withVisible(base::local({
[08:28:17.104]                 ...future.makeSendCondition <- base::local({
[08:28:17.104]                   sendCondition <- NULL
[08:28:17.104]                   function(frame = 1L) {
[08:28:17.104]                     if (is.function(sendCondition)) 
[08:28:17.104]                       return(sendCondition)
[08:28:17.104]                     ns <- getNamespace("parallel")
[08:28:17.104]                     if (exists("sendData", mode = "function", 
[08:28:17.104]                       envir = ns)) {
[08:28:17.104]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.104]                         envir = ns)
[08:28:17.104]                       envir <- sys.frame(frame)
[08:28:17.104]                       master <- NULL
[08:28:17.104]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.104]                         !identical(envir, emptyenv())) {
[08:28:17.104]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.104]                           inherits = FALSE)) {
[08:28:17.104]                           master <- get("master", mode = "list", 
[08:28:17.104]                             envir = envir, inherits = FALSE)
[08:28:17.104]                           if (inherits(master, c("SOCKnode", 
[08:28:17.104]                             "SOCK0node"))) {
[08:28:17.104]                             sendCondition <<- function(cond) {
[08:28:17.104]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.104]                                 success = TRUE)
[08:28:17.104]                               parallel_sendData(master, data)
[08:28:17.104]                             }
[08:28:17.104]                             return(sendCondition)
[08:28:17.104]                           }
[08:28:17.104]                         }
[08:28:17.104]                         frame <- frame + 1L
[08:28:17.104]                         envir <- sys.frame(frame)
[08:28:17.104]                       }
[08:28:17.104]                     }
[08:28:17.104]                     sendCondition <<- function(cond) NULL
[08:28:17.104]                   }
[08:28:17.104]                 })
[08:28:17.104]                 withCallingHandlers({
[08:28:17.104]                   value(a) + 1
[08:28:17.104]                 }, immediateCondition = function(cond) {
[08:28:17.104]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.104]                   sendCondition(cond)
[08:28:17.104]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.104]                   {
[08:28:17.104]                     inherits <- base::inherits
[08:28:17.104]                     invokeRestart <- base::invokeRestart
[08:28:17.104]                     is.null <- base::is.null
[08:28:17.104]                     muffled <- FALSE
[08:28:17.104]                     if (inherits(cond, "message")) {
[08:28:17.104]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.104]                       if (muffled) 
[08:28:17.104]                         invokeRestart("muffleMessage")
[08:28:17.104]                     }
[08:28:17.104]                     else if (inherits(cond, "warning")) {
[08:28:17.104]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.104]                       if (muffled) 
[08:28:17.104]                         invokeRestart("muffleWarning")
[08:28:17.104]                     }
[08:28:17.104]                     else if (inherits(cond, "condition")) {
[08:28:17.104]                       if (!is.null(pattern)) {
[08:28:17.104]                         computeRestarts <- base::computeRestarts
[08:28:17.104]                         grepl <- base::grepl
[08:28:17.104]                         restarts <- computeRestarts(cond)
[08:28:17.104]                         for (restart in restarts) {
[08:28:17.104]                           name <- restart$name
[08:28:17.104]                           if (is.null(name)) 
[08:28:17.104]                             next
[08:28:17.104]                           if (!grepl(pattern, name)) 
[08:28:17.104]                             next
[08:28:17.104]                           invokeRestart(restart)
[08:28:17.104]                           muffled <- TRUE
[08:28:17.104]                           break
[08:28:17.104]                         }
[08:28:17.104]                       }
[08:28:17.104]                     }
[08:28:17.104]                     invisible(muffled)
[08:28:17.104]                   }
[08:28:17.104]                   muffleCondition(cond)
[08:28:17.104]                 })
[08:28:17.104]             }))
[08:28:17.104]             future::FutureResult(value = ...future.value$value, 
[08:28:17.104]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.104]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.104]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.104]                     ...future.globalenv.names))
[08:28:17.104]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.104]         }, condition = base::local({
[08:28:17.104]             c <- base::c
[08:28:17.104]             inherits <- base::inherits
[08:28:17.104]             invokeRestart <- base::invokeRestart
[08:28:17.104]             length <- base::length
[08:28:17.104]             list <- base::list
[08:28:17.104]             seq.int <- base::seq.int
[08:28:17.104]             signalCondition <- base::signalCondition
[08:28:17.104]             sys.calls <- base::sys.calls
[08:28:17.104]             `[[` <- base::`[[`
[08:28:17.104]             `+` <- base::`+`
[08:28:17.104]             `<<-` <- base::`<<-`
[08:28:17.104]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.104]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.104]                   3L)]
[08:28:17.104]             }
[08:28:17.104]             function(cond) {
[08:28:17.104]                 is_error <- inherits(cond, "error")
[08:28:17.104]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.104]                   NULL)
[08:28:17.104]                 if (is_error) {
[08:28:17.104]                   sessionInformation <- function() {
[08:28:17.104]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.104]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.104]                       search = base::search(), system = base::Sys.info())
[08:28:17.104]                   }
[08:28:17.104]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.104]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.104]                     cond$call), session = sessionInformation(), 
[08:28:17.104]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.104]                   signalCondition(cond)
[08:28:17.104]                 }
[08:28:17.104]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.104]                 "immediateCondition"))) {
[08:28:17.104]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.104]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.104]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.104]                   if (TRUE && !signal) {
[08:28:17.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.104]                     {
[08:28:17.104]                       inherits <- base::inherits
[08:28:17.104]                       invokeRestart <- base::invokeRestart
[08:28:17.104]                       is.null <- base::is.null
[08:28:17.104]                       muffled <- FALSE
[08:28:17.104]                       if (inherits(cond, "message")) {
[08:28:17.104]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.104]                         if (muffled) 
[08:28:17.104]                           invokeRestart("muffleMessage")
[08:28:17.104]                       }
[08:28:17.104]                       else if (inherits(cond, "warning")) {
[08:28:17.104]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.104]                         if (muffled) 
[08:28:17.104]                           invokeRestart("muffleWarning")
[08:28:17.104]                       }
[08:28:17.104]                       else if (inherits(cond, "condition")) {
[08:28:17.104]                         if (!is.null(pattern)) {
[08:28:17.104]                           computeRestarts <- base::computeRestarts
[08:28:17.104]                           grepl <- base::grepl
[08:28:17.104]                           restarts <- computeRestarts(cond)
[08:28:17.104]                           for (restart in restarts) {
[08:28:17.104]                             name <- restart$name
[08:28:17.104]                             if (is.null(name)) 
[08:28:17.104]                               next
[08:28:17.104]                             if (!grepl(pattern, name)) 
[08:28:17.104]                               next
[08:28:17.104]                             invokeRestart(restart)
[08:28:17.104]                             muffled <- TRUE
[08:28:17.104]                             break
[08:28:17.104]                           }
[08:28:17.104]                         }
[08:28:17.104]                       }
[08:28:17.104]                       invisible(muffled)
[08:28:17.104]                     }
[08:28:17.104]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.104]                   }
[08:28:17.104]                 }
[08:28:17.104]                 else {
[08:28:17.104]                   if (TRUE) {
[08:28:17.104]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.104]                     {
[08:28:17.104]                       inherits <- base::inherits
[08:28:17.104]                       invokeRestart <- base::invokeRestart
[08:28:17.104]                       is.null <- base::is.null
[08:28:17.104]                       muffled <- FALSE
[08:28:17.104]                       if (inherits(cond, "message")) {
[08:28:17.104]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.104]                         if (muffled) 
[08:28:17.104]                           invokeRestart("muffleMessage")
[08:28:17.104]                       }
[08:28:17.104]                       else if (inherits(cond, "warning")) {
[08:28:17.104]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.104]                         if (muffled) 
[08:28:17.104]                           invokeRestart("muffleWarning")
[08:28:17.104]                       }
[08:28:17.104]                       else if (inherits(cond, "condition")) {
[08:28:17.104]                         if (!is.null(pattern)) {
[08:28:17.104]                           computeRestarts <- base::computeRestarts
[08:28:17.104]                           grepl <- base::grepl
[08:28:17.104]                           restarts <- computeRestarts(cond)
[08:28:17.104]                           for (restart in restarts) {
[08:28:17.104]                             name <- restart$name
[08:28:17.104]                             if (is.null(name)) 
[08:28:17.104]                               next
[08:28:17.104]                             if (!grepl(pattern, name)) 
[08:28:17.104]                               next
[08:28:17.104]                             invokeRestart(restart)
[08:28:17.104]                             muffled <- TRUE
[08:28:17.104]                             break
[08:28:17.104]                           }
[08:28:17.104]                         }
[08:28:17.104]                       }
[08:28:17.104]                       invisible(muffled)
[08:28:17.104]                     }
[08:28:17.104]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.104]                   }
[08:28:17.104]                 }
[08:28:17.104]             }
[08:28:17.104]         }))
[08:28:17.104]     }, error = function(ex) {
[08:28:17.104]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.104]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.104]                 ...future.rng), started = ...future.startTime, 
[08:28:17.104]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.104]             version = "1.8"), class = "FutureResult")
[08:28:17.104]     }, finally = {
[08:28:17.104]         if (!identical(...future.workdir, getwd())) 
[08:28:17.104]             setwd(...future.workdir)
[08:28:17.104]         {
[08:28:17.104]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.104]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.104]             }
[08:28:17.104]             base::options(...future.oldOptions)
[08:28:17.104]             if (.Platform$OS.type == "windows") {
[08:28:17.104]                 old_names <- names(...future.oldEnvVars)
[08:28:17.104]                 envs <- base::Sys.getenv()
[08:28:17.104]                 names <- names(envs)
[08:28:17.104]                 common <- intersect(names, old_names)
[08:28:17.104]                 added <- setdiff(names, old_names)
[08:28:17.104]                 removed <- setdiff(old_names, names)
[08:28:17.104]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.104]                   envs[common]]
[08:28:17.104]                 NAMES <- toupper(changed)
[08:28:17.104]                 args <- list()
[08:28:17.104]                 for (kk in seq_along(NAMES)) {
[08:28:17.104]                   name <- changed[[kk]]
[08:28:17.104]                   NAME <- NAMES[[kk]]
[08:28:17.104]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.104]                     next
[08:28:17.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.104]                 }
[08:28:17.104]                 NAMES <- toupper(added)
[08:28:17.104]                 for (kk in seq_along(NAMES)) {
[08:28:17.104]                   name <- added[[kk]]
[08:28:17.104]                   NAME <- NAMES[[kk]]
[08:28:17.104]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.104]                     next
[08:28:17.104]                   args[[name]] <- ""
[08:28:17.104]                 }
[08:28:17.104]                 NAMES <- toupper(removed)
[08:28:17.104]                 for (kk in seq_along(NAMES)) {
[08:28:17.104]                   name <- removed[[kk]]
[08:28:17.104]                   NAME <- NAMES[[kk]]
[08:28:17.104]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.104]                     next
[08:28:17.104]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.104]                 }
[08:28:17.104]                 if (length(args) > 0) 
[08:28:17.104]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.104]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.104]             }
[08:28:17.104]             else {
[08:28:17.104]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.104]             }
[08:28:17.104]             {
[08:28:17.104]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.104]                   0L) {
[08:28:17.104]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.104]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.104]                   base::options(opts)
[08:28:17.104]                 }
[08:28:17.104]                 {
[08:28:17.104]                   {
[08:28:17.104]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.104]                     NULL
[08:28:17.104]                   }
[08:28:17.104]                   options(future.plan = NULL)
[08:28:17.104]                   if (is.na(NA_character_)) 
[08:28:17.104]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.104]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.104]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.104]                     .init = FALSE)
[08:28:17.104]                 }
[08:28:17.104]             }
[08:28:17.104]         }
[08:28:17.104]     })
[08:28:17.104]     if (TRUE) {
[08:28:17.104]         base::sink(type = "output", split = FALSE)
[08:28:17.104]         if (TRUE) {
[08:28:17.104]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.104]         }
[08:28:17.104]         else {
[08:28:17.104]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.104]         }
[08:28:17.104]         base::close(...future.stdout)
[08:28:17.104]         ...future.stdout <- NULL
[08:28:17.104]     }
[08:28:17.104]     ...future.result$conditions <- ...future.conditions
[08:28:17.104]     ...future.result$finished <- base::Sys.time()
[08:28:17.104]     ...future.result
[08:28:17.104] }
[08:28:17.117] Exporting 1 global objects (313.44 KiB) to cluster node #2 ...
[08:28:17.128] Exporting ‘a’ (313.23 KiB) to cluster node #2 ...
[08:28:17.181] Exporting ‘a’ (313.23 KiB) to cluster node #2 ... DONE
[08:28:17.181] Exporting 1 global objects (313.44 KiB) to cluster node #2 ... DONE
[08:28:17.182] MultisessionFuture started
[08:28:17.182] - Launch lazy future ... done
[08:28:17.182] run() for ‘MultisessionFuture’ ... done
[08:28:17.182] result() for ClusterFuture ...
[08:28:17.182] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.182] - Validating connection of MultisessionFuture
[08:28:17.228] - received message: FutureResult
[08:28:17.228] - Received FutureResult
[08:28:17.228] - Erased future from FutureRegistry
[08:28:17.228] result() for ClusterFuture ...
[08:28:17.228] - result already collected: FutureResult
[08:28:17.228] result() for ClusterFuture ... done
[08:28:17.228] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.228] result() for ClusterFuture ... done
[08:28:17.229] result() for ClusterFuture ...
[08:28:17.229] - result already collected: FutureResult
[08:28:17.229] result() for ClusterFuture ... done
value(b) = 2
[08:28:17.229] result() for ClusterFuture ...
[08:28:17.229] - result already collected: FutureResult
[08:28:17.229] result() for ClusterFuture ... done
[08:28:17.229] result() for ClusterFuture ...
[08:28:17.229] - result already collected: FutureResult
[08:28:17.229] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.230] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.230] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.230] 
[08:28:17.230] Searching for globals ... DONE
[08:28:17.231] - globals: [0] <none>
[08:28:17.231] getGlobalsAndPackages() ... DONE
[08:28:17.231] run() for ‘Future’ ...
[08:28:17.231] - state: ‘created’
[08:28:17.231] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.245] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.245] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.246]   - Field: ‘node’
[08:28:17.246]   - Field: ‘label’
[08:28:17.246]   - Field: ‘local’
[08:28:17.246]   - Field: ‘owner’
[08:28:17.246]   - Field: ‘envir’
[08:28:17.246]   - Field: ‘workers’
[08:28:17.246]   - Field: ‘packages’
[08:28:17.246]   - Field: ‘gc’
[08:28:17.246]   - Field: ‘conditions’
[08:28:17.246]   - Field: ‘persistent’
[08:28:17.246]   - Field: ‘expr’
[08:28:17.247]   - Field: ‘uuid’
[08:28:17.247]   - Field: ‘seed’
[08:28:17.247]   - Field: ‘version’
[08:28:17.247]   - Field: ‘result’
[08:28:17.247]   - Field: ‘asynchronous’
[08:28:17.247]   - Field: ‘calls’
[08:28:17.247]   - Field: ‘globals’
[08:28:17.247]   - Field: ‘stdout’
[08:28:17.247]   - Field: ‘earlySignal’
[08:28:17.247]   - Field: ‘lazy’
[08:28:17.247]   - Field: ‘state’
[08:28:17.247] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.248] - Launch lazy future ...
[08:28:17.248] Packages needed by the future expression (n = 0): <none>
[08:28:17.248] Packages needed by future strategies (n = 0): <none>
[08:28:17.248] {
[08:28:17.248]     {
[08:28:17.248]         {
[08:28:17.248]             ...future.startTime <- base::Sys.time()
[08:28:17.248]             {
[08:28:17.248]                 {
[08:28:17.248]                   {
[08:28:17.248]                     {
[08:28:17.248]                       base::local({
[08:28:17.248]                         has_future <- base::requireNamespace("future", 
[08:28:17.248]                           quietly = TRUE)
[08:28:17.248]                         if (has_future) {
[08:28:17.248]                           ns <- base::getNamespace("future")
[08:28:17.248]                           version <- ns[[".package"]][["version"]]
[08:28:17.248]                           if (is.null(version)) 
[08:28:17.248]                             version <- utils::packageVersion("future")
[08:28:17.248]                         }
[08:28:17.248]                         else {
[08:28:17.248]                           version <- NULL
[08:28:17.248]                         }
[08:28:17.248]                         if (!has_future || version < "1.8.0") {
[08:28:17.248]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.248]                             "", base::R.version$version.string), 
[08:28:17.248]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:17.248]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:17.248]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.248]                               "release", "version")], collapse = " "), 
[08:28:17.248]                             hostname = base::Sys.info()[["nodename"]])
[08:28:17.248]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.248]                             info)
[08:28:17.248]                           info <- base::paste(info, collapse = "; ")
[08:28:17.248]                           if (!has_future) {
[08:28:17.248]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.248]                               info)
[08:28:17.248]                           }
[08:28:17.248]                           else {
[08:28:17.248]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.248]                               info, version)
[08:28:17.248]                           }
[08:28:17.248]                           base::stop(msg)
[08:28:17.248]                         }
[08:28:17.248]                       })
[08:28:17.248]                     }
[08:28:17.248]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.248]                     base::options(mc.cores = 1L)
[08:28:17.248]                   }
[08:28:17.248]                   ...future.strategy.old <- future::plan("list")
[08:28:17.248]                   options(future.plan = NULL)
[08:28:17.248]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.248]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.248]                 }
[08:28:17.248]                 ...future.workdir <- getwd()
[08:28:17.248]             }
[08:28:17.248]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.248]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.248]         }
[08:28:17.248]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.248]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.248]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.248]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.248]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.248]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.248]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.248]             base::names(...future.oldOptions))
[08:28:17.248]     }
[08:28:17.248]     if (FALSE) {
[08:28:17.248]     }
[08:28:17.248]     else {
[08:28:17.248]         if (TRUE) {
[08:28:17.248]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.248]                 open = "w")
[08:28:17.248]         }
[08:28:17.248]         else {
[08:28:17.248]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.248]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.248]         }
[08:28:17.248]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.248]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.248]             base::sink(type = "output", split = FALSE)
[08:28:17.248]             base::close(...future.stdout)
[08:28:17.248]         }, add = TRUE)
[08:28:17.248]     }
[08:28:17.248]     ...future.frame <- base::sys.nframe()
[08:28:17.248]     ...future.conditions <- base::list()
[08:28:17.248]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.248]     if (FALSE) {
[08:28:17.248]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.248]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.248]     }
[08:28:17.248]     ...future.result <- base::tryCatch({
[08:28:17.248]         base::withCallingHandlers({
[08:28:17.248]             ...future.value <- base::withVisible(base::local({
[08:28:17.248]                 ...future.makeSendCondition <- base::local({
[08:28:17.248]                   sendCondition <- NULL
[08:28:17.248]                   function(frame = 1L) {
[08:28:17.248]                     if (is.function(sendCondition)) 
[08:28:17.248]                       return(sendCondition)
[08:28:17.248]                     ns <- getNamespace("parallel")
[08:28:17.248]                     if (exists("sendData", mode = "function", 
[08:28:17.248]                       envir = ns)) {
[08:28:17.248]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.248]                         envir = ns)
[08:28:17.248]                       envir <- sys.frame(frame)
[08:28:17.248]                       master <- NULL
[08:28:17.248]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.248]                         !identical(envir, emptyenv())) {
[08:28:17.248]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.248]                           inherits = FALSE)) {
[08:28:17.248]                           master <- get("master", mode = "list", 
[08:28:17.248]                             envir = envir, inherits = FALSE)
[08:28:17.248]                           if (inherits(master, c("SOCKnode", 
[08:28:17.248]                             "SOCK0node"))) {
[08:28:17.248]                             sendCondition <<- function(cond) {
[08:28:17.248]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.248]                                 success = TRUE)
[08:28:17.248]                               parallel_sendData(master, data)
[08:28:17.248]                             }
[08:28:17.248]                             return(sendCondition)
[08:28:17.248]                           }
[08:28:17.248]                         }
[08:28:17.248]                         frame <- frame + 1L
[08:28:17.248]                         envir <- sys.frame(frame)
[08:28:17.248]                       }
[08:28:17.248]                     }
[08:28:17.248]                     sendCondition <<- function(cond) NULL
[08:28:17.248]                   }
[08:28:17.248]                 })
[08:28:17.248]                 withCallingHandlers({
[08:28:17.248]                   1
[08:28:17.248]                 }, immediateCondition = function(cond) {
[08:28:17.248]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.248]                   sendCondition(cond)
[08:28:17.248]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.248]                   {
[08:28:17.248]                     inherits <- base::inherits
[08:28:17.248]                     invokeRestart <- base::invokeRestart
[08:28:17.248]                     is.null <- base::is.null
[08:28:17.248]                     muffled <- FALSE
[08:28:17.248]                     if (inherits(cond, "message")) {
[08:28:17.248]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.248]                       if (muffled) 
[08:28:17.248]                         invokeRestart("muffleMessage")
[08:28:17.248]                     }
[08:28:17.248]                     else if (inherits(cond, "warning")) {
[08:28:17.248]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.248]                       if (muffled) 
[08:28:17.248]                         invokeRestart("muffleWarning")
[08:28:17.248]                     }
[08:28:17.248]                     else if (inherits(cond, "condition")) {
[08:28:17.248]                       if (!is.null(pattern)) {
[08:28:17.248]                         computeRestarts <- base::computeRestarts
[08:28:17.248]                         grepl <- base::grepl
[08:28:17.248]                         restarts <- computeRestarts(cond)
[08:28:17.248]                         for (restart in restarts) {
[08:28:17.248]                           name <- restart$name
[08:28:17.248]                           if (is.null(name)) 
[08:28:17.248]                             next
[08:28:17.248]                           if (!grepl(pattern, name)) 
[08:28:17.248]                             next
[08:28:17.248]                           invokeRestart(restart)
[08:28:17.248]                           muffled <- TRUE
[08:28:17.248]                           break
[08:28:17.248]                         }
[08:28:17.248]                       }
[08:28:17.248]                     }
[08:28:17.248]                     invisible(muffled)
[08:28:17.248]                   }
[08:28:17.248]                   muffleCondition(cond)
[08:28:17.248]                 })
[08:28:17.248]             }))
[08:28:17.248]             future::FutureResult(value = ...future.value$value, 
[08:28:17.248]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.248]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.248]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.248]                     ...future.globalenv.names))
[08:28:17.248]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.248]         }, condition = base::local({
[08:28:17.248]             c <- base::c
[08:28:17.248]             inherits <- base::inherits
[08:28:17.248]             invokeRestart <- base::invokeRestart
[08:28:17.248]             length <- base::length
[08:28:17.248]             list <- base::list
[08:28:17.248]             seq.int <- base::seq.int
[08:28:17.248]             signalCondition <- base::signalCondition
[08:28:17.248]             sys.calls <- base::sys.calls
[08:28:17.248]             `[[` <- base::`[[`
[08:28:17.248]             `+` <- base::`+`
[08:28:17.248]             `<<-` <- base::`<<-`
[08:28:17.248]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.248]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.248]                   3L)]
[08:28:17.248]             }
[08:28:17.248]             function(cond) {
[08:28:17.248]                 is_error <- inherits(cond, "error")
[08:28:17.248]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.248]                   NULL)
[08:28:17.248]                 if (is_error) {
[08:28:17.248]                   sessionInformation <- function() {
[08:28:17.248]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.248]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.248]                       search = base::search(), system = base::Sys.info())
[08:28:17.248]                   }
[08:28:17.248]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.248]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.248]                     cond$call), session = sessionInformation(), 
[08:28:17.248]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.248]                   signalCondition(cond)
[08:28:17.248]                 }
[08:28:17.248]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.248]                 "immediateCondition"))) {
[08:28:17.248]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.248]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.248]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.248]                   if (TRUE && !signal) {
[08:28:17.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.248]                     {
[08:28:17.248]                       inherits <- base::inherits
[08:28:17.248]                       invokeRestart <- base::invokeRestart
[08:28:17.248]                       is.null <- base::is.null
[08:28:17.248]                       muffled <- FALSE
[08:28:17.248]                       if (inherits(cond, "message")) {
[08:28:17.248]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.248]                         if (muffled) 
[08:28:17.248]                           invokeRestart("muffleMessage")
[08:28:17.248]                       }
[08:28:17.248]                       else if (inherits(cond, "warning")) {
[08:28:17.248]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.248]                         if (muffled) 
[08:28:17.248]                           invokeRestart("muffleWarning")
[08:28:17.248]                       }
[08:28:17.248]                       else if (inherits(cond, "condition")) {
[08:28:17.248]                         if (!is.null(pattern)) {
[08:28:17.248]                           computeRestarts <- base::computeRestarts
[08:28:17.248]                           grepl <- base::grepl
[08:28:17.248]                           restarts <- computeRestarts(cond)
[08:28:17.248]                           for (restart in restarts) {
[08:28:17.248]                             name <- restart$name
[08:28:17.248]                             if (is.null(name)) 
[08:28:17.248]                               next
[08:28:17.248]                             if (!grepl(pattern, name)) 
[08:28:17.248]                               next
[08:28:17.248]                             invokeRestart(restart)
[08:28:17.248]                             muffled <- TRUE
[08:28:17.248]                             break
[08:28:17.248]                           }
[08:28:17.248]                         }
[08:28:17.248]                       }
[08:28:17.248]                       invisible(muffled)
[08:28:17.248]                     }
[08:28:17.248]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.248]                   }
[08:28:17.248]                 }
[08:28:17.248]                 else {
[08:28:17.248]                   if (TRUE) {
[08:28:17.248]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.248]                     {
[08:28:17.248]                       inherits <- base::inherits
[08:28:17.248]                       invokeRestart <- base::invokeRestart
[08:28:17.248]                       is.null <- base::is.null
[08:28:17.248]                       muffled <- FALSE
[08:28:17.248]                       if (inherits(cond, "message")) {
[08:28:17.248]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.248]                         if (muffled) 
[08:28:17.248]                           invokeRestart("muffleMessage")
[08:28:17.248]                       }
[08:28:17.248]                       else if (inherits(cond, "warning")) {
[08:28:17.248]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.248]                         if (muffled) 
[08:28:17.248]                           invokeRestart("muffleWarning")
[08:28:17.248]                       }
[08:28:17.248]                       else if (inherits(cond, "condition")) {
[08:28:17.248]                         if (!is.null(pattern)) {
[08:28:17.248]                           computeRestarts <- base::computeRestarts
[08:28:17.248]                           grepl <- base::grepl
[08:28:17.248]                           restarts <- computeRestarts(cond)
[08:28:17.248]                           for (restart in restarts) {
[08:28:17.248]                             name <- restart$name
[08:28:17.248]                             if (is.null(name)) 
[08:28:17.248]                               next
[08:28:17.248]                             if (!grepl(pattern, name)) 
[08:28:17.248]                               next
[08:28:17.248]                             invokeRestart(restart)
[08:28:17.248]                             muffled <- TRUE
[08:28:17.248]                             break
[08:28:17.248]                           }
[08:28:17.248]                         }
[08:28:17.248]                       }
[08:28:17.248]                       invisible(muffled)
[08:28:17.248]                     }
[08:28:17.248]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.248]                   }
[08:28:17.248]                 }
[08:28:17.248]             }
[08:28:17.248]         }))
[08:28:17.248]     }, error = function(ex) {
[08:28:17.248]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.248]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.248]                 ...future.rng), started = ...future.startTime, 
[08:28:17.248]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.248]             version = "1.8"), class = "FutureResult")
[08:28:17.248]     }, finally = {
[08:28:17.248]         if (!identical(...future.workdir, getwd())) 
[08:28:17.248]             setwd(...future.workdir)
[08:28:17.248]         {
[08:28:17.248]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.248]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.248]             }
[08:28:17.248]             base::options(...future.oldOptions)
[08:28:17.248]             if (.Platform$OS.type == "windows") {
[08:28:17.248]                 old_names <- names(...future.oldEnvVars)
[08:28:17.248]                 envs <- base::Sys.getenv()
[08:28:17.248]                 names <- names(envs)
[08:28:17.248]                 common <- intersect(names, old_names)
[08:28:17.248]                 added <- setdiff(names, old_names)
[08:28:17.248]                 removed <- setdiff(old_names, names)
[08:28:17.248]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.248]                   envs[common]]
[08:28:17.248]                 NAMES <- toupper(changed)
[08:28:17.248]                 args <- list()
[08:28:17.248]                 for (kk in seq_along(NAMES)) {
[08:28:17.248]                   name <- changed[[kk]]
[08:28:17.248]                   NAME <- NAMES[[kk]]
[08:28:17.248]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.248]                     next
[08:28:17.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.248]                 }
[08:28:17.248]                 NAMES <- toupper(added)
[08:28:17.248]                 for (kk in seq_along(NAMES)) {
[08:28:17.248]                   name <- added[[kk]]
[08:28:17.248]                   NAME <- NAMES[[kk]]
[08:28:17.248]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.248]                     next
[08:28:17.248]                   args[[name]] <- ""
[08:28:17.248]                 }
[08:28:17.248]                 NAMES <- toupper(removed)
[08:28:17.248]                 for (kk in seq_along(NAMES)) {
[08:28:17.248]                   name <- removed[[kk]]
[08:28:17.248]                   NAME <- NAMES[[kk]]
[08:28:17.248]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.248]                     next
[08:28:17.248]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.248]                 }
[08:28:17.248]                 if (length(args) > 0) 
[08:28:17.248]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.248]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.248]             }
[08:28:17.248]             else {
[08:28:17.248]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.248]             }
[08:28:17.248]             {
[08:28:17.248]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.248]                   0L) {
[08:28:17.248]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.248]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.248]                   base::options(opts)
[08:28:17.248]                 }
[08:28:17.248]                 {
[08:28:17.248]                   {
[08:28:17.248]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.248]                     NULL
[08:28:17.248]                   }
[08:28:17.248]                   options(future.plan = NULL)
[08:28:17.248]                   if (is.na(NA_character_)) 
[08:28:17.248]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.248]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.248]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.248]                     .init = FALSE)
[08:28:17.248]                 }
[08:28:17.248]             }
[08:28:17.248]         }
[08:28:17.248]     })
[08:28:17.248]     if (TRUE) {
[08:28:17.248]         base::sink(type = "output", split = FALSE)
[08:28:17.248]         if (TRUE) {
[08:28:17.248]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.248]         }
[08:28:17.248]         else {
[08:28:17.248]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.248]         }
[08:28:17.248]         base::close(...future.stdout)
[08:28:17.248]         ...future.stdout <- NULL
[08:28:17.248]     }
[08:28:17.248]     ...future.result$conditions <- ...future.conditions
[08:28:17.248]     ...future.result$finished <- base::Sys.time()
[08:28:17.248]     ...future.result
[08:28:17.248] }
[08:28:17.251] MultisessionFuture started
[08:28:17.252] - Launch lazy future ... done
[08:28:17.252] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.252] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.252] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.253] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:17.253] Searching for globals ... DONE
[08:28:17.253] Resolving globals: TRUE
[08:28:17.253] Resolving any globals that are futures ...
[08:28:17.253] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:17.254] Resolving any globals that are futures ... DONE
[08:28:17.254] Resolving futures part of globals (recursively) ...
[08:28:17.254] resolve() on list ...
[08:28:17.254]  recursive: 99
[08:28:17.254]  length: 1
[08:28:17.254]  elements: ‘a’
[08:28:17.296] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.296] - Validating connection of MultisessionFuture
[08:28:17.297] - received message: FutureResult
[08:28:17.297] - Received FutureResult
[08:28:17.297] - Erased future from FutureRegistry
[08:28:17.297] result() for ClusterFuture ...
[08:28:17.297] - result already collected: FutureResult
[08:28:17.297] result() for ClusterFuture ... done
[08:28:17.297] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.297] Future #1
[08:28:17.297] result() for ClusterFuture ...
[08:28:17.297] - result already collected: FutureResult
[08:28:17.297] result() for ClusterFuture ... done
[08:28:17.298] result() for ClusterFuture ...
[08:28:17.298] - result already collected: FutureResult
[08:28:17.298] result() for ClusterFuture ... done
[08:28:17.298] A MultisessionFuture was resolved
[08:28:17.298]  length: 0 (resolved future 1)
[08:28:17.298] resolve() on list ... DONE
[08:28:17.298] - globals: [1] ‘a’
[08:28:17.298] Resolving futures part of globals (recursively) ... DONE
[08:28:17.309] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[08:28:17.310] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[08:28:17.310] - globals: [1] ‘a’
[08:28:17.310] - packages: [1] ‘future’
[08:28:17.310] getGlobalsAndPackages() ... DONE
[08:28:17.310] run() for ‘Future’ ...
[08:28:17.310] - state: ‘created’
[08:28:17.311] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.325] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.325] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.325]   - Field: ‘node’
[08:28:17.325]   - Field: ‘label’
[08:28:17.325]   - Field: ‘local’
[08:28:17.325]   - Field: ‘owner’
[08:28:17.325]   - Field: ‘envir’
[08:28:17.325]   - Field: ‘workers’
[08:28:17.326]   - Field: ‘packages’
[08:28:17.326]   - Field: ‘gc’
[08:28:17.326]   - Field: ‘conditions’
[08:28:17.326]   - Field: ‘persistent’
[08:28:17.326]   - Field: ‘expr’
[08:28:17.326]   - Field: ‘uuid’
[08:28:17.326]   - Field: ‘seed’
[08:28:17.326]   - Field: ‘version’
[08:28:17.326]   - Field: ‘result’
[08:28:17.326]   - Field: ‘asynchronous’
[08:28:17.326]   - Field: ‘calls’
[08:28:17.326]   - Field: ‘globals’
[08:28:17.327]   - Field: ‘stdout’
[08:28:17.329]   - Field: ‘earlySignal’
[08:28:17.329]   - Field: ‘lazy’
[08:28:17.329]   - Field: ‘state’
[08:28:17.329] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.329] - Launch lazy future ...
[08:28:17.329] Packages needed by the future expression (n = 1): ‘future’
[08:28:17.330] Packages needed by future strategies (n = 0): <none>
[08:28:17.330] {
[08:28:17.330]     {
[08:28:17.330]         {
[08:28:17.330]             ...future.startTime <- base::Sys.time()
[08:28:17.330]             {
[08:28:17.330]                 {
[08:28:17.330]                   {
[08:28:17.330]                     {
[08:28:17.330]                       {
[08:28:17.330]                         base::local({
[08:28:17.330]                           has_future <- base::requireNamespace("future", 
[08:28:17.330]                             quietly = TRUE)
[08:28:17.330]                           if (has_future) {
[08:28:17.330]                             ns <- base::getNamespace("future")
[08:28:17.330]                             version <- ns[[".package"]][["version"]]
[08:28:17.330]                             if (is.null(version)) 
[08:28:17.330]                               version <- utils::packageVersion("future")
[08:28:17.330]                           }
[08:28:17.330]                           else {
[08:28:17.330]                             version <- NULL
[08:28:17.330]                           }
[08:28:17.330]                           if (!has_future || version < "1.8.0") {
[08:28:17.330]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.330]                               "", base::R.version$version.string), 
[08:28:17.330]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:17.330]                                 base::R.version$platform, 8 * 
[08:28:17.330]                                   base::.Machine$sizeof.pointer), 
[08:28:17.330]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.330]                                 "release", "version")], collapse = " "), 
[08:28:17.330]                               hostname = base::Sys.info()[["nodename"]])
[08:28:17.330]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.330]                               info)
[08:28:17.330]                             info <- base::paste(info, collapse = "; ")
[08:28:17.330]                             if (!has_future) {
[08:28:17.330]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.330]                                 info)
[08:28:17.330]                             }
[08:28:17.330]                             else {
[08:28:17.330]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.330]                                 info, version)
[08:28:17.330]                             }
[08:28:17.330]                             base::stop(msg)
[08:28:17.330]                           }
[08:28:17.330]                         })
[08:28:17.330]                       }
[08:28:17.330]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.330]                       base::options(mc.cores = 1L)
[08:28:17.330]                     }
[08:28:17.330]                     base::local({
[08:28:17.330]                       for (pkg in "future") {
[08:28:17.330]                         base::loadNamespace(pkg)
[08:28:17.330]                         base::library(pkg, character.only = TRUE)
[08:28:17.330]                       }
[08:28:17.330]                     })
[08:28:17.330]                   }
[08:28:17.330]                   ...future.strategy.old <- future::plan("list")
[08:28:17.330]                   options(future.plan = NULL)
[08:28:17.330]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.330]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.330]                 }
[08:28:17.330]                 ...future.workdir <- getwd()
[08:28:17.330]             }
[08:28:17.330]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.330]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.330]         }
[08:28:17.330]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.330]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.330]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.330]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.330]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.330]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.330]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.330]             base::names(...future.oldOptions))
[08:28:17.330]     }
[08:28:17.330]     if (FALSE) {
[08:28:17.330]     }
[08:28:17.330]     else {
[08:28:17.330]         if (TRUE) {
[08:28:17.330]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.330]                 open = "w")
[08:28:17.330]         }
[08:28:17.330]         else {
[08:28:17.330]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.330]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.330]         }
[08:28:17.330]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.330]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.330]             base::sink(type = "output", split = FALSE)
[08:28:17.330]             base::close(...future.stdout)
[08:28:17.330]         }, add = TRUE)
[08:28:17.330]     }
[08:28:17.330]     ...future.frame <- base::sys.nframe()
[08:28:17.330]     ...future.conditions <- base::list()
[08:28:17.330]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.330]     if (FALSE) {
[08:28:17.330]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.330]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.330]     }
[08:28:17.330]     ...future.result <- base::tryCatch({
[08:28:17.330]         base::withCallingHandlers({
[08:28:17.330]             ...future.value <- base::withVisible(base::local({
[08:28:17.330]                 ...future.makeSendCondition <- base::local({
[08:28:17.330]                   sendCondition <- NULL
[08:28:17.330]                   function(frame = 1L) {
[08:28:17.330]                     if (is.function(sendCondition)) 
[08:28:17.330]                       return(sendCondition)
[08:28:17.330]                     ns <- getNamespace("parallel")
[08:28:17.330]                     if (exists("sendData", mode = "function", 
[08:28:17.330]                       envir = ns)) {
[08:28:17.330]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.330]                         envir = ns)
[08:28:17.330]                       envir <- sys.frame(frame)
[08:28:17.330]                       master <- NULL
[08:28:17.330]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.330]                         !identical(envir, emptyenv())) {
[08:28:17.330]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.330]                           inherits = FALSE)) {
[08:28:17.330]                           master <- get("master", mode = "list", 
[08:28:17.330]                             envir = envir, inherits = FALSE)
[08:28:17.330]                           if (inherits(master, c("SOCKnode", 
[08:28:17.330]                             "SOCK0node"))) {
[08:28:17.330]                             sendCondition <<- function(cond) {
[08:28:17.330]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.330]                                 success = TRUE)
[08:28:17.330]                               parallel_sendData(master, data)
[08:28:17.330]                             }
[08:28:17.330]                             return(sendCondition)
[08:28:17.330]                           }
[08:28:17.330]                         }
[08:28:17.330]                         frame <- frame + 1L
[08:28:17.330]                         envir <- sys.frame(frame)
[08:28:17.330]                       }
[08:28:17.330]                     }
[08:28:17.330]                     sendCondition <<- function(cond) NULL
[08:28:17.330]                   }
[08:28:17.330]                 })
[08:28:17.330]                 withCallingHandlers({
[08:28:17.330]                   value(a) + 1
[08:28:17.330]                 }, immediateCondition = function(cond) {
[08:28:17.330]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.330]                   sendCondition(cond)
[08:28:17.330]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.330]                   {
[08:28:17.330]                     inherits <- base::inherits
[08:28:17.330]                     invokeRestart <- base::invokeRestart
[08:28:17.330]                     is.null <- base::is.null
[08:28:17.330]                     muffled <- FALSE
[08:28:17.330]                     if (inherits(cond, "message")) {
[08:28:17.330]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.330]                       if (muffled) 
[08:28:17.330]                         invokeRestart("muffleMessage")
[08:28:17.330]                     }
[08:28:17.330]                     else if (inherits(cond, "warning")) {
[08:28:17.330]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.330]                       if (muffled) 
[08:28:17.330]                         invokeRestart("muffleWarning")
[08:28:17.330]                     }
[08:28:17.330]                     else if (inherits(cond, "condition")) {
[08:28:17.330]                       if (!is.null(pattern)) {
[08:28:17.330]                         computeRestarts <- base::computeRestarts
[08:28:17.330]                         grepl <- base::grepl
[08:28:17.330]                         restarts <- computeRestarts(cond)
[08:28:17.330]                         for (restart in restarts) {
[08:28:17.330]                           name <- restart$name
[08:28:17.330]                           if (is.null(name)) 
[08:28:17.330]                             next
[08:28:17.330]                           if (!grepl(pattern, name)) 
[08:28:17.330]                             next
[08:28:17.330]                           invokeRestart(restart)
[08:28:17.330]                           muffled <- TRUE
[08:28:17.330]                           break
[08:28:17.330]                         }
[08:28:17.330]                       }
[08:28:17.330]                     }
[08:28:17.330]                     invisible(muffled)
[08:28:17.330]                   }
[08:28:17.330]                   muffleCondition(cond)
[08:28:17.330]                 })
[08:28:17.330]             }))
[08:28:17.330]             future::FutureResult(value = ...future.value$value, 
[08:28:17.330]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.330]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.330]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.330]                     ...future.globalenv.names))
[08:28:17.330]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.330]         }, condition = base::local({
[08:28:17.330]             c <- base::c
[08:28:17.330]             inherits <- base::inherits
[08:28:17.330]             invokeRestart <- base::invokeRestart
[08:28:17.330]             length <- base::length
[08:28:17.330]             list <- base::list
[08:28:17.330]             seq.int <- base::seq.int
[08:28:17.330]             signalCondition <- base::signalCondition
[08:28:17.330]             sys.calls <- base::sys.calls
[08:28:17.330]             `[[` <- base::`[[`
[08:28:17.330]             `+` <- base::`+`
[08:28:17.330]             `<<-` <- base::`<<-`
[08:28:17.330]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.330]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.330]                   3L)]
[08:28:17.330]             }
[08:28:17.330]             function(cond) {
[08:28:17.330]                 is_error <- inherits(cond, "error")
[08:28:17.330]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.330]                   NULL)
[08:28:17.330]                 if (is_error) {
[08:28:17.330]                   sessionInformation <- function() {
[08:28:17.330]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.330]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.330]                       search = base::search(), system = base::Sys.info())
[08:28:17.330]                   }
[08:28:17.330]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.330]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.330]                     cond$call), session = sessionInformation(), 
[08:28:17.330]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.330]                   signalCondition(cond)
[08:28:17.330]                 }
[08:28:17.330]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.330]                 "immediateCondition"))) {
[08:28:17.330]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.330]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.330]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.330]                   if (TRUE && !signal) {
[08:28:17.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.330]                     {
[08:28:17.330]                       inherits <- base::inherits
[08:28:17.330]                       invokeRestart <- base::invokeRestart
[08:28:17.330]                       is.null <- base::is.null
[08:28:17.330]                       muffled <- FALSE
[08:28:17.330]                       if (inherits(cond, "message")) {
[08:28:17.330]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.330]                         if (muffled) 
[08:28:17.330]                           invokeRestart("muffleMessage")
[08:28:17.330]                       }
[08:28:17.330]                       else if (inherits(cond, "warning")) {
[08:28:17.330]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.330]                         if (muffled) 
[08:28:17.330]                           invokeRestart("muffleWarning")
[08:28:17.330]                       }
[08:28:17.330]                       else if (inherits(cond, "condition")) {
[08:28:17.330]                         if (!is.null(pattern)) {
[08:28:17.330]                           computeRestarts <- base::computeRestarts
[08:28:17.330]                           grepl <- base::grepl
[08:28:17.330]                           restarts <- computeRestarts(cond)
[08:28:17.330]                           for (restart in restarts) {
[08:28:17.330]                             name <- restart$name
[08:28:17.330]                             if (is.null(name)) 
[08:28:17.330]                               next
[08:28:17.330]                             if (!grepl(pattern, name)) 
[08:28:17.330]                               next
[08:28:17.330]                             invokeRestart(restart)
[08:28:17.330]                             muffled <- TRUE
[08:28:17.330]                             break
[08:28:17.330]                           }
[08:28:17.330]                         }
[08:28:17.330]                       }
[08:28:17.330]                       invisible(muffled)
[08:28:17.330]                     }
[08:28:17.330]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.330]                   }
[08:28:17.330]                 }
[08:28:17.330]                 else {
[08:28:17.330]                   if (TRUE) {
[08:28:17.330]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.330]                     {
[08:28:17.330]                       inherits <- base::inherits
[08:28:17.330]                       invokeRestart <- base::invokeRestart
[08:28:17.330]                       is.null <- base::is.null
[08:28:17.330]                       muffled <- FALSE
[08:28:17.330]                       if (inherits(cond, "message")) {
[08:28:17.330]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.330]                         if (muffled) 
[08:28:17.330]                           invokeRestart("muffleMessage")
[08:28:17.330]                       }
[08:28:17.330]                       else if (inherits(cond, "warning")) {
[08:28:17.330]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.330]                         if (muffled) 
[08:28:17.330]                           invokeRestart("muffleWarning")
[08:28:17.330]                       }
[08:28:17.330]                       else if (inherits(cond, "condition")) {
[08:28:17.330]                         if (!is.null(pattern)) {
[08:28:17.330]                           computeRestarts <- base::computeRestarts
[08:28:17.330]                           grepl <- base::grepl
[08:28:17.330]                           restarts <- computeRestarts(cond)
[08:28:17.330]                           for (restart in restarts) {
[08:28:17.330]                             name <- restart$name
[08:28:17.330]                             if (is.null(name)) 
[08:28:17.330]                               next
[08:28:17.330]                             if (!grepl(pattern, name)) 
[08:28:17.330]                               next
[08:28:17.330]                             invokeRestart(restart)
[08:28:17.330]                             muffled <- TRUE
[08:28:17.330]                             break
[08:28:17.330]                           }
[08:28:17.330]                         }
[08:28:17.330]                       }
[08:28:17.330]                       invisible(muffled)
[08:28:17.330]                     }
[08:28:17.330]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.330]                   }
[08:28:17.330]                 }
[08:28:17.330]             }
[08:28:17.330]         }))
[08:28:17.330]     }, error = function(ex) {
[08:28:17.330]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.330]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.330]                 ...future.rng), started = ...future.startTime, 
[08:28:17.330]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.330]             version = "1.8"), class = "FutureResult")
[08:28:17.330]     }, finally = {
[08:28:17.330]         if (!identical(...future.workdir, getwd())) 
[08:28:17.330]             setwd(...future.workdir)
[08:28:17.330]         {
[08:28:17.330]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.330]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.330]             }
[08:28:17.330]             base::options(...future.oldOptions)
[08:28:17.330]             if (.Platform$OS.type == "windows") {
[08:28:17.330]                 old_names <- names(...future.oldEnvVars)
[08:28:17.330]                 envs <- base::Sys.getenv()
[08:28:17.330]                 names <- names(envs)
[08:28:17.330]                 common <- intersect(names, old_names)
[08:28:17.330]                 added <- setdiff(names, old_names)
[08:28:17.330]                 removed <- setdiff(old_names, names)
[08:28:17.330]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.330]                   envs[common]]
[08:28:17.330]                 NAMES <- toupper(changed)
[08:28:17.330]                 args <- list()
[08:28:17.330]                 for (kk in seq_along(NAMES)) {
[08:28:17.330]                   name <- changed[[kk]]
[08:28:17.330]                   NAME <- NAMES[[kk]]
[08:28:17.330]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.330]                     next
[08:28:17.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.330]                 }
[08:28:17.330]                 NAMES <- toupper(added)
[08:28:17.330]                 for (kk in seq_along(NAMES)) {
[08:28:17.330]                   name <- added[[kk]]
[08:28:17.330]                   NAME <- NAMES[[kk]]
[08:28:17.330]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.330]                     next
[08:28:17.330]                   args[[name]] <- ""
[08:28:17.330]                 }
[08:28:17.330]                 NAMES <- toupper(removed)
[08:28:17.330]                 for (kk in seq_along(NAMES)) {
[08:28:17.330]                   name <- removed[[kk]]
[08:28:17.330]                   NAME <- NAMES[[kk]]
[08:28:17.330]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.330]                     next
[08:28:17.330]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.330]                 }
[08:28:17.330]                 if (length(args) > 0) 
[08:28:17.330]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.330]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.330]             }
[08:28:17.330]             else {
[08:28:17.330]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.330]             }
[08:28:17.330]             {
[08:28:17.330]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.330]                   0L) {
[08:28:17.330]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.330]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.330]                   base::options(opts)
[08:28:17.330]                 }
[08:28:17.330]                 {
[08:28:17.330]                   {
[08:28:17.330]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.330]                     NULL
[08:28:17.330]                   }
[08:28:17.330]                   options(future.plan = NULL)
[08:28:17.330]                   if (is.na(NA_character_)) 
[08:28:17.330]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.330]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.330]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.330]                     .init = FALSE)
[08:28:17.330]                 }
[08:28:17.330]             }
[08:28:17.330]         }
[08:28:17.330]     })
[08:28:17.330]     if (TRUE) {
[08:28:17.330]         base::sink(type = "output", split = FALSE)
[08:28:17.330]         if (TRUE) {
[08:28:17.330]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.330]         }
[08:28:17.330]         else {
[08:28:17.330]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.330]         }
[08:28:17.330]         base::close(...future.stdout)
[08:28:17.330]         ...future.stdout <- NULL
[08:28:17.330]     }
[08:28:17.330]     ...future.result$conditions <- ...future.conditions
[08:28:17.330]     ...future.result$finished <- base::Sys.time()
[08:28:17.330]     ...future.result
[08:28:17.330] }
[08:28:17.343] Exporting 1 global objects (313.44 KiB) to cluster node #2 ...
[08:28:17.354] Exporting ‘a’ (313.23 KiB) to cluster node #2 ...
[08:28:17.407] Exporting ‘a’ (313.23 KiB) to cluster node #2 ... DONE
[08:28:17.407] Exporting 1 global objects (313.44 KiB) to cluster node #2 ... DONE
[08:28:17.407] MultisessionFuture started
[08:28:17.408] - Launch lazy future ... done
[08:28:17.408] run() for ‘MultisessionFuture’ ... done
[08:28:17.408] result() for ClusterFuture ...
[08:28:17.408] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.408] - Validating connection of MultisessionFuture
[08:28:17.450] - received message: FutureResult
[08:28:17.451] - Received FutureResult
[08:28:17.451] - Erased future from FutureRegistry
[08:28:17.451] result() for ClusterFuture ...
[08:28:17.451] - result already collected: FutureResult
[08:28:17.451] result() for ClusterFuture ... done
[08:28:17.451] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.451] result() for ClusterFuture ... done
[08:28:17.451] result() for ClusterFuture ...
[08:28:17.451] - result already collected: FutureResult
[08:28:17.451] result() for ClusterFuture ... done
value(b) = 2
[08:28:17.452] result() for ClusterFuture ...
[08:28:17.452] - result already collected: FutureResult
[08:28:17.452] result() for ClusterFuture ... done
[08:28:17.452] result() for ClusterFuture ...
[08:28:17.452] - result already collected: FutureResult
[08:28:17.452] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.452] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.452] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.453] 
[08:28:17.453] Searching for globals ... DONE
[08:28:17.453] - globals: [0] <none>
[08:28:17.453] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.454] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.454] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.455] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:17.455] Searching for globals ... DONE
[08:28:17.455] Resolving globals: TRUE
[08:28:17.455] Resolving any globals that are futures ...
[08:28:17.455] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:17.455] Resolving any globals that are futures ... DONE
[08:28:17.455] Resolving futures part of globals (recursively) ...
[08:28:17.456] resolve() on list ...
[08:28:17.456]  recursive: 99
[08:28:17.456]  length: 1
[08:28:17.456]  elements: ‘a’
[08:28:17.456] run() for ‘Future’ ...
[08:28:17.456] - state: ‘created’
[08:28:17.456] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.470] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.470] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.470]   - Field: ‘node’
[08:28:17.471]   - Field: ‘label’
[08:28:17.471]   - Field: ‘local’
[08:28:17.471]   - Field: ‘owner’
[08:28:17.471]   - Field: ‘envir’
[08:28:17.471]   - Field: ‘workers’
[08:28:17.471]   - Field: ‘packages’
[08:28:17.471]   - Field: ‘gc’
[08:28:17.471]   - Field: ‘conditions’
[08:28:17.471]   - Field: ‘persistent’
[08:28:17.471]   - Field: ‘expr’
[08:28:17.471]   - Field: ‘uuid’
[08:28:17.471]   - Field: ‘seed’
[08:28:17.472]   - Field: ‘version’
[08:28:17.472]   - Field: ‘result’
[08:28:17.472]   - Field: ‘asynchronous’
[08:28:17.472]   - Field: ‘calls’
[08:28:17.472]   - Field: ‘globals’
[08:28:17.472]   - Field: ‘stdout’
[08:28:17.472]   - Field: ‘earlySignal’
[08:28:17.472]   - Field: ‘lazy’
[08:28:17.472]   - Field: ‘state’
[08:28:17.472] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.472] - Launch lazy future ...
[08:28:17.473] Packages needed by the future expression (n = 0): <none>
[08:28:17.473] Packages needed by future strategies (n = 0): <none>
[08:28:17.473] {
[08:28:17.473]     {
[08:28:17.473]         {
[08:28:17.473]             ...future.startTime <- base::Sys.time()
[08:28:17.473]             {
[08:28:17.473]                 {
[08:28:17.473]                   {
[08:28:17.473]                     {
[08:28:17.473]                       base::local({
[08:28:17.473]                         has_future <- base::requireNamespace("future", 
[08:28:17.473]                           quietly = TRUE)
[08:28:17.473]                         if (has_future) {
[08:28:17.473]                           ns <- base::getNamespace("future")
[08:28:17.473]                           version <- ns[[".package"]][["version"]]
[08:28:17.473]                           if (is.null(version)) 
[08:28:17.473]                             version <- utils::packageVersion("future")
[08:28:17.473]                         }
[08:28:17.473]                         else {
[08:28:17.473]                           version <- NULL
[08:28:17.473]                         }
[08:28:17.473]                         if (!has_future || version < "1.8.0") {
[08:28:17.473]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.473]                             "", base::R.version$version.string), 
[08:28:17.473]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:17.473]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:17.473]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.473]                               "release", "version")], collapse = " "), 
[08:28:17.473]                             hostname = base::Sys.info()[["nodename"]])
[08:28:17.473]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.473]                             info)
[08:28:17.473]                           info <- base::paste(info, collapse = "; ")
[08:28:17.473]                           if (!has_future) {
[08:28:17.473]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.473]                               info)
[08:28:17.473]                           }
[08:28:17.473]                           else {
[08:28:17.473]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.473]                               info, version)
[08:28:17.473]                           }
[08:28:17.473]                           base::stop(msg)
[08:28:17.473]                         }
[08:28:17.473]                       })
[08:28:17.473]                     }
[08:28:17.473]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.473]                     base::options(mc.cores = 1L)
[08:28:17.473]                   }
[08:28:17.473]                   ...future.strategy.old <- future::plan("list")
[08:28:17.473]                   options(future.plan = NULL)
[08:28:17.473]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.473]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.473]                 }
[08:28:17.473]                 ...future.workdir <- getwd()
[08:28:17.473]             }
[08:28:17.473]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.473]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.473]         }
[08:28:17.473]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.473]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.473]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.473]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.473]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.473]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.473]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.473]             base::names(...future.oldOptions))
[08:28:17.473]     }
[08:28:17.473]     if (FALSE) {
[08:28:17.473]     }
[08:28:17.473]     else {
[08:28:17.473]         if (TRUE) {
[08:28:17.473]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.473]                 open = "w")
[08:28:17.473]         }
[08:28:17.473]         else {
[08:28:17.473]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.473]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.473]         }
[08:28:17.473]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.473]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.473]             base::sink(type = "output", split = FALSE)
[08:28:17.473]             base::close(...future.stdout)
[08:28:17.473]         }, add = TRUE)
[08:28:17.473]     }
[08:28:17.473]     ...future.frame <- base::sys.nframe()
[08:28:17.473]     ...future.conditions <- base::list()
[08:28:17.473]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.473]     if (FALSE) {
[08:28:17.473]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.473]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.473]     }
[08:28:17.473]     ...future.result <- base::tryCatch({
[08:28:17.473]         base::withCallingHandlers({
[08:28:17.473]             ...future.value <- base::withVisible(base::local({
[08:28:17.473]                 ...future.makeSendCondition <- base::local({
[08:28:17.473]                   sendCondition <- NULL
[08:28:17.473]                   function(frame = 1L) {
[08:28:17.473]                     if (is.function(sendCondition)) 
[08:28:17.473]                       return(sendCondition)
[08:28:17.473]                     ns <- getNamespace("parallel")
[08:28:17.473]                     if (exists("sendData", mode = "function", 
[08:28:17.473]                       envir = ns)) {
[08:28:17.473]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.473]                         envir = ns)
[08:28:17.473]                       envir <- sys.frame(frame)
[08:28:17.473]                       master <- NULL
[08:28:17.473]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.473]                         !identical(envir, emptyenv())) {
[08:28:17.473]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.473]                           inherits = FALSE)) {
[08:28:17.473]                           master <- get("master", mode = "list", 
[08:28:17.473]                             envir = envir, inherits = FALSE)
[08:28:17.473]                           if (inherits(master, c("SOCKnode", 
[08:28:17.473]                             "SOCK0node"))) {
[08:28:17.473]                             sendCondition <<- function(cond) {
[08:28:17.473]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.473]                                 success = TRUE)
[08:28:17.473]                               parallel_sendData(master, data)
[08:28:17.473]                             }
[08:28:17.473]                             return(sendCondition)
[08:28:17.473]                           }
[08:28:17.473]                         }
[08:28:17.473]                         frame <- frame + 1L
[08:28:17.473]                         envir <- sys.frame(frame)
[08:28:17.473]                       }
[08:28:17.473]                     }
[08:28:17.473]                     sendCondition <<- function(cond) NULL
[08:28:17.473]                   }
[08:28:17.473]                 })
[08:28:17.473]                 withCallingHandlers({
[08:28:17.473]                   1
[08:28:17.473]                 }, immediateCondition = function(cond) {
[08:28:17.473]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.473]                   sendCondition(cond)
[08:28:17.473]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.473]                   {
[08:28:17.473]                     inherits <- base::inherits
[08:28:17.473]                     invokeRestart <- base::invokeRestart
[08:28:17.473]                     is.null <- base::is.null
[08:28:17.473]                     muffled <- FALSE
[08:28:17.473]                     if (inherits(cond, "message")) {
[08:28:17.473]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.473]                       if (muffled) 
[08:28:17.473]                         invokeRestart("muffleMessage")
[08:28:17.473]                     }
[08:28:17.473]                     else if (inherits(cond, "warning")) {
[08:28:17.473]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.473]                       if (muffled) 
[08:28:17.473]                         invokeRestart("muffleWarning")
[08:28:17.473]                     }
[08:28:17.473]                     else if (inherits(cond, "condition")) {
[08:28:17.473]                       if (!is.null(pattern)) {
[08:28:17.473]                         computeRestarts <- base::computeRestarts
[08:28:17.473]                         grepl <- base::grepl
[08:28:17.473]                         restarts <- computeRestarts(cond)
[08:28:17.473]                         for (restart in restarts) {
[08:28:17.473]                           name <- restart$name
[08:28:17.473]                           if (is.null(name)) 
[08:28:17.473]                             next
[08:28:17.473]                           if (!grepl(pattern, name)) 
[08:28:17.473]                             next
[08:28:17.473]                           invokeRestart(restart)
[08:28:17.473]                           muffled <- TRUE
[08:28:17.473]                           break
[08:28:17.473]                         }
[08:28:17.473]                       }
[08:28:17.473]                     }
[08:28:17.473]                     invisible(muffled)
[08:28:17.473]                   }
[08:28:17.473]                   muffleCondition(cond)
[08:28:17.473]                 })
[08:28:17.473]             }))
[08:28:17.473]             future::FutureResult(value = ...future.value$value, 
[08:28:17.473]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.473]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.473]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.473]                     ...future.globalenv.names))
[08:28:17.473]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.473]         }, condition = base::local({
[08:28:17.473]             c <- base::c
[08:28:17.473]             inherits <- base::inherits
[08:28:17.473]             invokeRestart <- base::invokeRestart
[08:28:17.473]             length <- base::length
[08:28:17.473]             list <- base::list
[08:28:17.473]             seq.int <- base::seq.int
[08:28:17.473]             signalCondition <- base::signalCondition
[08:28:17.473]             sys.calls <- base::sys.calls
[08:28:17.473]             `[[` <- base::`[[`
[08:28:17.473]             `+` <- base::`+`
[08:28:17.473]             `<<-` <- base::`<<-`
[08:28:17.473]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.473]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.473]                   3L)]
[08:28:17.473]             }
[08:28:17.473]             function(cond) {
[08:28:17.473]                 is_error <- inherits(cond, "error")
[08:28:17.473]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.473]                   NULL)
[08:28:17.473]                 if (is_error) {
[08:28:17.473]                   sessionInformation <- function() {
[08:28:17.473]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.473]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.473]                       search = base::search(), system = base::Sys.info())
[08:28:17.473]                   }
[08:28:17.473]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.473]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.473]                     cond$call), session = sessionInformation(), 
[08:28:17.473]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.473]                   signalCondition(cond)
[08:28:17.473]                 }
[08:28:17.473]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.473]                 "immediateCondition"))) {
[08:28:17.473]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.473]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.473]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.473]                   if (TRUE && !signal) {
[08:28:17.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.473]                     {
[08:28:17.473]                       inherits <- base::inherits
[08:28:17.473]                       invokeRestart <- base::invokeRestart
[08:28:17.473]                       is.null <- base::is.null
[08:28:17.473]                       muffled <- FALSE
[08:28:17.473]                       if (inherits(cond, "message")) {
[08:28:17.473]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.473]                         if (muffled) 
[08:28:17.473]                           invokeRestart("muffleMessage")
[08:28:17.473]                       }
[08:28:17.473]                       else if (inherits(cond, "warning")) {
[08:28:17.473]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.473]                         if (muffled) 
[08:28:17.473]                           invokeRestart("muffleWarning")
[08:28:17.473]                       }
[08:28:17.473]                       else if (inherits(cond, "condition")) {
[08:28:17.473]                         if (!is.null(pattern)) {
[08:28:17.473]                           computeRestarts <- base::computeRestarts
[08:28:17.473]                           grepl <- base::grepl
[08:28:17.473]                           restarts <- computeRestarts(cond)
[08:28:17.473]                           for (restart in restarts) {
[08:28:17.473]                             name <- restart$name
[08:28:17.473]                             if (is.null(name)) 
[08:28:17.473]                               next
[08:28:17.473]                             if (!grepl(pattern, name)) 
[08:28:17.473]                               next
[08:28:17.473]                             invokeRestart(restart)
[08:28:17.473]                             muffled <- TRUE
[08:28:17.473]                             break
[08:28:17.473]                           }
[08:28:17.473]                         }
[08:28:17.473]                       }
[08:28:17.473]                       invisible(muffled)
[08:28:17.473]                     }
[08:28:17.473]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.473]                   }
[08:28:17.473]                 }
[08:28:17.473]                 else {
[08:28:17.473]                   if (TRUE) {
[08:28:17.473]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.473]                     {
[08:28:17.473]                       inherits <- base::inherits
[08:28:17.473]                       invokeRestart <- base::invokeRestart
[08:28:17.473]                       is.null <- base::is.null
[08:28:17.473]                       muffled <- FALSE
[08:28:17.473]                       if (inherits(cond, "message")) {
[08:28:17.473]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.473]                         if (muffled) 
[08:28:17.473]                           invokeRestart("muffleMessage")
[08:28:17.473]                       }
[08:28:17.473]                       else if (inherits(cond, "warning")) {
[08:28:17.473]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.473]                         if (muffled) 
[08:28:17.473]                           invokeRestart("muffleWarning")
[08:28:17.473]                       }
[08:28:17.473]                       else if (inherits(cond, "condition")) {
[08:28:17.473]                         if (!is.null(pattern)) {
[08:28:17.473]                           computeRestarts <- base::computeRestarts
[08:28:17.473]                           grepl <- base::grepl
[08:28:17.473]                           restarts <- computeRestarts(cond)
[08:28:17.473]                           for (restart in restarts) {
[08:28:17.473]                             name <- restart$name
[08:28:17.473]                             if (is.null(name)) 
[08:28:17.473]                               next
[08:28:17.473]                             if (!grepl(pattern, name)) 
[08:28:17.473]                               next
[08:28:17.473]                             invokeRestart(restart)
[08:28:17.473]                             muffled <- TRUE
[08:28:17.473]                             break
[08:28:17.473]                           }
[08:28:17.473]                         }
[08:28:17.473]                       }
[08:28:17.473]                       invisible(muffled)
[08:28:17.473]                     }
[08:28:17.473]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.473]                   }
[08:28:17.473]                 }
[08:28:17.473]             }
[08:28:17.473]         }))
[08:28:17.473]     }, error = function(ex) {
[08:28:17.473]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.473]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.473]                 ...future.rng), started = ...future.startTime, 
[08:28:17.473]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.473]             version = "1.8"), class = "FutureResult")
[08:28:17.473]     }, finally = {
[08:28:17.473]         if (!identical(...future.workdir, getwd())) 
[08:28:17.473]             setwd(...future.workdir)
[08:28:17.473]         {
[08:28:17.473]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.473]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.473]             }
[08:28:17.473]             base::options(...future.oldOptions)
[08:28:17.473]             if (.Platform$OS.type == "windows") {
[08:28:17.473]                 old_names <- names(...future.oldEnvVars)
[08:28:17.473]                 envs <- base::Sys.getenv()
[08:28:17.473]                 names <- names(envs)
[08:28:17.473]                 common <- intersect(names, old_names)
[08:28:17.473]                 added <- setdiff(names, old_names)
[08:28:17.473]                 removed <- setdiff(old_names, names)
[08:28:17.473]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.473]                   envs[common]]
[08:28:17.473]                 NAMES <- toupper(changed)
[08:28:17.473]                 args <- list()
[08:28:17.473]                 for (kk in seq_along(NAMES)) {
[08:28:17.473]                   name <- changed[[kk]]
[08:28:17.473]                   NAME <- NAMES[[kk]]
[08:28:17.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.473]                     next
[08:28:17.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.473]                 }
[08:28:17.473]                 NAMES <- toupper(added)
[08:28:17.473]                 for (kk in seq_along(NAMES)) {
[08:28:17.473]                   name <- added[[kk]]
[08:28:17.473]                   NAME <- NAMES[[kk]]
[08:28:17.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.473]                     next
[08:28:17.473]                   args[[name]] <- ""
[08:28:17.473]                 }
[08:28:17.473]                 NAMES <- toupper(removed)
[08:28:17.473]                 for (kk in seq_along(NAMES)) {
[08:28:17.473]                   name <- removed[[kk]]
[08:28:17.473]                   NAME <- NAMES[[kk]]
[08:28:17.473]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.473]                     next
[08:28:17.473]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.473]                 }
[08:28:17.473]                 if (length(args) > 0) 
[08:28:17.473]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.473]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.473]             }
[08:28:17.473]             else {
[08:28:17.473]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.473]             }
[08:28:17.473]             {
[08:28:17.473]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.473]                   0L) {
[08:28:17.473]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.473]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.473]                   base::options(opts)
[08:28:17.473]                 }
[08:28:17.473]                 {
[08:28:17.473]                   {
[08:28:17.473]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.473]                     NULL
[08:28:17.473]                   }
[08:28:17.473]                   options(future.plan = NULL)
[08:28:17.473]                   if (is.na(NA_character_)) 
[08:28:17.473]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.473]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.473]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.473]                     .init = FALSE)
[08:28:17.473]                 }
[08:28:17.473]             }
[08:28:17.473]         }
[08:28:17.473]     })
[08:28:17.473]     if (TRUE) {
[08:28:17.473]         base::sink(type = "output", split = FALSE)
[08:28:17.473]         if (TRUE) {
[08:28:17.473]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.473]         }
[08:28:17.473]         else {
[08:28:17.473]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.473]         }
[08:28:17.473]         base::close(...future.stdout)
[08:28:17.473]         ...future.stdout <- NULL
[08:28:17.473]     }
[08:28:17.473]     ...future.result$conditions <- ...future.conditions
[08:28:17.473]     ...future.result$finished <- base::Sys.time()
[08:28:17.473]     ...future.result
[08:28:17.473] }
[08:28:17.476] MultisessionFuture started
[08:28:17.476] - Launch lazy future ... done
[08:28:17.476] run() for ‘MultisessionFuture’ ... done
[08:28:17.518] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.518] - Validating connection of MultisessionFuture
[08:28:17.518] - received message: FutureResult
[08:28:17.519] - Received FutureResult
[08:28:17.519] - Erased future from FutureRegistry
[08:28:17.519] result() for ClusterFuture ...
[08:28:17.519] - result already collected: FutureResult
[08:28:17.519] result() for ClusterFuture ... done
[08:28:17.519] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.519] Future #1
[08:28:17.519] result() for ClusterFuture ...
[08:28:17.519] - result already collected: FutureResult
[08:28:17.519] result() for ClusterFuture ... done
[08:28:17.519] result() for ClusterFuture ...
[08:28:17.519] - result already collected: FutureResult
[08:28:17.520] result() for ClusterFuture ... done
[08:28:17.520] A MultisessionFuture was resolved
[08:28:17.520]  length: 0 (resolved future 1)
[08:28:17.520] resolve() on list ... DONE
[08:28:17.520] - globals: [1] ‘a’
[08:28:17.520] Resolving futures part of globals (recursively) ... DONE
[08:28:17.531] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[08:28:17.532] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[08:28:17.532] - globals: [1] ‘a’
[08:28:17.532] - packages: [1] ‘future’
[08:28:17.532] getGlobalsAndPackages() ... DONE
[08:28:17.532] run() for ‘Future’ ...
[08:28:17.532] - state: ‘created’
[08:28:17.533] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.546] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.547] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.547]   - Field: ‘node’
[08:28:17.547]   - Field: ‘label’
[08:28:17.547]   - Field: ‘local’
[08:28:17.547]   - Field: ‘owner’
[08:28:17.547]   - Field: ‘envir’
[08:28:17.547]   - Field: ‘workers’
[08:28:17.547]   - Field: ‘packages’
[08:28:17.547]   - Field: ‘gc’
[08:28:17.547]   - Field: ‘conditions’
[08:28:17.548]   - Field: ‘persistent’
[08:28:17.548]   - Field: ‘expr’
[08:28:17.548]   - Field: ‘uuid’
[08:28:17.548]   - Field: ‘seed’
[08:28:17.548]   - Field: ‘version’
[08:28:17.548]   - Field: ‘result’
[08:28:17.548]   - Field: ‘asynchronous’
[08:28:17.548]   - Field: ‘calls’
[08:28:17.548]   - Field: ‘globals’
[08:28:17.548]   - Field: ‘stdout’
[08:28:17.548]   - Field: ‘earlySignal’
[08:28:17.548]   - Field: ‘lazy’
[08:28:17.549]   - Field: ‘state’
[08:28:17.549] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.549] - Launch lazy future ...
[08:28:17.549] Packages needed by the future expression (n = 1): ‘future’
[08:28:17.549] Packages needed by future strategies (n = 0): <none>
[08:28:17.550] {
[08:28:17.550]     {
[08:28:17.550]         {
[08:28:17.550]             ...future.startTime <- base::Sys.time()
[08:28:17.550]             {
[08:28:17.550]                 {
[08:28:17.550]                   {
[08:28:17.550]                     {
[08:28:17.550]                       {
[08:28:17.550]                         base::local({
[08:28:17.550]                           has_future <- base::requireNamespace("future", 
[08:28:17.550]                             quietly = TRUE)
[08:28:17.550]                           if (has_future) {
[08:28:17.550]                             ns <- base::getNamespace("future")
[08:28:17.550]                             version <- ns[[".package"]][["version"]]
[08:28:17.550]                             if (is.null(version)) 
[08:28:17.550]                               version <- utils::packageVersion("future")
[08:28:17.550]                           }
[08:28:17.550]                           else {
[08:28:17.550]                             version <- NULL
[08:28:17.550]                           }
[08:28:17.550]                           if (!has_future || version < "1.8.0") {
[08:28:17.550]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.550]                               "", base::R.version$version.string), 
[08:28:17.550]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:17.550]                                 base::R.version$platform, 8 * 
[08:28:17.550]                                   base::.Machine$sizeof.pointer), 
[08:28:17.550]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.550]                                 "release", "version")], collapse = " "), 
[08:28:17.550]                               hostname = base::Sys.info()[["nodename"]])
[08:28:17.550]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.550]                               info)
[08:28:17.550]                             info <- base::paste(info, collapse = "; ")
[08:28:17.550]                             if (!has_future) {
[08:28:17.550]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.550]                                 info)
[08:28:17.550]                             }
[08:28:17.550]                             else {
[08:28:17.550]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.550]                                 info, version)
[08:28:17.550]                             }
[08:28:17.550]                             base::stop(msg)
[08:28:17.550]                           }
[08:28:17.550]                         })
[08:28:17.550]                       }
[08:28:17.550]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.550]                       base::options(mc.cores = 1L)
[08:28:17.550]                     }
[08:28:17.550]                     base::local({
[08:28:17.550]                       for (pkg in "future") {
[08:28:17.550]                         base::loadNamespace(pkg)
[08:28:17.550]                         base::library(pkg, character.only = TRUE)
[08:28:17.550]                       }
[08:28:17.550]                     })
[08:28:17.550]                   }
[08:28:17.550]                   ...future.strategy.old <- future::plan("list")
[08:28:17.550]                   options(future.plan = NULL)
[08:28:17.550]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.550]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.550]                 }
[08:28:17.550]                 ...future.workdir <- getwd()
[08:28:17.550]             }
[08:28:17.550]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.550]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.550]         }
[08:28:17.550]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.550]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.550]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.550]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.550]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.550]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.550]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.550]             base::names(...future.oldOptions))
[08:28:17.550]     }
[08:28:17.550]     if (FALSE) {
[08:28:17.550]     }
[08:28:17.550]     else {
[08:28:17.550]         if (TRUE) {
[08:28:17.550]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.550]                 open = "w")
[08:28:17.550]         }
[08:28:17.550]         else {
[08:28:17.550]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.550]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.550]         }
[08:28:17.550]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.550]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.550]             base::sink(type = "output", split = FALSE)
[08:28:17.550]             base::close(...future.stdout)
[08:28:17.550]         }, add = TRUE)
[08:28:17.550]     }
[08:28:17.550]     ...future.frame <- base::sys.nframe()
[08:28:17.550]     ...future.conditions <- base::list()
[08:28:17.550]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.550]     if (FALSE) {
[08:28:17.550]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.550]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.550]     }
[08:28:17.550]     ...future.result <- base::tryCatch({
[08:28:17.550]         base::withCallingHandlers({
[08:28:17.550]             ...future.value <- base::withVisible(base::local({
[08:28:17.550]                 ...future.makeSendCondition <- base::local({
[08:28:17.550]                   sendCondition <- NULL
[08:28:17.550]                   function(frame = 1L) {
[08:28:17.550]                     if (is.function(sendCondition)) 
[08:28:17.550]                       return(sendCondition)
[08:28:17.550]                     ns <- getNamespace("parallel")
[08:28:17.550]                     if (exists("sendData", mode = "function", 
[08:28:17.550]                       envir = ns)) {
[08:28:17.550]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.550]                         envir = ns)
[08:28:17.550]                       envir <- sys.frame(frame)
[08:28:17.550]                       master <- NULL
[08:28:17.550]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.550]                         !identical(envir, emptyenv())) {
[08:28:17.550]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.550]                           inherits = FALSE)) {
[08:28:17.550]                           master <- get("master", mode = "list", 
[08:28:17.550]                             envir = envir, inherits = FALSE)
[08:28:17.550]                           if (inherits(master, c("SOCKnode", 
[08:28:17.550]                             "SOCK0node"))) {
[08:28:17.550]                             sendCondition <<- function(cond) {
[08:28:17.550]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.550]                                 success = TRUE)
[08:28:17.550]                               parallel_sendData(master, data)
[08:28:17.550]                             }
[08:28:17.550]                             return(sendCondition)
[08:28:17.550]                           }
[08:28:17.550]                         }
[08:28:17.550]                         frame <- frame + 1L
[08:28:17.550]                         envir <- sys.frame(frame)
[08:28:17.550]                       }
[08:28:17.550]                     }
[08:28:17.550]                     sendCondition <<- function(cond) NULL
[08:28:17.550]                   }
[08:28:17.550]                 })
[08:28:17.550]                 withCallingHandlers({
[08:28:17.550]                   value(a) + 1
[08:28:17.550]                 }, immediateCondition = function(cond) {
[08:28:17.550]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.550]                   sendCondition(cond)
[08:28:17.550]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.550]                   {
[08:28:17.550]                     inherits <- base::inherits
[08:28:17.550]                     invokeRestart <- base::invokeRestart
[08:28:17.550]                     is.null <- base::is.null
[08:28:17.550]                     muffled <- FALSE
[08:28:17.550]                     if (inherits(cond, "message")) {
[08:28:17.550]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.550]                       if (muffled) 
[08:28:17.550]                         invokeRestart("muffleMessage")
[08:28:17.550]                     }
[08:28:17.550]                     else if (inherits(cond, "warning")) {
[08:28:17.550]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.550]                       if (muffled) 
[08:28:17.550]                         invokeRestart("muffleWarning")
[08:28:17.550]                     }
[08:28:17.550]                     else if (inherits(cond, "condition")) {
[08:28:17.550]                       if (!is.null(pattern)) {
[08:28:17.550]                         computeRestarts <- base::computeRestarts
[08:28:17.550]                         grepl <- base::grepl
[08:28:17.550]                         restarts <- computeRestarts(cond)
[08:28:17.550]                         for (restart in restarts) {
[08:28:17.550]                           name <- restart$name
[08:28:17.550]                           if (is.null(name)) 
[08:28:17.550]                             next
[08:28:17.550]                           if (!grepl(pattern, name)) 
[08:28:17.550]                             next
[08:28:17.550]                           invokeRestart(restart)
[08:28:17.550]                           muffled <- TRUE
[08:28:17.550]                           break
[08:28:17.550]                         }
[08:28:17.550]                       }
[08:28:17.550]                     }
[08:28:17.550]                     invisible(muffled)
[08:28:17.550]                   }
[08:28:17.550]                   muffleCondition(cond)
[08:28:17.550]                 })
[08:28:17.550]             }))
[08:28:17.550]             future::FutureResult(value = ...future.value$value, 
[08:28:17.550]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.550]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.550]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.550]                     ...future.globalenv.names))
[08:28:17.550]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.550]         }, condition = base::local({
[08:28:17.550]             c <- base::c
[08:28:17.550]             inherits <- base::inherits
[08:28:17.550]             invokeRestart <- base::invokeRestart
[08:28:17.550]             length <- base::length
[08:28:17.550]             list <- base::list
[08:28:17.550]             seq.int <- base::seq.int
[08:28:17.550]             signalCondition <- base::signalCondition
[08:28:17.550]             sys.calls <- base::sys.calls
[08:28:17.550]             `[[` <- base::`[[`
[08:28:17.550]             `+` <- base::`+`
[08:28:17.550]             `<<-` <- base::`<<-`
[08:28:17.550]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.550]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.550]                   3L)]
[08:28:17.550]             }
[08:28:17.550]             function(cond) {
[08:28:17.550]                 is_error <- inherits(cond, "error")
[08:28:17.550]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.550]                   NULL)
[08:28:17.550]                 if (is_error) {
[08:28:17.550]                   sessionInformation <- function() {
[08:28:17.550]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.550]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.550]                       search = base::search(), system = base::Sys.info())
[08:28:17.550]                   }
[08:28:17.550]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.550]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.550]                     cond$call), session = sessionInformation(), 
[08:28:17.550]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.550]                   signalCondition(cond)
[08:28:17.550]                 }
[08:28:17.550]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.550]                 "immediateCondition"))) {
[08:28:17.550]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.550]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.550]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.550]                   if (TRUE && !signal) {
[08:28:17.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.550]                     {
[08:28:17.550]                       inherits <- base::inherits
[08:28:17.550]                       invokeRestart <- base::invokeRestart
[08:28:17.550]                       is.null <- base::is.null
[08:28:17.550]                       muffled <- FALSE
[08:28:17.550]                       if (inherits(cond, "message")) {
[08:28:17.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.550]                         if (muffled) 
[08:28:17.550]                           invokeRestart("muffleMessage")
[08:28:17.550]                       }
[08:28:17.550]                       else if (inherits(cond, "warning")) {
[08:28:17.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.550]                         if (muffled) 
[08:28:17.550]                           invokeRestart("muffleWarning")
[08:28:17.550]                       }
[08:28:17.550]                       else if (inherits(cond, "condition")) {
[08:28:17.550]                         if (!is.null(pattern)) {
[08:28:17.550]                           computeRestarts <- base::computeRestarts
[08:28:17.550]                           grepl <- base::grepl
[08:28:17.550]                           restarts <- computeRestarts(cond)
[08:28:17.550]                           for (restart in restarts) {
[08:28:17.550]                             name <- restart$name
[08:28:17.550]                             if (is.null(name)) 
[08:28:17.550]                               next
[08:28:17.550]                             if (!grepl(pattern, name)) 
[08:28:17.550]                               next
[08:28:17.550]                             invokeRestart(restart)
[08:28:17.550]                             muffled <- TRUE
[08:28:17.550]                             break
[08:28:17.550]                           }
[08:28:17.550]                         }
[08:28:17.550]                       }
[08:28:17.550]                       invisible(muffled)
[08:28:17.550]                     }
[08:28:17.550]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.550]                   }
[08:28:17.550]                 }
[08:28:17.550]                 else {
[08:28:17.550]                   if (TRUE) {
[08:28:17.550]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.550]                     {
[08:28:17.550]                       inherits <- base::inherits
[08:28:17.550]                       invokeRestart <- base::invokeRestart
[08:28:17.550]                       is.null <- base::is.null
[08:28:17.550]                       muffled <- FALSE
[08:28:17.550]                       if (inherits(cond, "message")) {
[08:28:17.550]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.550]                         if (muffled) 
[08:28:17.550]                           invokeRestart("muffleMessage")
[08:28:17.550]                       }
[08:28:17.550]                       else if (inherits(cond, "warning")) {
[08:28:17.550]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.550]                         if (muffled) 
[08:28:17.550]                           invokeRestart("muffleWarning")
[08:28:17.550]                       }
[08:28:17.550]                       else if (inherits(cond, "condition")) {
[08:28:17.550]                         if (!is.null(pattern)) {
[08:28:17.550]                           computeRestarts <- base::computeRestarts
[08:28:17.550]                           grepl <- base::grepl
[08:28:17.550]                           restarts <- computeRestarts(cond)
[08:28:17.550]                           for (restart in restarts) {
[08:28:17.550]                             name <- restart$name
[08:28:17.550]                             if (is.null(name)) 
[08:28:17.550]                               next
[08:28:17.550]                             if (!grepl(pattern, name)) 
[08:28:17.550]                               next
[08:28:17.550]                             invokeRestart(restart)
[08:28:17.550]                             muffled <- TRUE
[08:28:17.550]                             break
[08:28:17.550]                           }
[08:28:17.550]                         }
[08:28:17.550]                       }
[08:28:17.550]                       invisible(muffled)
[08:28:17.550]                     }
[08:28:17.550]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.550]                   }
[08:28:17.550]                 }
[08:28:17.550]             }
[08:28:17.550]         }))
[08:28:17.550]     }, error = function(ex) {
[08:28:17.550]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.550]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.550]                 ...future.rng), started = ...future.startTime, 
[08:28:17.550]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.550]             version = "1.8"), class = "FutureResult")
[08:28:17.550]     }, finally = {
[08:28:17.550]         if (!identical(...future.workdir, getwd())) 
[08:28:17.550]             setwd(...future.workdir)
[08:28:17.550]         {
[08:28:17.550]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.550]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.550]             }
[08:28:17.550]             base::options(...future.oldOptions)
[08:28:17.550]             if (.Platform$OS.type == "windows") {
[08:28:17.550]                 old_names <- names(...future.oldEnvVars)
[08:28:17.550]                 envs <- base::Sys.getenv()
[08:28:17.550]                 names <- names(envs)
[08:28:17.550]                 common <- intersect(names, old_names)
[08:28:17.550]                 added <- setdiff(names, old_names)
[08:28:17.550]                 removed <- setdiff(old_names, names)
[08:28:17.550]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.550]                   envs[common]]
[08:28:17.550]                 NAMES <- toupper(changed)
[08:28:17.550]                 args <- list()
[08:28:17.550]                 for (kk in seq_along(NAMES)) {
[08:28:17.550]                   name <- changed[[kk]]
[08:28:17.550]                   NAME <- NAMES[[kk]]
[08:28:17.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.550]                     next
[08:28:17.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.550]                 }
[08:28:17.550]                 NAMES <- toupper(added)
[08:28:17.550]                 for (kk in seq_along(NAMES)) {
[08:28:17.550]                   name <- added[[kk]]
[08:28:17.550]                   NAME <- NAMES[[kk]]
[08:28:17.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.550]                     next
[08:28:17.550]                   args[[name]] <- ""
[08:28:17.550]                 }
[08:28:17.550]                 NAMES <- toupper(removed)
[08:28:17.550]                 for (kk in seq_along(NAMES)) {
[08:28:17.550]                   name <- removed[[kk]]
[08:28:17.550]                   NAME <- NAMES[[kk]]
[08:28:17.550]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.550]                     next
[08:28:17.550]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.550]                 }
[08:28:17.550]                 if (length(args) > 0) 
[08:28:17.550]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.550]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.550]             }
[08:28:17.550]             else {
[08:28:17.550]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.550]             }
[08:28:17.550]             {
[08:28:17.550]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.550]                   0L) {
[08:28:17.550]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.550]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.550]                   base::options(opts)
[08:28:17.550]                 }
[08:28:17.550]                 {
[08:28:17.550]                   {
[08:28:17.550]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.550]                     NULL
[08:28:17.550]                   }
[08:28:17.550]                   options(future.plan = NULL)
[08:28:17.550]                   if (is.na(NA_character_)) 
[08:28:17.550]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.550]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.550]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.550]                     .init = FALSE)
[08:28:17.550]                 }
[08:28:17.550]             }
[08:28:17.550]         }
[08:28:17.550]     })
[08:28:17.550]     if (TRUE) {
[08:28:17.550]         base::sink(type = "output", split = FALSE)
[08:28:17.550]         if (TRUE) {
[08:28:17.550]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.550]         }
[08:28:17.550]         else {
[08:28:17.550]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.550]         }
[08:28:17.550]         base::close(...future.stdout)
[08:28:17.550]         ...future.stdout <- NULL
[08:28:17.550]     }
[08:28:17.550]     ...future.result$conditions <- ...future.conditions
[08:28:17.550]     ...future.result$finished <- base::Sys.time()
[08:28:17.550]     ...future.result
[08:28:17.550] }
[08:28:17.563] Exporting 1 global objects (313.46 KiB) to cluster node #2 ...
[08:28:17.574] Exporting ‘a’ (313.25 KiB) to cluster node #2 ...
[08:28:17.626] Exporting ‘a’ (313.25 KiB) to cluster node #2 ... DONE
[08:28:17.626] Exporting 1 global objects (313.46 KiB) to cluster node #2 ... DONE
[08:28:17.626] MultisessionFuture started
[08:28:17.627] - Launch lazy future ... done
[08:28:17.627] run() for ‘MultisessionFuture’ ... done
[08:28:17.627] result() for ClusterFuture ...
[08:28:17.627] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.627] - Validating connection of MultisessionFuture
[08:28:17.668] - received message: FutureResult
[08:28:17.668] - Received FutureResult
[08:28:17.669] - Erased future from FutureRegistry
[08:28:17.669] result() for ClusterFuture ...
[08:28:17.669] - result already collected: FutureResult
[08:28:17.669] result() for ClusterFuture ... done
[08:28:17.669] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.669] result() for ClusterFuture ... done
[08:28:17.669] result() for ClusterFuture ...
[08:28:17.669] - result already collected: FutureResult
[08:28:17.669] result() for ClusterFuture ... done
value(b) = 2
[08:28:17.670] result() for ClusterFuture ...
[08:28:17.670] - result already collected: FutureResult
[08:28:17.670] result() for ClusterFuture ... done
[08:28:17.670] result() for ClusterFuture ...
[08:28:17.670] - result already collected: FutureResult
[08:28:17.670] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.670] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.670] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.671] 
[08:28:17.671] Searching for globals ... DONE
[08:28:17.671] - globals: [0] <none>
[08:28:17.671] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.672] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.672] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.673] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:17.673] Searching for globals ... DONE
[08:28:17.673] Resolving globals: TRUE
[08:28:17.673] Resolving any globals that are futures ...
[08:28:17.673] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:17.673] Resolving any globals that are futures ... DONE
[08:28:17.673] Resolving futures part of globals (recursively) ...
[08:28:17.674] resolve() on list ...
[08:28:17.674]  recursive: 99
[08:28:17.674]  length: 1
[08:28:17.674]  elements: ‘a’
[08:28:17.674] run() for ‘Future’ ...
[08:28:17.674] - state: ‘created’
[08:28:17.674] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.688] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.688] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.689]   - Field: ‘node’
[08:28:17.689]   - Field: ‘label’
[08:28:17.689]   - Field: ‘local’
[08:28:17.689]   - Field: ‘owner’
[08:28:17.689]   - Field: ‘envir’
[08:28:17.689]   - Field: ‘workers’
[08:28:17.689]   - Field: ‘packages’
[08:28:17.689]   - Field: ‘gc’
[08:28:17.689]   - Field: ‘conditions’
[08:28:17.689]   - Field: ‘persistent’
[08:28:17.689]   - Field: ‘expr’
[08:28:17.690]   - Field: ‘uuid’
[08:28:17.690]   - Field: ‘seed’
[08:28:17.690]   - Field: ‘version’
[08:28:17.690]   - Field: ‘result’
[08:28:17.690]   - Field: ‘asynchronous’
[08:28:17.690]   - Field: ‘calls’
[08:28:17.690]   - Field: ‘globals’
[08:28:17.690]   - Field: ‘stdout’
[08:28:17.690]   - Field: ‘earlySignal’
[08:28:17.690]   - Field: ‘lazy’
[08:28:17.690]   - Field: ‘state’
[08:28:17.691] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.691] - Launch lazy future ...
[08:28:17.691] Packages needed by the future expression (n = 0): <none>
[08:28:17.691] Packages needed by future strategies (n = 0): <none>
[08:28:17.691] {
[08:28:17.691]     {
[08:28:17.691]         {
[08:28:17.691]             ...future.startTime <- base::Sys.time()
[08:28:17.691]             {
[08:28:17.691]                 {
[08:28:17.691]                   {
[08:28:17.691]                     {
[08:28:17.691]                       base::local({
[08:28:17.691]                         has_future <- base::requireNamespace("future", 
[08:28:17.691]                           quietly = TRUE)
[08:28:17.691]                         if (has_future) {
[08:28:17.691]                           ns <- base::getNamespace("future")
[08:28:17.691]                           version <- ns[[".package"]][["version"]]
[08:28:17.691]                           if (is.null(version)) 
[08:28:17.691]                             version <- utils::packageVersion("future")
[08:28:17.691]                         }
[08:28:17.691]                         else {
[08:28:17.691]                           version <- NULL
[08:28:17.691]                         }
[08:28:17.691]                         if (!has_future || version < "1.8.0") {
[08:28:17.691]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.691]                             "", base::R.version$version.string), 
[08:28:17.691]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:17.691]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:17.691]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.691]                               "release", "version")], collapse = " "), 
[08:28:17.691]                             hostname = base::Sys.info()[["nodename"]])
[08:28:17.691]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.691]                             info)
[08:28:17.691]                           info <- base::paste(info, collapse = "; ")
[08:28:17.691]                           if (!has_future) {
[08:28:17.691]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.691]                               info)
[08:28:17.691]                           }
[08:28:17.691]                           else {
[08:28:17.691]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.691]                               info, version)
[08:28:17.691]                           }
[08:28:17.691]                           base::stop(msg)
[08:28:17.691]                         }
[08:28:17.691]                       })
[08:28:17.691]                     }
[08:28:17.691]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.691]                     base::options(mc.cores = 1L)
[08:28:17.691]                   }
[08:28:17.691]                   ...future.strategy.old <- future::plan("list")
[08:28:17.691]                   options(future.plan = NULL)
[08:28:17.691]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.691]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.691]                 }
[08:28:17.691]                 ...future.workdir <- getwd()
[08:28:17.691]             }
[08:28:17.691]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.691]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.691]         }
[08:28:17.691]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.691]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.691]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.691]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.691]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.691]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.691]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.691]             base::names(...future.oldOptions))
[08:28:17.691]     }
[08:28:17.691]     if (FALSE) {
[08:28:17.691]     }
[08:28:17.691]     else {
[08:28:17.691]         if (TRUE) {
[08:28:17.691]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.691]                 open = "w")
[08:28:17.691]         }
[08:28:17.691]         else {
[08:28:17.691]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.691]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.691]         }
[08:28:17.691]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.691]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.691]             base::sink(type = "output", split = FALSE)
[08:28:17.691]             base::close(...future.stdout)
[08:28:17.691]         }, add = TRUE)
[08:28:17.691]     }
[08:28:17.691]     ...future.frame <- base::sys.nframe()
[08:28:17.691]     ...future.conditions <- base::list()
[08:28:17.691]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.691]     if (FALSE) {
[08:28:17.691]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.691]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.691]     }
[08:28:17.691]     ...future.result <- base::tryCatch({
[08:28:17.691]         base::withCallingHandlers({
[08:28:17.691]             ...future.value <- base::withVisible(base::local({
[08:28:17.691]                 ...future.makeSendCondition <- base::local({
[08:28:17.691]                   sendCondition <- NULL
[08:28:17.691]                   function(frame = 1L) {
[08:28:17.691]                     if (is.function(sendCondition)) 
[08:28:17.691]                       return(sendCondition)
[08:28:17.691]                     ns <- getNamespace("parallel")
[08:28:17.691]                     if (exists("sendData", mode = "function", 
[08:28:17.691]                       envir = ns)) {
[08:28:17.691]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.691]                         envir = ns)
[08:28:17.691]                       envir <- sys.frame(frame)
[08:28:17.691]                       master <- NULL
[08:28:17.691]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.691]                         !identical(envir, emptyenv())) {
[08:28:17.691]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.691]                           inherits = FALSE)) {
[08:28:17.691]                           master <- get("master", mode = "list", 
[08:28:17.691]                             envir = envir, inherits = FALSE)
[08:28:17.691]                           if (inherits(master, c("SOCKnode", 
[08:28:17.691]                             "SOCK0node"))) {
[08:28:17.691]                             sendCondition <<- function(cond) {
[08:28:17.691]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.691]                                 success = TRUE)
[08:28:17.691]                               parallel_sendData(master, data)
[08:28:17.691]                             }
[08:28:17.691]                             return(sendCondition)
[08:28:17.691]                           }
[08:28:17.691]                         }
[08:28:17.691]                         frame <- frame + 1L
[08:28:17.691]                         envir <- sys.frame(frame)
[08:28:17.691]                       }
[08:28:17.691]                     }
[08:28:17.691]                     sendCondition <<- function(cond) NULL
[08:28:17.691]                   }
[08:28:17.691]                 })
[08:28:17.691]                 withCallingHandlers({
[08:28:17.691]                   1
[08:28:17.691]                 }, immediateCondition = function(cond) {
[08:28:17.691]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.691]                   sendCondition(cond)
[08:28:17.691]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.691]                   {
[08:28:17.691]                     inherits <- base::inherits
[08:28:17.691]                     invokeRestart <- base::invokeRestart
[08:28:17.691]                     is.null <- base::is.null
[08:28:17.691]                     muffled <- FALSE
[08:28:17.691]                     if (inherits(cond, "message")) {
[08:28:17.691]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.691]                       if (muffled) 
[08:28:17.691]                         invokeRestart("muffleMessage")
[08:28:17.691]                     }
[08:28:17.691]                     else if (inherits(cond, "warning")) {
[08:28:17.691]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.691]                       if (muffled) 
[08:28:17.691]                         invokeRestart("muffleWarning")
[08:28:17.691]                     }
[08:28:17.691]                     else if (inherits(cond, "condition")) {
[08:28:17.691]                       if (!is.null(pattern)) {
[08:28:17.691]                         computeRestarts <- base::computeRestarts
[08:28:17.691]                         grepl <- base::grepl
[08:28:17.691]                         restarts <- computeRestarts(cond)
[08:28:17.691]                         for (restart in restarts) {
[08:28:17.691]                           name <- restart$name
[08:28:17.691]                           if (is.null(name)) 
[08:28:17.691]                             next
[08:28:17.691]                           if (!grepl(pattern, name)) 
[08:28:17.691]                             next
[08:28:17.691]                           invokeRestart(restart)
[08:28:17.691]                           muffled <- TRUE
[08:28:17.691]                           break
[08:28:17.691]                         }
[08:28:17.691]                       }
[08:28:17.691]                     }
[08:28:17.691]                     invisible(muffled)
[08:28:17.691]                   }
[08:28:17.691]                   muffleCondition(cond)
[08:28:17.691]                 })
[08:28:17.691]             }))
[08:28:17.691]             future::FutureResult(value = ...future.value$value, 
[08:28:17.691]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.691]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.691]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.691]                     ...future.globalenv.names))
[08:28:17.691]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.691]         }, condition = base::local({
[08:28:17.691]             c <- base::c
[08:28:17.691]             inherits <- base::inherits
[08:28:17.691]             invokeRestart <- base::invokeRestart
[08:28:17.691]             length <- base::length
[08:28:17.691]             list <- base::list
[08:28:17.691]             seq.int <- base::seq.int
[08:28:17.691]             signalCondition <- base::signalCondition
[08:28:17.691]             sys.calls <- base::sys.calls
[08:28:17.691]             `[[` <- base::`[[`
[08:28:17.691]             `+` <- base::`+`
[08:28:17.691]             `<<-` <- base::`<<-`
[08:28:17.691]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.691]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.691]                   3L)]
[08:28:17.691]             }
[08:28:17.691]             function(cond) {
[08:28:17.691]                 is_error <- inherits(cond, "error")
[08:28:17.691]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.691]                   NULL)
[08:28:17.691]                 if (is_error) {
[08:28:17.691]                   sessionInformation <- function() {
[08:28:17.691]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.691]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.691]                       search = base::search(), system = base::Sys.info())
[08:28:17.691]                   }
[08:28:17.691]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.691]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.691]                     cond$call), session = sessionInformation(), 
[08:28:17.691]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.691]                   signalCondition(cond)
[08:28:17.691]                 }
[08:28:17.691]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.691]                 "immediateCondition"))) {
[08:28:17.691]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.691]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.691]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.691]                   if (TRUE && !signal) {
[08:28:17.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.691]                     {
[08:28:17.691]                       inherits <- base::inherits
[08:28:17.691]                       invokeRestart <- base::invokeRestart
[08:28:17.691]                       is.null <- base::is.null
[08:28:17.691]                       muffled <- FALSE
[08:28:17.691]                       if (inherits(cond, "message")) {
[08:28:17.691]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.691]                         if (muffled) 
[08:28:17.691]                           invokeRestart("muffleMessage")
[08:28:17.691]                       }
[08:28:17.691]                       else if (inherits(cond, "warning")) {
[08:28:17.691]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.691]                         if (muffled) 
[08:28:17.691]                           invokeRestart("muffleWarning")
[08:28:17.691]                       }
[08:28:17.691]                       else if (inherits(cond, "condition")) {
[08:28:17.691]                         if (!is.null(pattern)) {
[08:28:17.691]                           computeRestarts <- base::computeRestarts
[08:28:17.691]                           grepl <- base::grepl
[08:28:17.691]                           restarts <- computeRestarts(cond)
[08:28:17.691]                           for (restart in restarts) {
[08:28:17.691]                             name <- restart$name
[08:28:17.691]                             if (is.null(name)) 
[08:28:17.691]                               next
[08:28:17.691]                             if (!grepl(pattern, name)) 
[08:28:17.691]                               next
[08:28:17.691]                             invokeRestart(restart)
[08:28:17.691]                             muffled <- TRUE
[08:28:17.691]                             break
[08:28:17.691]                           }
[08:28:17.691]                         }
[08:28:17.691]                       }
[08:28:17.691]                       invisible(muffled)
[08:28:17.691]                     }
[08:28:17.691]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.691]                   }
[08:28:17.691]                 }
[08:28:17.691]                 else {
[08:28:17.691]                   if (TRUE) {
[08:28:17.691]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.691]                     {
[08:28:17.691]                       inherits <- base::inherits
[08:28:17.691]                       invokeRestart <- base::invokeRestart
[08:28:17.691]                       is.null <- base::is.null
[08:28:17.691]                       muffled <- FALSE
[08:28:17.691]                       if (inherits(cond, "message")) {
[08:28:17.691]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.691]                         if (muffled) 
[08:28:17.691]                           invokeRestart("muffleMessage")
[08:28:17.691]                       }
[08:28:17.691]                       else if (inherits(cond, "warning")) {
[08:28:17.691]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.691]                         if (muffled) 
[08:28:17.691]                           invokeRestart("muffleWarning")
[08:28:17.691]                       }
[08:28:17.691]                       else if (inherits(cond, "condition")) {
[08:28:17.691]                         if (!is.null(pattern)) {
[08:28:17.691]                           computeRestarts <- base::computeRestarts
[08:28:17.691]                           grepl <- base::grepl
[08:28:17.691]                           restarts <- computeRestarts(cond)
[08:28:17.691]                           for (restart in restarts) {
[08:28:17.691]                             name <- restart$name
[08:28:17.691]                             if (is.null(name)) 
[08:28:17.691]                               next
[08:28:17.691]                             if (!grepl(pattern, name)) 
[08:28:17.691]                               next
[08:28:17.691]                             invokeRestart(restart)
[08:28:17.691]                             muffled <- TRUE
[08:28:17.691]                             break
[08:28:17.691]                           }
[08:28:17.691]                         }
[08:28:17.691]                       }
[08:28:17.691]                       invisible(muffled)
[08:28:17.691]                     }
[08:28:17.691]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.691]                   }
[08:28:17.691]                 }
[08:28:17.691]             }
[08:28:17.691]         }))
[08:28:17.691]     }, error = function(ex) {
[08:28:17.691]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.691]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.691]                 ...future.rng), started = ...future.startTime, 
[08:28:17.691]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.691]             version = "1.8"), class = "FutureResult")
[08:28:17.691]     }, finally = {
[08:28:17.691]         if (!identical(...future.workdir, getwd())) 
[08:28:17.691]             setwd(...future.workdir)
[08:28:17.691]         {
[08:28:17.691]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.691]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.691]             }
[08:28:17.691]             base::options(...future.oldOptions)
[08:28:17.691]             if (.Platform$OS.type == "windows") {
[08:28:17.691]                 old_names <- names(...future.oldEnvVars)
[08:28:17.691]                 envs <- base::Sys.getenv()
[08:28:17.691]                 names <- names(envs)
[08:28:17.691]                 common <- intersect(names, old_names)
[08:28:17.691]                 added <- setdiff(names, old_names)
[08:28:17.691]                 removed <- setdiff(old_names, names)
[08:28:17.691]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.691]                   envs[common]]
[08:28:17.691]                 NAMES <- toupper(changed)
[08:28:17.691]                 args <- list()
[08:28:17.691]                 for (kk in seq_along(NAMES)) {
[08:28:17.691]                   name <- changed[[kk]]
[08:28:17.691]                   NAME <- NAMES[[kk]]
[08:28:17.691]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.691]                     next
[08:28:17.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.691]                 }
[08:28:17.691]                 NAMES <- toupper(added)
[08:28:17.691]                 for (kk in seq_along(NAMES)) {
[08:28:17.691]                   name <- added[[kk]]
[08:28:17.691]                   NAME <- NAMES[[kk]]
[08:28:17.691]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.691]                     next
[08:28:17.691]                   args[[name]] <- ""
[08:28:17.691]                 }
[08:28:17.691]                 NAMES <- toupper(removed)
[08:28:17.691]                 for (kk in seq_along(NAMES)) {
[08:28:17.691]                   name <- removed[[kk]]
[08:28:17.691]                   NAME <- NAMES[[kk]]
[08:28:17.691]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.691]                     next
[08:28:17.691]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.691]                 }
[08:28:17.691]                 if (length(args) > 0) 
[08:28:17.691]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.691]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.691]             }
[08:28:17.691]             else {
[08:28:17.691]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.691]             }
[08:28:17.691]             {
[08:28:17.691]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.691]                   0L) {
[08:28:17.691]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.691]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.691]                   base::options(opts)
[08:28:17.691]                 }
[08:28:17.691]                 {
[08:28:17.691]                   {
[08:28:17.691]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.691]                     NULL
[08:28:17.691]                   }
[08:28:17.691]                   options(future.plan = NULL)
[08:28:17.691]                   if (is.na(NA_character_)) 
[08:28:17.691]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.691]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.691]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.691]                     .init = FALSE)
[08:28:17.691]                 }
[08:28:17.691]             }
[08:28:17.691]         }
[08:28:17.691]     })
[08:28:17.691]     if (TRUE) {
[08:28:17.691]         base::sink(type = "output", split = FALSE)
[08:28:17.691]         if (TRUE) {
[08:28:17.691]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.691]         }
[08:28:17.691]         else {
[08:28:17.691]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.691]         }
[08:28:17.691]         base::close(...future.stdout)
[08:28:17.691]         ...future.stdout <- NULL
[08:28:17.691]     }
[08:28:17.691]     ...future.result$conditions <- ...future.conditions
[08:28:17.691]     ...future.result$finished <- base::Sys.time()
[08:28:17.691]     ...future.result
[08:28:17.691] }
[08:28:17.694] MultisessionFuture started
[08:28:17.694] - Launch lazy future ... done
[08:28:17.695] run() for ‘MultisessionFuture’ ... done
[08:28:17.736] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.737] - Validating connection of MultisessionFuture
[08:28:17.737] - received message: FutureResult
[08:28:17.737] - Received FutureResult
[08:28:17.737] - Erased future from FutureRegistry
[08:28:17.737] result() for ClusterFuture ...
[08:28:17.737] - result already collected: FutureResult
[08:28:17.737] result() for ClusterFuture ... done
[08:28:17.737] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.737] Future #1
[08:28:17.737] result() for ClusterFuture ...
[08:28:17.738] - result already collected: FutureResult
[08:28:17.738] result() for ClusterFuture ... done
[08:28:17.738] result() for ClusterFuture ...
[08:28:17.738] - result already collected: FutureResult
[08:28:17.738] result() for ClusterFuture ... done
[08:28:17.738] A MultisessionFuture was resolved
[08:28:17.738]  length: 0 (resolved future 1)
[08:28:17.738] resolve() on list ... DONE
[08:28:17.738] - globals: [1] ‘a’
[08:28:17.738] Resolving futures part of globals (recursively) ... DONE
[08:28:17.749] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[08:28:17.750] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[08:28:17.750] - globals: [1] ‘a’
[08:28:17.750] - packages: [1] ‘future’
[08:28:17.750] getGlobalsAndPackages() ... DONE
[08:28:17.751] run() for ‘Future’ ...
[08:28:17.751] - state: ‘created’
[08:28:17.751] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.765] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.765] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.765]   - Field: ‘node’
[08:28:17.765]   - Field: ‘label’
[08:28:17.765]   - Field: ‘local’
[08:28:17.765]   - Field: ‘owner’
[08:28:17.766]   - Field: ‘envir’
[08:28:17.766]   - Field: ‘workers’
[08:28:17.766]   - Field: ‘packages’
[08:28:17.766]   - Field: ‘gc’
[08:28:17.766]   - Field: ‘conditions’
[08:28:17.766]   - Field: ‘persistent’
[08:28:17.766]   - Field: ‘expr’
[08:28:17.766]   - Field: ‘uuid’
[08:28:17.766]   - Field: ‘seed’
[08:28:17.766]   - Field: ‘version’
[08:28:17.766]   - Field: ‘result’
[08:28:17.767]   - Field: ‘asynchronous’
[08:28:17.767]   - Field: ‘calls’
[08:28:17.767]   - Field: ‘globals’
[08:28:17.767]   - Field: ‘stdout’
[08:28:17.767]   - Field: ‘earlySignal’
[08:28:17.767]   - Field: ‘lazy’
[08:28:17.767]   - Field: ‘state’
[08:28:17.767] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.767] - Launch lazy future ...
[08:28:17.767] Packages needed by the future expression (n = 1): ‘future’
[08:28:17.768] Packages needed by future strategies (n = 0): <none>
[08:28:17.768] {
[08:28:17.768]     {
[08:28:17.768]         {
[08:28:17.768]             ...future.startTime <- base::Sys.time()
[08:28:17.768]             {
[08:28:17.768]                 {
[08:28:17.768]                   {
[08:28:17.768]                     {
[08:28:17.768]                       {
[08:28:17.768]                         base::local({
[08:28:17.768]                           has_future <- base::requireNamespace("future", 
[08:28:17.768]                             quietly = TRUE)
[08:28:17.768]                           if (has_future) {
[08:28:17.768]                             ns <- base::getNamespace("future")
[08:28:17.768]                             version <- ns[[".package"]][["version"]]
[08:28:17.768]                             if (is.null(version)) 
[08:28:17.768]                               version <- utils::packageVersion("future")
[08:28:17.768]                           }
[08:28:17.768]                           else {
[08:28:17.768]                             version <- NULL
[08:28:17.768]                           }
[08:28:17.768]                           if (!has_future || version < "1.8.0") {
[08:28:17.768]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.768]                               "", base::R.version$version.string), 
[08:28:17.768]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:17.768]                                 base::R.version$platform, 8 * 
[08:28:17.768]                                   base::.Machine$sizeof.pointer), 
[08:28:17.768]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.768]                                 "release", "version")], collapse = " "), 
[08:28:17.768]                               hostname = base::Sys.info()[["nodename"]])
[08:28:17.768]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.768]                               info)
[08:28:17.768]                             info <- base::paste(info, collapse = "; ")
[08:28:17.768]                             if (!has_future) {
[08:28:17.768]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.768]                                 info)
[08:28:17.768]                             }
[08:28:17.768]                             else {
[08:28:17.768]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.768]                                 info, version)
[08:28:17.768]                             }
[08:28:17.768]                             base::stop(msg)
[08:28:17.768]                           }
[08:28:17.768]                         })
[08:28:17.768]                       }
[08:28:17.768]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.768]                       base::options(mc.cores = 1L)
[08:28:17.768]                     }
[08:28:17.768]                     base::local({
[08:28:17.768]                       for (pkg in "future") {
[08:28:17.768]                         base::loadNamespace(pkg)
[08:28:17.768]                         base::library(pkg, character.only = TRUE)
[08:28:17.768]                       }
[08:28:17.768]                     })
[08:28:17.768]                   }
[08:28:17.768]                   ...future.strategy.old <- future::plan("list")
[08:28:17.768]                   options(future.plan = NULL)
[08:28:17.768]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.768]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.768]                 }
[08:28:17.768]                 ...future.workdir <- getwd()
[08:28:17.768]             }
[08:28:17.768]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.768]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.768]         }
[08:28:17.768]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.768]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.768]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.768]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.768]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.768]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.768]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.768]             base::names(...future.oldOptions))
[08:28:17.768]     }
[08:28:17.768]     if (FALSE) {
[08:28:17.768]     }
[08:28:17.768]     else {
[08:28:17.768]         if (TRUE) {
[08:28:17.768]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.768]                 open = "w")
[08:28:17.768]         }
[08:28:17.768]         else {
[08:28:17.768]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.768]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.768]         }
[08:28:17.768]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.768]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.768]             base::sink(type = "output", split = FALSE)
[08:28:17.768]             base::close(...future.stdout)
[08:28:17.768]         }, add = TRUE)
[08:28:17.768]     }
[08:28:17.768]     ...future.frame <- base::sys.nframe()
[08:28:17.768]     ...future.conditions <- base::list()
[08:28:17.768]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.768]     if (FALSE) {
[08:28:17.768]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.768]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.768]     }
[08:28:17.768]     ...future.result <- base::tryCatch({
[08:28:17.768]         base::withCallingHandlers({
[08:28:17.768]             ...future.value <- base::withVisible(base::local({
[08:28:17.768]                 ...future.makeSendCondition <- base::local({
[08:28:17.768]                   sendCondition <- NULL
[08:28:17.768]                   function(frame = 1L) {
[08:28:17.768]                     if (is.function(sendCondition)) 
[08:28:17.768]                       return(sendCondition)
[08:28:17.768]                     ns <- getNamespace("parallel")
[08:28:17.768]                     if (exists("sendData", mode = "function", 
[08:28:17.768]                       envir = ns)) {
[08:28:17.768]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.768]                         envir = ns)
[08:28:17.768]                       envir <- sys.frame(frame)
[08:28:17.768]                       master <- NULL
[08:28:17.768]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.768]                         !identical(envir, emptyenv())) {
[08:28:17.768]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.768]                           inherits = FALSE)) {
[08:28:17.768]                           master <- get("master", mode = "list", 
[08:28:17.768]                             envir = envir, inherits = FALSE)
[08:28:17.768]                           if (inherits(master, c("SOCKnode", 
[08:28:17.768]                             "SOCK0node"))) {
[08:28:17.768]                             sendCondition <<- function(cond) {
[08:28:17.768]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.768]                                 success = TRUE)
[08:28:17.768]                               parallel_sendData(master, data)
[08:28:17.768]                             }
[08:28:17.768]                             return(sendCondition)
[08:28:17.768]                           }
[08:28:17.768]                         }
[08:28:17.768]                         frame <- frame + 1L
[08:28:17.768]                         envir <- sys.frame(frame)
[08:28:17.768]                       }
[08:28:17.768]                     }
[08:28:17.768]                     sendCondition <<- function(cond) NULL
[08:28:17.768]                   }
[08:28:17.768]                 })
[08:28:17.768]                 withCallingHandlers({
[08:28:17.768]                   value(a) + 1
[08:28:17.768]                 }, immediateCondition = function(cond) {
[08:28:17.768]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.768]                   sendCondition(cond)
[08:28:17.768]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.768]                   {
[08:28:17.768]                     inherits <- base::inherits
[08:28:17.768]                     invokeRestart <- base::invokeRestart
[08:28:17.768]                     is.null <- base::is.null
[08:28:17.768]                     muffled <- FALSE
[08:28:17.768]                     if (inherits(cond, "message")) {
[08:28:17.768]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.768]                       if (muffled) 
[08:28:17.768]                         invokeRestart("muffleMessage")
[08:28:17.768]                     }
[08:28:17.768]                     else if (inherits(cond, "warning")) {
[08:28:17.768]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.768]                       if (muffled) 
[08:28:17.768]                         invokeRestart("muffleWarning")
[08:28:17.768]                     }
[08:28:17.768]                     else if (inherits(cond, "condition")) {
[08:28:17.768]                       if (!is.null(pattern)) {
[08:28:17.768]                         computeRestarts <- base::computeRestarts
[08:28:17.768]                         grepl <- base::grepl
[08:28:17.768]                         restarts <- computeRestarts(cond)
[08:28:17.768]                         for (restart in restarts) {
[08:28:17.768]                           name <- restart$name
[08:28:17.768]                           if (is.null(name)) 
[08:28:17.768]                             next
[08:28:17.768]                           if (!grepl(pattern, name)) 
[08:28:17.768]                             next
[08:28:17.768]                           invokeRestart(restart)
[08:28:17.768]                           muffled <- TRUE
[08:28:17.768]                           break
[08:28:17.768]                         }
[08:28:17.768]                       }
[08:28:17.768]                     }
[08:28:17.768]                     invisible(muffled)
[08:28:17.768]                   }
[08:28:17.768]                   muffleCondition(cond)
[08:28:17.768]                 })
[08:28:17.768]             }))
[08:28:17.768]             future::FutureResult(value = ...future.value$value, 
[08:28:17.768]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.768]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.768]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.768]                     ...future.globalenv.names))
[08:28:17.768]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.768]         }, condition = base::local({
[08:28:17.768]             c <- base::c
[08:28:17.768]             inherits <- base::inherits
[08:28:17.768]             invokeRestart <- base::invokeRestart
[08:28:17.768]             length <- base::length
[08:28:17.768]             list <- base::list
[08:28:17.768]             seq.int <- base::seq.int
[08:28:17.768]             signalCondition <- base::signalCondition
[08:28:17.768]             sys.calls <- base::sys.calls
[08:28:17.768]             `[[` <- base::`[[`
[08:28:17.768]             `+` <- base::`+`
[08:28:17.768]             `<<-` <- base::`<<-`
[08:28:17.768]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.768]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.768]                   3L)]
[08:28:17.768]             }
[08:28:17.768]             function(cond) {
[08:28:17.768]                 is_error <- inherits(cond, "error")
[08:28:17.768]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.768]                   NULL)
[08:28:17.768]                 if (is_error) {
[08:28:17.768]                   sessionInformation <- function() {
[08:28:17.768]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.768]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.768]                       search = base::search(), system = base::Sys.info())
[08:28:17.768]                   }
[08:28:17.768]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.768]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.768]                     cond$call), session = sessionInformation(), 
[08:28:17.768]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.768]                   signalCondition(cond)
[08:28:17.768]                 }
[08:28:17.768]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.768]                 "immediateCondition"))) {
[08:28:17.768]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.768]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.768]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.768]                   if (TRUE && !signal) {
[08:28:17.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.768]                     {
[08:28:17.768]                       inherits <- base::inherits
[08:28:17.768]                       invokeRestart <- base::invokeRestart
[08:28:17.768]                       is.null <- base::is.null
[08:28:17.768]                       muffled <- FALSE
[08:28:17.768]                       if (inherits(cond, "message")) {
[08:28:17.768]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.768]                         if (muffled) 
[08:28:17.768]                           invokeRestart("muffleMessage")
[08:28:17.768]                       }
[08:28:17.768]                       else if (inherits(cond, "warning")) {
[08:28:17.768]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.768]                         if (muffled) 
[08:28:17.768]                           invokeRestart("muffleWarning")
[08:28:17.768]                       }
[08:28:17.768]                       else if (inherits(cond, "condition")) {
[08:28:17.768]                         if (!is.null(pattern)) {
[08:28:17.768]                           computeRestarts <- base::computeRestarts
[08:28:17.768]                           grepl <- base::grepl
[08:28:17.768]                           restarts <- computeRestarts(cond)
[08:28:17.768]                           for (restart in restarts) {
[08:28:17.768]                             name <- restart$name
[08:28:17.768]                             if (is.null(name)) 
[08:28:17.768]                               next
[08:28:17.768]                             if (!grepl(pattern, name)) 
[08:28:17.768]                               next
[08:28:17.768]                             invokeRestart(restart)
[08:28:17.768]                             muffled <- TRUE
[08:28:17.768]                             break
[08:28:17.768]                           }
[08:28:17.768]                         }
[08:28:17.768]                       }
[08:28:17.768]                       invisible(muffled)
[08:28:17.768]                     }
[08:28:17.768]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.768]                   }
[08:28:17.768]                 }
[08:28:17.768]                 else {
[08:28:17.768]                   if (TRUE) {
[08:28:17.768]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.768]                     {
[08:28:17.768]                       inherits <- base::inherits
[08:28:17.768]                       invokeRestart <- base::invokeRestart
[08:28:17.768]                       is.null <- base::is.null
[08:28:17.768]                       muffled <- FALSE
[08:28:17.768]                       if (inherits(cond, "message")) {
[08:28:17.768]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.768]                         if (muffled) 
[08:28:17.768]                           invokeRestart("muffleMessage")
[08:28:17.768]                       }
[08:28:17.768]                       else if (inherits(cond, "warning")) {
[08:28:17.768]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.768]                         if (muffled) 
[08:28:17.768]                           invokeRestart("muffleWarning")
[08:28:17.768]                       }
[08:28:17.768]                       else if (inherits(cond, "condition")) {
[08:28:17.768]                         if (!is.null(pattern)) {
[08:28:17.768]                           computeRestarts <- base::computeRestarts
[08:28:17.768]                           grepl <- base::grepl
[08:28:17.768]                           restarts <- computeRestarts(cond)
[08:28:17.768]                           for (restart in restarts) {
[08:28:17.768]                             name <- restart$name
[08:28:17.768]                             if (is.null(name)) 
[08:28:17.768]                               next
[08:28:17.768]                             if (!grepl(pattern, name)) 
[08:28:17.768]                               next
[08:28:17.768]                             invokeRestart(restart)
[08:28:17.768]                             muffled <- TRUE
[08:28:17.768]                             break
[08:28:17.768]                           }
[08:28:17.768]                         }
[08:28:17.768]                       }
[08:28:17.768]                       invisible(muffled)
[08:28:17.768]                     }
[08:28:17.768]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.768]                   }
[08:28:17.768]                 }
[08:28:17.768]             }
[08:28:17.768]         }))
[08:28:17.768]     }, error = function(ex) {
[08:28:17.768]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.768]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.768]                 ...future.rng), started = ...future.startTime, 
[08:28:17.768]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.768]             version = "1.8"), class = "FutureResult")
[08:28:17.768]     }, finally = {
[08:28:17.768]         if (!identical(...future.workdir, getwd())) 
[08:28:17.768]             setwd(...future.workdir)
[08:28:17.768]         {
[08:28:17.768]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.768]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.768]             }
[08:28:17.768]             base::options(...future.oldOptions)
[08:28:17.768]             if (.Platform$OS.type == "windows") {
[08:28:17.768]                 old_names <- names(...future.oldEnvVars)
[08:28:17.768]                 envs <- base::Sys.getenv()
[08:28:17.768]                 names <- names(envs)
[08:28:17.768]                 common <- intersect(names, old_names)
[08:28:17.768]                 added <- setdiff(names, old_names)
[08:28:17.768]                 removed <- setdiff(old_names, names)
[08:28:17.768]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.768]                   envs[common]]
[08:28:17.768]                 NAMES <- toupper(changed)
[08:28:17.768]                 args <- list()
[08:28:17.768]                 for (kk in seq_along(NAMES)) {
[08:28:17.768]                   name <- changed[[kk]]
[08:28:17.768]                   NAME <- NAMES[[kk]]
[08:28:17.768]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.768]                     next
[08:28:17.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.768]                 }
[08:28:17.768]                 NAMES <- toupper(added)
[08:28:17.768]                 for (kk in seq_along(NAMES)) {
[08:28:17.768]                   name <- added[[kk]]
[08:28:17.768]                   NAME <- NAMES[[kk]]
[08:28:17.768]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.768]                     next
[08:28:17.768]                   args[[name]] <- ""
[08:28:17.768]                 }
[08:28:17.768]                 NAMES <- toupper(removed)
[08:28:17.768]                 for (kk in seq_along(NAMES)) {
[08:28:17.768]                   name <- removed[[kk]]
[08:28:17.768]                   NAME <- NAMES[[kk]]
[08:28:17.768]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.768]                     next
[08:28:17.768]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.768]                 }
[08:28:17.768]                 if (length(args) > 0) 
[08:28:17.768]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.768]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.768]             }
[08:28:17.768]             else {
[08:28:17.768]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.768]             }
[08:28:17.768]             {
[08:28:17.768]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.768]                   0L) {
[08:28:17.768]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.768]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.768]                   base::options(opts)
[08:28:17.768]                 }
[08:28:17.768]                 {
[08:28:17.768]                   {
[08:28:17.768]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.768]                     NULL
[08:28:17.768]                   }
[08:28:17.768]                   options(future.plan = NULL)
[08:28:17.768]                   if (is.na(NA_character_)) 
[08:28:17.768]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.768]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.768]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.768]                     .init = FALSE)
[08:28:17.768]                 }
[08:28:17.768]             }
[08:28:17.768]         }
[08:28:17.768]     })
[08:28:17.768]     if (TRUE) {
[08:28:17.768]         base::sink(type = "output", split = FALSE)
[08:28:17.768]         if (TRUE) {
[08:28:17.768]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.768]         }
[08:28:17.768]         else {
[08:28:17.768]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.768]         }
[08:28:17.768]         base::close(...future.stdout)
[08:28:17.768]         ...future.stdout <- NULL
[08:28:17.768]     }
[08:28:17.768]     ...future.result$conditions <- ...future.conditions
[08:28:17.768]     ...future.result$finished <- base::Sys.time()
[08:28:17.768]     ...future.result
[08:28:17.768] }
[08:28:17.782] Exporting 1 global objects (313.46 KiB) to cluster node #2 ...
[08:28:17.793] Exporting ‘a’ (313.25 KiB) to cluster node #2 ...
[08:28:17.846] Exporting ‘a’ (313.25 KiB) to cluster node #2 ... DONE
[08:28:17.846] Exporting 1 global objects (313.46 KiB) to cluster node #2 ... DONE
[08:28:17.847] MultisessionFuture started
[08:28:17.847] - Launch lazy future ... done
[08:28:17.847] run() for ‘MultisessionFuture’ ... done
[08:28:17.847] result() for ClusterFuture ...
[08:28:17.847] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.847] - Validating connection of MultisessionFuture
[08:28:17.889] - received message: FutureResult
[08:28:17.890] - Received FutureResult
[08:28:17.890] - Erased future from FutureRegistry
[08:28:17.890] result() for ClusterFuture ...
[08:28:17.890] - result already collected: FutureResult
[08:28:17.890] result() for ClusterFuture ... done
[08:28:17.890] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.890] result() for ClusterFuture ... done
[08:28:17.891] result() for ClusterFuture ...
[08:28:17.891] - result already collected: FutureResult
[08:28:17.891] result() for ClusterFuture ... done
value(b) = 2
[08:28:17.891] result() for ClusterFuture ...
[08:28:17.891] - result already collected: FutureResult
[08:28:17.891] result() for ClusterFuture ... done
[08:28:17.891] result() for ClusterFuture ...
[08:28:17.891] - result already collected: FutureResult
[08:28:17.891] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.892] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.892] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[08:28:17.893] - globals found: [2] ‘{’, ‘pkg’
[08:28:17.893] Searching for globals ... DONE
[08:28:17.893] Resolving globals: TRUE
[08:28:17.893] Resolving any globals that are futures ...
[08:28:17.893] - globals: [2] ‘{’, ‘pkg’
[08:28:17.893] Resolving any globals that are futures ... DONE
[08:28:17.894] Resolving futures part of globals (recursively) ...
[08:28:17.894] resolve() on list ...
[08:28:17.894]  recursive: 99
[08:28:17.894]  length: 1
[08:28:17.894]  elements: ‘pkg’
[08:28:17.897]  length: 0 (resolved future 1)
[08:28:17.897] resolve() on list ... DONE
[08:28:17.897] - globals: [1] ‘pkg’
[08:28:17.897] Resolving futures part of globals (recursively) ... DONE
[08:28:17.897] The total size of the 1 globals is 42 bytes (42 bytes)
[08:28:17.898] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[08:28:17.898] - globals: [1] ‘pkg’
[08:28:17.898] 
[08:28:17.898] getGlobalsAndPackages() ... DONE
[08:28:17.898] Packages needed by the future expression (n = 0): <none>
[08:28:17.898] Packages needed by future strategies (n = 0): <none>
[08:28:17.899] {
[08:28:17.899]     {
[08:28:17.899]         {
[08:28:17.899]             ...future.startTime <- base::Sys.time()
[08:28:17.899]             {
[08:28:17.899]                 {
[08:28:17.899]                   {
[08:28:17.899]                     base::local({
[08:28:17.899]                       has_future <- base::requireNamespace("future", 
[08:28:17.899]                         quietly = TRUE)
[08:28:17.899]                       if (has_future) {
[08:28:17.899]                         ns <- base::getNamespace("future")
[08:28:17.899]                         version <- ns[[".package"]][["version"]]
[08:28:17.899]                         if (is.null(version)) 
[08:28:17.899]                           version <- utils::packageVersion("future")
[08:28:17.899]                       }
[08:28:17.899]                       else {
[08:28:17.899]                         version <- NULL
[08:28:17.899]                       }
[08:28:17.899]                       if (!has_future || version < "1.8.0") {
[08:28:17.899]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.899]                           "", base::R.version$version.string), 
[08:28:17.899]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:17.899]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:17.899]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.899]                             "release", "version")], collapse = " "), 
[08:28:17.899]                           hostname = base::Sys.info()[["nodename"]])
[08:28:17.899]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.899]                           info)
[08:28:17.899]                         info <- base::paste(info, collapse = "; ")
[08:28:17.899]                         if (!has_future) {
[08:28:17.899]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.899]                             info)
[08:28:17.899]                         }
[08:28:17.899]                         else {
[08:28:17.899]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.899]                             info, version)
[08:28:17.899]                         }
[08:28:17.899]                         base::stop(msg)
[08:28:17.899]                       }
[08:28:17.899]                     })
[08:28:17.899]                   }
[08:28:17.899]                   ...future.strategy.old <- future::plan("list")
[08:28:17.899]                   options(future.plan = NULL)
[08:28:17.899]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.899]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.899]                 }
[08:28:17.899]                 ...future.workdir <- getwd()
[08:28:17.899]             }
[08:28:17.899]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.899]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.899]         }
[08:28:17.899]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.899]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[08:28:17.899]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.899]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.899]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.899]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.899]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.899]             base::names(...future.oldOptions))
[08:28:17.899]     }
[08:28:17.899]     if (FALSE) {
[08:28:17.899]     }
[08:28:17.899]     else {
[08:28:17.899]         if (TRUE) {
[08:28:17.899]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.899]                 open = "w")
[08:28:17.899]         }
[08:28:17.899]         else {
[08:28:17.899]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.899]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.899]         }
[08:28:17.899]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.899]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.899]             base::sink(type = "output", split = FALSE)
[08:28:17.899]             base::close(...future.stdout)
[08:28:17.899]         }, add = TRUE)
[08:28:17.899]     }
[08:28:17.899]     ...future.frame <- base::sys.nframe()
[08:28:17.899]     ...future.conditions <- base::list()
[08:28:17.899]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.899]     if (FALSE) {
[08:28:17.899]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.899]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.899]     }
[08:28:17.899]     ...future.result <- base::tryCatch({
[08:28:17.899]         base::withCallingHandlers({
[08:28:17.899]             ...future.value <- base::withVisible(base::local({
[08:28:17.899]                 pkg
[08:28:17.899]             }))
[08:28:17.899]             future::FutureResult(value = ...future.value$value, 
[08:28:17.899]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.899]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.899]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.899]                     ...future.globalenv.names))
[08:28:17.899]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.899]         }, condition = base::local({
[08:28:17.899]             c <- base::c
[08:28:17.899]             inherits <- base::inherits
[08:28:17.899]             invokeRestart <- base::invokeRestart
[08:28:17.899]             length <- base::length
[08:28:17.899]             list <- base::list
[08:28:17.899]             seq.int <- base::seq.int
[08:28:17.899]             signalCondition <- base::signalCondition
[08:28:17.899]             sys.calls <- base::sys.calls
[08:28:17.899]             `[[` <- base::`[[`
[08:28:17.899]             `+` <- base::`+`
[08:28:17.899]             `<<-` <- base::`<<-`
[08:28:17.899]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.899]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.899]                   3L)]
[08:28:17.899]             }
[08:28:17.899]             function(cond) {
[08:28:17.899]                 is_error <- inherits(cond, "error")
[08:28:17.899]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.899]                   NULL)
[08:28:17.899]                 if (is_error) {
[08:28:17.899]                   sessionInformation <- function() {
[08:28:17.899]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.899]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.899]                       search = base::search(), system = base::Sys.info())
[08:28:17.899]                   }
[08:28:17.899]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.899]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.899]                     cond$call), session = sessionInformation(), 
[08:28:17.899]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.899]                   signalCondition(cond)
[08:28:17.899]                 }
[08:28:17.899]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.899]                 "immediateCondition"))) {
[08:28:17.899]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.899]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.899]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.899]                   if (TRUE && !signal) {
[08:28:17.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.899]                     {
[08:28:17.899]                       inherits <- base::inherits
[08:28:17.899]                       invokeRestart <- base::invokeRestart
[08:28:17.899]                       is.null <- base::is.null
[08:28:17.899]                       muffled <- FALSE
[08:28:17.899]                       if (inherits(cond, "message")) {
[08:28:17.899]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.899]                         if (muffled) 
[08:28:17.899]                           invokeRestart("muffleMessage")
[08:28:17.899]                       }
[08:28:17.899]                       else if (inherits(cond, "warning")) {
[08:28:17.899]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.899]                         if (muffled) 
[08:28:17.899]                           invokeRestart("muffleWarning")
[08:28:17.899]                       }
[08:28:17.899]                       else if (inherits(cond, "condition")) {
[08:28:17.899]                         if (!is.null(pattern)) {
[08:28:17.899]                           computeRestarts <- base::computeRestarts
[08:28:17.899]                           grepl <- base::grepl
[08:28:17.899]                           restarts <- computeRestarts(cond)
[08:28:17.899]                           for (restart in restarts) {
[08:28:17.899]                             name <- restart$name
[08:28:17.899]                             if (is.null(name)) 
[08:28:17.899]                               next
[08:28:17.899]                             if (!grepl(pattern, name)) 
[08:28:17.899]                               next
[08:28:17.899]                             invokeRestart(restart)
[08:28:17.899]                             muffled <- TRUE
[08:28:17.899]                             break
[08:28:17.899]                           }
[08:28:17.899]                         }
[08:28:17.899]                       }
[08:28:17.899]                       invisible(muffled)
[08:28:17.899]                     }
[08:28:17.899]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.899]                   }
[08:28:17.899]                 }
[08:28:17.899]                 else {
[08:28:17.899]                   if (TRUE) {
[08:28:17.899]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.899]                     {
[08:28:17.899]                       inherits <- base::inherits
[08:28:17.899]                       invokeRestart <- base::invokeRestart
[08:28:17.899]                       is.null <- base::is.null
[08:28:17.899]                       muffled <- FALSE
[08:28:17.899]                       if (inherits(cond, "message")) {
[08:28:17.899]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.899]                         if (muffled) 
[08:28:17.899]                           invokeRestart("muffleMessage")
[08:28:17.899]                       }
[08:28:17.899]                       else if (inherits(cond, "warning")) {
[08:28:17.899]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.899]                         if (muffled) 
[08:28:17.899]                           invokeRestart("muffleWarning")
[08:28:17.899]                       }
[08:28:17.899]                       else if (inherits(cond, "condition")) {
[08:28:17.899]                         if (!is.null(pattern)) {
[08:28:17.899]                           computeRestarts <- base::computeRestarts
[08:28:17.899]                           grepl <- base::grepl
[08:28:17.899]                           restarts <- computeRestarts(cond)
[08:28:17.899]                           for (restart in restarts) {
[08:28:17.899]                             name <- restart$name
[08:28:17.899]                             if (is.null(name)) 
[08:28:17.899]                               next
[08:28:17.899]                             if (!grepl(pattern, name)) 
[08:28:17.899]                               next
[08:28:17.899]                             invokeRestart(restart)
[08:28:17.899]                             muffled <- TRUE
[08:28:17.899]                             break
[08:28:17.899]                           }
[08:28:17.899]                         }
[08:28:17.899]                       }
[08:28:17.899]                       invisible(muffled)
[08:28:17.899]                     }
[08:28:17.899]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.899]                   }
[08:28:17.899]                 }
[08:28:17.899]             }
[08:28:17.899]         }))
[08:28:17.899]     }, error = function(ex) {
[08:28:17.899]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.899]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.899]                 ...future.rng), started = ...future.startTime, 
[08:28:17.899]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.899]             version = "1.8"), class = "FutureResult")
[08:28:17.899]     }, finally = {
[08:28:17.899]         if (!identical(...future.workdir, getwd())) 
[08:28:17.899]             setwd(...future.workdir)
[08:28:17.899]         {
[08:28:17.899]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.899]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.899]             }
[08:28:17.899]             base::options(...future.oldOptions)
[08:28:17.899]             if (.Platform$OS.type == "windows") {
[08:28:17.899]                 old_names <- names(...future.oldEnvVars)
[08:28:17.899]                 envs <- base::Sys.getenv()
[08:28:17.899]                 names <- names(envs)
[08:28:17.899]                 common <- intersect(names, old_names)
[08:28:17.899]                 added <- setdiff(names, old_names)
[08:28:17.899]                 removed <- setdiff(old_names, names)
[08:28:17.899]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.899]                   envs[common]]
[08:28:17.899]                 NAMES <- toupper(changed)
[08:28:17.899]                 args <- list()
[08:28:17.899]                 for (kk in seq_along(NAMES)) {
[08:28:17.899]                   name <- changed[[kk]]
[08:28:17.899]                   NAME <- NAMES[[kk]]
[08:28:17.899]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.899]                     next
[08:28:17.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.899]                 }
[08:28:17.899]                 NAMES <- toupper(added)
[08:28:17.899]                 for (kk in seq_along(NAMES)) {
[08:28:17.899]                   name <- added[[kk]]
[08:28:17.899]                   NAME <- NAMES[[kk]]
[08:28:17.899]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.899]                     next
[08:28:17.899]                   args[[name]] <- ""
[08:28:17.899]                 }
[08:28:17.899]                 NAMES <- toupper(removed)
[08:28:17.899]                 for (kk in seq_along(NAMES)) {
[08:28:17.899]                   name <- removed[[kk]]
[08:28:17.899]                   NAME <- NAMES[[kk]]
[08:28:17.899]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.899]                     next
[08:28:17.899]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.899]                 }
[08:28:17.899]                 if (length(args) > 0) 
[08:28:17.899]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.899]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.899]             }
[08:28:17.899]             else {
[08:28:17.899]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.899]             }
[08:28:17.899]             {
[08:28:17.899]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.899]                   0L) {
[08:28:17.899]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.899]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.899]                   base::options(opts)
[08:28:17.899]                 }
[08:28:17.899]                 {
[08:28:17.899]                   {
[08:28:17.899]                     NULL
[08:28:17.899]                     RNGkind("Mersenne-Twister")
[08:28:17.899]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:17.899]                       inherits = FALSE)
[08:28:17.899]                   }
[08:28:17.899]                   options(future.plan = NULL)
[08:28:17.899]                   if (is.na(NA_character_)) 
[08:28:17.899]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.899]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.899]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.899]                     .init = FALSE)
[08:28:17.899]                 }
[08:28:17.899]             }
[08:28:17.899]         }
[08:28:17.899]     })
[08:28:17.899]     if (TRUE) {
[08:28:17.899]         base::sink(type = "output", split = FALSE)
[08:28:17.899]         if (TRUE) {
[08:28:17.899]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.899]         }
[08:28:17.899]         else {
[08:28:17.899]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.899]         }
[08:28:17.899]         base::close(...future.stdout)
[08:28:17.899]         ...future.stdout <- NULL
[08:28:17.899]     }
[08:28:17.899]     ...future.result$conditions <- ...future.conditions
[08:28:17.899]     ...future.result$finished <- base::Sys.time()
[08:28:17.899]     ...future.result
[08:28:17.899] }
[08:28:17.901] assign_globals() ...
[08:28:17.901] List of 1
[08:28:17.901]  $ pkg: chr "foo"
[08:28:17.901]  - attr(*, "where")=List of 1
[08:28:17.901]   ..$ pkg:<environment: R_EmptyEnv> 
[08:28:17.901]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:17.901]  - attr(*, "resolved")= logi TRUE
[08:28:17.901]  - attr(*, "total_size")= num 42
[08:28:17.903] - copied ‘pkg’ to environment
[08:28:17.903] assign_globals() ... done
[08:28:17.903] plan(): Setting new future strategy stack:
[08:28:17.903] List of future strategies:
[08:28:17.903] 1. sequential:
[08:28:17.903]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:17.903]    - tweaked: FALSE
[08:28:17.903]    - call: NULL
[08:28:17.904] plan(): nbrOfWorkers() = 1
[08:28:17.904] plan(): Setting new future strategy stack:
[08:28:17.905] List of future strategies:
[08:28:17.905] 1. multisession:
[08:28:17.905]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:17.905]    - tweaked: FALSE
[08:28:17.905]    - call: plan(strategy)
[08:28:17.906] plan(): nbrOfWorkers() = 2
[08:28:17.906] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.907] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.907] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:17.909] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:17.909] Searching for globals ... DONE
[08:28:17.909] Resolving globals: TRUE
[08:28:17.909] Resolving any globals that are futures ...
[08:28:17.909] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:17.909] Resolving any globals that are futures ... DONE
[08:28:17.910] Resolving futures part of globals (recursively) ...
[08:28:17.910] resolve() on list ...
[08:28:17.910]  recursive: 99
[08:28:17.910]  length: 1
[08:28:17.910]  elements: ‘a’
[08:28:17.910]  length: 0 (resolved future 1)
[08:28:17.910] resolve() on list ... DONE
[08:28:17.911] - globals: [1] ‘a’
[08:28:17.911] Resolving futures part of globals (recursively) ... DONE
[08:28:17.911] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:17.911] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:17.911] - globals: [1] ‘a’
[08:28:17.911] 
[08:28:17.911] getGlobalsAndPackages() ... DONE
[08:28:17.912] run() for ‘Future’ ...
[08:28:17.912] - state: ‘created’
[08:28:17.912] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.928] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.928] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.928]   - Field: ‘node’
[08:28:17.928]   - Field: ‘label’
[08:28:17.928]   - Field: ‘local’
[08:28:17.928]   - Field: ‘owner’
[08:28:17.928]   - Field: ‘envir’
[08:28:17.928]   - Field: ‘workers’
[08:28:17.928]   - Field: ‘packages’
[08:28:17.928]   - Field: ‘gc’
[08:28:17.928]   - Field: ‘conditions’
[08:28:17.929]   - Field: ‘persistent’
[08:28:17.929]   - Field: ‘expr’
[08:28:17.929]   - Field: ‘uuid’
[08:28:17.929]   - Field: ‘seed’
[08:28:17.929]   - Field: ‘version’
[08:28:17.929]   - Field: ‘result’
[08:28:17.929]   - Field: ‘asynchronous’
[08:28:17.929]   - Field: ‘calls’
[08:28:17.929]   - Field: ‘globals’
[08:28:17.929]   - Field: ‘stdout’
[08:28:17.929]   - Field: ‘earlySignal’
[08:28:17.930]   - Field: ‘lazy’
[08:28:17.930]   - Field: ‘state’
[08:28:17.930] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:17.930] - Launch lazy future ...
[08:28:17.930] Packages needed by the future expression (n = 0): <none>
[08:28:17.930] Packages needed by future strategies (n = 0): <none>
[08:28:17.931] {
[08:28:17.931]     {
[08:28:17.931]         {
[08:28:17.931]             ...future.startTime <- base::Sys.time()
[08:28:17.931]             {
[08:28:17.931]                 {
[08:28:17.931]                   {
[08:28:17.931]                     {
[08:28:17.931]                       base::local({
[08:28:17.931]                         has_future <- base::requireNamespace("future", 
[08:28:17.931]                           quietly = TRUE)
[08:28:17.931]                         if (has_future) {
[08:28:17.931]                           ns <- base::getNamespace("future")
[08:28:17.931]                           version <- ns[[".package"]][["version"]]
[08:28:17.931]                           if (is.null(version)) 
[08:28:17.931]                             version <- utils::packageVersion("future")
[08:28:17.931]                         }
[08:28:17.931]                         else {
[08:28:17.931]                           version <- NULL
[08:28:17.931]                         }
[08:28:17.931]                         if (!has_future || version < "1.8.0") {
[08:28:17.931]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:17.931]                             "", base::R.version$version.string), 
[08:28:17.931]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:17.931]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:17.931]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:17.931]                               "release", "version")], collapse = " "), 
[08:28:17.931]                             hostname = base::Sys.info()[["nodename"]])
[08:28:17.931]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:17.931]                             info)
[08:28:17.931]                           info <- base::paste(info, collapse = "; ")
[08:28:17.931]                           if (!has_future) {
[08:28:17.931]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:17.931]                               info)
[08:28:17.931]                           }
[08:28:17.931]                           else {
[08:28:17.931]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:17.931]                               info, version)
[08:28:17.931]                           }
[08:28:17.931]                           base::stop(msg)
[08:28:17.931]                         }
[08:28:17.931]                       })
[08:28:17.931]                     }
[08:28:17.931]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:17.931]                     base::options(mc.cores = 1L)
[08:28:17.931]                   }
[08:28:17.931]                   ...future.strategy.old <- future::plan("list")
[08:28:17.931]                   options(future.plan = NULL)
[08:28:17.931]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.931]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:17.931]                 }
[08:28:17.931]                 ...future.workdir <- getwd()
[08:28:17.931]             }
[08:28:17.931]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:17.931]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:17.931]         }
[08:28:17.931]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:17.931]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:17.931]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:17.931]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:17.931]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:17.931]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:17.931]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:17.931]             base::names(...future.oldOptions))
[08:28:17.931]     }
[08:28:17.931]     if (FALSE) {
[08:28:17.931]     }
[08:28:17.931]     else {
[08:28:17.931]         if (TRUE) {
[08:28:17.931]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:17.931]                 open = "w")
[08:28:17.931]         }
[08:28:17.931]         else {
[08:28:17.931]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:17.931]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:17.931]         }
[08:28:17.931]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:17.931]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:17.931]             base::sink(type = "output", split = FALSE)
[08:28:17.931]             base::close(...future.stdout)
[08:28:17.931]         }, add = TRUE)
[08:28:17.931]     }
[08:28:17.931]     ...future.frame <- base::sys.nframe()
[08:28:17.931]     ...future.conditions <- base::list()
[08:28:17.931]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:17.931]     if (FALSE) {
[08:28:17.931]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:17.931]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:17.931]     }
[08:28:17.931]     ...future.result <- base::tryCatch({
[08:28:17.931]         base::withCallingHandlers({
[08:28:17.931]             ...future.value <- base::withVisible(base::local({
[08:28:17.931]                 ...future.makeSendCondition <- base::local({
[08:28:17.931]                   sendCondition <- NULL
[08:28:17.931]                   function(frame = 1L) {
[08:28:17.931]                     if (is.function(sendCondition)) 
[08:28:17.931]                       return(sendCondition)
[08:28:17.931]                     ns <- getNamespace("parallel")
[08:28:17.931]                     if (exists("sendData", mode = "function", 
[08:28:17.931]                       envir = ns)) {
[08:28:17.931]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:17.931]                         envir = ns)
[08:28:17.931]                       envir <- sys.frame(frame)
[08:28:17.931]                       master <- NULL
[08:28:17.931]                       while (!identical(envir, .GlobalEnv) && 
[08:28:17.931]                         !identical(envir, emptyenv())) {
[08:28:17.931]                         if (exists("master", mode = "list", envir = envir, 
[08:28:17.931]                           inherits = FALSE)) {
[08:28:17.931]                           master <- get("master", mode = "list", 
[08:28:17.931]                             envir = envir, inherits = FALSE)
[08:28:17.931]                           if (inherits(master, c("SOCKnode", 
[08:28:17.931]                             "SOCK0node"))) {
[08:28:17.931]                             sendCondition <<- function(cond) {
[08:28:17.931]                               data <- list(type = "VALUE", value = cond, 
[08:28:17.931]                                 success = TRUE)
[08:28:17.931]                               parallel_sendData(master, data)
[08:28:17.931]                             }
[08:28:17.931]                             return(sendCondition)
[08:28:17.931]                           }
[08:28:17.931]                         }
[08:28:17.931]                         frame <- frame + 1L
[08:28:17.931]                         envir <- sys.frame(frame)
[08:28:17.931]                       }
[08:28:17.931]                     }
[08:28:17.931]                     sendCondition <<- function(cond) NULL
[08:28:17.931]                   }
[08:28:17.931]                 })
[08:28:17.931]                 withCallingHandlers({
[08:28:17.931]                   {
[08:28:17.931]                     b <- a
[08:28:17.931]                     a <- 2
[08:28:17.931]                     a * b
[08:28:17.931]                   }
[08:28:17.931]                 }, immediateCondition = function(cond) {
[08:28:17.931]                   sendCondition <- ...future.makeSendCondition()
[08:28:17.931]                   sendCondition(cond)
[08:28:17.931]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.931]                   {
[08:28:17.931]                     inherits <- base::inherits
[08:28:17.931]                     invokeRestart <- base::invokeRestart
[08:28:17.931]                     is.null <- base::is.null
[08:28:17.931]                     muffled <- FALSE
[08:28:17.931]                     if (inherits(cond, "message")) {
[08:28:17.931]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:17.931]                       if (muffled) 
[08:28:17.931]                         invokeRestart("muffleMessage")
[08:28:17.931]                     }
[08:28:17.931]                     else if (inherits(cond, "warning")) {
[08:28:17.931]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:17.931]                       if (muffled) 
[08:28:17.931]                         invokeRestart("muffleWarning")
[08:28:17.931]                     }
[08:28:17.931]                     else if (inherits(cond, "condition")) {
[08:28:17.931]                       if (!is.null(pattern)) {
[08:28:17.931]                         computeRestarts <- base::computeRestarts
[08:28:17.931]                         grepl <- base::grepl
[08:28:17.931]                         restarts <- computeRestarts(cond)
[08:28:17.931]                         for (restart in restarts) {
[08:28:17.931]                           name <- restart$name
[08:28:17.931]                           if (is.null(name)) 
[08:28:17.931]                             next
[08:28:17.931]                           if (!grepl(pattern, name)) 
[08:28:17.931]                             next
[08:28:17.931]                           invokeRestart(restart)
[08:28:17.931]                           muffled <- TRUE
[08:28:17.931]                           break
[08:28:17.931]                         }
[08:28:17.931]                       }
[08:28:17.931]                     }
[08:28:17.931]                     invisible(muffled)
[08:28:17.931]                   }
[08:28:17.931]                   muffleCondition(cond)
[08:28:17.931]                 })
[08:28:17.931]             }))
[08:28:17.931]             future::FutureResult(value = ...future.value$value, 
[08:28:17.931]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.931]                   ...future.rng), globalenv = if (FALSE) 
[08:28:17.931]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:17.931]                     ...future.globalenv.names))
[08:28:17.931]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:17.931]         }, condition = base::local({
[08:28:17.931]             c <- base::c
[08:28:17.931]             inherits <- base::inherits
[08:28:17.931]             invokeRestart <- base::invokeRestart
[08:28:17.931]             length <- base::length
[08:28:17.931]             list <- base::list
[08:28:17.931]             seq.int <- base::seq.int
[08:28:17.931]             signalCondition <- base::signalCondition
[08:28:17.931]             sys.calls <- base::sys.calls
[08:28:17.931]             `[[` <- base::`[[`
[08:28:17.931]             `+` <- base::`+`
[08:28:17.931]             `<<-` <- base::`<<-`
[08:28:17.931]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:17.931]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:17.931]                   3L)]
[08:28:17.931]             }
[08:28:17.931]             function(cond) {
[08:28:17.931]                 is_error <- inherits(cond, "error")
[08:28:17.931]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:17.931]                   NULL)
[08:28:17.931]                 if (is_error) {
[08:28:17.931]                   sessionInformation <- function() {
[08:28:17.931]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:17.931]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:17.931]                       search = base::search(), system = base::Sys.info())
[08:28:17.931]                   }
[08:28:17.931]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.931]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:17.931]                     cond$call), session = sessionInformation(), 
[08:28:17.931]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:17.931]                   signalCondition(cond)
[08:28:17.931]                 }
[08:28:17.931]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:17.931]                 "immediateCondition"))) {
[08:28:17.931]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:17.931]                   ...future.conditions[[length(...future.conditions) + 
[08:28:17.931]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:17.931]                   if (TRUE && !signal) {
[08:28:17.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.931]                     {
[08:28:17.931]                       inherits <- base::inherits
[08:28:17.931]                       invokeRestart <- base::invokeRestart
[08:28:17.931]                       is.null <- base::is.null
[08:28:17.931]                       muffled <- FALSE
[08:28:17.931]                       if (inherits(cond, "message")) {
[08:28:17.931]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.931]                         if (muffled) 
[08:28:17.931]                           invokeRestart("muffleMessage")
[08:28:17.931]                       }
[08:28:17.931]                       else if (inherits(cond, "warning")) {
[08:28:17.931]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.931]                         if (muffled) 
[08:28:17.931]                           invokeRestart("muffleWarning")
[08:28:17.931]                       }
[08:28:17.931]                       else if (inherits(cond, "condition")) {
[08:28:17.931]                         if (!is.null(pattern)) {
[08:28:17.931]                           computeRestarts <- base::computeRestarts
[08:28:17.931]                           grepl <- base::grepl
[08:28:17.931]                           restarts <- computeRestarts(cond)
[08:28:17.931]                           for (restart in restarts) {
[08:28:17.931]                             name <- restart$name
[08:28:17.931]                             if (is.null(name)) 
[08:28:17.931]                               next
[08:28:17.931]                             if (!grepl(pattern, name)) 
[08:28:17.931]                               next
[08:28:17.931]                             invokeRestart(restart)
[08:28:17.931]                             muffled <- TRUE
[08:28:17.931]                             break
[08:28:17.931]                           }
[08:28:17.931]                         }
[08:28:17.931]                       }
[08:28:17.931]                       invisible(muffled)
[08:28:17.931]                     }
[08:28:17.931]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.931]                   }
[08:28:17.931]                 }
[08:28:17.931]                 else {
[08:28:17.931]                   if (TRUE) {
[08:28:17.931]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:17.931]                     {
[08:28:17.931]                       inherits <- base::inherits
[08:28:17.931]                       invokeRestart <- base::invokeRestart
[08:28:17.931]                       is.null <- base::is.null
[08:28:17.931]                       muffled <- FALSE
[08:28:17.931]                       if (inherits(cond, "message")) {
[08:28:17.931]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:17.931]                         if (muffled) 
[08:28:17.931]                           invokeRestart("muffleMessage")
[08:28:17.931]                       }
[08:28:17.931]                       else if (inherits(cond, "warning")) {
[08:28:17.931]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:17.931]                         if (muffled) 
[08:28:17.931]                           invokeRestart("muffleWarning")
[08:28:17.931]                       }
[08:28:17.931]                       else if (inherits(cond, "condition")) {
[08:28:17.931]                         if (!is.null(pattern)) {
[08:28:17.931]                           computeRestarts <- base::computeRestarts
[08:28:17.931]                           grepl <- base::grepl
[08:28:17.931]                           restarts <- computeRestarts(cond)
[08:28:17.931]                           for (restart in restarts) {
[08:28:17.931]                             name <- restart$name
[08:28:17.931]                             if (is.null(name)) 
[08:28:17.931]                               next
[08:28:17.931]                             if (!grepl(pattern, name)) 
[08:28:17.931]                               next
[08:28:17.931]                             invokeRestart(restart)
[08:28:17.931]                             muffled <- TRUE
[08:28:17.931]                             break
[08:28:17.931]                           }
[08:28:17.931]                         }
[08:28:17.931]                       }
[08:28:17.931]                       invisible(muffled)
[08:28:17.931]                     }
[08:28:17.931]                     muffleCondition(cond, pattern = "^muffle")
[08:28:17.931]                   }
[08:28:17.931]                 }
[08:28:17.931]             }
[08:28:17.931]         }))
[08:28:17.931]     }, error = function(ex) {
[08:28:17.931]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:17.931]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:17.931]                 ...future.rng), started = ...future.startTime, 
[08:28:17.931]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:17.931]             version = "1.8"), class = "FutureResult")
[08:28:17.931]     }, finally = {
[08:28:17.931]         if (!identical(...future.workdir, getwd())) 
[08:28:17.931]             setwd(...future.workdir)
[08:28:17.931]         {
[08:28:17.931]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:17.931]                 ...future.oldOptions$nwarnings <- NULL
[08:28:17.931]             }
[08:28:17.931]             base::options(...future.oldOptions)
[08:28:17.931]             if (.Platform$OS.type == "windows") {
[08:28:17.931]                 old_names <- names(...future.oldEnvVars)
[08:28:17.931]                 envs <- base::Sys.getenv()
[08:28:17.931]                 names <- names(envs)
[08:28:17.931]                 common <- intersect(names, old_names)
[08:28:17.931]                 added <- setdiff(names, old_names)
[08:28:17.931]                 removed <- setdiff(old_names, names)
[08:28:17.931]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:17.931]                   envs[common]]
[08:28:17.931]                 NAMES <- toupper(changed)
[08:28:17.931]                 args <- list()
[08:28:17.931]                 for (kk in seq_along(NAMES)) {
[08:28:17.931]                   name <- changed[[kk]]
[08:28:17.931]                   NAME <- NAMES[[kk]]
[08:28:17.931]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.931]                     next
[08:28:17.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.931]                 }
[08:28:17.931]                 NAMES <- toupper(added)
[08:28:17.931]                 for (kk in seq_along(NAMES)) {
[08:28:17.931]                   name <- added[[kk]]
[08:28:17.931]                   NAME <- NAMES[[kk]]
[08:28:17.931]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.931]                     next
[08:28:17.931]                   args[[name]] <- ""
[08:28:17.931]                 }
[08:28:17.931]                 NAMES <- toupper(removed)
[08:28:17.931]                 for (kk in seq_along(NAMES)) {
[08:28:17.931]                   name <- removed[[kk]]
[08:28:17.931]                   NAME <- NAMES[[kk]]
[08:28:17.931]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:17.931]                     next
[08:28:17.931]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:17.931]                 }
[08:28:17.931]                 if (length(args) > 0) 
[08:28:17.931]                   base::do.call(base::Sys.setenv, args = args)
[08:28:17.931]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:17.931]             }
[08:28:17.931]             else {
[08:28:17.931]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:17.931]             }
[08:28:17.931]             {
[08:28:17.931]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:17.931]                   0L) {
[08:28:17.931]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:17.931]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:17.931]                   base::options(opts)
[08:28:17.931]                 }
[08:28:17.931]                 {
[08:28:17.931]                   {
[08:28:17.931]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:17.931]                     NULL
[08:28:17.931]                   }
[08:28:17.931]                   options(future.plan = NULL)
[08:28:17.931]                   if (is.na(NA_character_)) 
[08:28:17.931]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:17.931]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:17.931]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:17.931]                     .init = FALSE)
[08:28:17.931]                 }
[08:28:17.931]             }
[08:28:17.931]         }
[08:28:17.931]     })
[08:28:17.931]     if (TRUE) {
[08:28:17.931]         base::sink(type = "output", split = FALSE)
[08:28:17.931]         if (TRUE) {
[08:28:17.931]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:17.931]         }
[08:28:17.931]         else {
[08:28:17.931]             ...future.result["stdout"] <- base::list(NULL)
[08:28:17.931]         }
[08:28:17.931]         base::close(...future.stdout)
[08:28:17.931]         ...future.stdout <- NULL
[08:28:17.931]     }
[08:28:17.931]     ...future.result$conditions <- ...future.conditions
[08:28:17.931]     ...future.result$finished <- base::Sys.time()
[08:28:17.931]     ...future.result
[08:28:17.931] }
[08:28:17.933] Exporting 1 global objects (346 bytes) to cluster node #2 ...
[08:28:17.934] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[08:28:17.934] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[08:28:17.934] Exporting 1 global objects (346 bytes) to cluster node #2 ... DONE
[08:28:17.935] MultisessionFuture started
[08:28:17.935] - Launch lazy future ... done
[08:28:17.935] run() for ‘MultisessionFuture’ ... done
[08:28:17.935] result() for ClusterFuture ...
[08:28:17.935] receiveMessageFromWorker() for ClusterFuture ...
[08:28:17.935] - Validating connection of MultisessionFuture
[08:28:17.977] - received message: FutureResult
[08:28:17.977] - Received FutureResult
[08:28:17.977] - Erased future from FutureRegistry
[08:28:17.978] result() for ClusterFuture ...
[08:28:17.978] - result already collected: FutureResult
[08:28:17.978] result() for ClusterFuture ... done
[08:28:17.978] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:17.978] result() for ClusterFuture ... done
[08:28:17.978] result() for ClusterFuture ...
[08:28:17.978] - result already collected: FutureResult
[08:28:17.978] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:17.979] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:17.979] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:17.981] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:17.981] Searching for globals ... DONE
[08:28:17.981] Resolving globals: TRUE
[08:28:17.981] Resolving any globals that are futures ...
[08:28:17.981] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[08:28:17.981] Resolving any globals that are futures ... DONE
[08:28:17.982] Resolving futures part of globals (recursively) ...
[08:28:17.982] resolve() on list ...
[08:28:17.982]  recursive: 99
[08:28:17.982]  length: 1
[08:28:17.982]  elements: ‘a’
[08:28:17.982]  length: 0 (resolved future 1)
[08:28:17.982] resolve() on list ... DONE
[08:28:17.982] - globals: [1] ‘a’
[08:28:17.983] Resolving futures part of globals (recursively) ... DONE
[08:28:17.983] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:17.983] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[08:28:17.983] - globals: [1] ‘a’
[08:28:17.983] 
[08:28:17.983] getGlobalsAndPackages() ... DONE
[08:28:17.984] run() for ‘Future’ ...
[08:28:17.984] - state: ‘created’
[08:28:17.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:17.998] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:17.998] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:17.998]   - Field: ‘node’
[08:28:17.998]   - Field: ‘label’
[08:28:17.998]   - Field: ‘local’
[08:28:17.999]   - Field: ‘owner’
[08:28:17.999]   - Field: ‘envir’
[08:28:17.999]   - Field: ‘workers’
[08:28:17.999]   - Field: ‘packages’
[08:28:17.999]   - Field: ‘gc’
[08:28:17.999]   - Field: ‘conditions’
[08:28:17.999]   - Field: ‘persistent’
[08:28:17.999]   - Field: ‘expr’
[08:28:17.999]   - Field: ‘uuid’
[08:28:17.999]   - Field: ‘seed’
[08:28:17.999]   - Field: ‘version’
[08:28:17.999]   - Field: ‘result’
[08:28:18.000]   - Field: ‘asynchronous’
[08:28:18.000]   - Field: ‘calls’
[08:28:18.000]   - Field: ‘globals’
[08:28:18.000]   - Field: ‘stdout’
[08:28:18.000]   - Field: ‘earlySignal’
[08:28:18.000]   - Field: ‘lazy’
[08:28:18.000]   - Field: ‘state’
[08:28:18.000] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.000] - Launch lazy future ...
[08:28:18.001] Packages needed by the future expression (n = 0): <none>
[08:28:18.001] Packages needed by future strategies (n = 0): <none>
[08:28:18.001] {
[08:28:18.001]     {
[08:28:18.001]         {
[08:28:18.001]             ...future.startTime <- base::Sys.time()
[08:28:18.001]             {
[08:28:18.001]                 {
[08:28:18.001]                   {
[08:28:18.001]                     {
[08:28:18.001]                       base::local({
[08:28:18.001]                         has_future <- base::requireNamespace("future", 
[08:28:18.001]                           quietly = TRUE)
[08:28:18.001]                         if (has_future) {
[08:28:18.001]                           ns <- base::getNamespace("future")
[08:28:18.001]                           version <- ns[[".package"]][["version"]]
[08:28:18.001]                           if (is.null(version)) 
[08:28:18.001]                             version <- utils::packageVersion("future")
[08:28:18.001]                         }
[08:28:18.001]                         else {
[08:28:18.001]                           version <- NULL
[08:28:18.001]                         }
[08:28:18.001]                         if (!has_future || version < "1.8.0") {
[08:28:18.001]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.001]                             "", base::R.version$version.string), 
[08:28:18.001]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.001]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.001]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.001]                               "release", "version")], collapse = " "), 
[08:28:18.001]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.001]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.001]                             info)
[08:28:18.001]                           info <- base::paste(info, collapse = "; ")
[08:28:18.001]                           if (!has_future) {
[08:28:18.001]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.001]                               info)
[08:28:18.001]                           }
[08:28:18.001]                           else {
[08:28:18.001]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.001]                               info, version)
[08:28:18.001]                           }
[08:28:18.001]                           base::stop(msg)
[08:28:18.001]                         }
[08:28:18.001]                       })
[08:28:18.001]                     }
[08:28:18.001]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.001]                     base::options(mc.cores = 1L)
[08:28:18.001]                   }
[08:28:18.001]                   ...future.strategy.old <- future::plan("list")
[08:28:18.001]                   options(future.plan = NULL)
[08:28:18.001]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.001]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.001]                 }
[08:28:18.001]                 ...future.workdir <- getwd()
[08:28:18.001]             }
[08:28:18.001]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.001]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.001]         }
[08:28:18.001]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.001]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.001]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.001]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.001]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.001]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.001]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.001]             base::names(...future.oldOptions))
[08:28:18.001]     }
[08:28:18.001]     if (FALSE) {
[08:28:18.001]     }
[08:28:18.001]     else {
[08:28:18.001]         if (TRUE) {
[08:28:18.001]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.001]                 open = "w")
[08:28:18.001]         }
[08:28:18.001]         else {
[08:28:18.001]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.001]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.001]         }
[08:28:18.001]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.001]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.001]             base::sink(type = "output", split = FALSE)
[08:28:18.001]             base::close(...future.stdout)
[08:28:18.001]         }, add = TRUE)
[08:28:18.001]     }
[08:28:18.001]     ...future.frame <- base::sys.nframe()
[08:28:18.001]     ...future.conditions <- base::list()
[08:28:18.001]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.001]     if (FALSE) {
[08:28:18.001]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.001]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.001]     }
[08:28:18.001]     ...future.result <- base::tryCatch({
[08:28:18.001]         base::withCallingHandlers({
[08:28:18.001]             ...future.value <- base::withVisible(base::local({
[08:28:18.001]                 ...future.makeSendCondition <- base::local({
[08:28:18.001]                   sendCondition <- NULL
[08:28:18.001]                   function(frame = 1L) {
[08:28:18.001]                     if (is.function(sendCondition)) 
[08:28:18.001]                       return(sendCondition)
[08:28:18.001]                     ns <- getNamespace("parallel")
[08:28:18.001]                     if (exists("sendData", mode = "function", 
[08:28:18.001]                       envir = ns)) {
[08:28:18.001]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.001]                         envir = ns)
[08:28:18.001]                       envir <- sys.frame(frame)
[08:28:18.001]                       master <- NULL
[08:28:18.001]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.001]                         !identical(envir, emptyenv())) {
[08:28:18.001]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.001]                           inherits = FALSE)) {
[08:28:18.001]                           master <- get("master", mode = "list", 
[08:28:18.001]                             envir = envir, inherits = FALSE)
[08:28:18.001]                           if (inherits(master, c("SOCKnode", 
[08:28:18.001]                             "SOCK0node"))) {
[08:28:18.001]                             sendCondition <<- function(cond) {
[08:28:18.001]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.001]                                 success = TRUE)
[08:28:18.001]                               parallel_sendData(master, data)
[08:28:18.001]                             }
[08:28:18.001]                             return(sendCondition)
[08:28:18.001]                           }
[08:28:18.001]                         }
[08:28:18.001]                         frame <- frame + 1L
[08:28:18.001]                         envir <- sys.frame(frame)
[08:28:18.001]                       }
[08:28:18.001]                     }
[08:28:18.001]                     sendCondition <<- function(cond) NULL
[08:28:18.001]                   }
[08:28:18.001]                 })
[08:28:18.001]                 withCallingHandlers({
[08:28:18.001]                   {
[08:28:18.001]                     b <- a
[08:28:18.001]                     a <- 2
[08:28:18.001]                     a * b
[08:28:18.001]                   }
[08:28:18.001]                 }, immediateCondition = function(cond) {
[08:28:18.001]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.001]                   sendCondition(cond)
[08:28:18.001]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.001]                   {
[08:28:18.001]                     inherits <- base::inherits
[08:28:18.001]                     invokeRestart <- base::invokeRestart
[08:28:18.001]                     is.null <- base::is.null
[08:28:18.001]                     muffled <- FALSE
[08:28:18.001]                     if (inherits(cond, "message")) {
[08:28:18.001]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.001]                       if (muffled) 
[08:28:18.001]                         invokeRestart("muffleMessage")
[08:28:18.001]                     }
[08:28:18.001]                     else if (inherits(cond, "warning")) {
[08:28:18.001]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.001]                       if (muffled) 
[08:28:18.001]                         invokeRestart("muffleWarning")
[08:28:18.001]                     }
[08:28:18.001]                     else if (inherits(cond, "condition")) {
[08:28:18.001]                       if (!is.null(pattern)) {
[08:28:18.001]                         computeRestarts <- base::computeRestarts
[08:28:18.001]                         grepl <- base::grepl
[08:28:18.001]                         restarts <- computeRestarts(cond)
[08:28:18.001]                         for (restart in restarts) {
[08:28:18.001]                           name <- restart$name
[08:28:18.001]                           if (is.null(name)) 
[08:28:18.001]                             next
[08:28:18.001]                           if (!grepl(pattern, name)) 
[08:28:18.001]                             next
[08:28:18.001]                           invokeRestart(restart)
[08:28:18.001]                           muffled <- TRUE
[08:28:18.001]                           break
[08:28:18.001]                         }
[08:28:18.001]                       }
[08:28:18.001]                     }
[08:28:18.001]                     invisible(muffled)
[08:28:18.001]                   }
[08:28:18.001]                   muffleCondition(cond)
[08:28:18.001]                 })
[08:28:18.001]             }))
[08:28:18.001]             future::FutureResult(value = ...future.value$value, 
[08:28:18.001]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.001]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.001]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.001]                     ...future.globalenv.names))
[08:28:18.001]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.001]         }, condition = base::local({
[08:28:18.001]             c <- base::c
[08:28:18.001]             inherits <- base::inherits
[08:28:18.001]             invokeRestart <- base::invokeRestart
[08:28:18.001]             length <- base::length
[08:28:18.001]             list <- base::list
[08:28:18.001]             seq.int <- base::seq.int
[08:28:18.001]             signalCondition <- base::signalCondition
[08:28:18.001]             sys.calls <- base::sys.calls
[08:28:18.001]             `[[` <- base::`[[`
[08:28:18.001]             `+` <- base::`+`
[08:28:18.001]             `<<-` <- base::`<<-`
[08:28:18.001]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.001]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.001]                   3L)]
[08:28:18.001]             }
[08:28:18.001]             function(cond) {
[08:28:18.001]                 is_error <- inherits(cond, "error")
[08:28:18.001]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.001]                   NULL)
[08:28:18.001]                 if (is_error) {
[08:28:18.001]                   sessionInformation <- function() {
[08:28:18.001]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.001]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.001]                       search = base::search(), system = base::Sys.info())
[08:28:18.001]                   }
[08:28:18.001]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.001]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.001]                     cond$call), session = sessionInformation(), 
[08:28:18.001]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.001]                   signalCondition(cond)
[08:28:18.001]                 }
[08:28:18.001]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.001]                 "immediateCondition"))) {
[08:28:18.001]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.001]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.001]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.001]                   if (TRUE && !signal) {
[08:28:18.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.001]                     {
[08:28:18.001]                       inherits <- base::inherits
[08:28:18.001]                       invokeRestart <- base::invokeRestart
[08:28:18.001]                       is.null <- base::is.null
[08:28:18.001]                       muffled <- FALSE
[08:28:18.001]                       if (inherits(cond, "message")) {
[08:28:18.001]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.001]                         if (muffled) 
[08:28:18.001]                           invokeRestart("muffleMessage")
[08:28:18.001]                       }
[08:28:18.001]                       else if (inherits(cond, "warning")) {
[08:28:18.001]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.001]                         if (muffled) 
[08:28:18.001]                           invokeRestart("muffleWarning")
[08:28:18.001]                       }
[08:28:18.001]                       else if (inherits(cond, "condition")) {
[08:28:18.001]                         if (!is.null(pattern)) {
[08:28:18.001]                           computeRestarts <- base::computeRestarts
[08:28:18.001]                           grepl <- base::grepl
[08:28:18.001]                           restarts <- computeRestarts(cond)
[08:28:18.001]                           for (restart in restarts) {
[08:28:18.001]                             name <- restart$name
[08:28:18.001]                             if (is.null(name)) 
[08:28:18.001]                               next
[08:28:18.001]                             if (!grepl(pattern, name)) 
[08:28:18.001]                               next
[08:28:18.001]                             invokeRestart(restart)
[08:28:18.001]                             muffled <- TRUE
[08:28:18.001]                             break
[08:28:18.001]                           }
[08:28:18.001]                         }
[08:28:18.001]                       }
[08:28:18.001]                       invisible(muffled)
[08:28:18.001]                     }
[08:28:18.001]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.001]                   }
[08:28:18.001]                 }
[08:28:18.001]                 else {
[08:28:18.001]                   if (TRUE) {
[08:28:18.001]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.001]                     {
[08:28:18.001]                       inherits <- base::inherits
[08:28:18.001]                       invokeRestart <- base::invokeRestart
[08:28:18.001]                       is.null <- base::is.null
[08:28:18.001]                       muffled <- FALSE
[08:28:18.001]                       if (inherits(cond, "message")) {
[08:28:18.001]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.001]                         if (muffled) 
[08:28:18.001]                           invokeRestart("muffleMessage")
[08:28:18.001]                       }
[08:28:18.001]                       else if (inherits(cond, "warning")) {
[08:28:18.001]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.001]                         if (muffled) 
[08:28:18.001]                           invokeRestart("muffleWarning")
[08:28:18.001]                       }
[08:28:18.001]                       else if (inherits(cond, "condition")) {
[08:28:18.001]                         if (!is.null(pattern)) {
[08:28:18.001]                           computeRestarts <- base::computeRestarts
[08:28:18.001]                           grepl <- base::grepl
[08:28:18.001]                           restarts <- computeRestarts(cond)
[08:28:18.001]                           for (restart in restarts) {
[08:28:18.001]                             name <- restart$name
[08:28:18.001]                             if (is.null(name)) 
[08:28:18.001]                               next
[08:28:18.001]                             if (!grepl(pattern, name)) 
[08:28:18.001]                               next
[08:28:18.001]                             invokeRestart(restart)
[08:28:18.001]                             muffled <- TRUE
[08:28:18.001]                             break
[08:28:18.001]                           }
[08:28:18.001]                         }
[08:28:18.001]                       }
[08:28:18.001]                       invisible(muffled)
[08:28:18.001]                     }
[08:28:18.001]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.001]                   }
[08:28:18.001]                 }
[08:28:18.001]             }
[08:28:18.001]         }))
[08:28:18.001]     }, error = function(ex) {
[08:28:18.001]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.001]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.001]                 ...future.rng), started = ...future.startTime, 
[08:28:18.001]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.001]             version = "1.8"), class = "FutureResult")
[08:28:18.001]     }, finally = {
[08:28:18.001]         if (!identical(...future.workdir, getwd())) 
[08:28:18.001]             setwd(...future.workdir)
[08:28:18.001]         {
[08:28:18.001]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.001]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.001]             }
[08:28:18.001]             base::options(...future.oldOptions)
[08:28:18.001]             if (.Platform$OS.type == "windows") {
[08:28:18.001]                 old_names <- names(...future.oldEnvVars)
[08:28:18.001]                 envs <- base::Sys.getenv()
[08:28:18.001]                 names <- names(envs)
[08:28:18.001]                 common <- intersect(names, old_names)
[08:28:18.001]                 added <- setdiff(names, old_names)
[08:28:18.001]                 removed <- setdiff(old_names, names)
[08:28:18.001]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.001]                   envs[common]]
[08:28:18.001]                 NAMES <- toupper(changed)
[08:28:18.001]                 args <- list()
[08:28:18.001]                 for (kk in seq_along(NAMES)) {
[08:28:18.001]                   name <- changed[[kk]]
[08:28:18.001]                   NAME <- NAMES[[kk]]
[08:28:18.001]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.001]                     next
[08:28:18.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.001]                 }
[08:28:18.001]                 NAMES <- toupper(added)
[08:28:18.001]                 for (kk in seq_along(NAMES)) {
[08:28:18.001]                   name <- added[[kk]]
[08:28:18.001]                   NAME <- NAMES[[kk]]
[08:28:18.001]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.001]                     next
[08:28:18.001]                   args[[name]] <- ""
[08:28:18.001]                 }
[08:28:18.001]                 NAMES <- toupper(removed)
[08:28:18.001]                 for (kk in seq_along(NAMES)) {
[08:28:18.001]                   name <- removed[[kk]]
[08:28:18.001]                   NAME <- NAMES[[kk]]
[08:28:18.001]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.001]                     next
[08:28:18.001]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.001]                 }
[08:28:18.001]                 if (length(args) > 0) 
[08:28:18.001]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.001]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.001]             }
[08:28:18.001]             else {
[08:28:18.001]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.001]             }
[08:28:18.001]             {
[08:28:18.001]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.001]                   0L) {
[08:28:18.001]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.001]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.001]                   base::options(opts)
[08:28:18.001]                 }
[08:28:18.001]                 {
[08:28:18.001]                   {
[08:28:18.001]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.001]                     NULL
[08:28:18.001]                   }
[08:28:18.001]                   options(future.plan = NULL)
[08:28:18.001]                   if (is.na(NA_character_)) 
[08:28:18.001]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.001]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.001]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.001]                     .init = FALSE)
[08:28:18.001]                 }
[08:28:18.001]             }
[08:28:18.001]         }
[08:28:18.001]     })
[08:28:18.001]     if (TRUE) {
[08:28:18.001]         base::sink(type = "output", split = FALSE)
[08:28:18.001]         if (TRUE) {
[08:28:18.001]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.001]         }
[08:28:18.001]         else {
[08:28:18.001]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.001]         }
[08:28:18.001]         base::close(...future.stdout)
[08:28:18.001]         ...future.stdout <- NULL
[08:28:18.001]     }
[08:28:18.001]     ...future.result$conditions <- ...future.conditions
[08:28:18.001]     ...future.result$finished <- base::Sys.time()
[08:28:18.001]     ...future.result
[08:28:18.001] }
[08:28:18.004] Exporting 1 global objects (346 bytes) to cluster node #2 ...
[08:28:18.004] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[08:28:18.004] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[08:28:18.004] Exporting 1 global objects (346 bytes) to cluster node #2 ... DONE
[08:28:18.005] MultisessionFuture started
[08:28:18.005] - Launch lazy future ... done
[08:28:18.005] run() for ‘MultisessionFuture’ ... done
[08:28:18.005] result() for ClusterFuture ...
[08:28:18.005] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.006] - Validating connection of MultisessionFuture
[08:28:18.047] - received message: FutureResult
[08:28:18.047] - Received FutureResult
[08:28:18.047] - Erased future from FutureRegistry
[08:28:18.048] result() for ClusterFuture ...
[08:28:18.048] - result already collected: FutureResult
[08:28:18.048] result() for ClusterFuture ... done
[08:28:18.048] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.048] result() for ClusterFuture ... done
[08:28:18.048] result() for ClusterFuture ...
[08:28:18.048] - result already collected: FutureResult
[08:28:18.048] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.049] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.049] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.051] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.051] Searching for globals ... DONE
[08:28:18.051] Resolving globals: TRUE
[08:28:18.051] Resolving any globals that are futures ...
[08:28:18.051] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.051] Resolving any globals that are futures ... DONE
[08:28:18.052] Resolving futures part of globals (recursively) ...
[08:28:18.052] resolve() on list ...
[08:28:18.052]  recursive: 99
[08:28:18.052]  length: 2
[08:28:18.052]  elements: ‘a’, ‘ii’
[08:28:18.052]  length: 1 (resolved future 1)
[08:28:18.053]  length: 0 (resolved future 2)
[08:28:18.053] resolve() on list ... DONE
[08:28:18.053] - globals: [2] ‘a’, ‘ii’
[08:28:18.053] Resolving futures part of globals (recursively) ... DONE
[08:28:18.053] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:18.053] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:18.053] - globals: [2] ‘a’, ‘ii’
[08:28:18.054] 
[08:28:18.054] getGlobalsAndPackages() ... DONE
[08:28:18.054] run() for ‘Future’ ...
[08:28:18.054] - state: ‘created’
[08:28:18.054] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.068] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.068] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.069]   - Field: ‘node’
[08:28:18.069]   - Field: ‘label’
[08:28:18.069]   - Field: ‘local’
[08:28:18.069]   - Field: ‘owner’
[08:28:18.069]   - Field: ‘envir’
[08:28:18.069]   - Field: ‘workers’
[08:28:18.069]   - Field: ‘packages’
[08:28:18.069]   - Field: ‘gc’
[08:28:18.069]   - Field: ‘conditions’
[08:28:18.069]   - Field: ‘persistent’
[08:28:18.069]   - Field: ‘expr’
[08:28:18.070]   - Field: ‘uuid’
[08:28:18.070]   - Field: ‘seed’
[08:28:18.070]   - Field: ‘version’
[08:28:18.070]   - Field: ‘result’
[08:28:18.070]   - Field: ‘asynchronous’
[08:28:18.070]   - Field: ‘calls’
[08:28:18.070]   - Field: ‘globals’
[08:28:18.070]   - Field: ‘stdout’
[08:28:18.070]   - Field: ‘earlySignal’
[08:28:18.070]   - Field: ‘lazy’
[08:28:18.070]   - Field: ‘state’
[08:28:18.071] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.071] - Launch lazy future ...
[08:28:18.071] Packages needed by the future expression (n = 0): <none>
[08:28:18.071] Packages needed by future strategies (n = 0): <none>
[08:28:18.071] {
[08:28:18.071]     {
[08:28:18.071]         {
[08:28:18.071]             ...future.startTime <- base::Sys.time()
[08:28:18.071]             {
[08:28:18.071]                 {
[08:28:18.071]                   {
[08:28:18.071]                     {
[08:28:18.071]                       base::local({
[08:28:18.071]                         has_future <- base::requireNamespace("future", 
[08:28:18.071]                           quietly = TRUE)
[08:28:18.071]                         if (has_future) {
[08:28:18.071]                           ns <- base::getNamespace("future")
[08:28:18.071]                           version <- ns[[".package"]][["version"]]
[08:28:18.071]                           if (is.null(version)) 
[08:28:18.071]                             version <- utils::packageVersion("future")
[08:28:18.071]                         }
[08:28:18.071]                         else {
[08:28:18.071]                           version <- NULL
[08:28:18.071]                         }
[08:28:18.071]                         if (!has_future || version < "1.8.0") {
[08:28:18.071]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.071]                             "", base::R.version$version.string), 
[08:28:18.071]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.071]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.071]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.071]                               "release", "version")], collapse = " "), 
[08:28:18.071]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.071]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.071]                             info)
[08:28:18.071]                           info <- base::paste(info, collapse = "; ")
[08:28:18.071]                           if (!has_future) {
[08:28:18.071]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.071]                               info)
[08:28:18.071]                           }
[08:28:18.071]                           else {
[08:28:18.071]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.071]                               info, version)
[08:28:18.071]                           }
[08:28:18.071]                           base::stop(msg)
[08:28:18.071]                         }
[08:28:18.071]                       })
[08:28:18.071]                     }
[08:28:18.071]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.071]                     base::options(mc.cores = 1L)
[08:28:18.071]                   }
[08:28:18.071]                   ...future.strategy.old <- future::plan("list")
[08:28:18.071]                   options(future.plan = NULL)
[08:28:18.071]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.071]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.071]                 }
[08:28:18.071]                 ...future.workdir <- getwd()
[08:28:18.071]             }
[08:28:18.071]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.071]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.071]         }
[08:28:18.071]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.071]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.071]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.071]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.071]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.071]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.071]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.071]             base::names(...future.oldOptions))
[08:28:18.071]     }
[08:28:18.071]     if (FALSE) {
[08:28:18.071]     }
[08:28:18.071]     else {
[08:28:18.071]         if (TRUE) {
[08:28:18.071]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.071]                 open = "w")
[08:28:18.071]         }
[08:28:18.071]         else {
[08:28:18.071]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.071]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.071]         }
[08:28:18.071]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.071]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.071]             base::sink(type = "output", split = FALSE)
[08:28:18.071]             base::close(...future.stdout)
[08:28:18.071]         }, add = TRUE)
[08:28:18.071]     }
[08:28:18.071]     ...future.frame <- base::sys.nframe()
[08:28:18.071]     ...future.conditions <- base::list()
[08:28:18.071]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.071]     if (FALSE) {
[08:28:18.071]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.071]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.071]     }
[08:28:18.071]     ...future.result <- base::tryCatch({
[08:28:18.071]         base::withCallingHandlers({
[08:28:18.071]             ...future.value <- base::withVisible(base::local({
[08:28:18.071]                 ...future.makeSendCondition <- base::local({
[08:28:18.071]                   sendCondition <- NULL
[08:28:18.071]                   function(frame = 1L) {
[08:28:18.071]                     if (is.function(sendCondition)) 
[08:28:18.071]                       return(sendCondition)
[08:28:18.071]                     ns <- getNamespace("parallel")
[08:28:18.071]                     if (exists("sendData", mode = "function", 
[08:28:18.071]                       envir = ns)) {
[08:28:18.071]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.071]                         envir = ns)
[08:28:18.071]                       envir <- sys.frame(frame)
[08:28:18.071]                       master <- NULL
[08:28:18.071]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.071]                         !identical(envir, emptyenv())) {
[08:28:18.071]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.071]                           inherits = FALSE)) {
[08:28:18.071]                           master <- get("master", mode = "list", 
[08:28:18.071]                             envir = envir, inherits = FALSE)
[08:28:18.071]                           if (inherits(master, c("SOCKnode", 
[08:28:18.071]                             "SOCK0node"))) {
[08:28:18.071]                             sendCondition <<- function(cond) {
[08:28:18.071]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.071]                                 success = TRUE)
[08:28:18.071]                               parallel_sendData(master, data)
[08:28:18.071]                             }
[08:28:18.071]                             return(sendCondition)
[08:28:18.071]                           }
[08:28:18.071]                         }
[08:28:18.071]                         frame <- frame + 1L
[08:28:18.071]                         envir <- sys.frame(frame)
[08:28:18.071]                       }
[08:28:18.071]                     }
[08:28:18.071]                     sendCondition <<- function(cond) NULL
[08:28:18.071]                   }
[08:28:18.071]                 })
[08:28:18.071]                 withCallingHandlers({
[08:28:18.071]                   {
[08:28:18.071]                     b <- a * ii
[08:28:18.071]                     a <- 0
[08:28:18.071]                     b
[08:28:18.071]                   }
[08:28:18.071]                 }, immediateCondition = function(cond) {
[08:28:18.071]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.071]                   sendCondition(cond)
[08:28:18.071]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.071]                   {
[08:28:18.071]                     inherits <- base::inherits
[08:28:18.071]                     invokeRestart <- base::invokeRestart
[08:28:18.071]                     is.null <- base::is.null
[08:28:18.071]                     muffled <- FALSE
[08:28:18.071]                     if (inherits(cond, "message")) {
[08:28:18.071]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.071]                       if (muffled) 
[08:28:18.071]                         invokeRestart("muffleMessage")
[08:28:18.071]                     }
[08:28:18.071]                     else if (inherits(cond, "warning")) {
[08:28:18.071]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.071]                       if (muffled) 
[08:28:18.071]                         invokeRestart("muffleWarning")
[08:28:18.071]                     }
[08:28:18.071]                     else if (inherits(cond, "condition")) {
[08:28:18.071]                       if (!is.null(pattern)) {
[08:28:18.071]                         computeRestarts <- base::computeRestarts
[08:28:18.071]                         grepl <- base::grepl
[08:28:18.071]                         restarts <- computeRestarts(cond)
[08:28:18.071]                         for (restart in restarts) {
[08:28:18.071]                           name <- restart$name
[08:28:18.071]                           if (is.null(name)) 
[08:28:18.071]                             next
[08:28:18.071]                           if (!grepl(pattern, name)) 
[08:28:18.071]                             next
[08:28:18.071]                           invokeRestart(restart)
[08:28:18.071]                           muffled <- TRUE
[08:28:18.071]                           break
[08:28:18.071]                         }
[08:28:18.071]                       }
[08:28:18.071]                     }
[08:28:18.071]                     invisible(muffled)
[08:28:18.071]                   }
[08:28:18.071]                   muffleCondition(cond)
[08:28:18.071]                 })
[08:28:18.071]             }))
[08:28:18.071]             future::FutureResult(value = ...future.value$value, 
[08:28:18.071]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.071]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.071]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.071]                     ...future.globalenv.names))
[08:28:18.071]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.071]         }, condition = base::local({
[08:28:18.071]             c <- base::c
[08:28:18.071]             inherits <- base::inherits
[08:28:18.071]             invokeRestart <- base::invokeRestart
[08:28:18.071]             length <- base::length
[08:28:18.071]             list <- base::list
[08:28:18.071]             seq.int <- base::seq.int
[08:28:18.071]             signalCondition <- base::signalCondition
[08:28:18.071]             sys.calls <- base::sys.calls
[08:28:18.071]             `[[` <- base::`[[`
[08:28:18.071]             `+` <- base::`+`
[08:28:18.071]             `<<-` <- base::`<<-`
[08:28:18.071]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.071]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.071]                   3L)]
[08:28:18.071]             }
[08:28:18.071]             function(cond) {
[08:28:18.071]                 is_error <- inherits(cond, "error")
[08:28:18.071]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.071]                   NULL)
[08:28:18.071]                 if (is_error) {
[08:28:18.071]                   sessionInformation <- function() {
[08:28:18.071]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.071]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.071]                       search = base::search(), system = base::Sys.info())
[08:28:18.071]                   }
[08:28:18.071]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.071]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.071]                     cond$call), session = sessionInformation(), 
[08:28:18.071]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.071]                   signalCondition(cond)
[08:28:18.071]                 }
[08:28:18.071]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.071]                 "immediateCondition"))) {
[08:28:18.071]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.071]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.071]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.071]                   if (TRUE && !signal) {
[08:28:18.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.071]                     {
[08:28:18.071]                       inherits <- base::inherits
[08:28:18.071]                       invokeRestart <- base::invokeRestart
[08:28:18.071]                       is.null <- base::is.null
[08:28:18.071]                       muffled <- FALSE
[08:28:18.071]                       if (inherits(cond, "message")) {
[08:28:18.071]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.071]                         if (muffled) 
[08:28:18.071]                           invokeRestart("muffleMessage")
[08:28:18.071]                       }
[08:28:18.071]                       else if (inherits(cond, "warning")) {
[08:28:18.071]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.071]                         if (muffled) 
[08:28:18.071]                           invokeRestart("muffleWarning")
[08:28:18.071]                       }
[08:28:18.071]                       else if (inherits(cond, "condition")) {
[08:28:18.071]                         if (!is.null(pattern)) {
[08:28:18.071]                           computeRestarts <- base::computeRestarts
[08:28:18.071]                           grepl <- base::grepl
[08:28:18.071]                           restarts <- computeRestarts(cond)
[08:28:18.071]                           for (restart in restarts) {
[08:28:18.071]                             name <- restart$name
[08:28:18.071]                             if (is.null(name)) 
[08:28:18.071]                               next
[08:28:18.071]                             if (!grepl(pattern, name)) 
[08:28:18.071]                               next
[08:28:18.071]                             invokeRestart(restart)
[08:28:18.071]                             muffled <- TRUE
[08:28:18.071]                             break
[08:28:18.071]                           }
[08:28:18.071]                         }
[08:28:18.071]                       }
[08:28:18.071]                       invisible(muffled)
[08:28:18.071]                     }
[08:28:18.071]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.071]                   }
[08:28:18.071]                 }
[08:28:18.071]                 else {
[08:28:18.071]                   if (TRUE) {
[08:28:18.071]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.071]                     {
[08:28:18.071]                       inherits <- base::inherits
[08:28:18.071]                       invokeRestart <- base::invokeRestart
[08:28:18.071]                       is.null <- base::is.null
[08:28:18.071]                       muffled <- FALSE
[08:28:18.071]                       if (inherits(cond, "message")) {
[08:28:18.071]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.071]                         if (muffled) 
[08:28:18.071]                           invokeRestart("muffleMessage")
[08:28:18.071]                       }
[08:28:18.071]                       else if (inherits(cond, "warning")) {
[08:28:18.071]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.071]                         if (muffled) 
[08:28:18.071]                           invokeRestart("muffleWarning")
[08:28:18.071]                       }
[08:28:18.071]                       else if (inherits(cond, "condition")) {
[08:28:18.071]                         if (!is.null(pattern)) {
[08:28:18.071]                           computeRestarts <- base::computeRestarts
[08:28:18.071]                           grepl <- base::grepl
[08:28:18.071]                           restarts <- computeRestarts(cond)
[08:28:18.071]                           for (restart in restarts) {
[08:28:18.071]                             name <- restart$name
[08:28:18.071]                             if (is.null(name)) 
[08:28:18.071]                               next
[08:28:18.071]                             if (!grepl(pattern, name)) 
[08:28:18.071]                               next
[08:28:18.071]                             invokeRestart(restart)
[08:28:18.071]                             muffled <- TRUE
[08:28:18.071]                             break
[08:28:18.071]                           }
[08:28:18.071]                         }
[08:28:18.071]                       }
[08:28:18.071]                       invisible(muffled)
[08:28:18.071]                     }
[08:28:18.071]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.071]                   }
[08:28:18.071]                 }
[08:28:18.071]             }
[08:28:18.071]         }))
[08:28:18.071]     }, error = function(ex) {
[08:28:18.071]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.071]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.071]                 ...future.rng), started = ...future.startTime, 
[08:28:18.071]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.071]             version = "1.8"), class = "FutureResult")
[08:28:18.071]     }, finally = {
[08:28:18.071]         if (!identical(...future.workdir, getwd())) 
[08:28:18.071]             setwd(...future.workdir)
[08:28:18.071]         {
[08:28:18.071]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.071]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.071]             }
[08:28:18.071]             base::options(...future.oldOptions)
[08:28:18.071]             if (.Platform$OS.type == "windows") {
[08:28:18.071]                 old_names <- names(...future.oldEnvVars)
[08:28:18.071]                 envs <- base::Sys.getenv()
[08:28:18.071]                 names <- names(envs)
[08:28:18.071]                 common <- intersect(names, old_names)
[08:28:18.071]                 added <- setdiff(names, old_names)
[08:28:18.071]                 removed <- setdiff(old_names, names)
[08:28:18.071]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.071]                   envs[common]]
[08:28:18.071]                 NAMES <- toupper(changed)
[08:28:18.071]                 args <- list()
[08:28:18.071]                 for (kk in seq_along(NAMES)) {
[08:28:18.071]                   name <- changed[[kk]]
[08:28:18.071]                   NAME <- NAMES[[kk]]
[08:28:18.071]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.071]                     next
[08:28:18.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.071]                 }
[08:28:18.071]                 NAMES <- toupper(added)
[08:28:18.071]                 for (kk in seq_along(NAMES)) {
[08:28:18.071]                   name <- added[[kk]]
[08:28:18.071]                   NAME <- NAMES[[kk]]
[08:28:18.071]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.071]                     next
[08:28:18.071]                   args[[name]] <- ""
[08:28:18.071]                 }
[08:28:18.071]                 NAMES <- toupper(removed)
[08:28:18.071]                 for (kk in seq_along(NAMES)) {
[08:28:18.071]                   name <- removed[[kk]]
[08:28:18.071]                   NAME <- NAMES[[kk]]
[08:28:18.071]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.071]                     next
[08:28:18.071]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.071]                 }
[08:28:18.071]                 if (length(args) > 0) 
[08:28:18.071]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.071]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.071]             }
[08:28:18.071]             else {
[08:28:18.071]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.071]             }
[08:28:18.071]             {
[08:28:18.071]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.071]                   0L) {
[08:28:18.071]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.071]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.071]                   base::options(opts)
[08:28:18.071]                 }
[08:28:18.071]                 {
[08:28:18.071]                   {
[08:28:18.071]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.071]                     NULL
[08:28:18.071]                   }
[08:28:18.071]                   options(future.plan = NULL)
[08:28:18.071]                   if (is.na(NA_character_)) 
[08:28:18.071]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.071]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.071]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.071]                     .init = FALSE)
[08:28:18.071]                 }
[08:28:18.071]             }
[08:28:18.071]         }
[08:28:18.071]     })
[08:28:18.071]     if (TRUE) {
[08:28:18.071]         base::sink(type = "output", split = FALSE)
[08:28:18.071]         if (TRUE) {
[08:28:18.071]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.071]         }
[08:28:18.071]         else {
[08:28:18.071]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.071]         }
[08:28:18.071]         base::close(...future.stdout)
[08:28:18.071]         ...future.stdout <- NULL
[08:28:18.071]     }
[08:28:18.071]     ...future.result$conditions <- ...future.conditions
[08:28:18.071]     ...future.result$finished <- base::Sys.time()
[08:28:18.071]     ...future.result
[08:28:18.071] }
[08:28:18.074] Exporting 2 global objects (382 bytes) to cluster node #2 ...
[08:28:18.074] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[08:28:18.075] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[08:28:18.075] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:28:18.075] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:28:18.075] Exporting 2 global objects (382 bytes) to cluster node #2 ... DONE
[08:28:18.076] MultisessionFuture started
[08:28:18.076] - Launch lazy future ... done
[08:28:18.076] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.077] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.077] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.079] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.079] Searching for globals ... DONE
[08:28:18.079] Resolving globals: TRUE
[08:28:18.079] Resolving any globals that are futures ...
[08:28:18.079] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.079] Resolving any globals that are futures ... DONE
[08:28:18.080] Resolving futures part of globals (recursively) ...
[08:28:18.080] resolve() on list ...
[08:28:18.080]  recursive: 99
[08:28:18.080]  length: 2
[08:28:18.080]  elements: ‘a’, ‘ii’
[08:28:18.080]  length: 1 (resolved future 1)
[08:28:18.081]  length: 0 (resolved future 2)
[08:28:18.081] resolve() on list ... DONE
[08:28:18.081] - globals: [2] ‘a’, ‘ii’
[08:28:18.081] Resolving futures part of globals (recursively) ... DONE
[08:28:18.081] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:18.081] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:18.081] - globals: [2] ‘a’, ‘ii’
[08:28:18.082] 
[08:28:18.082] getGlobalsAndPackages() ... DONE
[08:28:18.082] run() for ‘Future’ ...
[08:28:18.082] - state: ‘created’
[08:28:18.082] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.096] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.096] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.096]   - Field: ‘node’
[08:28:18.096]   - Field: ‘label’
[08:28:18.096]   - Field: ‘local’
[08:28:18.097]   - Field: ‘owner’
[08:28:18.097]   - Field: ‘envir’
[08:28:18.097]   - Field: ‘workers’
[08:28:18.097]   - Field: ‘packages’
[08:28:18.097]   - Field: ‘gc’
[08:28:18.097]   - Field: ‘conditions’
[08:28:18.097]   - Field: ‘persistent’
[08:28:18.097]   - Field: ‘expr’
[08:28:18.097]   - Field: ‘uuid’
[08:28:18.097]   - Field: ‘seed’
[08:28:18.097]   - Field: ‘version’
[08:28:18.098]   - Field: ‘result’
[08:28:18.098]   - Field: ‘asynchronous’
[08:28:18.098]   - Field: ‘calls’
[08:28:18.098]   - Field: ‘globals’
[08:28:18.098]   - Field: ‘stdout’
[08:28:18.098]   - Field: ‘earlySignal’
[08:28:18.098]   - Field: ‘lazy’
[08:28:18.098]   - Field: ‘state’
[08:28:18.098] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.098] - Launch lazy future ...
[08:28:18.099] Packages needed by the future expression (n = 0): <none>
[08:28:18.099] Packages needed by future strategies (n = 0): <none>
[08:28:18.099] {
[08:28:18.099]     {
[08:28:18.099]         {
[08:28:18.099]             ...future.startTime <- base::Sys.time()
[08:28:18.099]             {
[08:28:18.099]                 {
[08:28:18.099]                   {
[08:28:18.099]                     {
[08:28:18.099]                       base::local({
[08:28:18.099]                         has_future <- base::requireNamespace("future", 
[08:28:18.099]                           quietly = TRUE)
[08:28:18.099]                         if (has_future) {
[08:28:18.099]                           ns <- base::getNamespace("future")
[08:28:18.099]                           version <- ns[[".package"]][["version"]]
[08:28:18.099]                           if (is.null(version)) 
[08:28:18.099]                             version <- utils::packageVersion("future")
[08:28:18.099]                         }
[08:28:18.099]                         else {
[08:28:18.099]                           version <- NULL
[08:28:18.099]                         }
[08:28:18.099]                         if (!has_future || version < "1.8.0") {
[08:28:18.099]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.099]                             "", base::R.version$version.string), 
[08:28:18.099]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.099]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.099]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.099]                               "release", "version")], collapse = " "), 
[08:28:18.099]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.099]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.099]                             info)
[08:28:18.099]                           info <- base::paste(info, collapse = "; ")
[08:28:18.099]                           if (!has_future) {
[08:28:18.099]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.099]                               info)
[08:28:18.099]                           }
[08:28:18.099]                           else {
[08:28:18.099]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.099]                               info, version)
[08:28:18.099]                           }
[08:28:18.099]                           base::stop(msg)
[08:28:18.099]                         }
[08:28:18.099]                       })
[08:28:18.099]                     }
[08:28:18.099]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.099]                     base::options(mc.cores = 1L)
[08:28:18.099]                   }
[08:28:18.099]                   ...future.strategy.old <- future::plan("list")
[08:28:18.099]                   options(future.plan = NULL)
[08:28:18.099]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.099]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.099]                 }
[08:28:18.099]                 ...future.workdir <- getwd()
[08:28:18.099]             }
[08:28:18.099]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.099]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.099]         }
[08:28:18.099]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.099]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.099]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.099]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.099]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.099]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.099]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.099]             base::names(...future.oldOptions))
[08:28:18.099]     }
[08:28:18.099]     if (FALSE) {
[08:28:18.099]     }
[08:28:18.099]     else {
[08:28:18.099]         if (TRUE) {
[08:28:18.099]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.099]                 open = "w")
[08:28:18.099]         }
[08:28:18.099]         else {
[08:28:18.099]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.099]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.099]         }
[08:28:18.099]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.099]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.099]             base::sink(type = "output", split = FALSE)
[08:28:18.099]             base::close(...future.stdout)
[08:28:18.099]         }, add = TRUE)
[08:28:18.099]     }
[08:28:18.099]     ...future.frame <- base::sys.nframe()
[08:28:18.099]     ...future.conditions <- base::list()
[08:28:18.099]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.099]     if (FALSE) {
[08:28:18.099]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.099]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.099]     }
[08:28:18.099]     ...future.result <- base::tryCatch({
[08:28:18.099]         base::withCallingHandlers({
[08:28:18.099]             ...future.value <- base::withVisible(base::local({
[08:28:18.099]                 ...future.makeSendCondition <- base::local({
[08:28:18.099]                   sendCondition <- NULL
[08:28:18.099]                   function(frame = 1L) {
[08:28:18.099]                     if (is.function(sendCondition)) 
[08:28:18.099]                       return(sendCondition)
[08:28:18.099]                     ns <- getNamespace("parallel")
[08:28:18.099]                     if (exists("sendData", mode = "function", 
[08:28:18.099]                       envir = ns)) {
[08:28:18.099]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.099]                         envir = ns)
[08:28:18.099]                       envir <- sys.frame(frame)
[08:28:18.099]                       master <- NULL
[08:28:18.099]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.099]                         !identical(envir, emptyenv())) {
[08:28:18.099]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.099]                           inherits = FALSE)) {
[08:28:18.099]                           master <- get("master", mode = "list", 
[08:28:18.099]                             envir = envir, inherits = FALSE)
[08:28:18.099]                           if (inherits(master, c("SOCKnode", 
[08:28:18.099]                             "SOCK0node"))) {
[08:28:18.099]                             sendCondition <<- function(cond) {
[08:28:18.099]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.099]                                 success = TRUE)
[08:28:18.099]                               parallel_sendData(master, data)
[08:28:18.099]                             }
[08:28:18.099]                             return(sendCondition)
[08:28:18.099]                           }
[08:28:18.099]                         }
[08:28:18.099]                         frame <- frame + 1L
[08:28:18.099]                         envir <- sys.frame(frame)
[08:28:18.099]                       }
[08:28:18.099]                     }
[08:28:18.099]                     sendCondition <<- function(cond) NULL
[08:28:18.099]                   }
[08:28:18.099]                 })
[08:28:18.099]                 withCallingHandlers({
[08:28:18.099]                   {
[08:28:18.099]                     b <- a * ii
[08:28:18.099]                     a <- 0
[08:28:18.099]                     b
[08:28:18.099]                   }
[08:28:18.099]                 }, immediateCondition = function(cond) {
[08:28:18.099]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.099]                   sendCondition(cond)
[08:28:18.099]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.099]                   {
[08:28:18.099]                     inherits <- base::inherits
[08:28:18.099]                     invokeRestart <- base::invokeRestart
[08:28:18.099]                     is.null <- base::is.null
[08:28:18.099]                     muffled <- FALSE
[08:28:18.099]                     if (inherits(cond, "message")) {
[08:28:18.099]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.099]                       if (muffled) 
[08:28:18.099]                         invokeRestart("muffleMessage")
[08:28:18.099]                     }
[08:28:18.099]                     else if (inherits(cond, "warning")) {
[08:28:18.099]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.099]                       if (muffled) 
[08:28:18.099]                         invokeRestart("muffleWarning")
[08:28:18.099]                     }
[08:28:18.099]                     else if (inherits(cond, "condition")) {
[08:28:18.099]                       if (!is.null(pattern)) {
[08:28:18.099]                         computeRestarts <- base::computeRestarts
[08:28:18.099]                         grepl <- base::grepl
[08:28:18.099]                         restarts <- computeRestarts(cond)
[08:28:18.099]                         for (restart in restarts) {
[08:28:18.099]                           name <- restart$name
[08:28:18.099]                           if (is.null(name)) 
[08:28:18.099]                             next
[08:28:18.099]                           if (!grepl(pattern, name)) 
[08:28:18.099]                             next
[08:28:18.099]                           invokeRestart(restart)
[08:28:18.099]                           muffled <- TRUE
[08:28:18.099]                           break
[08:28:18.099]                         }
[08:28:18.099]                       }
[08:28:18.099]                     }
[08:28:18.099]                     invisible(muffled)
[08:28:18.099]                   }
[08:28:18.099]                   muffleCondition(cond)
[08:28:18.099]                 })
[08:28:18.099]             }))
[08:28:18.099]             future::FutureResult(value = ...future.value$value, 
[08:28:18.099]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.099]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.099]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.099]                     ...future.globalenv.names))
[08:28:18.099]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.099]         }, condition = base::local({
[08:28:18.099]             c <- base::c
[08:28:18.099]             inherits <- base::inherits
[08:28:18.099]             invokeRestart <- base::invokeRestart
[08:28:18.099]             length <- base::length
[08:28:18.099]             list <- base::list
[08:28:18.099]             seq.int <- base::seq.int
[08:28:18.099]             signalCondition <- base::signalCondition
[08:28:18.099]             sys.calls <- base::sys.calls
[08:28:18.099]             `[[` <- base::`[[`
[08:28:18.099]             `+` <- base::`+`
[08:28:18.099]             `<<-` <- base::`<<-`
[08:28:18.099]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.099]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.099]                   3L)]
[08:28:18.099]             }
[08:28:18.099]             function(cond) {
[08:28:18.099]                 is_error <- inherits(cond, "error")
[08:28:18.099]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.099]                   NULL)
[08:28:18.099]                 if (is_error) {
[08:28:18.099]                   sessionInformation <- function() {
[08:28:18.099]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.099]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.099]                       search = base::search(), system = base::Sys.info())
[08:28:18.099]                   }
[08:28:18.099]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.099]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.099]                     cond$call), session = sessionInformation(), 
[08:28:18.099]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.099]                   signalCondition(cond)
[08:28:18.099]                 }
[08:28:18.099]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.099]                 "immediateCondition"))) {
[08:28:18.099]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.099]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.099]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.099]                   if (TRUE && !signal) {
[08:28:18.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.099]                     {
[08:28:18.099]                       inherits <- base::inherits
[08:28:18.099]                       invokeRestart <- base::invokeRestart
[08:28:18.099]                       is.null <- base::is.null
[08:28:18.099]                       muffled <- FALSE
[08:28:18.099]                       if (inherits(cond, "message")) {
[08:28:18.099]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.099]                         if (muffled) 
[08:28:18.099]                           invokeRestart("muffleMessage")
[08:28:18.099]                       }
[08:28:18.099]                       else if (inherits(cond, "warning")) {
[08:28:18.099]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.099]                         if (muffled) 
[08:28:18.099]                           invokeRestart("muffleWarning")
[08:28:18.099]                       }
[08:28:18.099]                       else if (inherits(cond, "condition")) {
[08:28:18.099]                         if (!is.null(pattern)) {
[08:28:18.099]                           computeRestarts <- base::computeRestarts
[08:28:18.099]                           grepl <- base::grepl
[08:28:18.099]                           restarts <- computeRestarts(cond)
[08:28:18.099]                           for (restart in restarts) {
[08:28:18.099]                             name <- restart$name
[08:28:18.099]                             if (is.null(name)) 
[08:28:18.099]                               next
[08:28:18.099]                             if (!grepl(pattern, name)) 
[08:28:18.099]                               next
[08:28:18.099]                             invokeRestart(restart)
[08:28:18.099]                             muffled <- TRUE
[08:28:18.099]                             break
[08:28:18.099]                           }
[08:28:18.099]                         }
[08:28:18.099]                       }
[08:28:18.099]                       invisible(muffled)
[08:28:18.099]                     }
[08:28:18.099]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.099]                   }
[08:28:18.099]                 }
[08:28:18.099]                 else {
[08:28:18.099]                   if (TRUE) {
[08:28:18.099]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.099]                     {
[08:28:18.099]                       inherits <- base::inherits
[08:28:18.099]                       invokeRestart <- base::invokeRestart
[08:28:18.099]                       is.null <- base::is.null
[08:28:18.099]                       muffled <- FALSE
[08:28:18.099]                       if (inherits(cond, "message")) {
[08:28:18.099]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.099]                         if (muffled) 
[08:28:18.099]                           invokeRestart("muffleMessage")
[08:28:18.099]                       }
[08:28:18.099]                       else if (inherits(cond, "warning")) {
[08:28:18.099]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.099]                         if (muffled) 
[08:28:18.099]                           invokeRestart("muffleWarning")
[08:28:18.099]                       }
[08:28:18.099]                       else if (inherits(cond, "condition")) {
[08:28:18.099]                         if (!is.null(pattern)) {
[08:28:18.099]                           computeRestarts <- base::computeRestarts
[08:28:18.099]                           grepl <- base::grepl
[08:28:18.099]                           restarts <- computeRestarts(cond)
[08:28:18.099]                           for (restart in restarts) {
[08:28:18.099]                             name <- restart$name
[08:28:18.099]                             if (is.null(name)) 
[08:28:18.099]                               next
[08:28:18.099]                             if (!grepl(pattern, name)) 
[08:28:18.099]                               next
[08:28:18.099]                             invokeRestart(restart)
[08:28:18.099]                             muffled <- TRUE
[08:28:18.099]                             break
[08:28:18.099]                           }
[08:28:18.099]                         }
[08:28:18.099]                       }
[08:28:18.099]                       invisible(muffled)
[08:28:18.099]                     }
[08:28:18.099]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.099]                   }
[08:28:18.099]                 }
[08:28:18.099]             }
[08:28:18.099]         }))
[08:28:18.099]     }, error = function(ex) {
[08:28:18.099]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.099]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.099]                 ...future.rng), started = ...future.startTime, 
[08:28:18.099]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.099]             version = "1.8"), class = "FutureResult")
[08:28:18.099]     }, finally = {
[08:28:18.099]         if (!identical(...future.workdir, getwd())) 
[08:28:18.099]             setwd(...future.workdir)
[08:28:18.099]         {
[08:28:18.099]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.099]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.099]             }
[08:28:18.099]             base::options(...future.oldOptions)
[08:28:18.099]             if (.Platform$OS.type == "windows") {
[08:28:18.099]                 old_names <- names(...future.oldEnvVars)
[08:28:18.099]                 envs <- base::Sys.getenv()
[08:28:18.099]                 names <- names(envs)
[08:28:18.099]                 common <- intersect(names, old_names)
[08:28:18.099]                 added <- setdiff(names, old_names)
[08:28:18.099]                 removed <- setdiff(old_names, names)
[08:28:18.099]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.099]                   envs[common]]
[08:28:18.099]                 NAMES <- toupper(changed)
[08:28:18.099]                 args <- list()
[08:28:18.099]                 for (kk in seq_along(NAMES)) {
[08:28:18.099]                   name <- changed[[kk]]
[08:28:18.099]                   NAME <- NAMES[[kk]]
[08:28:18.099]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.099]                     next
[08:28:18.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.099]                 }
[08:28:18.099]                 NAMES <- toupper(added)
[08:28:18.099]                 for (kk in seq_along(NAMES)) {
[08:28:18.099]                   name <- added[[kk]]
[08:28:18.099]                   NAME <- NAMES[[kk]]
[08:28:18.099]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.099]                     next
[08:28:18.099]                   args[[name]] <- ""
[08:28:18.099]                 }
[08:28:18.099]                 NAMES <- toupper(removed)
[08:28:18.099]                 for (kk in seq_along(NAMES)) {
[08:28:18.099]                   name <- removed[[kk]]
[08:28:18.099]                   NAME <- NAMES[[kk]]
[08:28:18.099]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.099]                     next
[08:28:18.099]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.099]                 }
[08:28:18.099]                 if (length(args) > 0) 
[08:28:18.099]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.099]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.099]             }
[08:28:18.099]             else {
[08:28:18.099]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.099]             }
[08:28:18.099]             {
[08:28:18.099]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.099]                   0L) {
[08:28:18.099]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.099]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.099]                   base::options(opts)
[08:28:18.099]                 }
[08:28:18.099]                 {
[08:28:18.099]                   {
[08:28:18.099]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.099]                     NULL
[08:28:18.099]                   }
[08:28:18.099]                   options(future.plan = NULL)
[08:28:18.099]                   if (is.na(NA_character_)) 
[08:28:18.099]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.099]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.099]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.099]                     .init = FALSE)
[08:28:18.099]                 }
[08:28:18.099]             }
[08:28:18.099]         }
[08:28:18.099]     })
[08:28:18.099]     if (TRUE) {
[08:28:18.099]         base::sink(type = "output", split = FALSE)
[08:28:18.099]         if (TRUE) {
[08:28:18.099]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.099]         }
[08:28:18.099]         else {
[08:28:18.099]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.099]         }
[08:28:18.099]         base::close(...future.stdout)
[08:28:18.099]         ...future.stdout <- NULL
[08:28:18.099]     }
[08:28:18.099]     ...future.result$conditions <- ...future.conditions
[08:28:18.099]     ...future.result$finished <- base::Sys.time()
[08:28:18.099]     ...future.result
[08:28:18.099] }
[08:28:18.101] Poll #1 (0): usedNodes() = 2, workers = 2
[08:28:18.112] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.112] - Validating connection of MultisessionFuture
[08:28:18.113] - received message: FutureResult
[08:28:18.113] - Received FutureResult
[08:28:18.113] - Erased future from FutureRegistry
[08:28:18.113] result() for ClusterFuture ...
[08:28:18.113] - result already collected: FutureResult
[08:28:18.113] result() for ClusterFuture ... done
[08:28:18.113] signalConditions() ...
[08:28:18.113]  - include = ‘immediateCondition’
[08:28:18.113]  - exclude = 
[08:28:18.113]  - resignal = FALSE
[08:28:18.114]  - Number of conditions: 1
[08:28:18.114] signalConditions() ... done
[08:28:18.114] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.114] result() for ClusterFuture ...
[08:28:18.114] - result already collected: FutureResult
[08:28:18.114] result() for ClusterFuture ... done
[08:28:18.114] result() for ClusterFuture ...
[08:28:18.114] - result already collected: FutureResult
[08:28:18.114] result() for ClusterFuture ... done
[08:28:18.114] signalConditions() ...
[08:28:18.114]  - include = ‘immediateCondition’
[08:28:18.115]  - exclude = 
[08:28:18.115]  - resignal = FALSE
[08:28:18.115]  - Number of conditions: 1
[08:28:18.115] signalConditions() ... done
[08:28:18.116] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[08:28:18.116] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[08:28:18.116] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[08:28:18.116] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:28:18.117] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:28:18.117] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[08:28:18.118] MultisessionFuture started
[08:28:18.118] - Launch lazy future ... done
[08:28:18.118] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.119] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.119] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.121] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.121] Searching for globals ... DONE
[08:28:18.121] Resolving globals: TRUE
[08:28:18.121] Resolving any globals that are futures ...
[08:28:18.121] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.122] Resolving any globals that are futures ... DONE
[08:28:18.122] Resolving futures part of globals (recursively) ...
[08:28:18.122] resolve() on list ...
[08:28:18.122]  recursive: 99
[08:28:18.125]  length: 2
[08:28:18.125]  elements: ‘a’, ‘ii’
[08:28:18.125]  length: 1 (resolved future 1)
[08:28:18.125]  length: 0 (resolved future 2)
[08:28:18.125] resolve() on list ... DONE
[08:28:18.125] - globals: [2] ‘a’, ‘ii’
[08:28:18.125] Resolving futures part of globals (recursively) ... DONE
[08:28:18.126] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:18.126] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:18.126] - globals: [2] ‘a’, ‘ii’
[08:28:18.126] 
[08:28:18.126] getGlobalsAndPackages() ... DONE
[08:28:18.126] run() for ‘Future’ ...
[08:28:18.127] - state: ‘created’
[08:28:18.127] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.140] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.141] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.141]   - Field: ‘node’
[08:28:18.141]   - Field: ‘label’
[08:28:18.141]   - Field: ‘local’
[08:28:18.141]   - Field: ‘owner’
[08:28:18.141]   - Field: ‘envir’
[08:28:18.141]   - Field: ‘workers’
[08:28:18.141]   - Field: ‘packages’
[08:28:18.141]   - Field: ‘gc’
[08:28:18.141]   - Field: ‘conditions’
[08:28:18.142]   - Field: ‘persistent’
[08:28:18.142]   - Field: ‘expr’
[08:28:18.142]   - Field: ‘uuid’
[08:28:18.142]   - Field: ‘seed’
[08:28:18.142]   - Field: ‘version’
[08:28:18.142]   - Field: ‘result’
[08:28:18.142]   - Field: ‘asynchronous’
[08:28:18.142]   - Field: ‘calls’
[08:28:18.142]   - Field: ‘globals’
[08:28:18.142]   - Field: ‘stdout’
[08:28:18.142]   - Field: ‘earlySignal’
[08:28:18.142]   - Field: ‘lazy’
[08:28:18.143]   - Field: ‘state’
[08:28:18.143] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.143] - Launch lazy future ...
[08:28:18.143] Packages needed by the future expression (n = 0): <none>
[08:28:18.143] Packages needed by future strategies (n = 0): <none>
[08:28:18.143] {
[08:28:18.143]     {
[08:28:18.143]         {
[08:28:18.143]             ...future.startTime <- base::Sys.time()
[08:28:18.143]             {
[08:28:18.143]                 {
[08:28:18.143]                   {
[08:28:18.143]                     {
[08:28:18.143]                       base::local({
[08:28:18.143]                         has_future <- base::requireNamespace("future", 
[08:28:18.143]                           quietly = TRUE)
[08:28:18.143]                         if (has_future) {
[08:28:18.143]                           ns <- base::getNamespace("future")
[08:28:18.143]                           version <- ns[[".package"]][["version"]]
[08:28:18.143]                           if (is.null(version)) 
[08:28:18.143]                             version <- utils::packageVersion("future")
[08:28:18.143]                         }
[08:28:18.143]                         else {
[08:28:18.143]                           version <- NULL
[08:28:18.143]                         }
[08:28:18.143]                         if (!has_future || version < "1.8.0") {
[08:28:18.143]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.143]                             "", base::R.version$version.string), 
[08:28:18.143]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.143]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.143]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.143]                               "release", "version")], collapse = " "), 
[08:28:18.143]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.143]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.143]                             info)
[08:28:18.143]                           info <- base::paste(info, collapse = "; ")
[08:28:18.143]                           if (!has_future) {
[08:28:18.143]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.143]                               info)
[08:28:18.143]                           }
[08:28:18.143]                           else {
[08:28:18.143]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.143]                               info, version)
[08:28:18.143]                           }
[08:28:18.143]                           base::stop(msg)
[08:28:18.143]                         }
[08:28:18.143]                       })
[08:28:18.143]                     }
[08:28:18.143]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.143]                     base::options(mc.cores = 1L)
[08:28:18.143]                   }
[08:28:18.143]                   ...future.strategy.old <- future::plan("list")
[08:28:18.143]                   options(future.plan = NULL)
[08:28:18.143]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.143]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.143]                 }
[08:28:18.143]                 ...future.workdir <- getwd()
[08:28:18.143]             }
[08:28:18.143]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.143]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.143]         }
[08:28:18.143]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.143]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.143]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.143]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.143]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.143]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.143]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.143]             base::names(...future.oldOptions))
[08:28:18.143]     }
[08:28:18.143]     if (FALSE) {
[08:28:18.143]     }
[08:28:18.143]     else {
[08:28:18.143]         if (TRUE) {
[08:28:18.143]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.143]                 open = "w")
[08:28:18.143]         }
[08:28:18.143]         else {
[08:28:18.143]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.143]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.143]         }
[08:28:18.143]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.143]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.143]             base::sink(type = "output", split = FALSE)
[08:28:18.143]             base::close(...future.stdout)
[08:28:18.143]         }, add = TRUE)
[08:28:18.143]     }
[08:28:18.143]     ...future.frame <- base::sys.nframe()
[08:28:18.143]     ...future.conditions <- base::list()
[08:28:18.143]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.143]     if (FALSE) {
[08:28:18.143]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.143]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.143]     }
[08:28:18.143]     ...future.result <- base::tryCatch({
[08:28:18.143]         base::withCallingHandlers({
[08:28:18.143]             ...future.value <- base::withVisible(base::local({
[08:28:18.143]                 ...future.makeSendCondition <- base::local({
[08:28:18.143]                   sendCondition <- NULL
[08:28:18.143]                   function(frame = 1L) {
[08:28:18.143]                     if (is.function(sendCondition)) 
[08:28:18.143]                       return(sendCondition)
[08:28:18.143]                     ns <- getNamespace("parallel")
[08:28:18.143]                     if (exists("sendData", mode = "function", 
[08:28:18.143]                       envir = ns)) {
[08:28:18.143]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.143]                         envir = ns)
[08:28:18.143]                       envir <- sys.frame(frame)
[08:28:18.143]                       master <- NULL
[08:28:18.143]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.143]                         !identical(envir, emptyenv())) {
[08:28:18.143]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.143]                           inherits = FALSE)) {
[08:28:18.143]                           master <- get("master", mode = "list", 
[08:28:18.143]                             envir = envir, inherits = FALSE)
[08:28:18.143]                           if (inherits(master, c("SOCKnode", 
[08:28:18.143]                             "SOCK0node"))) {
[08:28:18.143]                             sendCondition <<- function(cond) {
[08:28:18.143]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.143]                                 success = TRUE)
[08:28:18.143]                               parallel_sendData(master, data)
[08:28:18.143]                             }
[08:28:18.143]                             return(sendCondition)
[08:28:18.143]                           }
[08:28:18.143]                         }
[08:28:18.143]                         frame <- frame + 1L
[08:28:18.143]                         envir <- sys.frame(frame)
[08:28:18.143]                       }
[08:28:18.143]                     }
[08:28:18.143]                     sendCondition <<- function(cond) NULL
[08:28:18.143]                   }
[08:28:18.143]                 })
[08:28:18.143]                 withCallingHandlers({
[08:28:18.143]                   {
[08:28:18.143]                     b <- a * ii
[08:28:18.143]                     a <- 0
[08:28:18.143]                     b
[08:28:18.143]                   }
[08:28:18.143]                 }, immediateCondition = function(cond) {
[08:28:18.143]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.143]                   sendCondition(cond)
[08:28:18.143]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.143]                   {
[08:28:18.143]                     inherits <- base::inherits
[08:28:18.143]                     invokeRestart <- base::invokeRestart
[08:28:18.143]                     is.null <- base::is.null
[08:28:18.143]                     muffled <- FALSE
[08:28:18.143]                     if (inherits(cond, "message")) {
[08:28:18.143]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.143]                       if (muffled) 
[08:28:18.143]                         invokeRestart("muffleMessage")
[08:28:18.143]                     }
[08:28:18.143]                     else if (inherits(cond, "warning")) {
[08:28:18.143]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.143]                       if (muffled) 
[08:28:18.143]                         invokeRestart("muffleWarning")
[08:28:18.143]                     }
[08:28:18.143]                     else if (inherits(cond, "condition")) {
[08:28:18.143]                       if (!is.null(pattern)) {
[08:28:18.143]                         computeRestarts <- base::computeRestarts
[08:28:18.143]                         grepl <- base::grepl
[08:28:18.143]                         restarts <- computeRestarts(cond)
[08:28:18.143]                         for (restart in restarts) {
[08:28:18.143]                           name <- restart$name
[08:28:18.143]                           if (is.null(name)) 
[08:28:18.143]                             next
[08:28:18.143]                           if (!grepl(pattern, name)) 
[08:28:18.143]                             next
[08:28:18.143]                           invokeRestart(restart)
[08:28:18.143]                           muffled <- TRUE
[08:28:18.143]                           break
[08:28:18.143]                         }
[08:28:18.143]                       }
[08:28:18.143]                     }
[08:28:18.143]                     invisible(muffled)
[08:28:18.143]                   }
[08:28:18.143]                   muffleCondition(cond)
[08:28:18.143]                 })
[08:28:18.143]             }))
[08:28:18.143]             future::FutureResult(value = ...future.value$value, 
[08:28:18.143]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.143]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.143]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.143]                     ...future.globalenv.names))
[08:28:18.143]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.143]         }, condition = base::local({
[08:28:18.143]             c <- base::c
[08:28:18.143]             inherits <- base::inherits
[08:28:18.143]             invokeRestart <- base::invokeRestart
[08:28:18.143]             length <- base::length
[08:28:18.143]             list <- base::list
[08:28:18.143]             seq.int <- base::seq.int
[08:28:18.143]             signalCondition <- base::signalCondition
[08:28:18.143]             sys.calls <- base::sys.calls
[08:28:18.143]             `[[` <- base::`[[`
[08:28:18.143]             `+` <- base::`+`
[08:28:18.143]             `<<-` <- base::`<<-`
[08:28:18.143]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.143]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.143]                   3L)]
[08:28:18.143]             }
[08:28:18.143]             function(cond) {
[08:28:18.143]                 is_error <- inherits(cond, "error")
[08:28:18.143]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.143]                   NULL)
[08:28:18.143]                 if (is_error) {
[08:28:18.143]                   sessionInformation <- function() {
[08:28:18.143]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.143]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.143]                       search = base::search(), system = base::Sys.info())
[08:28:18.143]                   }
[08:28:18.143]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.143]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.143]                     cond$call), session = sessionInformation(), 
[08:28:18.143]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.143]                   signalCondition(cond)
[08:28:18.143]                 }
[08:28:18.143]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.143]                 "immediateCondition"))) {
[08:28:18.143]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.143]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.143]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.143]                   if (TRUE && !signal) {
[08:28:18.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.143]                     {
[08:28:18.143]                       inherits <- base::inherits
[08:28:18.143]                       invokeRestart <- base::invokeRestart
[08:28:18.143]                       is.null <- base::is.null
[08:28:18.143]                       muffled <- FALSE
[08:28:18.143]                       if (inherits(cond, "message")) {
[08:28:18.143]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.143]                         if (muffled) 
[08:28:18.143]                           invokeRestart("muffleMessage")
[08:28:18.143]                       }
[08:28:18.143]                       else if (inherits(cond, "warning")) {
[08:28:18.143]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.143]                         if (muffled) 
[08:28:18.143]                           invokeRestart("muffleWarning")
[08:28:18.143]                       }
[08:28:18.143]                       else if (inherits(cond, "condition")) {
[08:28:18.143]                         if (!is.null(pattern)) {
[08:28:18.143]                           computeRestarts <- base::computeRestarts
[08:28:18.143]                           grepl <- base::grepl
[08:28:18.143]                           restarts <- computeRestarts(cond)
[08:28:18.143]                           for (restart in restarts) {
[08:28:18.143]                             name <- restart$name
[08:28:18.143]                             if (is.null(name)) 
[08:28:18.143]                               next
[08:28:18.143]                             if (!grepl(pattern, name)) 
[08:28:18.143]                               next
[08:28:18.143]                             invokeRestart(restart)
[08:28:18.143]                             muffled <- TRUE
[08:28:18.143]                             break
[08:28:18.143]                           }
[08:28:18.143]                         }
[08:28:18.143]                       }
[08:28:18.143]                       invisible(muffled)
[08:28:18.143]                     }
[08:28:18.143]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.143]                   }
[08:28:18.143]                 }
[08:28:18.143]                 else {
[08:28:18.143]                   if (TRUE) {
[08:28:18.143]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.143]                     {
[08:28:18.143]                       inherits <- base::inherits
[08:28:18.143]                       invokeRestart <- base::invokeRestart
[08:28:18.143]                       is.null <- base::is.null
[08:28:18.143]                       muffled <- FALSE
[08:28:18.143]                       if (inherits(cond, "message")) {
[08:28:18.143]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.143]                         if (muffled) 
[08:28:18.143]                           invokeRestart("muffleMessage")
[08:28:18.143]                       }
[08:28:18.143]                       else if (inherits(cond, "warning")) {
[08:28:18.143]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.143]                         if (muffled) 
[08:28:18.143]                           invokeRestart("muffleWarning")
[08:28:18.143]                       }
[08:28:18.143]                       else if (inherits(cond, "condition")) {
[08:28:18.143]                         if (!is.null(pattern)) {
[08:28:18.143]                           computeRestarts <- base::computeRestarts
[08:28:18.143]                           grepl <- base::grepl
[08:28:18.143]                           restarts <- computeRestarts(cond)
[08:28:18.143]                           for (restart in restarts) {
[08:28:18.143]                             name <- restart$name
[08:28:18.143]                             if (is.null(name)) 
[08:28:18.143]                               next
[08:28:18.143]                             if (!grepl(pattern, name)) 
[08:28:18.143]                               next
[08:28:18.143]                             invokeRestart(restart)
[08:28:18.143]                             muffled <- TRUE
[08:28:18.143]                             break
[08:28:18.143]                           }
[08:28:18.143]                         }
[08:28:18.143]                       }
[08:28:18.143]                       invisible(muffled)
[08:28:18.143]                     }
[08:28:18.143]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.143]                   }
[08:28:18.143]                 }
[08:28:18.143]             }
[08:28:18.143]         }))
[08:28:18.143]     }, error = function(ex) {
[08:28:18.143]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.143]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.143]                 ...future.rng), started = ...future.startTime, 
[08:28:18.143]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.143]             version = "1.8"), class = "FutureResult")
[08:28:18.143]     }, finally = {
[08:28:18.143]         if (!identical(...future.workdir, getwd())) 
[08:28:18.143]             setwd(...future.workdir)
[08:28:18.143]         {
[08:28:18.143]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.143]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.143]             }
[08:28:18.143]             base::options(...future.oldOptions)
[08:28:18.143]             if (.Platform$OS.type == "windows") {
[08:28:18.143]                 old_names <- names(...future.oldEnvVars)
[08:28:18.143]                 envs <- base::Sys.getenv()
[08:28:18.143]                 names <- names(envs)
[08:28:18.143]                 common <- intersect(names, old_names)
[08:28:18.143]                 added <- setdiff(names, old_names)
[08:28:18.143]                 removed <- setdiff(old_names, names)
[08:28:18.143]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.143]                   envs[common]]
[08:28:18.143]                 NAMES <- toupper(changed)
[08:28:18.143]                 args <- list()
[08:28:18.143]                 for (kk in seq_along(NAMES)) {
[08:28:18.143]                   name <- changed[[kk]]
[08:28:18.143]                   NAME <- NAMES[[kk]]
[08:28:18.143]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.143]                     next
[08:28:18.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.143]                 }
[08:28:18.143]                 NAMES <- toupper(added)
[08:28:18.143]                 for (kk in seq_along(NAMES)) {
[08:28:18.143]                   name <- added[[kk]]
[08:28:18.143]                   NAME <- NAMES[[kk]]
[08:28:18.143]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.143]                     next
[08:28:18.143]                   args[[name]] <- ""
[08:28:18.143]                 }
[08:28:18.143]                 NAMES <- toupper(removed)
[08:28:18.143]                 for (kk in seq_along(NAMES)) {
[08:28:18.143]                   name <- removed[[kk]]
[08:28:18.143]                   NAME <- NAMES[[kk]]
[08:28:18.143]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.143]                     next
[08:28:18.143]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.143]                 }
[08:28:18.143]                 if (length(args) > 0) 
[08:28:18.143]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.143]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.143]             }
[08:28:18.143]             else {
[08:28:18.143]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.143]             }
[08:28:18.143]             {
[08:28:18.143]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.143]                   0L) {
[08:28:18.143]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.143]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.143]                   base::options(opts)
[08:28:18.143]                 }
[08:28:18.143]                 {
[08:28:18.143]                   {
[08:28:18.143]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.143]                     NULL
[08:28:18.143]                   }
[08:28:18.143]                   options(future.plan = NULL)
[08:28:18.143]                   if (is.na(NA_character_)) 
[08:28:18.143]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.143]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.143]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.143]                     .init = FALSE)
[08:28:18.143]                 }
[08:28:18.143]             }
[08:28:18.143]         }
[08:28:18.143]     })
[08:28:18.143]     if (TRUE) {
[08:28:18.143]         base::sink(type = "output", split = FALSE)
[08:28:18.143]         if (TRUE) {
[08:28:18.143]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.143]         }
[08:28:18.143]         else {
[08:28:18.143]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.143]         }
[08:28:18.143]         base::close(...future.stdout)
[08:28:18.143]         ...future.stdout <- NULL
[08:28:18.143]     }
[08:28:18.143]     ...future.result$conditions <- ...future.conditions
[08:28:18.143]     ...future.result$finished <- base::Sys.time()
[08:28:18.143]     ...future.result
[08:28:18.143] }
[08:28:18.146] Poll #1 (0): usedNodes() = 2, workers = 2
[08:28:18.156] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.157] - Validating connection of MultisessionFuture
[08:28:18.157] - received message: FutureResult
[08:28:18.157] - Received FutureResult
[08:28:18.157] - Erased future from FutureRegistry
[08:28:18.157] result() for ClusterFuture ...
[08:28:18.157] - result already collected: FutureResult
[08:28:18.157] result() for ClusterFuture ... done
[08:28:18.157] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.157] result() for ClusterFuture ...
[08:28:18.158] - result already collected: FutureResult
[08:28:18.158] result() for ClusterFuture ... done
[08:28:18.158] result() for ClusterFuture ...
[08:28:18.158] - result already collected: FutureResult
[08:28:18.158] result() for ClusterFuture ... done
[08:28:18.159] Exporting 2 global objects (382 bytes) to cluster node #2 ...
[08:28:18.159] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[08:28:18.159] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[08:28:18.159] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[08:28:18.160] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[08:28:18.160] Exporting 2 global objects (382 bytes) to cluster node #2 ... DONE
[08:28:18.160] MultisessionFuture started
[08:28:18.161] - Launch lazy future ... done
[08:28:18.161] run() for ‘MultisessionFuture’ ... done
[08:28:18.161] result() for ClusterFuture ...
[08:28:18.161] - result already collected: FutureResult
[08:28:18.161] result() for ClusterFuture ... done
[08:28:18.161] result() for ClusterFuture ...
[08:28:18.161] - result already collected: FutureResult
[08:28:18.161] result() for ClusterFuture ... done
[08:28:18.161] result() for ClusterFuture ...
[08:28:18.162] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.162] - Validating connection of MultisessionFuture
[08:28:18.162] - received message: FutureResult
[08:28:18.162] - Received FutureResult
[08:28:18.162] - Erased future from FutureRegistry
[08:28:18.162] result() for ClusterFuture ...
[08:28:18.162] - result already collected: FutureResult
[08:28:18.162] result() for ClusterFuture ... done
[08:28:18.162] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.162] result() for ClusterFuture ... done
[08:28:18.163] result() for ClusterFuture ...
[08:28:18.163] - result already collected: FutureResult
[08:28:18.163] result() for ClusterFuture ... done
[08:28:18.163] result() for ClusterFuture ...
[08:28:18.163] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.163] - Validating connection of MultisessionFuture
[08:28:18.202] - received message: FutureResult
[08:28:18.202] - Received FutureResult
[08:28:18.202] - Erased future from FutureRegistry
[08:28:18.203] result() for ClusterFuture ...
[08:28:18.203] - result already collected: FutureResult
[08:28:18.203] result() for ClusterFuture ... done
[08:28:18.203] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.203] result() for ClusterFuture ... done
[08:28:18.203] result() for ClusterFuture ...
[08:28:18.203] - result already collected: FutureResult
[08:28:18.203] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.204] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.204] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.206] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.206] Searching for globals ... DONE
[08:28:18.206] Resolving globals: TRUE
[08:28:18.206] Resolving any globals that are futures ...
[08:28:18.206] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.206] Resolving any globals that are futures ... DONE
[08:28:18.207] Resolving futures part of globals (recursively) ...
[08:28:18.207] resolve() on list ...
[08:28:18.207]  recursive: 99
[08:28:18.207]  length: 2
[08:28:18.207]  elements: ‘a’, ‘ii’
[08:28:18.207]  length: 1 (resolved future 1)
[08:28:18.208]  length: 0 (resolved future 2)
[08:28:18.208] resolve() on list ... DONE
[08:28:18.208] - globals: [2] ‘a’, ‘ii’
[08:28:18.208] Resolving futures part of globals (recursively) ... DONE
[08:28:18.208] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:18.208] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:18.208] - globals: [2] ‘a’, ‘ii’
[08:28:18.209] 
[08:28:18.209] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.209] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.210] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.211] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.211] Searching for globals ... DONE
[08:28:18.212] Resolving globals: TRUE
[08:28:18.212] Resolving any globals that are futures ...
[08:28:18.212] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.212] Resolving any globals that are futures ... DONE
[08:28:18.212] Resolving futures part of globals (recursively) ...
[08:28:18.212] resolve() on list ...
[08:28:18.212]  recursive: 99
[08:28:18.213]  length: 2
[08:28:18.213]  elements: ‘a’, ‘ii’
[08:28:18.213]  length: 1 (resolved future 1)
[08:28:18.213]  length: 0 (resolved future 2)
[08:28:18.213] resolve() on list ... DONE
[08:28:18.213] - globals: [2] ‘a’, ‘ii’
[08:28:18.213] Resolving futures part of globals (recursively) ... DONE
[08:28:18.213] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:18.214] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:18.214] - globals: [2] ‘a’, ‘ii’
[08:28:18.214] 
[08:28:18.214] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.215] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.215] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.216] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.217] Searching for globals ... DONE
[08:28:18.217] Resolving globals: TRUE
[08:28:18.217] Resolving any globals that are futures ...
[08:28:18.217] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[08:28:18.217] Resolving any globals that are futures ... DONE
[08:28:18.217] Resolving futures part of globals (recursively) ...
[08:28:18.218] resolve() on list ...
[08:28:18.218]  recursive: 99
[08:28:18.218]  length: 2
[08:28:18.218]  elements: ‘a’, ‘ii’
[08:28:18.218]  length: 1 (resolved future 1)
[08:28:18.218]  length: 0 (resolved future 2)
[08:28:18.218] resolve() on list ... DONE
[08:28:18.218] - globals: [2] ‘a’, ‘ii’
[08:28:18.218] Resolving futures part of globals (recursively) ... DONE
[08:28:18.218] The total size of the 2 globals is 74 bytes (74 bytes)
[08:28:18.219] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[08:28:18.219] - globals: [2] ‘a’, ‘ii’
[08:28:18.219] 
[08:28:18.219] getGlobalsAndPackages() ... DONE
[08:28:18.219] run() for ‘Future’ ...
[08:28:18.219] - state: ‘created’
[08:28:18.220] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.234] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.234] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.234]   - Field: ‘node’
[08:28:18.234]   - Field: ‘label’
[08:28:18.234]   - Field: ‘local’
[08:28:18.234]   - Field: ‘owner’
[08:28:18.234]   - Field: ‘envir’
[08:28:18.234]   - Field: ‘workers’
[08:28:18.234]   - Field: ‘packages’
[08:28:18.235]   - Field: ‘gc’
[08:28:18.235]   - Field: ‘conditions’
[08:28:18.235]   - Field: ‘persistent’
[08:28:18.235]   - Field: ‘expr’
[08:28:18.235]   - Field: ‘uuid’
[08:28:18.235]   - Field: ‘seed’
[08:28:18.235]   - Field: ‘version’
[08:28:18.235]   - Field: ‘result’
[08:28:18.235]   - Field: ‘asynchronous’
[08:28:18.235]   - Field: ‘calls’
[08:28:18.235]   - Field: ‘globals’
[08:28:18.236]   - Field: ‘stdout’
[08:28:18.236]   - Field: ‘earlySignal’
[08:28:18.236]   - Field: ‘lazy’
[08:28:18.236]   - Field: ‘state’
[08:28:18.236] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.236] - Launch lazy future ...
[08:28:18.236] Packages needed by the future expression (n = 0): <none>
[08:28:18.236] Packages needed by future strategies (n = 0): <none>
[08:28:18.237] {
[08:28:18.237]     {
[08:28:18.237]         {
[08:28:18.237]             ...future.startTime <- base::Sys.time()
[08:28:18.237]             {
[08:28:18.237]                 {
[08:28:18.237]                   {
[08:28:18.237]                     {
[08:28:18.237]                       base::local({
[08:28:18.237]                         has_future <- base::requireNamespace("future", 
[08:28:18.237]                           quietly = TRUE)
[08:28:18.237]                         if (has_future) {
[08:28:18.237]                           ns <- base::getNamespace("future")
[08:28:18.237]                           version <- ns[[".package"]][["version"]]
[08:28:18.237]                           if (is.null(version)) 
[08:28:18.237]                             version <- utils::packageVersion("future")
[08:28:18.237]                         }
[08:28:18.237]                         else {
[08:28:18.237]                           version <- NULL
[08:28:18.237]                         }
[08:28:18.237]                         if (!has_future || version < "1.8.0") {
[08:28:18.237]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.237]                             "", base::R.version$version.string), 
[08:28:18.237]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.237]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.237]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.237]                               "release", "version")], collapse = " "), 
[08:28:18.237]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.237]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.237]                             info)
[08:28:18.237]                           info <- base::paste(info, collapse = "; ")
[08:28:18.237]                           if (!has_future) {
[08:28:18.237]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.237]                               info)
[08:28:18.237]                           }
[08:28:18.237]                           else {
[08:28:18.237]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.237]                               info, version)
[08:28:18.237]                           }
[08:28:18.237]                           base::stop(msg)
[08:28:18.237]                         }
[08:28:18.237]                       })
[08:28:18.237]                     }
[08:28:18.237]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.237]                     base::options(mc.cores = 1L)
[08:28:18.237]                   }
[08:28:18.237]                   ...future.strategy.old <- future::plan("list")
[08:28:18.237]                   options(future.plan = NULL)
[08:28:18.237]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.237]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.237]                 }
[08:28:18.237]                 ...future.workdir <- getwd()
[08:28:18.237]             }
[08:28:18.237]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.237]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.237]         }
[08:28:18.237]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.237]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.237]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.237]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.237]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.237]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.237]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.237]             base::names(...future.oldOptions))
[08:28:18.237]     }
[08:28:18.237]     if (FALSE) {
[08:28:18.237]     }
[08:28:18.237]     else {
[08:28:18.237]         if (TRUE) {
[08:28:18.237]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.237]                 open = "w")
[08:28:18.237]         }
[08:28:18.237]         else {
[08:28:18.237]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.237]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.237]         }
[08:28:18.237]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.237]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.237]             base::sink(type = "output", split = FALSE)
[08:28:18.237]             base::close(...future.stdout)
[08:28:18.237]         }, add = TRUE)
[08:28:18.237]     }
[08:28:18.237]     ...future.frame <- base::sys.nframe()
[08:28:18.237]     ...future.conditions <- base::list()
[08:28:18.237]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.237]     if (FALSE) {
[08:28:18.237]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.237]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.237]     }
[08:28:18.237]     ...future.result <- base::tryCatch({
[08:28:18.237]         base::withCallingHandlers({
[08:28:18.237]             ...future.value <- base::withVisible(base::local({
[08:28:18.237]                 ...future.makeSendCondition <- base::local({
[08:28:18.237]                   sendCondition <- NULL
[08:28:18.237]                   function(frame = 1L) {
[08:28:18.237]                     if (is.function(sendCondition)) 
[08:28:18.237]                       return(sendCondition)
[08:28:18.237]                     ns <- getNamespace("parallel")
[08:28:18.237]                     if (exists("sendData", mode = "function", 
[08:28:18.237]                       envir = ns)) {
[08:28:18.237]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.237]                         envir = ns)
[08:28:18.237]                       envir <- sys.frame(frame)
[08:28:18.237]                       master <- NULL
[08:28:18.237]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.237]                         !identical(envir, emptyenv())) {
[08:28:18.237]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.237]                           inherits = FALSE)) {
[08:28:18.237]                           master <- get("master", mode = "list", 
[08:28:18.237]                             envir = envir, inherits = FALSE)
[08:28:18.237]                           if (inherits(master, c("SOCKnode", 
[08:28:18.237]                             "SOCK0node"))) {
[08:28:18.237]                             sendCondition <<- function(cond) {
[08:28:18.237]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.237]                                 success = TRUE)
[08:28:18.237]                               parallel_sendData(master, data)
[08:28:18.237]                             }
[08:28:18.237]                             return(sendCondition)
[08:28:18.237]                           }
[08:28:18.237]                         }
[08:28:18.237]                         frame <- frame + 1L
[08:28:18.237]                         envir <- sys.frame(frame)
[08:28:18.237]                       }
[08:28:18.237]                     }
[08:28:18.237]                     sendCondition <<- function(cond) NULL
[08:28:18.237]                   }
[08:28:18.237]                 })
[08:28:18.237]                 withCallingHandlers({
[08:28:18.237]                   {
[08:28:18.237]                     b <- a * ii
[08:28:18.237]                     a <- 0
[08:28:18.237]                     b
[08:28:18.237]                   }
[08:28:18.237]                 }, immediateCondition = function(cond) {
[08:28:18.237]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.237]                   sendCondition(cond)
[08:28:18.237]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.237]                   {
[08:28:18.237]                     inherits <- base::inherits
[08:28:18.237]                     invokeRestart <- base::invokeRestart
[08:28:18.237]                     is.null <- base::is.null
[08:28:18.237]                     muffled <- FALSE
[08:28:18.237]                     if (inherits(cond, "message")) {
[08:28:18.237]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.237]                       if (muffled) 
[08:28:18.237]                         invokeRestart("muffleMessage")
[08:28:18.237]                     }
[08:28:18.237]                     else if (inherits(cond, "warning")) {
[08:28:18.237]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.237]                       if (muffled) 
[08:28:18.237]                         invokeRestart("muffleWarning")
[08:28:18.237]                     }
[08:28:18.237]                     else if (inherits(cond, "condition")) {
[08:28:18.237]                       if (!is.null(pattern)) {
[08:28:18.237]                         computeRestarts <- base::computeRestarts
[08:28:18.237]                         grepl <- base::grepl
[08:28:18.237]                         restarts <- computeRestarts(cond)
[08:28:18.237]                         for (restart in restarts) {
[08:28:18.237]                           name <- restart$name
[08:28:18.237]                           if (is.null(name)) 
[08:28:18.237]                             next
[08:28:18.237]                           if (!grepl(pattern, name)) 
[08:28:18.237]                             next
[08:28:18.237]                           invokeRestart(restart)
[08:28:18.237]                           muffled <- TRUE
[08:28:18.237]                           break
[08:28:18.237]                         }
[08:28:18.237]                       }
[08:28:18.237]                     }
[08:28:18.237]                     invisible(muffled)
[08:28:18.237]                   }
[08:28:18.237]                   muffleCondition(cond)
[08:28:18.237]                 })
[08:28:18.237]             }))
[08:28:18.237]             future::FutureResult(value = ...future.value$value, 
[08:28:18.237]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.237]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.237]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.237]                     ...future.globalenv.names))
[08:28:18.237]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.237]         }, condition = base::local({
[08:28:18.237]             c <- base::c
[08:28:18.237]             inherits <- base::inherits
[08:28:18.237]             invokeRestart <- base::invokeRestart
[08:28:18.237]             length <- base::length
[08:28:18.237]             list <- base::list
[08:28:18.237]             seq.int <- base::seq.int
[08:28:18.237]             signalCondition <- base::signalCondition
[08:28:18.237]             sys.calls <- base::sys.calls
[08:28:18.237]             `[[` <- base::`[[`
[08:28:18.237]             `+` <- base::`+`
[08:28:18.237]             `<<-` <- base::`<<-`
[08:28:18.237]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.237]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.237]                   3L)]
[08:28:18.237]             }
[08:28:18.237]             function(cond) {
[08:28:18.237]                 is_error <- inherits(cond, "error")
[08:28:18.237]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.237]                   NULL)
[08:28:18.237]                 if (is_error) {
[08:28:18.237]                   sessionInformation <- function() {
[08:28:18.237]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.237]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.237]                       search = base::search(), system = base::Sys.info())
[08:28:18.237]                   }
[08:28:18.237]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.237]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.237]                     cond$call), session = sessionInformation(), 
[08:28:18.237]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.237]                   signalCondition(cond)
[08:28:18.237]                 }
[08:28:18.237]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.237]                 "immediateCondition"))) {
[08:28:18.237]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.237]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.237]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.237]                   if (TRUE && !signal) {
[08:28:18.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.237]                     {
[08:28:18.237]                       inherits <- base::inherits
[08:28:18.237]                       invokeRestart <- base::invokeRestart
[08:28:18.237]                       is.null <- base::is.null
[08:28:18.237]                       muffled <- FALSE
[08:28:18.237]                       if (inherits(cond, "message")) {
[08:28:18.237]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.237]                         if (muffled) 
[08:28:18.237]                           invokeRestart("muffleMessage")
[08:28:18.237]                       }
[08:28:18.237]                       else if (inherits(cond, "warning")) {
[08:28:18.237]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.237]                         if (muffled) 
[08:28:18.237]                           invokeRestart("muffleWarning")
[08:28:18.237]                       }
[08:28:18.237]                       else if (inherits(cond, "condition")) {
[08:28:18.237]                         if (!is.null(pattern)) {
[08:28:18.237]                           computeRestarts <- base::computeRestarts
[08:28:18.237]                           grepl <- base::grepl
[08:28:18.237]                           restarts <- computeRestarts(cond)
[08:28:18.237]                           for (restart in restarts) {
[08:28:18.237]                             name <- restart$name
[08:28:18.237]                             if (is.null(name)) 
[08:28:18.237]                               next
[08:28:18.237]                             if (!grepl(pattern, name)) 
[08:28:18.237]                               next
[08:28:18.237]                             invokeRestart(restart)
[08:28:18.237]                             muffled <- TRUE
[08:28:18.237]                             break
[08:28:18.237]                           }
[08:28:18.237]                         }
[08:28:18.237]                       }
[08:28:18.237]                       invisible(muffled)
[08:28:18.237]                     }
[08:28:18.237]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.237]                   }
[08:28:18.237]                 }
[08:28:18.237]                 else {
[08:28:18.237]                   if (TRUE) {
[08:28:18.237]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.237]                     {
[08:28:18.237]                       inherits <- base::inherits
[08:28:18.237]                       invokeRestart <- base::invokeRestart
[08:28:18.237]                       is.null <- base::is.null
[08:28:18.237]                       muffled <- FALSE
[08:28:18.237]                       if (inherits(cond, "message")) {
[08:28:18.237]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.237]                         if (muffled) 
[08:28:18.237]                           invokeRestart("muffleMessage")
[08:28:18.237]                       }
[08:28:18.237]                       else if (inherits(cond, "warning")) {
[08:28:18.237]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.237]                         if (muffled) 
[08:28:18.237]                           invokeRestart("muffleWarning")
[08:28:18.237]                       }
[08:28:18.237]                       else if (inherits(cond, "condition")) {
[08:28:18.237]                         if (!is.null(pattern)) {
[08:28:18.237]                           computeRestarts <- base::computeRestarts
[08:28:18.237]                           grepl <- base::grepl
[08:28:18.237]                           restarts <- computeRestarts(cond)
[08:28:18.237]                           for (restart in restarts) {
[08:28:18.237]                             name <- restart$name
[08:28:18.237]                             if (is.null(name)) 
[08:28:18.237]                               next
[08:28:18.237]                             if (!grepl(pattern, name)) 
[08:28:18.237]                               next
[08:28:18.237]                             invokeRestart(restart)
[08:28:18.237]                             muffled <- TRUE
[08:28:18.237]                             break
[08:28:18.237]                           }
[08:28:18.237]                         }
[08:28:18.237]                       }
[08:28:18.237]                       invisible(muffled)
[08:28:18.237]                     }
[08:28:18.237]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.237]                   }
[08:28:18.237]                 }
[08:28:18.237]             }
[08:28:18.237]         }))
[08:28:18.237]     }, error = function(ex) {
[08:28:18.237]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.237]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.237]                 ...future.rng), started = ...future.startTime, 
[08:28:18.237]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.237]             version = "1.8"), class = "FutureResult")
[08:28:18.237]     }, finally = {
[08:28:18.237]         if (!identical(...future.workdir, getwd())) 
[08:28:18.237]             setwd(...future.workdir)
[08:28:18.237]         {
[08:28:18.237]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.237]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.237]             }
[08:28:18.237]             base::options(...future.oldOptions)
[08:28:18.237]             if (.Platform$OS.type == "windows") {
[08:28:18.237]                 old_names <- names(...future.oldEnvVars)
[08:28:18.237]                 envs <- base::Sys.getenv()
[08:28:18.237]                 names <- names(envs)
[08:28:18.237]                 common <- intersect(names, old_names)
[08:28:18.237]                 added <- setdiff(names, old_names)
[08:28:18.237]                 removed <- setdiff(old_names, names)
[08:28:18.237]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.237]                   envs[common]]
[08:28:18.237]                 NAMES <- toupper(changed)
[08:28:18.237]                 args <- list()
[08:28:18.237]                 for (kk in seq_along(NAMES)) {
[08:28:18.237]                   name <- changed[[kk]]
[08:28:18.237]                   NAME <- NAMES[[kk]]
[08:28:18.237]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.237]                     next
[08:28:18.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.237]                 }
[08:28:18.237]                 NAMES <- toupper(added)
[08:28:18.237]                 for (kk in seq_along(NAMES)) {
[08:28:18.237]                   name <- added[[kk]]
[08:28:18.237]                   NAME <- NAMES[[kk]]
[08:28:18.237]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.237]                     next
[08:28:18.237]                   args[[name]] <- ""
[08:28:18.237]                 }
[08:28:18.237]                 NAMES <- toupper(removed)
[08:28:18.237]                 for (kk in seq_along(NAMES)) {
[08:28:18.237]                   name <- removed[[kk]]
[08:28:18.237]                   NAME <- NAMES[[kk]]
[08:28:18.237]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.237]                     next
[08:28:18.237]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.237]                 }
[08:28:18.237]                 if (length(args) > 0) 
[08:28:18.237]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.237]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.237]             }
[08:28:18.237]             else {
[08:28:18.237]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.237]             }
[08:28:18.237]             {
[08:28:18.237]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.237]                   0L) {
[08:28:18.237]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.237]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.237]                   base::options(opts)
[08:28:18.237]                 }
[08:28:18.237]                 {
[08:28:18.237]                   {
[08:28:18.237]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.237]                     NULL
[08:28:18.237]                   }
[08:28:18.237]                   options(future.plan = NULL)
[08:28:18.237]                   if (is.na(NA_character_)) 
[08:28:18.237]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.237]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.237]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.237]                     .init = FALSE)
[08:28:18.237]                 }
[08:28:18.237]             }
[08:28:18.237]         }
[08:28:18.237]     })
[08:28:18.237]     if (TRUE) {
[08:28:18.237]         base::sink(type = "output", split = FALSE)
[08:28:18.237]         if (TRUE) {
[08:28:18.237]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.237]         }
[08:28:18.237]         else {
[08:28:18.237]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.237]         }
[08:28:18.237]         base::close(...future.stdout)
[08:28:18.237]         ...future.stdout <- NULL
[08:28:18.237]     }
[08:28:18.237]     ...future.result$conditions <- ...future.conditions
[08:28:18.237]     ...future.result$finished <- base::Sys.time()
[08:28:18.237]     ...future.result
[08:28:18.237] }
[08:28:18.240] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[08:28:18.240] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[08:28:18.240] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[08:28:18.240] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:28:18.241] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:28:18.241] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[08:28:18.241] MultisessionFuture started
[08:28:18.241] - Launch lazy future ... done
[08:28:18.241] run() for ‘MultisessionFuture’ ... done
[08:28:18.241] result() for ClusterFuture ...
[08:28:18.242] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.242] - Validating connection of MultisessionFuture
[08:28:18.283] - received message: FutureResult
[08:28:18.283] - Received FutureResult
[08:28:18.283] - Erased future from FutureRegistry
[08:28:18.284] result() for ClusterFuture ...
[08:28:18.284] - result already collected: FutureResult
[08:28:18.284] result() for ClusterFuture ... done
[08:28:18.284] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.284] result() for ClusterFuture ... done
[08:28:18.284] result() for ClusterFuture ...
[08:28:18.284] - result already collected: FutureResult
[08:28:18.284] result() for ClusterFuture ... done
[08:28:18.284] run() for ‘Future’ ...
[08:28:18.284] - state: ‘created’
[08:28:18.285] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.299] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.299] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.299]   - Field: ‘node’
[08:28:18.299]   - Field: ‘label’
[08:28:18.299]   - Field: ‘local’
[08:28:18.299]   - Field: ‘owner’
[08:28:18.299]   - Field: ‘envir’
[08:28:18.299]   - Field: ‘workers’
[08:28:18.300]   - Field: ‘packages’
[08:28:18.300]   - Field: ‘gc’
[08:28:18.300]   - Field: ‘conditions’
[08:28:18.300]   - Field: ‘persistent’
[08:28:18.300]   - Field: ‘expr’
[08:28:18.300]   - Field: ‘uuid’
[08:28:18.300]   - Field: ‘seed’
[08:28:18.300]   - Field: ‘version’
[08:28:18.300]   - Field: ‘result’
[08:28:18.300]   - Field: ‘asynchronous’
[08:28:18.300]   - Field: ‘calls’
[08:28:18.300]   - Field: ‘globals’
[08:28:18.301]   - Field: ‘stdout’
[08:28:18.301]   - Field: ‘earlySignal’
[08:28:18.301]   - Field: ‘lazy’
[08:28:18.301]   - Field: ‘state’
[08:28:18.301] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.301] - Launch lazy future ...
[08:28:18.301] Packages needed by the future expression (n = 0): <none>
[08:28:18.301] Packages needed by future strategies (n = 0): <none>
[08:28:18.302] {
[08:28:18.302]     {
[08:28:18.302]         {
[08:28:18.302]             ...future.startTime <- base::Sys.time()
[08:28:18.302]             {
[08:28:18.302]                 {
[08:28:18.302]                   {
[08:28:18.302]                     {
[08:28:18.302]                       base::local({
[08:28:18.302]                         has_future <- base::requireNamespace("future", 
[08:28:18.302]                           quietly = TRUE)
[08:28:18.302]                         if (has_future) {
[08:28:18.302]                           ns <- base::getNamespace("future")
[08:28:18.302]                           version <- ns[[".package"]][["version"]]
[08:28:18.302]                           if (is.null(version)) 
[08:28:18.302]                             version <- utils::packageVersion("future")
[08:28:18.302]                         }
[08:28:18.302]                         else {
[08:28:18.302]                           version <- NULL
[08:28:18.302]                         }
[08:28:18.302]                         if (!has_future || version < "1.8.0") {
[08:28:18.302]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.302]                             "", base::R.version$version.string), 
[08:28:18.302]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.302]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.302]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.302]                               "release", "version")], collapse = " "), 
[08:28:18.302]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.302]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.302]                             info)
[08:28:18.302]                           info <- base::paste(info, collapse = "; ")
[08:28:18.302]                           if (!has_future) {
[08:28:18.302]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.302]                               info)
[08:28:18.302]                           }
[08:28:18.302]                           else {
[08:28:18.302]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.302]                               info, version)
[08:28:18.302]                           }
[08:28:18.302]                           base::stop(msg)
[08:28:18.302]                         }
[08:28:18.302]                       })
[08:28:18.302]                     }
[08:28:18.302]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.302]                     base::options(mc.cores = 1L)
[08:28:18.302]                   }
[08:28:18.302]                   ...future.strategy.old <- future::plan("list")
[08:28:18.302]                   options(future.plan = NULL)
[08:28:18.302]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.302]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.302]                 }
[08:28:18.302]                 ...future.workdir <- getwd()
[08:28:18.302]             }
[08:28:18.302]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.302]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.302]         }
[08:28:18.302]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.302]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.302]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.302]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.302]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.302]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.302]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.302]             base::names(...future.oldOptions))
[08:28:18.302]     }
[08:28:18.302]     if (FALSE) {
[08:28:18.302]     }
[08:28:18.302]     else {
[08:28:18.302]         if (TRUE) {
[08:28:18.302]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.302]                 open = "w")
[08:28:18.302]         }
[08:28:18.302]         else {
[08:28:18.302]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.302]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.302]         }
[08:28:18.302]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.302]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.302]             base::sink(type = "output", split = FALSE)
[08:28:18.302]             base::close(...future.stdout)
[08:28:18.302]         }, add = TRUE)
[08:28:18.302]     }
[08:28:18.302]     ...future.frame <- base::sys.nframe()
[08:28:18.302]     ...future.conditions <- base::list()
[08:28:18.302]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.302]     if (FALSE) {
[08:28:18.302]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.302]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.302]     }
[08:28:18.302]     ...future.result <- base::tryCatch({
[08:28:18.302]         base::withCallingHandlers({
[08:28:18.302]             ...future.value <- base::withVisible(base::local({
[08:28:18.302]                 ...future.makeSendCondition <- base::local({
[08:28:18.302]                   sendCondition <- NULL
[08:28:18.302]                   function(frame = 1L) {
[08:28:18.302]                     if (is.function(sendCondition)) 
[08:28:18.302]                       return(sendCondition)
[08:28:18.302]                     ns <- getNamespace("parallel")
[08:28:18.302]                     if (exists("sendData", mode = "function", 
[08:28:18.302]                       envir = ns)) {
[08:28:18.302]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.302]                         envir = ns)
[08:28:18.302]                       envir <- sys.frame(frame)
[08:28:18.302]                       master <- NULL
[08:28:18.302]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.302]                         !identical(envir, emptyenv())) {
[08:28:18.302]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.302]                           inherits = FALSE)) {
[08:28:18.302]                           master <- get("master", mode = "list", 
[08:28:18.302]                             envir = envir, inherits = FALSE)
[08:28:18.302]                           if (inherits(master, c("SOCKnode", 
[08:28:18.302]                             "SOCK0node"))) {
[08:28:18.302]                             sendCondition <<- function(cond) {
[08:28:18.302]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.302]                                 success = TRUE)
[08:28:18.302]                               parallel_sendData(master, data)
[08:28:18.302]                             }
[08:28:18.302]                             return(sendCondition)
[08:28:18.302]                           }
[08:28:18.302]                         }
[08:28:18.302]                         frame <- frame + 1L
[08:28:18.302]                         envir <- sys.frame(frame)
[08:28:18.302]                       }
[08:28:18.302]                     }
[08:28:18.302]                     sendCondition <<- function(cond) NULL
[08:28:18.302]                   }
[08:28:18.302]                 })
[08:28:18.302]                 withCallingHandlers({
[08:28:18.302]                   {
[08:28:18.302]                     b <- a * ii
[08:28:18.302]                     a <- 0
[08:28:18.302]                     b
[08:28:18.302]                   }
[08:28:18.302]                 }, immediateCondition = function(cond) {
[08:28:18.302]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.302]                   sendCondition(cond)
[08:28:18.302]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.302]                   {
[08:28:18.302]                     inherits <- base::inherits
[08:28:18.302]                     invokeRestart <- base::invokeRestart
[08:28:18.302]                     is.null <- base::is.null
[08:28:18.302]                     muffled <- FALSE
[08:28:18.302]                     if (inherits(cond, "message")) {
[08:28:18.302]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.302]                       if (muffled) 
[08:28:18.302]                         invokeRestart("muffleMessage")
[08:28:18.302]                     }
[08:28:18.302]                     else if (inherits(cond, "warning")) {
[08:28:18.302]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.302]                       if (muffled) 
[08:28:18.302]                         invokeRestart("muffleWarning")
[08:28:18.302]                     }
[08:28:18.302]                     else if (inherits(cond, "condition")) {
[08:28:18.302]                       if (!is.null(pattern)) {
[08:28:18.302]                         computeRestarts <- base::computeRestarts
[08:28:18.302]                         grepl <- base::grepl
[08:28:18.302]                         restarts <- computeRestarts(cond)
[08:28:18.302]                         for (restart in restarts) {
[08:28:18.302]                           name <- restart$name
[08:28:18.302]                           if (is.null(name)) 
[08:28:18.302]                             next
[08:28:18.302]                           if (!grepl(pattern, name)) 
[08:28:18.302]                             next
[08:28:18.302]                           invokeRestart(restart)
[08:28:18.302]                           muffled <- TRUE
[08:28:18.302]                           break
[08:28:18.302]                         }
[08:28:18.302]                       }
[08:28:18.302]                     }
[08:28:18.302]                     invisible(muffled)
[08:28:18.302]                   }
[08:28:18.302]                   muffleCondition(cond)
[08:28:18.302]                 })
[08:28:18.302]             }))
[08:28:18.302]             future::FutureResult(value = ...future.value$value, 
[08:28:18.302]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.302]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.302]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.302]                     ...future.globalenv.names))
[08:28:18.302]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.302]         }, condition = base::local({
[08:28:18.302]             c <- base::c
[08:28:18.302]             inherits <- base::inherits
[08:28:18.302]             invokeRestart <- base::invokeRestart
[08:28:18.302]             length <- base::length
[08:28:18.302]             list <- base::list
[08:28:18.302]             seq.int <- base::seq.int
[08:28:18.302]             signalCondition <- base::signalCondition
[08:28:18.302]             sys.calls <- base::sys.calls
[08:28:18.302]             `[[` <- base::`[[`
[08:28:18.302]             `+` <- base::`+`
[08:28:18.302]             `<<-` <- base::`<<-`
[08:28:18.302]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.302]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.302]                   3L)]
[08:28:18.302]             }
[08:28:18.302]             function(cond) {
[08:28:18.302]                 is_error <- inherits(cond, "error")
[08:28:18.302]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.302]                   NULL)
[08:28:18.302]                 if (is_error) {
[08:28:18.302]                   sessionInformation <- function() {
[08:28:18.302]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.302]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.302]                       search = base::search(), system = base::Sys.info())
[08:28:18.302]                   }
[08:28:18.302]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.302]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.302]                     cond$call), session = sessionInformation(), 
[08:28:18.302]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.302]                   signalCondition(cond)
[08:28:18.302]                 }
[08:28:18.302]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.302]                 "immediateCondition"))) {
[08:28:18.302]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.302]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.302]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.302]                   if (TRUE && !signal) {
[08:28:18.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.302]                     {
[08:28:18.302]                       inherits <- base::inherits
[08:28:18.302]                       invokeRestart <- base::invokeRestart
[08:28:18.302]                       is.null <- base::is.null
[08:28:18.302]                       muffled <- FALSE
[08:28:18.302]                       if (inherits(cond, "message")) {
[08:28:18.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.302]                         if (muffled) 
[08:28:18.302]                           invokeRestart("muffleMessage")
[08:28:18.302]                       }
[08:28:18.302]                       else if (inherits(cond, "warning")) {
[08:28:18.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.302]                         if (muffled) 
[08:28:18.302]                           invokeRestart("muffleWarning")
[08:28:18.302]                       }
[08:28:18.302]                       else if (inherits(cond, "condition")) {
[08:28:18.302]                         if (!is.null(pattern)) {
[08:28:18.302]                           computeRestarts <- base::computeRestarts
[08:28:18.302]                           grepl <- base::grepl
[08:28:18.302]                           restarts <- computeRestarts(cond)
[08:28:18.302]                           for (restart in restarts) {
[08:28:18.302]                             name <- restart$name
[08:28:18.302]                             if (is.null(name)) 
[08:28:18.302]                               next
[08:28:18.302]                             if (!grepl(pattern, name)) 
[08:28:18.302]                               next
[08:28:18.302]                             invokeRestart(restart)
[08:28:18.302]                             muffled <- TRUE
[08:28:18.302]                             break
[08:28:18.302]                           }
[08:28:18.302]                         }
[08:28:18.302]                       }
[08:28:18.302]                       invisible(muffled)
[08:28:18.302]                     }
[08:28:18.302]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.302]                   }
[08:28:18.302]                 }
[08:28:18.302]                 else {
[08:28:18.302]                   if (TRUE) {
[08:28:18.302]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.302]                     {
[08:28:18.302]                       inherits <- base::inherits
[08:28:18.302]                       invokeRestart <- base::invokeRestart
[08:28:18.302]                       is.null <- base::is.null
[08:28:18.302]                       muffled <- FALSE
[08:28:18.302]                       if (inherits(cond, "message")) {
[08:28:18.302]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.302]                         if (muffled) 
[08:28:18.302]                           invokeRestart("muffleMessage")
[08:28:18.302]                       }
[08:28:18.302]                       else if (inherits(cond, "warning")) {
[08:28:18.302]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.302]                         if (muffled) 
[08:28:18.302]                           invokeRestart("muffleWarning")
[08:28:18.302]                       }
[08:28:18.302]                       else if (inherits(cond, "condition")) {
[08:28:18.302]                         if (!is.null(pattern)) {
[08:28:18.302]                           computeRestarts <- base::computeRestarts
[08:28:18.302]                           grepl <- base::grepl
[08:28:18.302]                           restarts <- computeRestarts(cond)
[08:28:18.302]                           for (restart in restarts) {
[08:28:18.302]                             name <- restart$name
[08:28:18.302]                             if (is.null(name)) 
[08:28:18.302]                               next
[08:28:18.302]                             if (!grepl(pattern, name)) 
[08:28:18.302]                               next
[08:28:18.302]                             invokeRestart(restart)
[08:28:18.302]                             muffled <- TRUE
[08:28:18.302]                             break
[08:28:18.302]                           }
[08:28:18.302]                         }
[08:28:18.302]                       }
[08:28:18.302]                       invisible(muffled)
[08:28:18.302]                     }
[08:28:18.302]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.302]                   }
[08:28:18.302]                 }
[08:28:18.302]             }
[08:28:18.302]         }))
[08:28:18.302]     }, error = function(ex) {
[08:28:18.302]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.302]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.302]                 ...future.rng), started = ...future.startTime, 
[08:28:18.302]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.302]             version = "1.8"), class = "FutureResult")
[08:28:18.302]     }, finally = {
[08:28:18.302]         if (!identical(...future.workdir, getwd())) 
[08:28:18.302]             setwd(...future.workdir)
[08:28:18.302]         {
[08:28:18.302]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.302]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.302]             }
[08:28:18.302]             base::options(...future.oldOptions)
[08:28:18.302]             if (.Platform$OS.type == "windows") {
[08:28:18.302]                 old_names <- names(...future.oldEnvVars)
[08:28:18.302]                 envs <- base::Sys.getenv()
[08:28:18.302]                 names <- names(envs)
[08:28:18.302]                 common <- intersect(names, old_names)
[08:28:18.302]                 added <- setdiff(names, old_names)
[08:28:18.302]                 removed <- setdiff(old_names, names)
[08:28:18.302]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.302]                   envs[common]]
[08:28:18.302]                 NAMES <- toupper(changed)
[08:28:18.302]                 args <- list()
[08:28:18.302]                 for (kk in seq_along(NAMES)) {
[08:28:18.302]                   name <- changed[[kk]]
[08:28:18.302]                   NAME <- NAMES[[kk]]
[08:28:18.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.302]                     next
[08:28:18.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.302]                 }
[08:28:18.302]                 NAMES <- toupper(added)
[08:28:18.302]                 for (kk in seq_along(NAMES)) {
[08:28:18.302]                   name <- added[[kk]]
[08:28:18.302]                   NAME <- NAMES[[kk]]
[08:28:18.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.302]                     next
[08:28:18.302]                   args[[name]] <- ""
[08:28:18.302]                 }
[08:28:18.302]                 NAMES <- toupper(removed)
[08:28:18.302]                 for (kk in seq_along(NAMES)) {
[08:28:18.302]                   name <- removed[[kk]]
[08:28:18.302]                   NAME <- NAMES[[kk]]
[08:28:18.302]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.302]                     next
[08:28:18.302]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.302]                 }
[08:28:18.302]                 if (length(args) > 0) 
[08:28:18.302]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.302]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.302]             }
[08:28:18.302]             else {
[08:28:18.302]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.302]             }
[08:28:18.302]             {
[08:28:18.302]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.302]                   0L) {
[08:28:18.302]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.302]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.302]                   base::options(opts)
[08:28:18.302]                 }
[08:28:18.302]                 {
[08:28:18.302]                   {
[08:28:18.302]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.302]                     NULL
[08:28:18.302]                   }
[08:28:18.302]                   options(future.plan = NULL)
[08:28:18.302]                   if (is.na(NA_character_)) 
[08:28:18.302]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.302]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.302]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.302]                     .init = FALSE)
[08:28:18.302]                 }
[08:28:18.302]             }
[08:28:18.302]         }
[08:28:18.302]     })
[08:28:18.302]     if (TRUE) {
[08:28:18.302]         base::sink(type = "output", split = FALSE)
[08:28:18.302]         if (TRUE) {
[08:28:18.302]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.302]         }
[08:28:18.302]         else {
[08:28:18.302]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.302]         }
[08:28:18.302]         base::close(...future.stdout)
[08:28:18.302]         ...future.stdout <- NULL
[08:28:18.302]     }
[08:28:18.302]     ...future.result$conditions <- ...future.conditions
[08:28:18.302]     ...future.result$finished <- base::Sys.time()
[08:28:18.302]     ...future.result
[08:28:18.302] }
[08:28:18.305] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[08:28:18.305] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[08:28:18.305] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[08:28:18.305] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:28:18.306] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:28:18.306] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[08:28:18.306] MultisessionFuture started
[08:28:18.306] - Launch lazy future ... done
[08:28:18.306] run() for ‘MultisessionFuture’ ... done
[08:28:18.307] result() for ClusterFuture ...
[08:28:18.307] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.307] - Validating connection of MultisessionFuture
[08:28:18.348] - received message: FutureResult
[08:28:18.348] - Received FutureResult
[08:28:18.349] - Erased future from FutureRegistry
[08:28:18.349] result() for ClusterFuture ...
[08:28:18.349] - result already collected: FutureResult
[08:28:18.349] result() for ClusterFuture ... done
[08:28:18.349] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.349] result() for ClusterFuture ... done
[08:28:18.349] result() for ClusterFuture ...
[08:28:18.349] - result already collected: FutureResult
[08:28:18.349] result() for ClusterFuture ... done
[08:28:18.350] run() for ‘Future’ ...
[08:28:18.350] - state: ‘created’
[08:28:18.350] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.364] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.364] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.364]   - Field: ‘node’
[08:28:18.364]   - Field: ‘label’
[08:28:18.364]   - Field: ‘local’
[08:28:18.365]   - Field: ‘owner’
[08:28:18.365]   - Field: ‘envir’
[08:28:18.365]   - Field: ‘workers’
[08:28:18.365]   - Field: ‘packages’
[08:28:18.365]   - Field: ‘gc’
[08:28:18.365]   - Field: ‘conditions’
[08:28:18.365]   - Field: ‘persistent’
[08:28:18.365]   - Field: ‘expr’
[08:28:18.365]   - Field: ‘uuid’
[08:28:18.365]   - Field: ‘seed’
[08:28:18.365]   - Field: ‘version’
[08:28:18.366]   - Field: ‘result’
[08:28:18.366]   - Field: ‘asynchronous’
[08:28:18.366]   - Field: ‘calls’
[08:28:18.366]   - Field: ‘globals’
[08:28:18.366]   - Field: ‘stdout’
[08:28:18.366]   - Field: ‘earlySignal’
[08:28:18.366]   - Field: ‘lazy’
[08:28:18.366]   - Field: ‘state’
[08:28:18.366] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.366] - Launch lazy future ...
[08:28:18.367] Packages needed by the future expression (n = 0): <none>
[08:28:18.367] Packages needed by future strategies (n = 0): <none>
[08:28:18.367] {
[08:28:18.367]     {
[08:28:18.367]         {
[08:28:18.367]             ...future.startTime <- base::Sys.time()
[08:28:18.367]             {
[08:28:18.367]                 {
[08:28:18.367]                   {
[08:28:18.367]                     {
[08:28:18.367]                       base::local({
[08:28:18.367]                         has_future <- base::requireNamespace("future", 
[08:28:18.367]                           quietly = TRUE)
[08:28:18.367]                         if (has_future) {
[08:28:18.367]                           ns <- base::getNamespace("future")
[08:28:18.367]                           version <- ns[[".package"]][["version"]]
[08:28:18.367]                           if (is.null(version)) 
[08:28:18.367]                             version <- utils::packageVersion("future")
[08:28:18.367]                         }
[08:28:18.367]                         else {
[08:28:18.367]                           version <- NULL
[08:28:18.367]                         }
[08:28:18.367]                         if (!has_future || version < "1.8.0") {
[08:28:18.367]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.367]                             "", base::R.version$version.string), 
[08:28:18.367]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.367]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.367]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.367]                               "release", "version")], collapse = " "), 
[08:28:18.367]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.367]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.367]                             info)
[08:28:18.367]                           info <- base::paste(info, collapse = "; ")
[08:28:18.367]                           if (!has_future) {
[08:28:18.367]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.367]                               info)
[08:28:18.367]                           }
[08:28:18.367]                           else {
[08:28:18.367]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.367]                               info, version)
[08:28:18.367]                           }
[08:28:18.367]                           base::stop(msg)
[08:28:18.367]                         }
[08:28:18.367]                       })
[08:28:18.367]                     }
[08:28:18.367]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.367]                     base::options(mc.cores = 1L)
[08:28:18.367]                   }
[08:28:18.367]                   ...future.strategy.old <- future::plan("list")
[08:28:18.367]                   options(future.plan = NULL)
[08:28:18.367]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.367]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.367]                 }
[08:28:18.367]                 ...future.workdir <- getwd()
[08:28:18.367]             }
[08:28:18.367]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.367]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.367]         }
[08:28:18.367]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.367]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.367]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.367]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.367]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.367]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.367]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.367]             base::names(...future.oldOptions))
[08:28:18.367]     }
[08:28:18.367]     if (FALSE) {
[08:28:18.367]     }
[08:28:18.367]     else {
[08:28:18.367]         if (TRUE) {
[08:28:18.367]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.367]                 open = "w")
[08:28:18.367]         }
[08:28:18.367]         else {
[08:28:18.367]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.367]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.367]         }
[08:28:18.367]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.367]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.367]             base::sink(type = "output", split = FALSE)
[08:28:18.367]             base::close(...future.stdout)
[08:28:18.367]         }, add = TRUE)
[08:28:18.367]     }
[08:28:18.367]     ...future.frame <- base::sys.nframe()
[08:28:18.367]     ...future.conditions <- base::list()
[08:28:18.367]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.367]     if (FALSE) {
[08:28:18.367]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.367]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.367]     }
[08:28:18.367]     ...future.result <- base::tryCatch({
[08:28:18.367]         base::withCallingHandlers({
[08:28:18.367]             ...future.value <- base::withVisible(base::local({
[08:28:18.367]                 ...future.makeSendCondition <- base::local({
[08:28:18.367]                   sendCondition <- NULL
[08:28:18.367]                   function(frame = 1L) {
[08:28:18.367]                     if (is.function(sendCondition)) 
[08:28:18.367]                       return(sendCondition)
[08:28:18.367]                     ns <- getNamespace("parallel")
[08:28:18.367]                     if (exists("sendData", mode = "function", 
[08:28:18.367]                       envir = ns)) {
[08:28:18.367]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.367]                         envir = ns)
[08:28:18.367]                       envir <- sys.frame(frame)
[08:28:18.367]                       master <- NULL
[08:28:18.367]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.367]                         !identical(envir, emptyenv())) {
[08:28:18.367]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.367]                           inherits = FALSE)) {
[08:28:18.367]                           master <- get("master", mode = "list", 
[08:28:18.367]                             envir = envir, inherits = FALSE)
[08:28:18.367]                           if (inherits(master, c("SOCKnode", 
[08:28:18.367]                             "SOCK0node"))) {
[08:28:18.367]                             sendCondition <<- function(cond) {
[08:28:18.367]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.367]                                 success = TRUE)
[08:28:18.367]                               parallel_sendData(master, data)
[08:28:18.367]                             }
[08:28:18.367]                             return(sendCondition)
[08:28:18.367]                           }
[08:28:18.367]                         }
[08:28:18.367]                         frame <- frame + 1L
[08:28:18.367]                         envir <- sys.frame(frame)
[08:28:18.367]                       }
[08:28:18.367]                     }
[08:28:18.367]                     sendCondition <<- function(cond) NULL
[08:28:18.367]                   }
[08:28:18.367]                 })
[08:28:18.367]                 withCallingHandlers({
[08:28:18.367]                   {
[08:28:18.367]                     b <- a * ii
[08:28:18.367]                     a <- 0
[08:28:18.367]                     b
[08:28:18.367]                   }
[08:28:18.367]                 }, immediateCondition = function(cond) {
[08:28:18.367]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.367]                   sendCondition(cond)
[08:28:18.367]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.367]                   {
[08:28:18.367]                     inherits <- base::inherits
[08:28:18.367]                     invokeRestart <- base::invokeRestart
[08:28:18.367]                     is.null <- base::is.null
[08:28:18.367]                     muffled <- FALSE
[08:28:18.367]                     if (inherits(cond, "message")) {
[08:28:18.367]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.367]                       if (muffled) 
[08:28:18.367]                         invokeRestart("muffleMessage")
[08:28:18.367]                     }
[08:28:18.367]                     else if (inherits(cond, "warning")) {
[08:28:18.367]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.367]                       if (muffled) 
[08:28:18.367]                         invokeRestart("muffleWarning")
[08:28:18.367]                     }
[08:28:18.367]                     else if (inherits(cond, "condition")) {
[08:28:18.367]                       if (!is.null(pattern)) {
[08:28:18.367]                         computeRestarts <- base::computeRestarts
[08:28:18.367]                         grepl <- base::grepl
[08:28:18.367]                         restarts <- computeRestarts(cond)
[08:28:18.367]                         for (restart in restarts) {
[08:28:18.367]                           name <- restart$name
[08:28:18.367]                           if (is.null(name)) 
[08:28:18.367]                             next
[08:28:18.367]                           if (!grepl(pattern, name)) 
[08:28:18.367]                             next
[08:28:18.367]                           invokeRestart(restart)
[08:28:18.367]                           muffled <- TRUE
[08:28:18.367]                           break
[08:28:18.367]                         }
[08:28:18.367]                       }
[08:28:18.367]                     }
[08:28:18.367]                     invisible(muffled)
[08:28:18.367]                   }
[08:28:18.367]                   muffleCondition(cond)
[08:28:18.367]                 })
[08:28:18.367]             }))
[08:28:18.367]             future::FutureResult(value = ...future.value$value, 
[08:28:18.367]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.367]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.367]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.367]                     ...future.globalenv.names))
[08:28:18.367]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.367]         }, condition = base::local({
[08:28:18.367]             c <- base::c
[08:28:18.367]             inherits <- base::inherits
[08:28:18.367]             invokeRestart <- base::invokeRestart
[08:28:18.367]             length <- base::length
[08:28:18.367]             list <- base::list
[08:28:18.367]             seq.int <- base::seq.int
[08:28:18.367]             signalCondition <- base::signalCondition
[08:28:18.367]             sys.calls <- base::sys.calls
[08:28:18.367]             `[[` <- base::`[[`
[08:28:18.367]             `+` <- base::`+`
[08:28:18.367]             `<<-` <- base::`<<-`
[08:28:18.367]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.367]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.367]                   3L)]
[08:28:18.367]             }
[08:28:18.367]             function(cond) {
[08:28:18.367]                 is_error <- inherits(cond, "error")
[08:28:18.367]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.367]                   NULL)
[08:28:18.367]                 if (is_error) {
[08:28:18.367]                   sessionInformation <- function() {
[08:28:18.367]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.367]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.367]                       search = base::search(), system = base::Sys.info())
[08:28:18.367]                   }
[08:28:18.367]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.367]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.367]                     cond$call), session = sessionInformation(), 
[08:28:18.367]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.367]                   signalCondition(cond)
[08:28:18.367]                 }
[08:28:18.367]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.367]                 "immediateCondition"))) {
[08:28:18.367]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.367]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.367]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.367]                   if (TRUE && !signal) {
[08:28:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.367]                     {
[08:28:18.367]                       inherits <- base::inherits
[08:28:18.367]                       invokeRestart <- base::invokeRestart
[08:28:18.367]                       is.null <- base::is.null
[08:28:18.367]                       muffled <- FALSE
[08:28:18.367]                       if (inherits(cond, "message")) {
[08:28:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.367]                         if (muffled) 
[08:28:18.367]                           invokeRestart("muffleMessage")
[08:28:18.367]                       }
[08:28:18.367]                       else if (inherits(cond, "warning")) {
[08:28:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.367]                         if (muffled) 
[08:28:18.367]                           invokeRestart("muffleWarning")
[08:28:18.367]                       }
[08:28:18.367]                       else if (inherits(cond, "condition")) {
[08:28:18.367]                         if (!is.null(pattern)) {
[08:28:18.367]                           computeRestarts <- base::computeRestarts
[08:28:18.367]                           grepl <- base::grepl
[08:28:18.367]                           restarts <- computeRestarts(cond)
[08:28:18.367]                           for (restart in restarts) {
[08:28:18.367]                             name <- restart$name
[08:28:18.367]                             if (is.null(name)) 
[08:28:18.367]                               next
[08:28:18.367]                             if (!grepl(pattern, name)) 
[08:28:18.367]                               next
[08:28:18.367]                             invokeRestart(restart)
[08:28:18.367]                             muffled <- TRUE
[08:28:18.367]                             break
[08:28:18.367]                           }
[08:28:18.367]                         }
[08:28:18.367]                       }
[08:28:18.367]                       invisible(muffled)
[08:28:18.367]                     }
[08:28:18.367]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.367]                   }
[08:28:18.367]                 }
[08:28:18.367]                 else {
[08:28:18.367]                   if (TRUE) {
[08:28:18.367]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.367]                     {
[08:28:18.367]                       inherits <- base::inherits
[08:28:18.367]                       invokeRestart <- base::invokeRestart
[08:28:18.367]                       is.null <- base::is.null
[08:28:18.367]                       muffled <- FALSE
[08:28:18.367]                       if (inherits(cond, "message")) {
[08:28:18.367]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.367]                         if (muffled) 
[08:28:18.367]                           invokeRestart("muffleMessage")
[08:28:18.367]                       }
[08:28:18.367]                       else if (inherits(cond, "warning")) {
[08:28:18.367]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.367]                         if (muffled) 
[08:28:18.367]                           invokeRestart("muffleWarning")
[08:28:18.367]                       }
[08:28:18.367]                       else if (inherits(cond, "condition")) {
[08:28:18.367]                         if (!is.null(pattern)) {
[08:28:18.367]                           computeRestarts <- base::computeRestarts
[08:28:18.367]                           grepl <- base::grepl
[08:28:18.367]                           restarts <- computeRestarts(cond)
[08:28:18.367]                           for (restart in restarts) {
[08:28:18.367]                             name <- restart$name
[08:28:18.367]                             if (is.null(name)) 
[08:28:18.367]                               next
[08:28:18.367]                             if (!grepl(pattern, name)) 
[08:28:18.367]                               next
[08:28:18.367]                             invokeRestart(restart)
[08:28:18.367]                             muffled <- TRUE
[08:28:18.367]                             break
[08:28:18.367]                           }
[08:28:18.367]                         }
[08:28:18.367]                       }
[08:28:18.367]                       invisible(muffled)
[08:28:18.367]                     }
[08:28:18.367]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.367]                   }
[08:28:18.367]                 }
[08:28:18.367]             }
[08:28:18.367]         }))
[08:28:18.367]     }, error = function(ex) {
[08:28:18.367]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.367]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.367]                 ...future.rng), started = ...future.startTime, 
[08:28:18.367]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.367]             version = "1.8"), class = "FutureResult")
[08:28:18.367]     }, finally = {
[08:28:18.367]         if (!identical(...future.workdir, getwd())) 
[08:28:18.367]             setwd(...future.workdir)
[08:28:18.367]         {
[08:28:18.367]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.367]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.367]             }
[08:28:18.367]             base::options(...future.oldOptions)
[08:28:18.367]             if (.Platform$OS.type == "windows") {
[08:28:18.367]                 old_names <- names(...future.oldEnvVars)
[08:28:18.367]                 envs <- base::Sys.getenv()
[08:28:18.367]                 names <- names(envs)
[08:28:18.367]                 common <- intersect(names, old_names)
[08:28:18.367]                 added <- setdiff(names, old_names)
[08:28:18.367]                 removed <- setdiff(old_names, names)
[08:28:18.367]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.367]                   envs[common]]
[08:28:18.367]                 NAMES <- toupper(changed)
[08:28:18.367]                 args <- list()
[08:28:18.367]                 for (kk in seq_along(NAMES)) {
[08:28:18.367]                   name <- changed[[kk]]
[08:28:18.367]                   NAME <- NAMES[[kk]]
[08:28:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.367]                     next
[08:28:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.367]                 }
[08:28:18.367]                 NAMES <- toupper(added)
[08:28:18.367]                 for (kk in seq_along(NAMES)) {
[08:28:18.367]                   name <- added[[kk]]
[08:28:18.367]                   NAME <- NAMES[[kk]]
[08:28:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.367]                     next
[08:28:18.367]                   args[[name]] <- ""
[08:28:18.367]                 }
[08:28:18.367]                 NAMES <- toupper(removed)
[08:28:18.367]                 for (kk in seq_along(NAMES)) {
[08:28:18.367]                   name <- removed[[kk]]
[08:28:18.367]                   NAME <- NAMES[[kk]]
[08:28:18.367]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.367]                     next
[08:28:18.367]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.367]                 }
[08:28:18.367]                 if (length(args) > 0) 
[08:28:18.367]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.367]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.367]             }
[08:28:18.367]             else {
[08:28:18.367]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.367]             }
[08:28:18.367]             {
[08:28:18.367]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.367]                   0L) {
[08:28:18.367]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.367]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.367]                   base::options(opts)
[08:28:18.367]                 }
[08:28:18.367]                 {
[08:28:18.367]                   {
[08:28:18.367]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.367]                     NULL
[08:28:18.367]                   }
[08:28:18.367]                   options(future.plan = NULL)
[08:28:18.367]                   if (is.na(NA_character_)) 
[08:28:18.367]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.367]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.367]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.367]                     .init = FALSE)
[08:28:18.367]                 }
[08:28:18.367]             }
[08:28:18.367]         }
[08:28:18.367]     })
[08:28:18.367]     if (TRUE) {
[08:28:18.367]         base::sink(type = "output", split = FALSE)
[08:28:18.367]         if (TRUE) {
[08:28:18.367]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.367]         }
[08:28:18.367]         else {
[08:28:18.367]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.367]         }
[08:28:18.367]         base::close(...future.stdout)
[08:28:18.367]         ...future.stdout <- NULL
[08:28:18.367]     }
[08:28:18.367]     ...future.result$conditions <- ...future.conditions
[08:28:18.367]     ...future.result$finished <- base::Sys.time()
[08:28:18.367]     ...future.result
[08:28:18.367] }
[08:28:18.370] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[08:28:18.370] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[08:28:18.371] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[08:28:18.371] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[08:28:18.371] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[08:28:18.371] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[08:28:18.372] MultisessionFuture started
[08:28:18.372] - Launch lazy future ... done
[08:28:18.372] run() for ‘MultisessionFuture’ ... done
[08:28:18.372] result() for ClusterFuture ...
[08:28:18.372] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.372] - Validating connection of MultisessionFuture
[08:28:18.414] - received message: FutureResult
[08:28:18.415] - Received FutureResult
[08:28:18.415] - Erased future from FutureRegistry
[08:28:18.415] result() for ClusterFuture ...
[08:28:18.415] - result already collected: FutureResult
[08:28:18.415] result() for ClusterFuture ... done
[08:28:18.415] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.415] result() for ClusterFuture ... done
[08:28:18.415] result() for ClusterFuture ...
[08:28:18.415] - result already collected: FutureResult
[08:28:18.416] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.416] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.416] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.417] 
[08:28:18.417] Searching for globals ... DONE
[08:28:18.417] - globals: [0] <none>
[08:28:18.417] getGlobalsAndPackages() ... DONE
[08:28:18.417] run() for ‘Future’ ...
[08:28:18.417] - state: ‘created’
[08:28:18.417] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.432] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.432] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.432]   - Field: ‘node’
[08:28:18.432]   - Field: ‘label’
[08:28:18.432]   - Field: ‘local’
[08:28:18.432]   - Field: ‘owner’
[08:28:18.433]   - Field: ‘envir’
[08:28:18.433]   - Field: ‘workers’
[08:28:18.433]   - Field: ‘packages’
[08:28:18.433]   - Field: ‘gc’
[08:28:18.433]   - Field: ‘conditions’
[08:28:18.433]   - Field: ‘persistent’
[08:28:18.433]   - Field: ‘expr’
[08:28:18.433]   - Field: ‘uuid’
[08:28:18.433]   - Field: ‘seed’
[08:28:18.433]   - Field: ‘version’
[08:28:18.433]   - Field: ‘result’
[08:28:18.433]   - Field: ‘asynchronous’
[08:28:18.434]   - Field: ‘calls’
[08:28:18.434]   - Field: ‘globals’
[08:28:18.434]   - Field: ‘stdout’
[08:28:18.434]   - Field: ‘earlySignal’
[08:28:18.434]   - Field: ‘lazy’
[08:28:18.434]   - Field: ‘state’
[08:28:18.434] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.434] - Launch lazy future ...
[08:28:18.434] Packages needed by the future expression (n = 0): <none>
[08:28:18.435] Packages needed by future strategies (n = 0): <none>
[08:28:18.435] {
[08:28:18.435]     {
[08:28:18.435]         {
[08:28:18.435]             ...future.startTime <- base::Sys.time()
[08:28:18.435]             {
[08:28:18.435]                 {
[08:28:18.435]                   {
[08:28:18.435]                     {
[08:28:18.435]                       base::local({
[08:28:18.435]                         has_future <- base::requireNamespace("future", 
[08:28:18.435]                           quietly = TRUE)
[08:28:18.435]                         if (has_future) {
[08:28:18.435]                           ns <- base::getNamespace("future")
[08:28:18.435]                           version <- ns[[".package"]][["version"]]
[08:28:18.435]                           if (is.null(version)) 
[08:28:18.435]                             version <- utils::packageVersion("future")
[08:28:18.435]                         }
[08:28:18.435]                         else {
[08:28:18.435]                           version <- NULL
[08:28:18.435]                         }
[08:28:18.435]                         if (!has_future || version < "1.8.0") {
[08:28:18.435]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.435]                             "", base::R.version$version.string), 
[08:28:18.435]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.435]                               "release", "version")], collapse = " "), 
[08:28:18.435]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.435]                             info)
[08:28:18.435]                           info <- base::paste(info, collapse = "; ")
[08:28:18.435]                           if (!has_future) {
[08:28:18.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.435]                               info)
[08:28:18.435]                           }
[08:28:18.435]                           else {
[08:28:18.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.435]                               info, version)
[08:28:18.435]                           }
[08:28:18.435]                           base::stop(msg)
[08:28:18.435]                         }
[08:28:18.435]                       })
[08:28:18.435]                     }
[08:28:18.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.435]                     base::options(mc.cores = 1L)
[08:28:18.435]                   }
[08:28:18.435]                   ...future.strategy.old <- future::plan("list")
[08:28:18.435]                   options(future.plan = NULL)
[08:28:18.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.435]                 }
[08:28:18.435]                 ...future.workdir <- getwd()
[08:28:18.435]             }
[08:28:18.435]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.435]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.435]         }
[08:28:18.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.435]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.435]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.435]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.435]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.435]             base::names(...future.oldOptions))
[08:28:18.435]     }
[08:28:18.435]     if (FALSE) {
[08:28:18.435]     }
[08:28:18.435]     else {
[08:28:18.435]         if (TRUE) {
[08:28:18.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.435]                 open = "w")
[08:28:18.435]         }
[08:28:18.435]         else {
[08:28:18.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.435]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.435]         }
[08:28:18.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.435]             base::sink(type = "output", split = FALSE)
[08:28:18.435]             base::close(...future.stdout)
[08:28:18.435]         }, add = TRUE)
[08:28:18.435]     }
[08:28:18.435]     ...future.frame <- base::sys.nframe()
[08:28:18.435]     ...future.conditions <- base::list()
[08:28:18.435]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.435]     if (FALSE) {
[08:28:18.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.435]     }
[08:28:18.435]     ...future.result <- base::tryCatch({
[08:28:18.435]         base::withCallingHandlers({
[08:28:18.435]             ...future.value <- base::withVisible(base::local({
[08:28:18.435]                 ...future.makeSendCondition <- base::local({
[08:28:18.435]                   sendCondition <- NULL
[08:28:18.435]                   function(frame = 1L) {
[08:28:18.435]                     if (is.function(sendCondition)) 
[08:28:18.435]                       return(sendCondition)
[08:28:18.435]                     ns <- getNamespace("parallel")
[08:28:18.435]                     if (exists("sendData", mode = "function", 
[08:28:18.435]                       envir = ns)) {
[08:28:18.435]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.435]                         envir = ns)
[08:28:18.435]                       envir <- sys.frame(frame)
[08:28:18.435]                       master <- NULL
[08:28:18.435]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.435]                         !identical(envir, emptyenv())) {
[08:28:18.435]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.435]                           inherits = FALSE)) {
[08:28:18.435]                           master <- get("master", mode = "list", 
[08:28:18.435]                             envir = envir, inherits = FALSE)
[08:28:18.435]                           if (inherits(master, c("SOCKnode", 
[08:28:18.435]                             "SOCK0node"))) {
[08:28:18.435]                             sendCondition <<- function(cond) {
[08:28:18.435]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.435]                                 success = TRUE)
[08:28:18.435]                               parallel_sendData(master, data)
[08:28:18.435]                             }
[08:28:18.435]                             return(sendCondition)
[08:28:18.435]                           }
[08:28:18.435]                         }
[08:28:18.435]                         frame <- frame + 1L
[08:28:18.435]                         envir <- sys.frame(frame)
[08:28:18.435]                       }
[08:28:18.435]                     }
[08:28:18.435]                     sendCondition <<- function(cond) NULL
[08:28:18.435]                   }
[08:28:18.435]                 })
[08:28:18.435]                 withCallingHandlers({
[08:28:18.435]                   1
[08:28:18.435]                 }, immediateCondition = function(cond) {
[08:28:18.435]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.435]                   sendCondition(cond)
[08:28:18.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.435]                   {
[08:28:18.435]                     inherits <- base::inherits
[08:28:18.435]                     invokeRestart <- base::invokeRestart
[08:28:18.435]                     is.null <- base::is.null
[08:28:18.435]                     muffled <- FALSE
[08:28:18.435]                     if (inherits(cond, "message")) {
[08:28:18.435]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.435]                       if (muffled) 
[08:28:18.435]                         invokeRestart("muffleMessage")
[08:28:18.435]                     }
[08:28:18.435]                     else if (inherits(cond, "warning")) {
[08:28:18.435]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.435]                       if (muffled) 
[08:28:18.435]                         invokeRestart("muffleWarning")
[08:28:18.435]                     }
[08:28:18.435]                     else if (inherits(cond, "condition")) {
[08:28:18.435]                       if (!is.null(pattern)) {
[08:28:18.435]                         computeRestarts <- base::computeRestarts
[08:28:18.435]                         grepl <- base::grepl
[08:28:18.435]                         restarts <- computeRestarts(cond)
[08:28:18.435]                         for (restart in restarts) {
[08:28:18.435]                           name <- restart$name
[08:28:18.435]                           if (is.null(name)) 
[08:28:18.435]                             next
[08:28:18.435]                           if (!grepl(pattern, name)) 
[08:28:18.435]                             next
[08:28:18.435]                           invokeRestart(restart)
[08:28:18.435]                           muffled <- TRUE
[08:28:18.435]                           break
[08:28:18.435]                         }
[08:28:18.435]                       }
[08:28:18.435]                     }
[08:28:18.435]                     invisible(muffled)
[08:28:18.435]                   }
[08:28:18.435]                   muffleCondition(cond)
[08:28:18.435]                 })
[08:28:18.435]             }))
[08:28:18.435]             future::FutureResult(value = ...future.value$value, 
[08:28:18.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.435]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.435]                     ...future.globalenv.names))
[08:28:18.435]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.435]         }, condition = base::local({
[08:28:18.435]             c <- base::c
[08:28:18.435]             inherits <- base::inherits
[08:28:18.435]             invokeRestart <- base::invokeRestart
[08:28:18.435]             length <- base::length
[08:28:18.435]             list <- base::list
[08:28:18.435]             seq.int <- base::seq.int
[08:28:18.435]             signalCondition <- base::signalCondition
[08:28:18.435]             sys.calls <- base::sys.calls
[08:28:18.435]             `[[` <- base::`[[`
[08:28:18.435]             `+` <- base::`+`
[08:28:18.435]             `<<-` <- base::`<<-`
[08:28:18.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.435]                   3L)]
[08:28:18.435]             }
[08:28:18.435]             function(cond) {
[08:28:18.435]                 is_error <- inherits(cond, "error")
[08:28:18.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.435]                   NULL)
[08:28:18.435]                 if (is_error) {
[08:28:18.435]                   sessionInformation <- function() {
[08:28:18.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.435]                       search = base::search(), system = base::Sys.info())
[08:28:18.435]                   }
[08:28:18.435]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.435]                     cond$call), session = sessionInformation(), 
[08:28:18.435]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.435]                   signalCondition(cond)
[08:28:18.435]                 }
[08:28:18.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.435]                 "immediateCondition"))) {
[08:28:18.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.435]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.435]                   if (TRUE && !signal) {
[08:28:18.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.435]                     {
[08:28:18.435]                       inherits <- base::inherits
[08:28:18.435]                       invokeRestart <- base::invokeRestart
[08:28:18.435]                       is.null <- base::is.null
[08:28:18.435]                       muffled <- FALSE
[08:28:18.435]                       if (inherits(cond, "message")) {
[08:28:18.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.435]                         if (muffled) 
[08:28:18.435]                           invokeRestart("muffleMessage")
[08:28:18.435]                       }
[08:28:18.435]                       else if (inherits(cond, "warning")) {
[08:28:18.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.435]                         if (muffled) 
[08:28:18.435]                           invokeRestart("muffleWarning")
[08:28:18.435]                       }
[08:28:18.435]                       else if (inherits(cond, "condition")) {
[08:28:18.435]                         if (!is.null(pattern)) {
[08:28:18.435]                           computeRestarts <- base::computeRestarts
[08:28:18.435]                           grepl <- base::grepl
[08:28:18.435]                           restarts <- computeRestarts(cond)
[08:28:18.435]                           for (restart in restarts) {
[08:28:18.435]                             name <- restart$name
[08:28:18.435]                             if (is.null(name)) 
[08:28:18.435]                               next
[08:28:18.435]                             if (!grepl(pattern, name)) 
[08:28:18.435]                               next
[08:28:18.435]                             invokeRestart(restart)
[08:28:18.435]                             muffled <- TRUE
[08:28:18.435]                             break
[08:28:18.435]                           }
[08:28:18.435]                         }
[08:28:18.435]                       }
[08:28:18.435]                       invisible(muffled)
[08:28:18.435]                     }
[08:28:18.435]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.435]                   }
[08:28:18.435]                 }
[08:28:18.435]                 else {
[08:28:18.435]                   if (TRUE) {
[08:28:18.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.435]                     {
[08:28:18.435]                       inherits <- base::inherits
[08:28:18.435]                       invokeRestart <- base::invokeRestart
[08:28:18.435]                       is.null <- base::is.null
[08:28:18.435]                       muffled <- FALSE
[08:28:18.435]                       if (inherits(cond, "message")) {
[08:28:18.435]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.435]                         if (muffled) 
[08:28:18.435]                           invokeRestart("muffleMessage")
[08:28:18.435]                       }
[08:28:18.435]                       else if (inherits(cond, "warning")) {
[08:28:18.435]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.435]                         if (muffled) 
[08:28:18.435]                           invokeRestart("muffleWarning")
[08:28:18.435]                       }
[08:28:18.435]                       else if (inherits(cond, "condition")) {
[08:28:18.435]                         if (!is.null(pattern)) {
[08:28:18.435]                           computeRestarts <- base::computeRestarts
[08:28:18.435]                           grepl <- base::grepl
[08:28:18.435]                           restarts <- computeRestarts(cond)
[08:28:18.435]                           for (restart in restarts) {
[08:28:18.435]                             name <- restart$name
[08:28:18.435]                             if (is.null(name)) 
[08:28:18.435]                               next
[08:28:18.435]                             if (!grepl(pattern, name)) 
[08:28:18.435]                               next
[08:28:18.435]                             invokeRestart(restart)
[08:28:18.435]                             muffled <- TRUE
[08:28:18.435]                             break
[08:28:18.435]                           }
[08:28:18.435]                         }
[08:28:18.435]                       }
[08:28:18.435]                       invisible(muffled)
[08:28:18.435]                     }
[08:28:18.435]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.435]                   }
[08:28:18.435]                 }
[08:28:18.435]             }
[08:28:18.435]         }))
[08:28:18.435]     }, error = function(ex) {
[08:28:18.435]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.435]                 ...future.rng), started = ...future.startTime, 
[08:28:18.435]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.435]             version = "1.8"), class = "FutureResult")
[08:28:18.435]     }, finally = {
[08:28:18.435]         if (!identical(...future.workdir, getwd())) 
[08:28:18.435]             setwd(...future.workdir)
[08:28:18.435]         {
[08:28:18.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.435]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.435]             }
[08:28:18.435]             base::options(...future.oldOptions)
[08:28:18.435]             if (.Platform$OS.type == "windows") {
[08:28:18.435]                 old_names <- names(...future.oldEnvVars)
[08:28:18.435]                 envs <- base::Sys.getenv()
[08:28:18.435]                 names <- names(envs)
[08:28:18.435]                 common <- intersect(names, old_names)
[08:28:18.435]                 added <- setdiff(names, old_names)
[08:28:18.435]                 removed <- setdiff(old_names, names)
[08:28:18.435]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.435]                   envs[common]]
[08:28:18.435]                 NAMES <- toupper(changed)
[08:28:18.435]                 args <- list()
[08:28:18.435]                 for (kk in seq_along(NAMES)) {
[08:28:18.435]                   name <- changed[[kk]]
[08:28:18.435]                   NAME <- NAMES[[kk]]
[08:28:18.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.435]                     next
[08:28:18.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.435]                 }
[08:28:18.435]                 NAMES <- toupper(added)
[08:28:18.435]                 for (kk in seq_along(NAMES)) {
[08:28:18.435]                   name <- added[[kk]]
[08:28:18.435]                   NAME <- NAMES[[kk]]
[08:28:18.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.435]                     next
[08:28:18.435]                   args[[name]] <- ""
[08:28:18.435]                 }
[08:28:18.435]                 NAMES <- toupper(removed)
[08:28:18.435]                 for (kk in seq_along(NAMES)) {
[08:28:18.435]                   name <- removed[[kk]]
[08:28:18.435]                   NAME <- NAMES[[kk]]
[08:28:18.435]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.435]                     next
[08:28:18.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.435]                 }
[08:28:18.435]                 if (length(args) > 0) 
[08:28:18.435]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.435]             }
[08:28:18.435]             else {
[08:28:18.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.435]             }
[08:28:18.435]             {
[08:28:18.435]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.435]                   0L) {
[08:28:18.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.435]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.435]                   base::options(opts)
[08:28:18.435]                 }
[08:28:18.435]                 {
[08:28:18.435]                   {
[08:28:18.435]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.435]                     NULL
[08:28:18.435]                   }
[08:28:18.435]                   options(future.plan = NULL)
[08:28:18.435]                   if (is.na(NA_character_)) 
[08:28:18.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.435]                     .init = FALSE)
[08:28:18.435]                 }
[08:28:18.435]             }
[08:28:18.435]         }
[08:28:18.435]     })
[08:28:18.435]     if (TRUE) {
[08:28:18.435]         base::sink(type = "output", split = FALSE)
[08:28:18.435]         if (TRUE) {
[08:28:18.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.435]         }
[08:28:18.435]         else {
[08:28:18.435]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.435]         }
[08:28:18.435]         base::close(...future.stdout)
[08:28:18.435]         ...future.stdout <- NULL
[08:28:18.435]     }
[08:28:18.435]     ...future.result$conditions <- ...future.conditions
[08:28:18.435]     ...future.result$finished <- base::Sys.time()
[08:28:18.435]     ...future.result
[08:28:18.435] }
[08:28:18.438] MultisessionFuture started
[08:28:18.438] - Launch lazy future ... done
[08:28:18.438] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.439] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.439] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.440] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:18.440] Searching for globals ... DONE
[08:28:18.440] Resolving globals: TRUE
[08:28:18.440] Resolving any globals that are futures ...
[08:28:18.440] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:18.440] Resolving any globals that are futures ... DONE
[08:28:18.443] Resolving futures part of globals (recursively) ...
[08:28:18.443] resolve() on list ...
[08:28:18.443]  recursive: 99
[08:28:18.443]  length: 1
[08:28:18.443]  elements: ‘a’
[08:28:18.485] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.486] - Validating connection of MultisessionFuture
[08:28:18.486] - received message: FutureResult
[08:28:18.486] - Received FutureResult
[08:28:18.486] - Erased future from FutureRegistry
[08:28:18.486] result() for ClusterFuture ...
[08:28:18.486] - result already collected: FutureResult
[08:28:18.486] result() for ClusterFuture ... done
[08:28:18.487] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.487] Future #1
[08:28:18.487] result() for ClusterFuture ...
[08:28:18.487] - result already collected: FutureResult
[08:28:18.487] result() for ClusterFuture ... done
[08:28:18.487] result() for ClusterFuture ...
[08:28:18.487] - result already collected: FutureResult
[08:28:18.487] result() for ClusterFuture ... done
[08:28:18.487] A MultisessionFuture was resolved
[08:28:18.487]  length: 0 (resolved future 1)
[08:28:18.487] resolve() on list ... DONE
[08:28:18.488] - globals: [1] ‘a’
[08:28:18.488] Resolving futures part of globals (recursively) ... DONE
[08:28:18.499] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[08:28:18.499] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[08:28:18.500] - globals: [1] ‘a’
[08:28:18.500] - packages: [1] ‘future’
[08:28:18.500] getGlobalsAndPackages() ... DONE
[08:28:18.500] run() for ‘Future’ ...
[08:28:18.500] - state: ‘created’
[08:28:18.500] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.514]   - Field: ‘node’
[08:28:18.515]   - Field: ‘label’
[08:28:18.515]   - Field: ‘local’
[08:28:18.515]   - Field: ‘owner’
[08:28:18.515]   - Field: ‘envir’
[08:28:18.515]   - Field: ‘workers’
[08:28:18.515]   - Field: ‘packages’
[08:28:18.515]   - Field: ‘gc’
[08:28:18.515]   - Field: ‘conditions’
[08:28:18.515]   - Field: ‘persistent’
[08:28:18.515]   - Field: ‘expr’
[08:28:18.515]   - Field: ‘uuid’
[08:28:18.515]   - Field: ‘seed’
[08:28:18.516]   - Field: ‘version’
[08:28:18.516]   - Field: ‘result’
[08:28:18.516]   - Field: ‘asynchronous’
[08:28:18.516]   - Field: ‘calls’
[08:28:18.516]   - Field: ‘globals’
[08:28:18.516]   - Field: ‘stdout’
[08:28:18.516]   - Field: ‘earlySignal’
[08:28:18.516]   - Field: ‘lazy’
[08:28:18.516]   - Field: ‘state’
[08:28:18.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.516] - Launch lazy future ...
[08:28:18.517] Packages needed by the future expression (n = 1): ‘future’
[08:28:18.517] Packages needed by future strategies (n = 0): <none>
[08:28:18.517] {
[08:28:18.517]     {
[08:28:18.517]         {
[08:28:18.517]             ...future.startTime <- base::Sys.time()
[08:28:18.517]             {
[08:28:18.517]                 {
[08:28:18.517]                   {
[08:28:18.517]                     {
[08:28:18.517]                       {
[08:28:18.517]                         base::local({
[08:28:18.517]                           has_future <- base::requireNamespace("future", 
[08:28:18.517]                             quietly = TRUE)
[08:28:18.517]                           if (has_future) {
[08:28:18.517]                             ns <- base::getNamespace("future")
[08:28:18.517]                             version <- ns[[".package"]][["version"]]
[08:28:18.517]                             if (is.null(version)) 
[08:28:18.517]                               version <- utils::packageVersion("future")
[08:28:18.517]                           }
[08:28:18.517]                           else {
[08:28:18.517]                             version <- NULL
[08:28:18.517]                           }
[08:28:18.517]                           if (!has_future || version < "1.8.0") {
[08:28:18.517]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.517]                               "", base::R.version$version.string), 
[08:28:18.517]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:18.517]                                 base::R.version$platform, 8 * 
[08:28:18.517]                                   base::.Machine$sizeof.pointer), 
[08:28:18.517]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.517]                                 "release", "version")], collapse = " "), 
[08:28:18.517]                               hostname = base::Sys.info()[["nodename"]])
[08:28:18.517]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.517]                               info)
[08:28:18.517]                             info <- base::paste(info, collapse = "; ")
[08:28:18.517]                             if (!has_future) {
[08:28:18.517]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.517]                                 info)
[08:28:18.517]                             }
[08:28:18.517]                             else {
[08:28:18.517]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.517]                                 info, version)
[08:28:18.517]                             }
[08:28:18.517]                             base::stop(msg)
[08:28:18.517]                           }
[08:28:18.517]                         })
[08:28:18.517]                       }
[08:28:18.517]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.517]                       base::options(mc.cores = 1L)
[08:28:18.517]                     }
[08:28:18.517]                     base::local({
[08:28:18.517]                       for (pkg in "future") {
[08:28:18.517]                         base::loadNamespace(pkg)
[08:28:18.517]                         base::library(pkg, character.only = TRUE)
[08:28:18.517]                       }
[08:28:18.517]                     })
[08:28:18.517]                   }
[08:28:18.517]                   ...future.strategy.old <- future::plan("list")
[08:28:18.517]                   options(future.plan = NULL)
[08:28:18.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.517]                 }
[08:28:18.517]                 ...future.workdir <- getwd()
[08:28:18.517]             }
[08:28:18.517]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.517]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.517]         }
[08:28:18.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.517]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.517]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.517]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.517]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.517]             base::names(...future.oldOptions))
[08:28:18.517]     }
[08:28:18.517]     if (FALSE) {
[08:28:18.517]     }
[08:28:18.517]     else {
[08:28:18.517]         if (TRUE) {
[08:28:18.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.517]                 open = "w")
[08:28:18.517]         }
[08:28:18.517]         else {
[08:28:18.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.517]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.517]         }
[08:28:18.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.517]             base::sink(type = "output", split = FALSE)
[08:28:18.517]             base::close(...future.stdout)
[08:28:18.517]         }, add = TRUE)
[08:28:18.517]     }
[08:28:18.517]     ...future.frame <- base::sys.nframe()
[08:28:18.517]     ...future.conditions <- base::list()
[08:28:18.517]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.517]     if (FALSE) {
[08:28:18.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.517]     }
[08:28:18.517]     ...future.result <- base::tryCatch({
[08:28:18.517]         base::withCallingHandlers({
[08:28:18.517]             ...future.value <- base::withVisible(base::local({
[08:28:18.517]                 ...future.makeSendCondition <- base::local({
[08:28:18.517]                   sendCondition <- NULL
[08:28:18.517]                   function(frame = 1L) {
[08:28:18.517]                     if (is.function(sendCondition)) 
[08:28:18.517]                       return(sendCondition)
[08:28:18.517]                     ns <- getNamespace("parallel")
[08:28:18.517]                     if (exists("sendData", mode = "function", 
[08:28:18.517]                       envir = ns)) {
[08:28:18.517]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.517]                         envir = ns)
[08:28:18.517]                       envir <- sys.frame(frame)
[08:28:18.517]                       master <- NULL
[08:28:18.517]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.517]                         !identical(envir, emptyenv())) {
[08:28:18.517]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.517]                           inherits = FALSE)) {
[08:28:18.517]                           master <- get("master", mode = "list", 
[08:28:18.517]                             envir = envir, inherits = FALSE)
[08:28:18.517]                           if (inherits(master, c("SOCKnode", 
[08:28:18.517]                             "SOCK0node"))) {
[08:28:18.517]                             sendCondition <<- function(cond) {
[08:28:18.517]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.517]                                 success = TRUE)
[08:28:18.517]                               parallel_sendData(master, data)
[08:28:18.517]                             }
[08:28:18.517]                             return(sendCondition)
[08:28:18.517]                           }
[08:28:18.517]                         }
[08:28:18.517]                         frame <- frame + 1L
[08:28:18.517]                         envir <- sys.frame(frame)
[08:28:18.517]                       }
[08:28:18.517]                     }
[08:28:18.517]                     sendCondition <<- function(cond) NULL
[08:28:18.517]                   }
[08:28:18.517]                 })
[08:28:18.517]                 withCallingHandlers({
[08:28:18.517]                   value(a) + 1
[08:28:18.517]                 }, immediateCondition = function(cond) {
[08:28:18.517]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.517]                   sendCondition(cond)
[08:28:18.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.517]                   {
[08:28:18.517]                     inherits <- base::inherits
[08:28:18.517]                     invokeRestart <- base::invokeRestart
[08:28:18.517]                     is.null <- base::is.null
[08:28:18.517]                     muffled <- FALSE
[08:28:18.517]                     if (inherits(cond, "message")) {
[08:28:18.517]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.517]                       if (muffled) 
[08:28:18.517]                         invokeRestart("muffleMessage")
[08:28:18.517]                     }
[08:28:18.517]                     else if (inherits(cond, "warning")) {
[08:28:18.517]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.517]                       if (muffled) 
[08:28:18.517]                         invokeRestart("muffleWarning")
[08:28:18.517]                     }
[08:28:18.517]                     else if (inherits(cond, "condition")) {
[08:28:18.517]                       if (!is.null(pattern)) {
[08:28:18.517]                         computeRestarts <- base::computeRestarts
[08:28:18.517]                         grepl <- base::grepl
[08:28:18.517]                         restarts <- computeRestarts(cond)
[08:28:18.517]                         for (restart in restarts) {
[08:28:18.517]                           name <- restart$name
[08:28:18.517]                           if (is.null(name)) 
[08:28:18.517]                             next
[08:28:18.517]                           if (!grepl(pattern, name)) 
[08:28:18.517]                             next
[08:28:18.517]                           invokeRestart(restart)
[08:28:18.517]                           muffled <- TRUE
[08:28:18.517]                           break
[08:28:18.517]                         }
[08:28:18.517]                       }
[08:28:18.517]                     }
[08:28:18.517]                     invisible(muffled)
[08:28:18.517]                   }
[08:28:18.517]                   muffleCondition(cond)
[08:28:18.517]                 })
[08:28:18.517]             }))
[08:28:18.517]             future::FutureResult(value = ...future.value$value, 
[08:28:18.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.517]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.517]                     ...future.globalenv.names))
[08:28:18.517]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.517]         }, condition = base::local({
[08:28:18.517]             c <- base::c
[08:28:18.517]             inherits <- base::inherits
[08:28:18.517]             invokeRestart <- base::invokeRestart
[08:28:18.517]             length <- base::length
[08:28:18.517]             list <- base::list
[08:28:18.517]             seq.int <- base::seq.int
[08:28:18.517]             signalCondition <- base::signalCondition
[08:28:18.517]             sys.calls <- base::sys.calls
[08:28:18.517]             `[[` <- base::`[[`
[08:28:18.517]             `+` <- base::`+`
[08:28:18.517]             `<<-` <- base::`<<-`
[08:28:18.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.517]                   3L)]
[08:28:18.517]             }
[08:28:18.517]             function(cond) {
[08:28:18.517]                 is_error <- inherits(cond, "error")
[08:28:18.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.517]                   NULL)
[08:28:18.517]                 if (is_error) {
[08:28:18.517]                   sessionInformation <- function() {
[08:28:18.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.517]                       search = base::search(), system = base::Sys.info())
[08:28:18.517]                   }
[08:28:18.517]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.517]                     cond$call), session = sessionInformation(), 
[08:28:18.517]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.517]                   signalCondition(cond)
[08:28:18.517]                 }
[08:28:18.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.517]                 "immediateCondition"))) {
[08:28:18.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.517]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.517]                   if (TRUE && !signal) {
[08:28:18.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.517]                     {
[08:28:18.517]                       inherits <- base::inherits
[08:28:18.517]                       invokeRestart <- base::invokeRestart
[08:28:18.517]                       is.null <- base::is.null
[08:28:18.517]                       muffled <- FALSE
[08:28:18.517]                       if (inherits(cond, "message")) {
[08:28:18.517]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.517]                         if (muffled) 
[08:28:18.517]                           invokeRestart("muffleMessage")
[08:28:18.517]                       }
[08:28:18.517]                       else if (inherits(cond, "warning")) {
[08:28:18.517]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.517]                         if (muffled) 
[08:28:18.517]                           invokeRestart("muffleWarning")
[08:28:18.517]                       }
[08:28:18.517]                       else if (inherits(cond, "condition")) {
[08:28:18.517]                         if (!is.null(pattern)) {
[08:28:18.517]                           computeRestarts <- base::computeRestarts
[08:28:18.517]                           grepl <- base::grepl
[08:28:18.517]                           restarts <- computeRestarts(cond)
[08:28:18.517]                           for (restart in restarts) {
[08:28:18.517]                             name <- restart$name
[08:28:18.517]                             if (is.null(name)) 
[08:28:18.517]                               next
[08:28:18.517]                             if (!grepl(pattern, name)) 
[08:28:18.517]                               next
[08:28:18.517]                             invokeRestart(restart)
[08:28:18.517]                             muffled <- TRUE
[08:28:18.517]                             break
[08:28:18.517]                           }
[08:28:18.517]                         }
[08:28:18.517]                       }
[08:28:18.517]                       invisible(muffled)
[08:28:18.517]                     }
[08:28:18.517]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.517]                   }
[08:28:18.517]                 }
[08:28:18.517]                 else {
[08:28:18.517]                   if (TRUE) {
[08:28:18.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.517]                     {
[08:28:18.517]                       inherits <- base::inherits
[08:28:18.517]                       invokeRestart <- base::invokeRestart
[08:28:18.517]                       is.null <- base::is.null
[08:28:18.517]                       muffled <- FALSE
[08:28:18.517]                       if (inherits(cond, "message")) {
[08:28:18.517]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.517]                         if (muffled) 
[08:28:18.517]                           invokeRestart("muffleMessage")
[08:28:18.517]                       }
[08:28:18.517]                       else if (inherits(cond, "warning")) {
[08:28:18.517]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.517]                         if (muffled) 
[08:28:18.517]                           invokeRestart("muffleWarning")
[08:28:18.517]                       }
[08:28:18.517]                       else if (inherits(cond, "condition")) {
[08:28:18.517]                         if (!is.null(pattern)) {
[08:28:18.517]                           computeRestarts <- base::computeRestarts
[08:28:18.517]                           grepl <- base::grepl
[08:28:18.517]                           restarts <- computeRestarts(cond)
[08:28:18.517]                           for (restart in restarts) {
[08:28:18.517]                             name <- restart$name
[08:28:18.517]                             if (is.null(name)) 
[08:28:18.517]                               next
[08:28:18.517]                             if (!grepl(pattern, name)) 
[08:28:18.517]                               next
[08:28:18.517]                             invokeRestart(restart)
[08:28:18.517]                             muffled <- TRUE
[08:28:18.517]                             break
[08:28:18.517]                           }
[08:28:18.517]                         }
[08:28:18.517]                       }
[08:28:18.517]                       invisible(muffled)
[08:28:18.517]                     }
[08:28:18.517]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.517]                   }
[08:28:18.517]                 }
[08:28:18.517]             }
[08:28:18.517]         }))
[08:28:18.517]     }, error = function(ex) {
[08:28:18.517]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.517]                 ...future.rng), started = ...future.startTime, 
[08:28:18.517]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.517]             version = "1.8"), class = "FutureResult")
[08:28:18.517]     }, finally = {
[08:28:18.517]         if (!identical(...future.workdir, getwd())) 
[08:28:18.517]             setwd(...future.workdir)
[08:28:18.517]         {
[08:28:18.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.517]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.517]             }
[08:28:18.517]             base::options(...future.oldOptions)
[08:28:18.517]             if (.Platform$OS.type == "windows") {
[08:28:18.517]                 old_names <- names(...future.oldEnvVars)
[08:28:18.517]                 envs <- base::Sys.getenv()
[08:28:18.517]                 names <- names(envs)
[08:28:18.517]                 common <- intersect(names, old_names)
[08:28:18.517]                 added <- setdiff(names, old_names)
[08:28:18.517]                 removed <- setdiff(old_names, names)
[08:28:18.517]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.517]                   envs[common]]
[08:28:18.517]                 NAMES <- toupper(changed)
[08:28:18.517]                 args <- list()
[08:28:18.517]                 for (kk in seq_along(NAMES)) {
[08:28:18.517]                   name <- changed[[kk]]
[08:28:18.517]                   NAME <- NAMES[[kk]]
[08:28:18.517]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.517]                     next
[08:28:18.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.517]                 }
[08:28:18.517]                 NAMES <- toupper(added)
[08:28:18.517]                 for (kk in seq_along(NAMES)) {
[08:28:18.517]                   name <- added[[kk]]
[08:28:18.517]                   NAME <- NAMES[[kk]]
[08:28:18.517]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.517]                     next
[08:28:18.517]                   args[[name]] <- ""
[08:28:18.517]                 }
[08:28:18.517]                 NAMES <- toupper(removed)
[08:28:18.517]                 for (kk in seq_along(NAMES)) {
[08:28:18.517]                   name <- removed[[kk]]
[08:28:18.517]                   NAME <- NAMES[[kk]]
[08:28:18.517]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.517]                     next
[08:28:18.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.517]                 }
[08:28:18.517]                 if (length(args) > 0) 
[08:28:18.517]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.517]             }
[08:28:18.517]             else {
[08:28:18.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.517]             }
[08:28:18.517]             {
[08:28:18.517]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.517]                   0L) {
[08:28:18.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.517]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.517]                   base::options(opts)
[08:28:18.517]                 }
[08:28:18.517]                 {
[08:28:18.517]                   {
[08:28:18.517]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.517]                     NULL
[08:28:18.517]                   }
[08:28:18.517]                   options(future.plan = NULL)
[08:28:18.517]                   if (is.na(NA_character_)) 
[08:28:18.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.517]                     .init = FALSE)
[08:28:18.517]                 }
[08:28:18.517]             }
[08:28:18.517]         }
[08:28:18.517]     })
[08:28:18.517]     if (TRUE) {
[08:28:18.517]         base::sink(type = "output", split = FALSE)
[08:28:18.517]         if (TRUE) {
[08:28:18.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.517]         }
[08:28:18.517]         else {
[08:28:18.517]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.517]         }
[08:28:18.517]         base::close(...future.stdout)
[08:28:18.517]         ...future.stdout <- NULL
[08:28:18.517]     }
[08:28:18.517]     ...future.result$conditions <- ...future.conditions
[08:28:18.517]     ...future.result$finished <- base::Sys.time()
[08:28:18.517]     ...future.result
[08:28:18.517] }
[08:28:18.531] Exporting 1 global objects (313.44 KiB) to cluster node #1 ...
[08:28:18.543] Exporting ‘a’ (313.23 KiB) to cluster node #1 ...
[08:28:18.596] Exporting ‘a’ (313.23 KiB) to cluster node #1 ... DONE
[08:28:18.596] Exporting 1 global objects (313.44 KiB) to cluster node #1 ... DONE
[08:28:18.597] MultisessionFuture started
[08:28:18.597] - Launch lazy future ... done
[08:28:18.597] run() for ‘MultisessionFuture’ ... done
[08:28:18.597] result() for ClusterFuture ...
[08:28:18.597] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.597] - Validating connection of MultisessionFuture
[08:28:18.643] - received message: FutureResult
[08:28:18.643] - Received FutureResult
[08:28:18.643] - Erased future from FutureRegistry
[08:28:18.643] result() for ClusterFuture ...
[08:28:18.643] - result already collected: FutureResult
[08:28:18.643] result() for ClusterFuture ... done
[08:28:18.643] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.644] result() for ClusterFuture ... done
[08:28:18.644] result() for ClusterFuture ...
[08:28:18.644] - result already collected: FutureResult
[08:28:18.644] result() for ClusterFuture ... done
value(b) = 2
[08:28:18.644] result() for ClusterFuture ...
[08:28:18.644] - result already collected: FutureResult
[08:28:18.644] result() for ClusterFuture ... done
[08:28:18.644] result() for ClusterFuture ...
[08:28:18.644] - result already collected: FutureResult
[08:28:18.645] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.645] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.645] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.646] 
[08:28:18.646] Searching for globals ... DONE
[08:28:18.646] - globals: [0] <none>
[08:28:18.646] getGlobalsAndPackages() ... DONE
[08:28:18.646] run() for ‘Future’ ...
[08:28:18.646] - state: ‘created’
[08:28:18.646] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.661] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.661] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.662]   - Field: ‘node’
[08:28:18.662]   - Field: ‘label’
[08:28:18.662]   - Field: ‘local’
[08:28:18.662]   - Field: ‘owner’
[08:28:18.662]   - Field: ‘envir’
[08:28:18.662]   - Field: ‘workers’
[08:28:18.662]   - Field: ‘packages’
[08:28:18.662]   - Field: ‘gc’
[08:28:18.662]   - Field: ‘conditions’
[08:28:18.662]   - Field: ‘persistent’
[08:28:18.662]   - Field: ‘expr’
[08:28:18.663]   - Field: ‘uuid’
[08:28:18.663]   - Field: ‘seed’
[08:28:18.663]   - Field: ‘version’
[08:28:18.663]   - Field: ‘result’
[08:28:18.663]   - Field: ‘asynchronous’
[08:28:18.663]   - Field: ‘calls’
[08:28:18.663]   - Field: ‘globals’
[08:28:18.663]   - Field: ‘stdout’
[08:28:18.663]   - Field: ‘earlySignal’
[08:28:18.663]   - Field: ‘lazy’
[08:28:18.663]   - Field: ‘state’
[08:28:18.663] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.664] - Launch lazy future ...
[08:28:18.664] Packages needed by the future expression (n = 0): <none>
[08:28:18.664] Packages needed by future strategies (n = 0): <none>
[08:28:18.664] {
[08:28:18.664]     {
[08:28:18.664]         {
[08:28:18.664]             ...future.startTime <- base::Sys.time()
[08:28:18.664]             {
[08:28:18.664]                 {
[08:28:18.664]                   {
[08:28:18.664]                     {
[08:28:18.664]                       base::local({
[08:28:18.664]                         has_future <- base::requireNamespace("future", 
[08:28:18.664]                           quietly = TRUE)
[08:28:18.664]                         if (has_future) {
[08:28:18.664]                           ns <- base::getNamespace("future")
[08:28:18.664]                           version <- ns[[".package"]][["version"]]
[08:28:18.664]                           if (is.null(version)) 
[08:28:18.664]                             version <- utils::packageVersion("future")
[08:28:18.664]                         }
[08:28:18.664]                         else {
[08:28:18.664]                           version <- NULL
[08:28:18.664]                         }
[08:28:18.664]                         if (!has_future || version < "1.8.0") {
[08:28:18.664]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.664]                             "", base::R.version$version.string), 
[08:28:18.664]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.664]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.664]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.664]                               "release", "version")], collapse = " "), 
[08:28:18.664]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.664]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.664]                             info)
[08:28:18.664]                           info <- base::paste(info, collapse = "; ")
[08:28:18.664]                           if (!has_future) {
[08:28:18.664]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.664]                               info)
[08:28:18.664]                           }
[08:28:18.664]                           else {
[08:28:18.664]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.664]                               info, version)
[08:28:18.664]                           }
[08:28:18.664]                           base::stop(msg)
[08:28:18.664]                         }
[08:28:18.664]                       })
[08:28:18.664]                     }
[08:28:18.664]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.664]                     base::options(mc.cores = 1L)
[08:28:18.664]                   }
[08:28:18.664]                   ...future.strategy.old <- future::plan("list")
[08:28:18.664]                   options(future.plan = NULL)
[08:28:18.664]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.664]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.664]                 }
[08:28:18.664]                 ...future.workdir <- getwd()
[08:28:18.664]             }
[08:28:18.664]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.664]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.664]         }
[08:28:18.664]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.664]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.664]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.664]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.664]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.664]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.664]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.664]             base::names(...future.oldOptions))
[08:28:18.664]     }
[08:28:18.664]     if (FALSE) {
[08:28:18.664]     }
[08:28:18.664]     else {
[08:28:18.664]         if (TRUE) {
[08:28:18.664]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.664]                 open = "w")
[08:28:18.664]         }
[08:28:18.664]         else {
[08:28:18.664]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.664]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.664]         }
[08:28:18.664]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.664]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.664]             base::sink(type = "output", split = FALSE)
[08:28:18.664]             base::close(...future.stdout)
[08:28:18.664]         }, add = TRUE)
[08:28:18.664]     }
[08:28:18.664]     ...future.frame <- base::sys.nframe()
[08:28:18.664]     ...future.conditions <- base::list()
[08:28:18.664]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.664]     if (FALSE) {
[08:28:18.664]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.664]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.664]     }
[08:28:18.664]     ...future.result <- base::tryCatch({
[08:28:18.664]         base::withCallingHandlers({
[08:28:18.664]             ...future.value <- base::withVisible(base::local({
[08:28:18.664]                 ...future.makeSendCondition <- base::local({
[08:28:18.664]                   sendCondition <- NULL
[08:28:18.664]                   function(frame = 1L) {
[08:28:18.664]                     if (is.function(sendCondition)) 
[08:28:18.664]                       return(sendCondition)
[08:28:18.664]                     ns <- getNamespace("parallel")
[08:28:18.664]                     if (exists("sendData", mode = "function", 
[08:28:18.664]                       envir = ns)) {
[08:28:18.664]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.664]                         envir = ns)
[08:28:18.664]                       envir <- sys.frame(frame)
[08:28:18.664]                       master <- NULL
[08:28:18.664]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.664]                         !identical(envir, emptyenv())) {
[08:28:18.664]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.664]                           inherits = FALSE)) {
[08:28:18.664]                           master <- get("master", mode = "list", 
[08:28:18.664]                             envir = envir, inherits = FALSE)
[08:28:18.664]                           if (inherits(master, c("SOCKnode", 
[08:28:18.664]                             "SOCK0node"))) {
[08:28:18.664]                             sendCondition <<- function(cond) {
[08:28:18.664]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.664]                                 success = TRUE)
[08:28:18.664]                               parallel_sendData(master, data)
[08:28:18.664]                             }
[08:28:18.664]                             return(sendCondition)
[08:28:18.664]                           }
[08:28:18.664]                         }
[08:28:18.664]                         frame <- frame + 1L
[08:28:18.664]                         envir <- sys.frame(frame)
[08:28:18.664]                       }
[08:28:18.664]                     }
[08:28:18.664]                     sendCondition <<- function(cond) NULL
[08:28:18.664]                   }
[08:28:18.664]                 })
[08:28:18.664]                 withCallingHandlers({
[08:28:18.664]                   1
[08:28:18.664]                 }, immediateCondition = function(cond) {
[08:28:18.664]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.664]                   sendCondition(cond)
[08:28:18.664]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.664]                   {
[08:28:18.664]                     inherits <- base::inherits
[08:28:18.664]                     invokeRestart <- base::invokeRestart
[08:28:18.664]                     is.null <- base::is.null
[08:28:18.664]                     muffled <- FALSE
[08:28:18.664]                     if (inherits(cond, "message")) {
[08:28:18.664]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.664]                       if (muffled) 
[08:28:18.664]                         invokeRestart("muffleMessage")
[08:28:18.664]                     }
[08:28:18.664]                     else if (inherits(cond, "warning")) {
[08:28:18.664]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.664]                       if (muffled) 
[08:28:18.664]                         invokeRestart("muffleWarning")
[08:28:18.664]                     }
[08:28:18.664]                     else if (inherits(cond, "condition")) {
[08:28:18.664]                       if (!is.null(pattern)) {
[08:28:18.664]                         computeRestarts <- base::computeRestarts
[08:28:18.664]                         grepl <- base::grepl
[08:28:18.664]                         restarts <- computeRestarts(cond)
[08:28:18.664]                         for (restart in restarts) {
[08:28:18.664]                           name <- restart$name
[08:28:18.664]                           if (is.null(name)) 
[08:28:18.664]                             next
[08:28:18.664]                           if (!grepl(pattern, name)) 
[08:28:18.664]                             next
[08:28:18.664]                           invokeRestart(restart)
[08:28:18.664]                           muffled <- TRUE
[08:28:18.664]                           break
[08:28:18.664]                         }
[08:28:18.664]                       }
[08:28:18.664]                     }
[08:28:18.664]                     invisible(muffled)
[08:28:18.664]                   }
[08:28:18.664]                   muffleCondition(cond)
[08:28:18.664]                 })
[08:28:18.664]             }))
[08:28:18.664]             future::FutureResult(value = ...future.value$value, 
[08:28:18.664]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.664]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.664]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.664]                     ...future.globalenv.names))
[08:28:18.664]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.664]         }, condition = base::local({
[08:28:18.664]             c <- base::c
[08:28:18.664]             inherits <- base::inherits
[08:28:18.664]             invokeRestart <- base::invokeRestart
[08:28:18.664]             length <- base::length
[08:28:18.664]             list <- base::list
[08:28:18.664]             seq.int <- base::seq.int
[08:28:18.664]             signalCondition <- base::signalCondition
[08:28:18.664]             sys.calls <- base::sys.calls
[08:28:18.664]             `[[` <- base::`[[`
[08:28:18.664]             `+` <- base::`+`
[08:28:18.664]             `<<-` <- base::`<<-`
[08:28:18.664]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.664]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.664]                   3L)]
[08:28:18.664]             }
[08:28:18.664]             function(cond) {
[08:28:18.664]                 is_error <- inherits(cond, "error")
[08:28:18.664]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.664]                   NULL)
[08:28:18.664]                 if (is_error) {
[08:28:18.664]                   sessionInformation <- function() {
[08:28:18.664]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.664]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.664]                       search = base::search(), system = base::Sys.info())
[08:28:18.664]                   }
[08:28:18.664]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.664]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.664]                     cond$call), session = sessionInformation(), 
[08:28:18.664]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.664]                   signalCondition(cond)
[08:28:18.664]                 }
[08:28:18.664]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.664]                 "immediateCondition"))) {
[08:28:18.664]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.664]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.664]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.664]                   if (TRUE && !signal) {
[08:28:18.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.664]                     {
[08:28:18.664]                       inherits <- base::inherits
[08:28:18.664]                       invokeRestart <- base::invokeRestart
[08:28:18.664]                       is.null <- base::is.null
[08:28:18.664]                       muffled <- FALSE
[08:28:18.664]                       if (inherits(cond, "message")) {
[08:28:18.664]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.664]                         if (muffled) 
[08:28:18.664]                           invokeRestart("muffleMessage")
[08:28:18.664]                       }
[08:28:18.664]                       else if (inherits(cond, "warning")) {
[08:28:18.664]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.664]                         if (muffled) 
[08:28:18.664]                           invokeRestart("muffleWarning")
[08:28:18.664]                       }
[08:28:18.664]                       else if (inherits(cond, "condition")) {
[08:28:18.664]                         if (!is.null(pattern)) {
[08:28:18.664]                           computeRestarts <- base::computeRestarts
[08:28:18.664]                           grepl <- base::grepl
[08:28:18.664]                           restarts <- computeRestarts(cond)
[08:28:18.664]                           for (restart in restarts) {
[08:28:18.664]                             name <- restart$name
[08:28:18.664]                             if (is.null(name)) 
[08:28:18.664]                               next
[08:28:18.664]                             if (!grepl(pattern, name)) 
[08:28:18.664]                               next
[08:28:18.664]                             invokeRestart(restart)
[08:28:18.664]                             muffled <- TRUE
[08:28:18.664]                             break
[08:28:18.664]                           }
[08:28:18.664]                         }
[08:28:18.664]                       }
[08:28:18.664]                       invisible(muffled)
[08:28:18.664]                     }
[08:28:18.664]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.664]                   }
[08:28:18.664]                 }
[08:28:18.664]                 else {
[08:28:18.664]                   if (TRUE) {
[08:28:18.664]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.664]                     {
[08:28:18.664]                       inherits <- base::inherits
[08:28:18.664]                       invokeRestart <- base::invokeRestart
[08:28:18.664]                       is.null <- base::is.null
[08:28:18.664]                       muffled <- FALSE
[08:28:18.664]                       if (inherits(cond, "message")) {
[08:28:18.664]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.664]                         if (muffled) 
[08:28:18.664]                           invokeRestart("muffleMessage")
[08:28:18.664]                       }
[08:28:18.664]                       else if (inherits(cond, "warning")) {
[08:28:18.664]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.664]                         if (muffled) 
[08:28:18.664]                           invokeRestart("muffleWarning")
[08:28:18.664]                       }
[08:28:18.664]                       else if (inherits(cond, "condition")) {
[08:28:18.664]                         if (!is.null(pattern)) {
[08:28:18.664]                           computeRestarts <- base::computeRestarts
[08:28:18.664]                           grepl <- base::grepl
[08:28:18.664]                           restarts <- computeRestarts(cond)
[08:28:18.664]                           for (restart in restarts) {
[08:28:18.664]                             name <- restart$name
[08:28:18.664]                             if (is.null(name)) 
[08:28:18.664]                               next
[08:28:18.664]                             if (!grepl(pattern, name)) 
[08:28:18.664]                               next
[08:28:18.664]                             invokeRestart(restart)
[08:28:18.664]                             muffled <- TRUE
[08:28:18.664]                             break
[08:28:18.664]                           }
[08:28:18.664]                         }
[08:28:18.664]                       }
[08:28:18.664]                       invisible(muffled)
[08:28:18.664]                     }
[08:28:18.664]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.664]                   }
[08:28:18.664]                 }
[08:28:18.664]             }
[08:28:18.664]         }))
[08:28:18.664]     }, error = function(ex) {
[08:28:18.664]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.664]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.664]                 ...future.rng), started = ...future.startTime, 
[08:28:18.664]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.664]             version = "1.8"), class = "FutureResult")
[08:28:18.664]     }, finally = {
[08:28:18.664]         if (!identical(...future.workdir, getwd())) 
[08:28:18.664]             setwd(...future.workdir)
[08:28:18.664]         {
[08:28:18.664]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.664]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.664]             }
[08:28:18.664]             base::options(...future.oldOptions)
[08:28:18.664]             if (.Platform$OS.type == "windows") {
[08:28:18.664]                 old_names <- names(...future.oldEnvVars)
[08:28:18.664]                 envs <- base::Sys.getenv()
[08:28:18.664]                 names <- names(envs)
[08:28:18.664]                 common <- intersect(names, old_names)
[08:28:18.664]                 added <- setdiff(names, old_names)
[08:28:18.664]                 removed <- setdiff(old_names, names)
[08:28:18.664]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.664]                   envs[common]]
[08:28:18.664]                 NAMES <- toupper(changed)
[08:28:18.664]                 args <- list()
[08:28:18.664]                 for (kk in seq_along(NAMES)) {
[08:28:18.664]                   name <- changed[[kk]]
[08:28:18.664]                   NAME <- NAMES[[kk]]
[08:28:18.664]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.664]                     next
[08:28:18.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.664]                 }
[08:28:18.664]                 NAMES <- toupper(added)
[08:28:18.664]                 for (kk in seq_along(NAMES)) {
[08:28:18.664]                   name <- added[[kk]]
[08:28:18.664]                   NAME <- NAMES[[kk]]
[08:28:18.664]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.664]                     next
[08:28:18.664]                   args[[name]] <- ""
[08:28:18.664]                 }
[08:28:18.664]                 NAMES <- toupper(removed)
[08:28:18.664]                 for (kk in seq_along(NAMES)) {
[08:28:18.664]                   name <- removed[[kk]]
[08:28:18.664]                   NAME <- NAMES[[kk]]
[08:28:18.664]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.664]                     next
[08:28:18.664]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.664]                 }
[08:28:18.664]                 if (length(args) > 0) 
[08:28:18.664]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.664]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.664]             }
[08:28:18.664]             else {
[08:28:18.664]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.664]             }
[08:28:18.664]             {
[08:28:18.664]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.664]                   0L) {
[08:28:18.664]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.664]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.664]                   base::options(opts)
[08:28:18.664]                 }
[08:28:18.664]                 {
[08:28:18.664]                   {
[08:28:18.664]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.664]                     NULL
[08:28:18.664]                   }
[08:28:18.664]                   options(future.plan = NULL)
[08:28:18.664]                   if (is.na(NA_character_)) 
[08:28:18.664]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.664]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.664]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.664]                     .init = FALSE)
[08:28:18.664]                 }
[08:28:18.664]             }
[08:28:18.664]         }
[08:28:18.664]     })
[08:28:18.664]     if (TRUE) {
[08:28:18.664]         base::sink(type = "output", split = FALSE)
[08:28:18.664]         if (TRUE) {
[08:28:18.664]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.664]         }
[08:28:18.664]         else {
[08:28:18.664]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.664]         }
[08:28:18.664]         base::close(...future.stdout)
[08:28:18.664]         ...future.stdout <- NULL
[08:28:18.664]     }
[08:28:18.664]     ...future.result$conditions <- ...future.conditions
[08:28:18.664]     ...future.result$finished <- base::Sys.time()
[08:28:18.664]     ...future.result
[08:28:18.664] }
[08:28:18.668] MultisessionFuture started
[08:28:18.668] - Launch lazy future ... done
[08:28:18.668] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.668] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.668] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.669] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:18.669] Searching for globals ... DONE
[08:28:18.669] Resolving globals: TRUE
[08:28:18.669] Resolving any globals that are futures ...
[08:28:18.669] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:18.670] Resolving any globals that are futures ... DONE
[08:28:18.670] Resolving futures part of globals (recursively) ...
[08:28:18.670] resolve() on list ...
[08:28:18.670]  recursive: 99
[08:28:18.670]  length: 1
[08:28:18.670]  elements: ‘a’
[08:28:18.712] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.712] - Validating connection of MultisessionFuture
[08:28:18.713] - received message: FutureResult
[08:28:18.713] - Received FutureResult
[08:28:18.713] - Erased future from FutureRegistry
[08:28:18.713] result() for ClusterFuture ...
[08:28:18.713] - result already collected: FutureResult
[08:28:18.713] result() for ClusterFuture ... done
[08:28:18.713] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.713] Future #1
[08:28:18.713] result() for ClusterFuture ...
[08:28:18.714] - result already collected: FutureResult
[08:28:18.714] result() for ClusterFuture ... done
[08:28:18.714] result() for ClusterFuture ...
[08:28:18.714] - result already collected: FutureResult
[08:28:18.714] result() for ClusterFuture ... done
[08:28:18.714] A MultisessionFuture was resolved
[08:28:18.714]  length: 0 (resolved future 1)
[08:28:18.714] resolve() on list ... DONE
[08:28:18.714] - globals: [1] ‘a’
[08:28:18.714] Resolving futures part of globals (recursively) ... DONE
[08:28:18.726] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[08:28:18.726] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[08:28:18.726] - globals: [1] ‘a’
[08:28:18.726] - packages: [1] ‘future’
[08:28:18.726] getGlobalsAndPackages() ... DONE
[08:28:18.727] run() for ‘Future’ ...
[08:28:18.727] - state: ‘created’
[08:28:18.727] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.741] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.741] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.741]   - Field: ‘node’
[08:28:18.741]   - Field: ‘label’
[08:28:18.741]   - Field: ‘local’
[08:28:18.741]   - Field: ‘owner’
[08:28:18.742]   - Field: ‘envir’
[08:28:18.742]   - Field: ‘workers’
[08:28:18.742]   - Field: ‘packages’
[08:28:18.742]   - Field: ‘gc’
[08:28:18.742]   - Field: ‘conditions’
[08:28:18.742]   - Field: ‘persistent’
[08:28:18.742]   - Field: ‘expr’
[08:28:18.742]   - Field: ‘uuid’
[08:28:18.742]   - Field: ‘seed’
[08:28:18.742]   - Field: ‘version’
[08:28:18.742]   - Field: ‘result’
[08:28:18.742]   - Field: ‘asynchronous’
[08:28:18.743]   - Field: ‘calls’
[08:28:18.743]   - Field: ‘globals’
[08:28:18.743]   - Field: ‘stdout’
[08:28:18.743]   - Field: ‘earlySignal’
[08:28:18.743]   - Field: ‘lazy’
[08:28:18.743]   - Field: ‘state’
[08:28:18.743] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.743] - Launch lazy future ...
[08:28:18.743] Packages needed by the future expression (n = 1): ‘future’
[08:28:18.744] Packages needed by future strategies (n = 0): <none>
[08:28:18.744] {
[08:28:18.744]     {
[08:28:18.744]         {
[08:28:18.744]             ...future.startTime <- base::Sys.time()
[08:28:18.744]             {
[08:28:18.744]                 {
[08:28:18.744]                   {
[08:28:18.744]                     {
[08:28:18.744]                       {
[08:28:18.744]                         base::local({
[08:28:18.744]                           has_future <- base::requireNamespace("future", 
[08:28:18.744]                             quietly = TRUE)
[08:28:18.744]                           if (has_future) {
[08:28:18.744]                             ns <- base::getNamespace("future")
[08:28:18.744]                             version <- ns[[".package"]][["version"]]
[08:28:18.744]                             if (is.null(version)) 
[08:28:18.744]                               version <- utils::packageVersion("future")
[08:28:18.744]                           }
[08:28:18.744]                           else {
[08:28:18.744]                             version <- NULL
[08:28:18.744]                           }
[08:28:18.744]                           if (!has_future || version < "1.8.0") {
[08:28:18.744]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.744]                               "", base::R.version$version.string), 
[08:28:18.744]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:18.744]                                 base::R.version$platform, 8 * 
[08:28:18.744]                                   base::.Machine$sizeof.pointer), 
[08:28:18.744]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.744]                                 "release", "version")], collapse = " "), 
[08:28:18.744]                               hostname = base::Sys.info()[["nodename"]])
[08:28:18.744]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.744]                               info)
[08:28:18.744]                             info <- base::paste(info, collapse = "; ")
[08:28:18.744]                             if (!has_future) {
[08:28:18.744]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.744]                                 info)
[08:28:18.744]                             }
[08:28:18.744]                             else {
[08:28:18.744]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.744]                                 info, version)
[08:28:18.744]                             }
[08:28:18.744]                             base::stop(msg)
[08:28:18.744]                           }
[08:28:18.744]                         })
[08:28:18.744]                       }
[08:28:18.744]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.744]                       base::options(mc.cores = 1L)
[08:28:18.744]                     }
[08:28:18.744]                     base::local({
[08:28:18.744]                       for (pkg in "future") {
[08:28:18.744]                         base::loadNamespace(pkg)
[08:28:18.744]                         base::library(pkg, character.only = TRUE)
[08:28:18.744]                       }
[08:28:18.744]                     })
[08:28:18.744]                   }
[08:28:18.744]                   ...future.strategy.old <- future::plan("list")
[08:28:18.744]                   options(future.plan = NULL)
[08:28:18.744]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.744]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.744]                 }
[08:28:18.744]                 ...future.workdir <- getwd()
[08:28:18.744]             }
[08:28:18.744]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.744]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.744]         }
[08:28:18.744]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.744]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.744]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.744]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.744]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.744]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.744]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.744]             base::names(...future.oldOptions))
[08:28:18.744]     }
[08:28:18.744]     if (FALSE) {
[08:28:18.744]     }
[08:28:18.744]     else {
[08:28:18.744]         if (TRUE) {
[08:28:18.744]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.744]                 open = "w")
[08:28:18.744]         }
[08:28:18.744]         else {
[08:28:18.744]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.744]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.744]         }
[08:28:18.744]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.744]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.744]             base::sink(type = "output", split = FALSE)
[08:28:18.744]             base::close(...future.stdout)
[08:28:18.744]         }, add = TRUE)
[08:28:18.744]     }
[08:28:18.744]     ...future.frame <- base::sys.nframe()
[08:28:18.744]     ...future.conditions <- base::list()
[08:28:18.744]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.744]     if (FALSE) {
[08:28:18.744]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.744]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.744]     }
[08:28:18.744]     ...future.result <- base::tryCatch({
[08:28:18.744]         base::withCallingHandlers({
[08:28:18.744]             ...future.value <- base::withVisible(base::local({
[08:28:18.744]                 ...future.makeSendCondition <- base::local({
[08:28:18.744]                   sendCondition <- NULL
[08:28:18.744]                   function(frame = 1L) {
[08:28:18.744]                     if (is.function(sendCondition)) 
[08:28:18.744]                       return(sendCondition)
[08:28:18.744]                     ns <- getNamespace("parallel")
[08:28:18.744]                     if (exists("sendData", mode = "function", 
[08:28:18.744]                       envir = ns)) {
[08:28:18.744]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.744]                         envir = ns)
[08:28:18.744]                       envir <- sys.frame(frame)
[08:28:18.744]                       master <- NULL
[08:28:18.744]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.744]                         !identical(envir, emptyenv())) {
[08:28:18.744]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.744]                           inherits = FALSE)) {
[08:28:18.744]                           master <- get("master", mode = "list", 
[08:28:18.744]                             envir = envir, inherits = FALSE)
[08:28:18.744]                           if (inherits(master, c("SOCKnode", 
[08:28:18.744]                             "SOCK0node"))) {
[08:28:18.744]                             sendCondition <<- function(cond) {
[08:28:18.744]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.744]                                 success = TRUE)
[08:28:18.744]                               parallel_sendData(master, data)
[08:28:18.744]                             }
[08:28:18.744]                             return(sendCondition)
[08:28:18.744]                           }
[08:28:18.744]                         }
[08:28:18.744]                         frame <- frame + 1L
[08:28:18.744]                         envir <- sys.frame(frame)
[08:28:18.744]                       }
[08:28:18.744]                     }
[08:28:18.744]                     sendCondition <<- function(cond) NULL
[08:28:18.744]                   }
[08:28:18.744]                 })
[08:28:18.744]                 withCallingHandlers({
[08:28:18.744]                   value(a) + 1
[08:28:18.744]                 }, immediateCondition = function(cond) {
[08:28:18.744]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.744]                   sendCondition(cond)
[08:28:18.744]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.744]                   {
[08:28:18.744]                     inherits <- base::inherits
[08:28:18.744]                     invokeRestart <- base::invokeRestart
[08:28:18.744]                     is.null <- base::is.null
[08:28:18.744]                     muffled <- FALSE
[08:28:18.744]                     if (inherits(cond, "message")) {
[08:28:18.744]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.744]                       if (muffled) 
[08:28:18.744]                         invokeRestart("muffleMessage")
[08:28:18.744]                     }
[08:28:18.744]                     else if (inherits(cond, "warning")) {
[08:28:18.744]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.744]                       if (muffled) 
[08:28:18.744]                         invokeRestart("muffleWarning")
[08:28:18.744]                     }
[08:28:18.744]                     else if (inherits(cond, "condition")) {
[08:28:18.744]                       if (!is.null(pattern)) {
[08:28:18.744]                         computeRestarts <- base::computeRestarts
[08:28:18.744]                         grepl <- base::grepl
[08:28:18.744]                         restarts <- computeRestarts(cond)
[08:28:18.744]                         for (restart in restarts) {
[08:28:18.744]                           name <- restart$name
[08:28:18.744]                           if (is.null(name)) 
[08:28:18.744]                             next
[08:28:18.744]                           if (!grepl(pattern, name)) 
[08:28:18.744]                             next
[08:28:18.744]                           invokeRestart(restart)
[08:28:18.744]                           muffled <- TRUE
[08:28:18.744]                           break
[08:28:18.744]                         }
[08:28:18.744]                       }
[08:28:18.744]                     }
[08:28:18.744]                     invisible(muffled)
[08:28:18.744]                   }
[08:28:18.744]                   muffleCondition(cond)
[08:28:18.744]                 })
[08:28:18.744]             }))
[08:28:18.744]             future::FutureResult(value = ...future.value$value, 
[08:28:18.744]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.744]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.744]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.744]                     ...future.globalenv.names))
[08:28:18.744]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.744]         }, condition = base::local({
[08:28:18.744]             c <- base::c
[08:28:18.744]             inherits <- base::inherits
[08:28:18.744]             invokeRestart <- base::invokeRestart
[08:28:18.744]             length <- base::length
[08:28:18.744]             list <- base::list
[08:28:18.744]             seq.int <- base::seq.int
[08:28:18.744]             signalCondition <- base::signalCondition
[08:28:18.744]             sys.calls <- base::sys.calls
[08:28:18.744]             `[[` <- base::`[[`
[08:28:18.744]             `+` <- base::`+`
[08:28:18.744]             `<<-` <- base::`<<-`
[08:28:18.744]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.744]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.744]                   3L)]
[08:28:18.744]             }
[08:28:18.744]             function(cond) {
[08:28:18.744]                 is_error <- inherits(cond, "error")
[08:28:18.744]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.744]                   NULL)
[08:28:18.744]                 if (is_error) {
[08:28:18.744]                   sessionInformation <- function() {
[08:28:18.744]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.744]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.744]                       search = base::search(), system = base::Sys.info())
[08:28:18.744]                   }
[08:28:18.744]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.744]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.744]                     cond$call), session = sessionInformation(), 
[08:28:18.744]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.744]                   signalCondition(cond)
[08:28:18.744]                 }
[08:28:18.744]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.744]                 "immediateCondition"))) {
[08:28:18.744]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.744]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.744]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.744]                   if (TRUE && !signal) {
[08:28:18.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.744]                     {
[08:28:18.744]                       inherits <- base::inherits
[08:28:18.744]                       invokeRestart <- base::invokeRestart
[08:28:18.744]                       is.null <- base::is.null
[08:28:18.744]                       muffled <- FALSE
[08:28:18.744]                       if (inherits(cond, "message")) {
[08:28:18.744]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.744]                         if (muffled) 
[08:28:18.744]                           invokeRestart("muffleMessage")
[08:28:18.744]                       }
[08:28:18.744]                       else if (inherits(cond, "warning")) {
[08:28:18.744]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.744]                         if (muffled) 
[08:28:18.744]                           invokeRestart("muffleWarning")
[08:28:18.744]                       }
[08:28:18.744]                       else if (inherits(cond, "condition")) {
[08:28:18.744]                         if (!is.null(pattern)) {
[08:28:18.744]                           computeRestarts <- base::computeRestarts
[08:28:18.744]                           grepl <- base::grepl
[08:28:18.744]                           restarts <- computeRestarts(cond)
[08:28:18.744]                           for (restart in restarts) {
[08:28:18.744]                             name <- restart$name
[08:28:18.744]                             if (is.null(name)) 
[08:28:18.744]                               next
[08:28:18.744]                             if (!grepl(pattern, name)) 
[08:28:18.744]                               next
[08:28:18.744]                             invokeRestart(restart)
[08:28:18.744]                             muffled <- TRUE
[08:28:18.744]                             break
[08:28:18.744]                           }
[08:28:18.744]                         }
[08:28:18.744]                       }
[08:28:18.744]                       invisible(muffled)
[08:28:18.744]                     }
[08:28:18.744]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.744]                   }
[08:28:18.744]                 }
[08:28:18.744]                 else {
[08:28:18.744]                   if (TRUE) {
[08:28:18.744]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.744]                     {
[08:28:18.744]                       inherits <- base::inherits
[08:28:18.744]                       invokeRestart <- base::invokeRestart
[08:28:18.744]                       is.null <- base::is.null
[08:28:18.744]                       muffled <- FALSE
[08:28:18.744]                       if (inherits(cond, "message")) {
[08:28:18.744]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.744]                         if (muffled) 
[08:28:18.744]                           invokeRestart("muffleMessage")
[08:28:18.744]                       }
[08:28:18.744]                       else if (inherits(cond, "warning")) {
[08:28:18.744]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.744]                         if (muffled) 
[08:28:18.744]                           invokeRestart("muffleWarning")
[08:28:18.744]                       }
[08:28:18.744]                       else if (inherits(cond, "condition")) {
[08:28:18.744]                         if (!is.null(pattern)) {
[08:28:18.744]                           computeRestarts <- base::computeRestarts
[08:28:18.744]                           grepl <- base::grepl
[08:28:18.744]                           restarts <- computeRestarts(cond)
[08:28:18.744]                           for (restart in restarts) {
[08:28:18.744]                             name <- restart$name
[08:28:18.744]                             if (is.null(name)) 
[08:28:18.744]                               next
[08:28:18.744]                             if (!grepl(pattern, name)) 
[08:28:18.744]                               next
[08:28:18.744]                             invokeRestart(restart)
[08:28:18.744]                             muffled <- TRUE
[08:28:18.744]                             break
[08:28:18.744]                           }
[08:28:18.744]                         }
[08:28:18.744]                       }
[08:28:18.744]                       invisible(muffled)
[08:28:18.744]                     }
[08:28:18.744]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.744]                   }
[08:28:18.744]                 }
[08:28:18.744]             }
[08:28:18.744]         }))
[08:28:18.744]     }, error = function(ex) {
[08:28:18.744]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.744]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.744]                 ...future.rng), started = ...future.startTime, 
[08:28:18.744]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.744]             version = "1.8"), class = "FutureResult")
[08:28:18.744]     }, finally = {
[08:28:18.744]         if (!identical(...future.workdir, getwd())) 
[08:28:18.744]             setwd(...future.workdir)
[08:28:18.744]         {
[08:28:18.744]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.744]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.744]             }
[08:28:18.744]             base::options(...future.oldOptions)
[08:28:18.744]             if (.Platform$OS.type == "windows") {
[08:28:18.744]                 old_names <- names(...future.oldEnvVars)
[08:28:18.744]                 envs <- base::Sys.getenv()
[08:28:18.744]                 names <- names(envs)
[08:28:18.744]                 common <- intersect(names, old_names)
[08:28:18.744]                 added <- setdiff(names, old_names)
[08:28:18.744]                 removed <- setdiff(old_names, names)
[08:28:18.744]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.744]                   envs[common]]
[08:28:18.744]                 NAMES <- toupper(changed)
[08:28:18.744]                 args <- list()
[08:28:18.744]                 for (kk in seq_along(NAMES)) {
[08:28:18.744]                   name <- changed[[kk]]
[08:28:18.744]                   NAME <- NAMES[[kk]]
[08:28:18.744]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.744]                     next
[08:28:18.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.744]                 }
[08:28:18.744]                 NAMES <- toupper(added)
[08:28:18.744]                 for (kk in seq_along(NAMES)) {
[08:28:18.744]                   name <- added[[kk]]
[08:28:18.744]                   NAME <- NAMES[[kk]]
[08:28:18.744]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.744]                     next
[08:28:18.744]                   args[[name]] <- ""
[08:28:18.744]                 }
[08:28:18.744]                 NAMES <- toupper(removed)
[08:28:18.744]                 for (kk in seq_along(NAMES)) {
[08:28:18.744]                   name <- removed[[kk]]
[08:28:18.744]                   NAME <- NAMES[[kk]]
[08:28:18.744]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.744]                     next
[08:28:18.744]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.744]                 }
[08:28:18.744]                 if (length(args) > 0) 
[08:28:18.744]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.744]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.744]             }
[08:28:18.744]             else {
[08:28:18.744]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.744]             }
[08:28:18.744]             {
[08:28:18.744]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.744]                   0L) {
[08:28:18.744]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.744]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.744]                   base::options(opts)
[08:28:18.744]                 }
[08:28:18.744]                 {
[08:28:18.744]                   {
[08:28:18.744]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.744]                     NULL
[08:28:18.744]                   }
[08:28:18.744]                   options(future.plan = NULL)
[08:28:18.744]                   if (is.na(NA_character_)) 
[08:28:18.744]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.744]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.744]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.744]                     .init = FALSE)
[08:28:18.744]                 }
[08:28:18.744]             }
[08:28:18.744]         }
[08:28:18.744]     })
[08:28:18.744]     if (TRUE) {
[08:28:18.744]         base::sink(type = "output", split = FALSE)
[08:28:18.744]         if (TRUE) {
[08:28:18.744]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.744]         }
[08:28:18.744]         else {
[08:28:18.744]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.744]         }
[08:28:18.744]         base::close(...future.stdout)
[08:28:18.744]         ...future.stdout <- NULL
[08:28:18.744]     }
[08:28:18.744]     ...future.result$conditions <- ...future.conditions
[08:28:18.744]     ...future.result$finished <- base::Sys.time()
[08:28:18.744]     ...future.result
[08:28:18.744] }
[08:28:18.758] Exporting 1 global objects (313.44 KiB) to cluster node #1 ...
[08:28:18.768] Exporting ‘a’ (313.23 KiB) to cluster node #1 ...
[08:28:18.821] Exporting ‘a’ (313.23 KiB) to cluster node #1 ... DONE
[08:28:18.821] Exporting 1 global objects (313.44 KiB) to cluster node #1 ... DONE
[08:28:18.822] MultisessionFuture started
[08:28:18.822] - Launch lazy future ... done
[08:28:18.822] run() for ‘MultisessionFuture’ ... done
[08:28:18.822] result() for ClusterFuture ...
[08:28:18.822] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.822] - Validating connection of MultisessionFuture
[08:28:18.864] - received message: FutureResult
[08:28:18.865] - Received FutureResult
[08:28:18.865] - Erased future from FutureRegistry
[08:28:18.865] result() for ClusterFuture ...
[08:28:18.865] - result already collected: FutureResult
[08:28:18.865] result() for ClusterFuture ... done
[08:28:18.865] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.865] result() for ClusterFuture ... done
[08:28:18.865] result() for ClusterFuture ...
[08:28:18.865] - result already collected: FutureResult
[08:28:18.865] result() for ClusterFuture ... done
value(b) = 2
[08:28:18.866] result() for ClusterFuture ...
[08:28:18.866] - result already collected: FutureResult
[08:28:18.866] result() for ClusterFuture ... done
[08:28:18.866] result() for ClusterFuture ...
[08:28:18.866] - result already collected: FutureResult
[08:28:18.866] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.866] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.866] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.867] 
[08:28:18.867] Searching for globals ... DONE
[08:28:18.867] - globals: [0] <none>
[08:28:18.867] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:18.868] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:18.868] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:18.869] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:18.869] Searching for globals ... DONE
[08:28:18.869] Resolving globals: TRUE
[08:28:18.869] Resolving any globals that are futures ...
[08:28:18.869] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:18.869] Resolving any globals that are futures ... DONE
[08:28:18.869] Resolving futures part of globals (recursively) ...
[08:28:18.870] resolve() on list ...
[08:28:18.870]  recursive: 99
[08:28:18.870]  length: 1
[08:28:18.870]  elements: ‘a’
[08:28:18.870] run() for ‘Future’ ...
[08:28:18.870] - state: ‘created’
[08:28:18.870] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.884] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.884] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.885]   - Field: ‘node’
[08:28:18.885]   - Field: ‘label’
[08:28:18.885]   - Field: ‘local’
[08:28:18.885]   - Field: ‘owner’
[08:28:18.885]   - Field: ‘envir’
[08:28:18.885]   - Field: ‘workers’
[08:28:18.885]   - Field: ‘packages’
[08:28:18.885]   - Field: ‘gc’
[08:28:18.885]   - Field: ‘conditions’
[08:28:18.885]   - Field: ‘persistent’
[08:28:18.885]   - Field: ‘expr’
[08:28:18.885]   - Field: ‘uuid’
[08:28:18.886]   - Field: ‘seed’
[08:28:18.886]   - Field: ‘version’
[08:28:18.886]   - Field: ‘result’
[08:28:18.886]   - Field: ‘asynchronous’
[08:28:18.886]   - Field: ‘calls’
[08:28:18.886]   - Field: ‘globals’
[08:28:18.886]   - Field: ‘stdout’
[08:28:18.886]   - Field: ‘earlySignal’
[08:28:18.886]   - Field: ‘lazy’
[08:28:18.886]   - Field: ‘state’
[08:28:18.886] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.887] - Launch lazy future ...
[08:28:18.887] Packages needed by the future expression (n = 0): <none>
[08:28:18.887] Packages needed by future strategies (n = 0): <none>
[08:28:18.887] {
[08:28:18.887]     {
[08:28:18.887]         {
[08:28:18.887]             ...future.startTime <- base::Sys.time()
[08:28:18.887]             {
[08:28:18.887]                 {
[08:28:18.887]                   {
[08:28:18.887]                     {
[08:28:18.887]                       base::local({
[08:28:18.887]                         has_future <- base::requireNamespace("future", 
[08:28:18.887]                           quietly = TRUE)
[08:28:18.887]                         if (has_future) {
[08:28:18.887]                           ns <- base::getNamespace("future")
[08:28:18.887]                           version <- ns[[".package"]][["version"]]
[08:28:18.887]                           if (is.null(version)) 
[08:28:18.887]                             version <- utils::packageVersion("future")
[08:28:18.887]                         }
[08:28:18.887]                         else {
[08:28:18.887]                           version <- NULL
[08:28:18.887]                         }
[08:28:18.887]                         if (!has_future || version < "1.8.0") {
[08:28:18.887]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.887]                             "", base::R.version$version.string), 
[08:28:18.887]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:18.887]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:18.887]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.887]                               "release", "version")], collapse = " "), 
[08:28:18.887]                             hostname = base::Sys.info()[["nodename"]])
[08:28:18.887]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.887]                             info)
[08:28:18.887]                           info <- base::paste(info, collapse = "; ")
[08:28:18.887]                           if (!has_future) {
[08:28:18.887]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.887]                               info)
[08:28:18.887]                           }
[08:28:18.887]                           else {
[08:28:18.887]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.887]                               info, version)
[08:28:18.887]                           }
[08:28:18.887]                           base::stop(msg)
[08:28:18.887]                         }
[08:28:18.887]                       })
[08:28:18.887]                     }
[08:28:18.887]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.887]                     base::options(mc.cores = 1L)
[08:28:18.887]                   }
[08:28:18.887]                   ...future.strategy.old <- future::plan("list")
[08:28:18.887]                   options(future.plan = NULL)
[08:28:18.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.887]                 }
[08:28:18.887]                 ...future.workdir <- getwd()
[08:28:18.887]             }
[08:28:18.887]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.887]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.887]         }
[08:28:18.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.887]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.887]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.887]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.887]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.887]             base::names(...future.oldOptions))
[08:28:18.887]     }
[08:28:18.887]     if (FALSE) {
[08:28:18.887]     }
[08:28:18.887]     else {
[08:28:18.887]         if (TRUE) {
[08:28:18.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.887]                 open = "w")
[08:28:18.887]         }
[08:28:18.887]         else {
[08:28:18.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.887]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.887]         }
[08:28:18.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.887]             base::sink(type = "output", split = FALSE)
[08:28:18.887]             base::close(...future.stdout)
[08:28:18.887]         }, add = TRUE)
[08:28:18.887]     }
[08:28:18.887]     ...future.frame <- base::sys.nframe()
[08:28:18.887]     ...future.conditions <- base::list()
[08:28:18.887]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.887]     if (FALSE) {
[08:28:18.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.887]     }
[08:28:18.887]     ...future.result <- base::tryCatch({
[08:28:18.887]         base::withCallingHandlers({
[08:28:18.887]             ...future.value <- base::withVisible(base::local({
[08:28:18.887]                 ...future.makeSendCondition <- base::local({
[08:28:18.887]                   sendCondition <- NULL
[08:28:18.887]                   function(frame = 1L) {
[08:28:18.887]                     if (is.function(sendCondition)) 
[08:28:18.887]                       return(sendCondition)
[08:28:18.887]                     ns <- getNamespace("parallel")
[08:28:18.887]                     if (exists("sendData", mode = "function", 
[08:28:18.887]                       envir = ns)) {
[08:28:18.887]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.887]                         envir = ns)
[08:28:18.887]                       envir <- sys.frame(frame)
[08:28:18.887]                       master <- NULL
[08:28:18.887]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.887]                         !identical(envir, emptyenv())) {
[08:28:18.887]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.887]                           inherits = FALSE)) {
[08:28:18.887]                           master <- get("master", mode = "list", 
[08:28:18.887]                             envir = envir, inherits = FALSE)
[08:28:18.887]                           if (inherits(master, c("SOCKnode", 
[08:28:18.887]                             "SOCK0node"))) {
[08:28:18.887]                             sendCondition <<- function(cond) {
[08:28:18.887]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.887]                                 success = TRUE)
[08:28:18.887]                               parallel_sendData(master, data)
[08:28:18.887]                             }
[08:28:18.887]                             return(sendCondition)
[08:28:18.887]                           }
[08:28:18.887]                         }
[08:28:18.887]                         frame <- frame + 1L
[08:28:18.887]                         envir <- sys.frame(frame)
[08:28:18.887]                       }
[08:28:18.887]                     }
[08:28:18.887]                     sendCondition <<- function(cond) NULL
[08:28:18.887]                   }
[08:28:18.887]                 })
[08:28:18.887]                 withCallingHandlers({
[08:28:18.887]                   1
[08:28:18.887]                 }, immediateCondition = function(cond) {
[08:28:18.887]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.887]                   sendCondition(cond)
[08:28:18.887]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.887]                   {
[08:28:18.887]                     inherits <- base::inherits
[08:28:18.887]                     invokeRestart <- base::invokeRestart
[08:28:18.887]                     is.null <- base::is.null
[08:28:18.887]                     muffled <- FALSE
[08:28:18.887]                     if (inherits(cond, "message")) {
[08:28:18.887]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.887]                       if (muffled) 
[08:28:18.887]                         invokeRestart("muffleMessage")
[08:28:18.887]                     }
[08:28:18.887]                     else if (inherits(cond, "warning")) {
[08:28:18.887]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.887]                       if (muffled) 
[08:28:18.887]                         invokeRestart("muffleWarning")
[08:28:18.887]                     }
[08:28:18.887]                     else if (inherits(cond, "condition")) {
[08:28:18.887]                       if (!is.null(pattern)) {
[08:28:18.887]                         computeRestarts <- base::computeRestarts
[08:28:18.887]                         grepl <- base::grepl
[08:28:18.887]                         restarts <- computeRestarts(cond)
[08:28:18.887]                         for (restart in restarts) {
[08:28:18.887]                           name <- restart$name
[08:28:18.887]                           if (is.null(name)) 
[08:28:18.887]                             next
[08:28:18.887]                           if (!grepl(pattern, name)) 
[08:28:18.887]                             next
[08:28:18.887]                           invokeRestart(restart)
[08:28:18.887]                           muffled <- TRUE
[08:28:18.887]                           break
[08:28:18.887]                         }
[08:28:18.887]                       }
[08:28:18.887]                     }
[08:28:18.887]                     invisible(muffled)
[08:28:18.887]                   }
[08:28:18.887]                   muffleCondition(cond)
[08:28:18.887]                 })
[08:28:18.887]             }))
[08:28:18.887]             future::FutureResult(value = ...future.value$value, 
[08:28:18.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.887]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.887]                     ...future.globalenv.names))
[08:28:18.887]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.887]         }, condition = base::local({
[08:28:18.887]             c <- base::c
[08:28:18.887]             inherits <- base::inherits
[08:28:18.887]             invokeRestart <- base::invokeRestart
[08:28:18.887]             length <- base::length
[08:28:18.887]             list <- base::list
[08:28:18.887]             seq.int <- base::seq.int
[08:28:18.887]             signalCondition <- base::signalCondition
[08:28:18.887]             sys.calls <- base::sys.calls
[08:28:18.887]             `[[` <- base::`[[`
[08:28:18.887]             `+` <- base::`+`
[08:28:18.887]             `<<-` <- base::`<<-`
[08:28:18.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.887]                   3L)]
[08:28:18.887]             }
[08:28:18.887]             function(cond) {
[08:28:18.887]                 is_error <- inherits(cond, "error")
[08:28:18.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.887]                   NULL)
[08:28:18.887]                 if (is_error) {
[08:28:18.887]                   sessionInformation <- function() {
[08:28:18.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.887]                       search = base::search(), system = base::Sys.info())
[08:28:18.887]                   }
[08:28:18.887]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.887]                     cond$call), session = sessionInformation(), 
[08:28:18.887]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.887]                   signalCondition(cond)
[08:28:18.887]                 }
[08:28:18.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.887]                 "immediateCondition"))) {
[08:28:18.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.887]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.887]                   if (TRUE && !signal) {
[08:28:18.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.887]                     {
[08:28:18.887]                       inherits <- base::inherits
[08:28:18.887]                       invokeRestart <- base::invokeRestart
[08:28:18.887]                       is.null <- base::is.null
[08:28:18.887]                       muffled <- FALSE
[08:28:18.887]                       if (inherits(cond, "message")) {
[08:28:18.887]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.887]                         if (muffled) 
[08:28:18.887]                           invokeRestart("muffleMessage")
[08:28:18.887]                       }
[08:28:18.887]                       else if (inherits(cond, "warning")) {
[08:28:18.887]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.887]                         if (muffled) 
[08:28:18.887]                           invokeRestart("muffleWarning")
[08:28:18.887]                       }
[08:28:18.887]                       else if (inherits(cond, "condition")) {
[08:28:18.887]                         if (!is.null(pattern)) {
[08:28:18.887]                           computeRestarts <- base::computeRestarts
[08:28:18.887]                           grepl <- base::grepl
[08:28:18.887]                           restarts <- computeRestarts(cond)
[08:28:18.887]                           for (restart in restarts) {
[08:28:18.887]                             name <- restart$name
[08:28:18.887]                             if (is.null(name)) 
[08:28:18.887]                               next
[08:28:18.887]                             if (!grepl(pattern, name)) 
[08:28:18.887]                               next
[08:28:18.887]                             invokeRestart(restart)
[08:28:18.887]                             muffled <- TRUE
[08:28:18.887]                             break
[08:28:18.887]                           }
[08:28:18.887]                         }
[08:28:18.887]                       }
[08:28:18.887]                       invisible(muffled)
[08:28:18.887]                     }
[08:28:18.887]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.887]                   }
[08:28:18.887]                 }
[08:28:18.887]                 else {
[08:28:18.887]                   if (TRUE) {
[08:28:18.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.887]                     {
[08:28:18.887]                       inherits <- base::inherits
[08:28:18.887]                       invokeRestart <- base::invokeRestart
[08:28:18.887]                       is.null <- base::is.null
[08:28:18.887]                       muffled <- FALSE
[08:28:18.887]                       if (inherits(cond, "message")) {
[08:28:18.887]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.887]                         if (muffled) 
[08:28:18.887]                           invokeRestart("muffleMessage")
[08:28:18.887]                       }
[08:28:18.887]                       else if (inherits(cond, "warning")) {
[08:28:18.887]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.887]                         if (muffled) 
[08:28:18.887]                           invokeRestart("muffleWarning")
[08:28:18.887]                       }
[08:28:18.887]                       else if (inherits(cond, "condition")) {
[08:28:18.887]                         if (!is.null(pattern)) {
[08:28:18.887]                           computeRestarts <- base::computeRestarts
[08:28:18.887]                           grepl <- base::grepl
[08:28:18.887]                           restarts <- computeRestarts(cond)
[08:28:18.887]                           for (restart in restarts) {
[08:28:18.887]                             name <- restart$name
[08:28:18.887]                             if (is.null(name)) 
[08:28:18.887]                               next
[08:28:18.887]                             if (!grepl(pattern, name)) 
[08:28:18.887]                               next
[08:28:18.887]                             invokeRestart(restart)
[08:28:18.887]                             muffled <- TRUE
[08:28:18.887]                             break
[08:28:18.887]                           }
[08:28:18.887]                         }
[08:28:18.887]                       }
[08:28:18.887]                       invisible(muffled)
[08:28:18.887]                     }
[08:28:18.887]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.887]                   }
[08:28:18.887]                 }
[08:28:18.887]             }
[08:28:18.887]         }))
[08:28:18.887]     }, error = function(ex) {
[08:28:18.887]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.887]                 ...future.rng), started = ...future.startTime, 
[08:28:18.887]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.887]             version = "1.8"), class = "FutureResult")
[08:28:18.887]     }, finally = {
[08:28:18.887]         if (!identical(...future.workdir, getwd())) 
[08:28:18.887]             setwd(...future.workdir)
[08:28:18.887]         {
[08:28:18.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.887]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.887]             }
[08:28:18.887]             base::options(...future.oldOptions)
[08:28:18.887]             if (.Platform$OS.type == "windows") {
[08:28:18.887]                 old_names <- names(...future.oldEnvVars)
[08:28:18.887]                 envs <- base::Sys.getenv()
[08:28:18.887]                 names <- names(envs)
[08:28:18.887]                 common <- intersect(names, old_names)
[08:28:18.887]                 added <- setdiff(names, old_names)
[08:28:18.887]                 removed <- setdiff(old_names, names)
[08:28:18.887]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.887]                   envs[common]]
[08:28:18.887]                 NAMES <- toupper(changed)
[08:28:18.887]                 args <- list()
[08:28:18.887]                 for (kk in seq_along(NAMES)) {
[08:28:18.887]                   name <- changed[[kk]]
[08:28:18.887]                   NAME <- NAMES[[kk]]
[08:28:18.887]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.887]                     next
[08:28:18.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.887]                 }
[08:28:18.887]                 NAMES <- toupper(added)
[08:28:18.887]                 for (kk in seq_along(NAMES)) {
[08:28:18.887]                   name <- added[[kk]]
[08:28:18.887]                   NAME <- NAMES[[kk]]
[08:28:18.887]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.887]                     next
[08:28:18.887]                   args[[name]] <- ""
[08:28:18.887]                 }
[08:28:18.887]                 NAMES <- toupper(removed)
[08:28:18.887]                 for (kk in seq_along(NAMES)) {
[08:28:18.887]                   name <- removed[[kk]]
[08:28:18.887]                   NAME <- NAMES[[kk]]
[08:28:18.887]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.887]                     next
[08:28:18.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.887]                 }
[08:28:18.887]                 if (length(args) > 0) 
[08:28:18.887]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.887]             }
[08:28:18.887]             else {
[08:28:18.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.887]             }
[08:28:18.887]             {
[08:28:18.887]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.887]                   0L) {
[08:28:18.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.887]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.887]                   base::options(opts)
[08:28:18.887]                 }
[08:28:18.887]                 {
[08:28:18.887]                   {
[08:28:18.887]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.887]                     NULL
[08:28:18.887]                   }
[08:28:18.887]                   options(future.plan = NULL)
[08:28:18.887]                   if (is.na(NA_character_)) 
[08:28:18.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.887]                     .init = FALSE)
[08:28:18.887]                 }
[08:28:18.887]             }
[08:28:18.887]         }
[08:28:18.887]     })
[08:28:18.887]     if (TRUE) {
[08:28:18.887]         base::sink(type = "output", split = FALSE)
[08:28:18.887]         if (TRUE) {
[08:28:18.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.887]         }
[08:28:18.887]         else {
[08:28:18.887]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.887]         }
[08:28:18.887]         base::close(...future.stdout)
[08:28:18.887]         ...future.stdout <- NULL
[08:28:18.887]     }
[08:28:18.887]     ...future.result$conditions <- ...future.conditions
[08:28:18.887]     ...future.result$finished <- base::Sys.time()
[08:28:18.887]     ...future.result
[08:28:18.887] }
[08:28:18.890] MultisessionFuture started
[08:28:18.891] - Launch lazy future ... done
[08:28:18.891] run() for ‘MultisessionFuture’ ... done
[08:28:18.933] receiveMessageFromWorker() for ClusterFuture ...
[08:28:18.933] - Validating connection of MultisessionFuture
[08:28:18.933] - received message: FutureResult
[08:28:18.933] - Received FutureResult
[08:28:18.934] - Erased future from FutureRegistry
[08:28:18.934] result() for ClusterFuture ...
[08:28:18.934] - result already collected: FutureResult
[08:28:18.934] result() for ClusterFuture ... done
[08:28:18.934] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:18.934] Future #1
[08:28:18.934] result() for ClusterFuture ...
[08:28:18.934] - result already collected: FutureResult
[08:28:18.934] result() for ClusterFuture ... done
[08:28:18.934] result() for ClusterFuture ...
[08:28:18.934] - result already collected: FutureResult
[08:28:18.934] result() for ClusterFuture ... done
[08:28:18.935] A MultisessionFuture was resolved
[08:28:18.935]  length: 0 (resolved future 1)
[08:28:18.935] resolve() on list ... DONE
[08:28:18.935] - globals: [1] ‘a’
[08:28:18.935] Resolving futures part of globals (recursively) ... DONE
[08:28:18.946] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[08:28:18.946] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[08:28:18.947] - globals: [1] ‘a’
[08:28:18.947] - packages: [1] ‘future’
[08:28:18.947] getGlobalsAndPackages() ... DONE
[08:28:18.947] run() for ‘Future’ ...
[08:28:18.947] - state: ‘created’
[08:28:18.947] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:18.961] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:18.962] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:18.962]   - Field: ‘node’
[08:28:18.962]   - Field: ‘label’
[08:28:18.962]   - Field: ‘local’
[08:28:18.962]   - Field: ‘owner’
[08:28:18.962]   - Field: ‘envir’
[08:28:18.962]   - Field: ‘workers’
[08:28:18.962]   - Field: ‘packages’
[08:28:18.962]   - Field: ‘gc’
[08:28:18.962]   - Field: ‘conditions’
[08:28:18.962]   - Field: ‘persistent’
[08:28:18.963]   - Field: ‘expr’
[08:28:18.963]   - Field: ‘uuid’
[08:28:18.963]   - Field: ‘seed’
[08:28:18.963]   - Field: ‘version’
[08:28:18.963]   - Field: ‘result’
[08:28:18.963]   - Field: ‘asynchronous’
[08:28:18.963]   - Field: ‘calls’
[08:28:18.963]   - Field: ‘globals’
[08:28:18.963]   - Field: ‘stdout’
[08:28:18.963]   - Field: ‘earlySignal’
[08:28:18.963]   - Field: ‘lazy’
[08:28:18.964]   - Field: ‘state’
[08:28:18.964] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:18.966] - Launch lazy future ...
[08:28:18.966] Packages needed by the future expression (n = 1): ‘future’
[08:28:18.967] Packages needed by future strategies (n = 0): <none>
[08:28:18.967] {
[08:28:18.967]     {
[08:28:18.967]         {
[08:28:18.967]             ...future.startTime <- base::Sys.time()
[08:28:18.967]             {
[08:28:18.967]                 {
[08:28:18.967]                   {
[08:28:18.967]                     {
[08:28:18.967]                       {
[08:28:18.967]                         base::local({
[08:28:18.967]                           has_future <- base::requireNamespace("future", 
[08:28:18.967]                             quietly = TRUE)
[08:28:18.967]                           if (has_future) {
[08:28:18.967]                             ns <- base::getNamespace("future")
[08:28:18.967]                             version <- ns[[".package"]][["version"]]
[08:28:18.967]                             if (is.null(version)) 
[08:28:18.967]                               version <- utils::packageVersion("future")
[08:28:18.967]                           }
[08:28:18.967]                           else {
[08:28:18.967]                             version <- NULL
[08:28:18.967]                           }
[08:28:18.967]                           if (!has_future || version < "1.8.0") {
[08:28:18.967]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:18.967]                               "", base::R.version$version.string), 
[08:28:18.967]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:18.967]                                 base::R.version$platform, 8 * 
[08:28:18.967]                                   base::.Machine$sizeof.pointer), 
[08:28:18.967]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:18.967]                                 "release", "version")], collapse = " "), 
[08:28:18.967]                               hostname = base::Sys.info()[["nodename"]])
[08:28:18.967]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:18.967]                               info)
[08:28:18.967]                             info <- base::paste(info, collapse = "; ")
[08:28:18.967]                             if (!has_future) {
[08:28:18.967]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:18.967]                                 info)
[08:28:18.967]                             }
[08:28:18.967]                             else {
[08:28:18.967]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:18.967]                                 info, version)
[08:28:18.967]                             }
[08:28:18.967]                             base::stop(msg)
[08:28:18.967]                           }
[08:28:18.967]                         })
[08:28:18.967]                       }
[08:28:18.967]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:18.967]                       base::options(mc.cores = 1L)
[08:28:18.967]                     }
[08:28:18.967]                     base::local({
[08:28:18.967]                       for (pkg in "future") {
[08:28:18.967]                         base::loadNamespace(pkg)
[08:28:18.967]                         base::library(pkg, character.only = TRUE)
[08:28:18.967]                       }
[08:28:18.967]                     })
[08:28:18.967]                   }
[08:28:18.967]                   ...future.strategy.old <- future::plan("list")
[08:28:18.967]                   options(future.plan = NULL)
[08:28:18.967]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.967]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:18.967]                 }
[08:28:18.967]                 ...future.workdir <- getwd()
[08:28:18.967]             }
[08:28:18.967]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:18.967]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:18.967]         }
[08:28:18.967]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:18.967]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:18.967]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:18.967]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:18.967]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:18.967]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:18.967]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:18.967]             base::names(...future.oldOptions))
[08:28:18.967]     }
[08:28:18.967]     if (FALSE) {
[08:28:18.967]     }
[08:28:18.967]     else {
[08:28:18.967]         if (TRUE) {
[08:28:18.967]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:18.967]                 open = "w")
[08:28:18.967]         }
[08:28:18.967]         else {
[08:28:18.967]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:18.967]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:18.967]         }
[08:28:18.967]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:18.967]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:18.967]             base::sink(type = "output", split = FALSE)
[08:28:18.967]             base::close(...future.stdout)
[08:28:18.967]         }, add = TRUE)
[08:28:18.967]     }
[08:28:18.967]     ...future.frame <- base::sys.nframe()
[08:28:18.967]     ...future.conditions <- base::list()
[08:28:18.967]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:18.967]     if (FALSE) {
[08:28:18.967]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:18.967]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:18.967]     }
[08:28:18.967]     ...future.result <- base::tryCatch({
[08:28:18.967]         base::withCallingHandlers({
[08:28:18.967]             ...future.value <- base::withVisible(base::local({
[08:28:18.967]                 ...future.makeSendCondition <- base::local({
[08:28:18.967]                   sendCondition <- NULL
[08:28:18.967]                   function(frame = 1L) {
[08:28:18.967]                     if (is.function(sendCondition)) 
[08:28:18.967]                       return(sendCondition)
[08:28:18.967]                     ns <- getNamespace("parallel")
[08:28:18.967]                     if (exists("sendData", mode = "function", 
[08:28:18.967]                       envir = ns)) {
[08:28:18.967]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:18.967]                         envir = ns)
[08:28:18.967]                       envir <- sys.frame(frame)
[08:28:18.967]                       master <- NULL
[08:28:18.967]                       while (!identical(envir, .GlobalEnv) && 
[08:28:18.967]                         !identical(envir, emptyenv())) {
[08:28:18.967]                         if (exists("master", mode = "list", envir = envir, 
[08:28:18.967]                           inherits = FALSE)) {
[08:28:18.967]                           master <- get("master", mode = "list", 
[08:28:18.967]                             envir = envir, inherits = FALSE)
[08:28:18.967]                           if (inherits(master, c("SOCKnode", 
[08:28:18.967]                             "SOCK0node"))) {
[08:28:18.967]                             sendCondition <<- function(cond) {
[08:28:18.967]                               data <- list(type = "VALUE", value = cond, 
[08:28:18.967]                                 success = TRUE)
[08:28:18.967]                               parallel_sendData(master, data)
[08:28:18.967]                             }
[08:28:18.967]                             return(sendCondition)
[08:28:18.967]                           }
[08:28:18.967]                         }
[08:28:18.967]                         frame <- frame + 1L
[08:28:18.967]                         envir <- sys.frame(frame)
[08:28:18.967]                       }
[08:28:18.967]                     }
[08:28:18.967]                     sendCondition <<- function(cond) NULL
[08:28:18.967]                   }
[08:28:18.967]                 })
[08:28:18.967]                 withCallingHandlers({
[08:28:18.967]                   value(a) + 1
[08:28:18.967]                 }, immediateCondition = function(cond) {
[08:28:18.967]                   sendCondition <- ...future.makeSendCondition()
[08:28:18.967]                   sendCondition(cond)
[08:28:18.967]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.967]                   {
[08:28:18.967]                     inherits <- base::inherits
[08:28:18.967]                     invokeRestart <- base::invokeRestart
[08:28:18.967]                     is.null <- base::is.null
[08:28:18.967]                     muffled <- FALSE
[08:28:18.967]                     if (inherits(cond, "message")) {
[08:28:18.967]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:18.967]                       if (muffled) 
[08:28:18.967]                         invokeRestart("muffleMessage")
[08:28:18.967]                     }
[08:28:18.967]                     else if (inherits(cond, "warning")) {
[08:28:18.967]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:18.967]                       if (muffled) 
[08:28:18.967]                         invokeRestart("muffleWarning")
[08:28:18.967]                     }
[08:28:18.967]                     else if (inherits(cond, "condition")) {
[08:28:18.967]                       if (!is.null(pattern)) {
[08:28:18.967]                         computeRestarts <- base::computeRestarts
[08:28:18.967]                         grepl <- base::grepl
[08:28:18.967]                         restarts <- computeRestarts(cond)
[08:28:18.967]                         for (restart in restarts) {
[08:28:18.967]                           name <- restart$name
[08:28:18.967]                           if (is.null(name)) 
[08:28:18.967]                             next
[08:28:18.967]                           if (!grepl(pattern, name)) 
[08:28:18.967]                             next
[08:28:18.967]                           invokeRestart(restart)
[08:28:18.967]                           muffled <- TRUE
[08:28:18.967]                           break
[08:28:18.967]                         }
[08:28:18.967]                       }
[08:28:18.967]                     }
[08:28:18.967]                     invisible(muffled)
[08:28:18.967]                   }
[08:28:18.967]                   muffleCondition(cond)
[08:28:18.967]                 })
[08:28:18.967]             }))
[08:28:18.967]             future::FutureResult(value = ...future.value$value, 
[08:28:18.967]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.967]                   ...future.rng), globalenv = if (FALSE) 
[08:28:18.967]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:18.967]                     ...future.globalenv.names))
[08:28:18.967]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:18.967]         }, condition = base::local({
[08:28:18.967]             c <- base::c
[08:28:18.967]             inherits <- base::inherits
[08:28:18.967]             invokeRestart <- base::invokeRestart
[08:28:18.967]             length <- base::length
[08:28:18.967]             list <- base::list
[08:28:18.967]             seq.int <- base::seq.int
[08:28:18.967]             signalCondition <- base::signalCondition
[08:28:18.967]             sys.calls <- base::sys.calls
[08:28:18.967]             `[[` <- base::`[[`
[08:28:18.967]             `+` <- base::`+`
[08:28:18.967]             `<<-` <- base::`<<-`
[08:28:18.967]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:18.967]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:18.967]                   3L)]
[08:28:18.967]             }
[08:28:18.967]             function(cond) {
[08:28:18.967]                 is_error <- inherits(cond, "error")
[08:28:18.967]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:18.967]                   NULL)
[08:28:18.967]                 if (is_error) {
[08:28:18.967]                   sessionInformation <- function() {
[08:28:18.967]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:18.967]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:18.967]                       search = base::search(), system = base::Sys.info())
[08:28:18.967]                   }
[08:28:18.967]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.967]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:18.967]                     cond$call), session = sessionInformation(), 
[08:28:18.967]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:18.967]                   signalCondition(cond)
[08:28:18.967]                 }
[08:28:18.967]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:18.967]                 "immediateCondition"))) {
[08:28:18.967]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:18.967]                   ...future.conditions[[length(...future.conditions) + 
[08:28:18.967]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:18.967]                   if (TRUE && !signal) {
[08:28:18.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.967]                     {
[08:28:18.967]                       inherits <- base::inherits
[08:28:18.967]                       invokeRestart <- base::invokeRestart
[08:28:18.967]                       is.null <- base::is.null
[08:28:18.967]                       muffled <- FALSE
[08:28:18.967]                       if (inherits(cond, "message")) {
[08:28:18.967]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.967]                         if (muffled) 
[08:28:18.967]                           invokeRestart("muffleMessage")
[08:28:18.967]                       }
[08:28:18.967]                       else if (inherits(cond, "warning")) {
[08:28:18.967]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.967]                         if (muffled) 
[08:28:18.967]                           invokeRestart("muffleWarning")
[08:28:18.967]                       }
[08:28:18.967]                       else if (inherits(cond, "condition")) {
[08:28:18.967]                         if (!is.null(pattern)) {
[08:28:18.967]                           computeRestarts <- base::computeRestarts
[08:28:18.967]                           grepl <- base::grepl
[08:28:18.967]                           restarts <- computeRestarts(cond)
[08:28:18.967]                           for (restart in restarts) {
[08:28:18.967]                             name <- restart$name
[08:28:18.967]                             if (is.null(name)) 
[08:28:18.967]                               next
[08:28:18.967]                             if (!grepl(pattern, name)) 
[08:28:18.967]                               next
[08:28:18.967]                             invokeRestart(restart)
[08:28:18.967]                             muffled <- TRUE
[08:28:18.967]                             break
[08:28:18.967]                           }
[08:28:18.967]                         }
[08:28:18.967]                       }
[08:28:18.967]                       invisible(muffled)
[08:28:18.967]                     }
[08:28:18.967]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.967]                   }
[08:28:18.967]                 }
[08:28:18.967]                 else {
[08:28:18.967]                   if (TRUE) {
[08:28:18.967]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:18.967]                     {
[08:28:18.967]                       inherits <- base::inherits
[08:28:18.967]                       invokeRestart <- base::invokeRestart
[08:28:18.967]                       is.null <- base::is.null
[08:28:18.967]                       muffled <- FALSE
[08:28:18.967]                       if (inherits(cond, "message")) {
[08:28:18.967]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:18.967]                         if (muffled) 
[08:28:18.967]                           invokeRestart("muffleMessage")
[08:28:18.967]                       }
[08:28:18.967]                       else if (inherits(cond, "warning")) {
[08:28:18.967]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:18.967]                         if (muffled) 
[08:28:18.967]                           invokeRestart("muffleWarning")
[08:28:18.967]                       }
[08:28:18.967]                       else if (inherits(cond, "condition")) {
[08:28:18.967]                         if (!is.null(pattern)) {
[08:28:18.967]                           computeRestarts <- base::computeRestarts
[08:28:18.967]                           grepl <- base::grepl
[08:28:18.967]                           restarts <- computeRestarts(cond)
[08:28:18.967]                           for (restart in restarts) {
[08:28:18.967]                             name <- restart$name
[08:28:18.967]                             if (is.null(name)) 
[08:28:18.967]                               next
[08:28:18.967]                             if (!grepl(pattern, name)) 
[08:28:18.967]                               next
[08:28:18.967]                             invokeRestart(restart)
[08:28:18.967]                             muffled <- TRUE
[08:28:18.967]                             break
[08:28:18.967]                           }
[08:28:18.967]                         }
[08:28:18.967]                       }
[08:28:18.967]                       invisible(muffled)
[08:28:18.967]                     }
[08:28:18.967]                     muffleCondition(cond, pattern = "^muffle")
[08:28:18.967]                   }
[08:28:18.967]                 }
[08:28:18.967]             }
[08:28:18.967]         }))
[08:28:18.967]     }, error = function(ex) {
[08:28:18.967]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:18.967]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:18.967]                 ...future.rng), started = ...future.startTime, 
[08:28:18.967]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:18.967]             version = "1.8"), class = "FutureResult")
[08:28:18.967]     }, finally = {
[08:28:18.967]         if (!identical(...future.workdir, getwd())) 
[08:28:18.967]             setwd(...future.workdir)
[08:28:18.967]         {
[08:28:18.967]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:18.967]                 ...future.oldOptions$nwarnings <- NULL
[08:28:18.967]             }
[08:28:18.967]             base::options(...future.oldOptions)
[08:28:18.967]             if (.Platform$OS.type == "windows") {
[08:28:18.967]                 old_names <- names(...future.oldEnvVars)
[08:28:18.967]                 envs <- base::Sys.getenv()
[08:28:18.967]                 names <- names(envs)
[08:28:18.967]                 common <- intersect(names, old_names)
[08:28:18.967]                 added <- setdiff(names, old_names)
[08:28:18.967]                 removed <- setdiff(old_names, names)
[08:28:18.967]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:18.967]                   envs[common]]
[08:28:18.967]                 NAMES <- toupper(changed)
[08:28:18.967]                 args <- list()
[08:28:18.967]                 for (kk in seq_along(NAMES)) {
[08:28:18.967]                   name <- changed[[kk]]
[08:28:18.967]                   NAME <- NAMES[[kk]]
[08:28:18.967]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.967]                     next
[08:28:18.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.967]                 }
[08:28:18.967]                 NAMES <- toupper(added)
[08:28:18.967]                 for (kk in seq_along(NAMES)) {
[08:28:18.967]                   name <- added[[kk]]
[08:28:18.967]                   NAME <- NAMES[[kk]]
[08:28:18.967]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.967]                     next
[08:28:18.967]                   args[[name]] <- ""
[08:28:18.967]                 }
[08:28:18.967]                 NAMES <- toupper(removed)
[08:28:18.967]                 for (kk in seq_along(NAMES)) {
[08:28:18.967]                   name <- removed[[kk]]
[08:28:18.967]                   NAME <- NAMES[[kk]]
[08:28:18.967]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:18.967]                     next
[08:28:18.967]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:18.967]                 }
[08:28:18.967]                 if (length(args) > 0) 
[08:28:18.967]                   base::do.call(base::Sys.setenv, args = args)
[08:28:18.967]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:18.967]             }
[08:28:18.967]             else {
[08:28:18.967]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:18.967]             }
[08:28:18.967]             {
[08:28:18.967]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:18.967]                   0L) {
[08:28:18.967]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:18.967]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:18.967]                   base::options(opts)
[08:28:18.967]                 }
[08:28:18.967]                 {
[08:28:18.967]                   {
[08:28:18.967]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:18.967]                     NULL
[08:28:18.967]                   }
[08:28:18.967]                   options(future.plan = NULL)
[08:28:18.967]                   if (is.na(NA_character_)) 
[08:28:18.967]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:18.967]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:18.967]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:18.967]                     .init = FALSE)
[08:28:18.967]                 }
[08:28:18.967]             }
[08:28:18.967]         }
[08:28:18.967]     })
[08:28:18.967]     if (TRUE) {
[08:28:18.967]         base::sink(type = "output", split = FALSE)
[08:28:18.967]         if (TRUE) {
[08:28:18.967]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:18.967]         }
[08:28:18.967]         else {
[08:28:18.967]             ...future.result["stdout"] <- base::list(NULL)
[08:28:18.967]         }
[08:28:18.967]         base::close(...future.stdout)
[08:28:18.967]         ...future.stdout <- NULL
[08:28:18.967]     }
[08:28:18.967]     ...future.result$conditions <- ...future.conditions
[08:28:18.967]     ...future.result$finished <- base::Sys.time()
[08:28:18.967]     ...future.result
[08:28:18.967] }
[08:28:18.981] Exporting 1 global objects (313.46 KiB) to cluster node #1 ...
[08:28:18.992] Exporting ‘a’ (313.25 KiB) to cluster node #1 ...
[08:28:19.045] Exporting ‘a’ (313.25 KiB) to cluster node #1 ... DONE
[08:28:19.045] Exporting 1 global objects (313.46 KiB) to cluster node #1 ... DONE
[08:28:19.045] MultisessionFuture started
[08:28:19.046] - Launch lazy future ... done
[08:28:19.046] run() for ‘MultisessionFuture’ ... done
[08:28:19.046] result() for ClusterFuture ...
[08:28:19.046] receiveMessageFromWorker() for ClusterFuture ...
[08:28:19.046] - Validating connection of MultisessionFuture
[08:28:19.087] - received message: FutureResult
[08:28:19.087] - Received FutureResult
[08:28:19.088] - Erased future from FutureRegistry
[08:28:19.088] result() for ClusterFuture ...
[08:28:19.088] - result already collected: FutureResult
[08:28:19.088] result() for ClusterFuture ... done
[08:28:19.088] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:19.088] result() for ClusterFuture ... done
[08:28:19.088] result() for ClusterFuture ...
[08:28:19.088] - result already collected: FutureResult
[08:28:19.088] result() for ClusterFuture ... done
value(b) = 2
[08:28:19.089] result() for ClusterFuture ...
[08:28:19.089] - result already collected: FutureResult
[08:28:19.089] result() for ClusterFuture ... done
[08:28:19.089] result() for ClusterFuture ...
[08:28:19.089] - result already collected: FutureResult
[08:28:19.089] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:19.089] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:19.089] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:19.090] 
[08:28:19.090] Searching for globals ... DONE
[08:28:19.090] - globals: [0] <none>
[08:28:19.090] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:19.091] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:19.091] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:19.091] - globals found: [3] ‘+’, ‘value’, ‘a’
[08:28:19.092] Searching for globals ... DONE
[08:28:19.092] Resolving globals: TRUE
[08:28:19.092] Resolving any globals that are futures ...
[08:28:19.092] - globals: [3] ‘+’, ‘value’, ‘a’
[08:28:19.092] Resolving any globals that are futures ... DONE
[08:28:19.092] Resolving futures part of globals (recursively) ...
[08:28:19.093] resolve() on list ...
[08:28:19.093]  recursive: 99
[08:28:19.093]  length: 1
[08:28:19.093]  elements: ‘a’
[08:28:19.093] run() for ‘Future’ ...
[08:28:19.093] - state: ‘created’
[08:28:19.093] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:19.108] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:19.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:19.108]   - Field: ‘node’
[08:28:19.108]   - Field: ‘label’
[08:28:19.108]   - Field: ‘local’
[08:28:19.108]   - Field: ‘owner’
[08:28:19.108]   - Field: ‘envir’
[08:28:19.108]   - Field: ‘workers’
[08:28:19.108]   - Field: ‘packages’
[08:28:19.109]   - Field: ‘gc’
[08:28:19.109]   - Field: ‘conditions’
[08:28:19.109]   - Field: ‘persistent’
[08:28:19.109]   - Field: ‘expr’
[08:28:19.109]   - Field: ‘uuid’
[08:28:19.109]   - Field: ‘seed’
[08:28:19.109]   - Field: ‘version’
[08:28:19.109]   - Field: ‘result’
[08:28:19.109]   - Field: ‘asynchronous’
[08:28:19.109]   - Field: ‘calls’
[08:28:19.109]   - Field: ‘globals’
[08:28:19.109]   - Field: ‘stdout’
[08:28:19.110]   - Field: ‘earlySignal’
[08:28:19.110]   - Field: ‘lazy’
[08:28:19.110]   - Field: ‘state’
[08:28:19.110] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:19.110] - Launch lazy future ...
[08:28:19.110] Packages needed by the future expression (n = 0): <none>
[08:28:19.110] Packages needed by future strategies (n = 0): <none>
[08:28:19.111] {
[08:28:19.111]     {
[08:28:19.111]         {
[08:28:19.111]             ...future.startTime <- base::Sys.time()
[08:28:19.111]             {
[08:28:19.111]                 {
[08:28:19.111]                   {
[08:28:19.111]                     {
[08:28:19.111]                       base::local({
[08:28:19.111]                         has_future <- base::requireNamespace("future", 
[08:28:19.111]                           quietly = TRUE)
[08:28:19.111]                         if (has_future) {
[08:28:19.111]                           ns <- base::getNamespace("future")
[08:28:19.111]                           version <- ns[[".package"]][["version"]]
[08:28:19.111]                           if (is.null(version)) 
[08:28:19.111]                             version <- utils::packageVersion("future")
[08:28:19.111]                         }
[08:28:19.111]                         else {
[08:28:19.111]                           version <- NULL
[08:28:19.111]                         }
[08:28:19.111]                         if (!has_future || version < "1.8.0") {
[08:28:19.111]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:19.111]                             "", base::R.version$version.string), 
[08:28:19.111]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:19.111]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:19.111]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:19.111]                               "release", "version")], collapse = " "), 
[08:28:19.111]                             hostname = base::Sys.info()[["nodename"]])
[08:28:19.111]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:19.111]                             info)
[08:28:19.111]                           info <- base::paste(info, collapse = "; ")
[08:28:19.111]                           if (!has_future) {
[08:28:19.111]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:19.111]                               info)
[08:28:19.111]                           }
[08:28:19.111]                           else {
[08:28:19.111]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:19.111]                               info, version)
[08:28:19.111]                           }
[08:28:19.111]                           base::stop(msg)
[08:28:19.111]                         }
[08:28:19.111]                       })
[08:28:19.111]                     }
[08:28:19.111]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:19.111]                     base::options(mc.cores = 1L)
[08:28:19.111]                   }
[08:28:19.111]                   ...future.strategy.old <- future::plan("list")
[08:28:19.111]                   options(future.plan = NULL)
[08:28:19.111]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.111]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:19.111]                 }
[08:28:19.111]                 ...future.workdir <- getwd()
[08:28:19.111]             }
[08:28:19.111]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:19.111]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:19.111]         }
[08:28:19.111]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:19.111]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:19.111]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:19.111]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:19.111]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:19.111]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:19.111]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:19.111]             base::names(...future.oldOptions))
[08:28:19.111]     }
[08:28:19.111]     if (FALSE) {
[08:28:19.111]     }
[08:28:19.111]     else {
[08:28:19.111]         if (TRUE) {
[08:28:19.111]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:19.111]                 open = "w")
[08:28:19.111]         }
[08:28:19.111]         else {
[08:28:19.111]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:19.111]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:19.111]         }
[08:28:19.111]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:19.111]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:19.111]             base::sink(type = "output", split = FALSE)
[08:28:19.111]             base::close(...future.stdout)
[08:28:19.111]         }, add = TRUE)
[08:28:19.111]     }
[08:28:19.111]     ...future.frame <- base::sys.nframe()
[08:28:19.111]     ...future.conditions <- base::list()
[08:28:19.111]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:19.111]     if (FALSE) {
[08:28:19.111]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:19.111]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:19.111]     }
[08:28:19.111]     ...future.result <- base::tryCatch({
[08:28:19.111]         base::withCallingHandlers({
[08:28:19.111]             ...future.value <- base::withVisible(base::local({
[08:28:19.111]                 ...future.makeSendCondition <- base::local({
[08:28:19.111]                   sendCondition <- NULL
[08:28:19.111]                   function(frame = 1L) {
[08:28:19.111]                     if (is.function(sendCondition)) 
[08:28:19.111]                       return(sendCondition)
[08:28:19.111]                     ns <- getNamespace("parallel")
[08:28:19.111]                     if (exists("sendData", mode = "function", 
[08:28:19.111]                       envir = ns)) {
[08:28:19.111]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:19.111]                         envir = ns)
[08:28:19.111]                       envir <- sys.frame(frame)
[08:28:19.111]                       master <- NULL
[08:28:19.111]                       while (!identical(envir, .GlobalEnv) && 
[08:28:19.111]                         !identical(envir, emptyenv())) {
[08:28:19.111]                         if (exists("master", mode = "list", envir = envir, 
[08:28:19.111]                           inherits = FALSE)) {
[08:28:19.111]                           master <- get("master", mode = "list", 
[08:28:19.111]                             envir = envir, inherits = FALSE)
[08:28:19.111]                           if (inherits(master, c("SOCKnode", 
[08:28:19.111]                             "SOCK0node"))) {
[08:28:19.111]                             sendCondition <<- function(cond) {
[08:28:19.111]                               data <- list(type = "VALUE", value = cond, 
[08:28:19.111]                                 success = TRUE)
[08:28:19.111]                               parallel_sendData(master, data)
[08:28:19.111]                             }
[08:28:19.111]                             return(sendCondition)
[08:28:19.111]                           }
[08:28:19.111]                         }
[08:28:19.111]                         frame <- frame + 1L
[08:28:19.111]                         envir <- sys.frame(frame)
[08:28:19.111]                       }
[08:28:19.111]                     }
[08:28:19.111]                     sendCondition <<- function(cond) NULL
[08:28:19.111]                   }
[08:28:19.111]                 })
[08:28:19.111]                 withCallingHandlers({
[08:28:19.111]                   1
[08:28:19.111]                 }, immediateCondition = function(cond) {
[08:28:19.111]                   sendCondition <- ...future.makeSendCondition()
[08:28:19.111]                   sendCondition(cond)
[08:28:19.111]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.111]                   {
[08:28:19.111]                     inherits <- base::inherits
[08:28:19.111]                     invokeRestart <- base::invokeRestart
[08:28:19.111]                     is.null <- base::is.null
[08:28:19.111]                     muffled <- FALSE
[08:28:19.111]                     if (inherits(cond, "message")) {
[08:28:19.111]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:19.111]                       if (muffled) 
[08:28:19.111]                         invokeRestart("muffleMessage")
[08:28:19.111]                     }
[08:28:19.111]                     else if (inherits(cond, "warning")) {
[08:28:19.111]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:19.111]                       if (muffled) 
[08:28:19.111]                         invokeRestart("muffleWarning")
[08:28:19.111]                     }
[08:28:19.111]                     else if (inherits(cond, "condition")) {
[08:28:19.111]                       if (!is.null(pattern)) {
[08:28:19.111]                         computeRestarts <- base::computeRestarts
[08:28:19.111]                         grepl <- base::grepl
[08:28:19.111]                         restarts <- computeRestarts(cond)
[08:28:19.111]                         for (restart in restarts) {
[08:28:19.111]                           name <- restart$name
[08:28:19.111]                           if (is.null(name)) 
[08:28:19.111]                             next
[08:28:19.111]                           if (!grepl(pattern, name)) 
[08:28:19.111]                             next
[08:28:19.111]                           invokeRestart(restart)
[08:28:19.111]                           muffled <- TRUE
[08:28:19.111]                           break
[08:28:19.111]                         }
[08:28:19.111]                       }
[08:28:19.111]                     }
[08:28:19.111]                     invisible(muffled)
[08:28:19.111]                   }
[08:28:19.111]                   muffleCondition(cond)
[08:28:19.111]                 })
[08:28:19.111]             }))
[08:28:19.111]             future::FutureResult(value = ...future.value$value, 
[08:28:19.111]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.111]                   ...future.rng), globalenv = if (FALSE) 
[08:28:19.111]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:19.111]                     ...future.globalenv.names))
[08:28:19.111]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:19.111]         }, condition = base::local({
[08:28:19.111]             c <- base::c
[08:28:19.111]             inherits <- base::inherits
[08:28:19.111]             invokeRestart <- base::invokeRestart
[08:28:19.111]             length <- base::length
[08:28:19.111]             list <- base::list
[08:28:19.111]             seq.int <- base::seq.int
[08:28:19.111]             signalCondition <- base::signalCondition
[08:28:19.111]             sys.calls <- base::sys.calls
[08:28:19.111]             `[[` <- base::`[[`
[08:28:19.111]             `+` <- base::`+`
[08:28:19.111]             `<<-` <- base::`<<-`
[08:28:19.111]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:19.111]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:19.111]                   3L)]
[08:28:19.111]             }
[08:28:19.111]             function(cond) {
[08:28:19.111]                 is_error <- inherits(cond, "error")
[08:28:19.111]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:19.111]                   NULL)
[08:28:19.111]                 if (is_error) {
[08:28:19.111]                   sessionInformation <- function() {
[08:28:19.111]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:19.111]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:19.111]                       search = base::search(), system = base::Sys.info())
[08:28:19.111]                   }
[08:28:19.111]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.111]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:19.111]                     cond$call), session = sessionInformation(), 
[08:28:19.111]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:19.111]                   signalCondition(cond)
[08:28:19.111]                 }
[08:28:19.111]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:19.111]                 "immediateCondition"))) {
[08:28:19.111]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:19.111]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.111]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:19.111]                   if (TRUE && !signal) {
[08:28:19.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.111]                     {
[08:28:19.111]                       inherits <- base::inherits
[08:28:19.111]                       invokeRestart <- base::invokeRestart
[08:28:19.111]                       is.null <- base::is.null
[08:28:19.111]                       muffled <- FALSE
[08:28:19.111]                       if (inherits(cond, "message")) {
[08:28:19.111]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.111]                         if (muffled) 
[08:28:19.111]                           invokeRestart("muffleMessage")
[08:28:19.111]                       }
[08:28:19.111]                       else if (inherits(cond, "warning")) {
[08:28:19.111]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.111]                         if (muffled) 
[08:28:19.111]                           invokeRestart("muffleWarning")
[08:28:19.111]                       }
[08:28:19.111]                       else if (inherits(cond, "condition")) {
[08:28:19.111]                         if (!is.null(pattern)) {
[08:28:19.111]                           computeRestarts <- base::computeRestarts
[08:28:19.111]                           grepl <- base::grepl
[08:28:19.111]                           restarts <- computeRestarts(cond)
[08:28:19.111]                           for (restart in restarts) {
[08:28:19.111]                             name <- restart$name
[08:28:19.111]                             if (is.null(name)) 
[08:28:19.111]                               next
[08:28:19.111]                             if (!grepl(pattern, name)) 
[08:28:19.111]                               next
[08:28:19.111]                             invokeRestart(restart)
[08:28:19.111]                             muffled <- TRUE
[08:28:19.111]                             break
[08:28:19.111]                           }
[08:28:19.111]                         }
[08:28:19.111]                       }
[08:28:19.111]                       invisible(muffled)
[08:28:19.111]                     }
[08:28:19.111]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.111]                   }
[08:28:19.111]                 }
[08:28:19.111]                 else {
[08:28:19.111]                   if (TRUE) {
[08:28:19.111]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.111]                     {
[08:28:19.111]                       inherits <- base::inherits
[08:28:19.111]                       invokeRestart <- base::invokeRestart
[08:28:19.111]                       is.null <- base::is.null
[08:28:19.111]                       muffled <- FALSE
[08:28:19.111]                       if (inherits(cond, "message")) {
[08:28:19.111]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.111]                         if (muffled) 
[08:28:19.111]                           invokeRestart("muffleMessage")
[08:28:19.111]                       }
[08:28:19.111]                       else if (inherits(cond, "warning")) {
[08:28:19.111]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.111]                         if (muffled) 
[08:28:19.111]                           invokeRestart("muffleWarning")
[08:28:19.111]                       }
[08:28:19.111]                       else if (inherits(cond, "condition")) {
[08:28:19.111]                         if (!is.null(pattern)) {
[08:28:19.111]                           computeRestarts <- base::computeRestarts
[08:28:19.111]                           grepl <- base::grepl
[08:28:19.111]                           restarts <- computeRestarts(cond)
[08:28:19.111]                           for (restart in restarts) {
[08:28:19.111]                             name <- restart$name
[08:28:19.111]                             if (is.null(name)) 
[08:28:19.111]                               next
[08:28:19.111]                             if (!grepl(pattern, name)) 
[08:28:19.111]                               next
[08:28:19.111]                             invokeRestart(restart)
[08:28:19.111]                             muffled <- TRUE
[08:28:19.111]                             break
[08:28:19.111]                           }
[08:28:19.111]                         }
[08:28:19.111]                       }
[08:28:19.111]                       invisible(muffled)
[08:28:19.111]                     }
[08:28:19.111]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.111]                   }
[08:28:19.111]                 }
[08:28:19.111]             }
[08:28:19.111]         }))
[08:28:19.111]     }, error = function(ex) {
[08:28:19.111]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:19.111]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.111]                 ...future.rng), started = ...future.startTime, 
[08:28:19.111]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:19.111]             version = "1.8"), class = "FutureResult")
[08:28:19.111]     }, finally = {
[08:28:19.111]         if (!identical(...future.workdir, getwd())) 
[08:28:19.111]             setwd(...future.workdir)
[08:28:19.111]         {
[08:28:19.111]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:19.111]                 ...future.oldOptions$nwarnings <- NULL
[08:28:19.111]             }
[08:28:19.111]             base::options(...future.oldOptions)
[08:28:19.111]             if (.Platform$OS.type == "windows") {
[08:28:19.111]                 old_names <- names(...future.oldEnvVars)
[08:28:19.111]                 envs <- base::Sys.getenv()
[08:28:19.111]                 names <- names(envs)
[08:28:19.111]                 common <- intersect(names, old_names)
[08:28:19.111]                 added <- setdiff(names, old_names)
[08:28:19.111]                 removed <- setdiff(old_names, names)
[08:28:19.111]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:19.111]                   envs[common]]
[08:28:19.111]                 NAMES <- toupper(changed)
[08:28:19.111]                 args <- list()
[08:28:19.111]                 for (kk in seq_along(NAMES)) {
[08:28:19.111]                   name <- changed[[kk]]
[08:28:19.111]                   NAME <- NAMES[[kk]]
[08:28:19.111]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.111]                     next
[08:28:19.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.111]                 }
[08:28:19.111]                 NAMES <- toupper(added)
[08:28:19.111]                 for (kk in seq_along(NAMES)) {
[08:28:19.111]                   name <- added[[kk]]
[08:28:19.111]                   NAME <- NAMES[[kk]]
[08:28:19.111]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.111]                     next
[08:28:19.111]                   args[[name]] <- ""
[08:28:19.111]                 }
[08:28:19.111]                 NAMES <- toupper(removed)
[08:28:19.111]                 for (kk in seq_along(NAMES)) {
[08:28:19.111]                   name <- removed[[kk]]
[08:28:19.111]                   NAME <- NAMES[[kk]]
[08:28:19.111]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.111]                     next
[08:28:19.111]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.111]                 }
[08:28:19.111]                 if (length(args) > 0) 
[08:28:19.111]                   base::do.call(base::Sys.setenv, args = args)
[08:28:19.111]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:19.111]             }
[08:28:19.111]             else {
[08:28:19.111]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:19.111]             }
[08:28:19.111]             {
[08:28:19.111]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:19.111]                   0L) {
[08:28:19.111]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:19.111]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:19.111]                   base::options(opts)
[08:28:19.111]                 }
[08:28:19.111]                 {
[08:28:19.111]                   {
[08:28:19.111]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:19.111]                     NULL
[08:28:19.111]                   }
[08:28:19.111]                   options(future.plan = NULL)
[08:28:19.111]                   if (is.na(NA_character_)) 
[08:28:19.111]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.111]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:19.111]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:19.111]                     .init = FALSE)
[08:28:19.111]                 }
[08:28:19.111]             }
[08:28:19.111]         }
[08:28:19.111]     })
[08:28:19.111]     if (TRUE) {
[08:28:19.111]         base::sink(type = "output", split = FALSE)
[08:28:19.111]         if (TRUE) {
[08:28:19.111]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:19.111]         }
[08:28:19.111]         else {
[08:28:19.111]             ...future.result["stdout"] <- base::list(NULL)
[08:28:19.111]         }
[08:28:19.111]         base::close(...future.stdout)
[08:28:19.111]         ...future.stdout <- NULL
[08:28:19.111]     }
[08:28:19.111]     ...future.result$conditions <- ...future.conditions
[08:28:19.111]     ...future.result$finished <- base::Sys.time()
[08:28:19.111]     ...future.result
[08:28:19.111] }
[08:28:19.114] MultisessionFuture started
[08:28:19.114] - Launch lazy future ... done
[08:28:19.114] run() for ‘MultisessionFuture’ ... done
[08:28:19.156] receiveMessageFromWorker() for ClusterFuture ...
[08:28:19.156] - Validating connection of MultisessionFuture
[08:28:19.156] - received message: FutureResult
[08:28:19.156] - Received FutureResult
[08:28:19.156] - Erased future from FutureRegistry
[08:28:19.157] result() for ClusterFuture ...
[08:28:19.157] - result already collected: FutureResult
[08:28:19.157] result() for ClusterFuture ... done
[08:28:19.157] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:19.157] Future #1
[08:28:19.157] result() for ClusterFuture ...
[08:28:19.157] - result already collected: FutureResult
[08:28:19.157] result() for ClusterFuture ... done
[08:28:19.157] result() for ClusterFuture ...
[08:28:19.157] - result already collected: FutureResult
[08:28:19.157] result() for ClusterFuture ... done
[08:28:19.158] A MultisessionFuture was resolved
[08:28:19.158]  length: 0 (resolved future 1)
[08:28:19.158] resolve() on list ... DONE
[08:28:19.158] - globals: [1] ‘a’
[08:28:19.158] Resolving futures part of globals (recursively) ... DONE
[08:28:19.170] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[08:28:19.171] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[08:28:19.171] - globals: [1] ‘a’
[08:28:19.171] - packages: [1] ‘future’
[08:28:19.171] getGlobalsAndPackages() ... DONE
[08:28:19.171] run() for ‘Future’ ...
[08:28:19.171] - state: ‘created’
[08:28:19.171] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:19.185] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:19.186] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:19.186]   - Field: ‘node’
[08:28:19.186]   - Field: ‘label’
[08:28:19.186]   - Field: ‘local’
[08:28:19.186]   - Field: ‘owner’
[08:28:19.186]   - Field: ‘envir’
[08:28:19.186]   - Field: ‘workers’
[08:28:19.186]   - Field: ‘packages’
[08:28:19.186]   - Field: ‘gc’
[08:28:19.186]   - Field: ‘conditions’
[08:28:19.186]   - Field: ‘persistent’
[08:28:19.187]   - Field: ‘expr’
[08:28:19.187]   - Field: ‘uuid’
[08:28:19.187]   - Field: ‘seed’
[08:28:19.187]   - Field: ‘version’
[08:28:19.187]   - Field: ‘result’
[08:28:19.187]   - Field: ‘asynchronous’
[08:28:19.187]   - Field: ‘calls’
[08:28:19.187]   - Field: ‘globals’
[08:28:19.187]   - Field: ‘stdout’
[08:28:19.187]   - Field: ‘earlySignal’
[08:28:19.187]   - Field: ‘lazy’
[08:28:19.187]   - Field: ‘state’
[08:28:19.188] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:19.188] - Launch lazy future ...
[08:28:19.188] Packages needed by the future expression (n = 1): ‘future’
[08:28:19.188] Packages needed by future strategies (n = 0): <none>
[08:28:19.189] {
[08:28:19.189]     {
[08:28:19.189]         {
[08:28:19.189]             ...future.startTime <- base::Sys.time()
[08:28:19.189]             {
[08:28:19.189]                 {
[08:28:19.189]                   {
[08:28:19.189]                     {
[08:28:19.189]                       {
[08:28:19.189]                         base::local({
[08:28:19.189]                           has_future <- base::requireNamespace("future", 
[08:28:19.189]                             quietly = TRUE)
[08:28:19.189]                           if (has_future) {
[08:28:19.189]                             ns <- base::getNamespace("future")
[08:28:19.189]                             version <- ns[[".package"]][["version"]]
[08:28:19.189]                             if (is.null(version)) 
[08:28:19.189]                               version <- utils::packageVersion("future")
[08:28:19.189]                           }
[08:28:19.189]                           else {
[08:28:19.189]                             version <- NULL
[08:28:19.189]                           }
[08:28:19.189]                           if (!has_future || version < "1.8.0") {
[08:28:19.189]                             info <- base::c(r_version = base::gsub("R version ", 
[08:28:19.189]                               "", base::R.version$version.string), 
[08:28:19.189]                               platform = base::sprintf("%s (%s-bit)", 
[08:28:19.189]                                 base::R.version$platform, 8 * 
[08:28:19.189]                                   base::.Machine$sizeof.pointer), 
[08:28:19.189]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:19.189]                                 "release", "version")], collapse = " "), 
[08:28:19.189]                               hostname = base::Sys.info()[["nodename"]])
[08:28:19.189]                             info <- base::sprintf("%s: %s", base::names(info), 
[08:28:19.189]                               info)
[08:28:19.189]                             info <- base::paste(info, collapse = "; ")
[08:28:19.189]                             if (!has_future) {
[08:28:19.189]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:19.189]                                 info)
[08:28:19.189]                             }
[08:28:19.189]                             else {
[08:28:19.189]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:19.189]                                 info, version)
[08:28:19.189]                             }
[08:28:19.189]                             base::stop(msg)
[08:28:19.189]                           }
[08:28:19.189]                         })
[08:28:19.189]                       }
[08:28:19.189]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:19.189]                       base::options(mc.cores = 1L)
[08:28:19.189]                     }
[08:28:19.189]                     base::local({
[08:28:19.189]                       for (pkg in "future") {
[08:28:19.189]                         base::loadNamespace(pkg)
[08:28:19.189]                         base::library(pkg, character.only = TRUE)
[08:28:19.189]                       }
[08:28:19.189]                     })
[08:28:19.189]                   }
[08:28:19.189]                   ...future.strategy.old <- future::plan("list")
[08:28:19.189]                   options(future.plan = NULL)
[08:28:19.189]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.189]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:19.189]                 }
[08:28:19.189]                 ...future.workdir <- getwd()
[08:28:19.189]             }
[08:28:19.189]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:19.189]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:19.189]         }
[08:28:19.189]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:19.189]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:19.189]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:19.189]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:19.189]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:19.189]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:19.189]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:19.189]             base::names(...future.oldOptions))
[08:28:19.189]     }
[08:28:19.189]     if (FALSE) {
[08:28:19.189]     }
[08:28:19.189]     else {
[08:28:19.189]         if (TRUE) {
[08:28:19.189]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:19.189]                 open = "w")
[08:28:19.189]         }
[08:28:19.189]         else {
[08:28:19.189]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:19.189]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:19.189]         }
[08:28:19.189]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:19.189]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:19.189]             base::sink(type = "output", split = FALSE)
[08:28:19.189]             base::close(...future.stdout)
[08:28:19.189]         }, add = TRUE)
[08:28:19.189]     }
[08:28:19.189]     ...future.frame <- base::sys.nframe()
[08:28:19.189]     ...future.conditions <- base::list()
[08:28:19.189]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:19.189]     if (FALSE) {
[08:28:19.189]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:19.189]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:19.189]     }
[08:28:19.189]     ...future.result <- base::tryCatch({
[08:28:19.189]         base::withCallingHandlers({
[08:28:19.189]             ...future.value <- base::withVisible(base::local({
[08:28:19.189]                 ...future.makeSendCondition <- base::local({
[08:28:19.189]                   sendCondition <- NULL
[08:28:19.189]                   function(frame = 1L) {
[08:28:19.189]                     if (is.function(sendCondition)) 
[08:28:19.189]                       return(sendCondition)
[08:28:19.189]                     ns <- getNamespace("parallel")
[08:28:19.189]                     if (exists("sendData", mode = "function", 
[08:28:19.189]                       envir = ns)) {
[08:28:19.189]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:19.189]                         envir = ns)
[08:28:19.189]                       envir <- sys.frame(frame)
[08:28:19.189]                       master <- NULL
[08:28:19.189]                       while (!identical(envir, .GlobalEnv) && 
[08:28:19.189]                         !identical(envir, emptyenv())) {
[08:28:19.189]                         if (exists("master", mode = "list", envir = envir, 
[08:28:19.189]                           inherits = FALSE)) {
[08:28:19.189]                           master <- get("master", mode = "list", 
[08:28:19.189]                             envir = envir, inherits = FALSE)
[08:28:19.189]                           if (inherits(master, c("SOCKnode", 
[08:28:19.189]                             "SOCK0node"))) {
[08:28:19.189]                             sendCondition <<- function(cond) {
[08:28:19.189]                               data <- list(type = "VALUE", value = cond, 
[08:28:19.189]                                 success = TRUE)
[08:28:19.189]                               parallel_sendData(master, data)
[08:28:19.189]                             }
[08:28:19.189]                             return(sendCondition)
[08:28:19.189]                           }
[08:28:19.189]                         }
[08:28:19.189]                         frame <- frame + 1L
[08:28:19.189]                         envir <- sys.frame(frame)
[08:28:19.189]                       }
[08:28:19.189]                     }
[08:28:19.189]                     sendCondition <<- function(cond) NULL
[08:28:19.189]                   }
[08:28:19.189]                 })
[08:28:19.189]                 withCallingHandlers({
[08:28:19.189]                   value(a) + 1
[08:28:19.189]                 }, immediateCondition = function(cond) {
[08:28:19.189]                   sendCondition <- ...future.makeSendCondition()
[08:28:19.189]                   sendCondition(cond)
[08:28:19.189]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.189]                   {
[08:28:19.189]                     inherits <- base::inherits
[08:28:19.189]                     invokeRestart <- base::invokeRestart
[08:28:19.189]                     is.null <- base::is.null
[08:28:19.189]                     muffled <- FALSE
[08:28:19.189]                     if (inherits(cond, "message")) {
[08:28:19.189]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:19.189]                       if (muffled) 
[08:28:19.189]                         invokeRestart("muffleMessage")
[08:28:19.189]                     }
[08:28:19.189]                     else if (inherits(cond, "warning")) {
[08:28:19.189]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:19.189]                       if (muffled) 
[08:28:19.189]                         invokeRestart("muffleWarning")
[08:28:19.189]                     }
[08:28:19.189]                     else if (inherits(cond, "condition")) {
[08:28:19.189]                       if (!is.null(pattern)) {
[08:28:19.189]                         computeRestarts <- base::computeRestarts
[08:28:19.189]                         grepl <- base::grepl
[08:28:19.189]                         restarts <- computeRestarts(cond)
[08:28:19.189]                         for (restart in restarts) {
[08:28:19.189]                           name <- restart$name
[08:28:19.189]                           if (is.null(name)) 
[08:28:19.189]                             next
[08:28:19.189]                           if (!grepl(pattern, name)) 
[08:28:19.189]                             next
[08:28:19.189]                           invokeRestart(restart)
[08:28:19.189]                           muffled <- TRUE
[08:28:19.189]                           break
[08:28:19.189]                         }
[08:28:19.189]                       }
[08:28:19.189]                     }
[08:28:19.189]                     invisible(muffled)
[08:28:19.189]                   }
[08:28:19.189]                   muffleCondition(cond)
[08:28:19.189]                 })
[08:28:19.189]             }))
[08:28:19.189]             future::FutureResult(value = ...future.value$value, 
[08:28:19.189]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.189]                   ...future.rng), globalenv = if (FALSE) 
[08:28:19.189]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:19.189]                     ...future.globalenv.names))
[08:28:19.189]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:19.189]         }, condition = base::local({
[08:28:19.189]             c <- base::c
[08:28:19.189]             inherits <- base::inherits
[08:28:19.189]             invokeRestart <- base::invokeRestart
[08:28:19.189]             length <- base::length
[08:28:19.189]             list <- base::list
[08:28:19.189]             seq.int <- base::seq.int
[08:28:19.189]             signalCondition <- base::signalCondition
[08:28:19.189]             sys.calls <- base::sys.calls
[08:28:19.189]             `[[` <- base::`[[`
[08:28:19.189]             `+` <- base::`+`
[08:28:19.189]             `<<-` <- base::`<<-`
[08:28:19.189]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:19.189]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:19.189]                   3L)]
[08:28:19.189]             }
[08:28:19.189]             function(cond) {
[08:28:19.189]                 is_error <- inherits(cond, "error")
[08:28:19.189]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:19.189]                   NULL)
[08:28:19.189]                 if (is_error) {
[08:28:19.189]                   sessionInformation <- function() {
[08:28:19.189]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:19.189]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:19.189]                       search = base::search(), system = base::Sys.info())
[08:28:19.189]                   }
[08:28:19.189]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.189]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:19.189]                     cond$call), session = sessionInformation(), 
[08:28:19.189]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:19.189]                   signalCondition(cond)
[08:28:19.189]                 }
[08:28:19.189]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:19.189]                 "immediateCondition"))) {
[08:28:19.189]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:19.189]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.189]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:19.189]                   if (TRUE && !signal) {
[08:28:19.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.189]                     {
[08:28:19.189]                       inherits <- base::inherits
[08:28:19.189]                       invokeRestart <- base::invokeRestart
[08:28:19.189]                       is.null <- base::is.null
[08:28:19.189]                       muffled <- FALSE
[08:28:19.189]                       if (inherits(cond, "message")) {
[08:28:19.189]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.189]                         if (muffled) 
[08:28:19.189]                           invokeRestart("muffleMessage")
[08:28:19.189]                       }
[08:28:19.189]                       else if (inherits(cond, "warning")) {
[08:28:19.189]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.189]                         if (muffled) 
[08:28:19.189]                           invokeRestart("muffleWarning")
[08:28:19.189]                       }
[08:28:19.189]                       else if (inherits(cond, "condition")) {
[08:28:19.189]                         if (!is.null(pattern)) {
[08:28:19.189]                           computeRestarts <- base::computeRestarts
[08:28:19.189]                           grepl <- base::grepl
[08:28:19.189]                           restarts <- computeRestarts(cond)
[08:28:19.189]                           for (restart in restarts) {
[08:28:19.189]                             name <- restart$name
[08:28:19.189]                             if (is.null(name)) 
[08:28:19.189]                               next
[08:28:19.189]                             if (!grepl(pattern, name)) 
[08:28:19.189]                               next
[08:28:19.189]                             invokeRestart(restart)
[08:28:19.189]                             muffled <- TRUE
[08:28:19.189]                             break
[08:28:19.189]                           }
[08:28:19.189]                         }
[08:28:19.189]                       }
[08:28:19.189]                       invisible(muffled)
[08:28:19.189]                     }
[08:28:19.189]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.189]                   }
[08:28:19.189]                 }
[08:28:19.189]                 else {
[08:28:19.189]                   if (TRUE) {
[08:28:19.189]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.189]                     {
[08:28:19.189]                       inherits <- base::inherits
[08:28:19.189]                       invokeRestart <- base::invokeRestart
[08:28:19.189]                       is.null <- base::is.null
[08:28:19.189]                       muffled <- FALSE
[08:28:19.189]                       if (inherits(cond, "message")) {
[08:28:19.189]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.189]                         if (muffled) 
[08:28:19.189]                           invokeRestart("muffleMessage")
[08:28:19.189]                       }
[08:28:19.189]                       else if (inherits(cond, "warning")) {
[08:28:19.189]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.189]                         if (muffled) 
[08:28:19.189]                           invokeRestart("muffleWarning")
[08:28:19.189]                       }
[08:28:19.189]                       else if (inherits(cond, "condition")) {
[08:28:19.189]                         if (!is.null(pattern)) {
[08:28:19.189]                           computeRestarts <- base::computeRestarts
[08:28:19.189]                           grepl <- base::grepl
[08:28:19.189]                           restarts <- computeRestarts(cond)
[08:28:19.189]                           for (restart in restarts) {
[08:28:19.189]                             name <- restart$name
[08:28:19.189]                             if (is.null(name)) 
[08:28:19.189]                               next
[08:28:19.189]                             if (!grepl(pattern, name)) 
[08:28:19.189]                               next
[08:28:19.189]                             invokeRestart(restart)
[08:28:19.189]                             muffled <- TRUE
[08:28:19.189]                             break
[08:28:19.189]                           }
[08:28:19.189]                         }
[08:28:19.189]                       }
[08:28:19.189]                       invisible(muffled)
[08:28:19.189]                     }
[08:28:19.189]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.189]                   }
[08:28:19.189]                 }
[08:28:19.189]             }
[08:28:19.189]         }))
[08:28:19.189]     }, error = function(ex) {
[08:28:19.189]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:19.189]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.189]                 ...future.rng), started = ...future.startTime, 
[08:28:19.189]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:19.189]             version = "1.8"), class = "FutureResult")
[08:28:19.189]     }, finally = {
[08:28:19.189]         if (!identical(...future.workdir, getwd())) 
[08:28:19.189]             setwd(...future.workdir)
[08:28:19.189]         {
[08:28:19.189]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:19.189]                 ...future.oldOptions$nwarnings <- NULL
[08:28:19.189]             }
[08:28:19.189]             base::options(...future.oldOptions)
[08:28:19.189]             if (.Platform$OS.type == "windows") {
[08:28:19.189]                 old_names <- names(...future.oldEnvVars)
[08:28:19.189]                 envs <- base::Sys.getenv()
[08:28:19.189]                 names <- names(envs)
[08:28:19.189]                 common <- intersect(names, old_names)
[08:28:19.189]                 added <- setdiff(names, old_names)
[08:28:19.189]                 removed <- setdiff(old_names, names)
[08:28:19.189]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:19.189]                   envs[common]]
[08:28:19.189]                 NAMES <- toupper(changed)
[08:28:19.189]                 args <- list()
[08:28:19.189]                 for (kk in seq_along(NAMES)) {
[08:28:19.189]                   name <- changed[[kk]]
[08:28:19.189]                   NAME <- NAMES[[kk]]
[08:28:19.189]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.189]                     next
[08:28:19.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.189]                 }
[08:28:19.189]                 NAMES <- toupper(added)
[08:28:19.189]                 for (kk in seq_along(NAMES)) {
[08:28:19.189]                   name <- added[[kk]]
[08:28:19.189]                   NAME <- NAMES[[kk]]
[08:28:19.189]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.189]                     next
[08:28:19.189]                   args[[name]] <- ""
[08:28:19.189]                 }
[08:28:19.189]                 NAMES <- toupper(removed)
[08:28:19.189]                 for (kk in seq_along(NAMES)) {
[08:28:19.189]                   name <- removed[[kk]]
[08:28:19.189]                   NAME <- NAMES[[kk]]
[08:28:19.189]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.189]                     next
[08:28:19.189]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.189]                 }
[08:28:19.189]                 if (length(args) > 0) 
[08:28:19.189]                   base::do.call(base::Sys.setenv, args = args)
[08:28:19.189]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:19.189]             }
[08:28:19.189]             else {
[08:28:19.189]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:19.189]             }
[08:28:19.189]             {
[08:28:19.189]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:19.189]                   0L) {
[08:28:19.189]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:19.189]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:19.189]                   base::options(opts)
[08:28:19.189]                 }
[08:28:19.189]                 {
[08:28:19.189]                   {
[08:28:19.189]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:19.189]                     NULL
[08:28:19.189]                   }
[08:28:19.189]                   options(future.plan = NULL)
[08:28:19.189]                   if (is.na(NA_character_)) 
[08:28:19.189]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.189]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:19.189]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:19.189]                     .init = FALSE)
[08:28:19.189]                 }
[08:28:19.189]             }
[08:28:19.189]         }
[08:28:19.189]     })
[08:28:19.189]     if (TRUE) {
[08:28:19.189]         base::sink(type = "output", split = FALSE)
[08:28:19.189]         if (TRUE) {
[08:28:19.189]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:19.189]         }
[08:28:19.189]         else {
[08:28:19.189]             ...future.result["stdout"] <- base::list(NULL)
[08:28:19.189]         }
[08:28:19.189]         base::close(...future.stdout)
[08:28:19.189]         ...future.stdout <- NULL
[08:28:19.189]     }
[08:28:19.189]     ...future.result$conditions <- ...future.conditions
[08:28:19.189]     ...future.result$finished <- base::Sys.time()
[08:28:19.189]     ...future.result
[08:28:19.189] }
[08:28:19.202] Exporting 1 global objects (313.46 KiB) to cluster node #1 ...
[08:28:19.213] Exporting ‘a’ (313.25 KiB) to cluster node #1 ...
[08:28:19.265] Exporting ‘a’ (313.25 KiB) to cluster node #1 ... DONE
[08:28:19.265] Exporting 1 global objects (313.46 KiB) to cluster node #1 ... DONE
[08:28:19.266] MultisessionFuture started
[08:28:19.266] - Launch lazy future ... done
[08:28:19.266] run() for ‘MultisessionFuture’ ... done
[08:28:19.266] result() for ClusterFuture ...
[08:28:19.266] receiveMessageFromWorker() for ClusterFuture ...
[08:28:19.266] - Validating connection of MultisessionFuture
[08:28:19.308] - received message: FutureResult
[08:28:19.308] - Received FutureResult
[08:28:19.308] - Erased future from FutureRegistry
[08:28:19.309] result() for ClusterFuture ...
[08:28:19.309] - result already collected: FutureResult
[08:28:19.309] result() for ClusterFuture ... done
[08:28:19.309] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:19.309] result() for ClusterFuture ... done
[08:28:19.309] result() for ClusterFuture ...
[08:28:19.309] - result already collected: FutureResult
[08:28:19.309] result() for ClusterFuture ... done
value(b) = 2
[08:28:19.309] result() for ClusterFuture ...
[08:28:19.309] - result already collected: FutureResult
[08:28:19.310] result() for ClusterFuture ... done
[08:28:19.310] result() for ClusterFuture ...
[08:28:19.310] - result already collected: FutureResult
[08:28:19.310] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:19.310] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:19.310] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:19.311] - globals found: [2] ‘{’, ‘pkg’
[08:28:19.311] Searching for globals ... DONE
[08:28:19.311] Resolving globals: TRUE
[08:28:19.311] Resolving any globals that are futures ...
[08:28:19.312] - globals: [2] ‘{’, ‘pkg’
[08:28:19.312] Resolving any globals that are futures ... DONE
[08:28:19.312] Resolving futures part of globals (recursively) ...
[08:28:19.312] resolve() on list ...
[08:28:19.312]  recursive: 99
[08:28:19.312]  length: 1
[08:28:19.312]  elements: ‘pkg’
[08:28:19.313]  length: 0 (resolved future 1)
[08:28:19.313] resolve() on list ... DONE
[08:28:19.313] - globals: [1] ‘pkg’
[08:28:19.313] Resolving futures part of globals (recursively) ... DONE
[08:28:19.313] The total size of the 1 globals is 42 bytes (42 bytes)
[08:28:19.313] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[08:28:19.313] - globals: [1] ‘pkg’
[08:28:19.314] 
[08:28:19.314] getGlobalsAndPackages() ... DONE
[08:28:19.314] Packages needed by the future expression (n = 0): <none>
[08:28:19.314] Packages needed by future strategies (n = 0): <none>
[08:28:19.314] {
[08:28:19.314]     {
[08:28:19.314]         {
[08:28:19.314]             ...future.startTime <- base::Sys.time()
[08:28:19.314]             {
[08:28:19.314]                 {
[08:28:19.314]                   {
[08:28:19.314]                     base::local({
[08:28:19.314]                       has_future <- base::requireNamespace("future", 
[08:28:19.314]                         quietly = TRUE)
[08:28:19.314]                       if (has_future) {
[08:28:19.314]                         ns <- base::getNamespace("future")
[08:28:19.314]                         version <- ns[[".package"]][["version"]]
[08:28:19.314]                         if (is.null(version)) 
[08:28:19.314]                           version <- utils::packageVersion("future")
[08:28:19.314]                       }
[08:28:19.314]                       else {
[08:28:19.314]                         version <- NULL
[08:28:19.314]                       }
[08:28:19.314]                       if (!has_future || version < "1.8.0") {
[08:28:19.314]                         info <- base::c(r_version = base::gsub("R version ", 
[08:28:19.314]                           "", base::R.version$version.string), 
[08:28:19.314]                           platform = base::sprintf("%s (%s-bit)", 
[08:28:19.314]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:19.314]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:19.314]                             "release", "version")], collapse = " "), 
[08:28:19.314]                           hostname = base::Sys.info()[["nodename"]])
[08:28:19.314]                         info <- base::sprintf("%s: %s", base::names(info), 
[08:28:19.314]                           info)
[08:28:19.314]                         info <- base::paste(info, collapse = "; ")
[08:28:19.314]                         if (!has_future) {
[08:28:19.314]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:19.314]                             info)
[08:28:19.314]                         }
[08:28:19.314]                         else {
[08:28:19.314]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:19.314]                             info, version)
[08:28:19.314]                         }
[08:28:19.314]                         base::stop(msg)
[08:28:19.314]                       }
[08:28:19.314]                     })
[08:28:19.314]                   }
[08:28:19.314]                   ...future.strategy.old <- future::plan("list")
[08:28:19.314]                   options(future.plan = NULL)
[08:28:19.314]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.314]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:19.314]                 }
[08:28:19.314]                 ...future.workdir <- getwd()
[08:28:19.314]             }
[08:28:19.314]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:19.314]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:19.314]         }
[08:28:19.314]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:19.314]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:19.314]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:19.314]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:19.314]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:19.314]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:19.314]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:19.314]             base::names(...future.oldOptions))
[08:28:19.314]     }
[08:28:19.314]     if (FALSE) {
[08:28:19.314]     }
[08:28:19.314]     else {
[08:28:19.314]         if (TRUE) {
[08:28:19.314]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:19.314]                 open = "w")
[08:28:19.314]         }
[08:28:19.314]         else {
[08:28:19.314]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:19.314]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:19.314]         }
[08:28:19.314]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:19.314]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:19.314]             base::sink(type = "output", split = FALSE)
[08:28:19.314]             base::close(...future.stdout)
[08:28:19.314]         }, add = TRUE)
[08:28:19.314]     }
[08:28:19.314]     ...future.frame <- base::sys.nframe()
[08:28:19.314]     ...future.conditions <- base::list()
[08:28:19.314]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:19.314]     if (FALSE) {
[08:28:19.314]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:19.314]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:19.314]     }
[08:28:19.314]     ...future.result <- base::tryCatch({
[08:28:19.314]         base::withCallingHandlers({
[08:28:19.314]             ...future.value <- base::withVisible(base::local({
[08:28:19.314]                 pkg
[08:28:19.314]             }))
[08:28:19.314]             future::FutureResult(value = ...future.value$value, 
[08:28:19.314]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.314]                   ...future.rng), globalenv = if (FALSE) 
[08:28:19.314]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:19.314]                     ...future.globalenv.names))
[08:28:19.314]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:19.314]         }, condition = base::local({
[08:28:19.314]             c <- base::c
[08:28:19.314]             inherits <- base::inherits
[08:28:19.314]             invokeRestart <- base::invokeRestart
[08:28:19.314]             length <- base::length
[08:28:19.314]             list <- base::list
[08:28:19.314]             seq.int <- base::seq.int
[08:28:19.314]             signalCondition <- base::signalCondition
[08:28:19.314]             sys.calls <- base::sys.calls
[08:28:19.314]             `[[` <- base::`[[`
[08:28:19.314]             `+` <- base::`+`
[08:28:19.314]             `<<-` <- base::`<<-`
[08:28:19.314]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:19.314]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:19.314]                   3L)]
[08:28:19.314]             }
[08:28:19.314]             function(cond) {
[08:28:19.314]                 is_error <- inherits(cond, "error")
[08:28:19.314]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:19.314]                   NULL)
[08:28:19.314]                 if (is_error) {
[08:28:19.314]                   sessionInformation <- function() {
[08:28:19.314]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:19.314]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:19.314]                       search = base::search(), system = base::Sys.info())
[08:28:19.314]                   }
[08:28:19.314]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.314]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:19.314]                     cond$call), session = sessionInformation(), 
[08:28:19.314]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:19.314]                   signalCondition(cond)
[08:28:19.314]                 }
[08:28:19.314]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:19.314]                 "immediateCondition"))) {
[08:28:19.314]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:19.314]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.314]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:19.314]                   if (TRUE && !signal) {
[08:28:19.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.314]                     {
[08:28:19.314]                       inherits <- base::inherits
[08:28:19.314]                       invokeRestart <- base::invokeRestart
[08:28:19.314]                       is.null <- base::is.null
[08:28:19.314]                       muffled <- FALSE
[08:28:19.314]                       if (inherits(cond, "message")) {
[08:28:19.314]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.314]                         if (muffled) 
[08:28:19.314]                           invokeRestart("muffleMessage")
[08:28:19.314]                       }
[08:28:19.314]                       else if (inherits(cond, "warning")) {
[08:28:19.314]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.314]                         if (muffled) 
[08:28:19.314]                           invokeRestart("muffleWarning")
[08:28:19.314]                       }
[08:28:19.314]                       else if (inherits(cond, "condition")) {
[08:28:19.314]                         if (!is.null(pattern)) {
[08:28:19.314]                           computeRestarts <- base::computeRestarts
[08:28:19.314]                           grepl <- base::grepl
[08:28:19.314]                           restarts <- computeRestarts(cond)
[08:28:19.314]                           for (restart in restarts) {
[08:28:19.314]                             name <- restart$name
[08:28:19.314]                             if (is.null(name)) 
[08:28:19.314]                               next
[08:28:19.314]                             if (!grepl(pattern, name)) 
[08:28:19.314]                               next
[08:28:19.314]                             invokeRestart(restart)
[08:28:19.314]                             muffled <- TRUE
[08:28:19.314]                             break
[08:28:19.314]                           }
[08:28:19.314]                         }
[08:28:19.314]                       }
[08:28:19.314]                       invisible(muffled)
[08:28:19.314]                     }
[08:28:19.314]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.314]                   }
[08:28:19.314]                 }
[08:28:19.314]                 else {
[08:28:19.314]                   if (TRUE) {
[08:28:19.314]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.314]                     {
[08:28:19.314]                       inherits <- base::inherits
[08:28:19.314]                       invokeRestart <- base::invokeRestart
[08:28:19.314]                       is.null <- base::is.null
[08:28:19.314]                       muffled <- FALSE
[08:28:19.314]                       if (inherits(cond, "message")) {
[08:28:19.314]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.314]                         if (muffled) 
[08:28:19.314]                           invokeRestart("muffleMessage")
[08:28:19.314]                       }
[08:28:19.314]                       else if (inherits(cond, "warning")) {
[08:28:19.314]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.314]                         if (muffled) 
[08:28:19.314]                           invokeRestart("muffleWarning")
[08:28:19.314]                       }
[08:28:19.314]                       else if (inherits(cond, "condition")) {
[08:28:19.314]                         if (!is.null(pattern)) {
[08:28:19.314]                           computeRestarts <- base::computeRestarts
[08:28:19.314]                           grepl <- base::grepl
[08:28:19.314]                           restarts <- computeRestarts(cond)
[08:28:19.314]                           for (restart in restarts) {
[08:28:19.314]                             name <- restart$name
[08:28:19.314]                             if (is.null(name)) 
[08:28:19.314]                               next
[08:28:19.314]                             if (!grepl(pattern, name)) 
[08:28:19.314]                               next
[08:28:19.314]                             invokeRestart(restart)
[08:28:19.314]                             muffled <- TRUE
[08:28:19.314]                             break
[08:28:19.314]                           }
[08:28:19.314]                         }
[08:28:19.314]                       }
[08:28:19.314]                       invisible(muffled)
[08:28:19.314]                     }
[08:28:19.314]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.314]                   }
[08:28:19.314]                 }
[08:28:19.314]             }
[08:28:19.314]         }))
[08:28:19.314]     }, error = function(ex) {
[08:28:19.314]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:19.314]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.314]                 ...future.rng), started = ...future.startTime, 
[08:28:19.314]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:19.314]             version = "1.8"), class = "FutureResult")
[08:28:19.314]     }, finally = {
[08:28:19.314]         if (!identical(...future.workdir, getwd())) 
[08:28:19.314]             setwd(...future.workdir)
[08:28:19.314]         {
[08:28:19.314]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:19.314]                 ...future.oldOptions$nwarnings <- NULL
[08:28:19.314]             }
[08:28:19.314]             base::options(...future.oldOptions)
[08:28:19.314]             if (.Platform$OS.type == "windows") {
[08:28:19.314]                 old_names <- names(...future.oldEnvVars)
[08:28:19.314]                 envs <- base::Sys.getenv()
[08:28:19.314]                 names <- names(envs)
[08:28:19.314]                 common <- intersect(names, old_names)
[08:28:19.314]                 added <- setdiff(names, old_names)
[08:28:19.314]                 removed <- setdiff(old_names, names)
[08:28:19.314]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:19.314]                   envs[common]]
[08:28:19.314]                 NAMES <- toupper(changed)
[08:28:19.314]                 args <- list()
[08:28:19.314]                 for (kk in seq_along(NAMES)) {
[08:28:19.314]                   name <- changed[[kk]]
[08:28:19.314]                   NAME <- NAMES[[kk]]
[08:28:19.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.314]                     next
[08:28:19.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.314]                 }
[08:28:19.314]                 NAMES <- toupper(added)
[08:28:19.314]                 for (kk in seq_along(NAMES)) {
[08:28:19.314]                   name <- added[[kk]]
[08:28:19.314]                   NAME <- NAMES[[kk]]
[08:28:19.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.314]                     next
[08:28:19.314]                   args[[name]] <- ""
[08:28:19.314]                 }
[08:28:19.314]                 NAMES <- toupper(removed)
[08:28:19.314]                 for (kk in seq_along(NAMES)) {
[08:28:19.314]                   name <- removed[[kk]]
[08:28:19.314]                   NAME <- NAMES[[kk]]
[08:28:19.314]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.314]                     next
[08:28:19.314]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.314]                 }
[08:28:19.314]                 if (length(args) > 0) 
[08:28:19.314]                   base::do.call(base::Sys.setenv, args = args)
[08:28:19.314]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:19.314]             }
[08:28:19.314]             else {
[08:28:19.314]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:19.314]             }
[08:28:19.314]             {
[08:28:19.314]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:19.314]                   0L) {
[08:28:19.314]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:19.314]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:19.314]                   base::options(opts)
[08:28:19.314]                 }
[08:28:19.314]                 {
[08:28:19.314]                   {
[08:28:19.314]                     NULL
[08:28:19.314]                     RNGkind("Mersenne-Twister")
[08:28:19.314]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[08:28:19.314]                       inherits = FALSE)
[08:28:19.314]                   }
[08:28:19.314]                   options(future.plan = NULL)
[08:28:19.314]                   if (is.na(NA_character_)) 
[08:28:19.314]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.314]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:19.314]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:19.314]                     .init = FALSE)
[08:28:19.314]                 }
[08:28:19.314]             }
[08:28:19.314]         }
[08:28:19.314]     })
[08:28:19.314]     if (TRUE) {
[08:28:19.314]         base::sink(type = "output", split = FALSE)
[08:28:19.314]         if (TRUE) {
[08:28:19.314]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:19.314]         }
[08:28:19.314]         else {
[08:28:19.314]             ...future.result["stdout"] <- base::list(NULL)
[08:28:19.314]         }
[08:28:19.314]         base::close(...future.stdout)
[08:28:19.314]         ...future.stdout <- NULL
[08:28:19.314]     }
[08:28:19.314]     ...future.result$conditions <- ...future.conditions
[08:28:19.314]     ...future.result$finished <- base::Sys.time()
[08:28:19.314]     ...future.result
[08:28:19.314] }
[08:28:19.316] assign_globals() ...
[08:28:19.316] List of 1
[08:28:19.316]  $ pkg: chr "foo"
[08:28:19.316]  - attr(*, "where")=List of 1
[08:28:19.316]   ..$ pkg:<environment: R_EmptyEnv> 
[08:28:19.316]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[08:28:19.316]  - attr(*, "resolved")= logi TRUE
[08:28:19.316]  - attr(*, "total_size")= num 42
[08:28:19.318] - copied ‘pkg’ to environment
[08:28:19.319] assign_globals() ... done
[08:28:19.319] plan(): Setting new future strategy stack:
[08:28:19.319] List of future strategies:
[08:28:19.319] 1. sequential:
[08:28:19.319]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:19.319]    - tweaked: FALSE
[08:28:19.319]    - call: NULL
[08:28:19.319] plan(): nbrOfWorkers() = 1
[08:28:19.320] plan(): Setting new future strategy stack:
[08:28:19.320] List of future strategies:
[08:28:19.320] 1. multisession:
[08:28:19.320]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[08:28:19.320]    - tweaked: FALSE
[08:28:19.320]    - call: plan(strategy)
[08:28:19.322] plan(): nbrOfWorkers() = 2
[08:28:19.322] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:19.323] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:19.323] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:19.324] - globals found: [3] ‘{’, ‘<-’, ‘+’
[08:28:19.325] Searching for globals ... DONE
[08:28:19.325] Resolving globals: TRUE
[08:28:19.325] Resolving any globals that are futures ...
[08:28:19.325] - globals: [3] ‘{’, ‘<-’, ‘+’
[08:28:19.325] Resolving any globals that are futures ... DONE
[08:28:19.325] 
[08:28:19.325] 
[08:28:19.325] getGlobalsAndPackages() ... DONE
[08:28:19.326] run() for ‘Future’ ...
[08:28:19.326] - state: ‘created’
[08:28:19.326] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:19.340] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:19.340] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:19.340]   - Field: ‘node’
[08:28:19.340]   - Field: ‘label’
[08:28:19.340]   - Field: ‘local’
[08:28:19.340]   - Field: ‘owner’
[08:28:19.340]   - Field: ‘envir’
[08:28:19.341]   - Field: ‘workers’
[08:28:19.341]   - Field: ‘packages’
[08:28:19.341]   - Field: ‘gc’
[08:28:19.341]   - Field: ‘conditions’
[08:28:19.341]   - Field: ‘persistent’
[08:28:19.341]   - Field: ‘expr’
[08:28:19.341]   - Field: ‘uuid’
[08:28:19.341]   - Field: ‘seed’
[08:28:19.341]   - Field: ‘version’
[08:28:19.341]   - Field: ‘result’
[08:28:19.341]   - Field: ‘asynchronous’
[08:28:19.341]   - Field: ‘calls’
[08:28:19.342]   - Field: ‘globals’
[08:28:19.342]   - Field: ‘stdout’
[08:28:19.342]   - Field: ‘earlySignal’
[08:28:19.342]   - Field: ‘lazy’
[08:28:19.342]   - Field: ‘state’
[08:28:19.342] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:19.342] - Launch lazy future ...
[08:28:19.342] Packages needed by the future expression (n = 0): <none>
[08:28:19.342] Packages needed by future strategies (n = 0): <none>
[08:28:19.343] {
[08:28:19.343]     {
[08:28:19.343]         {
[08:28:19.343]             ...future.startTime <- base::Sys.time()
[08:28:19.343]             {
[08:28:19.343]                 {
[08:28:19.343]                   {
[08:28:19.343]                     {
[08:28:19.343]                       base::local({
[08:28:19.343]                         has_future <- base::requireNamespace("future", 
[08:28:19.343]                           quietly = TRUE)
[08:28:19.343]                         if (has_future) {
[08:28:19.343]                           ns <- base::getNamespace("future")
[08:28:19.343]                           version <- ns[[".package"]][["version"]]
[08:28:19.343]                           if (is.null(version)) 
[08:28:19.343]                             version <- utils::packageVersion("future")
[08:28:19.343]                         }
[08:28:19.343]                         else {
[08:28:19.343]                           version <- NULL
[08:28:19.343]                         }
[08:28:19.343]                         if (!has_future || version < "1.8.0") {
[08:28:19.343]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:19.343]                             "", base::R.version$version.string), 
[08:28:19.343]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:19.343]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:19.343]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:19.343]                               "release", "version")], collapse = " "), 
[08:28:19.343]                             hostname = base::Sys.info()[["nodename"]])
[08:28:19.343]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:19.343]                             info)
[08:28:19.343]                           info <- base::paste(info, collapse = "; ")
[08:28:19.343]                           if (!has_future) {
[08:28:19.343]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:19.343]                               info)
[08:28:19.343]                           }
[08:28:19.343]                           else {
[08:28:19.343]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:19.343]                               info, version)
[08:28:19.343]                           }
[08:28:19.343]                           base::stop(msg)
[08:28:19.343]                         }
[08:28:19.343]                       })
[08:28:19.343]                     }
[08:28:19.343]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:19.343]                     base::options(mc.cores = 1L)
[08:28:19.343]                   }
[08:28:19.343]                   ...future.strategy.old <- future::plan("list")
[08:28:19.343]                   options(future.plan = NULL)
[08:28:19.343]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.343]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:19.343]                 }
[08:28:19.343]                 ...future.workdir <- getwd()
[08:28:19.343]             }
[08:28:19.343]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:19.343]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:19.343]         }
[08:28:19.343]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:19.343]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:19.343]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:19.343]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:19.343]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:19.343]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:19.343]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:19.343]             base::names(...future.oldOptions))
[08:28:19.343]     }
[08:28:19.343]     if (FALSE) {
[08:28:19.343]     }
[08:28:19.343]     else {
[08:28:19.343]         if (TRUE) {
[08:28:19.343]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:19.343]                 open = "w")
[08:28:19.343]         }
[08:28:19.343]         else {
[08:28:19.343]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:19.343]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:19.343]         }
[08:28:19.343]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:19.343]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:19.343]             base::sink(type = "output", split = FALSE)
[08:28:19.343]             base::close(...future.stdout)
[08:28:19.343]         }, add = TRUE)
[08:28:19.343]     }
[08:28:19.343]     ...future.frame <- base::sys.nframe()
[08:28:19.343]     ...future.conditions <- base::list()
[08:28:19.343]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:19.343]     if (FALSE) {
[08:28:19.343]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:19.343]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:19.343]     }
[08:28:19.343]     ...future.result <- base::tryCatch({
[08:28:19.343]         base::withCallingHandlers({
[08:28:19.343]             ...future.value <- base::withVisible(base::local({
[08:28:19.343]                 ...future.makeSendCondition <- base::local({
[08:28:19.343]                   sendCondition <- NULL
[08:28:19.343]                   function(frame = 1L) {
[08:28:19.343]                     if (is.function(sendCondition)) 
[08:28:19.343]                       return(sendCondition)
[08:28:19.343]                     ns <- getNamespace("parallel")
[08:28:19.343]                     if (exists("sendData", mode = "function", 
[08:28:19.343]                       envir = ns)) {
[08:28:19.343]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:19.343]                         envir = ns)
[08:28:19.343]                       envir <- sys.frame(frame)
[08:28:19.343]                       master <- NULL
[08:28:19.343]                       while (!identical(envir, .GlobalEnv) && 
[08:28:19.343]                         !identical(envir, emptyenv())) {
[08:28:19.343]                         if (exists("master", mode = "list", envir = envir, 
[08:28:19.343]                           inherits = FALSE)) {
[08:28:19.343]                           master <- get("master", mode = "list", 
[08:28:19.343]                             envir = envir, inherits = FALSE)
[08:28:19.343]                           if (inherits(master, c("SOCKnode", 
[08:28:19.343]                             "SOCK0node"))) {
[08:28:19.343]                             sendCondition <<- function(cond) {
[08:28:19.343]                               data <- list(type = "VALUE", value = cond, 
[08:28:19.343]                                 success = TRUE)
[08:28:19.343]                               parallel_sendData(master, data)
[08:28:19.343]                             }
[08:28:19.343]                             return(sendCondition)
[08:28:19.343]                           }
[08:28:19.343]                         }
[08:28:19.343]                         frame <- frame + 1L
[08:28:19.343]                         envir <- sys.frame(frame)
[08:28:19.343]                       }
[08:28:19.343]                     }
[08:28:19.343]                     sendCondition <<- function(cond) NULL
[08:28:19.343]                   }
[08:28:19.343]                 })
[08:28:19.343]                 withCallingHandlers({
[08:28:19.343]                   {
[08:28:19.343]                     x <- 0
[08:28:19.343]                     x <- x + 1
[08:28:19.343]                     x
[08:28:19.343]                   }
[08:28:19.343]                 }, immediateCondition = function(cond) {
[08:28:19.343]                   sendCondition <- ...future.makeSendCondition()
[08:28:19.343]                   sendCondition(cond)
[08:28:19.343]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.343]                   {
[08:28:19.343]                     inherits <- base::inherits
[08:28:19.343]                     invokeRestart <- base::invokeRestart
[08:28:19.343]                     is.null <- base::is.null
[08:28:19.343]                     muffled <- FALSE
[08:28:19.343]                     if (inherits(cond, "message")) {
[08:28:19.343]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:19.343]                       if (muffled) 
[08:28:19.343]                         invokeRestart("muffleMessage")
[08:28:19.343]                     }
[08:28:19.343]                     else if (inherits(cond, "warning")) {
[08:28:19.343]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:19.343]                       if (muffled) 
[08:28:19.343]                         invokeRestart("muffleWarning")
[08:28:19.343]                     }
[08:28:19.343]                     else if (inherits(cond, "condition")) {
[08:28:19.343]                       if (!is.null(pattern)) {
[08:28:19.343]                         computeRestarts <- base::computeRestarts
[08:28:19.343]                         grepl <- base::grepl
[08:28:19.343]                         restarts <- computeRestarts(cond)
[08:28:19.343]                         for (restart in restarts) {
[08:28:19.343]                           name <- restart$name
[08:28:19.343]                           if (is.null(name)) 
[08:28:19.343]                             next
[08:28:19.343]                           if (!grepl(pattern, name)) 
[08:28:19.343]                             next
[08:28:19.343]                           invokeRestart(restart)
[08:28:19.343]                           muffled <- TRUE
[08:28:19.343]                           break
[08:28:19.343]                         }
[08:28:19.343]                       }
[08:28:19.343]                     }
[08:28:19.343]                     invisible(muffled)
[08:28:19.343]                   }
[08:28:19.343]                   muffleCondition(cond)
[08:28:19.343]                 })
[08:28:19.343]             }))
[08:28:19.343]             future::FutureResult(value = ...future.value$value, 
[08:28:19.343]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.343]                   ...future.rng), globalenv = if (FALSE) 
[08:28:19.343]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:19.343]                     ...future.globalenv.names))
[08:28:19.343]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:19.343]         }, condition = base::local({
[08:28:19.343]             c <- base::c
[08:28:19.343]             inherits <- base::inherits
[08:28:19.343]             invokeRestart <- base::invokeRestart
[08:28:19.343]             length <- base::length
[08:28:19.343]             list <- base::list
[08:28:19.343]             seq.int <- base::seq.int
[08:28:19.343]             signalCondition <- base::signalCondition
[08:28:19.343]             sys.calls <- base::sys.calls
[08:28:19.343]             `[[` <- base::`[[`
[08:28:19.343]             `+` <- base::`+`
[08:28:19.343]             `<<-` <- base::`<<-`
[08:28:19.343]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:19.343]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:19.343]                   3L)]
[08:28:19.343]             }
[08:28:19.343]             function(cond) {
[08:28:19.343]                 is_error <- inherits(cond, "error")
[08:28:19.343]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:19.343]                   NULL)
[08:28:19.343]                 if (is_error) {
[08:28:19.343]                   sessionInformation <- function() {
[08:28:19.343]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:19.343]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:19.343]                       search = base::search(), system = base::Sys.info())
[08:28:19.343]                   }
[08:28:19.343]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.343]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:19.343]                     cond$call), session = sessionInformation(), 
[08:28:19.343]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:19.343]                   signalCondition(cond)
[08:28:19.343]                 }
[08:28:19.343]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:19.343]                 "immediateCondition"))) {
[08:28:19.343]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:19.343]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.343]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:19.343]                   if (TRUE && !signal) {
[08:28:19.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.343]                     {
[08:28:19.343]                       inherits <- base::inherits
[08:28:19.343]                       invokeRestart <- base::invokeRestart
[08:28:19.343]                       is.null <- base::is.null
[08:28:19.343]                       muffled <- FALSE
[08:28:19.343]                       if (inherits(cond, "message")) {
[08:28:19.343]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.343]                         if (muffled) 
[08:28:19.343]                           invokeRestart("muffleMessage")
[08:28:19.343]                       }
[08:28:19.343]                       else if (inherits(cond, "warning")) {
[08:28:19.343]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.343]                         if (muffled) 
[08:28:19.343]                           invokeRestart("muffleWarning")
[08:28:19.343]                       }
[08:28:19.343]                       else if (inherits(cond, "condition")) {
[08:28:19.343]                         if (!is.null(pattern)) {
[08:28:19.343]                           computeRestarts <- base::computeRestarts
[08:28:19.343]                           grepl <- base::grepl
[08:28:19.343]                           restarts <- computeRestarts(cond)
[08:28:19.343]                           for (restart in restarts) {
[08:28:19.343]                             name <- restart$name
[08:28:19.343]                             if (is.null(name)) 
[08:28:19.343]                               next
[08:28:19.343]                             if (!grepl(pattern, name)) 
[08:28:19.343]                               next
[08:28:19.343]                             invokeRestart(restart)
[08:28:19.343]                             muffled <- TRUE
[08:28:19.343]                             break
[08:28:19.343]                           }
[08:28:19.343]                         }
[08:28:19.343]                       }
[08:28:19.343]                       invisible(muffled)
[08:28:19.343]                     }
[08:28:19.343]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.343]                   }
[08:28:19.343]                 }
[08:28:19.343]                 else {
[08:28:19.343]                   if (TRUE) {
[08:28:19.343]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.343]                     {
[08:28:19.343]                       inherits <- base::inherits
[08:28:19.343]                       invokeRestart <- base::invokeRestart
[08:28:19.343]                       is.null <- base::is.null
[08:28:19.343]                       muffled <- FALSE
[08:28:19.343]                       if (inherits(cond, "message")) {
[08:28:19.343]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.343]                         if (muffled) 
[08:28:19.343]                           invokeRestart("muffleMessage")
[08:28:19.343]                       }
[08:28:19.343]                       else if (inherits(cond, "warning")) {
[08:28:19.343]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.343]                         if (muffled) 
[08:28:19.343]                           invokeRestart("muffleWarning")
[08:28:19.343]                       }
[08:28:19.343]                       else if (inherits(cond, "condition")) {
[08:28:19.343]                         if (!is.null(pattern)) {
[08:28:19.343]                           computeRestarts <- base::computeRestarts
[08:28:19.343]                           grepl <- base::grepl
[08:28:19.343]                           restarts <- computeRestarts(cond)
[08:28:19.343]                           for (restart in restarts) {
[08:28:19.343]                             name <- restart$name
[08:28:19.343]                             if (is.null(name)) 
[08:28:19.343]                               next
[08:28:19.343]                             if (!grepl(pattern, name)) 
[08:28:19.343]                               next
[08:28:19.343]                             invokeRestart(restart)
[08:28:19.343]                             muffled <- TRUE
[08:28:19.343]                             break
[08:28:19.343]                           }
[08:28:19.343]                         }
[08:28:19.343]                       }
[08:28:19.343]                       invisible(muffled)
[08:28:19.343]                     }
[08:28:19.343]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.343]                   }
[08:28:19.343]                 }
[08:28:19.343]             }
[08:28:19.343]         }))
[08:28:19.343]     }, error = function(ex) {
[08:28:19.343]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:19.343]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.343]                 ...future.rng), started = ...future.startTime, 
[08:28:19.343]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:19.343]             version = "1.8"), class = "FutureResult")
[08:28:19.343]     }, finally = {
[08:28:19.343]         if (!identical(...future.workdir, getwd())) 
[08:28:19.343]             setwd(...future.workdir)
[08:28:19.343]         {
[08:28:19.343]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:19.343]                 ...future.oldOptions$nwarnings <- NULL
[08:28:19.343]             }
[08:28:19.343]             base::options(...future.oldOptions)
[08:28:19.343]             if (.Platform$OS.type == "windows") {
[08:28:19.343]                 old_names <- names(...future.oldEnvVars)
[08:28:19.343]                 envs <- base::Sys.getenv()
[08:28:19.343]                 names <- names(envs)
[08:28:19.343]                 common <- intersect(names, old_names)
[08:28:19.343]                 added <- setdiff(names, old_names)
[08:28:19.343]                 removed <- setdiff(old_names, names)
[08:28:19.343]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:19.343]                   envs[common]]
[08:28:19.343]                 NAMES <- toupper(changed)
[08:28:19.343]                 args <- list()
[08:28:19.343]                 for (kk in seq_along(NAMES)) {
[08:28:19.343]                   name <- changed[[kk]]
[08:28:19.343]                   NAME <- NAMES[[kk]]
[08:28:19.343]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.343]                     next
[08:28:19.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.343]                 }
[08:28:19.343]                 NAMES <- toupper(added)
[08:28:19.343]                 for (kk in seq_along(NAMES)) {
[08:28:19.343]                   name <- added[[kk]]
[08:28:19.343]                   NAME <- NAMES[[kk]]
[08:28:19.343]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.343]                     next
[08:28:19.343]                   args[[name]] <- ""
[08:28:19.343]                 }
[08:28:19.343]                 NAMES <- toupper(removed)
[08:28:19.343]                 for (kk in seq_along(NAMES)) {
[08:28:19.343]                   name <- removed[[kk]]
[08:28:19.343]                   NAME <- NAMES[[kk]]
[08:28:19.343]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.343]                     next
[08:28:19.343]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.343]                 }
[08:28:19.343]                 if (length(args) > 0) 
[08:28:19.343]                   base::do.call(base::Sys.setenv, args = args)
[08:28:19.343]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:19.343]             }
[08:28:19.343]             else {
[08:28:19.343]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:19.343]             }
[08:28:19.343]             {
[08:28:19.343]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:19.343]                   0L) {
[08:28:19.343]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:19.343]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:19.343]                   base::options(opts)
[08:28:19.343]                 }
[08:28:19.343]                 {
[08:28:19.343]                   {
[08:28:19.343]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:19.343]                     NULL
[08:28:19.343]                   }
[08:28:19.343]                   options(future.plan = NULL)
[08:28:19.343]                   if (is.na(NA_character_)) 
[08:28:19.343]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.343]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:19.343]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:19.343]                     .init = FALSE)
[08:28:19.343]                 }
[08:28:19.343]             }
[08:28:19.343]         }
[08:28:19.343]     })
[08:28:19.343]     if (TRUE) {
[08:28:19.343]         base::sink(type = "output", split = FALSE)
[08:28:19.343]         if (TRUE) {
[08:28:19.343]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:19.343]         }
[08:28:19.343]         else {
[08:28:19.343]             ...future.result["stdout"] <- base::list(NULL)
[08:28:19.343]         }
[08:28:19.343]         base::close(...future.stdout)
[08:28:19.343]         ...future.stdout <- NULL
[08:28:19.343]     }
[08:28:19.343]     ...future.result$conditions <- ...future.conditions
[08:28:19.343]     ...future.result$finished <- base::Sys.time()
[08:28:19.343]     ...future.result
[08:28:19.343] }
[08:28:19.346] MultisessionFuture started
[08:28:19.346] - Launch lazy future ... done
[08:28:19.346] run() for ‘MultisessionFuture’ ... done
[08:28:19.346] result() for ClusterFuture ...
[08:28:19.346] receiveMessageFromWorker() for ClusterFuture ...
[08:28:19.346] - Validating connection of MultisessionFuture
[08:28:19.388] - received message: FutureResult
[08:28:19.388] - Received FutureResult
[08:28:19.388] - Erased future from FutureRegistry
[08:28:19.388] result() for ClusterFuture ...
[08:28:19.388] - result already collected: FutureResult
[08:28:19.389] result() for ClusterFuture ... done
[08:28:19.389] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:19.389] result() for ClusterFuture ... done
[08:28:19.389] result() for ClusterFuture ...
[08:28:19.389] - result already collected: FutureResult
[08:28:19.389] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:19.389] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:19.389] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:19.391] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[08:28:19.391] Searching for globals ... DONE
[08:28:19.391] Resolving globals: TRUE
[08:28:19.391] Resolving any globals that are futures ...
[08:28:19.391] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[08:28:19.391] Resolving any globals that are futures ... DONE
[08:28:19.392] Resolving futures part of globals (recursively) ...
[08:28:19.392] resolve() on list ...
[08:28:19.392]  recursive: 99
[08:28:19.392]  length: 1
[08:28:19.392]  elements: ‘x’
[08:28:19.392]  length: 0 (resolved future 1)
[08:28:19.392] resolve() on list ... DONE
[08:28:19.393] - globals: [1] ‘x’
[08:28:19.393] Resolving futures part of globals (recursively) ... DONE
[08:28:19.393] The total size of the 1 globals is 39 bytes (39 bytes)
[08:28:19.393] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[08:28:19.393] - globals: [1] ‘x’
[08:28:19.393] 
[08:28:19.393] getGlobalsAndPackages() ... DONE
[08:28:19.394] run() for ‘Future’ ...
[08:28:19.394] - state: ‘created’
[08:28:19.394] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:19.408] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:19.408] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:19.408]   - Field: ‘node’
[08:28:19.408]   - Field: ‘label’
[08:28:19.408]   - Field: ‘local’
[08:28:19.408]   - Field: ‘owner’
[08:28:19.408]   - Field: ‘envir’
[08:28:19.408]   - Field: ‘workers’
[08:28:19.408]   - Field: ‘packages’
[08:28:19.408]   - Field: ‘gc’
[08:28:19.409]   - Field: ‘conditions’
[08:28:19.409]   - Field: ‘persistent’
[08:28:19.409]   - Field: ‘expr’
[08:28:19.409]   - Field: ‘uuid’
[08:28:19.409]   - Field: ‘seed’
[08:28:19.409]   - Field: ‘version’
[08:28:19.409]   - Field: ‘result’
[08:28:19.409]   - Field: ‘asynchronous’
[08:28:19.409]   - Field: ‘calls’
[08:28:19.409]   - Field: ‘globals’
[08:28:19.412]   - Field: ‘stdout’
[08:28:19.412]   - Field: ‘earlySignal’
[08:28:19.412]   - Field: ‘lazy’
[08:28:19.412]   - Field: ‘state’
[08:28:19.412] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:19.412] - Launch lazy future ...
[08:28:19.413] Packages needed by the future expression (n = 0): <none>
[08:28:19.413] Packages needed by future strategies (n = 0): <none>
[08:28:19.413] {
[08:28:19.413]     {
[08:28:19.413]         {
[08:28:19.413]             ...future.startTime <- base::Sys.time()
[08:28:19.413]             {
[08:28:19.413]                 {
[08:28:19.413]                   {
[08:28:19.413]                     {
[08:28:19.413]                       base::local({
[08:28:19.413]                         has_future <- base::requireNamespace("future", 
[08:28:19.413]                           quietly = TRUE)
[08:28:19.413]                         if (has_future) {
[08:28:19.413]                           ns <- base::getNamespace("future")
[08:28:19.413]                           version <- ns[[".package"]][["version"]]
[08:28:19.413]                           if (is.null(version)) 
[08:28:19.413]                             version <- utils::packageVersion("future")
[08:28:19.413]                         }
[08:28:19.413]                         else {
[08:28:19.413]                           version <- NULL
[08:28:19.413]                         }
[08:28:19.413]                         if (!has_future || version < "1.8.0") {
[08:28:19.413]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:19.413]                             "", base::R.version$version.string), 
[08:28:19.413]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:19.413]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:19.413]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:19.413]                               "release", "version")], collapse = " "), 
[08:28:19.413]                             hostname = base::Sys.info()[["nodename"]])
[08:28:19.413]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:19.413]                             info)
[08:28:19.413]                           info <- base::paste(info, collapse = "; ")
[08:28:19.413]                           if (!has_future) {
[08:28:19.413]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:19.413]                               info)
[08:28:19.413]                           }
[08:28:19.413]                           else {
[08:28:19.413]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:19.413]                               info, version)
[08:28:19.413]                           }
[08:28:19.413]                           base::stop(msg)
[08:28:19.413]                         }
[08:28:19.413]                       })
[08:28:19.413]                     }
[08:28:19.413]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:19.413]                     base::options(mc.cores = 1L)
[08:28:19.413]                   }
[08:28:19.413]                   ...future.strategy.old <- future::plan("list")
[08:28:19.413]                   options(future.plan = NULL)
[08:28:19.413]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.413]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:19.413]                 }
[08:28:19.413]                 ...future.workdir <- getwd()
[08:28:19.413]             }
[08:28:19.413]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:19.413]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:19.413]         }
[08:28:19.413]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:19.413]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:19.413]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:19.413]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:19.413]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:19.413]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:19.413]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:19.413]             base::names(...future.oldOptions))
[08:28:19.413]     }
[08:28:19.413]     if (FALSE) {
[08:28:19.413]     }
[08:28:19.413]     else {
[08:28:19.413]         if (TRUE) {
[08:28:19.413]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:19.413]                 open = "w")
[08:28:19.413]         }
[08:28:19.413]         else {
[08:28:19.413]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:19.413]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:19.413]         }
[08:28:19.413]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:19.413]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:19.413]             base::sink(type = "output", split = FALSE)
[08:28:19.413]             base::close(...future.stdout)
[08:28:19.413]         }, add = TRUE)
[08:28:19.413]     }
[08:28:19.413]     ...future.frame <- base::sys.nframe()
[08:28:19.413]     ...future.conditions <- base::list()
[08:28:19.413]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:19.413]     if (FALSE) {
[08:28:19.413]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:19.413]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:19.413]     }
[08:28:19.413]     ...future.result <- base::tryCatch({
[08:28:19.413]         base::withCallingHandlers({
[08:28:19.413]             ...future.value <- base::withVisible(base::local({
[08:28:19.413]                 ...future.makeSendCondition <- base::local({
[08:28:19.413]                   sendCondition <- NULL
[08:28:19.413]                   function(frame = 1L) {
[08:28:19.413]                     if (is.function(sendCondition)) 
[08:28:19.413]                       return(sendCondition)
[08:28:19.413]                     ns <- getNamespace("parallel")
[08:28:19.413]                     if (exists("sendData", mode = "function", 
[08:28:19.413]                       envir = ns)) {
[08:28:19.413]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:19.413]                         envir = ns)
[08:28:19.413]                       envir <- sys.frame(frame)
[08:28:19.413]                       master <- NULL
[08:28:19.413]                       while (!identical(envir, .GlobalEnv) && 
[08:28:19.413]                         !identical(envir, emptyenv())) {
[08:28:19.413]                         if (exists("master", mode = "list", envir = envir, 
[08:28:19.413]                           inherits = FALSE)) {
[08:28:19.413]                           master <- get("master", mode = "list", 
[08:28:19.413]                             envir = envir, inherits = FALSE)
[08:28:19.413]                           if (inherits(master, c("SOCKnode", 
[08:28:19.413]                             "SOCK0node"))) {
[08:28:19.413]                             sendCondition <<- function(cond) {
[08:28:19.413]                               data <- list(type = "VALUE", value = cond, 
[08:28:19.413]                                 success = TRUE)
[08:28:19.413]                               parallel_sendData(master, data)
[08:28:19.413]                             }
[08:28:19.413]                             return(sendCondition)
[08:28:19.413]                           }
[08:28:19.413]                         }
[08:28:19.413]                         frame <- frame + 1L
[08:28:19.413]                         envir <- sys.frame(frame)
[08:28:19.413]                       }
[08:28:19.413]                     }
[08:28:19.413]                     sendCondition <<- function(cond) NULL
[08:28:19.413]                   }
[08:28:19.413]                 })
[08:28:19.413]                 withCallingHandlers({
[08:28:19.413]                   {
[08:28:19.413]                     x <- x + 1
[08:28:19.413]                     x
[08:28:19.413]                   }
[08:28:19.413]                 }, immediateCondition = function(cond) {
[08:28:19.413]                   sendCondition <- ...future.makeSendCondition()
[08:28:19.413]                   sendCondition(cond)
[08:28:19.413]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.413]                   {
[08:28:19.413]                     inherits <- base::inherits
[08:28:19.413]                     invokeRestart <- base::invokeRestart
[08:28:19.413]                     is.null <- base::is.null
[08:28:19.413]                     muffled <- FALSE
[08:28:19.413]                     if (inherits(cond, "message")) {
[08:28:19.413]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:19.413]                       if (muffled) 
[08:28:19.413]                         invokeRestart("muffleMessage")
[08:28:19.413]                     }
[08:28:19.413]                     else if (inherits(cond, "warning")) {
[08:28:19.413]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:19.413]                       if (muffled) 
[08:28:19.413]                         invokeRestart("muffleWarning")
[08:28:19.413]                     }
[08:28:19.413]                     else if (inherits(cond, "condition")) {
[08:28:19.413]                       if (!is.null(pattern)) {
[08:28:19.413]                         computeRestarts <- base::computeRestarts
[08:28:19.413]                         grepl <- base::grepl
[08:28:19.413]                         restarts <- computeRestarts(cond)
[08:28:19.413]                         for (restart in restarts) {
[08:28:19.413]                           name <- restart$name
[08:28:19.413]                           if (is.null(name)) 
[08:28:19.413]                             next
[08:28:19.413]                           if (!grepl(pattern, name)) 
[08:28:19.413]                             next
[08:28:19.413]                           invokeRestart(restart)
[08:28:19.413]                           muffled <- TRUE
[08:28:19.413]                           break
[08:28:19.413]                         }
[08:28:19.413]                       }
[08:28:19.413]                     }
[08:28:19.413]                     invisible(muffled)
[08:28:19.413]                   }
[08:28:19.413]                   muffleCondition(cond)
[08:28:19.413]                 })
[08:28:19.413]             }))
[08:28:19.413]             future::FutureResult(value = ...future.value$value, 
[08:28:19.413]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.413]                   ...future.rng), globalenv = if (FALSE) 
[08:28:19.413]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:19.413]                     ...future.globalenv.names))
[08:28:19.413]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:19.413]         }, condition = base::local({
[08:28:19.413]             c <- base::c
[08:28:19.413]             inherits <- base::inherits
[08:28:19.413]             invokeRestart <- base::invokeRestart
[08:28:19.413]             length <- base::length
[08:28:19.413]             list <- base::list
[08:28:19.413]             seq.int <- base::seq.int
[08:28:19.413]             signalCondition <- base::signalCondition
[08:28:19.413]             sys.calls <- base::sys.calls
[08:28:19.413]             `[[` <- base::`[[`
[08:28:19.413]             `+` <- base::`+`
[08:28:19.413]             `<<-` <- base::`<<-`
[08:28:19.413]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:19.413]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:19.413]                   3L)]
[08:28:19.413]             }
[08:28:19.413]             function(cond) {
[08:28:19.413]                 is_error <- inherits(cond, "error")
[08:28:19.413]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:19.413]                   NULL)
[08:28:19.413]                 if (is_error) {
[08:28:19.413]                   sessionInformation <- function() {
[08:28:19.413]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:19.413]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:19.413]                       search = base::search(), system = base::Sys.info())
[08:28:19.413]                   }
[08:28:19.413]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.413]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:19.413]                     cond$call), session = sessionInformation(), 
[08:28:19.413]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:19.413]                   signalCondition(cond)
[08:28:19.413]                 }
[08:28:19.413]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:19.413]                 "immediateCondition"))) {
[08:28:19.413]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:19.413]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.413]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:19.413]                   if (TRUE && !signal) {
[08:28:19.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.413]                     {
[08:28:19.413]                       inherits <- base::inherits
[08:28:19.413]                       invokeRestart <- base::invokeRestart
[08:28:19.413]                       is.null <- base::is.null
[08:28:19.413]                       muffled <- FALSE
[08:28:19.413]                       if (inherits(cond, "message")) {
[08:28:19.413]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.413]                         if (muffled) 
[08:28:19.413]                           invokeRestart("muffleMessage")
[08:28:19.413]                       }
[08:28:19.413]                       else if (inherits(cond, "warning")) {
[08:28:19.413]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.413]                         if (muffled) 
[08:28:19.413]                           invokeRestart("muffleWarning")
[08:28:19.413]                       }
[08:28:19.413]                       else if (inherits(cond, "condition")) {
[08:28:19.413]                         if (!is.null(pattern)) {
[08:28:19.413]                           computeRestarts <- base::computeRestarts
[08:28:19.413]                           grepl <- base::grepl
[08:28:19.413]                           restarts <- computeRestarts(cond)
[08:28:19.413]                           for (restart in restarts) {
[08:28:19.413]                             name <- restart$name
[08:28:19.413]                             if (is.null(name)) 
[08:28:19.413]                               next
[08:28:19.413]                             if (!grepl(pattern, name)) 
[08:28:19.413]                               next
[08:28:19.413]                             invokeRestart(restart)
[08:28:19.413]                             muffled <- TRUE
[08:28:19.413]                             break
[08:28:19.413]                           }
[08:28:19.413]                         }
[08:28:19.413]                       }
[08:28:19.413]                       invisible(muffled)
[08:28:19.413]                     }
[08:28:19.413]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.413]                   }
[08:28:19.413]                 }
[08:28:19.413]                 else {
[08:28:19.413]                   if (TRUE) {
[08:28:19.413]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.413]                     {
[08:28:19.413]                       inherits <- base::inherits
[08:28:19.413]                       invokeRestart <- base::invokeRestart
[08:28:19.413]                       is.null <- base::is.null
[08:28:19.413]                       muffled <- FALSE
[08:28:19.413]                       if (inherits(cond, "message")) {
[08:28:19.413]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.413]                         if (muffled) 
[08:28:19.413]                           invokeRestart("muffleMessage")
[08:28:19.413]                       }
[08:28:19.413]                       else if (inherits(cond, "warning")) {
[08:28:19.413]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.413]                         if (muffled) 
[08:28:19.413]                           invokeRestart("muffleWarning")
[08:28:19.413]                       }
[08:28:19.413]                       else if (inherits(cond, "condition")) {
[08:28:19.413]                         if (!is.null(pattern)) {
[08:28:19.413]                           computeRestarts <- base::computeRestarts
[08:28:19.413]                           grepl <- base::grepl
[08:28:19.413]                           restarts <- computeRestarts(cond)
[08:28:19.413]                           for (restart in restarts) {
[08:28:19.413]                             name <- restart$name
[08:28:19.413]                             if (is.null(name)) 
[08:28:19.413]                               next
[08:28:19.413]                             if (!grepl(pattern, name)) 
[08:28:19.413]                               next
[08:28:19.413]                             invokeRestart(restart)
[08:28:19.413]                             muffled <- TRUE
[08:28:19.413]                             break
[08:28:19.413]                           }
[08:28:19.413]                         }
[08:28:19.413]                       }
[08:28:19.413]                       invisible(muffled)
[08:28:19.413]                     }
[08:28:19.413]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.413]                   }
[08:28:19.413]                 }
[08:28:19.413]             }
[08:28:19.413]         }))
[08:28:19.413]     }, error = function(ex) {
[08:28:19.413]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:19.413]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.413]                 ...future.rng), started = ...future.startTime, 
[08:28:19.413]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:19.413]             version = "1.8"), class = "FutureResult")
[08:28:19.413]     }, finally = {
[08:28:19.413]         if (!identical(...future.workdir, getwd())) 
[08:28:19.413]             setwd(...future.workdir)
[08:28:19.413]         {
[08:28:19.413]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:19.413]                 ...future.oldOptions$nwarnings <- NULL
[08:28:19.413]             }
[08:28:19.413]             base::options(...future.oldOptions)
[08:28:19.413]             if (.Platform$OS.type == "windows") {
[08:28:19.413]                 old_names <- names(...future.oldEnvVars)
[08:28:19.413]                 envs <- base::Sys.getenv()
[08:28:19.413]                 names <- names(envs)
[08:28:19.413]                 common <- intersect(names, old_names)
[08:28:19.413]                 added <- setdiff(names, old_names)
[08:28:19.413]                 removed <- setdiff(old_names, names)
[08:28:19.413]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:19.413]                   envs[common]]
[08:28:19.413]                 NAMES <- toupper(changed)
[08:28:19.413]                 args <- list()
[08:28:19.413]                 for (kk in seq_along(NAMES)) {
[08:28:19.413]                   name <- changed[[kk]]
[08:28:19.413]                   NAME <- NAMES[[kk]]
[08:28:19.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.413]                     next
[08:28:19.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.413]                 }
[08:28:19.413]                 NAMES <- toupper(added)
[08:28:19.413]                 for (kk in seq_along(NAMES)) {
[08:28:19.413]                   name <- added[[kk]]
[08:28:19.413]                   NAME <- NAMES[[kk]]
[08:28:19.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.413]                     next
[08:28:19.413]                   args[[name]] <- ""
[08:28:19.413]                 }
[08:28:19.413]                 NAMES <- toupper(removed)
[08:28:19.413]                 for (kk in seq_along(NAMES)) {
[08:28:19.413]                   name <- removed[[kk]]
[08:28:19.413]                   NAME <- NAMES[[kk]]
[08:28:19.413]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.413]                     next
[08:28:19.413]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.413]                 }
[08:28:19.413]                 if (length(args) > 0) 
[08:28:19.413]                   base::do.call(base::Sys.setenv, args = args)
[08:28:19.413]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:19.413]             }
[08:28:19.413]             else {
[08:28:19.413]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:19.413]             }
[08:28:19.413]             {
[08:28:19.413]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:19.413]                   0L) {
[08:28:19.413]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:19.413]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:19.413]                   base::options(opts)
[08:28:19.413]                 }
[08:28:19.413]                 {
[08:28:19.413]                   {
[08:28:19.413]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:19.413]                     NULL
[08:28:19.413]                   }
[08:28:19.413]                   options(future.plan = NULL)
[08:28:19.413]                   if (is.na(NA_character_)) 
[08:28:19.413]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.413]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:19.413]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:19.413]                     .init = FALSE)
[08:28:19.413]                 }
[08:28:19.413]             }
[08:28:19.413]         }
[08:28:19.413]     })
[08:28:19.413]     if (TRUE) {
[08:28:19.413]         base::sink(type = "output", split = FALSE)
[08:28:19.413]         if (TRUE) {
[08:28:19.413]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:19.413]         }
[08:28:19.413]         else {
[08:28:19.413]             ...future.result["stdout"] <- base::list(NULL)
[08:28:19.413]         }
[08:28:19.413]         base::close(...future.stdout)
[08:28:19.413]         ...future.stdout <- NULL
[08:28:19.413]     }
[08:28:19.413]     ...future.result$conditions <- ...future.conditions
[08:28:19.413]     ...future.result$finished <- base::Sys.time()
[08:28:19.413]     ...future.result
[08:28:19.413] }
[08:28:19.416] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[08:28:19.416] Exporting ‘x’ (39 bytes) to cluster node #1 ...
[08:28:19.416] Exporting ‘x’ (39 bytes) to cluster node #1 ... DONE
[08:28:19.416] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[08:28:19.417] MultisessionFuture started
[08:28:19.417] - Launch lazy future ... done
[08:28:19.417] run() for ‘MultisessionFuture’ ... done
[08:28:19.417] result() for ClusterFuture ...
[08:28:19.417] receiveMessageFromWorker() for ClusterFuture ...
[08:28:19.417] - Validating connection of MultisessionFuture
[08:28:19.460] - received message: FutureResult
[08:28:19.460] - Received FutureResult
[08:28:19.460] - Erased future from FutureRegistry
[08:28:19.460] result() for ClusterFuture ...
[08:28:19.460] - result already collected: FutureResult
[08:28:19.461] result() for ClusterFuture ... done
[08:28:19.461] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:19.461] result() for ClusterFuture ... done
[08:28:19.461] result() for ClusterFuture ...
[08:28:19.461] - result already collected: FutureResult
[08:28:19.461] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[08:28:19.462] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[08:28:19.462] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[08:28:19.465] - globals found: [3] ‘{’, ‘<-’, ‘x’
[08:28:19.465] Searching for globals ... DONE
[08:28:19.465] Resolving globals: TRUE
[08:28:19.465] Resolving any globals that are futures ...
[08:28:19.465] - globals: [3] ‘{’, ‘<-’, ‘x’
[08:28:19.465] Resolving any globals that are futures ... DONE
[08:28:19.466] Resolving futures part of globals (recursively) ...
[08:28:19.466] resolve() on list ...
[08:28:19.466]  recursive: 99
[08:28:19.466]  length: 1
[08:28:19.466]  elements: ‘x’
[08:28:19.466]  length: 0 (resolved future 1)
[08:28:19.466] resolve() on list ... DONE
[08:28:19.466] - globals: [1] ‘x’
[08:28:19.467] Resolving futures part of globals (recursively) ... DONE
[08:28:19.467] The total size of the 1 globals is 260 bytes (260 bytes)
[08:28:19.467] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[08:28:19.467] - globals: [1] ‘x’
[08:28:19.467] 
[08:28:19.467] getGlobalsAndPackages() ... DONE
[08:28:19.468] run() for ‘Future’ ...
[08:28:19.468] - state: ‘created’
[08:28:19.468] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[08:28:19.484] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[08:28:19.484] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[08:28:19.484]   - Field: ‘node’
[08:28:19.484]   - Field: ‘label’
[08:28:19.485]   - Field: ‘local’
[08:28:19.485]   - Field: ‘owner’
[08:28:19.485]   - Field: ‘envir’
[08:28:19.485]   - Field: ‘workers’
[08:28:19.485]   - Field: ‘packages’
[08:28:19.485]   - Field: ‘gc’
[08:28:19.486]   - Field: ‘conditions’
[08:28:19.486]   - Field: ‘persistent’
[08:28:19.486]   - Field: ‘expr’
[08:28:19.486]   - Field: ‘uuid’
[08:28:19.486]   - Field: ‘seed’
[08:28:19.486]   - Field: ‘version’
[08:28:19.487]   - Field: ‘result’
[08:28:19.487]   - Field: ‘asynchronous’
[08:28:19.487]   - Field: ‘calls’
[08:28:19.487]   - Field: ‘globals’
[08:28:19.487]   - Field: ‘stdout’
[08:28:19.487]   - Field: ‘earlySignal’
[08:28:19.488]   - Field: ‘lazy’
[08:28:19.488]   - Field: ‘state’
[08:28:19.488] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[08:28:19.488] - Launch lazy future ...
[08:28:19.489] Packages needed by the future expression (n = 0): <none>
[08:28:19.489] Packages needed by future strategies (n = 0): <none>
[08:28:19.490] {
[08:28:19.490]     {
[08:28:19.490]         {
[08:28:19.490]             ...future.startTime <- base::Sys.time()
[08:28:19.490]             {
[08:28:19.490]                 {
[08:28:19.490]                   {
[08:28:19.490]                     {
[08:28:19.490]                       base::local({
[08:28:19.490]                         has_future <- base::requireNamespace("future", 
[08:28:19.490]                           quietly = TRUE)
[08:28:19.490]                         if (has_future) {
[08:28:19.490]                           ns <- base::getNamespace("future")
[08:28:19.490]                           version <- ns[[".package"]][["version"]]
[08:28:19.490]                           if (is.null(version)) 
[08:28:19.490]                             version <- utils::packageVersion("future")
[08:28:19.490]                         }
[08:28:19.490]                         else {
[08:28:19.490]                           version <- NULL
[08:28:19.490]                         }
[08:28:19.490]                         if (!has_future || version < "1.8.0") {
[08:28:19.490]                           info <- base::c(r_version = base::gsub("R version ", 
[08:28:19.490]                             "", base::R.version$version.string), 
[08:28:19.490]                             platform = base::sprintf("%s (%s-bit)", 
[08:28:19.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[08:28:19.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[08:28:19.490]                               "release", "version")], collapse = " "), 
[08:28:19.490]                             hostname = base::Sys.info()[["nodename"]])
[08:28:19.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[08:28:19.490]                             info)
[08:28:19.490]                           info <- base::paste(info, collapse = "; ")
[08:28:19.490]                           if (!has_future) {
[08:28:19.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[08:28:19.490]                               info)
[08:28:19.490]                           }
[08:28:19.490]                           else {
[08:28:19.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[08:28:19.490]                               info, version)
[08:28:19.490]                           }
[08:28:19.490]                           base::stop(msg)
[08:28:19.490]                         }
[08:28:19.490]                       })
[08:28:19.490]                     }
[08:28:19.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[08:28:19.490]                     base::options(mc.cores = 1L)
[08:28:19.490]                   }
[08:28:19.490]                   ...future.strategy.old <- future::plan("list")
[08:28:19.490]                   options(future.plan = NULL)
[08:28:19.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[08:28:19.490]                 }
[08:28:19.490]                 ...future.workdir <- getwd()
[08:28:19.490]             }
[08:28:19.490]             ...future.oldOptions <- base::as.list(base::.Options)
[08:28:19.490]             ...future.oldEnvVars <- base::Sys.getenv()
[08:28:19.490]         }
[08:28:19.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[08:28:19.490]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[08:28:19.490]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[08:28:19.490]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[08:28:19.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[08:28:19.490]             future.stdout.windows.reencode = NULL, width = 80L)
[08:28:19.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[08:28:19.490]             base::names(...future.oldOptions))
[08:28:19.490]     }
[08:28:19.490]     if (FALSE) {
[08:28:19.490]     }
[08:28:19.490]     else {
[08:28:19.490]         if (TRUE) {
[08:28:19.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[08:28:19.490]                 open = "w")
[08:28:19.490]         }
[08:28:19.490]         else {
[08:28:19.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[08:28:19.490]                 windows = "NUL", "/dev/null"), open = "w")
[08:28:19.490]         }
[08:28:19.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[08:28:19.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[08:28:19.490]             base::sink(type = "output", split = FALSE)
[08:28:19.490]             base::close(...future.stdout)
[08:28:19.490]         }, add = TRUE)
[08:28:19.490]     }
[08:28:19.490]     ...future.frame <- base::sys.nframe()
[08:28:19.490]     ...future.conditions <- base::list()
[08:28:19.490]     ...future.rng <- base::globalenv()$.Random.seed
[08:28:19.490]     if (FALSE) {
[08:28:19.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[08:28:19.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[08:28:19.490]     }
[08:28:19.490]     ...future.result <- base::tryCatch({
[08:28:19.490]         base::withCallingHandlers({
[08:28:19.490]             ...future.value <- base::withVisible(base::local({
[08:28:19.490]                 ...future.makeSendCondition <- base::local({
[08:28:19.490]                   sendCondition <- NULL
[08:28:19.490]                   function(frame = 1L) {
[08:28:19.490]                     if (is.function(sendCondition)) 
[08:28:19.490]                       return(sendCondition)
[08:28:19.490]                     ns <- getNamespace("parallel")
[08:28:19.490]                     if (exists("sendData", mode = "function", 
[08:28:19.490]                       envir = ns)) {
[08:28:19.490]                       parallel_sendData <- get("sendData", mode = "function", 
[08:28:19.490]                         envir = ns)
[08:28:19.490]                       envir <- sys.frame(frame)
[08:28:19.490]                       master <- NULL
[08:28:19.490]                       while (!identical(envir, .GlobalEnv) && 
[08:28:19.490]                         !identical(envir, emptyenv())) {
[08:28:19.490]                         if (exists("master", mode = "list", envir = envir, 
[08:28:19.490]                           inherits = FALSE)) {
[08:28:19.490]                           master <- get("master", mode = "list", 
[08:28:19.490]                             envir = envir, inherits = FALSE)
[08:28:19.490]                           if (inherits(master, c("SOCKnode", 
[08:28:19.490]                             "SOCK0node"))) {
[08:28:19.490]                             sendCondition <<- function(cond) {
[08:28:19.490]                               data <- list(type = "VALUE", value = cond, 
[08:28:19.490]                                 success = TRUE)
[08:28:19.490]                               parallel_sendData(master, data)
[08:28:19.490]                             }
[08:28:19.490]                             return(sendCondition)
[08:28:19.490]                           }
[08:28:19.490]                         }
[08:28:19.490]                         frame <- frame + 1L
[08:28:19.490]                         envir <- sys.frame(frame)
[08:28:19.490]                       }
[08:28:19.490]                     }
[08:28:19.490]                     sendCondition <<- function(cond) NULL
[08:28:19.490]                   }
[08:28:19.490]                 })
[08:28:19.490]                 withCallingHandlers({
[08:28:19.490]                   {
[08:28:19.490]                     x <- x()
[08:28:19.490]                     x
[08:28:19.490]                   }
[08:28:19.490]                 }, immediateCondition = function(cond) {
[08:28:19.490]                   sendCondition <- ...future.makeSendCondition()
[08:28:19.490]                   sendCondition(cond)
[08:28:19.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.490]                   {
[08:28:19.490]                     inherits <- base::inherits
[08:28:19.490]                     invokeRestart <- base::invokeRestart
[08:28:19.490]                     is.null <- base::is.null
[08:28:19.490]                     muffled <- FALSE
[08:28:19.490]                     if (inherits(cond, "message")) {
[08:28:19.490]                       muffled <- grepl(pattern, "muffleMessage")
[08:28:19.490]                       if (muffled) 
[08:28:19.490]                         invokeRestart("muffleMessage")
[08:28:19.490]                     }
[08:28:19.490]                     else if (inherits(cond, "warning")) {
[08:28:19.490]                       muffled <- grepl(pattern, "muffleWarning")
[08:28:19.490]                       if (muffled) 
[08:28:19.490]                         invokeRestart("muffleWarning")
[08:28:19.490]                     }
[08:28:19.490]                     else if (inherits(cond, "condition")) {
[08:28:19.490]                       if (!is.null(pattern)) {
[08:28:19.490]                         computeRestarts <- base::computeRestarts
[08:28:19.490]                         grepl <- base::grepl
[08:28:19.490]                         restarts <- computeRestarts(cond)
[08:28:19.490]                         for (restart in restarts) {
[08:28:19.490]                           name <- restart$name
[08:28:19.490]                           if (is.null(name)) 
[08:28:19.490]                             next
[08:28:19.490]                           if (!grepl(pattern, name)) 
[08:28:19.490]                             next
[08:28:19.490]                           invokeRestart(restart)
[08:28:19.490]                           muffled <- TRUE
[08:28:19.490]                           break
[08:28:19.490]                         }
[08:28:19.490]                       }
[08:28:19.490]                     }
[08:28:19.490]                     invisible(muffled)
[08:28:19.490]                   }
[08:28:19.490]                   muffleCondition(cond)
[08:28:19.490]                 })
[08:28:19.490]             }))
[08:28:19.490]             future::FutureResult(value = ...future.value$value, 
[08:28:19.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.490]                   ...future.rng), globalenv = if (FALSE) 
[08:28:19.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[08:28:19.490]                     ...future.globalenv.names))
[08:28:19.490]                 else NULL, started = ...future.startTime, version = "1.8")
[08:28:19.490]         }, condition = base::local({
[08:28:19.490]             c <- base::c
[08:28:19.490]             inherits <- base::inherits
[08:28:19.490]             invokeRestart <- base::invokeRestart
[08:28:19.490]             length <- base::length
[08:28:19.490]             list <- base::list
[08:28:19.490]             seq.int <- base::seq.int
[08:28:19.490]             signalCondition <- base::signalCondition
[08:28:19.490]             sys.calls <- base::sys.calls
[08:28:19.490]             `[[` <- base::`[[`
[08:28:19.490]             `+` <- base::`+`
[08:28:19.490]             `<<-` <- base::`<<-`
[08:28:19.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[08:28:19.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[08:28:19.490]                   3L)]
[08:28:19.490]             }
[08:28:19.490]             function(cond) {
[08:28:19.490]                 is_error <- inherits(cond, "error")
[08:28:19.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[08:28:19.490]                   NULL)
[08:28:19.490]                 if (is_error) {
[08:28:19.490]                   sessionInformation <- function() {
[08:28:19.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[08:28:19.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[08:28:19.490]                       search = base::search(), system = base::Sys.info())
[08:28:19.490]                   }
[08:28:19.490]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[08:28:19.490]                     cond$call), session = sessionInformation(), 
[08:28:19.490]                     timestamp = base::Sys.time(), signaled = 0L)
[08:28:19.490]                   signalCondition(cond)
[08:28:19.490]                 }
[08:28:19.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[08:28:19.490]                 "immediateCondition"))) {
[08:28:19.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[08:28:19.490]                   ...future.conditions[[length(...future.conditions) + 
[08:28:19.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[08:28:19.490]                   if (TRUE && !signal) {
[08:28:19.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.490]                     {
[08:28:19.490]                       inherits <- base::inherits
[08:28:19.490]                       invokeRestart <- base::invokeRestart
[08:28:19.490]                       is.null <- base::is.null
[08:28:19.490]                       muffled <- FALSE
[08:28:19.490]                       if (inherits(cond, "message")) {
[08:28:19.490]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.490]                         if (muffled) 
[08:28:19.490]                           invokeRestart("muffleMessage")
[08:28:19.490]                       }
[08:28:19.490]                       else if (inherits(cond, "warning")) {
[08:28:19.490]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.490]                         if (muffled) 
[08:28:19.490]                           invokeRestart("muffleWarning")
[08:28:19.490]                       }
[08:28:19.490]                       else if (inherits(cond, "condition")) {
[08:28:19.490]                         if (!is.null(pattern)) {
[08:28:19.490]                           computeRestarts <- base::computeRestarts
[08:28:19.490]                           grepl <- base::grepl
[08:28:19.490]                           restarts <- computeRestarts(cond)
[08:28:19.490]                           for (restart in restarts) {
[08:28:19.490]                             name <- restart$name
[08:28:19.490]                             if (is.null(name)) 
[08:28:19.490]                               next
[08:28:19.490]                             if (!grepl(pattern, name)) 
[08:28:19.490]                               next
[08:28:19.490]                             invokeRestart(restart)
[08:28:19.490]                             muffled <- TRUE
[08:28:19.490]                             break
[08:28:19.490]                           }
[08:28:19.490]                         }
[08:28:19.490]                       }
[08:28:19.490]                       invisible(muffled)
[08:28:19.490]                     }
[08:28:19.490]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.490]                   }
[08:28:19.490]                 }
[08:28:19.490]                 else {
[08:28:19.490]                   if (TRUE) {
[08:28:19.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[08:28:19.490]                     {
[08:28:19.490]                       inherits <- base::inherits
[08:28:19.490]                       invokeRestart <- base::invokeRestart
[08:28:19.490]                       is.null <- base::is.null
[08:28:19.490]                       muffled <- FALSE
[08:28:19.490]                       if (inherits(cond, "message")) {
[08:28:19.490]                         muffled <- grepl(pattern, "muffleMessage")
[08:28:19.490]                         if (muffled) 
[08:28:19.490]                           invokeRestart("muffleMessage")
[08:28:19.490]                       }
[08:28:19.490]                       else if (inherits(cond, "warning")) {
[08:28:19.490]                         muffled <- grepl(pattern, "muffleWarning")
[08:28:19.490]                         if (muffled) 
[08:28:19.490]                           invokeRestart("muffleWarning")
[08:28:19.490]                       }
[08:28:19.490]                       else if (inherits(cond, "condition")) {
[08:28:19.490]                         if (!is.null(pattern)) {
[08:28:19.490]                           computeRestarts <- base::computeRestarts
[08:28:19.490]                           grepl <- base::grepl
[08:28:19.490]                           restarts <- computeRestarts(cond)
[08:28:19.490]                           for (restart in restarts) {
[08:28:19.490]                             name <- restart$name
[08:28:19.490]                             if (is.null(name)) 
[08:28:19.490]                               next
[08:28:19.490]                             if (!grepl(pattern, name)) 
[08:28:19.490]                               next
[08:28:19.490]                             invokeRestart(restart)
[08:28:19.490]                             muffled <- TRUE
[08:28:19.490]                             break
[08:28:19.490]                           }
[08:28:19.490]                         }
[08:28:19.490]                       }
[08:28:19.490]                       invisible(muffled)
[08:28:19.490]                     }
[08:28:19.490]                     muffleCondition(cond, pattern = "^muffle")
[08:28:19.490]                   }
[08:28:19.490]                 }
[08:28:19.490]             }
[08:28:19.490]         }))
[08:28:19.490]     }, error = function(ex) {
[08:28:19.490]         base::structure(base::list(value = NULL, visible = NULL, 
[08:28:19.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[08:28:19.490]                 ...future.rng), started = ...future.startTime, 
[08:28:19.490]             finished = Sys.time(), session_uuid = NA_character_, 
[08:28:19.490]             version = "1.8"), class = "FutureResult")
[08:28:19.490]     }, finally = {
[08:28:19.490]         if (!identical(...future.workdir, getwd())) 
[08:28:19.490]             setwd(...future.workdir)
[08:28:19.490]         {
[08:28:19.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[08:28:19.490]                 ...future.oldOptions$nwarnings <- NULL
[08:28:19.490]             }
[08:28:19.490]             base::options(...future.oldOptions)
[08:28:19.490]             if (.Platform$OS.type == "windows") {
[08:28:19.490]                 old_names <- names(...future.oldEnvVars)
[08:28:19.490]                 envs <- base::Sys.getenv()
[08:28:19.490]                 names <- names(envs)
[08:28:19.490]                 common <- intersect(names, old_names)
[08:28:19.490]                 added <- setdiff(names, old_names)
[08:28:19.490]                 removed <- setdiff(old_names, names)
[08:28:19.490]                 changed <- common[...future.oldEnvVars[common] != 
[08:28:19.490]                   envs[common]]
[08:28:19.490]                 NAMES <- toupper(changed)
[08:28:19.490]                 args <- list()
[08:28:19.490]                 for (kk in seq_along(NAMES)) {
[08:28:19.490]                   name <- changed[[kk]]
[08:28:19.490]                   NAME <- NAMES[[kk]]
[08:28:19.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.490]                     next
[08:28:19.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.490]                 }
[08:28:19.490]                 NAMES <- toupper(added)
[08:28:19.490]                 for (kk in seq_along(NAMES)) {
[08:28:19.490]                   name <- added[[kk]]
[08:28:19.490]                   NAME <- NAMES[[kk]]
[08:28:19.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.490]                     next
[08:28:19.490]                   args[[name]] <- ""
[08:28:19.490]                 }
[08:28:19.490]                 NAMES <- toupper(removed)
[08:28:19.490]                 for (kk in seq_along(NAMES)) {
[08:28:19.490]                   name <- removed[[kk]]
[08:28:19.490]                   NAME <- NAMES[[kk]]
[08:28:19.490]                   if (name != NAME && is.element(NAME, old_names)) 
[08:28:19.490]                     next
[08:28:19.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[08:28:19.490]                 }
[08:28:19.490]                 if (length(args) > 0) 
[08:28:19.490]                   base::do.call(base::Sys.setenv, args = args)
[08:28:19.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[08:28:19.490]             }
[08:28:19.490]             else {
[08:28:19.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[08:28:19.490]             }
[08:28:19.490]             {
[08:28:19.490]                 if (base::length(...future.futureOptionsAdded) > 
[08:28:19.490]                   0L) {
[08:28:19.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[08:28:19.490]                   base::names(opts) <- ...future.futureOptionsAdded
[08:28:19.490]                   base::options(opts)
[08:28:19.490]                 }
[08:28:19.490]                 {
[08:28:19.490]                   {
[08:28:19.490]                     base::options(mc.cores = ...future.mc.cores.old)
[08:28:19.490]                     NULL
[08:28:19.490]                   }
[08:28:19.490]                   options(future.plan = NULL)
[08:28:19.490]                   if (is.na(NA_character_)) 
[08:28:19.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[08:28:19.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[08:28:19.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[08:28:19.490]                     .init = FALSE)
[08:28:19.490]                 }
[08:28:19.490]             }
[08:28:19.490]         }
[08:28:19.490]     })
[08:28:19.490]     if (TRUE) {
[08:28:19.490]         base::sink(type = "output", split = FALSE)
[08:28:19.490]         if (TRUE) {
[08:28:19.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[08:28:19.490]         }
[08:28:19.490]         else {
[08:28:19.490]             ...future.result["stdout"] <- base::list(NULL)
[08:28:19.490]         }
[08:28:19.490]         base::close(...future.stdout)
[08:28:19.490]         ...future.stdout <- NULL
[08:28:19.490]     }
[08:28:19.490]     ...future.result$conditions <- ...future.conditions
[08:28:19.490]     ...future.result$finished <- base::Sys.time()
[08:28:19.490]     ...future.result
[08:28:19.490] }
[08:28:19.494] Exporting 1 global objects (554 bytes) to cluster node #1 ...
[08:28:19.494] Exporting ‘x’ (260 bytes) to cluster node #1 ...
[08:28:19.495] Exporting ‘x’ (260 bytes) to cluster node #1 ... DONE
[08:28:19.495] Exporting 1 global objects (554 bytes) to cluster node #1 ... DONE
[08:28:19.496] MultisessionFuture started
[08:28:19.496] - Launch lazy future ... done
[08:28:19.496] run() for ‘MultisessionFuture’ ... done
[08:28:19.496] result() for ClusterFuture ...
[08:28:19.496] receiveMessageFromWorker() for ClusterFuture ...
[08:28:19.497] - Validating connection of MultisessionFuture
[08:28:19.538] - received message: FutureResult
[08:28:19.538] - Received FutureResult
[08:28:19.538] - Erased future from FutureRegistry
[08:28:19.538] result() for ClusterFuture ...
[08:28:19.538] - result already collected: FutureResult
[08:28:19.539] result() for ClusterFuture ... done
[08:28:19.539] receiveMessageFromWorker() for ClusterFuture ... done
[08:28:19.539] result() for ClusterFuture ... done
[08:28:19.539] result() for ClusterFuture ...
[08:28:19.539] - result already collected: FutureResult
[08:28:19.539] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[08:28:19.540] plan(): Setting new future strategy stack:
[08:28:19.540] List of future strategies:
[08:28:19.540] 1. FutureStrategy:
[08:28:19.540]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[08:28:19.540]    - tweaked: FALSE
[08:28:19.540]    - call: future::plan(oplan)
[08:28:19.541] plan(): nbrOfWorkers() = 1
> 
