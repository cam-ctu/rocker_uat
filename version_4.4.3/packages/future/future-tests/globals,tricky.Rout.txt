
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[11:01:51.687] plan(): Setting new future strategy stack:
[11:01:51.688] List of future strategies:
[11:01:51.688] 1. sequential:
[11:01:51.688]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.688]    - tweaked: FALSE
[11:01:51.688]    - call: future::plan("sequential")
[11:01:51.701] plan(): nbrOfWorkers() = 1
> library("listenv")
> oopts <- c(oopts, options(
+   future.globals.resolve = TRUE,
+   future.globals.onMissing = "error"
+ ))
> 
> message("*** Tricky use cases related to globals ...")
*** Tricky use cases related to globals ...
> 
> for (cores in 1:availCores) {
+   ## Speed up CRAN checks: Skip on CRAN Windows 32-bit
+   if (!fullTest && isWin32) next
+   
+   message(sprintf("Testing with %d cores ...", cores))
+   options(mc.cores = cores)
+ 
+   message("availableCores(): ", availableCores())
+ 
+   message("- Local variables with the same name as globals ...")
+ 
+   for (strategy in supportedStrategies(cores)) {
+     message(sprintf("- plan('%s') ...", strategy))
+     plan(strategy)
+ 
+     methods <- c("conservative", "ordered")
+     for (method in methods) {
+       options(future.globals.method = method)
+       message(sprintf("Method for identifying globals: '%s' ...", method))
+ 
+       a <- 3
+ 
+       yTruth <- local({
+         b <- a
+         a <- 2
+         a * b
+       })
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       }
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       a <- 3
+ 
+       y %<-% {
+         b <- a
+         a <- 2
+         a * b
+       } %lazy% TRUE
+ 
+       rm(list = "a")
+ 
+       res <- try(y, silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         message(sprintf("y = %g", y))
+         stopifnot(identical(y, yTruth))
+       }
+ 
+ 
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         }
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative" && strategy %in% c("multisession", "cluster")) {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Same with forced lazy evaluation
+       res <- listenv()
+       a <- 1
+       for (ii in 1:3) {
+         res[[ii]] %<-% {
+           b <- a * ii
+           a <- 0
+           b
+         } %lazy% TRUE
+       }
+       rm(list = "a")
+ 
+       res <- try(unlist(res), silent = TRUE)
+       if (method == "conservative") {
+         str(list(res = res))
+         stopifnot(inherits(res, "try-error"))
+       } else {
+         print(res)
+         stopifnot(all(res == 1:3))
+       }
+ 
+ 
+       ## Assert that `a` is resolved and turned into a constant future
+       ## at the moment when future `b` is created.
+       ## Requires options(future.globals.resolve = TRUE).
+       a <- future(1)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+       a <- future(1, lazy = TRUE)
+       b <- future(value(a) + 1, lazy = TRUE)
+       rm(list = "a")
+       message(sprintf("value(b) = %g", value(b)))
+       stopifnot(value(b) == 2)
+ 
+ 
+       ## BUG FIX: In future (<= 1.0.0) a global 'pkg' would be
+       ## overwritten by the name of the last package attached
+       ## by the future.
+       pkg <- "foo"
+       f <- sequential({ pkg })
+       v <- value(f)
+       message(sprintf("value(f) = %s", sQuote(v)))
+       stopifnot(pkg == "foo", v == "foo")
+       
+       message(sprintf("Method for identifying globals: '%s' ... DONE", method))
+     }
+ 
+     ## BUG FIX: In globals (<= 0.10.3) a global 'x' in LHS of an assignment
+     ## would be missed.
+     options(future.globals.method = "ordered")
+ 
+     ## A local
+     x <- 1
+     f <- future({ x <- 0; x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 1)
+     
+     ## A global
+     x <- 1
+     f <- future({ x <- x + 1; x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == 2)
+ 
+     ## A global
+     x <- function() TRUE
+     f <- future({ x <- x(); x })
+     v <- value(f)
+     message(sprintf("value(f) = %s", sQuote(v)))
+     stopifnot(v == TRUE)
+   } ## for (strategy ...)
+ 
+   message(sprintf("Testing with %d cores ... DONE", cores))
+ } ## for (cores ...)
Testing with 1 cores ...
availableCores(): 1
- Local variables with the same name as globals ...
- plan('sequential') ...
[11:01:51.792] plan(): Setting new future strategy stack:
[11:01:51.792] List of future strategies:
[11:01:51.792] 1. sequential:
[11:01:51.792]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.792]    - tweaked: FALSE
[11:01:51.792]    - call: plan(strategy)
[11:01:51.804] plan(): nbrOfWorkers() = 1
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.805] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.806] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.811] - globals found: [3] ‘{’, ‘<-’, ‘*’
[11:01:51.811] Searching for globals ... DONE
[11:01:51.811] Resolving globals: TRUE
[11:01:51.811] Resolving any globals that are futures ...
[11:01:51.811] - globals: [3] ‘{’, ‘<-’, ‘*’
[11:01:51.811] Resolving any globals that are futures ... DONE
[11:01:51.812] 
[11:01:51.812] 
[11:01:51.812] getGlobalsAndPackages() ... DONE
[11:01:51.813] run() for ‘Future’ ...
[11:01:51.813] - state: ‘created’
[11:01:51.813] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.813] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.813] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.813]   - Field: ‘label’
[11:01:51.814]   - Field: ‘local’
[11:01:51.814]   - Field: ‘owner’
[11:01:51.814]   - Field: ‘envir’
[11:01:51.814]   - Field: ‘packages’
[11:01:51.814]   - Field: ‘gc’
[11:01:51.814]   - Field: ‘conditions’
[11:01:51.814]   - Field: ‘expr’
[11:01:51.814]   - Field: ‘uuid’
[11:01:51.814]   - Field: ‘seed’
[11:01:51.814]   - Field: ‘version’
[11:01:51.814]   - Field: ‘result’
[11:01:51.814]   - Field: ‘asynchronous’
[11:01:51.814]   - Field: ‘calls’
[11:01:51.815]   - Field: ‘globals’
[11:01:51.815]   - Field: ‘stdout’
[11:01:51.815]   - Field: ‘earlySignal’
[11:01:51.815]   - Field: ‘lazy’
[11:01:51.815]   - Field: ‘state’
[11:01:51.815] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.815] - Launch lazy future ...
[11:01:51.816] Packages needed by the future expression (n = 0): <none>
[11:01:51.816] Packages needed by future strategies (n = 0): <none>
[11:01:51.816] {
[11:01:51.816]     {
[11:01:51.816]         {
[11:01:51.816]             ...future.startTime <- base::Sys.time()
[11:01:51.816]             {
[11:01:51.816]                 {
[11:01:51.816]                   {
[11:01:51.816]                     base::local({
[11:01:51.816]                       has_future <- base::requireNamespace("future", 
[11:01:51.816]                         quietly = TRUE)
[11:01:51.816]                       if (has_future) {
[11:01:51.816]                         ns <- base::getNamespace("future")
[11:01:51.816]                         version <- ns[[".package"]][["version"]]
[11:01:51.816]                         if (is.null(version)) 
[11:01:51.816]                           version <- utils::packageVersion("future")
[11:01:51.816]                       }
[11:01:51.816]                       else {
[11:01:51.816]                         version <- NULL
[11:01:51.816]                       }
[11:01:51.816]                       if (!has_future || version < "1.8.0") {
[11:01:51.816]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.816]                           "", base::R.version$version.string), 
[11:01:51.816]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.816]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.816]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.816]                             "release", "version")], collapse = " "), 
[11:01:51.816]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.816]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.816]                           info)
[11:01:51.816]                         info <- base::paste(info, collapse = "; ")
[11:01:51.816]                         if (!has_future) {
[11:01:51.816]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.816]                             info)
[11:01:51.816]                         }
[11:01:51.816]                         else {
[11:01:51.816]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.816]                             info, version)
[11:01:51.816]                         }
[11:01:51.816]                         base::stop(msg)
[11:01:51.816]                       }
[11:01:51.816]                     })
[11:01:51.816]                   }
[11:01:51.816]                   ...future.strategy.old <- future::plan("list")
[11:01:51.816]                   options(future.plan = NULL)
[11:01:51.816]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.816]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.816]                 }
[11:01:51.816]                 ...future.workdir <- getwd()
[11:01:51.816]             }
[11:01:51.816]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.816]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.816]         }
[11:01:51.816]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.816]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.816]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.816]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.816]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.816]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.816]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.816]             base::names(...future.oldOptions))
[11:01:51.816]     }
[11:01:51.816]     if (FALSE) {
[11:01:51.816]     }
[11:01:51.816]     else {
[11:01:51.816]         if (TRUE) {
[11:01:51.816]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.816]                 open = "w")
[11:01:51.816]         }
[11:01:51.816]         else {
[11:01:51.816]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.816]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.816]         }
[11:01:51.816]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.816]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.816]             base::sink(type = "output", split = FALSE)
[11:01:51.816]             base::close(...future.stdout)
[11:01:51.816]         }, add = TRUE)
[11:01:51.816]     }
[11:01:51.816]     ...future.frame <- base::sys.nframe()
[11:01:51.816]     ...future.conditions <- base::list()
[11:01:51.816]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.816]     if (FALSE) {
[11:01:51.816]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.816]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.816]     }
[11:01:51.816]     ...future.result <- base::tryCatch({
[11:01:51.816]         base::withCallingHandlers({
[11:01:51.816]             ...future.value <- base::withVisible(base::local({
[11:01:51.816]                 b <- a
[11:01:51.816]                 a <- 2
[11:01:51.816]                 a * b
[11:01:51.816]             }))
[11:01:51.816]             future::FutureResult(value = ...future.value$value, 
[11:01:51.816]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.816]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.816]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.816]                     ...future.globalenv.names))
[11:01:51.816]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.816]         }, condition = base::local({
[11:01:51.816]             c <- base::c
[11:01:51.816]             inherits <- base::inherits
[11:01:51.816]             invokeRestart <- base::invokeRestart
[11:01:51.816]             length <- base::length
[11:01:51.816]             list <- base::list
[11:01:51.816]             seq.int <- base::seq.int
[11:01:51.816]             signalCondition <- base::signalCondition
[11:01:51.816]             sys.calls <- base::sys.calls
[11:01:51.816]             `[[` <- base::`[[`
[11:01:51.816]             `+` <- base::`+`
[11:01:51.816]             `<<-` <- base::`<<-`
[11:01:51.816]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.816]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.816]                   3L)]
[11:01:51.816]             }
[11:01:51.816]             function(cond) {
[11:01:51.816]                 is_error <- inherits(cond, "error")
[11:01:51.816]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.816]                   NULL)
[11:01:51.816]                 if (is_error) {
[11:01:51.816]                   sessionInformation <- function() {
[11:01:51.816]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.816]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.816]                       search = base::search(), system = base::Sys.info())
[11:01:51.816]                   }
[11:01:51.816]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.816]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.816]                     cond$call), session = sessionInformation(), 
[11:01:51.816]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.816]                   signalCondition(cond)
[11:01:51.816]                 }
[11:01:51.816]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.816]                 "immediateCondition"))) {
[11:01:51.816]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.816]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.816]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.816]                   if (TRUE && !signal) {
[11:01:51.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.816]                     {
[11:01:51.816]                       inherits <- base::inherits
[11:01:51.816]                       invokeRestart <- base::invokeRestart
[11:01:51.816]                       is.null <- base::is.null
[11:01:51.816]                       muffled <- FALSE
[11:01:51.816]                       if (inherits(cond, "message")) {
[11:01:51.816]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.816]                         if (muffled) 
[11:01:51.816]                           invokeRestart("muffleMessage")
[11:01:51.816]                       }
[11:01:51.816]                       else if (inherits(cond, "warning")) {
[11:01:51.816]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.816]                         if (muffled) 
[11:01:51.816]                           invokeRestart("muffleWarning")
[11:01:51.816]                       }
[11:01:51.816]                       else if (inherits(cond, "condition")) {
[11:01:51.816]                         if (!is.null(pattern)) {
[11:01:51.816]                           computeRestarts <- base::computeRestarts
[11:01:51.816]                           grepl <- base::grepl
[11:01:51.816]                           restarts <- computeRestarts(cond)
[11:01:51.816]                           for (restart in restarts) {
[11:01:51.816]                             name <- restart$name
[11:01:51.816]                             if (is.null(name)) 
[11:01:51.816]                               next
[11:01:51.816]                             if (!grepl(pattern, name)) 
[11:01:51.816]                               next
[11:01:51.816]                             invokeRestart(restart)
[11:01:51.816]                             muffled <- TRUE
[11:01:51.816]                             break
[11:01:51.816]                           }
[11:01:51.816]                         }
[11:01:51.816]                       }
[11:01:51.816]                       invisible(muffled)
[11:01:51.816]                     }
[11:01:51.816]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.816]                   }
[11:01:51.816]                 }
[11:01:51.816]                 else {
[11:01:51.816]                   if (TRUE) {
[11:01:51.816]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.816]                     {
[11:01:51.816]                       inherits <- base::inherits
[11:01:51.816]                       invokeRestart <- base::invokeRestart
[11:01:51.816]                       is.null <- base::is.null
[11:01:51.816]                       muffled <- FALSE
[11:01:51.816]                       if (inherits(cond, "message")) {
[11:01:51.816]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.816]                         if (muffled) 
[11:01:51.816]                           invokeRestart("muffleMessage")
[11:01:51.816]                       }
[11:01:51.816]                       else if (inherits(cond, "warning")) {
[11:01:51.816]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.816]                         if (muffled) 
[11:01:51.816]                           invokeRestart("muffleWarning")
[11:01:51.816]                       }
[11:01:51.816]                       else if (inherits(cond, "condition")) {
[11:01:51.816]                         if (!is.null(pattern)) {
[11:01:51.816]                           computeRestarts <- base::computeRestarts
[11:01:51.816]                           grepl <- base::grepl
[11:01:51.816]                           restarts <- computeRestarts(cond)
[11:01:51.816]                           for (restart in restarts) {
[11:01:51.816]                             name <- restart$name
[11:01:51.816]                             if (is.null(name)) 
[11:01:51.816]                               next
[11:01:51.816]                             if (!grepl(pattern, name)) 
[11:01:51.816]                               next
[11:01:51.816]                             invokeRestart(restart)
[11:01:51.816]                             muffled <- TRUE
[11:01:51.816]                             break
[11:01:51.816]                           }
[11:01:51.816]                         }
[11:01:51.816]                       }
[11:01:51.816]                       invisible(muffled)
[11:01:51.816]                     }
[11:01:51.816]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.816]                   }
[11:01:51.816]                 }
[11:01:51.816]             }
[11:01:51.816]         }))
[11:01:51.816]     }, error = function(ex) {
[11:01:51.816]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.816]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.816]                 ...future.rng), started = ...future.startTime, 
[11:01:51.816]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.816]             version = "1.8"), class = "FutureResult")
[11:01:51.816]     }, finally = {
[11:01:51.816]         if (!identical(...future.workdir, getwd())) 
[11:01:51.816]             setwd(...future.workdir)
[11:01:51.816]         {
[11:01:51.816]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.816]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.816]             }
[11:01:51.816]             base::options(...future.oldOptions)
[11:01:51.816]             if (.Platform$OS.type == "windows") {
[11:01:51.816]                 old_names <- names(...future.oldEnvVars)
[11:01:51.816]                 envs <- base::Sys.getenv()
[11:01:51.816]                 names <- names(envs)
[11:01:51.816]                 common <- intersect(names, old_names)
[11:01:51.816]                 added <- setdiff(names, old_names)
[11:01:51.816]                 removed <- setdiff(old_names, names)
[11:01:51.816]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.816]                   envs[common]]
[11:01:51.816]                 NAMES <- toupper(changed)
[11:01:51.816]                 args <- list()
[11:01:51.816]                 for (kk in seq_along(NAMES)) {
[11:01:51.816]                   name <- changed[[kk]]
[11:01:51.816]                   NAME <- NAMES[[kk]]
[11:01:51.816]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.816]                     next
[11:01:51.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.816]                 }
[11:01:51.816]                 NAMES <- toupper(added)
[11:01:51.816]                 for (kk in seq_along(NAMES)) {
[11:01:51.816]                   name <- added[[kk]]
[11:01:51.816]                   NAME <- NAMES[[kk]]
[11:01:51.816]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.816]                     next
[11:01:51.816]                   args[[name]] <- ""
[11:01:51.816]                 }
[11:01:51.816]                 NAMES <- toupper(removed)
[11:01:51.816]                 for (kk in seq_along(NAMES)) {
[11:01:51.816]                   name <- removed[[kk]]
[11:01:51.816]                   NAME <- NAMES[[kk]]
[11:01:51.816]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.816]                     next
[11:01:51.816]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.816]                 }
[11:01:51.816]                 if (length(args) > 0) 
[11:01:51.816]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.816]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.816]             }
[11:01:51.816]             else {
[11:01:51.816]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.816]             }
[11:01:51.816]             {
[11:01:51.816]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.816]                   0L) {
[11:01:51.816]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.816]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.816]                   base::options(opts)
[11:01:51.816]                 }
[11:01:51.816]                 {
[11:01:51.816]                   {
[11:01:51.816]                     NULL
[11:01:51.816]                     RNGkind("Mersenne-Twister")
[11:01:51.816]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.816]                       inherits = FALSE)
[11:01:51.816]                   }
[11:01:51.816]                   options(future.plan = NULL)
[11:01:51.816]                   if (is.na(NA_character_)) 
[11:01:51.816]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.816]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.816]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.816]                     .init = FALSE)
[11:01:51.816]                 }
[11:01:51.816]             }
[11:01:51.816]         }
[11:01:51.816]     })
[11:01:51.816]     if (TRUE) {
[11:01:51.816]         base::sink(type = "output", split = FALSE)
[11:01:51.816]         if (TRUE) {
[11:01:51.816]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.816]         }
[11:01:51.816]         else {
[11:01:51.816]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.816]         }
[11:01:51.816]         base::close(...future.stdout)
[11:01:51.816]         ...future.stdout <- NULL
[11:01:51.816]     }
[11:01:51.816]     ...future.result$conditions <- ...future.conditions
[11:01:51.816]     ...future.result$finished <- base::Sys.time()
[11:01:51.816]     ...future.result
[11:01:51.816] }
[11:01:51.818] plan(): Setting new future strategy stack:
[11:01:51.818] List of future strategies:
[11:01:51.818] 1. sequential:
[11:01:51.818]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.818]    - tweaked: FALSE
[11:01:51.818]    - call: NULL
[11:01:51.819] plan(): nbrOfWorkers() = 1
[11:01:51.820] plan(): Setting new future strategy stack:
[11:01:51.820] List of future strategies:
[11:01:51.820] 1. sequential:
[11:01:51.820]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.820]    - tweaked: FALSE
[11:01:51.820]    - call: plan(strategy)
[11:01:51.820] plan(): nbrOfWorkers() = 1
[11:01:51.821] SequentialFuture started (and completed)
[11:01:51.821] - Launch lazy future ... done
[11:01:51.821] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.822] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.822] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.823] - globals found: [3] ‘{’, ‘<-’, ‘*’
[11:01:51.823] Searching for globals ... DONE
[11:01:51.823] Resolving globals: TRUE
[11:01:51.823] Resolving any globals that are futures ...
[11:01:51.823] - globals: [3] ‘{’, ‘<-’, ‘*’
[11:01:51.823] Resolving any globals that are futures ... DONE
[11:01:51.824] 
[11:01:51.824] 
[11:01:51.824] getGlobalsAndPackages() ... DONE
[11:01:51.824] run() for ‘Future’ ...
[11:01:51.824] - state: ‘created’
[11:01:51.826] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.826] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.826] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.826]   - Field: ‘label’
[11:01:51.826]   - Field: ‘local’
[11:01:51.826]   - Field: ‘owner’
[11:01:51.826]   - Field: ‘envir’
[11:01:51.827]   - Field: ‘packages’
[11:01:51.827]   - Field: ‘gc’
[11:01:51.827]   - Field: ‘conditions’
[11:01:51.827]   - Field: ‘expr’
[11:01:51.827]   - Field: ‘uuid’
[11:01:51.827]   - Field: ‘seed’
[11:01:51.827]   - Field: ‘version’
[11:01:51.827]   - Field: ‘result’
[11:01:51.827]   - Field: ‘asynchronous’
[11:01:51.827]   - Field: ‘calls’
[11:01:51.827]   - Field: ‘globals’
[11:01:51.827]   - Field: ‘stdout’
[11:01:51.827]   - Field: ‘earlySignal’
[11:01:51.828]   - Field: ‘lazy’
[11:01:51.828]   - Field: ‘state’
[11:01:51.828] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.828] - Launch lazy future ...
[11:01:51.828] Packages needed by the future expression (n = 0): <none>
[11:01:51.828] Packages needed by future strategies (n = 0): <none>
[11:01:51.828] {
[11:01:51.828]     {
[11:01:51.828]         {
[11:01:51.828]             ...future.startTime <- base::Sys.time()
[11:01:51.828]             {
[11:01:51.828]                 {
[11:01:51.828]                   {
[11:01:51.828]                     base::local({
[11:01:51.828]                       has_future <- base::requireNamespace("future", 
[11:01:51.828]                         quietly = TRUE)
[11:01:51.828]                       if (has_future) {
[11:01:51.828]                         ns <- base::getNamespace("future")
[11:01:51.828]                         version <- ns[[".package"]][["version"]]
[11:01:51.828]                         if (is.null(version)) 
[11:01:51.828]                           version <- utils::packageVersion("future")
[11:01:51.828]                       }
[11:01:51.828]                       else {
[11:01:51.828]                         version <- NULL
[11:01:51.828]                       }
[11:01:51.828]                       if (!has_future || version < "1.8.0") {
[11:01:51.828]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.828]                           "", base::R.version$version.string), 
[11:01:51.828]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.828]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.828]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.828]                             "release", "version")], collapse = " "), 
[11:01:51.828]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.828]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.828]                           info)
[11:01:51.828]                         info <- base::paste(info, collapse = "; ")
[11:01:51.828]                         if (!has_future) {
[11:01:51.828]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.828]                             info)
[11:01:51.828]                         }
[11:01:51.828]                         else {
[11:01:51.828]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.828]                             info, version)
[11:01:51.828]                         }
[11:01:51.828]                         base::stop(msg)
[11:01:51.828]                       }
[11:01:51.828]                     })
[11:01:51.828]                   }
[11:01:51.828]                   ...future.strategy.old <- future::plan("list")
[11:01:51.828]                   options(future.plan = NULL)
[11:01:51.828]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.828]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.828]                 }
[11:01:51.828]                 ...future.workdir <- getwd()
[11:01:51.828]             }
[11:01:51.828]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.828]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.828]         }
[11:01:51.828]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.828]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.828]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.828]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.828]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.828]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.828]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.828]             base::names(...future.oldOptions))
[11:01:51.828]     }
[11:01:51.828]     if (FALSE) {
[11:01:51.828]     }
[11:01:51.828]     else {
[11:01:51.828]         if (TRUE) {
[11:01:51.828]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.828]                 open = "w")
[11:01:51.828]         }
[11:01:51.828]         else {
[11:01:51.828]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.828]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.828]         }
[11:01:51.828]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.828]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.828]             base::sink(type = "output", split = FALSE)
[11:01:51.828]             base::close(...future.stdout)
[11:01:51.828]         }, add = TRUE)
[11:01:51.828]     }
[11:01:51.828]     ...future.frame <- base::sys.nframe()
[11:01:51.828]     ...future.conditions <- base::list()
[11:01:51.828]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.828]     if (FALSE) {
[11:01:51.828]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.828]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.828]     }
[11:01:51.828]     ...future.result <- base::tryCatch({
[11:01:51.828]         base::withCallingHandlers({
[11:01:51.828]             ...future.value <- base::withVisible(base::local({
[11:01:51.828]                 b <- a
[11:01:51.828]                 a <- 2
[11:01:51.828]                 a * b
[11:01:51.828]             }))
[11:01:51.828]             future::FutureResult(value = ...future.value$value, 
[11:01:51.828]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.828]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.828]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.828]                     ...future.globalenv.names))
[11:01:51.828]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.828]         }, condition = base::local({
[11:01:51.828]             c <- base::c
[11:01:51.828]             inherits <- base::inherits
[11:01:51.828]             invokeRestart <- base::invokeRestart
[11:01:51.828]             length <- base::length
[11:01:51.828]             list <- base::list
[11:01:51.828]             seq.int <- base::seq.int
[11:01:51.828]             signalCondition <- base::signalCondition
[11:01:51.828]             sys.calls <- base::sys.calls
[11:01:51.828]             `[[` <- base::`[[`
[11:01:51.828]             `+` <- base::`+`
[11:01:51.828]             `<<-` <- base::`<<-`
[11:01:51.828]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.828]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.828]                   3L)]
[11:01:51.828]             }
[11:01:51.828]             function(cond) {
[11:01:51.828]                 is_error <- inherits(cond, "error")
[11:01:51.828]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.828]                   NULL)
[11:01:51.828]                 if (is_error) {
[11:01:51.828]                   sessionInformation <- function() {
[11:01:51.828]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.828]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.828]                       search = base::search(), system = base::Sys.info())
[11:01:51.828]                   }
[11:01:51.828]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.828]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.828]                     cond$call), session = sessionInformation(), 
[11:01:51.828]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.828]                   signalCondition(cond)
[11:01:51.828]                 }
[11:01:51.828]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.828]                 "immediateCondition"))) {
[11:01:51.828]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.828]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.828]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.828]                   if (TRUE && !signal) {
[11:01:51.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.828]                     {
[11:01:51.828]                       inherits <- base::inherits
[11:01:51.828]                       invokeRestart <- base::invokeRestart
[11:01:51.828]                       is.null <- base::is.null
[11:01:51.828]                       muffled <- FALSE
[11:01:51.828]                       if (inherits(cond, "message")) {
[11:01:51.828]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.828]                         if (muffled) 
[11:01:51.828]                           invokeRestart("muffleMessage")
[11:01:51.828]                       }
[11:01:51.828]                       else if (inherits(cond, "warning")) {
[11:01:51.828]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.828]                         if (muffled) 
[11:01:51.828]                           invokeRestart("muffleWarning")
[11:01:51.828]                       }
[11:01:51.828]                       else if (inherits(cond, "condition")) {
[11:01:51.828]                         if (!is.null(pattern)) {
[11:01:51.828]                           computeRestarts <- base::computeRestarts
[11:01:51.828]                           grepl <- base::grepl
[11:01:51.828]                           restarts <- computeRestarts(cond)
[11:01:51.828]                           for (restart in restarts) {
[11:01:51.828]                             name <- restart$name
[11:01:51.828]                             if (is.null(name)) 
[11:01:51.828]                               next
[11:01:51.828]                             if (!grepl(pattern, name)) 
[11:01:51.828]                               next
[11:01:51.828]                             invokeRestart(restart)
[11:01:51.828]                             muffled <- TRUE
[11:01:51.828]                             break
[11:01:51.828]                           }
[11:01:51.828]                         }
[11:01:51.828]                       }
[11:01:51.828]                       invisible(muffled)
[11:01:51.828]                     }
[11:01:51.828]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.828]                   }
[11:01:51.828]                 }
[11:01:51.828]                 else {
[11:01:51.828]                   if (TRUE) {
[11:01:51.828]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.828]                     {
[11:01:51.828]                       inherits <- base::inherits
[11:01:51.828]                       invokeRestart <- base::invokeRestart
[11:01:51.828]                       is.null <- base::is.null
[11:01:51.828]                       muffled <- FALSE
[11:01:51.828]                       if (inherits(cond, "message")) {
[11:01:51.828]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.828]                         if (muffled) 
[11:01:51.828]                           invokeRestart("muffleMessage")
[11:01:51.828]                       }
[11:01:51.828]                       else if (inherits(cond, "warning")) {
[11:01:51.828]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.828]                         if (muffled) 
[11:01:51.828]                           invokeRestart("muffleWarning")
[11:01:51.828]                       }
[11:01:51.828]                       else if (inherits(cond, "condition")) {
[11:01:51.828]                         if (!is.null(pattern)) {
[11:01:51.828]                           computeRestarts <- base::computeRestarts
[11:01:51.828]                           grepl <- base::grepl
[11:01:51.828]                           restarts <- computeRestarts(cond)
[11:01:51.828]                           for (restart in restarts) {
[11:01:51.828]                             name <- restart$name
[11:01:51.828]                             if (is.null(name)) 
[11:01:51.828]                               next
[11:01:51.828]                             if (!grepl(pattern, name)) 
[11:01:51.828]                               next
[11:01:51.828]                             invokeRestart(restart)
[11:01:51.828]                             muffled <- TRUE
[11:01:51.828]                             break
[11:01:51.828]                           }
[11:01:51.828]                         }
[11:01:51.828]                       }
[11:01:51.828]                       invisible(muffled)
[11:01:51.828]                     }
[11:01:51.828]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.828]                   }
[11:01:51.828]                 }
[11:01:51.828]             }
[11:01:51.828]         }))
[11:01:51.828]     }, error = function(ex) {
[11:01:51.828]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.828]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.828]                 ...future.rng), started = ...future.startTime, 
[11:01:51.828]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.828]             version = "1.8"), class = "FutureResult")
[11:01:51.828]     }, finally = {
[11:01:51.828]         if (!identical(...future.workdir, getwd())) 
[11:01:51.828]             setwd(...future.workdir)
[11:01:51.828]         {
[11:01:51.828]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.828]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.828]             }
[11:01:51.828]             base::options(...future.oldOptions)
[11:01:51.828]             if (.Platform$OS.type == "windows") {
[11:01:51.828]                 old_names <- names(...future.oldEnvVars)
[11:01:51.828]                 envs <- base::Sys.getenv()
[11:01:51.828]                 names <- names(envs)
[11:01:51.828]                 common <- intersect(names, old_names)
[11:01:51.828]                 added <- setdiff(names, old_names)
[11:01:51.828]                 removed <- setdiff(old_names, names)
[11:01:51.828]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.828]                   envs[common]]
[11:01:51.828]                 NAMES <- toupper(changed)
[11:01:51.828]                 args <- list()
[11:01:51.828]                 for (kk in seq_along(NAMES)) {
[11:01:51.828]                   name <- changed[[kk]]
[11:01:51.828]                   NAME <- NAMES[[kk]]
[11:01:51.828]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.828]                     next
[11:01:51.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.828]                 }
[11:01:51.828]                 NAMES <- toupper(added)
[11:01:51.828]                 for (kk in seq_along(NAMES)) {
[11:01:51.828]                   name <- added[[kk]]
[11:01:51.828]                   NAME <- NAMES[[kk]]
[11:01:51.828]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.828]                     next
[11:01:51.828]                   args[[name]] <- ""
[11:01:51.828]                 }
[11:01:51.828]                 NAMES <- toupper(removed)
[11:01:51.828]                 for (kk in seq_along(NAMES)) {
[11:01:51.828]                   name <- removed[[kk]]
[11:01:51.828]                   NAME <- NAMES[[kk]]
[11:01:51.828]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.828]                     next
[11:01:51.828]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.828]                 }
[11:01:51.828]                 if (length(args) > 0) 
[11:01:51.828]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.828]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.828]             }
[11:01:51.828]             else {
[11:01:51.828]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.828]             }
[11:01:51.828]             {
[11:01:51.828]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.828]                   0L) {
[11:01:51.828]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.828]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.828]                   base::options(opts)
[11:01:51.828]                 }
[11:01:51.828]                 {
[11:01:51.828]                   {
[11:01:51.828]                     NULL
[11:01:51.828]                     RNGkind("Mersenne-Twister")
[11:01:51.828]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.828]                       inherits = FALSE)
[11:01:51.828]                   }
[11:01:51.828]                   options(future.plan = NULL)
[11:01:51.828]                   if (is.na(NA_character_)) 
[11:01:51.828]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.828]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.828]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.828]                     .init = FALSE)
[11:01:51.828]                 }
[11:01:51.828]             }
[11:01:51.828]         }
[11:01:51.828]     })
[11:01:51.828]     if (TRUE) {
[11:01:51.828]         base::sink(type = "output", split = FALSE)
[11:01:51.828]         if (TRUE) {
[11:01:51.828]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.828]         }
[11:01:51.828]         else {
[11:01:51.828]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.828]         }
[11:01:51.828]         base::close(...future.stdout)
[11:01:51.828]         ...future.stdout <- NULL
[11:01:51.828]     }
[11:01:51.828]     ...future.result$conditions <- ...future.conditions
[11:01:51.828]     ...future.result$finished <- base::Sys.time()
[11:01:51.828]     ...future.result
[11:01:51.828] }
[11:01:51.830] plan(): Setting new future strategy stack:
[11:01:51.830] List of future strategies:
[11:01:51.830] 1. sequential:
[11:01:51.830]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.830]    - tweaked: FALSE
[11:01:51.830]    - call: NULL
[11:01:51.831] plan(): nbrOfWorkers() = 1
[11:01:51.832] plan(): Setting new future strategy stack:
[11:01:51.832] List of future strategies:
[11:01:51.832] 1. sequential:
[11:01:51.832]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.832]    - tweaked: FALSE
[11:01:51.832]    - call: plan(strategy)
[11:01:51.832] plan(): nbrOfWorkers() = 1
[11:01:51.832] SequentialFuture started (and completed)
[11:01:51.832] signalConditions() ...
[11:01:51.832]  - include = ‘immediateCondition’
[11:01:51.832]  - exclude = 
[11:01:51.833]  - resignal = FALSE
[11:01:51.833]  - Number of conditions: 1
[11:01:51.833] signalConditions() ... done
[11:01:51.833] - Launch lazy future ... done
[11:01:51.833] run() for ‘SequentialFuture’ ... done
[11:01:51.833] signalConditions() ...
[11:01:51.833]  - include = ‘immediateCondition’
[11:01:51.833]  - exclude = 
[11:01:51.833]  - resignal = FALSE
[11:01:51.833]  - Number of conditions: 1
[11:01:51.833] signalConditions() ... done
[11:01:51.833] Future state: ‘finished’
[11:01:51.834] signalConditions() ...
[11:01:51.834]  - include = ‘condition’
[11:01:51.834]  - exclude = ‘immediateCondition’
[11:01:51.834]  - resignal = TRUE
[11:01:51.834]  - Number of conditions: 1
[11:01:51.834]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:51.834] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. .. ..$ : language eval(quote({     b <- a ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:51"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.848] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.848] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.849] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.849] Searching for globals ... DONE
[11:01:51.849] Resolving globals: TRUE
[11:01:51.850] Resolving any globals that are futures ...
[11:01:51.850] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.850] Resolving any globals that are futures ... DONE
[11:01:51.850] Resolving futures part of globals (recursively) ...
[11:01:51.851] resolve() on list ...
[11:01:51.851]  recursive: 99
[11:01:51.851]  length: 1
[11:01:51.851]  elements: ‘ii’
[11:01:51.851]  length: 0 (resolved future 1)
[11:01:51.851] resolve() on list ... DONE
[11:01:51.851] - globals: [1] ‘ii’
[11:01:51.853] Resolving futures part of globals (recursively) ... DONE
[11:01:51.853] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:51.854] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:51.854] - globals: [1] ‘ii’
[11:01:51.854] 
[11:01:51.854] getGlobalsAndPackages() ... DONE
[11:01:51.854] run() for ‘Future’ ...
[11:01:51.854] - state: ‘created’
[11:01:51.854] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.855] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.855] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.855]   - Field: ‘label’
[11:01:51.855]   - Field: ‘local’
[11:01:51.855]   - Field: ‘owner’
[11:01:51.855]   - Field: ‘envir’
[11:01:51.855]   - Field: ‘packages’
[11:01:51.855]   - Field: ‘gc’
[11:01:51.855]   - Field: ‘conditions’
[11:01:51.855]   - Field: ‘expr’
[11:01:51.855]   - Field: ‘uuid’
[11:01:51.856]   - Field: ‘seed’
[11:01:51.856]   - Field: ‘version’
[11:01:51.856]   - Field: ‘result’
[11:01:51.856]   - Field: ‘asynchronous’
[11:01:51.856]   - Field: ‘calls’
[11:01:51.856]   - Field: ‘globals’
[11:01:51.856]   - Field: ‘stdout’
[11:01:51.856]   - Field: ‘earlySignal’
[11:01:51.856]   - Field: ‘lazy’
[11:01:51.856]   - Field: ‘state’
[11:01:51.856] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.856] - Launch lazy future ...
[11:01:51.857] Packages needed by the future expression (n = 0): <none>
[11:01:51.857] Packages needed by future strategies (n = 0): <none>
[11:01:51.857] {
[11:01:51.857]     {
[11:01:51.857]         {
[11:01:51.857]             ...future.startTime <- base::Sys.time()
[11:01:51.857]             {
[11:01:51.857]                 {
[11:01:51.857]                   {
[11:01:51.857]                     base::local({
[11:01:51.857]                       has_future <- base::requireNamespace("future", 
[11:01:51.857]                         quietly = TRUE)
[11:01:51.857]                       if (has_future) {
[11:01:51.857]                         ns <- base::getNamespace("future")
[11:01:51.857]                         version <- ns[[".package"]][["version"]]
[11:01:51.857]                         if (is.null(version)) 
[11:01:51.857]                           version <- utils::packageVersion("future")
[11:01:51.857]                       }
[11:01:51.857]                       else {
[11:01:51.857]                         version <- NULL
[11:01:51.857]                       }
[11:01:51.857]                       if (!has_future || version < "1.8.0") {
[11:01:51.857]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.857]                           "", base::R.version$version.string), 
[11:01:51.857]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.857]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.857]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.857]                             "release", "version")], collapse = " "), 
[11:01:51.857]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.857]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.857]                           info)
[11:01:51.857]                         info <- base::paste(info, collapse = "; ")
[11:01:51.857]                         if (!has_future) {
[11:01:51.857]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.857]                             info)
[11:01:51.857]                         }
[11:01:51.857]                         else {
[11:01:51.857]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.857]                             info, version)
[11:01:51.857]                         }
[11:01:51.857]                         base::stop(msg)
[11:01:51.857]                       }
[11:01:51.857]                     })
[11:01:51.857]                   }
[11:01:51.857]                   ...future.strategy.old <- future::plan("list")
[11:01:51.857]                   options(future.plan = NULL)
[11:01:51.857]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.857]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.857]                 }
[11:01:51.857]                 ...future.workdir <- getwd()
[11:01:51.857]             }
[11:01:51.857]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.857]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.857]         }
[11:01:51.857]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.857]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.857]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.857]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.857]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.857]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.857]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.857]             base::names(...future.oldOptions))
[11:01:51.857]     }
[11:01:51.857]     if (FALSE) {
[11:01:51.857]     }
[11:01:51.857]     else {
[11:01:51.857]         if (TRUE) {
[11:01:51.857]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.857]                 open = "w")
[11:01:51.857]         }
[11:01:51.857]         else {
[11:01:51.857]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.857]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.857]         }
[11:01:51.857]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.857]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.857]             base::sink(type = "output", split = FALSE)
[11:01:51.857]             base::close(...future.stdout)
[11:01:51.857]         }, add = TRUE)
[11:01:51.857]     }
[11:01:51.857]     ...future.frame <- base::sys.nframe()
[11:01:51.857]     ...future.conditions <- base::list()
[11:01:51.857]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.857]     if (FALSE) {
[11:01:51.857]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.857]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.857]     }
[11:01:51.857]     ...future.result <- base::tryCatch({
[11:01:51.857]         base::withCallingHandlers({
[11:01:51.857]             ...future.value <- base::withVisible(base::local({
[11:01:51.857]                 b <- a * ii
[11:01:51.857]                 a <- 0
[11:01:51.857]                 b
[11:01:51.857]             }))
[11:01:51.857]             future::FutureResult(value = ...future.value$value, 
[11:01:51.857]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.857]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.857]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.857]                     ...future.globalenv.names))
[11:01:51.857]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.857]         }, condition = base::local({
[11:01:51.857]             c <- base::c
[11:01:51.857]             inherits <- base::inherits
[11:01:51.857]             invokeRestart <- base::invokeRestart
[11:01:51.857]             length <- base::length
[11:01:51.857]             list <- base::list
[11:01:51.857]             seq.int <- base::seq.int
[11:01:51.857]             signalCondition <- base::signalCondition
[11:01:51.857]             sys.calls <- base::sys.calls
[11:01:51.857]             `[[` <- base::`[[`
[11:01:51.857]             `+` <- base::`+`
[11:01:51.857]             `<<-` <- base::`<<-`
[11:01:51.857]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.857]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.857]                   3L)]
[11:01:51.857]             }
[11:01:51.857]             function(cond) {
[11:01:51.857]                 is_error <- inherits(cond, "error")
[11:01:51.857]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.857]                   NULL)
[11:01:51.857]                 if (is_error) {
[11:01:51.857]                   sessionInformation <- function() {
[11:01:51.857]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.857]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.857]                       search = base::search(), system = base::Sys.info())
[11:01:51.857]                   }
[11:01:51.857]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.857]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.857]                     cond$call), session = sessionInformation(), 
[11:01:51.857]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.857]                   signalCondition(cond)
[11:01:51.857]                 }
[11:01:51.857]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.857]                 "immediateCondition"))) {
[11:01:51.857]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.857]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.857]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.857]                   if (TRUE && !signal) {
[11:01:51.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.857]                     {
[11:01:51.857]                       inherits <- base::inherits
[11:01:51.857]                       invokeRestart <- base::invokeRestart
[11:01:51.857]                       is.null <- base::is.null
[11:01:51.857]                       muffled <- FALSE
[11:01:51.857]                       if (inherits(cond, "message")) {
[11:01:51.857]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.857]                         if (muffled) 
[11:01:51.857]                           invokeRestart("muffleMessage")
[11:01:51.857]                       }
[11:01:51.857]                       else if (inherits(cond, "warning")) {
[11:01:51.857]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.857]                         if (muffled) 
[11:01:51.857]                           invokeRestart("muffleWarning")
[11:01:51.857]                       }
[11:01:51.857]                       else if (inherits(cond, "condition")) {
[11:01:51.857]                         if (!is.null(pattern)) {
[11:01:51.857]                           computeRestarts <- base::computeRestarts
[11:01:51.857]                           grepl <- base::grepl
[11:01:51.857]                           restarts <- computeRestarts(cond)
[11:01:51.857]                           for (restart in restarts) {
[11:01:51.857]                             name <- restart$name
[11:01:51.857]                             if (is.null(name)) 
[11:01:51.857]                               next
[11:01:51.857]                             if (!grepl(pattern, name)) 
[11:01:51.857]                               next
[11:01:51.857]                             invokeRestart(restart)
[11:01:51.857]                             muffled <- TRUE
[11:01:51.857]                             break
[11:01:51.857]                           }
[11:01:51.857]                         }
[11:01:51.857]                       }
[11:01:51.857]                       invisible(muffled)
[11:01:51.857]                     }
[11:01:51.857]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.857]                   }
[11:01:51.857]                 }
[11:01:51.857]                 else {
[11:01:51.857]                   if (TRUE) {
[11:01:51.857]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.857]                     {
[11:01:51.857]                       inherits <- base::inherits
[11:01:51.857]                       invokeRestart <- base::invokeRestart
[11:01:51.857]                       is.null <- base::is.null
[11:01:51.857]                       muffled <- FALSE
[11:01:51.857]                       if (inherits(cond, "message")) {
[11:01:51.857]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.857]                         if (muffled) 
[11:01:51.857]                           invokeRestart("muffleMessage")
[11:01:51.857]                       }
[11:01:51.857]                       else if (inherits(cond, "warning")) {
[11:01:51.857]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.857]                         if (muffled) 
[11:01:51.857]                           invokeRestart("muffleWarning")
[11:01:51.857]                       }
[11:01:51.857]                       else if (inherits(cond, "condition")) {
[11:01:51.857]                         if (!is.null(pattern)) {
[11:01:51.857]                           computeRestarts <- base::computeRestarts
[11:01:51.857]                           grepl <- base::grepl
[11:01:51.857]                           restarts <- computeRestarts(cond)
[11:01:51.857]                           for (restart in restarts) {
[11:01:51.857]                             name <- restart$name
[11:01:51.857]                             if (is.null(name)) 
[11:01:51.857]                               next
[11:01:51.857]                             if (!grepl(pattern, name)) 
[11:01:51.857]                               next
[11:01:51.857]                             invokeRestart(restart)
[11:01:51.857]                             muffled <- TRUE
[11:01:51.857]                             break
[11:01:51.857]                           }
[11:01:51.857]                         }
[11:01:51.857]                       }
[11:01:51.857]                       invisible(muffled)
[11:01:51.857]                     }
[11:01:51.857]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.857]                   }
[11:01:51.857]                 }
[11:01:51.857]             }
[11:01:51.857]         }))
[11:01:51.857]     }, error = function(ex) {
[11:01:51.857]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.857]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.857]                 ...future.rng), started = ...future.startTime, 
[11:01:51.857]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.857]             version = "1.8"), class = "FutureResult")
[11:01:51.857]     }, finally = {
[11:01:51.857]         if (!identical(...future.workdir, getwd())) 
[11:01:51.857]             setwd(...future.workdir)
[11:01:51.857]         {
[11:01:51.857]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.857]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.857]             }
[11:01:51.857]             base::options(...future.oldOptions)
[11:01:51.857]             if (.Platform$OS.type == "windows") {
[11:01:51.857]                 old_names <- names(...future.oldEnvVars)
[11:01:51.857]                 envs <- base::Sys.getenv()
[11:01:51.857]                 names <- names(envs)
[11:01:51.857]                 common <- intersect(names, old_names)
[11:01:51.857]                 added <- setdiff(names, old_names)
[11:01:51.857]                 removed <- setdiff(old_names, names)
[11:01:51.857]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.857]                   envs[common]]
[11:01:51.857]                 NAMES <- toupper(changed)
[11:01:51.857]                 args <- list()
[11:01:51.857]                 for (kk in seq_along(NAMES)) {
[11:01:51.857]                   name <- changed[[kk]]
[11:01:51.857]                   NAME <- NAMES[[kk]]
[11:01:51.857]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.857]                     next
[11:01:51.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.857]                 }
[11:01:51.857]                 NAMES <- toupper(added)
[11:01:51.857]                 for (kk in seq_along(NAMES)) {
[11:01:51.857]                   name <- added[[kk]]
[11:01:51.857]                   NAME <- NAMES[[kk]]
[11:01:51.857]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.857]                     next
[11:01:51.857]                   args[[name]] <- ""
[11:01:51.857]                 }
[11:01:51.857]                 NAMES <- toupper(removed)
[11:01:51.857]                 for (kk in seq_along(NAMES)) {
[11:01:51.857]                   name <- removed[[kk]]
[11:01:51.857]                   NAME <- NAMES[[kk]]
[11:01:51.857]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.857]                     next
[11:01:51.857]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.857]                 }
[11:01:51.857]                 if (length(args) > 0) 
[11:01:51.857]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.857]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.857]             }
[11:01:51.857]             else {
[11:01:51.857]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.857]             }
[11:01:51.857]             {
[11:01:51.857]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.857]                   0L) {
[11:01:51.857]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.857]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.857]                   base::options(opts)
[11:01:51.857]                 }
[11:01:51.857]                 {
[11:01:51.857]                   {
[11:01:51.857]                     NULL
[11:01:51.857]                     RNGkind("Mersenne-Twister")
[11:01:51.857]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.857]                       inherits = FALSE)
[11:01:51.857]                   }
[11:01:51.857]                   options(future.plan = NULL)
[11:01:51.857]                   if (is.na(NA_character_)) 
[11:01:51.857]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.857]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.857]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.857]                     .init = FALSE)
[11:01:51.857]                 }
[11:01:51.857]             }
[11:01:51.857]         }
[11:01:51.857]     })
[11:01:51.857]     if (TRUE) {
[11:01:51.857]         base::sink(type = "output", split = FALSE)
[11:01:51.857]         if (TRUE) {
[11:01:51.857]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.857]         }
[11:01:51.857]         else {
[11:01:51.857]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.857]         }
[11:01:51.857]         base::close(...future.stdout)
[11:01:51.857]         ...future.stdout <- NULL
[11:01:51.857]     }
[11:01:51.857]     ...future.result$conditions <- ...future.conditions
[11:01:51.857]     ...future.result$finished <- base::Sys.time()
[11:01:51.857]     ...future.result
[11:01:51.857] }
[11:01:51.859] assign_globals() ...
[11:01:51.859] List of 1
[11:01:51.859]  $ ii: int 1
[11:01:51.859]  - attr(*, "where")=List of 1
[11:01:51.859]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:51.859]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:51.859]  - attr(*, "resolved")= logi TRUE
[11:01:51.859]  - attr(*, "total_size")= num 35
[11:01:51.859]  - attr(*, "already-done")= logi TRUE
[11:01:51.861] - copied ‘ii’ to environment
[11:01:51.862] assign_globals() ... done
[11:01:51.862] plan(): Setting new future strategy stack:
[11:01:51.862] List of future strategies:
[11:01:51.862] 1. sequential:
[11:01:51.862]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.862]    - tweaked: FALSE
[11:01:51.862]    - call: NULL
[11:01:51.862] plan(): nbrOfWorkers() = 1
[11:01:51.863] plan(): Setting new future strategy stack:
[11:01:51.863] List of future strategies:
[11:01:51.863] 1. sequential:
[11:01:51.863]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.863]    - tweaked: FALSE
[11:01:51.863]    - call: plan(strategy)
[11:01:51.864] plan(): nbrOfWorkers() = 1
[11:01:51.864] SequentialFuture started (and completed)
[11:01:51.864] - Launch lazy future ... done
[11:01:51.864] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.864] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.865] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.866] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.866] Searching for globals ... DONE
[11:01:51.866] Resolving globals: TRUE
[11:01:51.866] Resolving any globals that are futures ...
[11:01:51.866] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.866] Resolving any globals that are futures ... DONE
[11:01:51.867] Resolving futures part of globals (recursively) ...
[11:01:51.867] resolve() on list ...
[11:01:51.867]  recursive: 99
[11:01:51.867]  length: 1
[11:01:51.867]  elements: ‘ii’
[11:01:51.867]  length: 0 (resolved future 1)
[11:01:51.867] resolve() on list ... DONE
[11:01:51.867] - globals: [1] ‘ii’
[11:01:51.868] Resolving futures part of globals (recursively) ... DONE
[11:01:51.868] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:51.868] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:51.868] - globals: [1] ‘ii’
[11:01:51.868] 
[11:01:51.868] getGlobalsAndPackages() ... DONE
[11:01:51.869] run() for ‘Future’ ...
[11:01:51.869] - state: ‘created’
[11:01:51.869] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.869] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.869] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.869]   - Field: ‘label’
[11:01:51.869]   - Field: ‘local’
[11:01:51.869]   - Field: ‘owner’
[11:01:51.869]   - Field: ‘envir’
[11:01:51.870]   - Field: ‘packages’
[11:01:51.870]   - Field: ‘gc’
[11:01:51.870]   - Field: ‘conditions’
[11:01:51.870]   - Field: ‘expr’
[11:01:51.870]   - Field: ‘uuid’
[11:01:51.870]   - Field: ‘seed’
[11:01:51.870]   - Field: ‘version’
[11:01:51.870]   - Field: ‘result’
[11:01:51.870]   - Field: ‘asynchronous’
[11:01:51.870]   - Field: ‘calls’
[11:01:51.870]   - Field: ‘globals’
[11:01:51.870]   - Field: ‘stdout’
[11:01:51.871]   - Field: ‘earlySignal’
[11:01:51.871]   - Field: ‘lazy’
[11:01:51.871]   - Field: ‘state’
[11:01:51.871] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.871] - Launch lazy future ...
[11:01:51.871] Packages needed by the future expression (n = 0): <none>
[11:01:51.871] Packages needed by future strategies (n = 0): <none>
[11:01:51.872] {
[11:01:51.872]     {
[11:01:51.872]         {
[11:01:51.872]             ...future.startTime <- base::Sys.time()
[11:01:51.872]             {
[11:01:51.872]                 {
[11:01:51.872]                   {
[11:01:51.872]                     base::local({
[11:01:51.872]                       has_future <- base::requireNamespace("future", 
[11:01:51.872]                         quietly = TRUE)
[11:01:51.872]                       if (has_future) {
[11:01:51.872]                         ns <- base::getNamespace("future")
[11:01:51.872]                         version <- ns[[".package"]][["version"]]
[11:01:51.872]                         if (is.null(version)) 
[11:01:51.872]                           version <- utils::packageVersion("future")
[11:01:51.872]                       }
[11:01:51.872]                       else {
[11:01:51.872]                         version <- NULL
[11:01:51.872]                       }
[11:01:51.872]                       if (!has_future || version < "1.8.0") {
[11:01:51.872]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.872]                           "", base::R.version$version.string), 
[11:01:51.872]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.872]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.872]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.872]                             "release", "version")], collapse = " "), 
[11:01:51.872]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.872]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.872]                           info)
[11:01:51.872]                         info <- base::paste(info, collapse = "; ")
[11:01:51.872]                         if (!has_future) {
[11:01:51.872]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.872]                             info)
[11:01:51.872]                         }
[11:01:51.872]                         else {
[11:01:51.872]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.872]                             info, version)
[11:01:51.872]                         }
[11:01:51.872]                         base::stop(msg)
[11:01:51.872]                       }
[11:01:51.872]                     })
[11:01:51.872]                   }
[11:01:51.872]                   ...future.strategy.old <- future::plan("list")
[11:01:51.872]                   options(future.plan = NULL)
[11:01:51.872]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.872]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.872]                 }
[11:01:51.872]                 ...future.workdir <- getwd()
[11:01:51.872]             }
[11:01:51.872]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.872]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.872]         }
[11:01:51.872]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.872]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.872]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.872]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.872]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.872]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.872]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.872]             base::names(...future.oldOptions))
[11:01:51.872]     }
[11:01:51.872]     if (FALSE) {
[11:01:51.872]     }
[11:01:51.872]     else {
[11:01:51.872]         if (TRUE) {
[11:01:51.872]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.872]                 open = "w")
[11:01:51.872]         }
[11:01:51.872]         else {
[11:01:51.872]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.872]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.872]         }
[11:01:51.872]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.872]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.872]             base::sink(type = "output", split = FALSE)
[11:01:51.872]             base::close(...future.stdout)
[11:01:51.872]         }, add = TRUE)
[11:01:51.872]     }
[11:01:51.872]     ...future.frame <- base::sys.nframe()
[11:01:51.872]     ...future.conditions <- base::list()
[11:01:51.872]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.872]     if (FALSE) {
[11:01:51.872]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.872]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.872]     }
[11:01:51.872]     ...future.result <- base::tryCatch({
[11:01:51.872]         base::withCallingHandlers({
[11:01:51.872]             ...future.value <- base::withVisible(base::local({
[11:01:51.872]                 b <- a * ii
[11:01:51.872]                 a <- 0
[11:01:51.872]                 b
[11:01:51.872]             }))
[11:01:51.872]             future::FutureResult(value = ...future.value$value, 
[11:01:51.872]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.872]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.872]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.872]                     ...future.globalenv.names))
[11:01:51.872]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.872]         }, condition = base::local({
[11:01:51.872]             c <- base::c
[11:01:51.872]             inherits <- base::inherits
[11:01:51.872]             invokeRestart <- base::invokeRestart
[11:01:51.872]             length <- base::length
[11:01:51.872]             list <- base::list
[11:01:51.872]             seq.int <- base::seq.int
[11:01:51.872]             signalCondition <- base::signalCondition
[11:01:51.872]             sys.calls <- base::sys.calls
[11:01:51.872]             `[[` <- base::`[[`
[11:01:51.872]             `+` <- base::`+`
[11:01:51.872]             `<<-` <- base::`<<-`
[11:01:51.872]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.872]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.872]                   3L)]
[11:01:51.872]             }
[11:01:51.872]             function(cond) {
[11:01:51.872]                 is_error <- inherits(cond, "error")
[11:01:51.872]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.872]                   NULL)
[11:01:51.872]                 if (is_error) {
[11:01:51.872]                   sessionInformation <- function() {
[11:01:51.872]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.872]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.872]                       search = base::search(), system = base::Sys.info())
[11:01:51.872]                   }
[11:01:51.872]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.872]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.872]                     cond$call), session = sessionInformation(), 
[11:01:51.872]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.872]                   signalCondition(cond)
[11:01:51.872]                 }
[11:01:51.872]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.872]                 "immediateCondition"))) {
[11:01:51.872]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.872]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.872]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.872]                   if (TRUE && !signal) {
[11:01:51.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.872]                     {
[11:01:51.872]                       inherits <- base::inherits
[11:01:51.872]                       invokeRestart <- base::invokeRestart
[11:01:51.872]                       is.null <- base::is.null
[11:01:51.872]                       muffled <- FALSE
[11:01:51.872]                       if (inherits(cond, "message")) {
[11:01:51.872]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.872]                         if (muffled) 
[11:01:51.872]                           invokeRestart("muffleMessage")
[11:01:51.872]                       }
[11:01:51.872]                       else if (inherits(cond, "warning")) {
[11:01:51.872]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.872]                         if (muffled) 
[11:01:51.872]                           invokeRestart("muffleWarning")
[11:01:51.872]                       }
[11:01:51.872]                       else if (inherits(cond, "condition")) {
[11:01:51.872]                         if (!is.null(pattern)) {
[11:01:51.872]                           computeRestarts <- base::computeRestarts
[11:01:51.872]                           grepl <- base::grepl
[11:01:51.872]                           restarts <- computeRestarts(cond)
[11:01:51.872]                           for (restart in restarts) {
[11:01:51.872]                             name <- restart$name
[11:01:51.872]                             if (is.null(name)) 
[11:01:51.872]                               next
[11:01:51.872]                             if (!grepl(pattern, name)) 
[11:01:51.872]                               next
[11:01:51.872]                             invokeRestart(restart)
[11:01:51.872]                             muffled <- TRUE
[11:01:51.872]                             break
[11:01:51.872]                           }
[11:01:51.872]                         }
[11:01:51.872]                       }
[11:01:51.872]                       invisible(muffled)
[11:01:51.872]                     }
[11:01:51.872]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.872]                   }
[11:01:51.872]                 }
[11:01:51.872]                 else {
[11:01:51.872]                   if (TRUE) {
[11:01:51.872]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.872]                     {
[11:01:51.872]                       inherits <- base::inherits
[11:01:51.872]                       invokeRestart <- base::invokeRestart
[11:01:51.872]                       is.null <- base::is.null
[11:01:51.872]                       muffled <- FALSE
[11:01:51.872]                       if (inherits(cond, "message")) {
[11:01:51.872]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.872]                         if (muffled) 
[11:01:51.872]                           invokeRestart("muffleMessage")
[11:01:51.872]                       }
[11:01:51.872]                       else if (inherits(cond, "warning")) {
[11:01:51.872]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.872]                         if (muffled) 
[11:01:51.872]                           invokeRestart("muffleWarning")
[11:01:51.872]                       }
[11:01:51.872]                       else if (inherits(cond, "condition")) {
[11:01:51.872]                         if (!is.null(pattern)) {
[11:01:51.872]                           computeRestarts <- base::computeRestarts
[11:01:51.872]                           grepl <- base::grepl
[11:01:51.872]                           restarts <- computeRestarts(cond)
[11:01:51.872]                           for (restart in restarts) {
[11:01:51.872]                             name <- restart$name
[11:01:51.872]                             if (is.null(name)) 
[11:01:51.872]                               next
[11:01:51.872]                             if (!grepl(pattern, name)) 
[11:01:51.872]                               next
[11:01:51.872]                             invokeRestart(restart)
[11:01:51.872]                             muffled <- TRUE
[11:01:51.872]                             break
[11:01:51.872]                           }
[11:01:51.872]                         }
[11:01:51.872]                       }
[11:01:51.872]                       invisible(muffled)
[11:01:51.872]                     }
[11:01:51.872]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.872]                   }
[11:01:51.872]                 }
[11:01:51.872]             }
[11:01:51.872]         }))
[11:01:51.872]     }, error = function(ex) {
[11:01:51.872]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.872]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.872]                 ...future.rng), started = ...future.startTime, 
[11:01:51.872]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.872]             version = "1.8"), class = "FutureResult")
[11:01:51.872]     }, finally = {
[11:01:51.872]         if (!identical(...future.workdir, getwd())) 
[11:01:51.872]             setwd(...future.workdir)
[11:01:51.872]         {
[11:01:51.872]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.872]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.872]             }
[11:01:51.872]             base::options(...future.oldOptions)
[11:01:51.872]             if (.Platform$OS.type == "windows") {
[11:01:51.872]                 old_names <- names(...future.oldEnvVars)
[11:01:51.872]                 envs <- base::Sys.getenv()
[11:01:51.872]                 names <- names(envs)
[11:01:51.872]                 common <- intersect(names, old_names)
[11:01:51.872]                 added <- setdiff(names, old_names)
[11:01:51.872]                 removed <- setdiff(old_names, names)
[11:01:51.872]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.872]                   envs[common]]
[11:01:51.872]                 NAMES <- toupper(changed)
[11:01:51.872]                 args <- list()
[11:01:51.872]                 for (kk in seq_along(NAMES)) {
[11:01:51.872]                   name <- changed[[kk]]
[11:01:51.872]                   NAME <- NAMES[[kk]]
[11:01:51.872]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.872]                     next
[11:01:51.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.872]                 }
[11:01:51.872]                 NAMES <- toupper(added)
[11:01:51.872]                 for (kk in seq_along(NAMES)) {
[11:01:51.872]                   name <- added[[kk]]
[11:01:51.872]                   NAME <- NAMES[[kk]]
[11:01:51.872]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.872]                     next
[11:01:51.872]                   args[[name]] <- ""
[11:01:51.872]                 }
[11:01:51.872]                 NAMES <- toupper(removed)
[11:01:51.872]                 for (kk in seq_along(NAMES)) {
[11:01:51.872]                   name <- removed[[kk]]
[11:01:51.872]                   NAME <- NAMES[[kk]]
[11:01:51.872]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.872]                     next
[11:01:51.872]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.872]                 }
[11:01:51.872]                 if (length(args) > 0) 
[11:01:51.872]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.872]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.872]             }
[11:01:51.872]             else {
[11:01:51.872]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.872]             }
[11:01:51.872]             {
[11:01:51.872]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.872]                   0L) {
[11:01:51.872]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.872]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.872]                   base::options(opts)
[11:01:51.872]                 }
[11:01:51.872]                 {
[11:01:51.872]                   {
[11:01:51.872]                     NULL
[11:01:51.872]                     RNGkind("Mersenne-Twister")
[11:01:51.872]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.872]                       inherits = FALSE)
[11:01:51.872]                   }
[11:01:51.872]                   options(future.plan = NULL)
[11:01:51.872]                   if (is.na(NA_character_)) 
[11:01:51.872]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.872]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.872]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.872]                     .init = FALSE)
[11:01:51.872]                 }
[11:01:51.872]             }
[11:01:51.872]         }
[11:01:51.872]     })
[11:01:51.872]     if (TRUE) {
[11:01:51.872]         base::sink(type = "output", split = FALSE)
[11:01:51.872]         if (TRUE) {
[11:01:51.872]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.872]         }
[11:01:51.872]         else {
[11:01:51.872]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.872]         }
[11:01:51.872]         base::close(...future.stdout)
[11:01:51.872]         ...future.stdout <- NULL
[11:01:51.872]     }
[11:01:51.872]     ...future.result$conditions <- ...future.conditions
[11:01:51.872]     ...future.result$finished <- base::Sys.time()
[11:01:51.872]     ...future.result
[11:01:51.872] }
[11:01:51.873] assign_globals() ...
[11:01:51.873] List of 1
[11:01:51.873]  $ ii: int 2
[11:01:51.873]  - attr(*, "where")=List of 1
[11:01:51.873]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:51.873]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:51.873]  - attr(*, "resolved")= logi TRUE
[11:01:51.873]  - attr(*, "total_size")= num 35
[11:01:51.873]  - attr(*, "already-done")= logi TRUE
[11:01:51.876] - copied ‘ii’ to environment
[11:01:51.876] assign_globals() ... done
[11:01:51.876] plan(): Setting new future strategy stack:
[11:01:51.876] List of future strategies:
[11:01:51.876] 1. sequential:
[11:01:51.876]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.876]    - tweaked: FALSE
[11:01:51.876]    - call: NULL
[11:01:51.876] plan(): nbrOfWorkers() = 1
[11:01:51.877] plan(): Setting new future strategy stack:
[11:01:51.877] List of future strategies:
[11:01:51.877] 1. sequential:
[11:01:51.877]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.877]    - tweaked: FALSE
[11:01:51.877]    - call: plan(strategy)
[11:01:51.878] plan(): nbrOfWorkers() = 1
[11:01:51.878] SequentialFuture started (and completed)
[11:01:51.878] - Launch lazy future ... done
[11:01:51.878] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.879] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.879] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.882] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.882] Searching for globals ... DONE
[11:01:51.882] Resolving globals: TRUE
[11:01:51.882] Resolving any globals that are futures ...
[11:01:51.882] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.882] Resolving any globals that are futures ... DONE
[11:01:51.882] Resolving futures part of globals (recursively) ...
[11:01:51.883] resolve() on list ...
[11:01:51.883]  recursive: 99
[11:01:51.883]  length: 1
[11:01:51.883]  elements: ‘ii’
[11:01:51.883]  length: 0 (resolved future 1)
[11:01:51.883] resolve() on list ... DONE
[11:01:51.883] - globals: [1] ‘ii’
[11:01:51.883] Resolving futures part of globals (recursively) ... DONE
[11:01:51.883] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:51.884] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:51.884] - globals: [1] ‘ii’
[11:01:51.884] 
[11:01:51.884] getGlobalsAndPackages() ... DONE
[11:01:51.884] run() for ‘Future’ ...
[11:01:51.884] - state: ‘created’
[11:01:51.884] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.885] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.885] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.885]   - Field: ‘label’
[11:01:51.885]   - Field: ‘local’
[11:01:51.885]   - Field: ‘owner’
[11:01:51.885]   - Field: ‘envir’
[11:01:51.885]   - Field: ‘packages’
[11:01:51.885]   - Field: ‘gc’
[11:01:51.885]   - Field: ‘conditions’
[11:01:51.885]   - Field: ‘expr’
[11:01:51.886]   - Field: ‘uuid’
[11:01:51.886]   - Field: ‘seed’
[11:01:51.886]   - Field: ‘version’
[11:01:51.886]   - Field: ‘result’
[11:01:51.886]   - Field: ‘asynchronous’
[11:01:51.886]   - Field: ‘calls’
[11:01:51.886]   - Field: ‘globals’
[11:01:51.886]   - Field: ‘stdout’
[11:01:51.886]   - Field: ‘earlySignal’
[11:01:51.886]   - Field: ‘lazy’
[11:01:51.886]   - Field: ‘state’
[11:01:51.886] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.887] - Launch lazy future ...
[11:01:51.887] Packages needed by the future expression (n = 0): <none>
[11:01:51.887] Packages needed by future strategies (n = 0): <none>
[11:01:51.887] {
[11:01:51.887]     {
[11:01:51.887]         {
[11:01:51.887]             ...future.startTime <- base::Sys.time()
[11:01:51.887]             {
[11:01:51.887]                 {
[11:01:51.887]                   {
[11:01:51.887]                     base::local({
[11:01:51.887]                       has_future <- base::requireNamespace("future", 
[11:01:51.887]                         quietly = TRUE)
[11:01:51.887]                       if (has_future) {
[11:01:51.887]                         ns <- base::getNamespace("future")
[11:01:51.887]                         version <- ns[[".package"]][["version"]]
[11:01:51.887]                         if (is.null(version)) 
[11:01:51.887]                           version <- utils::packageVersion("future")
[11:01:51.887]                       }
[11:01:51.887]                       else {
[11:01:51.887]                         version <- NULL
[11:01:51.887]                       }
[11:01:51.887]                       if (!has_future || version < "1.8.0") {
[11:01:51.887]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.887]                           "", base::R.version$version.string), 
[11:01:51.887]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.887]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.887]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.887]                             "release", "version")], collapse = " "), 
[11:01:51.887]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.887]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.887]                           info)
[11:01:51.887]                         info <- base::paste(info, collapse = "; ")
[11:01:51.887]                         if (!has_future) {
[11:01:51.887]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.887]                             info)
[11:01:51.887]                         }
[11:01:51.887]                         else {
[11:01:51.887]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.887]                             info, version)
[11:01:51.887]                         }
[11:01:51.887]                         base::stop(msg)
[11:01:51.887]                       }
[11:01:51.887]                     })
[11:01:51.887]                   }
[11:01:51.887]                   ...future.strategy.old <- future::plan("list")
[11:01:51.887]                   options(future.plan = NULL)
[11:01:51.887]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.887]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.887]                 }
[11:01:51.887]                 ...future.workdir <- getwd()
[11:01:51.887]             }
[11:01:51.887]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.887]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.887]         }
[11:01:51.887]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.887]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.887]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.887]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.887]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.887]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.887]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.887]             base::names(...future.oldOptions))
[11:01:51.887]     }
[11:01:51.887]     if (FALSE) {
[11:01:51.887]     }
[11:01:51.887]     else {
[11:01:51.887]         if (TRUE) {
[11:01:51.887]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.887]                 open = "w")
[11:01:51.887]         }
[11:01:51.887]         else {
[11:01:51.887]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.887]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.887]         }
[11:01:51.887]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.887]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.887]             base::sink(type = "output", split = FALSE)
[11:01:51.887]             base::close(...future.stdout)
[11:01:51.887]         }, add = TRUE)
[11:01:51.887]     }
[11:01:51.887]     ...future.frame <- base::sys.nframe()
[11:01:51.887]     ...future.conditions <- base::list()
[11:01:51.887]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.887]     if (FALSE) {
[11:01:51.887]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.887]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.887]     }
[11:01:51.887]     ...future.result <- base::tryCatch({
[11:01:51.887]         base::withCallingHandlers({
[11:01:51.887]             ...future.value <- base::withVisible(base::local({
[11:01:51.887]                 b <- a * ii
[11:01:51.887]                 a <- 0
[11:01:51.887]                 b
[11:01:51.887]             }))
[11:01:51.887]             future::FutureResult(value = ...future.value$value, 
[11:01:51.887]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.887]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.887]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.887]                     ...future.globalenv.names))
[11:01:51.887]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.887]         }, condition = base::local({
[11:01:51.887]             c <- base::c
[11:01:51.887]             inherits <- base::inherits
[11:01:51.887]             invokeRestart <- base::invokeRestart
[11:01:51.887]             length <- base::length
[11:01:51.887]             list <- base::list
[11:01:51.887]             seq.int <- base::seq.int
[11:01:51.887]             signalCondition <- base::signalCondition
[11:01:51.887]             sys.calls <- base::sys.calls
[11:01:51.887]             `[[` <- base::`[[`
[11:01:51.887]             `+` <- base::`+`
[11:01:51.887]             `<<-` <- base::`<<-`
[11:01:51.887]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.887]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.887]                   3L)]
[11:01:51.887]             }
[11:01:51.887]             function(cond) {
[11:01:51.887]                 is_error <- inherits(cond, "error")
[11:01:51.887]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.887]                   NULL)
[11:01:51.887]                 if (is_error) {
[11:01:51.887]                   sessionInformation <- function() {
[11:01:51.887]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.887]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.887]                       search = base::search(), system = base::Sys.info())
[11:01:51.887]                   }
[11:01:51.887]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.887]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.887]                     cond$call), session = sessionInformation(), 
[11:01:51.887]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.887]                   signalCondition(cond)
[11:01:51.887]                 }
[11:01:51.887]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.887]                 "immediateCondition"))) {
[11:01:51.887]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.887]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.887]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.887]                   if (TRUE && !signal) {
[11:01:51.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.887]                     {
[11:01:51.887]                       inherits <- base::inherits
[11:01:51.887]                       invokeRestart <- base::invokeRestart
[11:01:51.887]                       is.null <- base::is.null
[11:01:51.887]                       muffled <- FALSE
[11:01:51.887]                       if (inherits(cond, "message")) {
[11:01:51.887]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.887]                         if (muffled) 
[11:01:51.887]                           invokeRestart("muffleMessage")
[11:01:51.887]                       }
[11:01:51.887]                       else if (inherits(cond, "warning")) {
[11:01:51.887]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.887]                         if (muffled) 
[11:01:51.887]                           invokeRestart("muffleWarning")
[11:01:51.887]                       }
[11:01:51.887]                       else if (inherits(cond, "condition")) {
[11:01:51.887]                         if (!is.null(pattern)) {
[11:01:51.887]                           computeRestarts <- base::computeRestarts
[11:01:51.887]                           grepl <- base::grepl
[11:01:51.887]                           restarts <- computeRestarts(cond)
[11:01:51.887]                           for (restart in restarts) {
[11:01:51.887]                             name <- restart$name
[11:01:51.887]                             if (is.null(name)) 
[11:01:51.887]                               next
[11:01:51.887]                             if (!grepl(pattern, name)) 
[11:01:51.887]                               next
[11:01:51.887]                             invokeRestart(restart)
[11:01:51.887]                             muffled <- TRUE
[11:01:51.887]                             break
[11:01:51.887]                           }
[11:01:51.887]                         }
[11:01:51.887]                       }
[11:01:51.887]                       invisible(muffled)
[11:01:51.887]                     }
[11:01:51.887]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.887]                   }
[11:01:51.887]                 }
[11:01:51.887]                 else {
[11:01:51.887]                   if (TRUE) {
[11:01:51.887]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.887]                     {
[11:01:51.887]                       inherits <- base::inherits
[11:01:51.887]                       invokeRestart <- base::invokeRestart
[11:01:51.887]                       is.null <- base::is.null
[11:01:51.887]                       muffled <- FALSE
[11:01:51.887]                       if (inherits(cond, "message")) {
[11:01:51.887]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.887]                         if (muffled) 
[11:01:51.887]                           invokeRestart("muffleMessage")
[11:01:51.887]                       }
[11:01:51.887]                       else if (inherits(cond, "warning")) {
[11:01:51.887]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.887]                         if (muffled) 
[11:01:51.887]                           invokeRestart("muffleWarning")
[11:01:51.887]                       }
[11:01:51.887]                       else if (inherits(cond, "condition")) {
[11:01:51.887]                         if (!is.null(pattern)) {
[11:01:51.887]                           computeRestarts <- base::computeRestarts
[11:01:51.887]                           grepl <- base::grepl
[11:01:51.887]                           restarts <- computeRestarts(cond)
[11:01:51.887]                           for (restart in restarts) {
[11:01:51.887]                             name <- restart$name
[11:01:51.887]                             if (is.null(name)) 
[11:01:51.887]                               next
[11:01:51.887]                             if (!grepl(pattern, name)) 
[11:01:51.887]                               next
[11:01:51.887]                             invokeRestart(restart)
[11:01:51.887]                             muffled <- TRUE
[11:01:51.887]                             break
[11:01:51.887]                           }
[11:01:51.887]                         }
[11:01:51.887]                       }
[11:01:51.887]                       invisible(muffled)
[11:01:51.887]                     }
[11:01:51.887]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.887]                   }
[11:01:51.887]                 }
[11:01:51.887]             }
[11:01:51.887]         }))
[11:01:51.887]     }, error = function(ex) {
[11:01:51.887]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.887]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.887]                 ...future.rng), started = ...future.startTime, 
[11:01:51.887]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.887]             version = "1.8"), class = "FutureResult")
[11:01:51.887]     }, finally = {
[11:01:51.887]         if (!identical(...future.workdir, getwd())) 
[11:01:51.887]             setwd(...future.workdir)
[11:01:51.887]         {
[11:01:51.887]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.887]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.887]             }
[11:01:51.887]             base::options(...future.oldOptions)
[11:01:51.887]             if (.Platform$OS.type == "windows") {
[11:01:51.887]                 old_names <- names(...future.oldEnvVars)
[11:01:51.887]                 envs <- base::Sys.getenv()
[11:01:51.887]                 names <- names(envs)
[11:01:51.887]                 common <- intersect(names, old_names)
[11:01:51.887]                 added <- setdiff(names, old_names)
[11:01:51.887]                 removed <- setdiff(old_names, names)
[11:01:51.887]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.887]                   envs[common]]
[11:01:51.887]                 NAMES <- toupper(changed)
[11:01:51.887]                 args <- list()
[11:01:51.887]                 for (kk in seq_along(NAMES)) {
[11:01:51.887]                   name <- changed[[kk]]
[11:01:51.887]                   NAME <- NAMES[[kk]]
[11:01:51.887]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.887]                     next
[11:01:51.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.887]                 }
[11:01:51.887]                 NAMES <- toupper(added)
[11:01:51.887]                 for (kk in seq_along(NAMES)) {
[11:01:51.887]                   name <- added[[kk]]
[11:01:51.887]                   NAME <- NAMES[[kk]]
[11:01:51.887]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.887]                     next
[11:01:51.887]                   args[[name]] <- ""
[11:01:51.887]                 }
[11:01:51.887]                 NAMES <- toupper(removed)
[11:01:51.887]                 for (kk in seq_along(NAMES)) {
[11:01:51.887]                   name <- removed[[kk]]
[11:01:51.887]                   NAME <- NAMES[[kk]]
[11:01:51.887]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.887]                     next
[11:01:51.887]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.887]                 }
[11:01:51.887]                 if (length(args) > 0) 
[11:01:51.887]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.887]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.887]             }
[11:01:51.887]             else {
[11:01:51.887]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.887]             }
[11:01:51.887]             {
[11:01:51.887]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.887]                   0L) {
[11:01:51.887]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.887]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.887]                   base::options(opts)
[11:01:51.887]                 }
[11:01:51.887]                 {
[11:01:51.887]                   {
[11:01:51.887]                     NULL
[11:01:51.887]                     RNGkind("Mersenne-Twister")
[11:01:51.887]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.887]                       inherits = FALSE)
[11:01:51.887]                   }
[11:01:51.887]                   options(future.plan = NULL)
[11:01:51.887]                   if (is.na(NA_character_)) 
[11:01:51.887]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.887]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.887]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.887]                     .init = FALSE)
[11:01:51.887]                 }
[11:01:51.887]             }
[11:01:51.887]         }
[11:01:51.887]     })
[11:01:51.887]     if (TRUE) {
[11:01:51.887]         base::sink(type = "output", split = FALSE)
[11:01:51.887]         if (TRUE) {
[11:01:51.887]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.887]         }
[11:01:51.887]         else {
[11:01:51.887]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.887]         }
[11:01:51.887]         base::close(...future.stdout)
[11:01:51.887]         ...future.stdout <- NULL
[11:01:51.887]     }
[11:01:51.887]     ...future.result$conditions <- ...future.conditions
[11:01:51.887]     ...future.result$finished <- base::Sys.time()
[11:01:51.887]     ...future.result
[11:01:51.887] }
[11:01:51.889] assign_globals() ...
[11:01:51.889] List of 1
[11:01:51.889]  $ ii: int 3
[11:01:51.889]  - attr(*, "where")=List of 1
[11:01:51.889]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:51.889]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:51.889]  - attr(*, "resolved")= logi TRUE
[11:01:51.889]  - attr(*, "total_size")= num 35
[11:01:51.889]  - attr(*, "already-done")= logi TRUE
[11:01:51.891] - copied ‘ii’ to environment
[11:01:51.891] assign_globals() ... done
[11:01:51.892] plan(): Setting new future strategy stack:
[11:01:51.892] List of future strategies:
[11:01:51.892] 1. sequential:
[11:01:51.892]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.892]    - tweaked: FALSE
[11:01:51.892]    - call: NULL
[11:01:51.892] plan(): nbrOfWorkers() = 1
[11:01:51.893] plan(): Setting new future strategy stack:
[11:01:51.893] List of future strategies:
[11:01:51.893] 1. sequential:
[11:01:51.893]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.893]    - tweaked: FALSE
[11:01:51.893]    - call: plan(strategy)
[11:01:51.893] plan(): nbrOfWorkers() = 1
[11:01:51.894] SequentialFuture started (and completed)
[11:01:51.894] - Launch lazy future ... done
[11:01:51.894] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.895] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.895] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.896] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.896] Searching for globals ... DONE
[11:01:51.896] Resolving globals: TRUE
[11:01:51.896] Resolving any globals that are futures ...
[11:01:51.897] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.897] Resolving any globals that are futures ... DONE
[11:01:51.897] Resolving futures part of globals (recursively) ...
[11:01:51.897] resolve() on list ...
[11:01:51.897]  recursive: 99
[11:01:51.897]  length: 1
[11:01:51.897]  elements: ‘ii’
[11:01:51.898]  length: 0 (resolved future 1)
[11:01:51.898] resolve() on list ... DONE
[11:01:51.898] - globals: [1] ‘ii’
[11:01:51.898] Resolving futures part of globals (recursively) ... DONE
[11:01:51.898] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:51.898] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:51.898] - globals: [1] ‘ii’
[11:01:51.898] 
[11:01:51.899] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.899] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.899] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.900] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.901] Searching for globals ... DONE
[11:01:51.901] Resolving globals: TRUE
[11:01:51.901] Resolving any globals that are futures ...
[11:01:51.901] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.901] Resolving any globals that are futures ... DONE
[11:01:51.901] Resolving futures part of globals (recursively) ...
[11:01:51.901] resolve() on list ...
[11:01:51.902]  recursive: 99
[11:01:51.902]  length: 1
[11:01:51.902]  elements: ‘ii’
[11:01:51.902]  length: 0 (resolved future 1)
[11:01:51.902] resolve() on list ... DONE
[11:01:51.902] - globals: [1] ‘ii’
[11:01:51.902] Resolving futures part of globals (recursively) ... DONE
[11:01:51.902] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:51.902] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:51.903] - globals: [1] ‘ii’
[11:01:51.903] 
[11:01:51.903] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.903] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.903] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.905] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.905] Searching for globals ... DONE
[11:01:51.905] Resolving globals: TRUE
[11:01:51.905] Resolving any globals that are futures ...
[11:01:51.905] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:51.905] Resolving any globals that are futures ... DONE
[11:01:51.907] Resolving futures part of globals (recursively) ...
[11:01:51.907] resolve() on list ...
[11:01:51.907]  recursive: 99
[11:01:51.907]  length: 1
[11:01:51.907]  elements: ‘ii’
[11:01:51.907]  length: 0 (resolved future 1)
[11:01:51.907] resolve() on list ... DONE
[11:01:51.907] - globals: [1] ‘ii’
[11:01:51.908] Resolving futures part of globals (recursively) ... DONE
[11:01:51.908] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:51.908] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:51.908] - globals: [1] ‘ii’
[11:01:51.908] 
[11:01:51.908] getGlobalsAndPackages() ... DONE
[11:01:51.909] run() for ‘Future’ ...
[11:01:51.909] - state: ‘created’
[11:01:51.909] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.909] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.909] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.909]   - Field: ‘label’
[11:01:51.909]   - Field: ‘local’
[11:01:51.909]   - Field: ‘owner’
[11:01:51.909]   - Field: ‘envir’
[11:01:51.910]   - Field: ‘packages’
[11:01:51.910]   - Field: ‘gc’
[11:01:51.910]   - Field: ‘conditions’
[11:01:51.910]   - Field: ‘expr’
[11:01:51.910]   - Field: ‘uuid’
[11:01:51.910]   - Field: ‘seed’
[11:01:51.910]   - Field: ‘version’
[11:01:51.910]   - Field: ‘result’
[11:01:51.910]   - Field: ‘asynchronous’
[11:01:51.910]   - Field: ‘calls’
[11:01:51.910]   - Field: ‘globals’
[11:01:51.910]   - Field: ‘stdout’
[11:01:51.911]   - Field: ‘earlySignal’
[11:01:51.911]   - Field: ‘lazy’
[11:01:51.911]   - Field: ‘state’
[11:01:51.911] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.911] - Launch lazy future ...
[11:01:51.911] Packages needed by the future expression (n = 0): <none>
[11:01:51.911] Packages needed by future strategies (n = 0): <none>
[11:01:51.912] {
[11:01:51.912]     {
[11:01:51.912]         {
[11:01:51.912]             ...future.startTime <- base::Sys.time()
[11:01:51.912]             {
[11:01:51.912]                 {
[11:01:51.912]                   {
[11:01:51.912]                     base::local({
[11:01:51.912]                       has_future <- base::requireNamespace("future", 
[11:01:51.912]                         quietly = TRUE)
[11:01:51.912]                       if (has_future) {
[11:01:51.912]                         ns <- base::getNamespace("future")
[11:01:51.912]                         version <- ns[[".package"]][["version"]]
[11:01:51.912]                         if (is.null(version)) 
[11:01:51.912]                           version <- utils::packageVersion("future")
[11:01:51.912]                       }
[11:01:51.912]                       else {
[11:01:51.912]                         version <- NULL
[11:01:51.912]                       }
[11:01:51.912]                       if (!has_future || version < "1.8.0") {
[11:01:51.912]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.912]                           "", base::R.version$version.string), 
[11:01:51.912]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.912]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.912]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.912]                             "release", "version")], collapse = " "), 
[11:01:51.912]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.912]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.912]                           info)
[11:01:51.912]                         info <- base::paste(info, collapse = "; ")
[11:01:51.912]                         if (!has_future) {
[11:01:51.912]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.912]                             info)
[11:01:51.912]                         }
[11:01:51.912]                         else {
[11:01:51.912]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.912]                             info, version)
[11:01:51.912]                         }
[11:01:51.912]                         base::stop(msg)
[11:01:51.912]                       }
[11:01:51.912]                     })
[11:01:51.912]                   }
[11:01:51.912]                   ...future.strategy.old <- future::plan("list")
[11:01:51.912]                   options(future.plan = NULL)
[11:01:51.912]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.912]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.912]                 }
[11:01:51.912]                 ...future.workdir <- getwd()
[11:01:51.912]             }
[11:01:51.912]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.912]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.912]         }
[11:01:51.912]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.912]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.912]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.912]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.912]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.912]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.912]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.912]             base::names(...future.oldOptions))
[11:01:51.912]     }
[11:01:51.912]     if (FALSE) {
[11:01:51.912]     }
[11:01:51.912]     else {
[11:01:51.912]         if (TRUE) {
[11:01:51.912]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.912]                 open = "w")
[11:01:51.912]         }
[11:01:51.912]         else {
[11:01:51.912]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.912]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.912]         }
[11:01:51.912]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.912]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.912]             base::sink(type = "output", split = FALSE)
[11:01:51.912]             base::close(...future.stdout)
[11:01:51.912]         }, add = TRUE)
[11:01:51.912]     }
[11:01:51.912]     ...future.frame <- base::sys.nframe()
[11:01:51.912]     ...future.conditions <- base::list()
[11:01:51.912]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.912]     if (FALSE) {
[11:01:51.912]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.912]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.912]     }
[11:01:51.912]     ...future.result <- base::tryCatch({
[11:01:51.912]         base::withCallingHandlers({
[11:01:51.912]             ...future.value <- base::withVisible(base::local({
[11:01:51.912]                 b <- a * ii
[11:01:51.912]                 a <- 0
[11:01:51.912]                 b
[11:01:51.912]             }))
[11:01:51.912]             future::FutureResult(value = ...future.value$value, 
[11:01:51.912]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.912]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.912]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.912]                     ...future.globalenv.names))
[11:01:51.912]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.912]         }, condition = base::local({
[11:01:51.912]             c <- base::c
[11:01:51.912]             inherits <- base::inherits
[11:01:51.912]             invokeRestart <- base::invokeRestart
[11:01:51.912]             length <- base::length
[11:01:51.912]             list <- base::list
[11:01:51.912]             seq.int <- base::seq.int
[11:01:51.912]             signalCondition <- base::signalCondition
[11:01:51.912]             sys.calls <- base::sys.calls
[11:01:51.912]             `[[` <- base::`[[`
[11:01:51.912]             `+` <- base::`+`
[11:01:51.912]             `<<-` <- base::`<<-`
[11:01:51.912]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.912]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.912]                   3L)]
[11:01:51.912]             }
[11:01:51.912]             function(cond) {
[11:01:51.912]                 is_error <- inherits(cond, "error")
[11:01:51.912]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.912]                   NULL)
[11:01:51.912]                 if (is_error) {
[11:01:51.912]                   sessionInformation <- function() {
[11:01:51.912]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.912]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.912]                       search = base::search(), system = base::Sys.info())
[11:01:51.912]                   }
[11:01:51.912]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.912]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.912]                     cond$call), session = sessionInformation(), 
[11:01:51.912]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.912]                   signalCondition(cond)
[11:01:51.912]                 }
[11:01:51.912]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.912]                 "immediateCondition"))) {
[11:01:51.912]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.912]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.912]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.912]                   if (TRUE && !signal) {
[11:01:51.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.912]                     {
[11:01:51.912]                       inherits <- base::inherits
[11:01:51.912]                       invokeRestart <- base::invokeRestart
[11:01:51.912]                       is.null <- base::is.null
[11:01:51.912]                       muffled <- FALSE
[11:01:51.912]                       if (inherits(cond, "message")) {
[11:01:51.912]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.912]                         if (muffled) 
[11:01:51.912]                           invokeRestart("muffleMessage")
[11:01:51.912]                       }
[11:01:51.912]                       else if (inherits(cond, "warning")) {
[11:01:51.912]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.912]                         if (muffled) 
[11:01:51.912]                           invokeRestart("muffleWarning")
[11:01:51.912]                       }
[11:01:51.912]                       else if (inherits(cond, "condition")) {
[11:01:51.912]                         if (!is.null(pattern)) {
[11:01:51.912]                           computeRestarts <- base::computeRestarts
[11:01:51.912]                           grepl <- base::grepl
[11:01:51.912]                           restarts <- computeRestarts(cond)
[11:01:51.912]                           for (restart in restarts) {
[11:01:51.912]                             name <- restart$name
[11:01:51.912]                             if (is.null(name)) 
[11:01:51.912]                               next
[11:01:51.912]                             if (!grepl(pattern, name)) 
[11:01:51.912]                               next
[11:01:51.912]                             invokeRestart(restart)
[11:01:51.912]                             muffled <- TRUE
[11:01:51.912]                             break
[11:01:51.912]                           }
[11:01:51.912]                         }
[11:01:51.912]                       }
[11:01:51.912]                       invisible(muffled)
[11:01:51.912]                     }
[11:01:51.912]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.912]                   }
[11:01:51.912]                 }
[11:01:51.912]                 else {
[11:01:51.912]                   if (TRUE) {
[11:01:51.912]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.912]                     {
[11:01:51.912]                       inherits <- base::inherits
[11:01:51.912]                       invokeRestart <- base::invokeRestart
[11:01:51.912]                       is.null <- base::is.null
[11:01:51.912]                       muffled <- FALSE
[11:01:51.912]                       if (inherits(cond, "message")) {
[11:01:51.912]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.912]                         if (muffled) 
[11:01:51.912]                           invokeRestart("muffleMessage")
[11:01:51.912]                       }
[11:01:51.912]                       else if (inherits(cond, "warning")) {
[11:01:51.912]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.912]                         if (muffled) 
[11:01:51.912]                           invokeRestart("muffleWarning")
[11:01:51.912]                       }
[11:01:51.912]                       else if (inherits(cond, "condition")) {
[11:01:51.912]                         if (!is.null(pattern)) {
[11:01:51.912]                           computeRestarts <- base::computeRestarts
[11:01:51.912]                           grepl <- base::grepl
[11:01:51.912]                           restarts <- computeRestarts(cond)
[11:01:51.912]                           for (restart in restarts) {
[11:01:51.912]                             name <- restart$name
[11:01:51.912]                             if (is.null(name)) 
[11:01:51.912]                               next
[11:01:51.912]                             if (!grepl(pattern, name)) 
[11:01:51.912]                               next
[11:01:51.912]                             invokeRestart(restart)
[11:01:51.912]                             muffled <- TRUE
[11:01:51.912]                             break
[11:01:51.912]                           }
[11:01:51.912]                         }
[11:01:51.912]                       }
[11:01:51.912]                       invisible(muffled)
[11:01:51.912]                     }
[11:01:51.912]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.912]                   }
[11:01:51.912]                 }
[11:01:51.912]             }
[11:01:51.912]         }))
[11:01:51.912]     }, error = function(ex) {
[11:01:51.912]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.912]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.912]                 ...future.rng), started = ...future.startTime, 
[11:01:51.912]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.912]             version = "1.8"), class = "FutureResult")
[11:01:51.912]     }, finally = {
[11:01:51.912]         if (!identical(...future.workdir, getwd())) 
[11:01:51.912]             setwd(...future.workdir)
[11:01:51.912]         {
[11:01:51.912]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.912]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.912]             }
[11:01:51.912]             base::options(...future.oldOptions)
[11:01:51.912]             if (.Platform$OS.type == "windows") {
[11:01:51.912]                 old_names <- names(...future.oldEnvVars)
[11:01:51.912]                 envs <- base::Sys.getenv()
[11:01:51.912]                 names <- names(envs)
[11:01:51.912]                 common <- intersect(names, old_names)
[11:01:51.912]                 added <- setdiff(names, old_names)
[11:01:51.912]                 removed <- setdiff(old_names, names)
[11:01:51.912]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.912]                   envs[common]]
[11:01:51.912]                 NAMES <- toupper(changed)
[11:01:51.912]                 args <- list()
[11:01:51.912]                 for (kk in seq_along(NAMES)) {
[11:01:51.912]                   name <- changed[[kk]]
[11:01:51.912]                   NAME <- NAMES[[kk]]
[11:01:51.912]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.912]                     next
[11:01:51.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.912]                 }
[11:01:51.912]                 NAMES <- toupper(added)
[11:01:51.912]                 for (kk in seq_along(NAMES)) {
[11:01:51.912]                   name <- added[[kk]]
[11:01:51.912]                   NAME <- NAMES[[kk]]
[11:01:51.912]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.912]                     next
[11:01:51.912]                   args[[name]] <- ""
[11:01:51.912]                 }
[11:01:51.912]                 NAMES <- toupper(removed)
[11:01:51.912]                 for (kk in seq_along(NAMES)) {
[11:01:51.912]                   name <- removed[[kk]]
[11:01:51.912]                   NAME <- NAMES[[kk]]
[11:01:51.912]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.912]                     next
[11:01:51.912]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.912]                 }
[11:01:51.912]                 if (length(args) > 0) 
[11:01:51.912]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.912]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.912]             }
[11:01:51.912]             else {
[11:01:51.912]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.912]             }
[11:01:51.912]             {
[11:01:51.912]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.912]                   0L) {
[11:01:51.912]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.912]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.912]                   base::options(opts)
[11:01:51.912]                 }
[11:01:51.912]                 {
[11:01:51.912]                   {
[11:01:51.912]                     NULL
[11:01:51.912]                     RNGkind("Mersenne-Twister")
[11:01:51.912]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.912]                       inherits = FALSE)
[11:01:51.912]                   }
[11:01:51.912]                   options(future.plan = NULL)
[11:01:51.912]                   if (is.na(NA_character_)) 
[11:01:51.912]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.912]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.912]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.912]                     .init = FALSE)
[11:01:51.912]                 }
[11:01:51.912]             }
[11:01:51.912]         }
[11:01:51.912]     })
[11:01:51.912]     if (TRUE) {
[11:01:51.912]         base::sink(type = "output", split = FALSE)
[11:01:51.912]         if (TRUE) {
[11:01:51.912]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.912]         }
[11:01:51.912]         else {
[11:01:51.912]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.912]         }
[11:01:51.912]         base::close(...future.stdout)
[11:01:51.912]         ...future.stdout <- NULL
[11:01:51.912]     }
[11:01:51.912]     ...future.result$conditions <- ...future.conditions
[11:01:51.912]     ...future.result$finished <- base::Sys.time()
[11:01:51.912]     ...future.result
[11:01:51.912] }
[11:01:51.913] assign_globals() ...
[11:01:51.913] List of 1
[11:01:51.913]  $ ii: int 1
[11:01:51.913]  - attr(*, "where")=List of 1
[11:01:51.913]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:51.913]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:51.913]  - attr(*, "resolved")= logi TRUE
[11:01:51.913]  - attr(*, "total_size")= num 35
[11:01:51.913]  - attr(*, "already-done")= logi TRUE
[11:01:51.916] - copied ‘ii’ to environment
[11:01:51.916] assign_globals() ... done
[11:01:51.916] plan(): Setting new future strategy stack:
[11:01:51.916] List of future strategies:
[11:01:51.916] 1. sequential:
[11:01:51.916]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.916]    - tweaked: FALSE
[11:01:51.916]    - call: NULL
[11:01:51.916] plan(): nbrOfWorkers() = 1
[11:01:51.917] plan(): Setting new future strategy stack:
[11:01:51.917] List of future strategies:
[11:01:51.917] 1. sequential:
[11:01:51.917]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.917]    - tweaked: FALSE
[11:01:51.917]    - call: plan(strategy)
[11:01:51.918] plan(): nbrOfWorkers() = 1
[11:01:51.918] SequentialFuture started (and completed)
[11:01:51.918] signalConditions() ...
[11:01:51.918]  - include = ‘immediateCondition’
[11:01:51.918]  - exclude = 
[11:01:51.918]  - resignal = FALSE
[11:01:51.918]  - Number of conditions: 1
[11:01:51.918] signalConditions() ... done
[11:01:51.918] - Launch lazy future ... done
[11:01:51.918] run() for ‘SequentialFuture’ ... done
[11:01:51.919] signalConditions() ...
[11:01:51.919]  - include = ‘immediateCondition’
[11:01:51.919]  - exclude = 
[11:01:51.919]  - resignal = FALSE
[11:01:51.919]  - Number of conditions: 1
[11:01:51.919] signalConditions() ... done
[11:01:51.919] Future state: ‘finished’
[11:01:51.919] signalConditions() ...
[11:01:51.919]  - include = ‘condition’
[11:01:51.919]  - exclude = ‘immediateCondition’
[11:01:51.919]  - resignal = TRUE
[11:01:51.919]  - Number of conditions: 1
[11:01:51.920]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:51.920] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     b <- a * ii ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     b <- a * ii ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 11
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. .. ..$ : language eval(quote({     b <- a * ii ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:51"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.933] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.933] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.934] 
[11:01:51.934] Searching for globals ... DONE
[11:01:51.934] - globals: [0] <none>
[11:01:51.934] getGlobalsAndPackages() ... DONE
[11:01:51.934] run() for ‘Future’ ...
[11:01:51.934] - state: ‘created’
[11:01:51.934] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.934] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.935] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.935]   - Field: ‘label’
[11:01:51.935]   - Field: ‘local’
[11:01:51.935]   - Field: ‘owner’
[11:01:51.935]   - Field: ‘envir’
[11:01:51.935]   - Field: ‘packages’
[11:01:51.935]   - Field: ‘gc’
[11:01:51.935]   - Field: ‘conditions’
[11:01:51.935]   - Field: ‘expr’
[11:01:51.935]   - Field: ‘uuid’
[11:01:51.935]   - Field: ‘seed’
[11:01:51.936]   - Field: ‘version’
[11:01:51.936]   - Field: ‘result’
[11:01:51.936]   - Field: ‘asynchronous’
[11:01:51.936]   - Field: ‘calls’
[11:01:51.936]   - Field: ‘globals’
[11:01:51.936]   - Field: ‘stdout’
[11:01:51.936]   - Field: ‘earlySignal’
[11:01:51.936]   - Field: ‘lazy’
[11:01:51.936]   - Field: ‘state’
[11:01:51.936] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.936] - Launch lazy future ...
[11:01:51.937] Packages needed by the future expression (n = 0): <none>
[11:01:51.937] Packages needed by future strategies (n = 0): <none>
[11:01:51.937] {
[11:01:51.937]     {
[11:01:51.937]         {
[11:01:51.937]             ...future.startTime <- base::Sys.time()
[11:01:51.937]             {
[11:01:51.937]                 {
[11:01:51.937]                   {
[11:01:51.937]                     base::local({
[11:01:51.937]                       has_future <- base::requireNamespace("future", 
[11:01:51.937]                         quietly = TRUE)
[11:01:51.937]                       if (has_future) {
[11:01:51.937]                         ns <- base::getNamespace("future")
[11:01:51.937]                         version <- ns[[".package"]][["version"]]
[11:01:51.937]                         if (is.null(version)) 
[11:01:51.937]                           version <- utils::packageVersion("future")
[11:01:51.937]                       }
[11:01:51.937]                       else {
[11:01:51.937]                         version <- NULL
[11:01:51.937]                       }
[11:01:51.937]                       if (!has_future || version < "1.8.0") {
[11:01:51.937]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.937]                           "", base::R.version$version.string), 
[11:01:51.937]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.937]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.937]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.937]                             "release", "version")], collapse = " "), 
[11:01:51.937]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.937]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.937]                           info)
[11:01:51.937]                         info <- base::paste(info, collapse = "; ")
[11:01:51.937]                         if (!has_future) {
[11:01:51.937]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.937]                             info)
[11:01:51.937]                         }
[11:01:51.937]                         else {
[11:01:51.937]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.937]                             info, version)
[11:01:51.937]                         }
[11:01:51.937]                         base::stop(msg)
[11:01:51.937]                       }
[11:01:51.937]                     })
[11:01:51.937]                   }
[11:01:51.937]                   ...future.strategy.old <- future::plan("list")
[11:01:51.937]                   options(future.plan = NULL)
[11:01:51.937]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.937]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.937]                 }
[11:01:51.937]                 ...future.workdir <- getwd()
[11:01:51.937]             }
[11:01:51.937]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.937]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.937]         }
[11:01:51.937]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.937]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.937]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.937]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.937]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.937]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.937]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.937]             base::names(...future.oldOptions))
[11:01:51.937]     }
[11:01:51.937]     if (FALSE) {
[11:01:51.937]     }
[11:01:51.937]     else {
[11:01:51.937]         if (TRUE) {
[11:01:51.937]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.937]                 open = "w")
[11:01:51.937]         }
[11:01:51.937]         else {
[11:01:51.937]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.937]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.937]         }
[11:01:51.937]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.937]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.937]             base::sink(type = "output", split = FALSE)
[11:01:51.937]             base::close(...future.stdout)
[11:01:51.937]         }, add = TRUE)
[11:01:51.937]     }
[11:01:51.937]     ...future.frame <- base::sys.nframe()
[11:01:51.937]     ...future.conditions <- base::list()
[11:01:51.937]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.937]     if (FALSE) {
[11:01:51.937]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.937]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.937]     }
[11:01:51.937]     ...future.result <- base::tryCatch({
[11:01:51.937]         base::withCallingHandlers({
[11:01:51.937]             ...future.value <- base::withVisible(base::local(1))
[11:01:51.937]             future::FutureResult(value = ...future.value$value, 
[11:01:51.937]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.937]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.937]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.937]                     ...future.globalenv.names))
[11:01:51.937]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.937]         }, condition = base::local({
[11:01:51.937]             c <- base::c
[11:01:51.937]             inherits <- base::inherits
[11:01:51.937]             invokeRestart <- base::invokeRestart
[11:01:51.937]             length <- base::length
[11:01:51.937]             list <- base::list
[11:01:51.937]             seq.int <- base::seq.int
[11:01:51.937]             signalCondition <- base::signalCondition
[11:01:51.937]             sys.calls <- base::sys.calls
[11:01:51.937]             `[[` <- base::`[[`
[11:01:51.937]             `+` <- base::`+`
[11:01:51.937]             `<<-` <- base::`<<-`
[11:01:51.937]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.937]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.937]                   3L)]
[11:01:51.937]             }
[11:01:51.937]             function(cond) {
[11:01:51.937]                 is_error <- inherits(cond, "error")
[11:01:51.937]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.937]                   NULL)
[11:01:51.937]                 if (is_error) {
[11:01:51.937]                   sessionInformation <- function() {
[11:01:51.937]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.937]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.937]                       search = base::search(), system = base::Sys.info())
[11:01:51.937]                   }
[11:01:51.937]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.937]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.937]                     cond$call), session = sessionInformation(), 
[11:01:51.937]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.937]                   signalCondition(cond)
[11:01:51.937]                 }
[11:01:51.937]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.937]                 "immediateCondition"))) {
[11:01:51.937]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.937]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.937]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.937]                   if (TRUE && !signal) {
[11:01:51.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.937]                     {
[11:01:51.937]                       inherits <- base::inherits
[11:01:51.937]                       invokeRestart <- base::invokeRestart
[11:01:51.937]                       is.null <- base::is.null
[11:01:51.937]                       muffled <- FALSE
[11:01:51.937]                       if (inherits(cond, "message")) {
[11:01:51.937]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.937]                         if (muffled) 
[11:01:51.937]                           invokeRestart("muffleMessage")
[11:01:51.937]                       }
[11:01:51.937]                       else if (inherits(cond, "warning")) {
[11:01:51.937]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.937]                         if (muffled) 
[11:01:51.937]                           invokeRestart("muffleWarning")
[11:01:51.937]                       }
[11:01:51.937]                       else if (inherits(cond, "condition")) {
[11:01:51.937]                         if (!is.null(pattern)) {
[11:01:51.937]                           computeRestarts <- base::computeRestarts
[11:01:51.937]                           grepl <- base::grepl
[11:01:51.937]                           restarts <- computeRestarts(cond)
[11:01:51.937]                           for (restart in restarts) {
[11:01:51.937]                             name <- restart$name
[11:01:51.937]                             if (is.null(name)) 
[11:01:51.937]                               next
[11:01:51.937]                             if (!grepl(pattern, name)) 
[11:01:51.937]                               next
[11:01:51.937]                             invokeRestart(restart)
[11:01:51.937]                             muffled <- TRUE
[11:01:51.937]                             break
[11:01:51.937]                           }
[11:01:51.937]                         }
[11:01:51.937]                       }
[11:01:51.937]                       invisible(muffled)
[11:01:51.937]                     }
[11:01:51.937]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.937]                   }
[11:01:51.937]                 }
[11:01:51.937]                 else {
[11:01:51.937]                   if (TRUE) {
[11:01:51.937]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.937]                     {
[11:01:51.937]                       inherits <- base::inherits
[11:01:51.937]                       invokeRestart <- base::invokeRestart
[11:01:51.937]                       is.null <- base::is.null
[11:01:51.937]                       muffled <- FALSE
[11:01:51.937]                       if (inherits(cond, "message")) {
[11:01:51.937]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.937]                         if (muffled) 
[11:01:51.937]                           invokeRestart("muffleMessage")
[11:01:51.937]                       }
[11:01:51.937]                       else if (inherits(cond, "warning")) {
[11:01:51.937]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.937]                         if (muffled) 
[11:01:51.937]                           invokeRestart("muffleWarning")
[11:01:51.937]                       }
[11:01:51.937]                       else if (inherits(cond, "condition")) {
[11:01:51.937]                         if (!is.null(pattern)) {
[11:01:51.937]                           computeRestarts <- base::computeRestarts
[11:01:51.937]                           grepl <- base::grepl
[11:01:51.937]                           restarts <- computeRestarts(cond)
[11:01:51.937]                           for (restart in restarts) {
[11:01:51.937]                             name <- restart$name
[11:01:51.937]                             if (is.null(name)) 
[11:01:51.937]                               next
[11:01:51.937]                             if (!grepl(pattern, name)) 
[11:01:51.937]                               next
[11:01:51.937]                             invokeRestart(restart)
[11:01:51.937]                             muffled <- TRUE
[11:01:51.937]                             break
[11:01:51.937]                           }
[11:01:51.937]                         }
[11:01:51.937]                       }
[11:01:51.937]                       invisible(muffled)
[11:01:51.937]                     }
[11:01:51.937]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.937]                   }
[11:01:51.937]                 }
[11:01:51.937]             }
[11:01:51.937]         }))
[11:01:51.937]     }, error = function(ex) {
[11:01:51.937]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.937]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.937]                 ...future.rng), started = ...future.startTime, 
[11:01:51.937]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.937]             version = "1.8"), class = "FutureResult")
[11:01:51.937]     }, finally = {
[11:01:51.937]         if (!identical(...future.workdir, getwd())) 
[11:01:51.937]             setwd(...future.workdir)
[11:01:51.937]         {
[11:01:51.937]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.937]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.937]             }
[11:01:51.937]             base::options(...future.oldOptions)
[11:01:51.937]             if (.Platform$OS.type == "windows") {
[11:01:51.937]                 old_names <- names(...future.oldEnvVars)
[11:01:51.937]                 envs <- base::Sys.getenv()
[11:01:51.937]                 names <- names(envs)
[11:01:51.937]                 common <- intersect(names, old_names)
[11:01:51.937]                 added <- setdiff(names, old_names)
[11:01:51.937]                 removed <- setdiff(old_names, names)
[11:01:51.937]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.937]                   envs[common]]
[11:01:51.937]                 NAMES <- toupper(changed)
[11:01:51.937]                 args <- list()
[11:01:51.937]                 for (kk in seq_along(NAMES)) {
[11:01:51.937]                   name <- changed[[kk]]
[11:01:51.937]                   NAME <- NAMES[[kk]]
[11:01:51.937]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.937]                     next
[11:01:51.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.937]                 }
[11:01:51.937]                 NAMES <- toupper(added)
[11:01:51.937]                 for (kk in seq_along(NAMES)) {
[11:01:51.937]                   name <- added[[kk]]
[11:01:51.937]                   NAME <- NAMES[[kk]]
[11:01:51.937]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.937]                     next
[11:01:51.937]                   args[[name]] <- ""
[11:01:51.937]                 }
[11:01:51.937]                 NAMES <- toupper(removed)
[11:01:51.937]                 for (kk in seq_along(NAMES)) {
[11:01:51.937]                   name <- removed[[kk]]
[11:01:51.937]                   NAME <- NAMES[[kk]]
[11:01:51.937]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.937]                     next
[11:01:51.937]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.937]                 }
[11:01:51.937]                 if (length(args) > 0) 
[11:01:51.937]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.937]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.937]             }
[11:01:51.937]             else {
[11:01:51.937]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.937]             }
[11:01:51.937]             {
[11:01:51.937]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.937]                   0L) {
[11:01:51.937]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.937]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.937]                   base::options(opts)
[11:01:51.937]                 }
[11:01:51.937]                 {
[11:01:51.937]                   {
[11:01:51.937]                     NULL
[11:01:51.937]                     RNGkind("Mersenne-Twister")
[11:01:51.937]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.937]                       inherits = FALSE)
[11:01:51.937]                   }
[11:01:51.937]                   options(future.plan = NULL)
[11:01:51.937]                   if (is.na(NA_character_)) 
[11:01:51.937]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.937]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.937]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.937]                     .init = FALSE)
[11:01:51.937]                 }
[11:01:51.937]             }
[11:01:51.937]         }
[11:01:51.937]     })
[11:01:51.937]     if (TRUE) {
[11:01:51.937]         base::sink(type = "output", split = FALSE)
[11:01:51.937]         if (TRUE) {
[11:01:51.937]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.937]         }
[11:01:51.937]         else {
[11:01:51.937]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.937]         }
[11:01:51.937]         base::close(...future.stdout)
[11:01:51.937]         ...future.stdout <- NULL
[11:01:51.937]     }
[11:01:51.937]     ...future.result$conditions <- ...future.conditions
[11:01:51.937]     ...future.result$finished <- base::Sys.time()
[11:01:51.937]     ...future.result
[11:01:51.937] }
[11:01:51.939] plan(): Setting new future strategy stack:
[11:01:51.939] List of future strategies:
[11:01:51.939] 1. sequential:
[11:01:51.939]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.939]    - tweaked: FALSE
[11:01:51.939]    - call: NULL
[11:01:51.939] plan(): nbrOfWorkers() = 1
[11:01:51.940] plan(): Setting new future strategy stack:
[11:01:51.940] List of future strategies:
[11:01:51.940] 1. sequential:
[11:01:51.940]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.940]    - tweaked: FALSE
[11:01:51.940]    - call: plan(strategy)
[11:01:51.940] plan(): nbrOfWorkers() = 1
[11:01:51.940] SequentialFuture started (and completed)
[11:01:51.941] - Launch lazy future ... done
[11:01:51.941] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.941] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.941] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.942] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:51.942] Searching for globals ... DONE
[11:01:51.942] Resolving globals: TRUE
[11:01:51.942] Resolving any globals that are futures ...
[11:01:51.942] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:51.942] Resolving any globals that are futures ... DONE
[11:01:51.943] Resolving futures part of globals (recursively) ...
[11:01:51.943] resolve() on list ...
[11:01:51.943]  recursive: 99
[11:01:51.943]  length: 1
[11:01:51.943]  elements: ‘a’
[11:01:51.943] resolved() for ‘SequentialFuture’ ...
[11:01:51.943] - state: ‘finished’
[11:01:51.943] - run: TRUE
[11:01:51.943] - result: ‘FutureResult’
[11:01:51.944] resolved() for ‘SequentialFuture’ ... done
[11:01:51.944] Future #1
[11:01:51.944] resolved() for ‘SequentialFuture’ ...
[11:01:51.944] - state: ‘finished’
[11:01:51.944] - run: TRUE
[11:01:51.944] - result: ‘FutureResult’
[11:01:51.944] resolved() for ‘SequentialFuture’ ... done
[11:01:51.944] A SequentialFuture was resolved
[11:01:51.944]  length: 0 (resolved future 1)
[11:01:51.944] resolve() on list ... DONE
[11:01:51.945] - globals: [1] ‘a’
[11:01:51.945] Resolving futures part of globals (recursively) ... DONE
[11:01:51.945] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[11:01:51.945] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[11:01:51.945] - globals: [1] ‘a’
[11:01:51.945] - packages: [1] ‘future’
[11:01:51.945] getGlobalsAndPackages() ... DONE
[11:01:51.946] run() for ‘Future’ ...
[11:01:51.946] - state: ‘created’
[11:01:51.946] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.946] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.946] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.946]   - Field: ‘label’
[11:01:51.946]   - Field: ‘local’
[11:01:51.946]   - Field: ‘owner’
[11:01:51.947]   - Field: ‘envir’
[11:01:51.947]   - Field: ‘packages’
[11:01:51.947]   - Field: ‘gc’
[11:01:51.947]   - Field: ‘conditions’
[11:01:51.947]   - Field: ‘expr’
[11:01:51.947]   - Field: ‘uuid’
[11:01:51.947]   - Field: ‘seed’
[11:01:51.947]   - Field: ‘version’
[11:01:51.947]   - Field: ‘result’
[11:01:51.947]   - Field: ‘asynchronous’
[11:01:51.947]   - Field: ‘calls’
[11:01:51.947]   - Field: ‘globals’
[11:01:51.947]   - Field: ‘stdout’
[11:01:51.948]   - Field: ‘earlySignal’
[11:01:51.948]   - Field: ‘lazy’
[11:01:51.948]   - Field: ‘state’
[11:01:51.948] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.948] - Launch lazy future ...
[11:01:51.948] Packages needed by the future expression (n = 1): ‘future’
[11:01:51.948] Packages needed by future strategies (n = 0): <none>
[11:01:51.949] {
[11:01:51.949]     {
[11:01:51.949]         {
[11:01:51.949]             ...future.startTime <- base::Sys.time()
[11:01:51.949]             {
[11:01:51.949]                 {
[11:01:51.949]                   {
[11:01:51.949]                     {
[11:01:51.949]                       base::local({
[11:01:51.949]                         has_future <- base::requireNamespace("future", 
[11:01:51.949]                           quietly = TRUE)
[11:01:51.949]                         if (has_future) {
[11:01:51.949]                           ns <- base::getNamespace("future")
[11:01:51.949]                           version <- ns[[".package"]][["version"]]
[11:01:51.949]                           if (is.null(version)) 
[11:01:51.949]                             version <- utils::packageVersion("future")
[11:01:51.949]                         }
[11:01:51.949]                         else {
[11:01:51.949]                           version <- NULL
[11:01:51.949]                         }
[11:01:51.949]                         if (!has_future || version < "1.8.0") {
[11:01:51.949]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.949]                             "", base::R.version$version.string), 
[11:01:51.949]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:51.949]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.949]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.949]                               "release", "version")], collapse = " "), 
[11:01:51.949]                             hostname = base::Sys.info()[["nodename"]])
[11:01:51.949]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.949]                             info)
[11:01:51.949]                           info <- base::paste(info, collapse = "; ")
[11:01:51.949]                           if (!has_future) {
[11:01:51.949]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.949]                               info)
[11:01:51.949]                           }
[11:01:51.949]                           else {
[11:01:51.949]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.949]                               info, version)
[11:01:51.949]                           }
[11:01:51.949]                           base::stop(msg)
[11:01:51.949]                         }
[11:01:51.949]                       })
[11:01:51.949]                     }
[11:01:51.949]                     base::local({
[11:01:51.949]                       for (pkg in "future") {
[11:01:51.949]                         base::loadNamespace(pkg)
[11:01:51.949]                         base::library(pkg, character.only = TRUE)
[11:01:51.949]                       }
[11:01:51.949]                     })
[11:01:51.949]                   }
[11:01:51.949]                   ...future.strategy.old <- future::plan("list")
[11:01:51.949]                   options(future.plan = NULL)
[11:01:51.949]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.949]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.949]                 }
[11:01:51.949]                 ...future.workdir <- getwd()
[11:01:51.949]             }
[11:01:51.949]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.949]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.949]         }
[11:01:51.949]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.949]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.949]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.949]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.949]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.949]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.949]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.949]             base::names(...future.oldOptions))
[11:01:51.949]     }
[11:01:51.949]     if (FALSE) {
[11:01:51.949]     }
[11:01:51.949]     else {
[11:01:51.949]         if (TRUE) {
[11:01:51.949]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.949]                 open = "w")
[11:01:51.949]         }
[11:01:51.949]         else {
[11:01:51.949]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.949]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.949]         }
[11:01:51.949]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.949]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.949]             base::sink(type = "output", split = FALSE)
[11:01:51.949]             base::close(...future.stdout)
[11:01:51.949]         }, add = TRUE)
[11:01:51.949]     }
[11:01:51.949]     ...future.frame <- base::sys.nframe()
[11:01:51.949]     ...future.conditions <- base::list()
[11:01:51.949]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.949]     if (FALSE) {
[11:01:51.949]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.949]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.949]     }
[11:01:51.949]     ...future.result <- base::tryCatch({
[11:01:51.949]         base::withCallingHandlers({
[11:01:51.949]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:51.949]                 1))
[11:01:51.949]             future::FutureResult(value = ...future.value$value, 
[11:01:51.949]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.949]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.949]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.949]                     ...future.globalenv.names))
[11:01:51.949]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.949]         }, condition = base::local({
[11:01:51.949]             c <- base::c
[11:01:51.949]             inherits <- base::inherits
[11:01:51.949]             invokeRestart <- base::invokeRestart
[11:01:51.949]             length <- base::length
[11:01:51.949]             list <- base::list
[11:01:51.949]             seq.int <- base::seq.int
[11:01:51.949]             signalCondition <- base::signalCondition
[11:01:51.949]             sys.calls <- base::sys.calls
[11:01:51.949]             `[[` <- base::`[[`
[11:01:51.949]             `+` <- base::`+`
[11:01:51.949]             `<<-` <- base::`<<-`
[11:01:51.949]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.949]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.949]                   3L)]
[11:01:51.949]             }
[11:01:51.949]             function(cond) {
[11:01:51.949]                 is_error <- inherits(cond, "error")
[11:01:51.949]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.949]                   NULL)
[11:01:51.949]                 if (is_error) {
[11:01:51.949]                   sessionInformation <- function() {
[11:01:51.949]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.949]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.949]                       search = base::search(), system = base::Sys.info())
[11:01:51.949]                   }
[11:01:51.949]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.949]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.949]                     cond$call), session = sessionInformation(), 
[11:01:51.949]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.949]                   signalCondition(cond)
[11:01:51.949]                 }
[11:01:51.949]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.949]                 "immediateCondition"))) {
[11:01:51.949]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.949]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.949]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.949]                   if (TRUE && !signal) {
[11:01:51.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.949]                     {
[11:01:51.949]                       inherits <- base::inherits
[11:01:51.949]                       invokeRestart <- base::invokeRestart
[11:01:51.949]                       is.null <- base::is.null
[11:01:51.949]                       muffled <- FALSE
[11:01:51.949]                       if (inherits(cond, "message")) {
[11:01:51.949]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.949]                         if (muffled) 
[11:01:51.949]                           invokeRestart("muffleMessage")
[11:01:51.949]                       }
[11:01:51.949]                       else if (inherits(cond, "warning")) {
[11:01:51.949]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.949]                         if (muffled) 
[11:01:51.949]                           invokeRestart("muffleWarning")
[11:01:51.949]                       }
[11:01:51.949]                       else if (inherits(cond, "condition")) {
[11:01:51.949]                         if (!is.null(pattern)) {
[11:01:51.949]                           computeRestarts <- base::computeRestarts
[11:01:51.949]                           grepl <- base::grepl
[11:01:51.949]                           restarts <- computeRestarts(cond)
[11:01:51.949]                           for (restart in restarts) {
[11:01:51.949]                             name <- restart$name
[11:01:51.949]                             if (is.null(name)) 
[11:01:51.949]                               next
[11:01:51.949]                             if (!grepl(pattern, name)) 
[11:01:51.949]                               next
[11:01:51.949]                             invokeRestart(restart)
[11:01:51.949]                             muffled <- TRUE
[11:01:51.949]                             break
[11:01:51.949]                           }
[11:01:51.949]                         }
[11:01:51.949]                       }
[11:01:51.949]                       invisible(muffled)
[11:01:51.949]                     }
[11:01:51.949]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.949]                   }
[11:01:51.949]                 }
[11:01:51.949]                 else {
[11:01:51.949]                   if (TRUE) {
[11:01:51.949]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.949]                     {
[11:01:51.949]                       inherits <- base::inherits
[11:01:51.949]                       invokeRestart <- base::invokeRestart
[11:01:51.949]                       is.null <- base::is.null
[11:01:51.949]                       muffled <- FALSE
[11:01:51.949]                       if (inherits(cond, "message")) {
[11:01:51.949]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.949]                         if (muffled) 
[11:01:51.949]                           invokeRestart("muffleMessage")
[11:01:51.949]                       }
[11:01:51.949]                       else if (inherits(cond, "warning")) {
[11:01:51.949]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.949]                         if (muffled) 
[11:01:51.949]                           invokeRestart("muffleWarning")
[11:01:51.949]                       }
[11:01:51.949]                       else if (inherits(cond, "condition")) {
[11:01:51.949]                         if (!is.null(pattern)) {
[11:01:51.949]                           computeRestarts <- base::computeRestarts
[11:01:51.949]                           grepl <- base::grepl
[11:01:51.949]                           restarts <- computeRestarts(cond)
[11:01:51.949]                           for (restart in restarts) {
[11:01:51.949]                             name <- restart$name
[11:01:51.949]                             if (is.null(name)) 
[11:01:51.949]                               next
[11:01:51.949]                             if (!grepl(pattern, name)) 
[11:01:51.949]                               next
[11:01:51.949]                             invokeRestart(restart)
[11:01:51.949]                             muffled <- TRUE
[11:01:51.949]                             break
[11:01:51.949]                           }
[11:01:51.949]                         }
[11:01:51.949]                       }
[11:01:51.949]                       invisible(muffled)
[11:01:51.949]                     }
[11:01:51.949]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.949]                   }
[11:01:51.949]                 }
[11:01:51.949]             }
[11:01:51.949]         }))
[11:01:51.949]     }, error = function(ex) {
[11:01:51.949]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.949]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.949]                 ...future.rng), started = ...future.startTime, 
[11:01:51.949]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.949]             version = "1.8"), class = "FutureResult")
[11:01:51.949]     }, finally = {
[11:01:51.949]         if (!identical(...future.workdir, getwd())) 
[11:01:51.949]             setwd(...future.workdir)
[11:01:51.949]         {
[11:01:51.949]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.949]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.949]             }
[11:01:51.949]             base::options(...future.oldOptions)
[11:01:51.949]             if (.Platform$OS.type == "windows") {
[11:01:51.949]                 old_names <- names(...future.oldEnvVars)
[11:01:51.949]                 envs <- base::Sys.getenv()
[11:01:51.949]                 names <- names(envs)
[11:01:51.949]                 common <- intersect(names, old_names)
[11:01:51.949]                 added <- setdiff(names, old_names)
[11:01:51.949]                 removed <- setdiff(old_names, names)
[11:01:51.949]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.949]                   envs[common]]
[11:01:51.949]                 NAMES <- toupper(changed)
[11:01:51.949]                 args <- list()
[11:01:51.949]                 for (kk in seq_along(NAMES)) {
[11:01:51.949]                   name <- changed[[kk]]
[11:01:51.949]                   NAME <- NAMES[[kk]]
[11:01:51.949]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.949]                     next
[11:01:51.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.949]                 }
[11:01:51.949]                 NAMES <- toupper(added)
[11:01:51.949]                 for (kk in seq_along(NAMES)) {
[11:01:51.949]                   name <- added[[kk]]
[11:01:51.949]                   NAME <- NAMES[[kk]]
[11:01:51.949]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.949]                     next
[11:01:51.949]                   args[[name]] <- ""
[11:01:51.949]                 }
[11:01:51.949]                 NAMES <- toupper(removed)
[11:01:51.949]                 for (kk in seq_along(NAMES)) {
[11:01:51.949]                   name <- removed[[kk]]
[11:01:51.949]                   NAME <- NAMES[[kk]]
[11:01:51.949]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.949]                     next
[11:01:51.949]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.949]                 }
[11:01:51.949]                 if (length(args) > 0) 
[11:01:51.949]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.949]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.949]             }
[11:01:51.949]             else {
[11:01:51.949]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.949]             }
[11:01:51.949]             {
[11:01:51.949]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.949]                   0L) {
[11:01:51.949]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.949]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.949]                   base::options(opts)
[11:01:51.949]                 }
[11:01:51.949]                 {
[11:01:51.949]                   {
[11:01:51.949]                     NULL
[11:01:51.949]                     RNGkind("Mersenne-Twister")
[11:01:51.949]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.949]                       inherits = FALSE)
[11:01:51.949]                   }
[11:01:51.949]                   options(future.plan = NULL)
[11:01:51.949]                   if (is.na(NA_character_)) 
[11:01:51.949]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.949]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.949]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.949]                     .init = FALSE)
[11:01:51.949]                 }
[11:01:51.949]             }
[11:01:51.949]         }
[11:01:51.949]     })
[11:01:51.949]     if (TRUE) {
[11:01:51.949]         base::sink(type = "output", split = FALSE)
[11:01:51.949]         if (TRUE) {
[11:01:51.949]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.949]         }
[11:01:51.949]         else {
[11:01:51.949]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.949]         }
[11:01:51.949]         base::close(...future.stdout)
[11:01:51.949]         ...future.stdout <- NULL
[11:01:51.949]     }
[11:01:51.949]     ...future.result$conditions <- ...future.conditions
[11:01:51.949]     ...future.result$finished <- base::Sys.time()
[11:01:51.949]     ...future.result
[11:01:51.949] }
[11:01:51.950] assign_globals() ...
[11:01:51.950] List of 1
[11:01:51.950]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eecc9e4b98> 
[11:01:51.950]  - attr(*, "where")=List of 1
[11:01:51.950]   ..$ a:<environment: R_EmptyEnv> 
[11:01:51.950]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:51.950]  - attr(*, "resolved")= logi TRUE
[11:01:51.950]  - attr(*, "total_size")= num 3535
[11:01:51.950]  - attr(*, "already-done")= logi TRUE
[11:01:51.952] - copied ‘a’ to environment
[11:01:51.953] assign_globals() ... done
[11:01:51.953] plan(): Setting new future strategy stack:
[11:01:51.953] List of future strategies:
[11:01:51.953] 1. sequential:
[11:01:51.953]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.953]    - tweaked: FALSE
[11:01:51.953]    - call: NULL
[11:01:51.953] plan(): nbrOfWorkers() = 1
[11:01:51.954] plan(): Setting new future strategy stack:
[11:01:51.954] List of future strategies:
[11:01:51.954] 1. sequential:
[11:01:51.954]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.954]    - tweaked: FALSE
[11:01:51.954]    - call: plan(strategy)
[11:01:51.955] plan(): nbrOfWorkers() = 1
[11:01:51.955] SequentialFuture started (and completed)
[11:01:51.955] - Launch lazy future ... done
[11:01:51.955] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.955] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.956] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.957] 
[11:01:51.957] Searching for globals ... DONE
[11:01:51.957] - globals: [0] <none>
[11:01:51.957] getGlobalsAndPackages() ... DONE
[11:01:51.958] run() for ‘Future’ ...
[11:01:51.958] - state: ‘created’
[11:01:51.958] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.958] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.958] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.958]   - Field: ‘label’
[11:01:51.958]   - Field: ‘local’
[11:01:51.958]   - Field: ‘owner’
[11:01:51.958]   - Field: ‘envir’
[11:01:51.959]   - Field: ‘packages’
[11:01:51.959]   - Field: ‘gc’
[11:01:51.959]   - Field: ‘conditions’
[11:01:51.959]   - Field: ‘expr’
[11:01:51.959]   - Field: ‘uuid’
[11:01:51.959]   - Field: ‘seed’
[11:01:51.959]   - Field: ‘version’
[11:01:51.959]   - Field: ‘result’
[11:01:51.959]   - Field: ‘asynchronous’
[11:01:51.959]   - Field: ‘calls’
[11:01:51.960]   - Field: ‘globals’
[11:01:51.960]   - Field: ‘stdout’
[11:01:51.960]   - Field: ‘earlySignal’
[11:01:51.960]   - Field: ‘lazy’
[11:01:51.960]   - Field: ‘state’
[11:01:51.960] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.960] - Launch lazy future ...
[11:01:51.960] Packages needed by the future expression (n = 0): <none>
[11:01:51.960] Packages needed by future strategies (n = 0): <none>
[11:01:51.961] {
[11:01:51.961]     {
[11:01:51.961]         {
[11:01:51.961]             ...future.startTime <- base::Sys.time()
[11:01:51.961]             {
[11:01:51.961]                 {
[11:01:51.961]                   {
[11:01:51.961]                     base::local({
[11:01:51.961]                       has_future <- base::requireNamespace("future", 
[11:01:51.961]                         quietly = TRUE)
[11:01:51.961]                       if (has_future) {
[11:01:51.961]                         ns <- base::getNamespace("future")
[11:01:51.961]                         version <- ns[[".package"]][["version"]]
[11:01:51.961]                         if (is.null(version)) 
[11:01:51.961]                           version <- utils::packageVersion("future")
[11:01:51.961]                       }
[11:01:51.961]                       else {
[11:01:51.961]                         version <- NULL
[11:01:51.961]                       }
[11:01:51.961]                       if (!has_future || version < "1.8.0") {
[11:01:51.961]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.961]                           "", base::R.version$version.string), 
[11:01:51.961]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.961]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.961]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.961]                             "release", "version")], collapse = " "), 
[11:01:51.961]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.961]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.961]                           info)
[11:01:51.961]                         info <- base::paste(info, collapse = "; ")
[11:01:51.961]                         if (!has_future) {
[11:01:51.961]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.961]                             info)
[11:01:51.961]                         }
[11:01:51.961]                         else {
[11:01:51.961]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.961]                             info, version)
[11:01:51.961]                         }
[11:01:51.961]                         base::stop(msg)
[11:01:51.961]                       }
[11:01:51.961]                     })
[11:01:51.961]                   }
[11:01:51.961]                   ...future.strategy.old <- future::plan("list")
[11:01:51.961]                   options(future.plan = NULL)
[11:01:51.961]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.961]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.961]                 }
[11:01:51.961]                 ...future.workdir <- getwd()
[11:01:51.961]             }
[11:01:51.961]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.961]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.961]         }
[11:01:51.961]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.961]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.961]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.961]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.961]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.961]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.961]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.961]             base::names(...future.oldOptions))
[11:01:51.961]     }
[11:01:51.961]     if (FALSE) {
[11:01:51.961]     }
[11:01:51.961]     else {
[11:01:51.961]         if (TRUE) {
[11:01:51.961]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.961]                 open = "w")
[11:01:51.961]         }
[11:01:51.961]         else {
[11:01:51.961]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.961]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.961]         }
[11:01:51.961]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.961]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.961]             base::sink(type = "output", split = FALSE)
[11:01:51.961]             base::close(...future.stdout)
[11:01:51.961]         }, add = TRUE)
[11:01:51.961]     }
[11:01:51.961]     ...future.frame <- base::sys.nframe()
[11:01:51.961]     ...future.conditions <- base::list()
[11:01:51.961]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.961]     if (FALSE) {
[11:01:51.961]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.961]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.961]     }
[11:01:51.961]     ...future.result <- base::tryCatch({
[11:01:51.961]         base::withCallingHandlers({
[11:01:51.961]             ...future.value <- base::withVisible(base::local(1))
[11:01:51.961]             future::FutureResult(value = ...future.value$value, 
[11:01:51.961]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.961]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.961]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.961]                     ...future.globalenv.names))
[11:01:51.961]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.961]         }, condition = base::local({
[11:01:51.961]             c <- base::c
[11:01:51.961]             inherits <- base::inherits
[11:01:51.961]             invokeRestart <- base::invokeRestart
[11:01:51.961]             length <- base::length
[11:01:51.961]             list <- base::list
[11:01:51.961]             seq.int <- base::seq.int
[11:01:51.961]             signalCondition <- base::signalCondition
[11:01:51.961]             sys.calls <- base::sys.calls
[11:01:51.961]             `[[` <- base::`[[`
[11:01:51.961]             `+` <- base::`+`
[11:01:51.961]             `<<-` <- base::`<<-`
[11:01:51.961]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.961]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.961]                   3L)]
[11:01:51.961]             }
[11:01:51.961]             function(cond) {
[11:01:51.961]                 is_error <- inherits(cond, "error")
[11:01:51.961]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.961]                   NULL)
[11:01:51.961]                 if (is_error) {
[11:01:51.961]                   sessionInformation <- function() {
[11:01:51.961]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.961]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.961]                       search = base::search(), system = base::Sys.info())
[11:01:51.961]                   }
[11:01:51.961]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.961]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.961]                     cond$call), session = sessionInformation(), 
[11:01:51.961]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.961]                   signalCondition(cond)
[11:01:51.961]                 }
[11:01:51.961]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.961]                 "immediateCondition"))) {
[11:01:51.961]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.961]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.961]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.961]                   if (TRUE && !signal) {
[11:01:51.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.961]                     {
[11:01:51.961]                       inherits <- base::inherits
[11:01:51.961]                       invokeRestart <- base::invokeRestart
[11:01:51.961]                       is.null <- base::is.null
[11:01:51.961]                       muffled <- FALSE
[11:01:51.961]                       if (inherits(cond, "message")) {
[11:01:51.961]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.961]                         if (muffled) 
[11:01:51.961]                           invokeRestart("muffleMessage")
[11:01:51.961]                       }
[11:01:51.961]                       else if (inherits(cond, "warning")) {
[11:01:51.961]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.961]                         if (muffled) 
[11:01:51.961]                           invokeRestart("muffleWarning")
[11:01:51.961]                       }
[11:01:51.961]                       else if (inherits(cond, "condition")) {
[11:01:51.961]                         if (!is.null(pattern)) {
[11:01:51.961]                           computeRestarts <- base::computeRestarts
[11:01:51.961]                           grepl <- base::grepl
[11:01:51.961]                           restarts <- computeRestarts(cond)
[11:01:51.961]                           for (restart in restarts) {
[11:01:51.961]                             name <- restart$name
[11:01:51.961]                             if (is.null(name)) 
[11:01:51.961]                               next
[11:01:51.961]                             if (!grepl(pattern, name)) 
[11:01:51.961]                               next
[11:01:51.961]                             invokeRestart(restart)
[11:01:51.961]                             muffled <- TRUE
[11:01:51.961]                             break
[11:01:51.961]                           }
[11:01:51.961]                         }
[11:01:51.961]                       }
[11:01:51.961]                       invisible(muffled)
[11:01:51.961]                     }
[11:01:51.961]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.961]                   }
[11:01:51.961]                 }
[11:01:51.961]                 else {
[11:01:51.961]                   if (TRUE) {
[11:01:51.961]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.961]                     {
[11:01:51.961]                       inherits <- base::inherits
[11:01:51.961]                       invokeRestart <- base::invokeRestart
[11:01:51.961]                       is.null <- base::is.null
[11:01:51.961]                       muffled <- FALSE
[11:01:51.961]                       if (inherits(cond, "message")) {
[11:01:51.961]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.961]                         if (muffled) 
[11:01:51.961]                           invokeRestart("muffleMessage")
[11:01:51.961]                       }
[11:01:51.961]                       else if (inherits(cond, "warning")) {
[11:01:51.961]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.961]                         if (muffled) 
[11:01:51.961]                           invokeRestart("muffleWarning")
[11:01:51.961]                       }
[11:01:51.961]                       else if (inherits(cond, "condition")) {
[11:01:51.961]                         if (!is.null(pattern)) {
[11:01:51.961]                           computeRestarts <- base::computeRestarts
[11:01:51.961]                           grepl <- base::grepl
[11:01:51.961]                           restarts <- computeRestarts(cond)
[11:01:51.961]                           for (restart in restarts) {
[11:01:51.961]                             name <- restart$name
[11:01:51.961]                             if (is.null(name)) 
[11:01:51.961]                               next
[11:01:51.961]                             if (!grepl(pattern, name)) 
[11:01:51.961]                               next
[11:01:51.961]                             invokeRestart(restart)
[11:01:51.961]                             muffled <- TRUE
[11:01:51.961]                             break
[11:01:51.961]                           }
[11:01:51.961]                         }
[11:01:51.961]                       }
[11:01:51.961]                       invisible(muffled)
[11:01:51.961]                     }
[11:01:51.961]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.961]                   }
[11:01:51.961]                 }
[11:01:51.961]             }
[11:01:51.961]         }))
[11:01:51.961]     }, error = function(ex) {
[11:01:51.961]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.961]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.961]                 ...future.rng), started = ...future.startTime, 
[11:01:51.961]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.961]             version = "1.8"), class = "FutureResult")
[11:01:51.961]     }, finally = {
[11:01:51.961]         if (!identical(...future.workdir, getwd())) 
[11:01:51.961]             setwd(...future.workdir)
[11:01:51.961]         {
[11:01:51.961]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.961]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.961]             }
[11:01:51.961]             base::options(...future.oldOptions)
[11:01:51.961]             if (.Platform$OS.type == "windows") {
[11:01:51.961]                 old_names <- names(...future.oldEnvVars)
[11:01:51.961]                 envs <- base::Sys.getenv()
[11:01:51.961]                 names <- names(envs)
[11:01:51.961]                 common <- intersect(names, old_names)
[11:01:51.961]                 added <- setdiff(names, old_names)
[11:01:51.961]                 removed <- setdiff(old_names, names)
[11:01:51.961]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.961]                   envs[common]]
[11:01:51.961]                 NAMES <- toupper(changed)
[11:01:51.961]                 args <- list()
[11:01:51.961]                 for (kk in seq_along(NAMES)) {
[11:01:51.961]                   name <- changed[[kk]]
[11:01:51.961]                   NAME <- NAMES[[kk]]
[11:01:51.961]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.961]                     next
[11:01:51.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.961]                 }
[11:01:51.961]                 NAMES <- toupper(added)
[11:01:51.961]                 for (kk in seq_along(NAMES)) {
[11:01:51.961]                   name <- added[[kk]]
[11:01:51.961]                   NAME <- NAMES[[kk]]
[11:01:51.961]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.961]                     next
[11:01:51.961]                   args[[name]] <- ""
[11:01:51.961]                 }
[11:01:51.961]                 NAMES <- toupper(removed)
[11:01:51.961]                 for (kk in seq_along(NAMES)) {
[11:01:51.961]                   name <- removed[[kk]]
[11:01:51.961]                   NAME <- NAMES[[kk]]
[11:01:51.961]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.961]                     next
[11:01:51.961]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.961]                 }
[11:01:51.961]                 if (length(args) > 0) 
[11:01:51.961]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.961]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.961]             }
[11:01:51.961]             else {
[11:01:51.961]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.961]             }
[11:01:51.961]             {
[11:01:51.961]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.961]                   0L) {
[11:01:51.961]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.961]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.961]                   base::options(opts)
[11:01:51.961]                 }
[11:01:51.961]                 {
[11:01:51.961]                   {
[11:01:51.961]                     NULL
[11:01:51.961]                     RNGkind("Mersenne-Twister")
[11:01:51.961]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.961]                       inherits = FALSE)
[11:01:51.961]                   }
[11:01:51.961]                   options(future.plan = NULL)
[11:01:51.961]                   if (is.na(NA_character_)) 
[11:01:51.961]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.961]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.961]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.961]                     .init = FALSE)
[11:01:51.961]                 }
[11:01:51.961]             }
[11:01:51.961]         }
[11:01:51.961]     })
[11:01:51.961]     if (TRUE) {
[11:01:51.961]         base::sink(type = "output", split = FALSE)
[11:01:51.961]         if (TRUE) {
[11:01:51.961]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.961]         }
[11:01:51.961]         else {
[11:01:51.961]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.961]         }
[11:01:51.961]         base::close(...future.stdout)
[11:01:51.961]         ...future.stdout <- NULL
[11:01:51.961]     }
[11:01:51.961]     ...future.result$conditions <- ...future.conditions
[11:01:51.961]     ...future.result$finished <- base::Sys.time()
[11:01:51.961]     ...future.result
[11:01:51.961] }
[11:01:51.962] plan(): Setting new future strategy stack:
[11:01:51.962] List of future strategies:
[11:01:51.962] 1. sequential:
[11:01:51.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.962]    - tweaked: FALSE
[11:01:51.962]    - call: NULL
[11:01:51.963] plan(): nbrOfWorkers() = 1
[11:01:51.964] plan(): Setting new future strategy stack:
[11:01:51.964] List of future strategies:
[11:01:51.964] 1. sequential:
[11:01:51.964]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.964]    - tweaked: FALSE
[11:01:51.964]    - call: plan(strategy)
[11:01:51.964] plan(): nbrOfWorkers() = 1
[11:01:51.964] SequentialFuture started (and completed)
[11:01:51.964] - Launch lazy future ... done
[11:01:51.964] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.965] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.965] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.966] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:51.966] Searching for globals ... DONE
[11:01:51.966] Resolving globals: TRUE
[11:01:51.966] Resolving any globals that are futures ...
[11:01:51.966] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:51.966] Resolving any globals that are futures ... DONE
[11:01:51.966] Resolving futures part of globals (recursively) ...
[11:01:51.966] resolve() on list ...
[11:01:51.967]  recursive: 99
[11:01:51.967]  length: 1
[11:01:51.967]  elements: ‘a’
[11:01:51.967] resolved() for ‘SequentialFuture’ ...
[11:01:51.967] - state: ‘finished’
[11:01:51.967] - run: TRUE
[11:01:51.967] - result: ‘FutureResult’
[11:01:51.967] resolved() for ‘SequentialFuture’ ... done
[11:01:51.967] Future #1
[11:01:51.967] resolved() for ‘SequentialFuture’ ...
[11:01:51.967] - state: ‘finished’
[11:01:51.968] - run: TRUE
[11:01:51.968] - result: ‘FutureResult’
[11:01:51.968] resolved() for ‘SequentialFuture’ ... done
[11:01:51.968] A SequentialFuture was resolved
[11:01:51.968]  length: 0 (resolved future 1)
[11:01:51.968] resolve() on list ... DONE
[11:01:51.968] - globals: [1] ‘a’
[11:01:51.968] Resolving futures part of globals (recursively) ... DONE
[11:01:51.968] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[11:01:51.968] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[11:01:51.969] - globals: [1] ‘a’
[11:01:51.969] - packages: [1] ‘future’
[11:01:51.969] getGlobalsAndPackages() ... DONE
[11:01:51.969] run() for ‘Future’ ...
[11:01:51.969] - state: ‘created’
[11:01:51.969] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.969] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.970] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.970]   - Field: ‘label’
[11:01:51.970]   - Field: ‘local’
[11:01:51.970]   - Field: ‘owner’
[11:01:51.970]   - Field: ‘envir’
[11:01:51.970]   - Field: ‘packages’
[11:01:51.970]   - Field: ‘gc’
[11:01:51.970]   - Field: ‘conditions’
[11:01:51.970]   - Field: ‘expr’
[11:01:51.970]   - Field: ‘uuid’
[11:01:51.970]   - Field: ‘seed’
[11:01:51.970]   - Field: ‘version’
[11:01:51.971]   - Field: ‘result’
[11:01:51.971]   - Field: ‘asynchronous’
[11:01:51.971]   - Field: ‘calls’
[11:01:51.971]   - Field: ‘globals’
[11:01:51.971]   - Field: ‘stdout’
[11:01:51.971]   - Field: ‘earlySignal’
[11:01:51.971]   - Field: ‘lazy’
[11:01:51.971]   - Field: ‘state’
[11:01:51.971] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.971] - Launch lazy future ...
[11:01:51.972] Packages needed by the future expression (n = 1): ‘future’
[11:01:51.972] Packages needed by future strategies (n = 0): <none>
[11:01:51.972] {
[11:01:51.972]     {
[11:01:51.972]         {
[11:01:51.972]             ...future.startTime <- base::Sys.time()
[11:01:51.972]             {
[11:01:51.972]                 {
[11:01:51.972]                   {
[11:01:51.972]                     {
[11:01:51.972]                       base::local({
[11:01:51.972]                         has_future <- base::requireNamespace("future", 
[11:01:51.972]                           quietly = TRUE)
[11:01:51.972]                         if (has_future) {
[11:01:51.972]                           ns <- base::getNamespace("future")
[11:01:51.972]                           version <- ns[[".package"]][["version"]]
[11:01:51.972]                           if (is.null(version)) 
[11:01:51.972]                             version <- utils::packageVersion("future")
[11:01:51.972]                         }
[11:01:51.972]                         else {
[11:01:51.972]                           version <- NULL
[11:01:51.972]                         }
[11:01:51.972]                         if (!has_future || version < "1.8.0") {
[11:01:51.972]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.972]                             "", base::R.version$version.string), 
[11:01:51.972]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:51.972]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.972]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.972]                               "release", "version")], collapse = " "), 
[11:01:51.972]                             hostname = base::Sys.info()[["nodename"]])
[11:01:51.972]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.972]                             info)
[11:01:51.972]                           info <- base::paste(info, collapse = "; ")
[11:01:51.972]                           if (!has_future) {
[11:01:51.972]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.972]                               info)
[11:01:51.972]                           }
[11:01:51.972]                           else {
[11:01:51.972]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.972]                               info, version)
[11:01:51.972]                           }
[11:01:51.972]                           base::stop(msg)
[11:01:51.972]                         }
[11:01:51.972]                       })
[11:01:51.972]                     }
[11:01:51.972]                     base::local({
[11:01:51.972]                       for (pkg in "future") {
[11:01:51.972]                         base::loadNamespace(pkg)
[11:01:51.972]                         base::library(pkg, character.only = TRUE)
[11:01:51.972]                       }
[11:01:51.972]                     })
[11:01:51.972]                   }
[11:01:51.972]                   ...future.strategy.old <- future::plan("list")
[11:01:51.972]                   options(future.plan = NULL)
[11:01:51.972]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.972]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.972]                 }
[11:01:51.972]                 ...future.workdir <- getwd()
[11:01:51.972]             }
[11:01:51.972]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.972]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.972]         }
[11:01:51.972]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.972]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.972]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.972]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.972]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.972]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.972]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.972]             base::names(...future.oldOptions))
[11:01:51.972]     }
[11:01:51.972]     if (FALSE) {
[11:01:51.972]     }
[11:01:51.972]     else {
[11:01:51.972]         if (TRUE) {
[11:01:51.972]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.972]                 open = "w")
[11:01:51.972]         }
[11:01:51.972]         else {
[11:01:51.972]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.972]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.972]         }
[11:01:51.972]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.972]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.972]             base::sink(type = "output", split = FALSE)
[11:01:51.972]             base::close(...future.stdout)
[11:01:51.972]         }, add = TRUE)
[11:01:51.972]     }
[11:01:51.972]     ...future.frame <- base::sys.nframe()
[11:01:51.972]     ...future.conditions <- base::list()
[11:01:51.972]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.972]     if (FALSE) {
[11:01:51.972]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.972]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.972]     }
[11:01:51.972]     ...future.result <- base::tryCatch({
[11:01:51.972]         base::withCallingHandlers({
[11:01:51.972]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:51.972]                 1))
[11:01:51.972]             future::FutureResult(value = ...future.value$value, 
[11:01:51.972]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.972]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.972]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.972]                     ...future.globalenv.names))
[11:01:51.972]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.972]         }, condition = base::local({
[11:01:51.972]             c <- base::c
[11:01:51.972]             inherits <- base::inherits
[11:01:51.972]             invokeRestart <- base::invokeRestart
[11:01:51.972]             length <- base::length
[11:01:51.972]             list <- base::list
[11:01:51.972]             seq.int <- base::seq.int
[11:01:51.972]             signalCondition <- base::signalCondition
[11:01:51.972]             sys.calls <- base::sys.calls
[11:01:51.972]             `[[` <- base::`[[`
[11:01:51.972]             `+` <- base::`+`
[11:01:51.972]             `<<-` <- base::`<<-`
[11:01:51.972]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.972]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.972]                   3L)]
[11:01:51.972]             }
[11:01:51.972]             function(cond) {
[11:01:51.972]                 is_error <- inherits(cond, "error")
[11:01:51.972]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.972]                   NULL)
[11:01:51.972]                 if (is_error) {
[11:01:51.972]                   sessionInformation <- function() {
[11:01:51.972]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.972]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.972]                       search = base::search(), system = base::Sys.info())
[11:01:51.972]                   }
[11:01:51.972]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.972]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.972]                     cond$call), session = sessionInformation(), 
[11:01:51.972]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.972]                   signalCondition(cond)
[11:01:51.972]                 }
[11:01:51.972]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.972]                 "immediateCondition"))) {
[11:01:51.972]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.972]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.972]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.972]                   if (TRUE && !signal) {
[11:01:51.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.972]                     {
[11:01:51.972]                       inherits <- base::inherits
[11:01:51.972]                       invokeRestart <- base::invokeRestart
[11:01:51.972]                       is.null <- base::is.null
[11:01:51.972]                       muffled <- FALSE
[11:01:51.972]                       if (inherits(cond, "message")) {
[11:01:51.972]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.972]                         if (muffled) 
[11:01:51.972]                           invokeRestart("muffleMessage")
[11:01:51.972]                       }
[11:01:51.972]                       else if (inherits(cond, "warning")) {
[11:01:51.972]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.972]                         if (muffled) 
[11:01:51.972]                           invokeRestart("muffleWarning")
[11:01:51.972]                       }
[11:01:51.972]                       else if (inherits(cond, "condition")) {
[11:01:51.972]                         if (!is.null(pattern)) {
[11:01:51.972]                           computeRestarts <- base::computeRestarts
[11:01:51.972]                           grepl <- base::grepl
[11:01:51.972]                           restarts <- computeRestarts(cond)
[11:01:51.972]                           for (restart in restarts) {
[11:01:51.972]                             name <- restart$name
[11:01:51.972]                             if (is.null(name)) 
[11:01:51.972]                               next
[11:01:51.972]                             if (!grepl(pattern, name)) 
[11:01:51.972]                               next
[11:01:51.972]                             invokeRestart(restart)
[11:01:51.972]                             muffled <- TRUE
[11:01:51.972]                             break
[11:01:51.972]                           }
[11:01:51.972]                         }
[11:01:51.972]                       }
[11:01:51.972]                       invisible(muffled)
[11:01:51.972]                     }
[11:01:51.972]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.972]                   }
[11:01:51.972]                 }
[11:01:51.972]                 else {
[11:01:51.972]                   if (TRUE) {
[11:01:51.972]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.972]                     {
[11:01:51.972]                       inherits <- base::inherits
[11:01:51.972]                       invokeRestart <- base::invokeRestart
[11:01:51.972]                       is.null <- base::is.null
[11:01:51.972]                       muffled <- FALSE
[11:01:51.972]                       if (inherits(cond, "message")) {
[11:01:51.972]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.972]                         if (muffled) 
[11:01:51.972]                           invokeRestart("muffleMessage")
[11:01:51.972]                       }
[11:01:51.972]                       else if (inherits(cond, "warning")) {
[11:01:51.972]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.972]                         if (muffled) 
[11:01:51.972]                           invokeRestart("muffleWarning")
[11:01:51.972]                       }
[11:01:51.972]                       else if (inherits(cond, "condition")) {
[11:01:51.972]                         if (!is.null(pattern)) {
[11:01:51.972]                           computeRestarts <- base::computeRestarts
[11:01:51.972]                           grepl <- base::grepl
[11:01:51.972]                           restarts <- computeRestarts(cond)
[11:01:51.972]                           for (restart in restarts) {
[11:01:51.972]                             name <- restart$name
[11:01:51.972]                             if (is.null(name)) 
[11:01:51.972]                               next
[11:01:51.972]                             if (!grepl(pattern, name)) 
[11:01:51.972]                               next
[11:01:51.972]                             invokeRestart(restart)
[11:01:51.972]                             muffled <- TRUE
[11:01:51.972]                             break
[11:01:51.972]                           }
[11:01:51.972]                         }
[11:01:51.972]                       }
[11:01:51.972]                       invisible(muffled)
[11:01:51.972]                     }
[11:01:51.972]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.972]                   }
[11:01:51.972]                 }
[11:01:51.972]             }
[11:01:51.972]         }))
[11:01:51.972]     }, error = function(ex) {
[11:01:51.972]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.972]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.972]                 ...future.rng), started = ...future.startTime, 
[11:01:51.972]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.972]             version = "1.8"), class = "FutureResult")
[11:01:51.972]     }, finally = {
[11:01:51.972]         if (!identical(...future.workdir, getwd())) 
[11:01:51.972]             setwd(...future.workdir)
[11:01:51.972]         {
[11:01:51.972]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.972]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.972]             }
[11:01:51.972]             base::options(...future.oldOptions)
[11:01:51.972]             if (.Platform$OS.type == "windows") {
[11:01:51.972]                 old_names <- names(...future.oldEnvVars)
[11:01:51.972]                 envs <- base::Sys.getenv()
[11:01:51.972]                 names <- names(envs)
[11:01:51.972]                 common <- intersect(names, old_names)
[11:01:51.972]                 added <- setdiff(names, old_names)
[11:01:51.972]                 removed <- setdiff(old_names, names)
[11:01:51.972]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.972]                   envs[common]]
[11:01:51.972]                 NAMES <- toupper(changed)
[11:01:51.972]                 args <- list()
[11:01:51.972]                 for (kk in seq_along(NAMES)) {
[11:01:51.972]                   name <- changed[[kk]]
[11:01:51.972]                   NAME <- NAMES[[kk]]
[11:01:51.972]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.972]                     next
[11:01:51.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.972]                 }
[11:01:51.972]                 NAMES <- toupper(added)
[11:01:51.972]                 for (kk in seq_along(NAMES)) {
[11:01:51.972]                   name <- added[[kk]]
[11:01:51.972]                   NAME <- NAMES[[kk]]
[11:01:51.972]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.972]                     next
[11:01:51.972]                   args[[name]] <- ""
[11:01:51.972]                 }
[11:01:51.972]                 NAMES <- toupper(removed)
[11:01:51.972]                 for (kk in seq_along(NAMES)) {
[11:01:51.972]                   name <- removed[[kk]]
[11:01:51.972]                   NAME <- NAMES[[kk]]
[11:01:51.972]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.972]                     next
[11:01:51.972]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.972]                 }
[11:01:51.972]                 if (length(args) > 0) 
[11:01:51.972]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.972]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.972]             }
[11:01:51.972]             else {
[11:01:51.972]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.972]             }
[11:01:51.972]             {
[11:01:51.972]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.972]                   0L) {
[11:01:51.972]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.972]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.972]                   base::options(opts)
[11:01:51.972]                 }
[11:01:51.972]                 {
[11:01:51.972]                   {
[11:01:51.972]                     NULL
[11:01:51.972]                     RNGkind("Mersenne-Twister")
[11:01:51.972]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.972]                       inherits = FALSE)
[11:01:51.972]                   }
[11:01:51.972]                   options(future.plan = NULL)
[11:01:51.972]                   if (is.na(NA_character_)) 
[11:01:51.972]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.972]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.972]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.972]                     .init = FALSE)
[11:01:51.972]                 }
[11:01:51.972]             }
[11:01:51.972]         }
[11:01:51.972]     })
[11:01:51.972]     if (TRUE) {
[11:01:51.972]         base::sink(type = "output", split = FALSE)
[11:01:51.972]         if (TRUE) {
[11:01:51.972]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.972]         }
[11:01:51.972]         else {
[11:01:51.972]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.972]         }
[11:01:51.972]         base::close(...future.stdout)
[11:01:51.972]         ...future.stdout <- NULL
[11:01:51.972]     }
[11:01:51.972]     ...future.result$conditions <- ...future.conditions
[11:01:51.972]     ...future.result$finished <- base::Sys.time()
[11:01:51.972]     ...future.result
[11:01:51.972] }
[11:01:51.974] assign_globals() ...
[11:01:51.974] List of 1
[11:01:51.974]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eecd8ccf40> 
[11:01:51.974]  - attr(*, "where")=List of 1
[11:01:51.974]   ..$ a:<environment: R_EmptyEnv> 
[11:01:51.974]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:51.974]  - attr(*, "resolved")= logi TRUE
[11:01:51.974]  - attr(*, "total_size")= num 3535
[11:01:51.974]  - attr(*, "already-done")= logi TRUE
[11:01:51.976] - copied ‘a’ to environment
[11:01:51.976] assign_globals() ... done
[11:01:51.976] plan(): Setting new future strategy stack:
[11:01:51.976] List of future strategies:
[11:01:51.976] 1. sequential:
[11:01:51.976]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.976]    - tweaked: FALSE
[11:01:51.976]    - call: NULL
[11:01:51.977] plan(): nbrOfWorkers() = 1
[11:01:51.978] plan(): Setting new future strategy stack:
[11:01:51.978] List of future strategies:
[11:01:51.978] 1. sequential:
[11:01:51.978]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.978]    - tweaked: FALSE
[11:01:51.978]    - call: plan(strategy)
[11:01:51.978] plan(): nbrOfWorkers() = 1
[11:01:51.978] SequentialFuture started (and completed)
[11:01:51.978] - Launch lazy future ... done
[11:01:51.978] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.979] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.979] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.979] 
[11:01:51.980] Searching for globals ... DONE
[11:01:51.980] - globals: [0] <none>
[11:01:51.980] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:51.980] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:51.980] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:51.981] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:51.981] Searching for globals ... DONE
[11:01:51.981] Resolving globals: TRUE
[11:01:51.981] Resolving any globals that are futures ...
[11:01:51.981] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:51.981] Resolving any globals that are futures ... DONE
[11:01:51.982] Resolving futures part of globals (recursively) ...
[11:01:51.983] resolve() on list ...
[11:01:51.983]  recursive: 99
[11:01:51.983]  length: 1
[11:01:51.983]  elements: ‘a’
[11:01:51.983] run() for ‘Future’ ...
[11:01:51.983] - state: ‘created’
[11:01:51.983] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.984] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.984] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.984]   - Field: ‘label’
[11:01:51.984]   - Field: ‘local’
[11:01:51.984]   - Field: ‘owner’
[11:01:51.984]   - Field: ‘envir’
[11:01:51.984]   - Field: ‘packages’
[11:01:51.984]   - Field: ‘gc’
[11:01:51.984]   - Field: ‘conditions’
[11:01:51.985]   - Field: ‘expr’
[11:01:51.985]   - Field: ‘uuid’
[11:01:51.985]   - Field: ‘seed’
[11:01:51.985]   - Field: ‘version’
[11:01:51.985]   - Field: ‘result’
[11:01:51.985]   - Field: ‘asynchronous’
[11:01:51.985]   - Field: ‘calls’
[11:01:51.985]   - Field: ‘globals’
[11:01:51.985]   - Field: ‘stdout’
[11:01:51.985]   - Field: ‘earlySignal’
[11:01:51.985]   - Field: ‘lazy’
[11:01:51.985]   - Field: ‘state’
[11:01:51.986] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.986] - Launch lazy future ...
[11:01:51.986] Packages needed by the future expression (n = 0): <none>
[11:01:51.986] Packages needed by future strategies (n = 0): <none>
[11:01:51.986] {
[11:01:51.986]     {
[11:01:51.986]         {
[11:01:51.986]             ...future.startTime <- base::Sys.time()
[11:01:51.986]             {
[11:01:51.986]                 {
[11:01:51.986]                   {
[11:01:51.986]                     base::local({
[11:01:51.986]                       has_future <- base::requireNamespace("future", 
[11:01:51.986]                         quietly = TRUE)
[11:01:51.986]                       if (has_future) {
[11:01:51.986]                         ns <- base::getNamespace("future")
[11:01:51.986]                         version <- ns[[".package"]][["version"]]
[11:01:51.986]                         if (is.null(version)) 
[11:01:51.986]                           version <- utils::packageVersion("future")
[11:01:51.986]                       }
[11:01:51.986]                       else {
[11:01:51.986]                         version <- NULL
[11:01:51.986]                       }
[11:01:51.986]                       if (!has_future || version < "1.8.0") {
[11:01:51.986]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.986]                           "", base::R.version$version.string), 
[11:01:51.986]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:51.986]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.986]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.986]                             "release", "version")], collapse = " "), 
[11:01:51.986]                           hostname = base::Sys.info()[["nodename"]])
[11:01:51.986]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.986]                           info)
[11:01:51.986]                         info <- base::paste(info, collapse = "; ")
[11:01:51.986]                         if (!has_future) {
[11:01:51.986]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.986]                             info)
[11:01:51.986]                         }
[11:01:51.986]                         else {
[11:01:51.986]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.986]                             info, version)
[11:01:51.986]                         }
[11:01:51.986]                         base::stop(msg)
[11:01:51.986]                       }
[11:01:51.986]                     })
[11:01:51.986]                   }
[11:01:51.986]                   ...future.strategy.old <- future::plan("list")
[11:01:51.986]                   options(future.plan = NULL)
[11:01:51.986]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.986]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.986]                 }
[11:01:51.986]                 ...future.workdir <- getwd()
[11:01:51.986]             }
[11:01:51.986]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.986]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.986]         }
[11:01:51.986]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.986]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.986]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.986]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.986]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.986]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.986]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.986]             base::names(...future.oldOptions))
[11:01:51.986]     }
[11:01:51.986]     if (FALSE) {
[11:01:51.986]     }
[11:01:51.986]     else {
[11:01:51.986]         if (TRUE) {
[11:01:51.986]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.986]                 open = "w")
[11:01:51.986]         }
[11:01:51.986]         else {
[11:01:51.986]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.986]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.986]         }
[11:01:51.986]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.986]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.986]             base::sink(type = "output", split = FALSE)
[11:01:51.986]             base::close(...future.stdout)
[11:01:51.986]         }, add = TRUE)
[11:01:51.986]     }
[11:01:51.986]     ...future.frame <- base::sys.nframe()
[11:01:51.986]     ...future.conditions <- base::list()
[11:01:51.986]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.986]     if (FALSE) {
[11:01:51.986]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.986]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.986]     }
[11:01:51.986]     ...future.result <- base::tryCatch({
[11:01:51.986]         base::withCallingHandlers({
[11:01:51.986]             ...future.value <- base::withVisible(base::local(1))
[11:01:51.986]             future::FutureResult(value = ...future.value$value, 
[11:01:51.986]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.986]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.986]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.986]                     ...future.globalenv.names))
[11:01:51.986]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.986]         }, condition = base::local({
[11:01:51.986]             c <- base::c
[11:01:51.986]             inherits <- base::inherits
[11:01:51.986]             invokeRestart <- base::invokeRestart
[11:01:51.986]             length <- base::length
[11:01:51.986]             list <- base::list
[11:01:51.986]             seq.int <- base::seq.int
[11:01:51.986]             signalCondition <- base::signalCondition
[11:01:51.986]             sys.calls <- base::sys.calls
[11:01:51.986]             `[[` <- base::`[[`
[11:01:51.986]             `+` <- base::`+`
[11:01:51.986]             `<<-` <- base::`<<-`
[11:01:51.986]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.986]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.986]                   3L)]
[11:01:51.986]             }
[11:01:51.986]             function(cond) {
[11:01:51.986]                 is_error <- inherits(cond, "error")
[11:01:51.986]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.986]                   NULL)
[11:01:51.986]                 if (is_error) {
[11:01:51.986]                   sessionInformation <- function() {
[11:01:51.986]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.986]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.986]                       search = base::search(), system = base::Sys.info())
[11:01:51.986]                   }
[11:01:51.986]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.986]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.986]                     cond$call), session = sessionInformation(), 
[11:01:51.986]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.986]                   signalCondition(cond)
[11:01:51.986]                 }
[11:01:51.986]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.986]                 "immediateCondition"))) {
[11:01:51.986]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.986]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.986]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.986]                   if (TRUE && !signal) {
[11:01:51.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.986]                     {
[11:01:51.986]                       inherits <- base::inherits
[11:01:51.986]                       invokeRestart <- base::invokeRestart
[11:01:51.986]                       is.null <- base::is.null
[11:01:51.986]                       muffled <- FALSE
[11:01:51.986]                       if (inherits(cond, "message")) {
[11:01:51.986]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.986]                         if (muffled) 
[11:01:51.986]                           invokeRestart("muffleMessage")
[11:01:51.986]                       }
[11:01:51.986]                       else if (inherits(cond, "warning")) {
[11:01:51.986]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.986]                         if (muffled) 
[11:01:51.986]                           invokeRestart("muffleWarning")
[11:01:51.986]                       }
[11:01:51.986]                       else if (inherits(cond, "condition")) {
[11:01:51.986]                         if (!is.null(pattern)) {
[11:01:51.986]                           computeRestarts <- base::computeRestarts
[11:01:51.986]                           grepl <- base::grepl
[11:01:51.986]                           restarts <- computeRestarts(cond)
[11:01:51.986]                           for (restart in restarts) {
[11:01:51.986]                             name <- restart$name
[11:01:51.986]                             if (is.null(name)) 
[11:01:51.986]                               next
[11:01:51.986]                             if (!grepl(pattern, name)) 
[11:01:51.986]                               next
[11:01:51.986]                             invokeRestart(restart)
[11:01:51.986]                             muffled <- TRUE
[11:01:51.986]                             break
[11:01:51.986]                           }
[11:01:51.986]                         }
[11:01:51.986]                       }
[11:01:51.986]                       invisible(muffled)
[11:01:51.986]                     }
[11:01:51.986]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.986]                   }
[11:01:51.986]                 }
[11:01:51.986]                 else {
[11:01:51.986]                   if (TRUE) {
[11:01:51.986]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.986]                     {
[11:01:51.986]                       inherits <- base::inherits
[11:01:51.986]                       invokeRestart <- base::invokeRestart
[11:01:51.986]                       is.null <- base::is.null
[11:01:51.986]                       muffled <- FALSE
[11:01:51.986]                       if (inherits(cond, "message")) {
[11:01:51.986]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.986]                         if (muffled) 
[11:01:51.986]                           invokeRestart("muffleMessage")
[11:01:51.986]                       }
[11:01:51.986]                       else if (inherits(cond, "warning")) {
[11:01:51.986]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.986]                         if (muffled) 
[11:01:51.986]                           invokeRestart("muffleWarning")
[11:01:51.986]                       }
[11:01:51.986]                       else if (inherits(cond, "condition")) {
[11:01:51.986]                         if (!is.null(pattern)) {
[11:01:51.986]                           computeRestarts <- base::computeRestarts
[11:01:51.986]                           grepl <- base::grepl
[11:01:51.986]                           restarts <- computeRestarts(cond)
[11:01:51.986]                           for (restart in restarts) {
[11:01:51.986]                             name <- restart$name
[11:01:51.986]                             if (is.null(name)) 
[11:01:51.986]                               next
[11:01:51.986]                             if (!grepl(pattern, name)) 
[11:01:51.986]                               next
[11:01:51.986]                             invokeRestart(restart)
[11:01:51.986]                             muffled <- TRUE
[11:01:51.986]                             break
[11:01:51.986]                           }
[11:01:51.986]                         }
[11:01:51.986]                       }
[11:01:51.986]                       invisible(muffled)
[11:01:51.986]                     }
[11:01:51.986]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.986]                   }
[11:01:51.986]                 }
[11:01:51.986]             }
[11:01:51.986]         }))
[11:01:51.986]     }, error = function(ex) {
[11:01:51.986]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.986]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.986]                 ...future.rng), started = ...future.startTime, 
[11:01:51.986]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.986]             version = "1.8"), class = "FutureResult")
[11:01:51.986]     }, finally = {
[11:01:51.986]         if (!identical(...future.workdir, getwd())) 
[11:01:51.986]             setwd(...future.workdir)
[11:01:51.986]         {
[11:01:51.986]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.986]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.986]             }
[11:01:51.986]             base::options(...future.oldOptions)
[11:01:51.986]             if (.Platform$OS.type == "windows") {
[11:01:51.986]                 old_names <- names(...future.oldEnvVars)
[11:01:51.986]                 envs <- base::Sys.getenv()
[11:01:51.986]                 names <- names(envs)
[11:01:51.986]                 common <- intersect(names, old_names)
[11:01:51.986]                 added <- setdiff(names, old_names)
[11:01:51.986]                 removed <- setdiff(old_names, names)
[11:01:51.986]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.986]                   envs[common]]
[11:01:51.986]                 NAMES <- toupper(changed)
[11:01:51.986]                 args <- list()
[11:01:51.986]                 for (kk in seq_along(NAMES)) {
[11:01:51.986]                   name <- changed[[kk]]
[11:01:51.986]                   NAME <- NAMES[[kk]]
[11:01:51.986]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.986]                     next
[11:01:51.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.986]                 }
[11:01:51.986]                 NAMES <- toupper(added)
[11:01:51.986]                 for (kk in seq_along(NAMES)) {
[11:01:51.986]                   name <- added[[kk]]
[11:01:51.986]                   NAME <- NAMES[[kk]]
[11:01:51.986]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.986]                     next
[11:01:51.986]                   args[[name]] <- ""
[11:01:51.986]                 }
[11:01:51.986]                 NAMES <- toupper(removed)
[11:01:51.986]                 for (kk in seq_along(NAMES)) {
[11:01:51.986]                   name <- removed[[kk]]
[11:01:51.986]                   NAME <- NAMES[[kk]]
[11:01:51.986]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.986]                     next
[11:01:51.986]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.986]                 }
[11:01:51.986]                 if (length(args) > 0) 
[11:01:51.986]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.986]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.986]             }
[11:01:51.986]             else {
[11:01:51.986]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.986]             }
[11:01:51.986]             {
[11:01:51.986]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.986]                   0L) {
[11:01:51.986]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.986]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.986]                   base::options(opts)
[11:01:51.986]                 }
[11:01:51.986]                 {
[11:01:51.986]                   {
[11:01:51.986]                     NULL
[11:01:51.986]                     RNGkind("Mersenne-Twister")
[11:01:51.986]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.986]                       inherits = FALSE)
[11:01:51.986]                   }
[11:01:51.986]                   options(future.plan = NULL)
[11:01:51.986]                   if (is.na(NA_character_)) 
[11:01:51.986]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.986]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.986]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.986]                     .init = FALSE)
[11:01:51.986]                 }
[11:01:51.986]             }
[11:01:51.986]         }
[11:01:51.986]     })
[11:01:51.986]     if (TRUE) {
[11:01:51.986]         base::sink(type = "output", split = FALSE)
[11:01:51.986]         if (TRUE) {
[11:01:51.986]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.986]         }
[11:01:51.986]         else {
[11:01:51.986]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.986]         }
[11:01:51.986]         base::close(...future.stdout)
[11:01:51.986]         ...future.stdout <- NULL
[11:01:51.986]     }
[11:01:51.986]     ...future.result$conditions <- ...future.conditions
[11:01:51.986]     ...future.result$finished <- base::Sys.time()
[11:01:51.986]     ...future.result
[11:01:51.986] }
[11:01:51.988] plan(): Setting new future strategy stack:
[11:01:51.988] List of future strategies:
[11:01:51.988] 1. sequential:
[11:01:51.988]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.988]    - tweaked: FALSE
[11:01:51.988]    - call: NULL
[11:01:51.988] plan(): nbrOfWorkers() = 1
[11:01:51.989] plan(): Setting new future strategy stack:
[11:01:51.989] List of future strategies:
[11:01:51.989] 1. sequential:
[11:01:51.989]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:51.989]    - tweaked: FALSE
[11:01:51.989]    - call: plan(strategy)
[11:01:51.990] plan(): nbrOfWorkers() = 1
[11:01:51.990] SequentialFuture started (and completed)
[11:01:51.990] - Launch lazy future ... done
[11:01:51.990] run() for ‘SequentialFuture’ ... done
[11:01:51.990] resolved() for ‘SequentialFuture’ ...
[11:01:51.990] - state: ‘finished’
[11:01:51.990] - run: TRUE
[11:01:51.990] - result: ‘FutureResult’
[11:01:51.990] resolved() for ‘SequentialFuture’ ... done
[11:01:51.990] Future #1
[11:01:51.991] resolved() for ‘SequentialFuture’ ...
[11:01:51.991] - state: ‘finished’
[11:01:51.991] - run: TRUE
[11:01:51.991] - result: ‘FutureResult’
[11:01:51.991] resolved() for ‘SequentialFuture’ ... done
[11:01:51.991] A SequentialFuture was resolved
[11:01:51.991]  length: 0 (resolved future 1)
[11:01:51.991] resolve() on list ... DONE
[11:01:51.991] - globals: [1] ‘a’
[11:01:51.991] Resolving futures part of globals (recursively) ... DONE
[11:01:51.992] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[11:01:51.992] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[11:01:51.992] - globals: [1] ‘a’
[11:01:51.992] - packages: [1] ‘future’
[11:01:51.992] getGlobalsAndPackages() ... DONE
[11:01:51.992] run() for ‘Future’ ...
[11:01:51.992] - state: ‘created’
[11:01:51.993] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:51.993] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:51.993] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:51.993]   - Field: ‘label’
[11:01:51.993]   - Field: ‘local’
[11:01:51.993]   - Field: ‘owner’
[11:01:51.993]   - Field: ‘envir’
[11:01:51.993]   - Field: ‘packages’
[11:01:51.993]   - Field: ‘gc’
[11:01:51.993]   - Field: ‘conditions’
[11:01:51.994]   - Field: ‘expr’
[11:01:51.994]   - Field: ‘uuid’
[11:01:51.994]   - Field: ‘seed’
[11:01:51.994]   - Field: ‘version’
[11:01:51.994]   - Field: ‘result’
[11:01:51.994]   - Field: ‘asynchronous’
[11:01:51.994]   - Field: ‘calls’
[11:01:51.994]   - Field: ‘globals’
[11:01:51.994]   - Field: ‘stdout’
[11:01:51.994]   - Field: ‘earlySignal’
[11:01:51.994]   - Field: ‘lazy’
[11:01:51.994]   - Field: ‘state’
[11:01:51.994] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:51.995] - Launch lazy future ...
[11:01:51.995] Packages needed by the future expression (n = 1): ‘future’
[11:01:51.995] Packages needed by future strategies (n = 0): <none>
[11:01:51.995] {
[11:01:51.995]     {
[11:01:51.995]         {
[11:01:51.995]             ...future.startTime <- base::Sys.time()
[11:01:51.995]             {
[11:01:51.995]                 {
[11:01:51.995]                   {
[11:01:51.995]                     {
[11:01:51.995]                       base::local({
[11:01:51.995]                         has_future <- base::requireNamespace("future", 
[11:01:51.995]                           quietly = TRUE)
[11:01:51.995]                         if (has_future) {
[11:01:51.995]                           ns <- base::getNamespace("future")
[11:01:51.995]                           version <- ns[[".package"]][["version"]]
[11:01:51.995]                           if (is.null(version)) 
[11:01:51.995]                             version <- utils::packageVersion("future")
[11:01:51.995]                         }
[11:01:51.995]                         else {
[11:01:51.995]                           version <- NULL
[11:01:51.995]                         }
[11:01:51.995]                         if (!has_future || version < "1.8.0") {
[11:01:51.995]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:51.995]                             "", base::R.version$version.string), 
[11:01:51.995]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:51.995]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:51.995]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:51.995]                               "release", "version")], collapse = " "), 
[11:01:51.995]                             hostname = base::Sys.info()[["nodename"]])
[11:01:51.995]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:51.995]                             info)
[11:01:51.995]                           info <- base::paste(info, collapse = "; ")
[11:01:51.995]                           if (!has_future) {
[11:01:51.995]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:51.995]                               info)
[11:01:51.995]                           }
[11:01:51.995]                           else {
[11:01:51.995]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:51.995]                               info, version)
[11:01:51.995]                           }
[11:01:51.995]                           base::stop(msg)
[11:01:51.995]                         }
[11:01:51.995]                       })
[11:01:51.995]                     }
[11:01:51.995]                     base::local({
[11:01:51.995]                       for (pkg in "future") {
[11:01:51.995]                         base::loadNamespace(pkg)
[11:01:51.995]                         base::library(pkg, character.only = TRUE)
[11:01:51.995]                       }
[11:01:51.995]                     })
[11:01:51.995]                   }
[11:01:51.995]                   ...future.strategy.old <- future::plan("list")
[11:01:51.995]                   options(future.plan = NULL)
[11:01:51.995]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.995]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:51.995]                 }
[11:01:51.995]                 ...future.workdir <- getwd()
[11:01:51.995]             }
[11:01:51.995]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:51.995]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:51.995]         }
[11:01:51.995]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:51.995]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:51.995]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:51.995]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:51.995]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:51.995]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:51.995]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:51.995]             base::names(...future.oldOptions))
[11:01:51.995]     }
[11:01:51.995]     if (FALSE) {
[11:01:51.995]     }
[11:01:51.995]     else {
[11:01:51.995]         if (TRUE) {
[11:01:51.995]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:51.995]                 open = "w")
[11:01:51.995]         }
[11:01:51.995]         else {
[11:01:51.995]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:51.995]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:51.995]         }
[11:01:51.995]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:51.995]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:51.995]             base::sink(type = "output", split = FALSE)
[11:01:51.995]             base::close(...future.stdout)
[11:01:51.995]         }, add = TRUE)
[11:01:51.995]     }
[11:01:51.995]     ...future.frame <- base::sys.nframe()
[11:01:51.995]     ...future.conditions <- base::list()
[11:01:51.995]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:51.995]     if (FALSE) {
[11:01:51.995]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:51.995]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:51.995]     }
[11:01:51.995]     ...future.result <- base::tryCatch({
[11:01:51.995]         base::withCallingHandlers({
[11:01:51.995]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:51.995]                 1))
[11:01:51.995]             future::FutureResult(value = ...future.value$value, 
[11:01:51.995]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.995]                   ...future.rng), globalenv = if (FALSE) 
[11:01:51.995]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:51.995]                     ...future.globalenv.names))
[11:01:51.995]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:51.995]         }, condition = base::local({
[11:01:51.995]             c <- base::c
[11:01:51.995]             inherits <- base::inherits
[11:01:51.995]             invokeRestart <- base::invokeRestart
[11:01:51.995]             length <- base::length
[11:01:51.995]             list <- base::list
[11:01:51.995]             seq.int <- base::seq.int
[11:01:51.995]             signalCondition <- base::signalCondition
[11:01:51.995]             sys.calls <- base::sys.calls
[11:01:51.995]             `[[` <- base::`[[`
[11:01:51.995]             `+` <- base::`+`
[11:01:51.995]             `<<-` <- base::`<<-`
[11:01:51.995]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:51.995]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:51.995]                   3L)]
[11:01:51.995]             }
[11:01:51.995]             function(cond) {
[11:01:51.995]                 is_error <- inherits(cond, "error")
[11:01:51.995]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:51.995]                   NULL)
[11:01:51.995]                 if (is_error) {
[11:01:51.995]                   sessionInformation <- function() {
[11:01:51.995]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:51.995]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:51.995]                       search = base::search(), system = base::Sys.info())
[11:01:51.995]                   }
[11:01:51.995]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.995]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:51.995]                     cond$call), session = sessionInformation(), 
[11:01:51.995]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:51.995]                   signalCondition(cond)
[11:01:51.995]                 }
[11:01:51.995]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:51.995]                 "immediateCondition"))) {
[11:01:51.995]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:51.995]                   ...future.conditions[[length(...future.conditions) + 
[11:01:51.995]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:51.995]                   if (TRUE && !signal) {
[11:01:51.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.995]                     {
[11:01:51.995]                       inherits <- base::inherits
[11:01:51.995]                       invokeRestart <- base::invokeRestart
[11:01:51.995]                       is.null <- base::is.null
[11:01:51.995]                       muffled <- FALSE
[11:01:51.995]                       if (inherits(cond, "message")) {
[11:01:51.995]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.995]                         if (muffled) 
[11:01:51.995]                           invokeRestart("muffleMessage")
[11:01:51.995]                       }
[11:01:51.995]                       else if (inherits(cond, "warning")) {
[11:01:51.995]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.995]                         if (muffled) 
[11:01:51.995]                           invokeRestart("muffleWarning")
[11:01:51.995]                       }
[11:01:51.995]                       else if (inherits(cond, "condition")) {
[11:01:51.995]                         if (!is.null(pattern)) {
[11:01:51.995]                           computeRestarts <- base::computeRestarts
[11:01:51.995]                           grepl <- base::grepl
[11:01:51.995]                           restarts <- computeRestarts(cond)
[11:01:51.995]                           for (restart in restarts) {
[11:01:51.995]                             name <- restart$name
[11:01:51.995]                             if (is.null(name)) 
[11:01:51.995]                               next
[11:01:51.995]                             if (!grepl(pattern, name)) 
[11:01:51.995]                               next
[11:01:51.995]                             invokeRestart(restart)
[11:01:51.995]                             muffled <- TRUE
[11:01:51.995]                             break
[11:01:51.995]                           }
[11:01:51.995]                         }
[11:01:51.995]                       }
[11:01:51.995]                       invisible(muffled)
[11:01:51.995]                     }
[11:01:51.995]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.995]                   }
[11:01:51.995]                 }
[11:01:51.995]                 else {
[11:01:51.995]                   if (TRUE) {
[11:01:51.995]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:51.995]                     {
[11:01:51.995]                       inherits <- base::inherits
[11:01:51.995]                       invokeRestart <- base::invokeRestart
[11:01:51.995]                       is.null <- base::is.null
[11:01:51.995]                       muffled <- FALSE
[11:01:51.995]                       if (inherits(cond, "message")) {
[11:01:51.995]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:51.995]                         if (muffled) 
[11:01:51.995]                           invokeRestart("muffleMessage")
[11:01:51.995]                       }
[11:01:51.995]                       else if (inherits(cond, "warning")) {
[11:01:51.995]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:51.995]                         if (muffled) 
[11:01:51.995]                           invokeRestart("muffleWarning")
[11:01:51.995]                       }
[11:01:51.995]                       else if (inherits(cond, "condition")) {
[11:01:51.995]                         if (!is.null(pattern)) {
[11:01:51.995]                           computeRestarts <- base::computeRestarts
[11:01:51.995]                           grepl <- base::grepl
[11:01:51.995]                           restarts <- computeRestarts(cond)
[11:01:51.995]                           for (restart in restarts) {
[11:01:51.995]                             name <- restart$name
[11:01:51.995]                             if (is.null(name)) 
[11:01:51.995]                               next
[11:01:51.995]                             if (!grepl(pattern, name)) 
[11:01:51.995]                               next
[11:01:51.995]                             invokeRestart(restart)
[11:01:51.995]                             muffled <- TRUE
[11:01:51.995]                             break
[11:01:51.995]                           }
[11:01:51.995]                         }
[11:01:51.995]                       }
[11:01:51.995]                       invisible(muffled)
[11:01:51.995]                     }
[11:01:51.995]                     muffleCondition(cond, pattern = "^muffle")
[11:01:51.995]                   }
[11:01:51.995]                 }
[11:01:51.995]             }
[11:01:51.995]         }))
[11:01:51.995]     }, error = function(ex) {
[11:01:51.995]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:51.995]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:51.995]                 ...future.rng), started = ...future.startTime, 
[11:01:51.995]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:51.995]             version = "1.8"), class = "FutureResult")
[11:01:51.995]     }, finally = {
[11:01:51.995]         if (!identical(...future.workdir, getwd())) 
[11:01:51.995]             setwd(...future.workdir)
[11:01:51.995]         {
[11:01:51.995]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:51.995]                 ...future.oldOptions$nwarnings <- NULL
[11:01:51.995]             }
[11:01:51.995]             base::options(...future.oldOptions)
[11:01:51.995]             if (.Platform$OS.type == "windows") {
[11:01:51.995]                 old_names <- names(...future.oldEnvVars)
[11:01:51.995]                 envs <- base::Sys.getenv()
[11:01:51.995]                 names <- names(envs)
[11:01:51.995]                 common <- intersect(names, old_names)
[11:01:51.995]                 added <- setdiff(names, old_names)
[11:01:51.995]                 removed <- setdiff(old_names, names)
[11:01:51.995]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:51.995]                   envs[common]]
[11:01:51.995]                 NAMES <- toupper(changed)
[11:01:51.995]                 args <- list()
[11:01:51.995]                 for (kk in seq_along(NAMES)) {
[11:01:51.995]                   name <- changed[[kk]]
[11:01:51.995]                   NAME <- NAMES[[kk]]
[11:01:51.995]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.995]                     next
[11:01:51.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.995]                 }
[11:01:51.995]                 NAMES <- toupper(added)
[11:01:51.995]                 for (kk in seq_along(NAMES)) {
[11:01:51.995]                   name <- added[[kk]]
[11:01:51.995]                   NAME <- NAMES[[kk]]
[11:01:51.995]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.995]                     next
[11:01:51.995]                   args[[name]] <- ""
[11:01:51.995]                 }
[11:01:51.995]                 NAMES <- toupper(removed)
[11:01:51.995]                 for (kk in seq_along(NAMES)) {
[11:01:51.995]                   name <- removed[[kk]]
[11:01:51.995]                   NAME <- NAMES[[kk]]
[11:01:51.995]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:51.995]                     next
[11:01:51.995]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:51.995]                 }
[11:01:51.995]                 if (length(args) > 0) 
[11:01:51.995]                   base::do.call(base::Sys.setenv, args = args)
[11:01:51.995]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:51.995]             }
[11:01:51.995]             else {
[11:01:51.995]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:51.995]             }
[11:01:51.995]             {
[11:01:51.995]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:51.995]                   0L) {
[11:01:51.995]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:51.995]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:51.995]                   base::options(opts)
[11:01:51.995]                 }
[11:01:51.995]                 {
[11:01:51.995]                   {
[11:01:51.995]                     NULL
[11:01:51.995]                     RNGkind("Mersenne-Twister")
[11:01:51.995]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:51.995]                       inherits = FALSE)
[11:01:51.995]                   }
[11:01:51.995]                   options(future.plan = NULL)
[11:01:51.995]                   if (is.na(NA_character_)) 
[11:01:51.995]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:51.995]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:51.995]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:51.995]                     .init = FALSE)
[11:01:51.995]                 }
[11:01:51.995]             }
[11:01:51.995]         }
[11:01:51.995]     })
[11:01:51.995]     if (TRUE) {
[11:01:51.995]         base::sink(type = "output", split = FALSE)
[11:01:51.995]         if (TRUE) {
[11:01:51.995]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:51.995]         }
[11:01:51.995]         else {
[11:01:51.995]             ...future.result["stdout"] <- base::list(NULL)
[11:01:51.995]         }
[11:01:51.995]         base::close(...future.stdout)
[11:01:51.995]         ...future.stdout <- NULL
[11:01:51.995]     }
[11:01:51.995]     ...future.result$conditions <- ...future.conditions
[11:01:51.995]     ...future.result$finished <- base::Sys.time()
[11:01:51.995]     ...future.result
[11:01:51.995] }
[11:01:51.997] assign_globals() ...
[11:01:51.997] List of 1
[11:01:51.997]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eece8d7050> 
[11:01:51.997]  - attr(*, "where")=List of 1
[11:01:51.997]   ..$ a:<environment: R_EmptyEnv> 
[11:01:51.997]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:51.997]  - attr(*, "resolved")= logi TRUE
[11:01:51.997]  - attr(*, "total_size")= num 3555
[11:01:51.997]  - attr(*, "already-done")= logi TRUE
[11:01:51.999] - copied ‘a’ to environment
[11:01:51.999] assign_globals() ... done
[11:01:52.000] plan(): Setting new future strategy stack:
[11:01:52.000] List of future strategies:
[11:01:52.000] 1. sequential:
[11:01:52.000]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.000]    - tweaked: FALSE
[11:01:52.000]    - call: NULL
[11:01:52.000] plan(): nbrOfWorkers() = 1
[11:01:52.001] plan(): Setting new future strategy stack:
[11:01:52.001] List of future strategies:
[11:01:52.001] 1. sequential:
[11:01:52.001]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.001]    - tweaked: FALSE
[11:01:52.001]    - call: plan(strategy)
[11:01:52.001] plan(): nbrOfWorkers() = 1
[11:01:52.001] SequentialFuture started (and completed)
[11:01:52.001] - Launch lazy future ... done
[11:01:52.002] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.002] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.002] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.003] 
[11:01:52.003] Searching for globals ... DONE
[11:01:52.003] - globals: [0] <none>
[11:01:52.003] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.003] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.003] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.004] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.004] Searching for globals ... DONE
[11:01:52.004] Resolving globals: TRUE
[11:01:52.004] Resolving any globals that are futures ...
[11:01:52.004] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.005] Resolving any globals that are futures ... DONE
[11:01:52.005] Resolving futures part of globals (recursively) ...
[11:01:52.005] resolve() on list ...
[11:01:52.005]  recursive: 99
[11:01:52.005]  length: 1
[11:01:52.005]  elements: ‘a’
[11:01:52.005] run() for ‘Future’ ...
[11:01:52.005] - state: ‘created’
[11:01:52.006] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.006] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.006] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.006]   - Field: ‘label’
[11:01:52.006]   - Field: ‘local’
[11:01:52.006]   - Field: ‘owner’
[11:01:52.006]   - Field: ‘envir’
[11:01:52.006]   - Field: ‘packages’
[11:01:52.006]   - Field: ‘gc’
[11:01:52.006]   - Field: ‘conditions’
[11:01:52.007]   - Field: ‘expr’
[11:01:52.007]   - Field: ‘uuid’
[11:01:52.007]   - Field: ‘seed’
[11:01:52.007]   - Field: ‘version’
[11:01:52.008]   - Field: ‘result’
[11:01:52.008]   - Field: ‘asynchronous’
[11:01:52.008]   - Field: ‘calls’
[11:01:52.008]   - Field: ‘globals’
[11:01:52.008]   - Field: ‘stdout’
[11:01:52.008]   - Field: ‘earlySignal’
[11:01:52.008]   - Field: ‘lazy’
[11:01:52.008]   - Field: ‘state’
[11:01:52.008] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.009] - Launch lazy future ...
[11:01:52.009] Packages needed by the future expression (n = 0): <none>
[11:01:52.009] Packages needed by future strategies (n = 0): <none>
[11:01:52.009] {
[11:01:52.009]     {
[11:01:52.009]         {
[11:01:52.009]             ...future.startTime <- base::Sys.time()
[11:01:52.009]             {
[11:01:52.009]                 {
[11:01:52.009]                   {
[11:01:52.009]                     base::local({
[11:01:52.009]                       has_future <- base::requireNamespace("future", 
[11:01:52.009]                         quietly = TRUE)
[11:01:52.009]                       if (has_future) {
[11:01:52.009]                         ns <- base::getNamespace("future")
[11:01:52.009]                         version <- ns[[".package"]][["version"]]
[11:01:52.009]                         if (is.null(version)) 
[11:01:52.009]                           version <- utils::packageVersion("future")
[11:01:52.009]                       }
[11:01:52.009]                       else {
[11:01:52.009]                         version <- NULL
[11:01:52.009]                       }
[11:01:52.009]                       if (!has_future || version < "1.8.0") {
[11:01:52.009]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.009]                           "", base::R.version$version.string), 
[11:01:52.009]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.009]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.009]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.009]                             "release", "version")], collapse = " "), 
[11:01:52.009]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.009]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.009]                           info)
[11:01:52.009]                         info <- base::paste(info, collapse = "; ")
[11:01:52.009]                         if (!has_future) {
[11:01:52.009]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.009]                             info)
[11:01:52.009]                         }
[11:01:52.009]                         else {
[11:01:52.009]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.009]                             info, version)
[11:01:52.009]                         }
[11:01:52.009]                         base::stop(msg)
[11:01:52.009]                       }
[11:01:52.009]                     })
[11:01:52.009]                   }
[11:01:52.009]                   ...future.strategy.old <- future::plan("list")
[11:01:52.009]                   options(future.plan = NULL)
[11:01:52.009]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.009]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.009]                 }
[11:01:52.009]                 ...future.workdir <- getwd()
[11:01:52.009]             }
[11:01:52.009]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.009]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.009]         }
[11:01:52.009]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.009]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.009]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.009]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.009]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.009]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.009]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.009]             base::names(...future.oldOptions))
[11:01:52.009]     }
[11:01:52.009]     if (FALSE) {
[11:01:52.009]     }
[11:01:52.009]     else {
[11:01:52.009]         if (TRUE) {
[11:01:52.009]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.009]                 open = "w")
[11:01:52.009]         }
[11:01:52.009]         else {
[11:01:52.009]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.009]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.009]         }
[11:01:52.009]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.009]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.009]             base::sink(type = "output", split = FALSE)
[11:01:52.009]             base::close(...future.stdout)
[11:01:52.009]         }, add = TRUE)
[11:01:52.009]     }
[11:01:52.009]     ...future.frame <- base::sys.nframe()
[11:01:52.009]     ...future.conditions <- base::list()
[11:01:52.009]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.009]     if (FALSE) {
[11:01:52.009]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.009]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.009]     }
[11:01:52.009]     ...future.result <- base::tryCatch({
[11:01:52.009]         base::withCallingHandlers({
[11:01:52.009]             ...future.value <- base::withVisible(base::local(1))
[11:01:52.009]             future::FutureResult(value = ...future.value$value, 
[11:01:52.009]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.009]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.009]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.009]                     ...future.globalenv.names))
[11:01:52.009]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.009]         }, condition = base::local({
[11:01:52.009]             c <- base::c
[11:01:52.009]             inherits <- base::inherits
[11:01:52.009]             invokeRestart <- base::invokeRestart
[11:01:52.009]             length <- base::length
[11:01:52.009]             list <- base::list
[11:01:52.009]             seq.int <- base::seq.int
[11:01:52.009]             signalCondition <- base::signalCondition
[11:01:52.009]             sys.calls <- base::sys.calls
[11:01:52.009]             `[[` <- base::`[[`
[11:01:52.009]             `+` <- base::`+`
[11:01:52.009]             `<<-` <- base::`<<-`
[11:01:52.009]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.009]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.009]                   3L)]
[11:01:52.009]             }
[11:01:52.009]             function(cond) {
[11:01:52.009]                 is_error <- inherits(cond, "error")
[11:01:52.009]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.009]                   NULL)
[11:01:52.009]                 if (is_error) {
[11:01:52.009]                   sessionInformation <- function() {
[11:01:52.009]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.009]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.009]                       search = base::search(), system = base::Sys.info())
[11:01:52.009]                   }
[11:01:52.009]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.009]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.009]                     cond$call), session = sessionInformation(), 
[11:01:52.009]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.009]                   signalCondition(cond)
[11:01:52.009]                 }
[11:01:52.009]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.009]                 "immediateCondition"))) {
[11:01:52.009]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.009]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.009]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.009]                   if (TRUE && !signal) {
[11:01:52.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.009]                     {
[11:01:52.009]                       inherits <- base::inherits
[11:01:52.009]                       invokeRestart <- base::invokeRestart
[11:01:52.009]                       is.null <- base::is.null
[11:01:52.009]                       muffled <- FALSE
[11:01:52.009]                       if (inherits(cond, "message")) {
[11:01:52.009]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.009]                         if (muffled) 
[11:01:52.009]                           invokeRestart("muffleMessage")
[11:01:52.009]                       }
[11:01:52.009]                       else if (inherits(cond, "warning")) {
[11:01:52.009]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.009]                         if (muffled) 
[11:01:52.009]                           invokeRestart("muffleWarning")
[11:01:52.009]                       }
[11:01:52.009]                       else if (inherits(cond, "condition")) {
[11:01:52.009]                         if (!is.null(pattern)) {
[11:01:52.009]                           computeRestarts <- base::computeRestarts
[11:01:52.009]                           grepl <- base::grepl
[11:01:52.009]                           restarts <- computeRestarts(cond)
[11:01:52.009]                           for (restart in restarts) {
[11:01:52.009]                             name <- restart$name
[11:01:52.009]                             if (is.null(name)) 
[11:01:52.009]                               next
[11:01:52.009]                             if (!grepl(pattern, name)) 
[11:01:52.009]                               next
[11:01:52.009]                             invokeRestart(restart)
[11:01:52.009]                             muffled <- TRUE
[11:01:52.009]                             break
[11:01:52.009]                           }
[11:01:52.009]                         }
[11:01:52.009]                       }
[11:01:52.009]                       invisible(muffled)
[11:01:52.009]                     }
[11:01:52.009]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.009]                   }
[11:01:52.009]                 }
[11:01:52.009]                 else {
[11:01:52.009]                   if (TRUE) {
[11:01:52.009]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.009]                     {
[11:01:52.009]                       inherits <- base::inherits
[11:01:52.009]                       invokeRestart <- base::invokeRestart
[11:01:52.009]                       is.null <- base::is.null
[11:01:52.009]                       muffled <- FALSE
[11:01:52.009]                       if (inherits(cond, "message")) {
[11:01:52.009]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.009]                         if (muffled) 
[11:01:52.009]                           invokeRestart("muffleMessage")
[11:01:52.009]                       }
[11:01:52.009]                       else if (inherits(cond, "warning")) {
[11:01:52.009]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.009]                         if (muffled) 
[11:01:52.009]                           invokeRestart("muffleWarning")
[11:01:52.009]                       }
[11:01:52.009]                       else if (inherits(cond, "condition")) {
[11:01:52.009]                         if (!is.null(pattern)) {
[11:01:52.009]                           computeRestarts <- base::computeRestarts
[11:01:52.009]                           grepl <- base::grepl
[11:01:52.009]                           restarts <- computeRestarts(cond)
[11:01:52.009]                           for (restart in restarts) {
[11:01:52.009]                             name <- restart$name
[11:01:52.009]                             if (is.null(name)) 
[11:01:52.009]                               next
[11:01:52.009]                             if (!grepl(pattern, name)) 
[11:01:52.009]                               next
[11:01:52.009]                             invokeRestart(restart)
[11:01:52.009]                             muffled <- TRUE
[11:01:52.009]                             break
[11:01:52.009]                           }
[11:01:52.009]                         }
[11:01:52.009]                       }
[11:01:52.009]                       invisible(muffled)
[11:01:52.009]                     }
[11:01:52.009]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.009]                   }
[11:01:52.009]                 }
[11:01:52.009]             }
[11:01:52.009]         }))
[11:01:52.009]     }, error = function(ex) {
[11:01:52.009]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.009]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.009]                 ...future.rng), started = ...future.startTime, 
[11:01:52.009]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.009]             version = "1.8"), class = "FutureResult")
[11:01:52.009]     }, finally = {
[11:01:52.009]         if (!identical(...future.workdir, getwd())) 
[11:01:52.009]             setwd(...future.workdir)
[11:01:52.009]         {
[11:01:52.009]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.009]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.009]             }
[11:01:52.009]             base::options(...future.oldOptions)
[11:01:52.009]             if (.Platform$OS.type == "windows") {
[11:01:52.009]                 old_names <- names(...future.oldEnvVars)
[11:01:52.009]                 envs <- base::Sys.getenv()
[11:01:52.009]                 names <- names(envs)
[11:01:52.009]                 common <- intersect(names, old_names)
[11:01:52.009]                 added <- setdiff(names, old_names)
[11:01:52.009]                 removed <- setdiff(old_names, names)
[11:01:52.009]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.009]                   envs[common]]
[11:01:52.009]                 NAMES <- toupper(changed)
[11:01:52.009]                 args <- list()
[11:01:52.009]                 for (kk in seq_along(NAMES)) {
[11:01:52.009]                   name <- changed[[kk]]
[11:01:52.009]                   NAME <- NAMES[[kk]]
[11:01:52.009]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.009]                     next
[11:01:52.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.009]                 }
[11:01:52.009]                 NAMES <- toupper(added)
[11:01:52.009]                 for (kk in seq_along(NAMES)) {
[11:01:52.009]                   name <- added[[kk]]
[11:01:52.009]                   NAME <- NAMES[[kk]]
[11:01:52.009]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.009]                     next
[11:01:52.009]                   args[[name]] <- ""
[11:01:52.009]                 }
[11:01:52.009]                 NAMES <- toupper(removed)
[11:01:52.009]                 for (kk in seq_along(NAMES)) {
[11:01:52.009]                   name <- removed[[kk]]
[11:01:52.009]                   NAME <- NAMES[[kk]]
[11:01:52.009]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.009]                     next
[11:01:52.009]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.009]                 }
[11:01:52.009]                 if (length(args) > 0) 
[11:01:52.009]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.009]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.009]             }
[11:01:52.009]             else {
[11:01:52.009]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.009]             }
[11:01:52.009]             {
[11:01:52.009]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.009]                   0L) {
[11:01:52.009]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.009]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.009]                   base::options(opts)
[11:01:52.009]                 }
[11:01:52.009]                 {
[11:01:52.009]                   {
[11:01:52.009]                     NULL
[11:01:52.009]                     RNGkind("Mersenne-Twister")
[11:01:52.009]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.009]                       inherits = FALSE)
[11:01:52.009]                   }
[11:01:52.009]                   options(future.plan = NULL)
[11:01:52.009]                   if (is.na(NA_character_)) 
[11:01:52.009]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.009]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.009]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.009]                     .init = FALSE)
[11:01:52.009]                 }
[11:01:52.009]             }
[11:01:52.009]         }
[11:01:52.009]     })
[11:01:52.009]     if (TRUE) {
[11:01:52.009]         base::sink(type = "output", split = FALSE)
[11:01:52.009]         if (TRUE) {
[11:01:52.009]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.009]         }
[11:01:52.009]         else {
[11:01:52.009]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.009]         }
[11:01:52.009]         base::close(...future.stdout)
[11:01:52.009]         ...future.stdout <- NULL
[11:01:52.009]     }
[11:01:52.009]     ...future.result$conditions <- ...future.conditions
[11:01:52.009]     ...future.result$finished <- base::Sys.time()
[11:01:52.009]     ...future.result
[11:01:52.009] }
[11:01:52.011] plan(): Setting new future strategy stack:
[11:01:52.011] List of future strategies:
[11:01:52.011] 1. sequential:
[11:01:52.011]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.011]    - tweaked: FALSE
[11:01:52.011]    - call: NULL
[11:01:52.011] plan(): nbrOfWorkers() = 1
[11:01:52.012] plan(): Setting new future strategy stack:
[11:01:52.012] List of future strategies:
[11:01:52.012] 1. sequential:
[11:01:52.012]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.012]    - tweaked: FALSE
[11:01:52.012]    - call: plan(strategy)
[11:01:52.013] plan(): nbrOfWorkers() = 1
[11:01:52.013] SequentialFuture started (and completed)
[11:01:52.013] - Launch lazy future ... done
[11:01:52.013] run() for ‘SequentialFuture’ ... done
[11:01:52.013] resolved() for ‘SequentialFuture’ ...
[11:01:52.013] - state: ‘finished’
[11:01:52.013] - run: TRUE
[11:01:52.013] - result: ‘FutureResult’
[11:01:52.013] resolved() for ‘SequentialFuture’ ... done
[11:01:52.013] Future #1
[11:01:52.014] resolved() for ‘SequentialFuture’ ...
[11:01:52.014] - state: ‘finished’
[11:01:52.014] - run: TRUE
[11:01:52.014] - result: ‘FutureResult’
[11:01:52.014] resolved() for ‘SequentialFuture’ ... done
[11:01:52.014] A SequentialFuture was resolved
[11:01:52.014]  length: 0 (resolved future 1)
[11:01:52.014] resolve() on list ... DONE
[11:01:52.014] - globals: [1] ‘a’
[11:01:52.014] Resolving futures part of globals (recursively) ... DONE
[11:01:52.014] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[11:01:52.015] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[11:01:52.015] - globals: [1] ‘a’
[11:01:52.015] - packages: [1] ‘future’
[11:01:52.015] getGlobalsAndPackages() ... DONE
[11:01:52.015] run() for ‘Future’ ...
[11:01:52.015] - state: ‘created’
[11:01:52.015] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.016] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.016] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.016]   - Field: ‘label’
[11:01:52.016]   - Field: ‘local’
[11:01:52.016]   - Field: ‘owner’
[11:01:52.016]   - Field: ‘envir’
[11:01:52.016]   - Field: ‘packages’
[11:01:52.016]   - Field: ‘gc’
[11:01:52.016]   - Field: ‘conditions’
[11:01:52.016]   - Field: ‘expr’
[11:01:52.016]   - Field: ‘uuid’
[11:01:52.017]   - Field: ‘seed’
[11:01:52.017]   - Field: ‘version’
[11:01:52.017]   - Field: ‘result’
[11:01:52.017]   - Field: ‘asynchronous’
[11:01:52.017]   - Field: ‘calls’
[11:01:52.017]   - Field: ‘globals’
[11:01:52.017]   - Field: ‘stdout’
[11:01:52.017]   - Field: ‘earlySignal’
[11:01:52.017]   - Field: ‘lazy’
[11:01:52.017]   - Field: ‘state’
[11:01:52.017] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.017] - Launch lazy future ...
[11:01:52.018] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.018] Packages needed by future strategies (n = 0): <none>
[11:01:52.018] {
[11:01:52.018]     {
[11:01:52.018]         {
[11:01:52.018]             ...future.startTime <- base::Sys.time()
[11:01:52.018]             {
[11:01:52.018]                 {
[11:01:52.018]                   {
[11:01:52.018]                     {
[11:01:52.018]                       base::local({
[11:01:52.018]                         has_future <- base::requireNamespace("future", 
[11:01:52.018]                           quietly = TRUE)
[11:01:52.018]                         if (has_future) {
[11:01:52.018]                           ns <- base::getNamespace("future")
[11:01:52.018]                           version <- ns[[".package"]][["version"]]
[11:01:52.018]                           if (is.null(version)) 
[11:01:52.018]                             version <- utils::packageVersion("future")
[11:01:52.018]                         }
[11:01:52.018]                         else {
[11:01:52.018]                           version <- NULL
[11:01:52.018]                         }
[11:01:52.018]                         if (!has_future || version < "1.8.0") {
[11:01:52.018]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.018]                             "", base::R.version$version.string), 
[11:01:52.018]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.018]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.018]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.018]                               "release", "version")], collapse = " "), 
[11:01:52.018]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.018]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.018]                             info)
[11:01:52.018]                           info <- base::paste(info, collapse = "; ")
[11:01:52.018]                           if (!has_future) {
[11:01:52.018]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.018]                               info)
[11:01:52.018]                           }
[11:01:52.018]                           else {
[11:01:52.018]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.018]                               info, version)
[11:01:52.018]                           }
[11:01:52.018]                           base::stop(msg)
[11:01:52.018]                         }
[11:01:52.018]                       })
[11:01:52.018]                     }
[11:01:52.018]                     base::local({
[11:01:52.018]                       for (pkg in "future") {
[11:01:52.018]                         base::loadNamespace(pkg)
[11:01:52.018]                         base::library(pkg, character.only = TRUE)
[11:01:52.018]                       }
[11:01:52.018]                     })
[11:01:52.018]                   }
[11:01:52.018]                   ...future.strategy.old <- future::plan("list")
[11:01:52.018]                   options(future.plan = NULL)
[11:01:52.018]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.018]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.018]                 }
[11:01:52.018]                 ...future.workdir <- getwd()
[11:01:52.018]             }
[11:01:52.018]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.018]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.018]         }
[11:01:52.018]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.018]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.018]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.018]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.018]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.018]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.018]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.018]             base::names(...future.oldOptions))
[11:01:52.018]     }
[11:01:52.018]     if (FALSE) {
[11:01:52.018]     }
[11:01:52.018]     else {
[11:01:52.018]         if (TRUE) {
[11:01:52.018]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.018]                 open = "w")
[11:01:52.018]         }
[11:01:52.018]         else {
[11:01:52.018]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.018]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.018]         }
[11:01:52.018]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.018]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.018]             base::sink(type = "output", split = FALSE)
[11:01:52.018]             base::close(...future.stdout)
[11:01:52.018]         }, add = TRUE)
[11:01:52.018]     }
[11:01:52.018]     ...future.frame <- base::sys.nframe()
[11:01:52.018]     ...future.conditions <- base::list()
[11:01:52.018]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.018]     if (FALSE) {
[11:01:52.018]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.018]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.018]     }
[11:01:52.018]     ...future.result <- base::tryCatch({
[11:01:52.018]         base::withCallingHandlers({
[11:01:52.018]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:52.018]                 1))
[11:01:52.018]             future::FutureResult(value = ...future.value$value, 
[11:01:52.018]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.018]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.018]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.018]                     ...future.globalenv.names))
[11:01:52.018]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.018]         }, condition = base::local({
[11:01:52.018]             c <- base::c
[11:01:52.018]             inherits <- base::inherits
[11:01:52.018]             invokeRestart <- base::invokeRestart
[11:01:52.018]             length <- base::length
[11:01:52.018]             list <- base::list
[11:01:52.018]             seq.int <- base::seq.int
[11:01:52.018]             signalCondition <- base::signalCondition
[11:01:52.018]             sys.calls <- base::sys.calls
[11:01:52.018]             `[[` <- base::`[[`
[11:01:52.018]             `+` <- base::`+`
[11:01:52.018]             `<<-` <- base::`<<-`
[11:01:52.018]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.018]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.018]                   3L)]
[11:01:52.018]             }
[11:01:52.018]             function(cond) {
[11:01:52.018]                 is_error <- inherits(cond, "error")
[11:01:52.018]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.018]                   NULL)
[11:01:52.018]                 if (is_error) {
[11:01:52.018]                   sessionInformation <- function() {
[11:01:52.018]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.018]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.018]                       search = base::search(), system = base::Sys.info())
[11:01:52.018]                   }
[11:01:52.018]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.018]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.018]                     cond$call), session = sessionInformation(), 
[11:01:52.018]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.018]                   signalCondition(cond)
[11:01:52.018]                 }
[11:01:52.018]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.018]                 "immediateCondition"))) {
[11:01:52.018]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.018]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.018]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.018]                   if (TRUE && !signal) {
[11:01:52.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.018]                     {
[11:01:52.018]                       inherits <- base::inherits
[11:01:52.018]                       invokeRestart <- base::invokeRestart
[11:01:52.018]                       is.null <- base::is.null
[11:01:52.018]                       muffled <- FALSE
[11:01:52.018]                       if (inherits(cond, "message")) {
[11:01:52.018]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.018]                         if (muffled) 
[11:01:52.018]                           invokeRestart("muffleMessage")
[11:01:52.018]                       }
[11:01:52.018]                       else if (inherits(cond, "warning")) {
[11:01:52.018]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.018]                         if (muffled) 
[11:01:52.018]                           invokeRestart("muffleWarning")
[11:01:52.018]                       }
[11:01:52.018]                       else if (inherits(cond, "condition")) {
[11:01:52.018]                         if (!is.null(pattern)) {
[11:01:52.018]                           computeRestarts <- base::computeRestarts
[11:01:52.018]                           grepl <- base::grepl
[11:01:52.018]                           restarts <- computeRestarts(cond)
[11:01:52.018]                           for (restart in restarts) {
[11:01:52.018]                             name <- restart$name
[11:01:52.018]                             if (is.null(name)) 
[11:01:52.018]                               next
[11:01:52.018]                             if (!grepl(pattern, name)) 
[11:01:52.018]                               next
[11:01:52.018]                             invokeRestart(restart)
[11:01:52.018]                             muffled <- TRUE
[11:01:52.018]                             break
[11:01:52.018]                           }
[11:01:52.018]                         }
[11:01:52.018]                       }
[11:01:52.018]                       invisible(muffled)
[11:01:52.018]                     }
[11:01:52.018]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.018]                   }
[11:01:52.018]                 }
[11:01:52.018]                 else {
[11:01:52.018]                   if (TRUE) {
[11:01:52.018]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.018]                     {
[11:01:52.018]                       inherits <- base::inherits
[11:01:52.018]                       invokeRestart <- base::invokeRestart
[11:01:52.018]                       is.null <- base::is.null
[11:01:52.018]                       muffled <- FALSE
[11:01:52.018]                       if (inherits(cond, "message")) {
[11:01:52.018]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.018]                         if (muffled) 
[11:01:52.018]                           invokeRestart("muffleMessage")
[11:01:52.018]                       }
[11:01:52.018]                       else if (inherits(cond, "warning")) {
[11:01:52.018]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.018]                         if (muffled) 
[11:01:52.018]                           invokeRestart("muffleWarning")
[11:01:52.018]                       }
[11:01:52.018]                       else if (inherits(cond, "condition")) {
[11:01:52.018]                         if (!is.null(pattern)) {
[11:01:52.018]                           computeRestarts <- base::computeRestarts
[11:01:52.018]                           grepl <- base::grepl
[11:01:52.018]                           restarts <- computeRestarts(cond)
[11:01:52.018]                           for (restart in restarts) {
[11:01:52.018]                             name <- restart$name
[11:01:52.018]                             if (is.null(name)) 
[11:01:52.018]                               next
[11:01:52.018]                             if (!grepl(pattern, name)) 
[11:01:52.018]                               next
[11:01:52.018]                             invokeRestart(restart)
[11:01:52.018]                             muffled <- TRUE
[11:01:52.018]                             break
[11:01:52.018]                           }
[11:01:52.018]                         }
[11:01:52.018]                       }
[11:01:52.018]                       invisible(muffled)
[11:01:52.018]                     }
[11:01:52.018]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.018]                   }
[11:01:52.018]                 }
[11:01:52.018]             }
[11:01:52.018]         }))
[11:01:52.018]     }, error = function(ex) {
[11:01:52.018]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.018]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.018]                 ...future.rng), started = ...future.startTime, 
[11:01:52.018]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.018]             version = "1.8"), class = "FutureResult")
[11:01:52.018]     }, finally = {
[11:01:52.018]         if (!identical(...future.workdir, getwd())) 
[11:01:52.018]             setwd(...future.workdir)
[11:01:52.018]         {
[11:01:52.018]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.018]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.018]             }
[11:01:52.018]             base::options(...future.oldOptions)
[11:01:52.018]             if (.Platform$OS.type == "windows") {
[11:01:52.018]                 old_names <- names(...future.oldEnvVars)
[11:01:52.018]                 envs <- base::Sys.getenv()
[11:01:52.018]                 names <- names(envs)
[11:01:52.018]                 common <- intersect(names, old_names)
[11:01:52.018]                 added <- setdiff(names, old_names)
[11:01:52.018]                 removed <- setdiff(old_names, names)
[11:01:52.018]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.018]                   envs[common]]
[11:01:52.018]                 NAMES <- toupper(changed)
[11:01:52.018]                 args <- list()
[11:01:52.018]                 for (kk in seq_along(NAMES)) {
[11:01:52.018]                   name <- changed[[kk]]
[11:01:52.018]                   NAME <- NAMES[[kk]]
[11:01:52.018]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.018]                     next
[11:01:52.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.018]                 }
[11:01:52.018]                 NAMES <- toupper(added)
[11:01:52.018]                 for (kk in seq_along(NAMES)) {
[11:01:52.018]                   name <- added[[kk]]
[11:01:52.018]                   NAME <- NAMES[[kk]]
[11:01:52.018]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.018]                     next
[11:01:52.018]                   args[[name]] <- ""
[11:01:52.018]                 }
[11:01:52.018]                 NAMES <- toupper(removed)
[11:01:52.018]                 for (kk in seq_along(NAMES)) {
[11:01:52.018]                   name <- removed[[kk]]
[11:01:52.018]                   NAME <- NAMES[[kk]]
[11:01:52.018]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.018]                     next
[11:01:52.018]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.018]                 }
[11:01:52.018]                 if (length(args) > 0) 
[11:01:52.018]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.018]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.018]             }
[11:01:52.018]             else {
[11:01:52.018]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.018]             }
[11:01:52.018]             {
[11:01:52.018]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.018]                   0L) {
[11:01:52.018]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.018]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.018]                   base::options(opts)
[11:01:52.018]                 }
[11:01:52.018]                 {
[11:01:52.018]                   {
[11:01:52.018]                     NULL
[11:01:52.018]                     RNGkind("Mersenne-Twister")
[11:01:52.018]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.018]                       inherits = FALSE)
[11:01:52.018]                   }
[11:01:52.018]                   options(future.plan = NULL)
[11:01:52.018]                   if (is.na(NA_character_)) 
[11:01:52.018]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.018]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.018]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.018]                     .init = FALSE)
[11:01:52.018]                 }
[11:01:52.018]             }
[11:01:52.018]         }
[11:01:52.018]     })
[11:01:52.018]     if (TRUE) {
[11:01:52.018]         base::sink(type = "output", split = FALSE)
[11:01:52.018]         if (TRUE) {
[11:01:52.018]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.018]         }
[11:01:52.018]         else {
[11:01:52.018]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.018]         }
[11:01:52.018]         base::close(...future.stdout)
[11:01:52.018]         ...future.stdout <- NULL
[11:01:52.018]     }
[11:01:52.018]     ...future.result$conditions <- ...future.conditions
[11:01:52.018]     ...future.result$finished <- base::Sys.time()
[11:01:52.018]     ...future.result
[11:01:52.018] }
[11:01:52.020] assign_globals() ...
[11:01:52.020] List of 1
[11:01:52.020]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eece6bffe8> 
[11:01:52.020]  - attr(*, "where")=List of 1
[11:01:52.020]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.020]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.020]  - attr(*, "resolved")= logi TRUE
[11:01:52.020]  - attr(*, "total_size")= num 3555
[11:01:52.020]  - attr(*, "already-done")= logi TRUE
[11:01:52.022] - copied ‘a’ to environment
[11:01:52.022] assign_globals() ... done
[11:01:52.022] plan(): Setting new future strategy stack:
[11:01:52.022] List of future strategies:
[11:01:52.022] 1. sequential:
[11:01:52.022]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.022]    - tweaked: FALSE
[11:01:52.022]    - call: NULL
[11:01:52.023] plan(): nbrOfWorkers() = 1
[11:01:52.024] plan(): Setting new future strategy stack:
[11:01:52.024] List of future strategies:
[11:01:52.024] 1. sequential:
[11:01:52.024]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.024]    - tweaked: FALSE
[11:01:52.024]    - call: plan(strategy)
[11:01:52.024] plan(): nbrOfWorkers() = 1
[11:01:52.024] SequentialFuture started (and completed)
[11:01:52.024] - Launch lazy future ... done
[11:01:52.024] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.025] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.025] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.026] - globals found: [2] ‘{’, ‘pkg’
[11:01:52.026] Searching for globals ... DONE
[11:01:52.026] Resolving globals: TRUE
[11:01:52.026] Resolving any globals that are futures ...
[11:01:52.026] - globals: [2] ‘{’, ‘pkg’
[11:01:52.026] Resolving any globals that are futures ... DONE
[11:01:52.026] Resolving futures part of globals (recursively) ...
[11:01:52.027] resolve() on list ...
[11:01:52.027]  recursive: 99
[11:01:52.027]  length: 1
[11:01:52.027]  elements: ‘pkg’
[11:01:52.027]  length: 0 (resolved future 1)
[11:01:52.027] resolve() on list ... DONE
[11:01:52.027] - globals: [1] ‘pkg’
[11:01:52.027] Resolving futures part of globals (recursively) ... DONE
[11:01:52.027] The total size of the 1 globals is 42 bytes (42 bytes)
[11:01:52.028] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[11:01:52.028] - globals: [1] ‘pkg’
[11:01:52.028] 
[11:01:52.028] getGlobalsAndPackages() ... DONE
[11:01:52.028] Packages needed by the future expression (n = 0): <none>
[11:01:52.028] Packages needed by future strategies (n = 0): <none>
[11:01:52.028] {
[11:01:52.028]     {
[11:01:52.028]         {
[11:01:52.028]             ...future.startTime <- base::Sys.time()
[11:01:52.028]             {
[11:01:52.028]                 {
[11:01:52.028]                   {
[11:01:52.028]                     base::local({
[11:01:52.028]                       has_future <- base::requireNamespace("future", 
[11:01:52.028]                         quietly = TRUE)
[11:01:52.028]                       if (has_future) {
[11:01:52.028]                         ns <- base::getNamespace("future")
[11:01:52.028]                         version <- ns[[".package"]][["version"]]
[11:01:52.028]                         if (is.null(version)) 
[11:01:52.028]                           version <- utils::packageVersion("future")
[11:01:52.028]                       }
[11:01:52.028]                       else {
[11:01:52.028]                         version <- NULL
[11:01:52.028]                       }
[11:01:52.028]                       if (!has_future || version < "1.8.0") {
[11:01:52.028]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.028]                           "", base::R.version$version.string), 
[11:01:52.028]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.028]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.028]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.028]                             "release", "version")], collapse = " "), 
[11:01:52.028]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.028]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.028]                           info)
[11:01:52.028]                         info <- base::paste(info, collapse = "; ")
[11:01:52.028]                         if (!has_future) {
[11:01:52.028]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.028]                             info)
[11:01:52.028]                         }
[11:01:52.028]                         else {
[11:01:52.028]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.028]                             info, version)
[11:01:52.028]                         }
[11:01:52.028]                         base::stop(msg)
[11:01:52.028]                       }
[11:01:52.028]                     })
[11:01:52.028]                   }
[11:01:52.028]                   ...future.strategy.old <- future::plan("list")
[11:01:52.028]                   options(future.plan = NULL)
[11:01:52.028]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.028]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.028]                 }
[11:01:52.028]                 ...future.workdir <- getwd()
[11:01:52.028]             }
[11:01:52.028]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.028]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.028]         }
[11:01:52.028]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.028]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.028]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.028]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.028]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.028]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.028]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.028]             base::names(...future.oldOptions))
[11:01:52.028]     }
[11:01:52.028]     if (FALSE) {
[11:01:52.028]     }
[11:01:52.028]     else {
[11:01:52.028]         if (TRUE) {
[11:01:52.028]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.028]                 open = "w")
[11:01:52.028]         }
[11:01:52.028]         else {
[11:01:52.028]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.028]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.028]         }
[11:01:52.028]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.028]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.028]             base::sink(type = "output", split = FALSE)
[11:01:52.028]             base::close(...future.stdout)
[11:01:52.028]         }, add = TRUE)
[11:01:52.028]     }
[11:01:52.028]     ...future.frame <- base::sys.nframe()
[11:01:52.028]     ...future.conditions <- base::list()
[11:01:52.028]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.028]     if (FALSE) {
[11:01:52.028]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.028]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.028]     }
[11:01:52.028]     ...future.result <- base::tryCatch({
[11:01:52.028]         base::withCallingHandlers({
[11:01:52.028]             ...future.value <- base::withVisible(base::local({
[11:01:52.028]                 pkg
[11:01:52.028]             }))
[11:01:52.028]             future::FutureResult(value = ...future.value$value, 
[11:01:52.028]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.028]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.028]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.028]                     ...future.globalenv.names))
[11:01:52.028]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.028]         }, condition = base::local({
[11:01:52.028]             c <- base::c
[11:01:52.028]             inherits <- base::inherits
[11:01:52.028]             invokeRestart <- base::invokeRestart
[11:01:52.028]             length <- base::length
[11:01:52.028]             list <- base::list
[11:01:52.028]             seq.int <- base::seq.int
[11:01:52.028]             signalCondition <- base::signalCondition
[11:01:52.028]             sys.calls <- base::sys.calls
[11:01:52.028]             `[[` <- base::`[[`
[11:01:52.028]             `+` <- base::`+`
[11:01:52.028]             `<<-` <- base::`<<-`
[11:01:52.028]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.028]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.028]                   3L)]
[11:01:52.028]             }
[11:01:52.028]             function(cond) {
[11:01:52.028]                 is_error <- inherits(cond, "error")
[11:01:52.028]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.028]                   NULL)
[11:01:52.028]                 if (is_error) {
[11:01:52.028]                   sessionInformation <- function() {
[11:01:52.028]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.028]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.028]                       search = base::search(), system = base::Sys.info())
[11:01:52.028]                   }
[11:01:52.028]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.028]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.028]                     cond$call), session = sessionInformation(), 
[11:01:52.028]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.028]                   signalCondition(cond)
[11:01:52.028]                 }
[11:01:52.028]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.028]                 "immediateCondition"))) {
[11:01:52.028]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.028]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.028]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.028]                   if (TRUE && !signal) {
[11:01:52.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.028]                     {
[11:01:52.028]                       inherits <- base::inherits
[11:01:52.028]                       invokeRestart <- base::invokeRestart
[11:01:52.028]                       is.null <- base::is.null
[11:01:52.028]                       muffled <- FALSE
[11:01:52.028]                       if (inherits(cond, "message")) {
[11:01:52.028]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.028]                         if (muffled) 
[11:01:52.028]                           invokeRestart("muffleMessage")
[11:01:52.028]                       }
[11:01:52.028]                       else if (inherits(cond, "warning")) {
[11:01:52.028]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.028]                         if (muffled) 
[11:01:52.028]                           invokeRestart("muffleWarning")
[11:01:52.028]                       }
[11:01:52.028]                       else if (inherits(cond, "condition")) {
[11:01:52.028]                         if (!is.null(pattern)) {
[11:01:52.028]                           computeRestarts <- base::computeRestarts
[11:01:52.028]                           grepl <- base::grepl
[11:01:52.028]                           restarts <- computeRestarts(cond)
[11:01:52.028]                           for (restart in restarts) {
[11:01:52.028]                             name <- restart$name
[11:01:52.028]                             if (is.null(name)) 
[11:01:52.028]                               next
[11:01:52.028]                             if (!grepl(pattern, name)) 
[11:01:52.028]                               next
[11:01:52.028]                             invokeRestart(restart)
[11:01:52.028]                             muffled <- TRUE
[11:01:52.028]                             break
[11:01:52.028]                           }
[11:01:52.028]                         }
[11:01:52.028]                       }
[11:01:52.028]                       invisible(muffled)
[11:01:52.028]                     }
[11:01:52.028]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.028]                   }
[11:01:52.028]                 }
[11:01:52.028]                 else {
[11:01:52.028]                   if (TRUE) {
[11:01:52.028]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.028]                     {
[11:01:52.028]                       inherits <- base::inherits
[11:01:52.028]                       invokeRestart <- base::invokeRestart
[11:01:52.028]                       is.null <- base::is.null
[11:01:52.028]                       muffled <- FALSE
[11:01:52.028]                       if (inherits(cond, "message")) {
[11:01:52.028]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.028]                         if (muffled) 
[11:01:52.028]                           invokeRestart("muffleMessage")
[11:01:52.028]                       }
[11:01:52.028]                       else if (inherits(cond, "warning")) {
[11:01:52.028]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.028]                         if (muffled) 
[11:01:52.028]                           invokeRestart("muffleWarning")
[11:01:52.028]                       }
[11:01:52.028]                       else if (inherits(cond, "condition")) {
[11:01:52.028]                         if (!is.null(pattern)) {
[11:01:52.028]                           computeRestarts <- base::computeRestarts
[11:01:52.028]                           grepl <- base::grepl
[11:01:52.028]                           restarts <- computeRestarts(cond)
[11:01:52.028]                           for (restart in restarts) {
[11:01:52.028]                             name <- restart$name
[11:01:52.028]                             if (is.null(name)) 
[11:01:52.028]                               next
[11:01:52.028]                             if (!grepl(pattern, name)) 
[11:01:52.028]                               next
[11:01:52.028]                             invokeRestart(restart)
[11:01:52.028]                             muffled <- TRUE
[11:01:52.028]                             break
[11:01:52.028]                           }
[11:01:52.028]                         }
[11:01:52.028]                       }
[11:01:52.028]                       invisible(muffled)
[11:01:52.028]                     }
[11:01:52.028]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.028]                   }
[11:01:52.028]                 }
[11:01:52.028]             }
[11:01:52.028]         }))
[11:01:52.028]     }, error = function(ex) {
[11:01:52.028]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.028]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.028]                 ...future.rng), started = ...future.startTime, 
[11:01:52.028]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.028]             version = "1.8"), class = "FutureResult")
[11:01:52.028]     }, finally = {
[11:01:52.028]         if (!identical(...future.workdir, getwd())) 
[11:01:52.028]             setwd(...future.workdir)
[11:01:52.028]         {
[11:01:52.028]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.028]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.028]             }
[11:01:52.028]             base::options(...future.oldOptions)
[11:01:52.028]             if (.Platform$OS.type == "windows") {
[11:01:52.028]                 old_names <- names(...future.oldEnvVars)
[11:01:52.028]                 envs <- base::Sys.getenv()
[11:01:52.028]                 names <- names(envs)
[11:01:52.028]                 common <- intersect(names, old_names)
[11:01:52.028]                 added <- setdiff(names, old_names)
[11:01:52.028]                 removed <- setdiff(old_names, names)
[11:01:52.028]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.028]                   envs[common]]
[11:01:52.028]                 NAMES <- toupper(changed)
[11:01:52.028]                 args <- list()
[11:01:52.028]                 for (kk in seq_along(NAMES)) {
[11:01:52.028]                   name <- changed[[kk]]
[11:01:52.028]                   NAME <- NAMES[[kk]]
[11:01:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.028]                     next
[11:01:52.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.028]                 }
[11:01:52.028]                 NAMES <- toupper(added)
[11:01:52.028]                 for (kk in seq_along(NAMES)) {
[11:01:52.028]                   name <- added[[kk]]
[11:01:52.028]                   NAME <- NAMES[[kk]]
[11:01:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.028]                     next
[11:01:52.028]                   args[[name]] <- ""
[11:01:52.028]                 }
[11:01:52.028]                 NAMES <- toupper(removed)
[11:01:52.028]                 for (kk in seq_along(NAMES)) {
[11:01:52.028]                   name <- removed[[kk]]
[11:01:52.028]                   NAME <- NAMES[[kk]]
[11:01:52.028]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.028]                     next
[11:01:52.028]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.028]                 }
[11:01:52.028]                 if (length(args) > 0) 
[11:01:52.028]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.028]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.028]             }
[11:01:52.028]             else {
[11:01:52.028]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.028]             }
[11:01:52.028]             {
[11:01:52.028]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.028]                   0L) {
[11:01:52.028]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.028]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.028]                   base::options(opts)
[11:01:52.028]                 }
[11:01:52.028]                 {
[11:01:52.028]                   {
[11:01:52.028]                     NULL
[11:01:52.028]                     RNGkind("Mersenne-Twister")
[11:01:52.028]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.028]                       inherits = FALSE)
[11:01:52.028]                   }
[11:01:52.028]                   options(future.plan = NULL)
[11:01:52.028]                   if (is.na(NA_character_)) 
[11:01:52.028]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.028]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.028]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.028]                     .init = FALSE)
[11:01:52.028]                 }
[11:01:52.028]             }
[11:01:52.028]         }
[11:01:52.028]     })
[11:01:52.028]     if (TRUE) {
[11:01:52.028]         base::sink(type = "output", split = FALSE)
[11:01:52.028]         if (TRUE) {
[11:01:52.028]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.028]         }
[11:01:52.028]         else {
[11:01:52.028]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.028]         }
[11:01:52.028]         base::close(...future.stdout)
[11:01:52.028]         ...future.stdout <- NULL
[11:01:52.028]     }
[11:01:52.028]     ...future.result$conditions <- ...future.conditions
[11:01:52.028]     ...future.result$finished <- base::Sys.time()
[11:01:52.028]     ...future.result
[11:01:52.028] }
[11:01:52.030] assign_globals() ...
[11:01:52.030] List of 1
[11:01:52.030]  $ pkg: chr "foo"
[11:01:52.030]  - attr(*, "where")=List of 1
[11:01:52.030]   ..$ pkg:<environment: R_EmptyEnv> 
[11:01:52.030]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.030]  - attr(*, "resolved")= logi TRUE
[11:01:52.030]  - attr(*, "total_size")= num 42
[11:01:52.032] - copied ‘pkg’ to environment
[11:01:52.032] assign_globals() ... done
[11:01:52.033] plan(): Setting new future strategy stack:
[11:01:52.033] List of future strategies:
[11:01:52.033] 1. sequential:
[11:01:52.033]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.033]    - tweaked: FALSE
[11:01:52.033]    - call: NULL
[11:01:52.033] plan(): nbrOfWorkers() = 1
[11:01:52.035] plan(): Setting new future strategy stack:
[11:01:52.035] List of future strategies:
[11:01:52.035] 1. sequential:
[11:01:52.035]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.035]    - tweaked: FALSE
[11:01:52.035]    - call: plan(strategy)
[11:01:52.035] plan(): nbrOfWorkers() = 1
[11:01:52.035] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.036] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.036] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.038] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.038] Searching for globals ... DONE
[11:01:52.038] Resolving globals: TRUE
[11:01:52.039] Resolving any globals that are futures ...
[11:01:52.039] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.039] Resolving any globals that are futures ... DONE
[11:01:52.039] Resolving futures part of globals (recursively) ...
[11:01:52.039] resolve() on list ...
[11:01:52.039]  recursive: 99
[11:01:52.039]  length: 1
[11:01:52.039]  elements: ‘a’
[11:01:52.040]  length: 0 (resolved future 1)
[11:01:52.040] resolve() on list ... DONE
[11:01:52.040] - globals: [1] ‘a’
[11:01:52.040] Resolving futures part of globals (recursively) ... DONE
[11:01:52.040] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:52.040] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:52.040] - globals: [1] ‘a’
[11:01:52.040] 
[11:01:52.040] getGlobalsAndPackages() ... DONE
[11:01:52.041] run() for ‘Future’ ...
[11:01:52.041] - state: ‘created’
[11:01:52.041] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.041] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.041] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.041]   - Field: ‘label’
[11:01:52.041]   - Field: ‘local’
[11:01:52.041]   - Field: ‘owner’
[11:01:52.041]   - Field: ‘envir’
[11:01:52.042]   - Field: ‘packages’
[11:01:52.042]   - Field: ‘gc’
[11:01:52.042]   - Field: ‘conditions’
[11:01:52.042]   - Field: ‘expr’
[11:01:52.042]   - Field: ‘uuid’
[11:01:52.042]   - Field: ‘seed’
[11:01:52.042]   - Field: ‘version’
[11:01:52.042]   - Field: ‘result’
[11:01:52.042]   - Field: ‘asynchronous’
[11:01:52.042]   - Field: ‘calls’
[11:01:52.042]   - Field: ‘globals’
[11:01:52.042]   - Field: ‘stdout’
[11:01:52.043]   - Field: ‘earlySignal’
[11:01:52.043]   - Field: ‘lazy’
[11:01:52.043]   - Field: ‘state’
[11:01:52.043] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.043] - Launch lazy future ...
[11:01:52.043] Packages needed by the future expression (n = 0): <none>
[11:01:52.043] Packages needed by future strategies (n = 0): <none>
[11:01:52.043] {
[11:01:52.043]     {
[11:01:52.043]         {
[11:01:52.043]             ...future.startTime <- base::Sys.time()
[11:01:52.043]             {
[11:01:52.043]                 {
[11:01:52.043]                   {
[11:01:52.043]                     base::local({
[11:01:52.043]                       has_future <- base::requireNamespace("future", 
[11:01:52.043]                         quietly = TRUE)
[11:01:52.043]                       if (has_future) {
[11:01:52.043]                         ns <- base::getNamespace("future")
[11:01:52.043]                         version <- ns[[".package"]][["version"]]
[11:01:52.043]                         if (is.null(version)) 
[11:01:52.043]                           version <- utils::packageVersion("future")
[11:01:52.043]                       }
[11:01:52.043]                       else {
[11:01:52.043]                         version <- NULL
[11:01:52.043]                       }
[11:01:52.043]                       if (!has_future || version < "1.8.0") {
[11:01:52.043]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.043]                           "", base::R.version$version.string), 
[11:01:52.043]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.043]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.043]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.043]                             "release", "version")], collapse = " "), 
[11:01:52.043]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.043]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.043]                           info)
[11:01:52.043]                         info <- base::paste(info, collapse = "; ")
[11:01:52.043]                         if (!has_future) {
[11:01:52.043]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.043]                             info)
[11:01:52.043]                         }
[11:01:52.043]                         else {
[11:01:52.043]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.043]                             info, version)
[11:01:52.043]                         }
[11:01:52.043]                         base::stop(msg)
[11:01:52.043]                       }
[11:01:52.043]                     })
[11:01:52.043]                   }
[11:01:52.043]                   ...future.strategy.old <- future::plan("list")
[11:01:52.043]                   options(future.plan = NULL)
[11:01:52.043]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.043]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.043]                 }
[11:01:52.043]                 ...future.workdir <- getwd()
[11:01:52.043]             }
[11:01:52.043]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.043]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.043]         }
[11:01:52.043]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.043]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.043]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.043]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.043]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.043]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.043]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.043]             base::names(...future.oldOptions))
[11:01:52.043]     }
[11:01:52.043]     if (FALSE) {
[11:01:52.043]     }
[11:01:52.043]     else {
[11:01:52.043]         if (TRUE) {
[11:01:52.043]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.043]                 open = "w")
[11:01:52.043]         }
[11:01:52.043]         else {
[11:01:52.043]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.043]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.043]         }
[11:01:52.043]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.043]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.043]             base::sink(type = "output", split = FALSE)
[11:01:52.043]             base::close(...future.stdout)
[11:01:52.043]         }, add = TRUE)
[11:01:52.043]     }
[11:01:52.043]     ...future.frame <- base::sys.nframe()
[11:01:52.043]     ...future.conditions <- base::list()
[11:01:52.043]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.043]     if (FALSE) {
[11:01:52.043]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.043]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.043]     }
[11:01:52.043]     ...future.result <- base::tryCatch({
[11:01:52.043]         base::withCallingHandlers({
[11:01:52.043]             ...future.value <- base::withVisible(base::local({
[11:01:52.043]                 b <- a
[11:01:52.043]                 a <- 2
[11:01:52.043]                 a * b
[11:01:52.043]             }))
[11:01:52.043]             future::FutureResult(value = ...future.value$value, 
[11:01:52.043]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.043]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.043]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.043]                     ...future.globalenv.names))
[11:01:52.043]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.043]         }, condition = base::local({
[11:01:52.043]             c <- base::c
[11:01:52.043]             inherits <- base::inherits
[11:01:52.043]             invokeRestart <- base::invokeRestart
[11:01:52.043]             length <- base::length
[11:01:52.043]             list <- base::list
[11:01:52.043]             seq.int <- base::seq.int
[11:01:52.043]             signalCondition <- base::signalCondition
[11:01:52.043]             sys.calls <- base::sys.calls
[11:01:52.043]             `[[` <- base::`[[`
[11:01:52.043]             `+` <- base::`+`
[11:01:52.043]             `<<-` <- base::`<<-`
[11:01:52.043]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.043]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.043]                   3L)]
[11:01:52.043]             }
[11:01:52.043]             function(cond) {
[11:01:52.043]                 is_error <- inherits(cond, "error")
[11:01:52.043]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.043]                   NULL)
[11:01:52.043]                 if (is_error) {
[11:01:52.043]                   sessionInformation <- function() {
[11:01:52.043]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.043]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.043]                       search = base::search(), system = base::Sys.info())
[11:01:52.043]                   }
[11:01:52.043]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.043]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.043]                     cond$call), session = sessionInformation(), 
[11:01:52.043]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.043]                   signalCondition(cond)
[11:01:52.043]                 }
[11:01:52.043]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.043]                 "immediateCondition"))) {
[11:01:52.043]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.043]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.043]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.043]                   if (TRUE && !signal) {
[11:01:52.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.043]                     {
[11:01:52.043]                       inherits <- base::inherits
[11:01:52.043]                       invokeRestart <- base::invokeRestart
[11:01:52.043]                       is.null <- base::is.null
[11:01:52.043]                       muffled <- FALSE
[11:01:52.043]                       if (inherits(cond, "message")) {
[11:01:52.043]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.043]                         if (muffled) 
[11:01:52.043]                           invokeRestart("muffleMessage")
[11:01:52.043]                       }
[11:01:52.043]                       else if (inherits(cond, "warning")) {
[11:01:52.043]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.043]                         if (muffled) 
[11:01:52.043]                           invokeRestart("muffleWarning")
[11:01:52.043]                       }
[11:01:52.043]                       else if (inherits(cond, "condition")) {
[11:01:52.043]                         if (!is.null(pattern)) {
[11:01:52.043]                           computeRestarts <- base::computeRestarts
[11:01:52.043]                           grepl <- base::grepl
[11:01:52.043]                           restarts <- computeRestarts(cond)
[11:01:52.043]                           for (restart in restarts) {
[11:01:52.043]                             name <- restart$name
[11:01:52.043]                             if (is.null(name)) 
[11:01:52.043]                               next
[11:01:52.043]                             if (!grepl(pattern, name)) 
[11:01:52.043]                               next
[11:01:52.043]                             invokeRestart(restart)
[11:01:52.043]                             muffled <- TRUE
[11:01:52.043]                             break
[11:01:52.043]                           }
[11:01:52.043]                         }
[11:01:52.043]                       }
[11:01:52.043]                       invisible(muffled)
[11:01:52.043]                     }
[11:01:52.043]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.043]                   }
[11:01:52.043]                 }
[11:01:52.043]                 else {
[11:01:52.043]                   if (TRUE) {
[11:01:52.043]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.043]                     {
[11:01:52.043]                       inherits <- base::inherits
[11:01:52.043]                       invokeRestart <- base::invokeRestart
[11:01:52.043]                       is.null <- base::is.null
[11:01:52.043]                       muffled <- FALSE
[11:01:52.043]                       if (inherits(cond, "message")) {
[11:01:52.043]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.043]                         if (muffled) 
[11:01:52.043]                           invokeRestart("muffleMessage")
[11:01:52.043]                       }
[11:01:52.043]                       else if (inherits(cond, "warning")) {
[11:01:52.043]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.043]                         if (muffled) 
[11:01:52.043]                           invokeRestart("muffleWarning")
[11:01:52.043]                       }
[11:01:52.043]                       else if (inherits(cond, "condition")) {
[11:01:52.043]                         if (!is.null(pattern)) {
[11:01:52.043]                           computeRestarts <- base::computeRestarts
[11:01:52.043]                           grepl <- base::grepl
[11:01:52.043]                           restarts <- computeRestarts(cond)
[11:01:52.043]                           for (restart in restarts) {
[11:01:52.043]                             name <- restart$name
[11:01:52.043]                             if (is.null(name)) 
[11:01:52.043]                               next
[11:01:52.043]                             if (!grepl(pattern, name)) 
[11:01:52.043]                               next
[11:01:52.043]                             invokeRestart(restart)
[11:01:52.043]                             muffled <- TRUE
[11:01:52.043]                             break
[11:01:52.043]                           }
[11:01:52.043]                         }
[11:01:52.043]                       }
[11:01:52.043]                       invisible(muffled)
[11:01:52.043]                     }
[11:01:52.043]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.043]                   }
[11:01:52.043]                 }
[11:01:52.043]             }
[11:01:52.043]         }))
[11:01:52.043]     }, error = function(ex) {
[11:01:52.043]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.043]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.043]                 ...future.rng), started = ...future.startTime, 
[11:01:52.043]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.043]             version = "1.8"), class = "FutureResult")
[11:01:52.043]     }, finally = {
[11:01:52.043]         if (!identical(...future.workdir, getwd())) 
[11:01:52.043]             setwd(...future.workdir)
[11:01:52.043]         {
[11:01:52.043]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.043]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.043]             }
[11:01:52.043]             base::options(...future.oldOptions)
[11:01:52.043]             if (.Platform$OS.type == "windows") {
[11:01:52.043]                 old_names <- names(...future.oldEnvVars)
[11:01:52.043]                 envs <- base::Sys.getenv()
[11:01:52.043]                 names <- names(envs)
[11:01:52.043]                 common <- intersect(names, old_names)
[11:01:52.043]                 added <- setdiff(names, old_names)
[11:01:52.043]                 removed <- setdiff(old_names, names)
[11:01:52.043]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.043]                   envs[common]]
[11:01:52.043]                 NAMES <- toupper(changed)
[11:01:52.043]                 args <- list()
[11:01:52.043]                 for (kk in seq_along(NAMES)) {
[11:01:52.043]                   name <- changed[[kk]]
[11:01:52.043]                   NAME <- NAMES[[kk]]
[11:01:52.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.043]                     next
[11:01:52.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.043]                 }
[11:01:52.043]                 NAMES <- toupper(added)
[11:01:52.043]                 for (kk in seq_along(NAMES)) {
[11:01:52.043]                   name <- added[[kk]]
[11:01:52.043]                   NAME <- NAMES[[kk]]
[11:01:52.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.043]                     next
[11:01:52.043]                   args[[name]] <- ""
[11:01:52.043]                 }
[11:01:52.043]                 NAMES <- toupper(removed)
[11:01:52.043]                 for (kk in seq_along(NAMES)) {
[11:01:52.043]                   name <- removed[[kk]]
[11:01:52.043]                   NAME <- NAMES[[kk]]
[11:01:52.043]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.043]                     next
[11:01:52.043]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.043]                 }
[11:01:52.043]                 if (length(args) > 0) 
[11:01:52.043]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.043]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.043]             }
[11:01:52.043]             else {
[11:01:52.043]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.043]             }
[11:01:52.043]             {
[11:01:52.043]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.043]                   0L) {
[11:01:52.043]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.043]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.043]                   base::options(opts)
[11:01:52.043]                 }
[11:01:52.043]                 {
[11:01:52.043]                   {
[11:01:52.043]                     NULL
[11:01:52.043]                     RNGkind("Mersenne-Twister")
[11:01:52.043]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.043]                       inherits = FALSE)
[11:01:52.043]                   }
[11:01:52.043]                   options(future.plan = NULL)
[11:01:52.043]                   if (is.na(NA_character_)) 
[11:01:52.043]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.043]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.043]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.043]                     .init = FALSE)
[11:01:52.043]                 }
[11:01:52.043]             }
[11:01:52.043]         }
[11:01:52.043]     })
[11:01:52.043]     if (TRUE) {
[11:01:52.043]         base::sink(type = "output", split = FALSE)
[11:01:52.043]         if (TRUE) {
[11:01:52.043]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.043]         }
[11:01:52.043]         else {
[11:01:52.043]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.043]         }
[11:01:52.043]         base::close(...future.stdout)
[11:01:52.043]         ...future.stdout <- NULL
[11:01:52.043]     }
[11:01:52.043]     ...future.result$conditions <- ...future.conditions
[11:01:52.043]     ...future.result$finished <- base::Sys.time()
[11:01:52.043]     ...future.result
[11:01:52.043] }
[11:01:52.045] assign_globals() ...
[11:01:52.045] List of 1
[11:01:52.045]  $ a: num 3
[11:01:52.045]  - attr(*, "where")=List of 1
[11:01:52.045]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.045]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.045]  - attr(*, "resolved")= logi TRUE
[11:01:52.045]  - attr(*, "total_size")= num 39
[11:01:52.045]  - attr(*, "already-done")= logi TRUE
[11:01:52.047] - copied ‘a’ to environment
[11:01:52.047] assign_globals() ... done
[11:01:52.048] plan(): Setting new future strategy stack:
[11:01:52.048] List of future strategies:
[11:01:52.048] 1. sequential:
[11:01:52.048]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.048]    - tweaked: FALSE
[11:01:52.048]    - call: NULL
[11:01:52.048] plan(): nbrOfWorkers() = 1
[11:01:52.049] plan(): Setting new future strategy stack:
[11:01:52.049] List of future strategies:
[11:01:52.049] 1. sequential:
[11:01:52.049]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.049]    - tweaked: FALSE
[11:01:52.049]    - call: plan(strategy)
[11:01:52.049] plan(): nbrOfWorkers() = 1
[11:01:52.049] SequentialFuture started (and completed)
[11:01:52.050] - Launch lazy future ... done
[11:01:52.050] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.050] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.050] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.052] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.052] Searching for globals ... DONE
[11:01:52.052] Resolving globals: TRUE
[11:01:52.052] Resolving any globals that are futures ...
[11:01:52.052] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.052] Resolving any globals that are futures ... DONE
[11:01:52.053] Resolving futures part of globals (recursively) ...
[11:01:52.053] resolve() on list ...
[11:01:52.053]  recursive: 99
[11:01:52.053]  length: 1
[11:01:52.053]  elements: ‘a’
[11:01:52.053]  length: 0 (resolved future 1)
[11:01:52.053] resolve() on list ... DONE
[11:01:52.053] - globals: [1] ‘a’
[11:01:52.053] Resolving futures part of globals (recursively) ... DONE
[11:01:52.054] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:52.054] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:52.054] - globals: [1] ‘a’
[11:01:52.054] 
[11:01:52.054] getGlobalsAndPackages() ... DONE
[11:01:52.054] run() for ‘Future’ ...
[11:01:52.054] - state: ‘created’
[11:01:52.055] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.055] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.055] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.055]   - Field: ‘label’
[11:01:52.055]   - Field: ‘local’
[11:01:52.055]   - Field: ‘owner’
[11:01:52.055]   - Field: ‘envir’
[11:01:52.055]   - Field: ‘packages’
[11:01:52.055]   - Field: ‘gc’
[11:01:52.056]   - Field: ‘conditions’
[11:01:52.056]   - Field: ‘expr’
[11:01:52.056]   - Field: ‘uuid’
[11:01:52.056]   - Field: ‘seed’
[11:01:52.056]   - Field: ‘version’
[11:01:52.056]   - Field: ‘result’
[11:01:52.056]   - Field: ‘asynchronous’
[11:01:52.056]   - Field: ‘calls’
[11:01:52.056]   - Field: ‘globals’
[11:01:52.056]   - Field: ‘stdout’
[11:01:52.057]   - Field: ‘earlySignal’
[11:01:52.057]   - Field: ‘lazy’
[11:01:52.058]   - Field: ‘state’
[11:01:52.058] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.058] - Launch lazy future ...
[11:01:52.058] Packages needed by the future expression (n = 0): <none>
[11:01:52.058] Packages needed by future strategies (n = 0): <none>
[11:01:52.058] {
[11:01:52.058]     {
[11:01:52.058]         {
[11:01:52.058]             ...future.startTime <- base::Sys.time()
[11:01:52.058]             {
[11:01:52.058]                 {
[11:01:52.058]                   {
[11:01:52.058]                     base::local({
[11:01:52.058]                       has_future <- base::requireNamespace("future", 
[11:01:52.058]                         quietly = TRUE)
[11:01:52.058]                       if (has_future) {
[11:01:52.058]                         ns <- base::getNamespace("future")
[11:01:52.058]                         version <- ns[[".package"]][["version"]]
[11:01:52.058]                         if (is.null(version)) 
[11:01:52.058]                           version <- utils::packageVersion("future")
[11:01:52.058]                       }
[11:01:52.058]                       else {
[11:01:52.058]                         version <- NULL
[11:01:52.058]                       }
[11:01:52.058]                       if (!has_future || version < "1.8.0") {
[11:01:52.058]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.058]                           "", base::R.version$version.string), 
[11:01:52.058]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.058]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.058]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.058]                             "release", "version")], collapse = " "), 
[11:01:52.058]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.058]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.058]                           info)
[11:01:52.058]                         info <- base::paste(info, collapse = "; ")
[11:01:52.058]                         if (!has_future) {
[11:01:52.058]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.058]                             info)
[11:01:52.058]                         }
[11:01:52.058]                         else {
[11:01:52.058]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.058]                             info, version)
[11:01:52.058]                         }
[11:01:52.058]                         base::stop(msg)
[11:01:52.058]                       }
[11:01:52.058]                     })
[11:01:52.058]                   }
[11:01:52.058]                   ...future.strategy.old <- future::plan("list")
[11:01:52.058]                   options(future.plan = NULL)
[11:01:52.058]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.058]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.058]                 }
[11:01:52.058]                 ...future.workdir <- getwd()
[11:01:52.058]             }
[11:01:52.058]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.058]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.058]         }
[11:01:52.058]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.058]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.058]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.058]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.058]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.058]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.058]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.058]             base::names(...future.oldOptions))
[11:01:52.058]     }
[11:01:52.058]     if (FALSE) {
[11:01:52.058]     }
[11:01:52.058]     else {
[11:01:52.058]         if (TRUE) {
[11:01:52.058]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.058]                 open = "w")
[11:01:52.058]         }
[11:01:52.058]         else {
[11:01:52.058]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.058]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.058]         }
[11:01:52.058]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.058]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.058]             base::sink(type = "output", split = FALSE)
[11:01:52.058]             base::close(...future.stdout)
[11:01:52.058]         }, add = TRUE)
[11:01:52.058]     }
[11:01:52.058]     ...future.frame <- base::sys.nframe()
[11:01:52.058]     ...future.conditions <- base::list()
[11:01:52.058]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.058]     if (FALSE) {
[11:01:52.058]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.058]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.058]     }
[11:01:52.058]     ...future.result <- base::tryCatch({
[11:01:52.058]         base::withCallingHandlers({
[11:01:52.058]             ...future.value <- base::withVisible(base::local({
[11:01:52.058]                 b <- a
[11:01:52.058]                 a <- 2
[11:01:52.058]                 a * b
[11:01:52.058]             }))
[11:01:52.058]             future::FutureResult(value = ...future.value$value, 
[11:01:52.058]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.058]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.058]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.058]                     ...future.globalenv.names))
[11:01:52.058]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.058]         }, condition = base::local({
[11:01:52.058]             c <- base::c
[11:01:52.058]             inherits <- base::inherits
[11:01:52.058]             invokeRestart <- base::invokeRestart
[11:01:52.058]             length <- base::length
[11:01:52.058]             list <- base::list
[11:01:52.058]             seq.int <- base::seq.int
[11:01:52.058]             signalCondition <- base::signalCondition
[11:01:52.058]             sys.calls <- base::sys.calls
[11:01:52.058]             `[[` <- base::`[[`
[11:01:52.058]             `+` <- base::`+`
[11:01:52.058]             `<<-` <- base::`<<-`
[11:01:52.058]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.058]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.058]                   3L)]
[11:01:52.058]             }
[11:01:52.058]             function(cond) {
[11:01:52.058]                 is_error <- inherits(cond, "error")
[11:01:52.058]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.058]                   NULL)
[11:01:52.058]                 if (is_error) {
[11:01:52.058]                   sessionInformation <- function() {
[11:01:52.058]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.058]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.058]                       search = base::search(), system = base::Sys.info())
[11:01:52.058]                   }
[11:01:52.058]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.058]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.058]                     cond$call), session = sessionInformation(), 
[11:01:52.058]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.058]                   signalCondition(cond)
[11:01:52.058]                 }
[11:01:52.058]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.058]                 "immediateCondition"))) {
[11:01:52.058]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.058]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.058]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.058]                   if (TRUE && !signal) {
[11:01:52.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.058]                     {
[11:01:52.058]                       inherits <- base::inherits
[11:01:52.058]                       invokeRestart <- base::invokeRestart
[11:01:52.058]                       is.null <- base::is.null
[11:01:52.058]                       muffled <- FALSE
[11:01:52.058]                       if (inherits(cond, "message")) {
[11:01:52.058]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.058]                         if (muffled) 
[11:01:52.058]                           invokeRestart("muffleMessage")
[11:01:52.058]                       }
[11:01:52.058]                       else if (inherits(cond, "warning")) {
[11:01:52.058]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.058]                         if (muffled) 
[11:01:52.058]                           invokeRestart("muffleWarning")
[11:01:52.058]                       }
[11:01:52.058]                       else if (inherits(cond, "condition")) {
[11:01:52.058]                         if (!is.null(pattern)) {
[11:01:52.058]                           computeRestarts <- base::computeRestarts
[11:01:52.058]                           grepl <- base::grepl
[11:01:52.058]                           restarts <- computeRestarts(cond)
[11:01:52.058]                           for (restart in restarts) {
[11:01:52.058]                             name <- restart$name
[11:01:52.058]                             if (is.null(name)) 
[11:01:52.058]                               next
[11:01:52.058]                             if (!grepl(pattern, name)) 
[11:01:52.058]                               next
[11:01:52.058]                             invokeRestart(restart)
[11:01:52.058]                             muffled <- TRUE
[11:01:52.058]                             break
[11:01:52.058]                           }
[11:01:52.058]                         }
[11:01:52.058]                       }
[11:01:52.058]                       invisible(muffled)
[11:01:52.058]                     }
[11:01:52.058]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.058]                   }
[11:01:52.058]                 }
[11:01:52.058]                 else {
[11:01:52.058]                   if (TRUE) {
[11:01:52.058]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.058]                     {
[11:01:52.058]                       inherits <- base::inherits
[11:01:52.058]                       invokeRestart <- base::invokeRestart
[11:01:52.058]                       is.null <- base::is.null
[11:01:52.058]                       muffled <- FALSE
[11:01:52.058]                       if (inherits(cond, "message")) {
[11:01:52.058]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.058]                         if (muffled) 
[11:01:52.058]                           invokeRestart("muffleMessage")
[11:01:52.058]                       }
[11:01:52.058]                       else if (inherits(cond, "warning")) {
[11:01:52.058]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.058]                         if (muffled) 
[11:01:52.058]                           invokeRestart("muffleWarning")
[11:01:52.058]                       }
[11:01:52.058]                       else if (inherits(cond, "condition")) {
[11:01:52.058]                         if (!is.null(pattern)) {
[11:01:52.058]                           computeRestarts <- base::computeRestarts
[11:01:52.058]                           grepl <- base::grepl
[11:01:52.058]                           restarts <- computeRestarts(cond)
[11:01:52.058]                           for (restart in restarts) {
[11:01:52.058]                             name <- restart$name
[11:01:52.058]                             if (is.null(name)) 
[11:01:52.058]                               next
[11:01:52.058]                             if (!grepl(pattern, name)) 
[11:01:52.058]                               next
[11:01:52.058]                             invokeRestart(restart)
[11:01:52.058]                             muffled <- TRUE
[11:01:52.058]                             break
[11:01:52.058]                           }
[11:01:52.058]                         }
[11:01:52.058]                       }
[11:01:52.058]                       invisible(muffled)
[11:01:52.058]                     }
[11:01:52.058]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.058]                   }
[11:01:52.058]                 }
[11:01:52.058]             }
[11:01:52.058]         }))
[11:01:52.058]     }, error = function(ex) {
[11:01:52.058]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.058]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.058]                 ...future.rng), started = ...future.startTime, 
[11:01:52.058]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.058]             version = "1.8"), class = "FutureResult")
[11:01:52.058]     }, finally = {
[11:01:52.058]         if (!identical(...future.workdir, getwd())) 
[11:01:52.058]             setwd(...future.workdir)
[11:01:52.058]         {
[11:01:52.058]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.058]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.058]             }
[11:01:52.058]             base::options(...future.oldOptions)
[11:01:52.058]             if (.Platform$OS.type == "windows") {
[11:01:52.058]                 old_names <- names(...future.oldEnvVars)
[11:01:52.058]                 envs <- base::Sys.getenv()
[11:01:52.058]                 names <- names(envs)
[11:01:52.058]                 common <- intersect(names, old_names)
[11:01:52.058]                 added <- setdiff(names, old_names)
[11:01:52.058]                 removed <- setdiff(old_names, names)
[11:01:52.058]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.058]                   envs[common]]
[11:01:52.058]                 NAMES <- toupper(changed)
[11:01:52.058]                 args <- list()
[11:01:52.058]                 for (kk in seq_along(NAMES)) {
[11:01:52.058]                   name <- changed[[kk]]
[11:01:52.058]                   NAME <- NAMES[[kk]]
[11:01:52.058]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.058]                     next
[11:01:52.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.058]                 }
[11:01:52.058]                 NAMES <- toupper(added)
[11:01:52.058]                 for (kk in seq_along(NAMES)) {
[11:01:52.058]                   name <- added[[kk]]
[11:01:52.058]                   NAME <- NAMES[[kk]]
[11:01:52.058]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.058]                     next
[11:01:52.058]                   args[[name]] <- ""
[11:01:52.058]                 }
[11:01:52.058]                 NAMES <- toupper(removed)
[11:01:52.058]                 for (kk in seq_along(NAMES)) {
[11:01:52.058]                   name <- removed[[kk]]
[11:01:52.058]                   NAME <- NAMES[[kk]]
[11:01:52.058]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.058]                     next
[11:01:52.058]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.058]                 }
[11:01:52.058]                 if (length(args) > 0) 
[11:01:52.058]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.058]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.058]             }
[11:01:52.058]             else {
[11:01:52.058]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.058]             }
[11:01:52.058]             {
[11:01:52.058]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.058]                   0L) {
[11:01:52.058]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.058]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.058]                   base::options(opts)
[11:01:52.058]                 }
[11:01:52.058]                 {
[11:01:52.058]                   {
[11:01:52.058]                     NULL
[11:01:52.058]                     RNGkind("Mersenne-Twister")
[11:01:52.058]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.058]                       inherits = FALSE)
[11:01:52.058]                   }
[11:01:52.058]                   options(future.plan = NULL)
[11:01:52.058]                   if (is.na(NA_character_)) 
[11:01:52.058]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.058]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.058]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.058]                     .init = FALSE)
[11:01:52.058]                 }
[11:01:52.058]             }
[11:01:52.058]         }
[11:01:52.058]     })
[11:01:52.058]     if (TRUE) {
[11:01:52.058]         base::sink(type = "output", split = FALSE)
[11:01:52.058]         if (TRUE) {
[11:01:52.058]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.058]         }
[11:01:52.058]         else {
[11:01:52.058]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.058]         }
[11:01:52.058]         base::close(...future.stdout)
[11:01:52.058]         ...future.stdout <- NULL
[11:01:52.058]     }
[11:01:52.058]     ...future.result$conditions <- ...future.conditions
[11:01:52.058]     ...future.result$finished <- base::Sys.time()
[11:01:52.058]     ...future.result
[11:01:52.058] }
[11:01:52.060] assign_globals() ...
[11:01:52.060] List of 1
[11:01:52.060]  $ a: num 3
[11:01:52.060]  - attr(*, "where")=List of 1
[11:01:52.060]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.060]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.060]  - attr(*, "resolved")= logi TRUE
[11:01:52.060]  - attr(*, "total_size")= num 39
[11:01:52.060]  - attr(*, "already-done")= logi TRUE
[11:01:52.062] - copied ‘a’ to environment
[11:01:52.062] assign_globals() ... done
[11:01:52.063] plan(): Setting new future strategy stack:
[11:01:52.063] List of future strategies:
[11:01:52.063] 1. sequential:
[11:01:52.063]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.063]    - tweaked: FALSE
[11:01:52.063]    - call: NULL
[11:01:52.063] plan(): nbrOfWorkers() = 1
[11:01:52.064] plan(): Setting new future strategy stack:
[11:01:52.064] List of future strategies:
[11:01:52.064] 1. sequential:
[11:01:52.064]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.064]    - tweaked: FALSE
[11:01:52.064]    - call: plan(strategy)
[11:01:52.064] plan(): nbrOfWorkers() = 1
[11:01:52.064] SequentialFuture started (and completed)
[11:01:52.064] - Launch lazy future ... done
[11:01:52.065] run() for ‘SequentialFuture’ ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.065] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.065] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.067] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.067] Searching for globals ... DONE
[11:01:52.067] Resolving globals: TRUE
[11:01:52.067] Resolving any globals that are futures ...
[11:01:52.067] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.067] Resolving any globals that are futures ... DONE
[11:01:52.068] Resolving futures part of globals (recursively) ...
[11:01:52.068] resolve() on list ...
[11:01:52.068]  recursive: 99
[11:01:52.068]  length: 2
[11:01:52.068]  elements: ‘a’, ‘ii’
[11:01:52.068]  length: 1 (resolved future 1)
[11:01:52.068]  length: 0 (resolved future 2)
[11:01:52.068] resolve() on list ... DONE
[11:01:52.068] - globals: [2] ‘a’, ‘ii’
[11:01:52.069] Resolving futures part of globals (recursively) ... DONE
[11:01:52.069] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.069] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.069] - globals: [2] ‘a’, ‘ii’
[11:01:52.069] 
[11:01:52.069] getGlobalsAndPackages() ... DONE
[11:01:52.070] run() for ‘Future’ ...
[11:01:52.070] - state: ‘created’
[11:01:52.070] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.070] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.070] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.070]   - Field: ‘label’
[11:01:52.070]   - Field: ‘local’
[11:01:52.070]   - Field: ‘owner’
[11:01:52.070]   - Field: ‘envir’
[11:01:52.070]   - Field: ‘packages’
[11:01:52.071]   - Field: ‘gc’
[11:01:52.071]   - Field: ‘conditions’
[11:01:52.071]   - Field: ‘expr’
[11:01:52.071]   - Field: ‘uuid’
[11:01:52.071]   - Field: ‘seed’
[11:01:52.071]   - Field: ‘version’
[11:01:52.071]   - Field: ‘result’
[11:01:52.071]   - Field: ‘asynchronous’
[11:01:52.071]   - Field: ‘calls’
[11:01:52.071]   - Field: ‘globals’
[11:01:52.071]   - Field: ‘stdout’
[11:01:52.071]   - Field: ‘earlySignal’
[11:01:52.071]   - Field: ‘lazy’
[11:01:52.072]   - Field: ‘state’
[11:01:52.072] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.072] - Launch lazy future ...
[11:01:52.072] Packages needed by the future expression (n = 0): <none>
[11:01:52.072] Packages needed by future strategies (n = 0): <none>
[11:01:52.072] {
[11:01:52.072]     {
[11:01:52.072]         {
[11:01:52.072]             ...future.startTime <- base::Sys.time()
[11:01:52.072]             {
[11:01:52.072]                 {
[11:01:52.072]                   {
[11:01:52.072]                     base::local({
[11:01:52.072]                       has_future <- base::requireNamespace("future", 
[11:01:52.072]                         quietly = TRUE)
[11:01:52.072]                       if (has_future) {
[11:01:52.072]                         ns <- base::getNamespace("future")
[11:01:52.072]                         version <- ns[[".package"]][["version"]]
[11:01:52.072]                         if (is.null(version)) 
[11:01:52.072]                           version <- utils::packageVersion("future")
[11:01:52.072]                       }
[11:01:52.072]                       else {
[11:01:52.072]                         version <- NULL
[11:01:52.072]                       }
[11:01:52.072]                       if (!has_future || version < "1.8.0") {
[11:01:52.072]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.072]                           "", base::R.version$version.string), 
[11:01:52.072]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.072]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.072]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.072]                             "release", "version")], collapse = " "), 
[11:01:52.072]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.072]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.072]                           info)
[11:01:52.072]                         info <- base::paste(info, collapse = "; ")
[11:01:52.072]                         if (!has_future) {
[11:01:52.072]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.072]                             info)
[11:01:52.072]                         }
[11:01:52.072]                         else {
[11:01:52.072]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.072]                             info, version)
[11:01:52.072]                         }
[11:01:52.072]                         base::stop(msg)
[11:01:52.072]                       }
[11:01:52.072]                     })
[11:01:52.072]                   }
[11:01:52.072]                   ...future.strategy.old <- future::plan("list")
[11:01:52.072]                   options(future.plan = NULL)
[11:01:52.072]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.072]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.072]                 }
[11:01:52.072]                 ...future.workdir <- getwd()
[11:01:52.072]             }
[11:01:52.072]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.072]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.072]         }
[11:01:52.072]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.072]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.072]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.072]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.072]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.072]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.072]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.072]             base::names(...future.oldOptions))
[11:01:52.072]     }
[11:01:52.072]     if (FALSE) {
[11:01:52.072]     }
[11:01:52.072]     else {
[11:01:52.072]         if (TRUE) {
[11:01:52.072]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.072]                 open = "w")
[11:01:52.072]         }
[11:01:52.072]         else {
[11:01:52.072]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.072]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.072]         }
[11:01:52.072]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.072]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.072]             base::sink(type = "output", split = FALSE)
[11:01:52.072]             base::close(...future.stdout)
[11:01:52.072]         }, add = TRUE)
[11:01:52.072]     }
[11:01:52.072]     ...future.frame <- base::sys.nframe()
[11:01:52.072]     ...future.conditions <- base::list()
[11:01:52.072]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.072]     if (FALSE) {
[11:01:52.072]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.072]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.072]     }
[11:01:52.072]     ...future.result <- base::tryCatch({
[11:01:52.072]         base::withCallingHandlers({
[11:01:52.072]             ...future.value <- base::withVisible(base::local({
[11:01:52.072]                 b <- a * ii
[11:01:52.072]                 a <- 0
[11:01:52.072]                 b
[11:01:52.072]             }))
[11:01:52.072]             future::FutureResult(value = ...future.value$value, 
[11:01:52.072]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.072]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.072]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.072]                     ...future.globalenv.names))
[11:01:52.072]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.072]         }, condition = base::local({
[11:01:52.072]             c <- base::c
[11:01:52.072]             inherits <- base::inherits
[11:01:52.072]             invokeRestart <- base::invokeRestart
[11:01:52.072]             length <- base::length
[11:01:52.072]             list <- base::list
[11:01:52.072]             seq.int <- base::seq.int
[11:01:52.072]             signalCondition <- base::signalCondition
[11:01:52.072]             sys.calls <- base::sys.calls
[11:01:52.072]             `[[` <- base::`[[`
[11:01:52.072]             `+` <- base::`+`
[11:01:52.072]             `<<-` <- base::`<<-`
[11:01:52.072]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.072]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.072]                   3L)]
[11:01:52.072]             }
[11:01:52.072]             function(cond) {
[11:01:52.072]                 is_error <- inherits(cond, "error")
[11:01:52.072]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.072]                   NULL)
[11:01:52.072]                 if (is_error) {
[11:01:52.072]                   sessionInformation <- function() {
[11:01:52.072]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.072]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.072]                       search = base::search(), system = base::Sys.info())
[11:01:52.072]                   }
[11:01:52.072]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.072]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.072]                     cond$call), session = sessionInformation(), 
[11:01:52.072]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.072]                   signalCondition(cond)
[11:01:52.072]                 }
[11:01:52.072]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.072]                 "immediateCondition"))) {
[11:01:52.072]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.072]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.072]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.072]                   if (TRUE && !signal) {
[11:01:52.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.072]                     {
[11:01:52.072]                       inherits <- base::inherits
[11:01:52.072]                       invokeRestart <- base::invokeRestart
[11:01:52.072]                       is.null <- base::is.null
[11:01:52.072]                       muffled <- FALSE
[11:01:52.072]                       if (inherits(cond, "message")) {
[11:01:52.072]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.072]                         if (muffled) 
[11:01:52.072]                           invokeRestart("muffleMessage")
[11:01:52.072]                       }
[11:01:52.072]                       else if (inherits(cond, "warning")) {
[11:01:52.072]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.072]                         if (muffled) 
[11:01:52.072]                           invokeRestart("muffleWarning")
[11:01:52.072]                       }
[11:01:52.072]                       else if (inherits(cond, "condition")) {
[11:01:52.072]                         if (!is.null(pattern)) {
[11:01:52.072]                           computeRestarts <- base::computeRestarts
[11:01:52.072]                           grepl <- base::grepl
[11:01:52.072]                           restarts <- computeRestarts(cond)
[11:01:52.072]                           for (restart in restarts) {
[11:01:52.072]                             name <- restart$name
[11:01:52.072]                             if (is.null(name)) 
[11:01:52.072]                               next
[11:01:52.072]                             if (!grepl(pattern, name)) 
[11:01:52.072]                               next
[11:01:52.072]                             invokeRestart(restart)
[11:01:52.072]                             muffled <- TRUE
[11:01:52.072]                             break
[11:01:52.072]                           }
[11:01:52.072]                         }
[11:01:52.072]                       }
[11:01:52.072]                       invisible(muffled)
[11:01:52.072]                     }
[11:01:52.072]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.072]                   }
[11:01:52.072]                 }
[11:01:52.072]                 else {
[11:01:52.072]                   if (TRUE) {
[11:01:52.072]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.072]                     {
[11:01:52.072]                       inherits <- base::inherits
[11:01:52.072]                       invokeRestart <- base::invokeRestart
[11:01:52.072]                       is.null <- base::is.null
[11:01:52.072]                       muffled <- FALSE
[11:01:52.072]                       if (inherits(cond, "message")) {
[11:01:52.072]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.072]                         if (muffled) 
[11:01:52.072]                           invokeRestart("muffleMessage")
[11:01:52.072]                       }
[11:01:52.072]                       else if (inherits(cond, "warning")) {
[11:01:52.072]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.072]                         if (muffled) 
[11:01:52.072]                           invokeRestart("muffleWarning")
[11:01:52.072]                       }
[11:01:52.072]                       else if (inherits(cond, "condition")) {
[11:01:52.072]                         if (!is.null(pattern)) {
[11:01:52.072]                           computeRestarts <- base::computeRestarts
[11:01:52.072]                           grepl <- base::grepl
[11:01:52.072]                           restarts <- computeRestarts(cond)
[11:01:52.072]                           for (restart in restarts) {
[11:01:52.072]                             name <- restart$name
[11:01:52.072]                             if (is.null(name)) 
[11:01:52.072]                               next
[11:01:52.072]                             if (!grepl(pattern, name)) 
[11:01:52.072]                               next
[11:01:52.072]                             invokeRestart(restart)
[11:01:52.072]                             muffled <- TRUE
[11:01:52.072]                             break
[11:01:52.072]                           }
[11:01:52.072]                         }
[11:01:52.072]                       }
[11:01:52.072]                       invisible(muffled)
[11:01:52.072]                     }
[11:01:52.072]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.072]                   }
[11:01:52.072]                 }
[11:01:52.072]             }
[11:01:52.072]         }))
[11:01:52.072]     }, error = function(ex) {
[11:01:52.072]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.072]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.072]                 ...future.rng), started = ...future.startTime, 
[11:01:52.072]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.072]             version = "1.8"), class = "FutureResult")
[11:01:52.072]     }, finally = {
[11:01:52.072]         if (!identical(...future.workdir, getwd())) 
[11:01:52.072]             setwd(...future.workdir)
[11:01:52.072]         {
[11:01:52.072]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.072]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.072]             }
[11:01:52.072]             base::options(...future.oldOptions)
[11:01:52.072]             if (.Platform$OS.type == "windows") {
[11:01:52.072]                 old_names <- names(...future.oldEnvVars)
[11:01:52.072]                 envs <- base::Sys.getenv()
[11:01:52.072]                 names <- names(envs)
[11:01:52.072]                 common <- intersect(names, old_names)
[11:01:52.072]                 added <- setdiff(names, old_names)
[11:01:52.072]                 removed <- setdiff(old_names, names)
[11:01:52.072]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.072]                   envs[common]]
[11:01:52.072]                 NAMES <- toupper(changed)
[11:01:52.072]                 args <- list()
[11:01:52.072]                 for (kk in seq_along(NAMES)) {
[11:01:52.072]                   name <- changed[[kk]]
[11:01:52.072]                   NAME <- NAMES[[kk]]
[11:01:52.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.072]                     next
[11:01:52.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.072]                 }
[11:01:52.072]                 NAMES <- toupper(added)
[11:01:52.072]                 for (kk in seq_along(NAMES)) {
[11:01:52.072]                   name <- added[[kk]]
[11:01:52.072]                   NAME <- NAMES[[kk]]
[11:01:52.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.072]                     next
[11:01:52.072]                   args[[name]] <- ""
[11:01:52.072]                 }
[11:01:52.072]                 NAMES <- toupper(removed)
[11:01:52.072]                 for (kk in seq_along(NAMES)) {
[11:01:52.072]                   name <- removed[[kk]]
[11:01:52.072]                   NAME <- NAMES[[kk]]
[11:01:52.072]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.072]                     next
[11:01:52.072]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.072]                 }
[11:01:52.072]                 if (length(args) > 0) 
[11:01:52.072]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.072]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.072]             }
[11:01:52.072]             else {
[11:01:52.072]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.072]             }
[11:01:52.072]             {
[11:01:52.072]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.072]                   0L) {
[11:01:52.072]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.072]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.072]                   base::options(opts)
[11:01:52.072]                 }
[11:01:52.072]                 {
[11:01:52.072]                   {
[11:01:52.072]                     NULL
[11:01:52.072]                     RNGkind("Mersenne-Twister")
[11:01:52.072]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.072]                       inherits = FALSE)
[11:01:52.072]                   }
[11:01:52.072]                   options(future.plan = NULL)
[11:01:52.072]                   if (is.na(NA_character_)) 
[11:01:52.072]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.072]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.072]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.072]                     .init = FALSE)
[11:01:52.072]                 }
[11:01:52.072]             }
[11:01:52.072]         }
[11:01:52.072]     })
[11:01:52.072]     if (TRUE) {
[11:01:52.072]         base::sink(type = "output", split = FALSE)
[11:01:52.072]         if (TRUE) {
[11:01:52.072]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.072]         }
[11:01:52.072]         else {
[11:01:52.072]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.072]         }
[11:01:52.072]         base::close(...future.stdout)
[11:01:52.072]         ...future.stdout <- NULL
[11:01:52.072]     }
[11:01:52.072]     ...future.result$conditions <- ...future.conditions
[11:01:52.072]     ...future.result$finished <- base::Sys.time()
[11:01:52.072]     ...future.result
[11:01:52.072] }
[11:01:52.074] assign_globals() ...
[11:01:52.074] List of 2
[11:01:52.074]  $ a : num 1
[11:01:52.074]  $ ii: int 1
[11:01:52.074]  - attr(*, "where")=List of 2
[11:01:52.074]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.074]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.074]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.074]  - attr(*, "resolved")= logi TRUE
[11:01:52.074]  - attr(*, "total_size")= num 74
[11:01:52.074]  - attr(*, "already-done")= logi TRUE
[11:01:52.077] - copied ‘a’ to environment
[11:01:52.077] - copied ‘ii’ to environment
[11:01:52.077] assign_globals() ... done
[11:01:52.077] plan(): Setting new future strategy stack:
[11:01:52.077] List of future strategies:
[11:01:52.077] 1. sequential:
[11:01:52.077]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.077]    - tweaked: FALSE
[11:01:52.077]    - call: NULL
[11:01:52.078] plan(): nbrOfWorkers() = 1
[11:01:52.078] plan(): Setting new future strategy stack:
[11:01:52.078] List of future strategies:
[11:01:52.078] 1. sequential:
[11:01:52.078]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.078]    - tweaked: FALSE
[11:01:52.078]    - call: plan(strategy)
[11:01:52.079] plan(): nbrOfWorkers() = 1
[11:01:52.079] SequentialFuture started (and completed)
[11:01:52.079] - Launch lazy future ... done
[11:01:52.079] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.079] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.080] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.082] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.082] Searching for globals ... DONE
[11:01:52.082] Resolving globals: TRUE
[11:01:52.082] Resolving any globals that are futures ...
[11:01:52.083] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.083] Resolving any globals that are futures ... DONE
[11:01:52.083] Resolving futures part of globals (recursively) ...
[11:01:52.083] resolve() on list ...
[11:01:52.083]  recursive: 99
[11:01:52.083]  length: 2
[11:01:52.083]  elements: ‘a’, ‘ii’
[11:01:52.084]  length: 1 (resolved future 1)
[11:01:52.084]  length: 0 (resolved future 2)
[11:01:52.084] resolve() on list ... DONE
[11:01:52.084] - globals: [2] ‘a’, ‘ii’
[11:01:52.084] Resolving futures part of globals (recursively) ... DONE
[11:01:52.084] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.084] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.084] - globals: [2] ‘a’, ‘ii’
[11:01:52.084] 
[11:01:52.085] getGlobalsAndPackages() ... DONE
[11:01:52.085] run() for ‘Future’ ...
[11:01:52.085] - state: ‘created’
[11:01:52.085] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.085] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.085] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.085]   - Field: ‘label’
[11:01:52.086]   - Field: ‘local’
[11:01:52.086]   - Field: ‘owner’
[11:01:52.086]   - Field: ‘envir’
[11:01:52.086]   - Field: ‘packages’
[11:01:52.086]   - Field: ‘gc’
[11:01:52.086]   - Field: ‘conditions’
[11:01:52.086]   - Field: ‘expr’
[11:01:52.086]   - Field: ‘uuid’
[11:01:52.086]   - Field: ‘seed’
[11:01:52.086]   - Field: ‘version’
[11:01:52.086]   - Field: ‘result’
[11:01:52.086]   - Field: ‘asynchronous’
[11:01:52.086]   - Field: ‘calls’
[11:01:52.087]   - Field: ‘globals’
[11:01:52.087]   - Field: ‘stdout’
[11:01:52.087]   - Field: ‘earlySignal’
[11:01:52.087]   - Field: ‘lazy’
[11:01:52.087]   - Field: ‘state’
[11:01:52.087] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.087] - Launch lazy future ...
[11:01:52.087] Packages needed by the future expression (n = 0): <none>
[11:01:52.087] Packages needed by future strategies (n = 0): <none>
[11:01:52.088] {
[11:01:52.088]     {
[11:01:52.088]         {
[11:01:52.088]             ...future.startTime <- base::Sys.time()
[11:01:52.088]             {
[11:01:52.088]                 {
[11:01:52.088]                   {
[11:01:52.088]                     base::local({
[11:01:52.088]                       has_future <- base::requireNamespace("future", 
[11:01:52.088]                         quietly = TRUE)
[11:01:52.088]                       if (has_future) {
[11:01:52.088]                         ns <- base::getNamespace("future")
[11:01:52.088]                         version <- ns[[".package"]][["version"]]
[11:01:52.088]                         if (is.null(version)) 
[11:01:52.088]                           version <- utils::packageVersion("future")
[11:01:52.088]                       }
[11:01:52.088]                       else {
[11:01:52.088]                         version <- NULL
[11:01:52.088]                       }
[11:01:52.088]                       if (!has_future || version < "1.8.0") {
[11:01:52.088]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.088]                           "", base::R.version$version.string), 
[11:01:52.088]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.088]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.088]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.088]                             "release", "version")], collapse = " "), 
[11:01:52.088]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.088]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.088]                           info)
[11:01:52.088]                         info <- base::paste(info, collapse = "; ")
[11:01:52.088]                         if (!has_future) {
[11:01:52.088]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.088]                             info)
[11:01:52.088]                         }
[11:01:52.088]                         else {
[11:01:52.088]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.088]                             info, version)
[11:01:52.088]                         }
[11:01:52.088]                         base::stop(msg)
[11:01:52.088]                       }
[11:01:52.088]                     })
[11:01:52.088]                   }
[11:01:52.088]                   ...future.strategy.old <- future::plan("list")
[11:01:52.088]                   options(future.plan = NULL)
[11:01:52.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.088]                 }
[11:01:52.088]                 ...future.workdir <- getwd()
[11:01:52.088]             }
[11:01:52.088]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.088]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.088]         }
[11:01:52.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.088]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.088]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.088]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.088]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.088]             base::names(...future.oldOptions))
[11:01:52.088]     }
[11:01:52.088]     if (FALSE) {
[11:01:52.088]     }
[11:01:52.088]     else {
[11:01:52.088]         if (TRUE) {
[11:01:52.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.088]                 open = "w")
[11:01:52.088]         }
[11:01:52.088]         else {
[11:01:52.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.088]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.088]         }
[11:01:52.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.088]             base::sink(type = "output", split = FALSE)
[11:01:52.088]             base::close(...future.stdout)
[11:01:52.088]         }, add = TRUE)
[11:01:52.088]     }
[11:01:52.088]     ...future.frame <- base::sys.nframe()
[11:01:52.088]     ...future.conditions <- base::list()
[11:01:52.088]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.088]     if (FALSE) {
[11:01:52.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.088]     }
[11:01:52.088]     ...future.result <- base::tryCatch({
[11:01:52.088]         base::withCallingHandlers({
[11:01:52.088]             ...future.value <- base::withVisible(base::local({
[11:01:52.088]                 b <- a * ii
[11:01:52.088]                 a <- 0
[11:01:52.088]                 b
[11:01:52.088]             }))
[11:01:52.088]             future::FutureResult(value = ...future.value$value, 
[11:01:52.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.088]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.088]                     ...future.globalenv.names))
[11:01:52.088]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.088]         }, condition = base::local({
[11:01:52.088]             c <- base::c
[11:01:52.088]             inherits <- base::inherits
[11:01:52.088]             invokeRestart <- base::invokeRestart
[11:01:52.088]             length <- base::length
[11:01:52.088]             list <- base::list
[11:01:52.088]             seq.int <- base::seq.int
[11:01:52.088]             signalCondition <- base::signalCondition
[11:01:52.088]             sys.calls <- base::sys.calls
[11:01:52.088]             `[[` <- base::`[[`
[11:01:52.088]             `+` <- base::`+`
[11:01:52.088]             `<<-` <- base::`<<-`
[11:01:52.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.088]                   3L)]
[11:01:52.088]             }
[11:01:52.088]             function(cond) {
[11:01:52.088]                 is_error <- inherits(cond, "error")
[11:01:52.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.088]                   NULL)
[11:01:52.088]                 if (is_error) {
[11:01:52.088]                   sessionInformation <- function() {
[11:01:52.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.088]                       search = base::search(), system = base::Sys.info())
[11:01:52.088]                   }
[11:01:52.088]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.088]                     cond$call), session = sessionInformation(), 
[11:01:52.088]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.088]                   signalCondition(cond)
[11:01:52.088]                 }
[11:01:52.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.088]                 "immediateCondition"))) {
[11:01:52.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.088]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.088]                   if (TRUE && !signal) {
[11:01:52.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.088]                     {
[11:01:52.088]                       inherits <- base::inherits
[11:01:52.088]                       invokeRestart <- base::invokeRestart
[11:01:52.088]                       is.null <- base::is.null
[11:01:52.088]                       muffled <- FALSE
[11:01:52.088]                       if (inherits(cond, "message")) {
[11:01:52.088]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.088]                         if (muffled) 
[11:01:52.088]                           invokeRestart("muffleMessage")
[11:01:52.088]                       }
[11:01:52.088]                       else if (inherits(cond, "warning")) {
[11:01:52.088]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.088]                         if (muffled) 
[11:01:52.088]                           invokeRestart("muffleWarning")
[11:01:52.088]                       }
[11:01:52.088]                       else if (inherits(cond, "condition")) {
[11:01:52.088]                         if (!is.null(pattern)) {
[11:01:52.088]                           computeRestarts <- base::computeRestarts
[11:01:52.088]                           grepl <- base::grepl
[11:01:52.088]                           restarts <- computeRestarts(cond)
[11:01:52.088]                           for (restart in restarts) {
[11:01:52.088]                             name <- restart$name
[11:01:52.088]                             if (is.null(name)) 
[11:01:52.088]                               next
[11:01:52.088]                             if (!grepl(pattern, name)) 
[11:01:52.088]                               next
[11:01:52.088]                             invokeRestart(restart)
[11:01:52.088]                             muffled <- TRUE
[11:01:52.088]                             break
[11:01:52.088]                           }
[11:01:52.088]                         }
[11:01:52.088]                       }
[11:01:52.088]                       invisible(muffled)
[11:01:52.088]                     }
[11:01:52.088]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.088]                   }
[11:01:52.088]                 }
[11:01:52.088]                 else {
[11:01:52.088]                   if (TRUE) {
[11:01:52.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.088]                     {
[11:01:52.088]                       inherits <- base::inherits
[11:01:52.088]                       invokeRestart <- base::invokeRestart
[11:01:52.088]                       is.null <- base::is.null
[11:01:52.088]                       muffled <- FALSE
[11:01:52.088]                       if (inherits(cond, "message")) {
[11:01:52.088]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.088]                         if (muffled) 
[11:01:52.088]                           invokeRestart("muffleMessage")
[11:01:52.088]                       }
[11:01:52.088]                       else if (inherits(cond, "warning")) {
[11:01:52.088]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.088]                         if (muffled) 
[11:01:52.088]                           invokeRestart("muffleWarning")
[11:01:52.088]                       }
[11:01:52.088]                       else if (inherits(cond, "condition")) {
[11:01:52.088]                         if (!is.null(pattern)) {
[11:01:52.088]                           computeRestarts <- base::computeRestarts
[11:01:52.088]                           grepl <- base::grepl
[11:01:52.088]                           restarts <- computeRestarts(cond)
[11:01:52.088]                           for (restart in restarts) {
[11:01:52.088]                             name <- restart$name
[11:01:52.088]                             if (is.null(name)) 
[11:01:52.088]                               next
[11:01:52.088]                             if (!grepl(pattern, name)) 
[11:01:52.088]                               next
[11:01:52.088]                             invokeRestart(restart)
[11:01:52.088]                             muffled <- TRUE
[11:01:52.088]                             break
[11:01:52.088]                           }
[11:01:52.088]                         }
[11:01:52.088]                       }
[11:01:52.088]                       invisible(muffled)
[11:01:52.088]                     }
[11:01:52.088]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.088]                   }
[11:01:52.088]                 }
[11:01:52.088]             }
[11:01:52.088]         }))
[11:01:52.088]     }, error = function(ex) {
[11:01:52.088]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.088]                 ...future.rng), started = ...future.startTime, 
[11:01:52.088]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.088]             version = "1.8"), class = "FutureResult")
[11:01:52.088]     }, finally = {
[11:01:52.088]         if (!identical(...future.workdir, getwd())) 
[11:01:52.088]             setwd(...future.workdir)
[11:01:52.088]         {
[11:01:52.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.088]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.088]             }
[11:01:52.088]             base::options(...future.oldOptions)
[11:01:52.088]             if (.Platform$OS.type == "windows") {
[11:01:52.088]                 old_names <- names(...future.oldEnvVars)
[11:01:52.088]                 envs <- base::Sys.getenv()
[11:01:52.088]                 names <- names(envs)
[11:01:52.088]                 common <- intersect(names, old_names)
[11:01:52.088]                 added <- setdiff(names, old_names)
[11:01:52.088]                 removed <- setdiff(old_names, names)
[11:01:52.088]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.088]                   envs[common]]
[11:01:52.088]                 NAMES <- toupper(changed)
[11:01:52.088]                 args <- list()
[11:01:52.088]                 for (kk in seq_along(NAMES)) {
[11:01:52.088]                   name <- changed[[kk]]
[11:01:52.088]                   NAME <- NAMES[[kk]]
[11:01:52.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.088]                     next
[11:01:52.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.088]                 }
[11:01:52.088]                 NAMES <- toupper(added)
[11:01:52.088]                 for (kk in seq_along(NAMES)) {
[11:01:52.088]                   name <- added[[kk]]
[11:01:52.088]                   NAME <- NAMES[[kk]]
[11:01:52.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.088]                     next
[11:01:52.088]                   args[[name]] <- ""
[11:01:52.088]                 }
[11:01:52.088]                 NAMES <- toupper(removed)
[11:01:52.088]                 for (kk in seq_along(NAMES)) {
[11:01:52.088]                   name <- removed[[kk]]
[11:01:52.088]                   NAME <- NAMES[[kk]]
[11:01:52.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.088]                     next
[11:01:52.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.088]                 }
[11:01:52.088]                 if (length(args) > 0) 
[11:01:52.088]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.088]             }
[11:01:52.088]             else {
[11:01:52.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.088]             }
[11:01:52.088]             {
[11:01:52.088]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.088]                   0L) {
[11:01:52.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.088]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.088]                   base::options(opts)
[11:01:52.088]                 }
[11:01:52.088]                 {
[11:01:52.088]                   {
[11:01:52.088]                     NULL
[11:01:52.088]                     RNGkind("Mersenne-Twister")
[11:01:52.088]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.088]                       inherits = FALSE)
[11:01:52.088]                   }
[11:01:52.088]                   options(future.plan = NULL)
[11:01:52.088]                   if (is.na(NA_character_)) 
[11:01:52.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.088]                     .init = FALSE)
[11:01:52.088]                 }
[11:01:52.088]             }
[11:01:52.088]         }
[11:01:52.088]     })
[11:01:52.088]     if (TRUE) {
[11:01:52.088]         base::sink(type = "output", split = FALSE)
[11:01:52.088]         if (TRUE) {
[11:01:52.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.088]         }
[11:01:52.088]         else {
[11:01:52.088]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.088]         }
[11:01:52.088]         base::close(...future.stdout)
[11:01:52.088]         ...future.stdout <- NULL
[11:01:52.088]     }
[11:01:52.088]     ...future.result$conditions <- ...future.conditions
[11:01:52.088]     ...future.result$finished <- base::Sys.time()
[11:01:52.088]     ...future.result
[11:01:52.088] }
[11:01:52.089] assign_globals() ...
[11:01:52.089] List of 2
[11:01:52.089]  $ a : num 1
[11:01:52.089]  $ ii: int 2
[11:01:52.089]  - attr(*, "where")=List of 2
[11:01:52.089]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.089]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.089]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.089]  - attr(*, "resolved")= logi TRUE
[11:01:52.089]  - attr(*, "total_size")= num 74
[11:01:52.089]  - attr(*, "already-done")= logi TRUE
[11:01:52.092] - copied ‘a’ to environment
[11:01:52.092] - copied ‘ii’ to environment
[11:01:52.092] assign_globals() ... done
[11:01:52.092] plan(): Setting new future strategy stack:
[11:01:52.092] List of future strategies:
[11:01:52.092] 1. sequential:
[11:01:52.092]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.092]    - tweaked: FALSE
[11:01:52.092]    - call: NULL
[11:01:52.093] plan(): nbrOfWorkers() = 1
[11:01:52.093] plan(): Setting new future strategy stack:
[11:01:52.094] List of future strategies:
[11:01:52.094] 1. sequential:
[11:01:52.094]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.094]    - tweaked: FALSE
[11:01:52.094]    - call: plan(strategy)
[11:01:52.094] plan(): nbrOfWorkers() = 1
[11:01:52.094] SequentialFuture started (and completed)
[11:01:52.094] - Launch lazy future ... done
[11:01:52.094] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.095] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.095] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.096] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.097] Searching for globals ... DONE
[11:01:52.097] Resolving globals: TRUE
[11:01:52.097] Resolving any globals that are futures ...
[11:01:52.097] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.097] Resolving any globals that are futures ... DONE
[11:01:52.097] Resolving futures part of globals (recursively) ...
[11:01:52.097] resolve() on list ...
[11:01:52.098]  recursive: 99
[11:01:52.098]  length: 2
[11:01:52.098]  elements: ‘a’, ‘ii’
[11:01:52.098]  length: 1 (resolved future 1)
[11:01:52.098]  length: 0 (resolved future 2)
[11:01:52.098] resolve() on list ... DONE
[11:01:52.098] - globals: [2] ‘a’, ‘ii’
[11:01:52.098] Resolving futures part of globals (recursively) ... DONE
[11:01:52.098] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.099] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.099] - globals: [2] ‘a’, ‘ii’
[11:01:52.099] 
[11:01:52.099] getGlobalsAndPackages() ... DONE
[11:01:52.099] run() for ‘Future’ ...
[11:01:52.099] - state: ‘created’
[11:01:52.099] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.099] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.100] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.100]   - Field: ‘label’
[11:01:52.100]   - Field: ‘local’
[11:01:52.100]   - Field: ‘owner’
[11:01:52.100]   - Field: ‘envir’
[11:01:52.100]   - Field: ‘packages’
[11:01:52.100]   - Field: ‘gc’
[11:01:52.100]   - Field: ‘conditions’
[11:01:52.100]   - Field: ‘expr’
[11:01:52.100]   - Field: ‘uuid’
[11:01:52.100]   - Field: ‘seed’
[11:01:52.100]   - Field: ‘version’
[11:01:52.101]   - Field: ‘result’
[11:01:52.101]   - Field: ‘asynchronous’
[11:01:52.101]   - Field: ‘calls’
[11:01:52.101]   - Field: ‘globals’
[11:01:52.101]   - Field: ‘stdout’
[11:01:52.101]   - Field: ‘earlySignal’
[11:01:52.101]   - Field: ‘lazy’
[11:01:52.101]   - Field: ‘state’
[11:01:52.101] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.101] - Launch lazy future ...
[11:01:52.101] Packages needed by the future expression (n = 0): <none>
[11:01:52.102] Packages needed by future strategies (n = 0): <none>
[11:01:52.103] {
[11:01:52.103]     {
[11:01:52.103]         {
[11:01:52.103]             ...future.startTime <- base::Sys.time()
[11:01:52.103]             {
[11:01:52.103]                 {
[11:01:52.103]                   {
[11:01:52.103]                     base::local({
[11:01:52.103]                       has_future <- base::requireNamespace("future", 
[11:01:52.103]                         quietly = TRUE)
[11:01:52.103]                       if (has_future) {
[11:01:52.103]                         ns <- base::getNamespace("future")
[11:01:52.103]                         version <- ns[[".package"]][["version"]]
[11:01:52.103]                         if (is.null(version)) 
[11:01:52.103]                           version <- utils::packageVersion("future")
[11:01:52.103]                       }
[11:01:52.103]                       else {
[11:01:52.103]                         version <- NULL
[11:01:52.103]                       }
[11:01:52.103]                       if (!has_future || version < "1.8.0") {
[11:01:52.103]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.103]                           "", base::R.version$version.string), 
[11:01:52.103]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.103]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.103]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.103]                             "release", "version")], collapse = " "), 
[11:01:52.103]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.103]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.103]                           info)
[11:01:52.103]                         info <- base::paste(info, collapse = "; ")
[11:01:52.103]                         if (!has_future) {
[11:01:52.103]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.103]                             info)
[11:01:52.103]                         }
[11:01:52.103]                         else {
[11:01:52.103]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.103]                             info, version)
[11:01:52.103]                         }
[11:01:52.103]                         base::stop(msg)
[11:01:52.103]                       }
[11:01:52.103]                     })
[11:01:52.103]                   }
[11:01:52.103]                   ...future.strategy.old <- future::plan("list")
[11:01:52.103]                   options(future.plan = NULL)
[11:01:52.103]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.103]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.103]                 }
[11:01:52.103]                 ...future.workdir <- getwd()
[11:01:52.103]             }
[11:01:52.103]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.103]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.103]         }
[11:01:52.103]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.103]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.103]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.103]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.103]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.103]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.103]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.103]             base::names(...future.oldOptions))
[11:01:52.103]     }
[11:01:52.103]     if (FALSE) {
[11:01:52.103]     }
[11:01:52.103]     else {
[11:01:52.103]         if (TRUE) {
[11:01:52.103]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.103]                 open = "w")
[11:01:52.103]         }
[11:01:52.103]         else {
[11:01:52.103]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.103]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.103]         }
[11:01:52.103]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.103]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.103]             base::sink(type = "output", split = FALSE)
[11:01:52.103]             base::close(...future.stdout)
[11:01:52.103]         }, add = TRUE)
[11:01:52.103]     }
[11:01:52.103]     ...future.frame <- base::sys.nframe()
[11:01:52.103]     ...future.conditions <- base::list()
[11:01:52.103]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.103]     if (FALSE) {
[11:01:52.103]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.103]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.103]     }
[11:01:52.103]     ...future.result <- base::tryCatch({
[11:01:52.103]         base::withCallingHandlers({
[11:01:52.103]             ...future.value <- base::withVisible(base::local({
[11:01:52.103]                 b <- a * ii
[11:01:52.103]                 a <- 0
[11:01:52.103]                 b
[11:01:52.103]             }))
[11:01:52.103]             future::FutureResult(value = ...future.value$value, 
[11:01:52.103]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.103]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.103]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.103]                     ...future.globalenv.names))
[11:01:52.103]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.103]         }, condition = base::local({
[11:01:52.103]             c <- base::c
[11:01:52.103]             inherits <- base::inherits
[11:01:52.103]             invokeRestart <- base::invokeRestart
[11:01:52.103]             length <- base::length
[11:01:52.103]             list <- base::list
[11:01:52.103]             seq.int <- base::seq.int
[11:01:52.103]             signalCondition <- base::signalCondition
[11:01:52.103]             sys.calls <- base::sys.calls
[11:01:52.103]             `[[` <- base::`[[`
[11:01:52.103]             `+` <- base::`+`
[11:01:52.103]             `<<-` <- base::`<<-`
[11:01:52.103]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.103]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.103]                   3L)]
[11:01:52.103]             }
[11:01:52.103]             function(cond) {
[11:01:52.103]                 is_error <- inherits(cond, "error")
[11:01:52.103]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.103]                   NULL)
[11:01:52.103]                 if (is_error) {
[11:01:52.103]                   sessionInformation <- function() {
[11:01:52.103]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.103]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.103]                       search = base::search(), system = base::Sys.info())
[11:01:52.103]                   }
[11:01:52.103]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.103]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.103]                     cond$call), session = sessionInformation(), 
[11:01:52.103]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.103]                   signalCondition(cond)
[11:01:52.103]                 }
[11:01:52.103]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.103]                 "immediateCondition"))) {
[11:01:52.103]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.103]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.103]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.103]                   if (TRUE && !signal) {
[11:01:52.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.103]                     {
[11:01:52.103]                       inherits <- base::inherits
[11:01:52.103]                       invokeRestart <- base::invokeRestart
[11:01:52.103]                       is.null <- base::is.null
[11:01:52.103]                       muffled <- FALSE
[11:01:52.103]                       if (inherits(cond, "message")) {
[11:01:52.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.103]                         if (muffled) 
[11:01:52.103]                           invokeRestart("muffleMessage")
[11:01:52.103]                       }
[11:01:52.103]                       else if (inherits(cond, "warning")) {
[11:01:52.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.103]                         if (muffled) 
[11:01:52.103]                           invokeRestart("muffleWarning")
[11:01:52.103]                       }
[11:01:52.103]                       else if (inherits(cond, "condition")) {
[11:01:52.103]                         if (!is.null(pattern)) {
[11:01:52.103]                           computeRestarts <- base::computeRestarts
[11:01:52.103]                           grepl <- base::grepl
[11:01:52.103]                           restarts <- computeRestarts(cond)
[11:01:52.103]                           for (restart in restarts) {
[11:01:52.103]                             name <- restart$name
[11:01:52.103]                             if (is.null(name)) 
[11:01:52.103]                               next
[11:01:52.103]                             if (!grepl(pattern, name)) 
[11:01:52.103]                               next
[11:01:52.103]                             invokeRestart(restart)
[11:01:52.103]                             muffled <- TRUE
[11:01:52.103]                             break
[11:01:52.103]                           }
[11:01:52.103]                         }
[11:01:52.103]                       }
[11:01:52.103]                       invisible(muffled)
[11:01:52.103]                     }
[11:01:52.103]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.103]                   }
[11:01:52.103]                 }
[11:01:52.103]                 else {
[11:01:52.103]                   if (TRUE) {
[11:01:52.103]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.103]                     {
[11:01:52.103]                       inherits <- base::inherits
[11:01:52.103]                       invokeRestart <- base::invokeRestart
[11:01:52.103]                       is.null <- base::is.null
[11:01:52.103]                       muffled <- FALSE
[11:01:52.103]                       if (inherits(cond, "message")) {
[11:01:52.103]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.103]                         if (muffled) 
[11:01:52.103]                           invokeRestart("muffleMessage")
[11:01:52.103]                       }
[11:01:52.103]                       else if (inherits(cond, "warning")) {
[11:01:52.103]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.103]                         if (muffled) 
[11:01:52.103]                           invokeRestart("muffleWarning")
[11:01:52.103]                       }
[11:01:52.103]                       else if (inherits(cond, "condition")) {
[11:01:52.103]                         if (!is.null(pattern)) {
[11:01:52.103]                           computeRestarts <- base::computeRestarts
[11:01:52.103]                           grepl <- base::grepl
[11:01:52.103]                           restarts <- computeRestarts(cond)
[11:01:52.103]                           for (restart in restarts) {
[11:01:52.103]                             name <- restart$name
[11:01:52.103]                             if (is.null(name)) 
[11:01:52.103]                               next
[11:01:52.103]                             if (!grepl(pattern, name)) 
[11:01:52.103]                               next
[11:01:52.103]                             invokeRestart(restart)
[11:01:52.103]                             muffled <- TRUE
[11:01:52.103]                             break
[11:01:52.103]                           }
[11:01:52.103]                         }
[11:01:52.103]                       }
[11:01:52.103]                       invisible(muffled)
[11:01:52.103]                     }
[11:01:52.103]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.103]                   }
[11:01:52.103]                 }
[11:01:52.103]             }
[11:01:52.103]         }))
[11:01:52.103]     }, error = function(ex) {
[11:01:52.103]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.103]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.103]                 ...future.rng), started = ...future.startTime, 
[11:01:52.103]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.103]             version = "1.8"), class = "FutureResult")
[11:01:52.103]     }, finally = {
[11:01:52.103]         if (!identical(...future.workdir, getwd())) 
[11:01:52.103]             setwd(...future.workdir)
[11:01:52.103]         {
[11:01:52.103]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.103]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.103]             }
[11:01:52.103]             base::options(...future.oldOptions)
[11:01:52.103]             if (.Platform$OS.type == "windows") {
[11:01:52.103]                 old_names <- names(...future.oldEnvVars)
[11:01:52.103]                 envs <- base::Sys.getenv()
[11:01:52.103]                 names <- names(envs)
[11:01:52.103]                 common <- intersect(names, old_names)
[11:01:52.103]                 added <- setdiff(names, old_names)
[11:01:52.103]                 removed <- setdiff(old_names, names)
[11:01:52.103]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.103]                   envs[common]]
[11:01:52.103]                 NAMES <- toupper(changed)
[11:01:52.103]                 args <- list()
[11:01:52.103]                 for (kk in seq_along(NAMES)) {
[11:01:52.103]                   name <- changed[[kk]]
[11:01:52.103]                   NAME <- NAMES[[kk]]
[11:01:52.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.103]                     next
[11:01:52.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.103]                 }
[11:01:52.103]                 NAMES <- toupper(added)
[11:01:52.103]                 for (kk in seq_along(NAMES)) {
[11:01:52.103]                   name <- added[[kk]]
[11:01:52.103]                   NAME <- NAMES[[kk]]
[11:01:52.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.103]                     next
[11:01:52.103]                   args[[name]] <- ""
[11:01:52.103]                 }
[11:01:52.103]                 NAMES <- toupper(removed)
[11:01:52.103]                 for (kk in seq_along(NAMES)) {
[11:01:52.103]                   name <- removed[[kk]]
[11:01:52.103]                   NAME <- NAMES[[kk]]
[11:01:52.103]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.103]                     next
[11:01:52.103]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.103]                 }
[11:01:52.103]                 if (length(args) > 0) 
[11:01:52.103]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.103]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.103]             }
[11:01:52.103]             else {
[11:01:52.103]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.103]             }
[11:01:52.103]             {
[11:01:52.103]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.103]                   0L) {
[11:01:52.103]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.103]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.103]                   base::options(opts)
[11:01:52.103]                 }
[11:01:52.103]                 {
[11:01:52.103]                   {
[11:01:52.103]                     NULL
[11:01:52.103]                     RNGkind("Mersenne-Twister")
[11:01:52.103]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.103]                       inherits = FALSE)
[11:01:52.103]                   }
[11:01:52.103]                   options(future.plan = NULL)
[11:01:52.103]                   if (is.na(NA_character_)) 
[11:01:52.103]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.103]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.103]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.103]                     .init = FALSE)
[11:01:52.103]                 }
[11:01:52.103]             }
[11:01:52.103]         }
[11:01:52.103]     })
[11:01:52.103]     if (TRUE) {
[11:01:52.103]         base::sink(type = "output", split = FALSE)
[11:01:52.103]         if (TRUE) {
[11:01:52.103]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.103]         }
[11:01:52.103]         else {
[11:01:52.103]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.103]         }
[11:01:52.103]         base::close(...future.stdout)
[11:01:52.103]         ...future.stdout <- NULL
[11:01:52.103]     }
[11:01:52.103]     ...future.result$conditions <- ...future.conditions
[11:01:52.103]     ...future.result$finished <- base::Sys.time()
[11:01:52.103]     ...future.result
[11:01:52.103] }
[11:01:52.104] assign_globals() ...
[11:01:52.105] List of 2
[11:01:52.105]  $ a : num 1
[11:01:52.105]  $ ii: int 3
[11:01:52.105]  - attr(*, "where")=List of 2
[11:01:52.105]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.105]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.105]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.105]  - attr(*, "resolved")= logi TRUE
[11:01:52.105]  - attr(*, "total_size")= num 74
[11:01:52.105]  - attr(*, "already-done")= logi TRUE
[11:01:52.107] - copied ‘a’ to environment
[11:01:52.107] - copied ‘ii’ to environment
[11:01:52.107] assign_globals() ... done
[11:01:52.108] plan(): Setting new future strategy stack:
[11:01:52.108] List of future strategies:
[11:01:52.108] 1. sequential:
[11:01:52.108]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.108]    - tweaked: FALSE
[11:01:52.108]    - call: NULL
[11:01:52.108] plan(): nbrOfWorkers() = 1
[11:01:52.109] plan(): Setting new future strategy stack:
[11:01:52.109] List of future strategies:
[11:01:52.109] 1. sequential:
[11:01:52.109]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.109]    - tweaked: FALSE
[11:01:52.109]    - call: plan(strategy)
[11:01:52.109] plan(): nbrOfWorkers() = 1
[11:01:52.109] SequentialFuture started (and completed)
[11:01:52.109] - Launch lazy future ... done
[11:01:52.110] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.110] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.110] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.112] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.112] Searching for globals ... DONE
[11:01:52.112] Resolving globals: TRUE
[11:01:52.112] Resolving any globals that are futures ...
[11:01:52.112] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.113] Resolving any globals that are futures ... DONE
[11:01:52.113] Resolving futures part of globals (recursively) ...
[11:01:52.113] resolve() on list ...
[11:01:52.113]  recursive: 99
[11:01:52.113]  length: 2
[11:01:52.113]  elements: ‘a’, ‘ii’
[11:01:52.113]  length: 1 (resolved future 1)
[11:01:52.114]  length: 0 (resolved future 2)
[11:01:52.114] resolve() on list ... DONE
[11:01:52.114] - globals: [2] ‘a’, ‘ii’
[11:01:52.114] Resolving futures part of globals (recursively) ... DONE
[11:01:52.114] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.114] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.114] - globals: [2] ‘a’, ‘ii’
[11:01:52.114] 
[11:01:52.114] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.115] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.115] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.117] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.117] Searching for globals ... DONE
[11:01:52.117] Resolving globals: TRUE
[11:01:52.117] Resolving any globals that are futures ...
[11:01:52.117] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.117] Resolving any globals that are futures ... DONE
[11:01:52.118] Resolving futures part of globals (recursively) ...
[11:01:52.118] resolve() on list ...
[11:01:52.118]  recursive: 99
[11:01:52.118]  length: 2
[11:01:52.118]  elements: ‘a’, ‘ii’
[11:01:52.118]  length: 1 (resolved future 1)
[11:01:52.118]  length: 0 (resolved future 2)
[11:01:52.118] resolve() on list ... DONE
[11:01:52.118] - globals: [2] ‘a’, ‘ii’
[11:01:52.118] Resolving futures part of globals (recursively) ... DONE
[11:01:52.119] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.119] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.119] - globals: [2] ‘a’, ‘ii’
[11:01:52.119] 
[11:01:52.119] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.120] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.120] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.121] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.122] Searching for globals ... DONE
[11:01:52.122] Resolving globals: TRUE
[11:01:52.122] Resolving any globals that are futures ...
[11:01:52.122] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.122] Resolving any globals that are futures ... DONE
[11:01:52.122] Resolving futures part of globals (recursively) ...
[11:01:52.122] resolve() on list ...
[11:01:52.123]  recursive: 99
[11:01:52.123]  length: 2
[11:01:52.123]  elements: ‘a’, ‘ii’
[11:01:52.123]  length: 1 (resolved future 1)
[11:01:52.123]  length: 0 (resolved future 2)
[11:01:52.123] resolve() on list ... DONE
[11:01:52.123] - globals: [2] ‘a’, ‘ii’
[11:01:52.124] Resolving futures part of globals (recursively) ... DONE
[11:01:52.124] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.125] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.125] - globals: [2] ‘a’, ‘ii’
[11:01:52.125] 
[11:01:52.125] getGlobalsAndPackages() ... DONE
[11:01:52.125] run() for ‘Future’ ...
[11:01:52.125] - state: ‘created’
[11:01:52.125] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.126] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.126] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.126]   - Field: ‘label’
[11:01:52.126]   - Field: ‘local’
[11:01:52.126]   - Field: ‘owner’
[11:01:52.126]   - Field: ‘envir’
[11:01:52.126]   - Field: ‘packages’
[11:01:52.126]   - Field: ‘gc’
[11:01:52.126]   - Field: ‘conditions’
[11:01:52.126]   - Field: ‘expr’
[11:01:52.126]   - Field: ‘uuid’
[11:01:52.126]   - Field: ‘seed’
[11:01:52.127]   - Field: ‘version’
[11:01:52.127]   - Field: ‘result’
[11:01:52.127]   - Field: ‘asynchronous’
[11:01:52.127]   - Field: ‘calls’
[11:01:52.127]   - Field: ‘globals’
[11:01:52.127]   - Field: ‘stdout’
[11:01:52.127]   - Field: ‘earlySignal’
[11:01:52.127]   - Field: ‘lazy’
[11:01:52.127]   - Field: ‘state’
[11:01:52.127] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.127] - Launch lazy future ...
[11:01:52.127] Packages needed by the future expression (n = 0): <none>
[11:01:52.128] Packages needed by future strategies (n = 0): <none>
[11:01:52.128] {
[11:01:52.128]     {
[11:01:52.128]         {
[11:01:52.128]             ...future.startTime <- base::Sys.time()
[11:01:52.128]             {
[11:01:52.128]                 {
[11:01:52.128]                   {
[11:01:52.128]                     base::local({
[11:01:52.128]                       has_future <- base::requireNamespace("future", 
[11:01:52.128]                         quietly = TRUE)
[11:01:52.128]                       if (has_future) {
[11:01:52.128]                         ns <- base::getNamespace("future")
[11:01:52.128]                         version <- ns[[".package"]][["version"]]
[11:01:52.128]                         if (is.null(version)) 
[11:01:52.128]                           version <- utils::packageVersion("future")
[11:01:52.128]                       }
[11:01:52.128]                       else {
[11:01:52.128]                         version <- NULL
[11:01:52.128]                       }
[11:01:52.128]                       if (!has_future || version < "1.8.0") {
[11:01:52.128]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.128]                           "", base::R.version$version.string), 
[11:01:52.128]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.128]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.128]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.128]                             "release", "version")], collapse = " "), 
[11:01:52.128]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.128]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.128]                           info)
[11:01:52.128]                         info <- base::paste(info, collapse = "; ")
[11:01:52.128]                         if (!has_future) {
[11:01:52.128]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.128]                             info)
[11:01:52.128]                         }
[11:01:52.128]                         else {
[11:01:52.128]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.128]                             info, version)
[11:01:52.128]                         }
[11:01:52.128]                         base::stop(msg)
[11:01:52.128]                       }
[11:01:52.128]                     })
[11:01:52.128]                   }
[11:01:52.128]                   ...future.strategy.old <- future::plan("list")
[11:01:52.128]                   options(future.plan = NULL)
[11:01:52.128]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.128]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.128]                 }
[11:01:52.128]                 ...future.workdir <- getwd()
[11:01:52.128]             }
[11:01:52.128]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.128]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.128]         }
[11:01:52.128]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.128]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.128]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.128]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.128]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.128]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.128]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.128]             base::names(...future.oldOptions))
[11:01:52.128]     }
[11:01:52.128]     if (FALSE) {
[11:01:52.128]     }
[11:01:52.128]     else {
[11:01:52.128]         if (TRUE) {
[11:01:52.128]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.128]                 open = "w")
[11:01:52.128]         }
[11:01:52.128]         else {
[11:01:52.128]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.128]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.128]         }
[11:01:52.128]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.128]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.128]             base::sink(type = "output", split = FALSE)
[11:01:52.128]             base::close(...future.stdout)
[11:01:52.128]         }, add = TRUE)
[11:01:52.128]     }
[11:01:52.128]     ...future.frame <- base::sys.nframe()
[11:01:52.128]     ...future.conditions <- base::list()
[11:01:52.128]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.128]     if (FALSE) {
[11:01:52.128]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.128]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.128]     }
[11:01:52.128]     ...future.result <- base::tryCatch({
[11:01:52.128]         base::withCallingHandlers({
[11:01:52.128]             ...future.value <- base::withVisible(base::local({
[11:01:52.128]                 b <- a * ii
[11:01:52.128]                 a <- 0
[11:01:52.128]                 b
[11:01:52.128]             }))
[11:01:52.128]             future::FutureResult(value = ...future.value$value, 
[11:01:52.128]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.128]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.128]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.128]                     ...future.globalenv.names))
[11:01:52.128]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.128]         }, condition = base::local({
[11:01:52.128]             c <- base::c
[11:01:52.128]             inherits <- base::inherits
[11:01:52.128]             invokeRestart <- base::invokeRestart
[11:01:52.128]             length <- base::length
[11:01:52.128]             list <- base::list
[11:01:52.128]             seq.int <- base::seq.int
[11:01:52.128]             signalCondition <- base::signalCondition
[11:01:52.128]             sys.calls <- base::sys.calls
[11:01:52.128]             `[[` <- base::`[[`
[11:01:52.128]             `+` <- base::`+`
[11:01:52.128]             `<<-` <- base::`<<-`
[11:01:52.128]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.128]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.128]                   3L)]
[11:01:52.128]             }
[11:01:52.128]             function(cond) {
[11:01:52.128]                 is_error <- inherits(cond, "error")
[11:01:52.128]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.128]                   NULL)
[11:01:52.128]                 if (is_error) {
[11:01:52.128]                   sessionInformation <- function() {
[11:01:52.128]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.128]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.128]                       search = base::search(), system = base::Sys.info())
[11:01:52.128]                   }
[11:01:52.128]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.128]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.128]                     cond$call), session = sessionInformation(), 
[11:01:52.128]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.128]                   signalCondition(cond)
[11:01:52.128]                 }
[11:01:52.128]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.128]                 "immediateCondition"))) {
[11:01:52.128]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.128]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.128]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.128]                   if (TRUE && !signal) {
[11:01:52.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.128]                     {
[11:01:52.128]                       inherits <- base::inherits
[11:01:52.128]                       invokeRestart <- base::invokeRestart
[11:01:52.128]                       is.null <- base::is.null
[11:01:52.128]                       muffled <- FALSE
[11:01:52.128]                       if (inherits(cond, "message")) {
[11:01:52.128]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.128]                         if (muffled) 
[11:01:52.128]                           invokeRestart("muffleMessage")
[11:01:52.128]                       }
[11:01:52.128]                       else if (inherits(cond, "warning")) {
[11:01:52.128]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.128]                         if (muffled) 
[11:01:52.128]                           invokeRestart("muffleWarning")
[11:01:52.128]                       }
[11:01:52.128]                       else if (inherits(cond, "condition")) {
[11:01:52.128]                         if (!is.null(pattern)) {
[11:01:52.128]                           computeRestarts <- base::computeRestarts
[11:01:52.128]                           grepl <- base::grepl
[11:01:52.128]                           restarts <- computeRestarts(cond)
[11:01:52.128]                           for (restart in restarts) {
[11:01:52.128]                             name <- restart$name
[11:01:52.128]                             if (is.null(name)) 
[11:01:52.128]                               next
[11:01:52.128]                             if (!grepl(pattern, name)) 
[11:01:52.128]                               next
[11:01:52.128]                             invokeRestart(restart)
[11:01:52.128]                             muffled <- TRUE
[11:01:52.128]                             break
[11:01:52.128]                           }
[11:01:52.128]                         }
[11:01:52.128]                       }
[11:01:52.128]                       invisible(muffled)
[11:01:52.128]                     }
[11:01:52.128]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.128]                   }
[11:01:52.128]                 }
[11:01:52.128]                 else {
[11:01:52.128]                   if (TRUE) {
[11:01:52.128]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.128]                     {
[11:01:52.128]                       inherits <- base::inherits
[11:01:52.128]                       invokeRestart <- base::invokeRestart
[11:01:52.128]                       is.null <- base::is.null
[11:01:52.128]                       muffled <- FALSE
[11:01:52.128]                       if (inherits(cond, "message")) {
[11:01:52.128]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.128]                         if (muffled) 
[11:01:52.128]                           invokeRestart("muffleMessage")
[11:01:52.128]                       }
[11:01:52.128]                       else if (inherits(cond, "warning")) {
[11:01:52.128]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.128]                         if (muffled) 
[11:01:52.128]                           invokeRestart("muffleWarning")
[11:01:52.128]                       }
[11:01:52.128]                       else if (inherits(cond, "condition")) {
[11:01:52.128]                         if (!is.null(pattern)) {
[11:01:52.128]                           computeRestarts <- base::computeRestarts
[11:01:52.128]                           grepl <- base::grepl
[11:01:52.128]                           restarts <- computeRestarts(cond)
[11:01:52.128]                           for (restart in restarts) {
[11:01:52.128]                             name <- restart$name
[11:01:52.128]                             if (is.null(name)) 
[11:01:52.128]                               next
[11:01:52.128]                             if (!grepl(pattern, name)) 
[11:01:52.128]                               next
[11:01:52.128]                             invokeRestart(restart)
[11:01:52.128]                             muffled <- TRUE
[11:01:52.128]                             break
[11:01:52.128]                           }
[11:01:52.128]                         }
[11:01:52.128]                       }
[11:01:52.128]                       invisible(muffled)
[11:01:52.128]                     }
[11:01:52.128]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.128]                   }
[11:01:52.128]                 }
[11:01:52.128]             }
[11:01:52.128]         }))
[11:01:52.128]     }, error = function(ex) {
[11:01:52.128]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.128]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.128]                 ...future.rng), started = ...future.startTime, 
[11:01:52.128]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.128]             version = "1.8"), class = "FutureResult")
[11:01:52.128]     }, finally = {
[11:01:52.128]         if (!identical(...future.workdir, getwd())) 
[11:01:52.128]             setwd(...future.workdir)
[11:01:52.128]         {
[11:01:52.128]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.128]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.128]             }
[11:01:52.128]             base::options(...future.oldOptions)
[11:01:52.128]             if (.Platform$OS.type == "windows") {
[11:01:52.128]                 old_names <- names(...future.oldEnvVars)
[11:01:52.128]                 envs <- base::Sys.getenv()
[11:01:52.128]                 names <- names(envs)
[11:01:52.128]                 common <- intersect(names, old_names)
[11:01:52.128]                 added <- setdiff(names, old_names)
[11:01:52.128]                 removed <- setdiff(old_names, names)
[11:01:52.128]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.128]                   envs[common]]
[11:01:52.128]                 NAMES <- toupper(changed)
[11:01:52.128]                 args <- list()
[11:01:52.128]                 for (kk in seq_along(NAMES)) {
[11:01:52.128]                   name <- changed[[kk]]
[11:01:52.128]                   NAME <- NAMES[[kk]]
[11:01:52.128]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.128]                     next
[11:01:52.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.128]                 }
[11:01:52.128]                 NAMES <- toupper(added)
[11:01:52.128]                 for (kk in seq_along(NAMES)) {
[11:01:52.128]                   name <- added[[kk]]
[11:01:52.128]                   NAME <- NAMES[[kk]]
[11:01:52.128]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.128]                     next
[11:01:52.128]                   args[[name]] <- ""
[11:01:52.128]                 }
[11:01:52.128]                 NAMES <- toupper(removed)
[11:01:52.128]                 for (kk in seq_along(NAMES)) {
[11:01:52.128]                   name <- removed[[kk]]
[11:01:52.128]                   NAME <- NAMES[[kk]]
[11:01:52.128]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.128]                     next
[11:01:52.128]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.128]                 }
[11:01:52.128]                 if (length(args) > 0) 
[11:01:52.128]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.128]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.128]             }
[11:01:52.128]             else {
[11:01:52.128]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.128]             }
[11:01:52.128]             {
[11:01:52.128]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.128]                   0L) {
[11:01:52.128]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.128]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.128]                   base::options(opts)
[11:01:52.128]                 }
[11:01:52.128]                 {
[11:01:52.128]                   {
[11:01:52.128]                     NULL
[11:01:52.128]                     RNGkind("Mersenne-Twister")
[11:01:52.128]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.128]                       inherits = FALSE)
[11:01:52.128]                   }
[11:01:52.128]                   options(future.plan = NULL)
[11:01:52.128]                   if (is.na(NA_character_)) 
[11:01:52.128]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.128]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.128]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.128]                     .init = FALSE)
[11:01:52.128]                 }
[11:01:52.128]             }
[11:01:52.128]         }
[11:01:52.128]     })
[11:01:52.128]     if (TRUE) {
[11:01:52.128]         base::sink(type = "output", split = FALSE)
[11:01:52.128]         if (TRUE) {
[11:01:52.128]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.128]         }
[11:01:52.128]         else {
[11:01:52.128]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.128]         }
[11:01:52.128]         base::close(...future.stdout)
[11:01:52.128]         ...future.stdout <- NULL
[11:01:52.128]     }
[11:01:52.128]     ...future.result$conditions <- ...future.conditions
[11:01:52.128]     ...future.result$finished <- base::Sys.time()
[11:01:52.128]     ...future.result
[11:01:52.128] }
[11:01:52.129] assign_globals() ...
[11:01:52.130] List of 2
[11:01:52.130]  $ a : num 1
[11:01:52.130]  $ ii: int 1
[11:01:52.130]  - attr(*, "where")=List of 2
[11:01:52.130]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.130]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.130]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.130]  - attr(*, "resolved")= logi TRUE
[11:01:52.130]  - attr(*, "total_size")= num 74
[11:01:52.130]  - attr(*, "already-done")= logi TRUE
[11:01:52.132] - copied ‘a’ to environment
[11:01:52.132] - copied ‘ii’ to environment
[11:01:52.133] assign_globals() ... done
[11:01:52.133] plan(): Setting new future strategy stack:
[11:01:52.133] List of future strategies:
[11:01:52.133] 1. sequential:
[11:01:52.133]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.133]    - tweaked: FALSE
[11:01:52.133]    - call: NULL
[11:01:52.133] plan(): nbrOfWorkers() = 1
[11:01:52.134] plan(): Setting new future strategy stack:
[11:01:52.134] List of future strategies:
[11:01:52.134] 1. sequential:
[11:01:52.134]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.134]    - tweaked: FALSE
[11:01:52.134]    - call: plan(strategy)
[11:01:52.134] plan(): nbrOfWorkers() = 1
[11:01:52.134] SequentialFuture started (and completed)
[11:01:52.135] - Launch lazy future ... done
[11:01:52.135] run() for ‘SequentialFuture’ ... done
[11:01:52.135] run() for ‘Future’ ...
[11:01:52.135] - state: ‘created’
[11:01:52.135] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.135] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.135] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.135]   - Field: ‘label’
[11:01:52.136]   - Field: ‘local’
[11:01:52.136]   - Field: ‘owner’
[11:01:52.136]   - Field: ‘envir’
[11:01:52.136]   - Field: ‘packages’
[11:01:52.136]   - Field: ‘gc’
[11:01:52.136]   - Field: ‘conditions’
[11:01:52.136]   - Field: ‘expr’
[11:01:52.136]   - Field: ‘uuid’
[11:01:52.136]   - Field: ‘seed’
[11:01:52.136]   - Field: ‘version’
[11:01:52.136]   - Field: ‘result’
[11:01:52.136]   - Field: ‘asynchronous’
[11:01:52.137]   - Field: ‘calls’
[11:01:52.137]   - Field: ‘globals’
[11:01:52.137]   - Field: ‘stdout’
[11:01:52.137]   - Field: ‘earlySignal’
[11:01:52.137]   - Field: ‘lazy’
[11:01:52.137]   - Field: ‘state’
[11:01:52.137] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.137] - Launch lazy future ...
[11:01:52.137] Packages needed by the future expression (n = 0): <none>
[11:01:52.137] Packages needed by future strategies (n = 0): <none>
[11:01:52.138] {
[11:01:52.138]     {
[11:01:52.138]         {
[11:01:52.138]             ...future.startTime <- base::Sys.time()
[11:01:52.138]             {
[11:01:52.138]                 {
[11:01:52.138]                   {
[11:01:52.138]                     base::local({
[11:01:52.138]                       has_future <- base::requireNamespace("future", 
[11:01:52.138]                         quietly = TRUE)
[11:01:52.138]                       if (has_future) {
[11:01:52.138]                         ns <- base::getNamespace("future")
[11:01:52.138]                         version <- ns[[".package"]][["version"]]
[11:01:52.138]                         if (is.null(version)) 
[11:01:52.138]                           version <- utils::packageVersion("future")
[11:01:52.138]                       }
[11:01:52.138]                       else {
[11:01:52.138]                         version <- NULL
[11:01:52.138]                       }
[11:01:52.138]                       if (!has_future || version < "1.8.0") {
[11:01:52.138]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.138]                           "", base::R.version$version.string), 
[11:01:52.138]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.138]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.138]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.138]                             "release", "version")], collapse = " "), 
[11:01:52.138]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.138]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.138]                           info)
[11:01:52.138]                         info <- base::paste(info, collapse = "; ")
[11:01:52.138]                         if (!has_future) {
[11:01:52.138]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.138]                             info)
[11:01:52.138]                         }
[11:01:52.138]                         else {
[11:01:52.138]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.138]                             info, version)
[11:01:52.138]                         }
[11:01:52.138]                         base::stop(msg)
[11:01:52.138]                       }
[11:01:52.138]                     })
[11:01:52.138]                   }
[11:01:52.138]                   ...future.strategy.old <- future::plan("list")
[11:01:52.138]                   options(future.plan = NULL)
[11:01:52.138]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.138]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.138]                 }
[11:01:52.138]                 ...future.workdir <- getwd()
[11:01:52.138]             }
[11:01:52.138]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.138]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.138]         }
[11:01:52.138]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.138]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.138]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.138]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.138]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.138]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.138]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.138]             base::names(...future.oldOptions))
[11:01:52.138]     }
[11:01:52.138]     if (FALSE) {
[11:01:52.138]     }
[11:01:52.138]     else {
[11:01:52.138]         if (TRUE) {
[11:01:52.138]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.138]                 open = "w")
[11:01:52.138]         }
[11:01:52.138]         else {
[11:01:52.138]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.138]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.138]         }
[11:01:52.138]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.138]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.138]             base::sink(type = "output", split = FALSE)
[11:01:52.138]             base::close(...future.stdout)
[11:01:52.138]         }, add = TRUE)
[11:01:52.138]     }
[11:01:52.138]     ...future.frame <- base::sys.nframe()
[11:01:52.138]     ...future.conditions <- base::list()
[11:01:52.138]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.138]     if (FALSE) {
[11:01:52.138]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.138]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.138]     }
[11:01:52.138]     ...future.result <- base::tryCatch({
[11:01:52.138]         base::withCallingHandlers({
[11:01:52.138]             ...future.value <- base::withVisible(base::local({
[11:01:52.138]                 b <- a * ii
[11:01:52.138]                 a <- 0
[11:01:52.138]                 b
[11:01:52.138]             }))
[11:01:52.138]             future::FutureResult(value = ...future.value$value, 
[11:01:52.138]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.138]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.138]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.138]                     ...future.globalenv.names))
[11:01:52.138]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.138]         }, condition = base::local({
[11:01:52.138]             c <- base::c
[11:01:52.138]             inherits <- base::inherits
[11:01:52.138]             invokeRestart <- base::invokeRestart
[11:01:52.138]             length <- base::length
[11:01:52.138]             list <- base::list
[11:01:52.138]             seq.int <- base::seq.int
[11:01:52.138]             signalCondition <- base::signalCondition
[11:01:52.138]             sys.calls <- base::sys.calls
[11:01:52.138]             `[[` <- base::`[[`
[11:01:52.138]             `+` <- base::`+`
[11:01:52.138]             `<<-` <- base::`<<-`
[11:01:52.138]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.138]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.138]                   3L)]
[11:01:52.138]             }
[11:01:52.138]             function(cond) {
[11:01:52.138]                 is_error <- inherits(cond, "error")
[11:01:52.138]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.138]                   NULL)
[11:01:52.138]                 if (is_error) {
[11:01:52.138]                   sessionInformation <- function() {
[11:01:52.138]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.138]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.138]                       search = base::search(), system = base::Sys.info())
[11:01:52.138]                   }
[11:01:52.138]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.138]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.138]                     cond$call), session = sessionInformation(), 
[11:01:52.138]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.138]                   signalCondition(cond)
[11:01:52.138]                 }
[11:01:52.138]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.138]                 "immediateCondition"))) {
[11:01:52.138]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.138]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.138]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.138]                   if (TRUE && !signal) {
[11:01:52.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.138]                     {
[11:01:52.138]                       inherits <- base::inherits
[11:01:52.138]                       invokeRestart <- base::invokeRestart
[11:01:52.138]                       is.null <- base::is.null
[11:01:52.138]                       muffled <- FALSE
[11:01:52.138]                       if (inherits(cond, "message")) {
[11:01:52.138]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.138]                         if (muffled) 
[11:01:52.138]                           invokeRestart("muffleMessage")
[11:01:52.138]                       }
[11:01:52.138]                       else if (inherits(cond, "warning")) {
[11:01:52.138]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.138]                         if (muffled) 
[11:01:52.138]                           invokeRestart("muffleWarning")
[11:01:52.138]                       }
[11:01:52.138]                       else if (inherits(cond, "condition")) {
[11:01:52.138]                         if (!is.null(pattern)) {
[11:01:52.138]                           computeRestarts <- base::computeRestarts
[11:01:52.138]                           grepl <- base::grepl
[11:01:52.138]                           restarts <- computeRestarts(cond)
[11:01:52.138]                           for (restart in restarts) {
[11:01:52.138]                             name <- restart$name
[11:01:52.138]                             if (is.null(name)) 
[11:01:52.138]                               next
[11:01:52.138]                             if (!grepl(pattern, name)) 
[11:01:52.138]                               next
[11:01:52.138]                             invokeRestart(restart)
[11:01:52.138]                             muffled <- TRUE
[11:01:52.138]                             break
[11:01:52.138]                           }
[11:01:52.138]                         }
[11:01:52.138]                       }
[11:01:52.138]                       invisible(muffled)
[11:01:52.138]                     }
[11:01:52.138]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.138]                   }
[11:01:52.138]                 }
[11:01:52.138]                 else {
[11:01:52.138]                   if (TRUE) {
[11:01:52.138]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.138]                     {
[11:01:52.138]                       inherits <- base::inherits
[11:01:52.138]                       invokeRestart <- base::invokeRestart
[11:01:52.138]                       is.null <- base::is.null
[11:01:52.138]                       muffled <- FALSE
[11:01:52.138]                       if (inherits(cond, "message")) {
[11:01:52.138]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.138]                         if (muffled) 
[11:01:52.138]                           invokeRestart("muffleMessage")
[11:01:52.138]                       }
[11:01:52.138]                       else if (inherits(cond, "warning")) {
[11:01:52.138]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.138]                         if (muffled) 
[11:01:52.138]                           invokeRestart("muffleWarning")
[11:01:52.138]                       }
[11:01:52.138]                       else if (inherits(cond, "condition")) {
[11:01:52.138]                         if (!is.null(pattern)) {
[11:01:52.138]                           computeRestarts <- base::computeRestarts
[11:01:52.138]                           grepl <- base::grepl
[11:01:52.138]                           restarts <- computeRestarts(cond)
[11:01:52.138]                           for (restart in restarts) {
[11:01:52.138]                             name <- restart$name
[11:01:52.138]                             if (is.null(name)) 
[11:01:52.138]                               next
[11:01:52.138]                             if (!grepl(pattern, name)) 
[11:01:52.138]                               next
[11:01:52.138]                             invokeRestart(restart)
[11:01:52.138]                             muffled <- TRUE
[11:01:52.138]                             break
[11:01:52.138]                           }
[11:01:52.138]                         }
[11:01:52.138]                       }
[11:01:52.138]                       invisible(muffled)
[11:01:52.138]                     }
[11:01:52.138]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.138]                   }
[11:01:52.138]                 }
[11:01:52.138]             }
[11:01:52.138]         }))
[11:01:52.138]     }, error = function(ex) {
[11:01:52.138]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.138]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.138]                 ...future.rng), started = ...future.startTime, 
[11:01:52.138]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.138]             version = "1.8"), class = "FutureResult")
[11:01:52.138]     }, finally = {
[11:01:52.138]         if (!identical(...future.workdir, getwd())) 
[11:01:52.138]             setwd(...future.workdir)
[11:01:52.138]         {
[11:01:52.138]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.138]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.138]             }
[11:01:52.138]             base::options(...future.oldOptions)
[11:01:52.138]             if (.Platform$OS.type == "windows") {
[11:01:52.138]                 old_names <- names(...future.oldEnvVars)
[11:01:52.138]                 envs <- base::Sys.getenv()
[11:01:52.138]                 names <- names(envs)
[11:01:52.138]                 common <- intersect(names, old_names)
[11:01:52.138]                 added <- setdiff(names, old_names)
[11:01:52.138]                 removed <- setdiff(old_names, names)
[11:01:52.138]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.138]                   envs[common]]
[11:01:52.138]                 NAMES <- toupper(changed)
[11:01:52.138]                 args <- list()
[11:01:52.138]                 for (kk in seq_along(NAMES)) {
[11:01:52.138]                   name <- changed[[kk]]
[11:01:52.138]                   NAME <- NAMES[[kk]]
[11:01:52.138]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.138]                     next
[11:01:52.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.138]                 }
[11:01:52.138]                 NAMES <- toupper(added)
[11:01:52.138]                 for (kk in seq_along(NAMES)) {
[11:01:52.138]                   name <- added[[kk]]
[11:01:52.138]                   NAME <- NAMES[[kk]]
[11:01:52.138]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.138]                     next
[11:01:52.138]                   args[[name]] <- ""
[11:01:52.138]                 }
[11:01:52.138]                 NAMES <- toupper(removed)
[11:01:52.138]                 for (kk in seq_along(NAMES)) {
[11:01:52.138]                   name <- removed[[kk]]
[11:01:52.138]                   NAME <- NAMES[[kk]]
[11:01:52.138]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.138]                     next
[11:01:52.138]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.138]                 }
[11:01:52.138]                 if (length(args) > 0) 
[11:01:52.138]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.138]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.138]             }
[11:01:52.138]             else {
[11:01:52.138]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.138]             }
[11:01:52.138]             {
[11:01:52.138]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.138]                   0L) {
[11:01:52.138]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.138]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.138]                   base::options(opts)
[11:01:52.138]                 }
[11:01:52.138]                 {
[11:01:52.138]                   {
[11:01:52.138]                     NULL
[11:01:52.138]                     RNGkind("Mersenne-Twister")
[11:01:52.138]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.138]                       inherits = FALSE)
[11:01:52.138]                   }
[11:01:52.138]                   options(future.plan = NULL)
[11:01:52.138]                   if (is.na(NA_character_)) 
[11:01:52.138]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.138]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.138]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.138]                     .init = FALSE)
[11:01:52.138]                 }
[11:01:52.138]             }
[11:01:52.138]         }
[11:01:52.138]     })
[11:01:52.138]     if (TRUE) {
[11:01:52.138]         base::sink(type = "output", split = FALSE)
[11:01:52.138]         if (TRUE) {
[11:01:52.138]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.138]         }
[11:01:52.138]         else {
[11:01:52.138]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.138]         }
[11:01:52.138]         base::close(...future.stdout)
[11:01:52.138]         ...future.stdout <- NULL
[11:01:52.138]     }
[11:01:52.138]     ...future.result$conditions <- ...future.conditions
[11:01:52.138]     ...future.result$finished <- base::Sys.time()
[11:01:52.138]     ...future.result
[11:01:52.138] }
[11:01:52.139] assign_globals() ...
[11:01:52.139] List of 2
[11:01:52.139]  $ a : num 1
[11:01:52.139]  $ ii: int 2
[11:01:52.139]  - attr(*, "where")=List of 2
[11:01:52.139]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.139]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.139]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.139]  - attr(*, "resolved")= logi TRUE
[11:01:52.139]  - attr(*, "total_size")= num 74
[11:01:52.139]  - attr(*, "already-done")= logi TRUE
[11:01:52.142] - copied ‘a’ to environment
[11:01:52.142] - copied ‘ii’ to environment
[11:01:52.142] assign_globals() ... done
[11:01:52.143] plan(): Setting new future strategy stack:
[11:01:52.143] List of future strategies:
[11:01:52.143] 1. sequential:
[11:01:52.143]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.143]    - tweaked: FALSE
[11:01:52.143]    - call: NULL
[11:01:52.143] plan(): nbrOfWorkers() = 1
[11:01:52.144] plan(): Setting new future strategy stack:
[11:01:52.144] List of future strategies:
[11:01:52.144] 1. sequential:
[11:01:52.144]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.144]    - tweaked: FALSE
[11:01:52.144]    - call: plan(strategy)
[11:01:52.144] plan(): nbrOfWorkers() = 1
[11:01:52.144] SequentialFuture started (and completed)
[11:01:52.144] - Launch lazy future ... done
[11:01:52.145] run() for ‘SequentialFuture’ ... done
[11:01:52.145] run() for ‘Future’ ...
[11:01:52.145] - state: ‘created’
[11:01:52.145] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.145] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.145] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.145]   - Field: ‘label’
[11:01:52.145]   - Field: ‘local’
[11:01:52.146]   - Field: ‘owner’
[11:01:52.146]   - Field: ‘envir’
[11:01:52.146]   - Field: ‘packages’
[11:01:52.146]   - Field: ‘gc’
[11:01:52.146]   - Field: ‘conditions’
[11:01:52.146]   - Field: ‘expr’
[11:01:52.146]   - Field: ‘uuid’
[11:01:52.146]   - Field: ‘seed’
[11:01:52.146]   - Field: ‘version’
[11:01:52.146]   - Field: ‘result’
[11:01:52.146]   - Field: ‘asynchronous’
[11:01:52.146]   - Field: ‘calls’
[11:01:52.146]   - Field: ‘globals’
[11:01:52.147]   - Field: ‘stdout’
[11:01:52.147]   - Field: ‘earlySignal’
[11:01:52.147]   - Field: ‘lazy’
[11:01:52.148]   - Field: ‘state’
[11:01:52.148] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.148] - Launch lazy future ...
[11:01:52.148] Packages needed by the future expression (n = 0): <none>
[11:01:52.148] Packages needed by future strategies (n = 0): <none>
[11:01:52.149] {
[11:01:52.149]     {
[11:01:52.149]         {
[11:01:52.149]             ...future.startTime <- base::Sys.time()
[11:01:52.149]             {
[11:01:52.149]                 {
[11:01:52.149]                   {
[11:01:52.149]                     base::local({
[11:01:52.149]                       has_future <- base::requireNamespace("future", 
[11:01:52.149]                         quietly = TRUE)
[11:01:52.149]                       if (has_future) {
[11:01:52.149]                         ns <- base::getNamespace("future")
[11:01:52.149]                         version <- ns[[".package"]][["version"]]
[11:01:52.149]                         if (is.null(version)) 
[11:01:52.149]                           version <- utils::packageVersion("future")
[11:01:52.149]                       }
[11:01:52.149]                       else {
[11:01:52.149]                         version <- NULL
[11:01:52.149]                       }
[11:01:52.149]                       if (!has_future || version < "1.8.0") {
[11:01:52.149]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.149]                           "", base::R.version$version.string), 
[11:01:52.149]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.149]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.149]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.149]                             "release", "version")], collapse = " "), 
[11:01:52.149]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.149]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.149]                           info)
[11:01:52.149]                         info <- base::paste(info, collapse = "; ")
[11:01:52.149]                         if (!has_future) {
[11:01:52.149]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.149]                             info)
[11:01:52.149]                         }
[11:01:52.149]                         else {
[11:01:52.149]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.149]                             info, version)
[11:01:52.149]                         }
[11:01:52.149]                         base::stop(msg)
[11:01:52.149]                       }
[11:01:52.149]                     })
[11:01:52.149]                   }
[11:01:52.149]                   ...future.strategy.old <- future::plan("list")
[11:01:52.149]                   options(future.plan = NULL)
[11:01:52.149]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.149]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.149]                 }
[11:01:52.149]                 ...future.workdir <- getwd()
[11:01:52.149]             }
[11:01:52.149]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.149]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.149]         }
[11:01:52.149]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.149]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.149]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.149]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.149]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.149]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.149]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.149]             base::names(...future.oldOptions))
[11:01:52.149]     }
[11:01:52.149]     if (FALSE) {
[11:01:52.149]     }
[11:01:52.149]     else {
[11:01:52.149]         if (TRUE) {
[11:01:52.149]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.149]                 open = "w")
[11:01:52.149]         }
[11:01:52.149]         else {
[11:01:52.149]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.149]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.149]         }
[11:01:52.149]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.149]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.149]             base::sink(type = "output", split = FALSE)
[11:01:52.149]             base::close(...future.stdout)
[11:01:52.149]         }, add = TRUE)
[11:01:52.149]     }
[11:01:52.149]     ...future.frame <- base::sys.nframe()
[11:01:52.149]     ...future.conditions <- base::list()
[11:01:52.149]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.149]     if (FALSE) {
[11:01:52.149]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.149]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.149]     }
[11:01:52.149]     ...future.result <- base::tryCatch({
[11:01:52.149]         base::withCallingHandlers({
[11:01:52.149]             ...future.value <- base::withVisible(base::local({
[11:01:52.149]                 b <- a * ii
[11:01:52.149]                 a <- 0
[11:01:52.149]                 b
[11:01:52.149]             }))
[11:01:52.149]             future::FutureResult(value = ...future.value$value, 
[11:01:52.149]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.149]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.149]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.149]                     ...future.globalenv.names))
[11:01:52.149]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.149]         }, condition = base::local({
[11:01:52.149]             c <- base::c
[11:01:52.149]             inherits <- base::inherits
[11:01:52.149]             invokeRestart <- base::invokeRestart
[11:01:52.149]             length <- base::length
[11:01:52.149]             list <- base::list
[11:01:52.149]             seq.int <- base::seq.int
[11:01:52.149]             signalCondition <- base::signalCondition
[11:01:52.149]             sys.calls <- base::sys.calls
[11:01:52.149]             `[[` <- base::`[[`
[11:01:52.149]             `+` <- base::`+`
[11:01:52.149]             `<<-` <- base::`<<-`
[11:01:52.149]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.149]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.149]                   3L)]
[11:01:52.149]             }
[11:01:52.149]             function(cond) {
[11:01:52.149]                 is_error <- inherits(cond, "error")
[11:01:52.149]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.149]                   NULL)
[11:01:52.149]                 if (is_error) {
[11:01:52.149]                   sessionInformation <- function() {
[11:01:52.149]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.149]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.149]                       search = base::search(), system = base::Sys.info())
[11:01:52.149]                   }
[11:01:52.149]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.149]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.149]                     cond$call), session = sessionInformation(), 
[11:01:52.149]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.149]                   signalCondition(cond)
[11:01:52.149]                 }
[11:01:52.149]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.149]                 "immediateCondition"))) {
[11:01:52.149]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.149]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.149]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.149]                   if (TRUE && !signal) {
[11:01:52.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.149]                     {
[11:01:52.149]                       inherits <- base::inherits
[11:01:52.149]                       invokeRestart <- base::invokeRestart
[11:01:52.149]                       is.null <- base::is.null
[11:01:52.149]                       muffled <- FALSE
[11:01:52.149]                       if (inherits(cond, "message")) {
[11:01:52.149]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.149]                         if (muffled) 
[11:01:52.149]                           invokeRestart("muffleMessage")
[11:01:52.149]                       }
[11:01:52.149]                       else if (inherits(cond, "warning")) {
[11:01:52.149]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.149]                         if (muffled) 
[11:01:52.149]                           invokeRestart("muffleWarning")
[11:01:52.149]                       }
[11:01:52.149]                       else if (inherits(cond, "condition")) {
[11:01:52.149]                         if (!is.null(pattern)) {
[11:01:52.149]                           computeRestarts <- base::computeRestarts
[11:01:52.149]                           grepl <- base::grepl
[11:01:52.149]                           restarts <- computeRestarts(cond)
[11:01:52.149]                           for (restart in restarts) {
[11:01:52.149]                             name <- restart$name
[11:01:52.149]                             if (is.null(name)) 
[11:01:52.149]                               next
[11:01:52.149]                             if (!grepl(pattern, name)) 
[11:01:52.149]                               next
[11:01:52.149]                             invokeRestart(restart)
[11:01:52.149]                             muffled <- TRUE
[11:01:52.149]                             break
[11:01:52.149]                           }
[11:01:52.149]                         }
[11:01:52.149]                       }
[11:01:52.149]                       invisible(muffled)
[11:01:52.149]                     }
[11:01:52.149]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.149]                   }
[11:01:52.149]                 }
[11:01:52.149]                 else {
[11:01:52.149]                   if (TRUE) {
[11:01:52.149]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.149]                     {
[11:01:52.149]                       inherits <- base::inherits
[11:01:52.149]                       invokeRestart <- base::invokeRestart
[11:01:52.149]                       is.null <- base::is.null
[11:01:52.149]                       muffled <- FALSE
[11:01:52.149]                       if (inherits(cond, "message")) {
[11:01:52.149]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.149]                         if (muffled) 
[11:01:52.149]                           invokeRestart("muffleMessage")
[11:01:52.149]                       }
[11:01:52.149]                       else if (inherits(cond, "warning")) {
[11:01:52.149]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.149]                         if (muffled) 
[11:01:52.149]                           invokeRestart("muffleWarning")
[11:01:52.149]                       }
[11:01:52.149]                       else if (inherits(cond, "condition")) {
[11:01:52.149]                         if (!is.null(pattern)) {
[11:01:52.149]                           computeRestarts <- base::computeRestarts
[11:01:52.149]                           grepl <- base::grepl
[11:01:52.149]                           restarts <- computeRestarts(cond)
[11:01:52.149]                           for (restart in restarts) {
[11:01:52.149]                             name <- restart$name
[11:01:52.149]                             if (is.null(name)) 
[11:01:52.149]                               next
[11:01:52.149]                             if (!grepl(pattern, name)) 
[11:01:52.149]                               next
[11:01:52.149]                             invokeRestart(restart)
[11:01:52.149]                             muffled <- TRUE
[11:01:52.149]                             break
[11:01:52.149]                           }
[11:01:52.149]                         }
[11:01:52.149]                       }
[11:01:52.149]                       invisible(muffled)
[11:01:52.149]                     }
[11:01:52.149]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.149]                   }
[11:01:52.149]                 }
[11:01:52.149]             }
[11:01:52.149]         }))
[11:01:52.149]     }, error = function(ex) {
[11:01:52.149]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.149]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.149]                 ...future.rng), started = ...future.startTime, 
[11:01:52.149]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.149]             version = "1.8"), class = "FutureResult")
[11:01:52.149]     }, finally = {
[11:01:52.149]         if (!identical(...future.workdir, getwd())) 
[11:01:52.149]             setwd(...future.workdir)
[11:01:52.149]         {
[11:01:52.149]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.149]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.149]             }
[11:01:52.149]             base::options(...future.oldOptions)
[11:01:52.149]             if (.Platform$OS.type == "windows") {
[11:01:52.149]                 old_names <- names(...future.oldEnvVars)
[11:01:52.149]                 envs <- base::Sys.getenv()
[11:01:52.149]                 names <- names(envs)
[11:01:52.149]                 common <- intersect(names, old_names)
[11:01:52.149]                 added <- setdiff(names, old_names)
[11:01:52.149]                 removed <- setdiff(old_names, names)
[11:01:52.149]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.149]                   envs[common]]
[11:01:52.149]                 NAMES <- toupper(changed)
[11:01:52.149]                 args <- list()
[11:01:52.149]                 for (kk in seq_along(NAMES)) {
[11:01:52.149]                   name <- changed[[kk]]
[11:01:52.149]                   NAME <- NAMES[[kk]]
[11:01:52.149]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.149]                     next
[11:01:52.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.149]                 }
[11:01:52.149]                 NAMES <- toupper(added)
[11:01:52.149]                 for (kk in seq_along(NAMES)) {
[11:01:52.149]                   name <- added[[kk]]
[11:01:52.149]                   NAME <- NAMES[[kk]]
[11:01:52.149]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.149]                     next
[11:01:52.149]                   args[[name]] <- ""
[11:01:52.149]                 }
[11:01:52.149]                 NAMES <- toupper(removed)
[11:01:52.149]                 for (kk in seq_along(NAMES)) {
[11:01:52.149]                   name <- removed[[kk]]
[11:01:52.149]                   NAME <- NAMES[[kk]]
[11:01:52.149]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.149]                     next
[11:01:52.149]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.149]                 }
[11:01:52.149]                 if (length(args) > 0) 
[11:01:52.149]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.149]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.149]             }
[11:01:52.149]             else {
[11:01:52.149]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.149]             }
[11:01:52.149]             {
[11:01:52.149]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.149]                   0L) {
[11:01:52.149]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.149]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.149]                   base::options(opts)
[11:01:52.149]                 }
[11:01:52.149]                 {
[11:01:52.149]                   {
[11:01:52.149]                     NULL
[11:01:52.149]                     RNGkind("Mersenne-Twister")
[11:01:52.149]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.149]                       inherits = FALSE)
[11:01:52.149]                   }
[11:01:52.149]                   options(future.plan = NULL)
[11:01:52.149]                   if (is.na(NA_character_)) 
[11:01:52.149]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.149]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.149]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.149]                     .init = FALSE)
[11:01:52.149]                 }
[11:01:52.149]             }
[11:01:52.149]         }
[11:01:52.149]     })
[11:01:52.149]     if (TRUE) {
[11:01:52.149]         base::sink(type = "output", split = FALSE)
[11:01:52.149]         if (TRUE) {
[11:01:52.149]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.149]         }
[11:01:52.149]         else {
[11:01:52.149]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.149]         }
[11:01:52.149]         base::close(...future.stdout)
[11:01:52.149]         ...future.stdout <- NULL
[11:01:52.149]     }
[11:01:52.149]     ...future.result$conditions <- ...future.conditions
[11:01:52.149]     ...future.result$finished <- base::Sys.time()
[11:01:52.149]     ...future.result
[11:01:52.149] }
[11:01:52.150] assign_globals() ...
[11:01:52.150] List of 2
[11:01:52.150]  $ a : num 1
[11:01:52.150]  $ ii: int 3
[11:01:52.150]  - attr(*, "where")=List of 2
[11:01:52.150]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.150]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.150]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.150]  - attr(*, "resolved")= logi TRUE
[11:01:52.150]  - attr(*, "total_size")= num 74
[11:01:52.150]  - attr(*, "already-done")= logi TRUE
[11:01:52.153] - copied ‘a’ to environment
[11:01:52.153] - copied ‘ii’ to environment
[11:01:52.153] assign_globals() ... done
[11:01:52.153] plan(): Setting new future strategy stack:
[11:01:52.154] List of future strategies:
[11:01:52.154] 1. sequential:
[11:01:52.154]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.154]    - tweaked: FALSE
[11:01:52.154]    - call: NULL
[11:01:52.154] plan(): nbrOfWorkers() = 1
[11:01:52.155] plan(): Setting new future strategy stack:
[11:01:52.155] List of future strategies:
[11:01:52.155] 1. sequential:
[11:01:52.155]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.155]    - tweaked: FALSE
[11:01:52.155]    - call: plan(strategy)
[11:01:52.155] plan(): nbrOfWorkers() = 1
[11:01:52.155] SequentialFuture started (and completed)
[11:01:52.155] - Launch lazy future ... done
[11:01:52.155] run() for ‘SequentialFuture’ ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.156] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.156] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.156] 
[11:01:52.156] Searching for globals ... DONE
[11:01:52.156] - globals: [0] <none>
[11:01:52.156] getGlobalsAndPackages() ... DONE
[11:01:52.157] run() for ‘Future’ ...
[11:01:52.157] - state: ‘created’
[11:01:52.157] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.157] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.157] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.157]   - Field: ‘label’
[11:01:52.157]   - Field: ‘local’
[11:01:52.157]   - Field: ‘owner’
[11:01:52.158]   - Field: ‘envir’
[11:01:52.158]   - Field: ‘packages’
[11:01:52.158]   - Field: ‘gc’
[11:01:52.158]   - Field: ‘conditions’
[11:01:52.158]   - Field: ‘expr’
[11:01:52.158]   - Field: ‘uuid’
[11:01:52.158]   - Field: ‘seed’
[11:01:52.158]   - Field: ‘version’
[11:01:52.158]   - Field: ‘result’
[11:01:52.158]   - Field: ‘asynchronous’
[11:01:52.158]   - Field: ‘calls’
[11:01:52.158]   - Field: ‘globals’
[11:01:52.158]   - Field: ‘stdout’
[11:01:52.159]   - Field: ‘earlySignal’
[11:01:52.159]   - Field: ‘lazy’
[11:01:52.159]   - Field: ‘state’
[11:01:52.159] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.159] - Launch lazy future ...
[11:01:52.159] Packages needed by the future expression (n = 0): <none>
[11:01:52.159] Packages needed by future strategies (n = 0): <none>
[11:01:52.160] {
[11:01:52.160]     {
[11:01:52.160]         {
[11:01:52.160]             ...future.startTime <- base::Sys.time()
[11:01:52.160]             {
[11:01:52.160]                 {
[11:01:52.160]                   {
[11:01:52.160]                     base::local({
[11:01:52.160]                       has_future <- base::requireNamespace("future", 
[11:01:52.160]                         quietly = TRUE)
[11:01:52.160]                       if (has_future) {
[11:01:52.160]                         ns <- base::getNamespace("future")
[11:01:52.160]                         version <- ns[[".package"]][["version"]]
[11:01:52.160]                         if (is.null(version)) 
[11:01:52.160]                           version <- utils::packageVersion("future")
[11:01:52.160]                       }
[11:01:52.160]                       else {
[11:01:52.160]                         version <- NULL
[11:01:52.160]                       }
[11:01:52.160]                       if (!has_future || version < "1.8.0") {
[11:01:52.160]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.160]                           "", base::R.version$version.string), 
[11:01:52.160]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.160]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.160]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.160]                             "release", "version")], collapse = " "), 
[11:01:52.160]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.160]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.160]                           info)
[11:01:52.160]                         info <- base::paste(info, collapse = "; ")
[11:01:52.160]                         if (!has_future) {
[11:01:52.160]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.160]                             info)
[11:01:52.160]                         }
[11:01:52.160]                         else {
[11:01:52.160]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.160]                             info, version)
[11:01:52.160]                         }
[11:01:52.160]                         base::stop(msg)
[11:01:52.160]                       }
[11:01:52.160]                     })
[11:01:52.160]                   }
[11:01:52.160]                   ...future.strategy.old <- future::plan("list")
[11:01:52.160]                   options(future.plan = NULL)
[11:01:52.160]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.160]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.160]                 }
[11:01:52.160]                 ...future.workdir <- getwd()
[11:01:52.160]             }
[11:01:52.160]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.160]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.160]         }
[11:01:52.160]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.160]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.160]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.160]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.160]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.160]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.160]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.160]             base::names(...future.oldOptions))
[11:01:52.160]     }
[11:01:52.160]     if (FALSE) {
[11:01:52.160]     }
[11:01:52.160]     else {
[11:01:52.160]         if (TRUE) {
[11:01:52.160]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.160]                 open = "w")
[11:01:52.160]         }
[11:01:52.160]         else {
[11:01:52.160]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.160]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.160]         }
[11:01:52.160]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.160]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.160]             base::sink(type = "output", split = FALSE)
[11:01:52.160]             base::close(...future.stdout)
[11:01:52.160]         }, add = TRUE)
[11:01:52.160]     }
[11:01:52.160]     ...future.frame <- base::sys.nframe()
[11:01:52.160]     ...future.conditions <- base::list()
[11:01:52.160]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.160]     if (FALSE) {
[11:01:52.160]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.160]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.160]     }
[11:01:52.160]     ...future.result <- base::tryCatch({
[11:01:52.160]         base::withCallingHandlers({
[11:01:52.160]             ...future.value <- base::withVisible(base::local(1))
[11:01:52.160]             future::FutureResult(value = ...future.value$value, 
[11:01:52.160]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.160]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.160]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.160]                     ...future.globalenv.names))
[11:01:52.160]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.160]         }, condition = base::local({
[11:01:52.160]             c <- base::c
[11:01:52.160]             inherits <- base::inherits
[11:01:52.160]             invokeRestart <- base::invokeRestart
[11:01:52.160]             length <- base::length
[11:01:52.160]             list <- base::list
[11:01:52.160]             seq.int <- base::seq.int
[11:01:52.160]             signalCondition <- base::signalCondition
[11:01:52.160]             sys.calls <- base::sys.calls
[11:01:52.160]             `[[` <- base::`[[`
[11:01:52.160]             `+` <- base::`+`
[11:01:52.160]             `<<-` <- base::`<<-`
[11:01:52.160]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.160]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.160]                   3L)]
[11:01:52.160]             }
[11:01:52.160]             function(cond) {
[11:01:52.160]                 is_error <- inherits(cond, "error")
[11:01:52.160]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.160]                   NULL)
[11:01:52.160]                 if (is_error) {
[11:01:52.160]                   sessionInformation <- function() {
[11:01:52.160]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.160]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.160]                       search = base::search(), system = base::Sys.info())
[11:01:52.160]                   }
[11:01:52.160]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.160]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.160]                     cond$call), session = sessionInformation(), 
[11:01:52.160]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.160]                   signalCondition(cond)
[11:01:52.160]                 }
[11:01:52.160]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.160]                 "immediateCondition"))) {
[11:01:52.160]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.160]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.160]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.160]                   if (TRUE && !signal) {
[11:01:52.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.160]                     {
[11:01:52.160]                       inherits <- base::inherits
[11:01:52.160]                       invokeRestart <- base::invokeRestart
[11:01:52.160]                       is.null <- base::is.null
[11:01:52.160]                       muffled <- FALSE
[11:01:52.160]                       if (inherits(cond, "message")) {
[11:01:52.160]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.160]                         if (muffled) 
[11:01:52.160]                           invokeRestart("muffleMessage")
[11:01:52.160]                       }
[11:01:52.160]                       else if (inherits(cond, "warning")) {
[11:01:52.160]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.160]                         if (muffled) 
[11:01:52.160]                           invokeRestart("muffleWarning")
[11:01:52.160]                       }
[11:01:52.160]                       else if (inherits(cond, "condition")) {
[11:01:52.160]                         if (!is.null(pattern)) {
[11:01:52.160]                           computeRestarts <- base::computeRestarts
[11:01:52.160]                           grepl <- base::grepl
[11:01:52.160]                           restarts <- computeRestarts(cond)
[11:01:52.160]                           for (restart in restarts) {
[11:01:52.160]                             name <- restart$name
[11:01:52.160]                             if (is.null(name)) 
[11:01:52.160]                               next
[11:01:52.160]                             if (!grepl(pattern, name)) 
[11:01:52.160]                               next
[11:01:52.160]                             invokeRestart(restart)
[11:01:52.160]                             muffled <- TRUE
[11:01:52.160]                             break
[11:01:52.160]                           }
[11:01:52.160]                         }
[11:01:52.160]                       }
[11:01:52.160]                       invisible(muffled)
[11:01:52.160]                     }
[11:01:52.160]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.160]                   }
[11:01:52.160]                 }
[11:01:52.160]                 else {
[11:01:52.160]                   if (TRUE) {
[11:01:52.160]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.160]                     {
[11:01:52.160]                       inherits <- base::inherits
[11:01:52.160]                       invokeRestart <- base::invokeRestart
[11:01:52.160]                       is.null <- base::is.null
[11:01:52.160]                       muffled <- FALSE
[11:01:52.160]                       if (inherits(cond, "message")) {
[11:01:52.160]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.160]                         if (muffled) 
[11:01:52.160]                           invokeRestart("muffleMessage")
[11:01:52.160]                       }
[11:01:52.160]                       else if (inherits(cond, "warning")) {
[11:01:52.160]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.160]                         if (muffled) 
[11:01:52.160]                           invokeRestart("muffleWarning")
[11:01:52.160]                       }
[11:01:52.160]                       else if (inherits(cond, "condition")) {
[11:01:52.160]                         if (!is.null(pattern)) {
[11:01:52.160]                           computeRestarts <- base::computeRestarts
[11:01:52.160]                           grepl <- base::grepl
[11:01:52.160]                           restarts <- computeRestarts(cond)
[11:01:52.160]                           for (restart in restarts) {
[11:01:52.160]                             name <- restart$name
[11:01:52.160]                             if (is.null(name)) 
[11:01:52.160]                               next
[11:01:52.160]                             if (!grepl(pattern, name)) 
[11:01:52.160]                               next
[11:01:52.160]                             invokeRestart(restart)
[11:01:52.160]                             muffled <- TRUE
[11:01:52.160]                             break
[11:01:52.160]                           }
[11:01:52.160]                         }
[11:01:52.160]                       }
[11:01:52.160]                       invisible(muffled)
[11:01:52.160]                     }
[11:01:52.160]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.160]                   }
[11:01:52.160]                 }
[11:01:52.160]             }
[11:01:52.160]         }))
[11:01:52.160]     }, error = function(ex) {
[11:01:52.160]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.160]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.160]                 ...future.rng), started = ...future.startTime, 
[11:01:52.160]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.160]             version = "1.8"), class = "FutureResult")
[11:01:52.160]     }, finally = {
[11:01:52.160]         if (!identical(...future.workdir, getwd())) 
[11:01:52.160]             setwd(...future.workdir)
[11:01:52.160]         {
[11:01:52.160]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.160]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.160]             }
[11:01:52.160]             base::options(...future.oldOptions)
[11:01:52.160]             if (.Platform$OS.type == "windows") {
[11:01:52.160]                 old_names <- names(...future.oldEnvVars)
[11:01:52.160]                 envs <- base::Sys.getenv()
[11:01:52.160]                 names <- names(envs)
[11:01:52.160]                 common <- intersect(names, old_names)
[11:01:52.160]                 added <- setdiff(names, old_names)
[11:01:52.160]                 removed <- setdiff(old_names, names)
[11:01:52.160]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.160]                   envs[common]]
[11:01:52.160]                 NAMES <- toupper(changed)
[11:01:52.160]                 args <- list()
[11:01:52.160]                 for (kk in seq_along(NAMES)) {
[11:01:52.160]                   name <- changed[[kk]]
[11:01:52.160]                   NAME <- NAMES[[kk]]
[11:01:52.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.160]                     next
[11:01:52.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.160]                 }
[11:01:52.160]                 NAMES <- toupper(added)
[11:01:52.160]                 for (kk in seq_along(NAMES)) {
[11:01:52.160]                   name <- added[[kk]]
[11:01:52.160]                   NAME <- NAMES[[kk]]
[11:01:52.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.160]                     next
[11:01:52.160]                   args[[name]] <- ""
[11:01:52.160]                 }
[11:01:52.160]                 NAMES <- toupper(removed)
[11:01:52.160]                 for (kk in seq_along(NAMES)) {
[11:01:52.160]                   name <- removed[[kk]]
[11:01:52.160]                   NAME <- NAMES[[kk]]
[11:01:52.160]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.160]                     next
[11:01:52.160]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.160]                 }
[11:01:52.160]                 if (length(args) > 0) 
[11:01:52.160]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.160]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.160]             }
[11:01:52.160]             else {
[11:01:52.160]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.160]             }
[11:01:52.160]             {
[11:01:52.160]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.160]                   0L) {
[11:01:52.160]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.160]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.160]                   base::options(opts)
[11:01:52.160]                 }
[11:01:52.160]                 {
[11:01:52.160]                   {
[11:01:52.160]                     NULL
[11:01:52.160]                     RNGkind("Mersenne-Twister")
[11:01:52.160]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.160]                       inherits = FALSE)
[11:01:52.160]                   }
[11:01:52.160]                   options(future.plan = NULL)
[11:01:52.160]                   if (is.na(NA_character_)) 
[11:01:52.160]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.160]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.160]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.160]                     .init = FALSE)
[11:01:52.160]                 }
[11:01:52.160]             }
[11:01:52.160]         }
[11:01:52.160]     })
[11:01:52.160]     if (TRUE) {
[11:01:52.160]         base::sink(type = "output", split = FALSE)
[11:01:52.160]         if (TRUE) {
[11:01:52.160]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.160]         }
[11:01:52.160]         else {
[11:01:52.160]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.160]         }
[11:01:52.160]         base::close(...future.stdout)
[11:01:52.160]         ...future.stdout <- NULL
[11:01:52.160]     }
[11:01:52.160]     ...future.result$conditions <- ...future.conditions
[11:01:52.160]     ...future.result$finished <- base::Sys.time()
[11:01:52.160]     ...future.result
[11:01:52.160] }
[11:01:52.161] plan(): Setting new future strategy stack:
[11:01:52.161] List of future strategies:
[11:01:52.161] 1. sequential:
[11:01:52.161]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.161]    - tweaked: FALSE
[11:01:52.161]    - call: NULL
[11:01:52.162] plan(): nbrOfWorkers() = 1
[11:01:52.163] plan(): Setting new future strategy stack:
[11:01:52.163] List of future strategies:
[11:01:52.163] 1. sequential:
[11:01:52.163]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.163]    - tweaked: FALSE
[11:01:52.163]    - call: plan(strategy)
[11:01:52.163] plan(): nbrOfWorkers() = 1
[11:01:52.163] SequentialFuture started (and completed)
[11:01:52.163] - Launch lazy future ... done
[11:01:52.163] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.164] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.164] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.164] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.165] Searching for globals ... DONE
[11:01:52.165] Resolving globals: TRUE
[11:01:52.165] Resolving any globals that are futures ...
[11:01:52.165] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.165] Resolving any globals that are futures ... DONE
[11:01:52.165] Resolving futures part of globals (recursively) ...
[11:01:52.165] resolve() on list ...
[11:01:52.165]  recursive: 99
[11:01:52.166]  length: 1
[11:01:52.166]  elements: ‘a’
[11:01:52.166] resolved() for ‘SequentialFuture’ ...
[11:01:52.166] - state: ‘finished’
[11:01:52.166] - run: TRUE
[11:01:52.166] - result: ‘FutureResult’
[11:01:52.166] resolved() for ‘SequentialFuture’ ... done
[11:01:52.166] Future #1
[11:01:52.166] resolved() for ‘SequentialFuture’ ...
[11:01:52.166] - state: ‘finished’
[11:01:52.166] - run: TRUE
[11:01:52.167] - result: ‘FutureResult’
[11:01:52.167] resolved() for ‘SequentialFuture’ ... done
[11:01:52.167] A SequentialFuture was resolved
[11:01:52.167]  length: 0 (resolved future 1)
[11:01:52.167] resolve() on list ... DONE
[11:01:52.167] - globals: [1] ‘a’
[11:01:52.167] Resolving futures part of globals (recursively) ... DONE
[11:01:52.167] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[11:01:52.167] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[11:01:52.168] - globals: [1] ‘a’
[11:01:52.168] - packages: [1] ‘future’
[11:01:52.168] getGlobalsAndPackages() ... DONE
[11:01:52.168] run() for ‘Future’ ...
[11:01:52.168] - state: ‘created’
[11:01:52.168] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.168] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.168] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.169]   - Field: ‘label’
[11:01:52.169]   - Field: ‘local’
[11:01:52.169]   - Field: ‘owner’
[11:01:52.169]   - Field: ‘envir’
[11:01:52.169]   - Field: ‘packages’
[11:01:52.169]   - Field: ‘gc’
[11:01:52.169]   - Field: ‘conditions’
[11:01:52.169]   - Field: ‘expr’
[11:01:52.169]   - Field: ‘uuid’
[11:01:52.169]   - Field: ‘seed’
[11:01:52.169]   - Field: ‘version’
[11:01:52.169]   - Field: ‘result’
[11:01:52.170]   - Field: ‘asynchronous’
[11:01:52.170]   - Field: ‘calls’
[11:01:52.170]   - Field: ‘globals’
[11:01:52.170]   - Field: ‘stdout’
[11:01:52.170]   - Field: ‘earlySignal’
[11:01:52.170]   - Field: ‘lazy’
[11:01:52.170]   - Field: ‘state’
[11:01:52.170] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.170] - Launch lazy future ...
[11:01:52.170] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.170] Packages needed by future strategies (n = 0): <none>
[11:01:52.172] {
[11:01:52.172]     {
[11:01:52.172]         {
[11:01:52.172]             ...future.startTime <- base::Sys.time()
[11:01:52.172]             {
[11:01:52.172]                 {
[11:01:52.172]                   {
[11:01:52.172]                     {
[11:01:52.172]                       base::local({
[11:01:52.172]                         has_future <- base::requireNamespace("future", 
[11:01:52.172]                           quietly = TRUE)
[11:01:52.172]                         if (has_future) {
[11:01:52.172]                           ns <- base::getNamespace("future")
[11:01:52.172]                           version <- ns[[".package"]][["version"]]
[11:01:52.172]                           if (is.null(version)) 
[11:01:52.172]                             version <- utils::packageVersion("future")
[11:01:52.172]                         }
[11:01:52.172]                         else {
[11:01:52.172]                           version <- NULL
[11:01:52.172]                         }
[11:01:52.172]                         if (!has_future || version < "1.8.0") {
[11:01:52.172]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.172]                             "", base::R.version$version.string), 
[11:01:52.172]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.172]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.172]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.172]                               "release", "version")], collapse = " "), 
[11:01:52.172]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.172]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.172]                             info)
[11:01:52.172]                           info <- base::paste(info, collapse = "; ")
[11:01:52.172]                           if (!has_future) {
[11:01:52.172]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.172]                               info)
[11:01:52.172]                           }
[11:01:52.172]                           else {
[11:01:52.172]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.172]                               info, version)
[11:01:52.172]                           }
[11:01:52.172]                           base::stop(msg)
[11:01:52.172]                         }
[11:01:52.172]                       })
[11:01:52.172]                     }
[11:01:52.172]                     base::local({
[11:01:52.172]                       for (pkg in "future") {
[11:01:52.172]                         base::loadNamespace(pkg)
[11:01:52.172]                         base::library(pkg, character.only = TRUE)
[11:01:52.172]                       }
[11:01:52.172]                     })
[11:01:52.172]                   }
[11:01:52.172]                   ...future.strategy.old <- future::plan("list")
[11:01:52.172]                   options(future.plan = NULL)
[11:01:52.172]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.172]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.172]                 }
[11:01:52.172]                 ...future.workdir <- getwd()
[11:01:52.172]             }
[11:01:52.172]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.172]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.172]         }
[11:01:52.172]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.172]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.172]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.172]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.172]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.172]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.172]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.172]             base::names(...future.oldOptions))
[11:01:52.172]     }
[11:01:52.172]     if (FALSE) {
[11:01:52.172]     }
[11:01:52.172]     else {
[11:01:52.172]         if (TRUE) {
[11:01:52.172]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.172]                 open = "w")
[11:01:52.172]         }
[11:01:52.172]         else {
[11:01:52.172]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.172]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.172]         }
[11:01:52.172]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.172]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.172]             base::sink(type = "output", split = FALSE)
[11:01:52.172]             base::close(...future.stdout)
[11:01:52.172]         }, add = TRUE)
[11:01:52.172]     }
[11:01:52.172]     ...future.frame <- base::sys.nframe()
[11:01:52.172]     ...future.conditions <- base::list()
[11:01:52.172]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.172]     if (FALSE) {
[11:01:52.172]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.172]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.172]     }
[11:01:52.172]     ...future.result <- base::tryCatch({
[11:01:52.172]         base::withCallingHandlers({
[11:01:52.172]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:52.172]                 1))
[11:01:52.172]             future::FutureResult(value = ...future.value$value, 
[11:01:52.172]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.172]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.172]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.172]                     ...future.globalenv.names))
[11:01:52.172]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.172]         }, condition = base::local({
[11:01:52.172]             c <- base::c
[11:01:52.172]             inherits <- base::inherits
[11:01:52.172]             invokeRestart <- base::invokeRestart
[11:01:52.172]             length <- base::length
[11:01:52.172]             list <- base::list
[11:01:52.172]             seq.int <- base::seq.int
[11:01:52.172]             signalCondition <- base::signalCondition
[11:01:52.172]             sys.calls <- base::sys.calls
[11:01:52.172]             `[[` <- base::`[[`
[11:01:52.172]             `+` <- base::`+`
[11:01:52.172]             `<<-` <- base::`<<-`
[11:01:52.172]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.172]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.172]                   3L)]
[11:01:52.172]             }
[11:01:52.172]             function(cond) {
[11:01:52.172]                 is_error <- inherits(cond, "error")
[11:01:52.172]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.172]                   NULL)
[11:01:52.172]                 if (is_error) {
[11:01:52.172]                   sessionInformation <- function() {
[11:01:52.172]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.172]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.172]                       search = base::search(), system = base::Sys.info())
[11:01:52.172]                   }
[11:01:52.172]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.172]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.172]                     cond$call), session = sessionInformation(), 
[11:01:52.172]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.172]                   signalCondition(cond)
[11:01:52.172]                 }
[11:01:52.172]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.172]                 "immediateCondition"))) {
[11:01:52.172]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.172]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.172]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.172]                   if (TRUE && !signal) {
[11:01:52.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.172]                     {
[11:01:52.172]                       inherits <- base::inherits
[11:01:52.172]                       invokeRestart <- base::invokeRestart
[11:01:52.172]                       is.null <- base::is.null
[11:01:52.172]                       muffled <- FALSE
[11:01:52.172]                       if (inherits(cond, "message")) {
[11:01:52.172]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.172]                         if (muffled) 
[11:01:52.172]                           invokeRestart("muffleMessage")
[11:01:52.172]                       }
[11:01:52.172]                       else if (inherits(cond, "warning")) {
[11:01:52.172]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.172]                         if (muffled) 
[11:01:52.172]                           invokeRestart("muffleWarning")
[11:01:52.172]                       }
[11:01:52.172]                       else if (inherits(cond, "condition")) {
[11:01:52.172]                         if (!is.null(pattern)) {
[11:01:52.172]                           computeRestarts <- base::computeRestarts
[11:01:52.172]                           grepl <- base::grepl
[11:01:52.172]                           restarts <- computeRestarts(cond)
[11:01:52.172]                           for (restart in restarts) {
[11:01:52.172]                             name <- restart$name
[11:01:52.172]                             if (is.null(name)) 
[11:01:52.172]                               next
[11:01:52.172]                             if (!grepl(pattern, name)) 
[11:01:52.172]                               next
[11:01:52.172]                             invokeRestart(restart)
[11:01:52.172]                             muffled <- TRUE
[11:01:52.172]                             break
[11:01:52.172]                           }
[11:01:52.172]                         }
[11:01:52.172]                       }
[11:01:52.172]                       invisible(muffled)
[11:01:52.172]                     }
[11:01:52.172]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.172]                   }
[11:01:52.172]                 }
[11:01:52.172]                 else {
[11:01:52.172]                   if (TRUE) {
[11:01:52.172]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.172]                     {
[11:01:52.172]                       inherits <- base::inherits
[11:01:52.172]                       invokeRestart <- base::invokeRestart
[11:01:52.172]                       is.null <- base::is.null
[11:01:52.172]                       muffled <- FALSE
[11:01:52.172]                       if (inherits(cond, "message")) {
[11:01:52.172]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.172]                         if (muffled) 
[11:01:52.172]                           invokeRestart("muffleMessage")
[11:01:52.172]                       }
[11:01:52.172]                       else if (inherits(cond, "warning")) {
[11:01:52.172]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.172]                         if (muffled) 
[11:01:52.172]                           invokeRestart("muffleWarning")
[11:01:52.172]                       }
[11:01:52.172]                       else if (inherits(cond, "condition")) {
[11:01:52.172]                         if (!is.null(pattern)) {
[11:01:52.172]                           computeRestarts <- base::computeRestarts
[11:01:52.172]                           grepl <- base::grepl
[11:01:52.172]                           restarts <- computeRestarts(cond)
[11:01:52.172]                           for (restart in restarts) {
[11:01:52.172]                             name <- restart$name
[11:01:52.172]                             if (is.null(name)) 
[11:01:52.172]                               next
[11:01:52.172]                             if (!grepl(pattern, name)) 
[11:01:52.172]                               next
[11:01:52.172]                             invokeRestart(restart)
[11:01:52.172]                             muffled <- TRUE
[11:01:52.172]                             break
[11:01:52.172]                           }
[11:01:52.172]                         }
[11:01:52.172]                       }
[11:01:52.172]                       invisible(muffled)
[11:01:52.172]                     }
[11:01:52.172]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.172]                   }
[11:01:52.172]                 }
[11:01:52.172]             }
[11:01:52.172]         }))
[11:01:52.172]     }, error = function(ex) {
[11:01:52.172]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.172]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.172]                 ...future.rng), started = ...future.startTime, 
[11:01:52.172]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.172]             version = "1.8"), class = "FutureResult")
[11:01:52.172]     }, finally = {
[11:01:52.172]         if (!identical(...future.workdir, getwd())) 
[11:01:52.172]             setwd(...future.workdir)
[11:01:52.172]         {
[11:01:52.172]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.172]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.172]             }
[11:01:52.172]             base::options(...future.oldOptions)
[11:01:52.172]             if (.Platform$OS.type == "windows") {
[11:01:52.172]                 old_names <- names(...future.oldEnvVars)
[11:01:52.172]                 envs <- base::Sys.getenv()
[11:01:52.172]                 names <- names(envs)
[11:01:52.172]                 common <- intersect(names, old_names)
[11:01:52.172]                 added <- setdiff(names, old_names)
[11:01:52.172]                 removed <- setdiff(old_names, names)
[11:01:52.172]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.172]                   envs[common]]
[11:01:52.172]                 NAMES <- toupper(changed)
[11:01:52.172]                 args <- list()
[11:01:52.172]                 for (kk in seq_along(NAMES)) {
[11:01:52.172]                   name <- changed[[kk]]
[11:01:52.172]                   NAME <- NAMES[[kk]]
[11:01:52.172]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.172]                     next
[11:01:52.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.172]                 }
[11:01:52.172]                 NAMES <- toupper(added)
[11:01:52.172]                 for (kk in seq_along(NAMES)) {
[11:01:52.172]                   name <- added[[kk]]
[11:01:52.172]                   NAME <- NAMES[[kk]]
[11:01:52.172]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.172]                     next
[11:01:52.172]                   args[[name]] <- ""
[11:01:52.172]                 }
[11:01:52.172]                 NAMES <- toupper(removed)
[11:01:52.172]                 for (kk in seq_along(NAMES)) {
[11:01:52.172]                   name <- removed[[kk]]
[11:01:52.172]                   NAME <- NAMES[[kk]]
[11:01:52.172]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.172]                     next
[11:01:52.172]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.172]                 }
[11:01:52.172]                 if (length(args) > 0) 
[11:01:52.172]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.172]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.172]             }
[11:01:52.172]             else {
[11:01:52.172]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.172]             }
[11:01:52.172]             {
[11:01:52.172]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.172]                   0L) {
[11:01:52.172]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.172]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.172]                   base::options(opts)
[11:01:52.172]                 }
[11:01:52.172]                 {
[11:01:52.172]                   {
[11:01:52.172]                     NULL
[11:01:52.172]                     RNGkind("Mersenne-Twister")
[11:01:52.172]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.172]                       inherits = FALSE)
[11:01:52.172]                   }
[11:01:52.172]                   options(future.plan = NULL)
[11:01:52.172]                   if (is.na(NA_character_)) 
[11:01:52.172]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.172]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.172]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.172]                     .init = FALSE)
[11:01:52.172]                 }
[11:01:52.172]             }
[11:01:52.172]         }
[11:01:52.172]     })
[11:01:52.172]     if (TRUE) {
[11:01:52.172]         base::sink(type = "output", split = FALSE)
[11:01:52.172]         if (TRUE) {
[11:01:52.172]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.172]         }
[11:01:52.172]         else {
[11:01:52.172]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.172]         }
[11:01:52.172]         base::close(...future.stdout)
[11:01:52.172]         ...future.stdout <- NULL
[11:01:52.172]     }
[11:01:52.172]     ...future.result$conditions <- ...future.conditions
[11:01:52.172]     ...future.result$finished <- base::Sys.time()
[11:01:52.172]     ...future.result
[11:01:52.172] }
[11:01:52.173] assign_globals() ...
[11:01:52.174] List of 1
[11:01:52.174]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eecdb78c58> 
[11:01:52.174]  - attr(*, "where")=List of 1
[11:01:52.174]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.174]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.174]  - attr(*, "resolved")= logi TRUE
[11:01:52.174]  - attr(*, "total_size")= num 3535
[11:01:52.174]  - attr(*, "already-done")= logi TRUE
[11:01:52.176] - copied ‘a’ to environment
[11:01:52.176] assign_globals() ... done
[11:01:52.176] plan(): Setting new future strategy stack:
[11:01:52.176] List of future strategies:
[11:01:52.176] 1. sequential:
[11:01:52.176]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.176]    - tweaked: FALSE
[11:01:52.176]    - call: NULL
[11:01:52.177] plan(): nbrOfWorkers() = 1
[11:01:52.177] plan(): Setting new future strategy stack:
[11:01:52.177] List of future strategies:
[11:01:52.177] 1. sequential:
[11:01:52.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.177]    - tweaked: FALSE
[11:01:52.177]    - call: plan(strategy)
[11:01:52.178] plan(): nbrOfWorkers() = 1
[11:01:52.178] SequentialFuture started (and completed)
[11:01:52.178] - Launch lazy future ... done
[11:01:52.178] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.179] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.179] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.179] 
[11:01:52.179] Searching for globals ... DONE
[11:01:52.179] - globals: [0] <none>
[11:01:52.179] getGlobalsAndPackages() ... DONE
[11:01:52.180] run() for ‘Future’ ...
[11:01:52.180] - state: ‘created’
[11:01:52.180] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.180] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.180] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.180]   - Field: ‘label’
[11:01:52.180]   - Field: ‘local’
[11:01:52.180]   - Field: ‘owner’
[11:01:52.180]   - Field: ‘envir’
[11:01:52.181]   - Field: ‘packages’
[11:01:52.181]   - Field: ‘gc’
[11:01:52.181]   - Field: ‘conditions’
[11:01:52.181]   - Field: ‘expr’
[11:01:52.181]   - Field: ‘uuid’
[11:01:52.181]   - Field: ‘seed’
[11:01:52.181]   - Field: ‘version’
[11:01:52.181]   - Field: ‘result’
[11:01:52.181]   - Field: ‘asynchronous’
[11:01:52.181]   - Field: ‘calls’
[11:01:52.181]   - Field: ‘globals’
[11:01:52.181]   - Field: ‘stdout’
[11:01:52.181]   - Field: ‘earlySignal’
[11:01:52.182]   - Field: ‘lazy’
[11:01:52.182]   - Field: ‘state’
[11:01:52.182] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.182] - Launch lazy future ...
[11:01:52.182] Packages needed by the future expression (n = 0): <none>
[11:01:52.182] Packages needed by future strategies (n = 0): <none>
[11:01:52.182] {
[11:01:52.182]     {
[11:01:52.182]         {
[11:01:52.182]             ...future.startTime <- base::Sys.time()
[11:01:52.182]             {
[11:01:52.182]                 {
[11:01:52.182]                   {
[11:01:52.182]                     base::local({
[11:01:52.182]                       has_future <- base::requireNamespace("future", 
[11:01:52.182]                         quietly = TRUE)
[11:01:52.182]                       if (has_future) {
[11:01:52.182]                         ns <- base::getNamespace("future")
[11:01:52.182]                         version <- ns[[".package"]][["version"]]
[11:01:52.182]                         if (is.null(version)) 
[11:01:52.182]                           version <- utils::packageVersion("future")
[11:01:52.182]                       }
[11:01:52.182]                       else {
[11:01:52.182]                         version <- NULL
[11:01:52.182]                       }
[11:01:52.182]                       if (!has_future || version < "1.8.0") {
[11:01:52.182]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.182]                           "", base::R.version$version.string), 
[11:01:52.182]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.182]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.182]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.182]                             "release", "version")], collapse = " "), 
[11:01:52.182]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.182]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.182]                           info)
[11:01:52.182]                         info <- base::paste(info, collapse = "; ")
[11:01:52.182]                         if (!has_future) {
[11:01:52.182]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.182]                             info)
[11:01:52.182]                         }
[11:01:52.182]                         else {
[11:01:52.182]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.182]                             info, version)
[11:01:52.182]                         }
[11:01:52.182]                         base::stop(msg)
[11:01:52.182]                       }
[11:01:52.182]                     })
[11:01:52.182]                   }
[11:01:52.182]                   ...future.strategy.old <- future::plan("list")
[11:01:52.182]                   options(future.plan = NULL)
[11:01:52.182]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.182]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.182]                 }
[11:01:52.182]                 ...future.workdir <- getwd()
[11:01:52.182]             }
[11:01:52.182]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.182]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.182]         }
[11:01:52.182]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.182]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.182]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.182]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.182]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.182]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.182]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.182]             base::names(...future.oldOptions))
[11:01:52.182]     }
[11:01:52.182]     if (FALSE) {
[11:01:52.182]     }
[11:01:52.182]     else {
[11:01:52.182]         if (TRUE) {
[11:01:52.182]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.182]                 open = "w")
[11:01:52.182]         }
[11:01:52.182]         else {
[11:01:52.182]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.182]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.182]         }
[11:01:52.182]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.182]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.182]             base::sink(type = "output", split = FALSE)
[11:01:52.182]             base::close(...future.stdout)
[11:01:52.182]         }, add = TRUE)
[11:01:52.182]     }
[11:01:52.182]     ...future.frame <- base::sys.nframe()
[11:01:52.182]     ...future.conditions <- base::list()
[11:01:52.182]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.182]     if (FALSE) {
[11:01:52.182]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.182]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.182]     }
[11:01:52.182]     ...future.result <- base::tryCatch({
[11:01:52.182]         base::withCallingHandlers({
[11:01:52.182]             ...future.value <- base::withVisible(base::local(1))
[11:01:52.182]             future::FutureResult(value = ...future.value$value, 
[11:01:52.182]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.182]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.182]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.182]                     ...future.globalenv.names))
[11:01:52.182]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.182]         }, condition = base::local({
[11:01:52.182]             c <- base::c
[11:01:52.182]             inherits <- base::inherits
[11:01:52.182]             invokeRestart <- base::invokeRestart
[11:01:52.182]             length <- base::length
[11:01:52.182]             list <- base::list
[11:01:52.182]             seq.int <- base::seq.int
[11:01:52.182]             signalCondition <- base::signalCondition
[11:01:52.182]             sys.calls <- base::sys.calls
[11:01:52.182]             `[[` <- base::`[[`
[11:01:52.182]             `+` <- base::`+`
[11:01:52.182]             `<<-` <- base::`<<-`
[11:01:52.182]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.182]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.182]                   3L)]
[11:01:52.182]             }
[11:01:52.182]             function(cond) {
[11:01:52.182]                 is_error <- inherits(cond, "error")
[11:01:52.182]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.182]                   NULL)
[11:01:52.182]                 if (is_error) {
[11:01:52.182]                   sessionInformation <- function() {
[11:01:52.182]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.182]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.182]                       search = base::search(), system = base::Sys.info())
[11:01:52.182]                   }
[11:01:52.182]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.182]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.182]                     cond$call), session = sessionInformation(), 
[11:01:52.182]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.182]                   signalCondition(cond)
[11:01:52.182]                 }
[11:01:52.182]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.182]                 "immediateCondition"))) {
[11:01:52.182]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.182]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.182]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.182]                   if (TRUE && !signal) {
[11:01:52.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.182]                     {
[11:01:52.182]                       inherits <- base::inherits
[11:01:52.182]                       invokeRestart <- base::invokeRestart
[11:01:52.182]                       is.null <- base::is.null
[11:01:52.182]                       muffled <- FALSE
[11:01:52.182]                       if (inherits(cond, "message")) {
[11:01:52.182]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.182]                         if (muffled) 
[11:01:52.182]                           invokeRestart("muffleMessage")
[11:01:52.182]                       }
[11:01:52.182]                       else if (inherits(cond, "warning")) {
[11:01:52.182]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.182]                         if (muffled) 
[11:01:52.182]                           invokeRestart("muffleWarning")
[11:01:52.182]                       }
[11:01:52.182]                       else if (inherits(cond, "condition")) {
[11:01:52.182]                         if (!is.null(pattern)) {
[11:01:52.182]                           computeRestarts <- base::computeRestarts
[11:01:52.182]                           grepl <- base::grepl
[11:01:52.182]                           restarts <- computeRestarts(cond)
[11:01:52.182]                           for (restart in restarts) {
[11:01:52.182]                             name <- restart$name
[11:01:52.182]                             if (is.null(name)) 
[11:01:52.182]                               next
[11:01:52.182]                             if (!grepl(pattern, name)) 
[11:01:52.182]                               next
[11:01:52.182]                             invokeRestart(restart)
[11:01:52.182]                             muffled <- TRUE
[11:01:52.182]                             break
[11:01:52.182]                           }
[11:01:52.182]                         }
[11:01:52.182]                       }
[11:01:52.182]                       invisible(muffled)
[11:01:52.182]                     }
[11:01:52.182]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.182]                   }
[11:01:52.182]                 }
[11:01:52.182]                 else {
[11:01:52.182]                   if (TRUE) {
[11:01:52.182]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.182]                     {
[11:01:52.182]                       inherits <- base::inherits
[11:01:52.182]                       invokeRestart <- base::invokeRestart
[11:01:52.182]                       is.null <- base::is.null
[11:01:52.182]                       muffled <- FALSE
[11:01:52.182]                       if (inherits(cond, "message")) {
[11:01:52.182]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.182]                         if (muffled) 
[11:01:52.182]                           invokeRestart("muffleMessage")
[11:01:52.182]                       }
[11:01:52.182]                       else if (inherits(cond, "warning")) {
[11:01:52.182]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.182]                         if (muffled) 
[11:01:52.182]                           invokeRestart("muffleWarning")
[11:01:52.182]                       }
[11:01:52.182]                       else if (inherits(cond, "condition")) {
[11:01:52.182]                         if (!is.null(pattern)) {
[11:01:52.182]                           computeRestarts <- base::computeRestarts
[11:01:52.182]                           grepl <- base::grepl
[11:01:52.182]                           restarts <- computeRestarts(cond)
[11:01:52.182]                           for (restart in restarts) {
[11:01:52.182]                             name <- restart$name
[11:01:52.182]                             if (is.null(name)) 
[11:01:52.182]                               next
[11:01:52.182]                             if (!grepl(pattern, name)) 
[11:01:52.182]                               next
[11:01:52.182]                             invokeRestart(restart)
[11:01:52.182]                             muffled <- TRUE
[11:01:52.182]                             break
[11:01:52.182]                           }
[11:01:52.182]                         }
[11:01:52.182]                       }
[11:01:52.182]                       invisible(muffled)
[11:01:52.182]                     }
[11:01:52.182]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.182]                   }
[11:01:52.182]                 }
[11:01:52.182]             }
[11:01:52.182]         }))
[11:01:52.182]     }, error = function(ex) {
[11:01:52.182]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.182]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.182]                 ...future.rng), started = ...future.startTime, 
[11:01:52.182]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.182]             version = "1.8"), class = "FutureResult")
[11:01:52.182]     }, finally = {
[11:01:52.182]         if (!identical(...future.workdir, getwd())) 
[11:01:52.182]             setwd(...future.workdir)
[11:01:52.182]         {
[11:01:52.182]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.182]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.182]             }
[11:01:52.182]             base::options(...future.oldOptions)
[11:01:52.182]             if (.Platform$OS.type == "windows") {
[11:01:52.182]                 old_names <- names(...future.oldEnvVars)
[11:01:52.182]                 envs <- base::Sys.getenv()
[11:01:52.182]                 names <- names(envs)
[11:01:52.182]                 common <- intersect(names, old_names)
[11:01:52.182]                 added <- setdiff(names, old_names)
[11:01:52.182]                 removed <- setdiff(old_names, names)
[11:01:52.182]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.182]                   envs[common]]
[11:01:52.182]                 NAMES <- toupper(changed)
[11:01:52.182]                 args <- list()
[11:01:52.182]                 for (kk in seq_along(NAMES)) {
[11:01:52.182]                   name <- changed[[kk]]
[11:01:52.182]                   NAME <- NAMES[[kk]]
[11:01:52.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.182]                     next
[11:01:52.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.182]                 }
[11:01:52.182]                 NAMES <- toupper(added)
[11:01:52.182]                 for (kk in seq_along(NAMES)) {
[11:01:52.182]                   name <- added[[kk]]
[11:01:52.182]                   NAME <- NAMES[[kk]]
[11:01:52.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.182]                     next
[11:01:52.182]                   args[[name]] <- ""
[11:01:52.182]                 }
[11:01:52.182]                 NAMES <- toupper(removed)
[11:01:52.182]                 for (kk in seq_along(NAMES)) {
[11:01:52.182]                   name <- removed[[kk]]
[11:01:52.182]                   NAME <- NAMES[[kk]]
[11:01:52.182]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.182]                     next
[11:01:52.182]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.182]                 }
[11:01:52.182]                 if (length(args) > 0) 
[11:01:52.182]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.182]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.182]             }
[11:01:52.182]             else {
[11:01:52.182]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.182]             }
[11:01:52.182]             {
[11:01:52.182]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.182]                   0L) {
[11:01:52.182]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.182]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.182]                   base::options(opts)
[11:01:52.182]                 }
[11:01:52.182]                 {
[11:01:52.182]                   {
[11:01:52.182]                     NULL
[11:01:52.182]                     RNGkind("Mersenne-Twister")
[11:01:52.182]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.182]                       inherits = FALSE)
[11:01:52.182]                   }
[11:01:52.182]                   options(future.plan = NULL)
[11:01:52.182]                   if (is.na(NA_character_)) 
[11:01:52.182]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.182]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.182]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.182]                     .init = FALSE)
[11:01:52.182]                 }
[11:01:52.182]             }
[11:01:52.182]         }
[11:01:52.182]     })
[11:01:52.182]     if (TRUE) {
[11:01:52.182]         base::sink(type = "output", split = FALSE)
[11:01:52.182]         if (TRUE) {
[11:01:52.182]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.182]         }
[11:01:52.182]         else {
[11:01:52.182]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.182]         }
[11:01:52.182]         base::close(...future.stdout)
[11:01:52.182]         ...future.stdout <- NULL
[11:01:52.182]     }
[11:01:52.182]     ...future.result$conditions <- ...future.conditions
[11:01:52.182]     ...future.result$finished <- base::Sys.time()
[11:01:52.182]     ...future.result
[11:01:52.182] }
[11:01:52.184] plan(): Setting new future strategy stack:
[11:01:52.184] List of future strategies:
[11:01:52.184] 1. sequential:
[11:01:52.184]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.184]    - tweaked: FALSE
[11:01:52.184]    - call: NULL
[11:01:52.185] plan(): nbrOfWorkers() = 1
[11:01:52.185] plan(): Setting new future strategy stack:
[11:01:52.185] List of future strategies:
[11:01:52.185] 1. sequential:
[11:01:52.185]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.185]    - tweaked: FALSE
[11:01:52.185]    - call: plan(strategy)
[11:01:52.186] plan(): nbrOfWorkers() = 1
[11:01:52.186] SequentialFuture started (and completed)
[11:01:52.186] - Launch lazy future ... done
[11:01:52.186] run() for ‘SequentialFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.186] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.186] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.187] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.187] Searching for globals ... DONE
[11:01:52.187] Resolving globals: TRUE
[11:01:52.187] Resolving any globals that are futures ...
[11:01:52.187] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.188] Resolving any globals that are futures ... DONE
[11:01:52.188] Resolving futures part of globals (recursively) ...
[11:01:52.188] resolve() on list ...
[11:01:52.188]  recursive: 99
[11:01:52.188]  length: 1
[11:01:52.188]  elements: ‘a’
[11:01:52.188] resolved() for ‘SequentialFuture’ ...
[11:01:52.188] - state: ‘finished’
[11:01:52.189] - run: TRUE
[11:01:52.189] - result: ‘FutureResult’
[11:01:52.189] resolved() for ‘SequentialFuture’ ... done
[11:01:52.189] Future #1
[11:01:52.189] resolved() for ‘SequentialFuture’ ...
[11:01:52.189] - state: ‘finished’
[11:01:52.189] - run: TRUE
[11:01:52.189] - result: ‘FutureResult’
[11:01:52.189] resolved() for ‘SequentialFuture’ ... done
[11:01:52.189] A SequentialFuture was resolved
[11:01:52.189]  length: 0 (resolved future 1)
[11:01:52.190] resolve() on list ... DONE
[11:01:52.190] - globals: [1] ‘a’
[11:01:52.190] Resolving futures part of globals (recursively) ... DONE
[11:01:52.190] The total size of the 1 globals is 3.45 KiB (3535 bytes)
[11:01:52.190] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.45 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.45 KiB of class ‘environment’)
[11:01:52.190] - globals: [1] ‘a’
[11:01:52.190] - packages: [1] ‘future’
[11:01:52.190] getGlobalsAndPackages() ... DONE
[11:01:52.191] run() for ‘Future’ ...
[11:01:52.191] - state: ‘created’
[11:01:52.191] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.191] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.191] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.191]   - Field: ‘label’
[11:01:52.191]   - Field: ‘local’
[11:01:52.191]   - Field: ‘owner’
[11:01:52.192]   - Field: ‘envir’
[11:01:52.192]   - Field: ‘packages’
[11:01:52.192]   - Field: ‘gc’
[11:01:52.192]   - Field: ‘conditions’
[11:01:52.192]   - Field: ‘expr’
[11:01:52.192]   - Field: ‘uuid’
[11:01:52.192]   - Field: ‘seed’
[11:01:52.192]   - Field: ‘version’
[11:01:52.192]   - Field: ‘result’
[11:01:52.192]   - Field: ‘asynchronous’
[11:01:52.192]   - Field: ‘calls’
[11:01:52.192]   - Field: ‘globals’
[11:01:52.192]   - Field: ‘stdout’
[11:01:52.193]   - Field: ‘earlySignal’
[11:01:52.193]   - Field: ‘lazy’
[11:01:52.193]   - Field: ‘state’
[11:01:52.193] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.193] - Launch lazy future ...
[11:01:52.193] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.193] Packages needed by future strategies (n = 0): <none>
[11:01:52.194] {
[11:01:52.194]     {
[11:01:52.194]         {
[11:01:52.194]             ...future.startTime <- base::Sys.time()
[11:01:52.194]             {
[11:01:52.194]                 {
[11:01:52.194]                   {
[11:01:52.194]                     {
[11:01:52.194]                       base::local({
[11:01:52.194]                         has_future <- base::requireNamespace("future", 
[11:01:52.194]                           quietly = TRUE)
[11:01:52.194]                         if (has_future) {
[11:01:52.194]                           ns <- base::getNamespace("future")
[11:01:52.194]                           version <- ns[[".package"]][["version"]]
[11:01:52.194]                           if (is.null(version)) 
[11:01:52.194]                             version <- utils::packageVersion("future")
[11:01:52.194]                         }
[11:01:52.194]                         else {
[11:01:52.194]                           version <- NULL
[11:01:52.194]                         }
[11:01:52.194]                         if (!has_future || version < "1.8.0") {
[11:01:52.194]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.194]                             "", base::R.version$version.string), 
[11:01:52.194]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.194]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.194]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.194]                               "release", "version")], collapse = " "), 
[11:01:52.194]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.194]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.194]                             info)
[11:01:52.194]                           info <- base::paste(info, collapse = "; ")
[11:01:52.194]                           if (!has_future) {
[11:01:52.194]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.194]                               info)
[11:01:52.194]                           }
[11:01:52.194]                           else {
[11:01:52.194]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.194]                               info, version)
[11:01:52.194]                           }
[11:01:52.194]                           base::stop(msg)
[11:01:52.194]                         }
[11:01:52.194]                       })
[11:01:52.194]                     }
[11:01:52.194]                     base::local({
[11:01:52.194]                       for (pkg in "future") {
[11:01:52.194]                         base::loadNamespace(pkg)
[11:01:52.194]                         base::library(pkg, character.only = TRUE)
[11:01:52.194]                       }
[11:01:52.194]                     })
[11:01:52.194]                   }
[11:01:52.194]                   ...future.strategy.old <- future::plan("list")
[11:01:52.194]                   options(future.plan = NULL)
[11:01:52.194]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.194]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.194]                 }
[11:01:52.194]                 ...future.workdir <- getwd()
[11:01:52.194]             }
[11:01:52.194]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.194]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.194]         }
[11:01:52.194]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.194]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.194]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.194]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.194]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.194]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.194]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.194]             base::names(...future.oldOptions))
[11:01:52.194]     }
[11:01:52.194]     if (FALSE) {
[11:01:52.194]     }
[11:01:52.194]     else {
[11:01:52.194]         if (TRUE) {
[11:01:52.194]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.194]                 open = "w")
[11:01:52.194]         }
[11:01:52.194]         else {
[11:01:52.194]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.194]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.194]         }
[11:01:52.194]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.194]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.194]             base::sink(type = "output", split = FALSE)
[11:01:52.194]             base::close(...future.stdout)
[11:01:52.194]         }, add = TRUE)
[11:01:52.194]     }
[11:01:52.194]     ...future.frame <- base::sys.nframe()
[11:01:52.194]     ...future.conditions <- base::list()
[11:01:52.194]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.194]     if (FALSE) {
[11:01:52.194]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.194]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.194]     }
[11:01:52.194]     ...future.result <- base::tryCatch({
[11:01:52.194]         base::withCallingHandlers({
[11:01:52.194]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:52.194]                 1))
[11:01:52.194]             future::FutureResult(value = ...future.value$value, 
[11:01:52.194]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.194]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.194]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.194]                     ...future.globalenv.names))
[11:01:52.194]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.194]         }, condition = base::local({
[11:01:52.194]             c <- base::c
[11:01:52.194]             inherits <- base::inherits
[11:01:52.194]             invokeRestart <- base::invokeRestart
[11:01:52.194]             length <- base::length
[11:01:52.194]             list <- base::list
[11:01:52.194]             seq.int <- base::seq.int
[11:01:52.194]             signalCondition <- base::signalCondition
[11:01:52.194]             sys.calls <- base::sys.calls
[11:01:52.194]             `[[` <- base::`[[`
[11:01:52.194]             `+` <- base::`+`
[11:01:52.194]             `<<-` <- base::`<<-`
[11:01:52.194]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.194]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.194]                   3L)]
[11:01:52.194]             }
[11:01:52.194]             function(cond) {
[11:01:52.194]                 is_error <- inherits(cond, "error")
[11:01:52.194]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.194]                   NULL)
[11:01:52.194]                 if (is_error) {
[11:01:52.194]                   sessionInformation <- function() {
[11:01:52.194]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.194]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.194]                       search = base::search(), system = base::Sys.info())
[11:01:52.194]                   }
[11:01:52.194]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.194]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.194]                     cond$call), session = sessionInformation(), 
[11:01:52.194]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.194]                   signalCondition(cond)
[11:01:52.194]                 }
[11:01:52.194]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.194]                 "immediateCondition"))) {
[11:01:52.194]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.194]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.194]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.194]                   if (TRUE && !signal) {
[11:01:52.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.194]                     {
[11:01:52.194]                       inherits <- base::inherits
[11:01:52.194]                       invokeRestart <- base::invokeRestart
[11:01:52.194]                       is.null <- base::is.null
[11:01:52.194]                       muffled <- FALSE
[11:01:52.194]                       if (inherits(cond, "message")) {
[11:01:52.194]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.194]                         if (muffled) 
[11:01:52.194]                           invokeRestart("muffleMessage")
[11:01:52.194]                       }
[11:01:52.194]                       else if (inherits(cond, "warning")) {
[11:01:52.194]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.194]                         if (muffled) 
[11:01:52.194]                           invokeRestart("muffleWarning")
[11:01:52.194]                       }
[11:01:52.194]                       else if (inherits(cond, "condition")) {
[11:01:52.194]                         if (!is.null(pattern)) {
[11:01:52.194]                           computeRestarts <- base::computeRestarts
[11:01:52.194]                           grepl <- base::grepl
[11:01:52.194]                           restarts <- computeRestarts(cond)
[11:01:52.194]                           for (restart in restarts) {
[11:01:52.194]                             name <- restart$name
[11:01:52.194]                             if (is.null(name)) 
[11:01:52.194]                               next
[11:01:52.194]                             if (!grepl(pattern, name)) 
[11:01:52.194]                               next
[11:01:52.194]                             invokeRestart(restart)
[11:01:52.194]                             muffled <- TRUE
[11:01:52.194]                             break
[11:01:52.194]                           }
[11:01:52.194]                         }
[11:01:52.194]                       }
[11:01:52.194]                       invisible(muffled)
[11:01:52.194]                     }
[11:01:52.194]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.194]                   }
[11:01:52.194]                 }
[11:01:52.194]                 else {
[11:01:52.194]                   if (TRUE) {
[11:01:52.194]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.194]                     {
[11:01:52.194]                       inherits <- base::inherits
[11:01:52.194]                       invokeRestart <- base::invokeRestart
[11:01:52.194]                       is.null <- base::is.null
[11:01:52.194]                       muffled <- FALSE
[11:01:52.194]                       if (inherits(cond, "message")) {
[11:01:52.194]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.194]                         if (muffled) 
[11:01:52.194]                           invokeRestart("muffleMessage")
[11:01:52.194]                       }
[11:01:52.194]                       else if (inherits(cond, "warning")) {
[11:01:52.194]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.194]                         if (muffled) 
[11:01:52.194]                           invokeRestart("muffleWarning")
[11:01:52.194]                       }
[11:01:52.194]                       else if (inherits(cond, "condition")) {
[11:01:52.194]                         if (!is.null(pattern)) {
[11:01:52.194]                           computeRestarts <- base::computeRestarts
[11:01:52.194]                           grepl <- base::grepl
[11:01:52.194]                           restarts <- computeRestarts(cond)
[11:01:52.194]                           for (restart in restarts) {
[11:01:52.194]                             name <- restart$name
[11:01:52.194]                             if (is.null(name)) 
[11:01:52.194]                               next
[11:01:52.194]                             if (!grepl(pattern, name)) 
[11:01:52.194]                               next
[11:01:52.194]                             invokeRestart(restart)
[11:01:52.194]                             muffled <- TRUE
[11:01:52.194]                             break
[11:01:52.194]                           }
[11:01:52.194]                         }
[11:01:52.194]                       }
[11:01:52.194]                       invisible(muffled)
[11:01:52.194]                     }
[11:01:52.194]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.194]                   }
[11:01:52.194]                 }
[11:01:52.194]             }
[11:01:52.194]         }))
[11:01:52.194]     }, error = function(ex) {
[11:01:52.194]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.194]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.194]                 ...future.rng), started = ...future.startTime, 
[11:01:52.194]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.194]             version = "1.8"), class = "FutureResult")
[11:01:52.194]     }, finally = {
[11:01:52.194]         if (!identical(...future.workdir, getwd())) 
[11:01:52.194]             setwd(...future.workdir)
[11:01:52.194]         {
[11:01:52.194]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.194]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.194]             }
[11:01:52.194]             base::options(...future.oldOptions)
[11:01:52.194]             if (.Platform$OS.type == "windows") {
[11:01:52.194]                 old_names <- names(...future.oldEnvVars)
[11:01:52.194]                 envs <- base::Sys.getenv()
[11:01:52.194]                 names <- names(envs)
[11:01:52.194]                 common <- intersect(names, old_names)
[11:01:52.194]                 added <- setdiff(names, old_names)
[11:01:52.194]                 removed <- setdiff(old_names, names)
[11:01:52.194]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.194]                   envs[common]]
[11:01:52.194]                 NAMES <- toupper(changed)
[11:01:52.194]                 args <- list()
[11:01:52.194]                 for (kk in seq_along(NAMES)) {
[11:01:52.194]                   name <- changed[[kk]]
[11:01:52.194]                   NAME <- NAMES[[kk]]
[11:01:52.194]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.194]                     next
[11:01:52.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.194]                 }
[11:01:52.194]                 NAMES <- toupper(added)
[11:01:52.194]                 for (kk in seq_along(NAMES)) {
[11:01:52.194]                   name <- added[[kk]]
[11:01:52.194]                   NAME <- NAMES[[kk]]
[11:01:52.194]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.194]                     next
[11:01:52.194]                   args[[name]] <- ""
[11:01:52.194]                 }
[11:01:52.194]                 NAMES <- toupper(removed)
[11:01:52.194]                 for (kk in seq_along(NAMES)) {
[11:01:52.194]                   name <- removed[[kk]]
[11:01:52.194]                   NAME <- NAMES[[kk]]
[11:01:52.194]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.194]                     next
[11:01:52.194]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.194]                 }
[11:01:52.194]                 if (length(args) > 0) 
[11:01:52.194]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.194]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.194]             }
[11:01:52.194]             else {
[11:01:52.194]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.194]             }
[11:01:52.194]             {
[11:01:52.194]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.194]                   0L) {
[11:01:52.194]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.194]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.194]                   base::options(opts)
[11:01:52.194]                 }
[11:01:52.194]                 {
[11:01:52.194]                   {
[11:01:52.194]                     NULL
[11:01:52.194]                     RNGkind("Mersenne-Twister")
[11:01:52.194]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.194]                       inherits = FALSE)
[11:01:52.194]                   }
[11:01:52.194]                   options(future.plan = NULL)
[11:01:52.194]                   if (is.na(NA_character_)) 
[11:01:52.194]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.194]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.194]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.194]                     .init = FALSE)
[11:01:52.194]                 }
[11:01:52.194]             }
[11:01:52.194]         }
[11:01:52.194]     })
[11:01:52.194]     if (TRUE) {
[11:01:52.194]         base::sink(type = "output", split = FALSE)
[11:01:52.194]         if (TRUE) {
[11:01:52.194]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.194]         }
[11:01:52.194]         else {
[11:01:52.194]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.194]         }
[11:01:52.194]         base::close(...future.stdout)
[11:01:52.194]         ...future.stdout <- NULL
[11:01:52.194]     }
[11:01:52.194]     ...future.result$conditions <- ...future.conditions
[11:01:52.194]     ...future.result$finished <- base::Sys.time()
[11:01:52.194]     ...future.result
[11:01:52.194] }
[11:01:52.195] assign_globals() ...
[11:01:52.195] List of 1
[11:01:52.195]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eecc6715c0> 
[11:01:52.195]  - attr(*, "where")=List of 1
[11:01:52.195]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.195]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.195]  - attr(*, "resolved")= logi TRUE
[11:01:52.195]  - attr(*, "total_size")= num 3535
[11:01:52.195]  - attr(*, "already-done")= logi TRUE
[11:01:52.220] - copied ‘a’ to environment
[11:01:52.221] assign_globals() ... done
[11:01:52.221] plan(): Setting new future strategy stack:
[11:01:52.221] List of future strategies:
[11:01:52.221] 1. sequential:
[11:01:52.221]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.221]    - tweaked: FALSE
[11:01:52.221]    - call: NULL
[11:01:52.221] plan(): nbrOfWorkers() = 1
[11:01:52.222] plan(): Setting new future strategy stack:
[11:01:52.222] List of future strategies:
[11:01:52.222] 1. sequential:
[11:01:52.222]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.222]    - tweaked: FALSE
[11:01:52.222]    - call: plan(strategy)
[11:01:52.223] plan(): nbrOfWorkers() = 1
[11:01:52.223] SequentialFuture started (and completed)
[11:01:52.223] - Launch lazy future ... done
[11:01:52.223] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.223] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.224] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.224] 
[11:01:52.224] Searching for globals ... DONE
[11:01:52.224] - globals: [0] <none>
[11:01:52.224] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.225] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.225] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.225] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.226] Searching for globals ... DONE
[11:01:52.226] Resolving globals: TRUE
[11:01:52.226] Resolving any globals that are futures ...
[11:01:52.226] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.226] Resolving any globals that are futures ... DONE
[11:01:52.226] Resolving futures part of globals (recursively) ...
[11:01:52.226] resolve() on list ...
[11:01:52.226]  recursive: 99
[11:01:52.227]  length: 1
[11:01:52.227]  elements: ‘a’
[11:01:52.227] run() for ‘Future’ ...
[11:01:52.227] - state: ‘created’
[11:01:52.227] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.227] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.227] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.227]   - Field: ‘label’
[11:01:52.227]   - Field: ‘local’
[11:01:52.228]   - Field: ‘owner’
[11:01:52.228]   - Field: ‘envir’
[11:01:52.228]   - Field: ‘packages’
[11:01:52.228]   - Field: ‘gc’
[11:01:52.228]   - Field: ‘conditions’
[11:01:52.228]   - Field: ‘expr’
[11:01:52.228]   - Field: ‘uuid’
[11:01:52.228]   - Field: ‘seed’
[11:01:52.228]   - Field: ‘version’
[11:01:52.228]   - Field: ‘result’
[11:01:52.228]   - Field: ‘asynchronous’
[11:01:52.228]   - Field: ‘calls’
[11:01:52.229]   - Field: ‘globals’
[11:01:52.229]   - Field: ‘stdout’
[11:01:52.229]   - Field: ‘earlySignal’
[11:01:52.229]   - Field: ‘lazy’
[11:01:52.229]   - Field: ‘state’
[11:01:52.229] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.229] - Launch lazy future ...
[11:01:52.229] Packages needed by the future expression (n = 0): <none>
[11:01:52.229] Packages needed by future strategies (n = 0): <none>
[11:01:52.230] {
[11:01:52.230]     {
[11:01:52.230]         {
[11:01:52.230]             ...future.startTime <- base::Sys.time()
[11:01:52.230]             {
[11:01:52.230]                 {
[11:01:52.230]                   {
[11:01:52.230]                     base::local({
[11:01:52.230]                       has_future <- base::requireNamespace("future", 
[11:01:52.230]                         quietly = TRUE)
[11:01:52.230]                       if (has_future) {
[11:01:52.230]                         ns <- base::getNamespace("future")
[11:01:52.230]                         version <- ns[[".package"]][["version"]]
[11:01:52.230]                         if (is.null(version)) 
[11:01:52.230]                           version <- utils::packageVersion("future")
[11:01:52.230]                       }
[11:01:52.230]                       else {
[11:01:52.230]                         version <- NULL
[11:01:52.230]                       }
[11:01:52.230]                       if (!has_future || version < "1.8.0") {
[11:01:52.230]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.230]                           "", base::R.version$version.string), 
[11:01:52.230]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.230]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.230]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.230]                             "release", "version")], collapse = " "), 
[11:01:52.230]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.230]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.230]                           info)
[11:01:52.230]                         info <- base::paste(info, collapse = "; ")
[11:01:52.230]                         if (!has_future) {
[11:01:52.230]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.230]                             info)
[11:01:52.230]                         }
[11:01:52.230]                         else {
[11:01:52.230]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.230]                             info, version)
[11:01:52.230]                         }
[11:01:52.230]                         base::stop(msg)
[11:01:52.230]                       }
[11:01:52.230]                     })
[11:01:52.230]                   }
[11:01:52.230]                   ...future.strategy.old <- future::plan("list")
[11:01:52.230]                   options(future.plan = NULL)
[11:01:52.230]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.230]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.230]                 }
[11:01:52.230]                 ...future.workdir <- getwd()
[11:01:52.230]             }
[11:01:52.230]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.230]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.230]         }
[11:01:52.230]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.230]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.230]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.230]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.230]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.230]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.230]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.230]             base::names(...future.oldOptions))
[11:01:52.230]     }
[11:01:52.230]     if (FALSE) {
[11:01:52.230]     }
[11:01:52.230]     else {
[11:01:52.230]         if (TRUE) {
[11:01:52.230]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.230]                 open = "w")
[11:01:52.230]         }
[11:01:52.230]         else {
[11:01:52.230]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.230]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.230]         }
[11:01:52.230]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.230]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.230]             base::sink(type = "output", split = FALSE)
[11:01:52.230]             base::close(...future.stdout)
[11:01:52.230]         }, add = TRUE)
[11:01:52.230]     }
[11:01:52.230]     ...future.frame <- base::sys.nframe()
[11:01:52.230]     ...future.conditions <- base::list()
[11:01:52.230]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.230]     if (FALSE) {
[11:01:52.230]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.230]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.230]     }
[11:01:52.230]     ...future.result <- base::tryCatch({
[11:01:52.230]         base::withCallingHandlers({
[11:01:52.230]             ...future.value <- base::withVisible(base::local(1))
[11:01:52.230]             future::FutureResult(value = ...future.value$value, 
[11:01:52.230]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.230]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.230]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.230]                     ...future.globalenv.names))
[11:01:52.230]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.230]         }, condition = base::local({
[11:01:52.230]             c <- base::c
[11:01:52.230]             inherits <- base::inherits
[11:01:52.230]             invokeRestart <- base::invokeRestart
[11:01:52.230]             length <- base::length
[11:01:52.230]             list <- base::list
[11:01:52.230]             seq.int <- base::seq.int
[11:01:52.230]             signalCondition <- base::signalCondition
[11:01:52.230]             sys.calls <- base::sys.calls
[11:01:52.230]             `[[` <- base::`[[`
[11:01:52.230]             `+` <- base::`+`
[11:01:52.230]             `<<-` <- base::`<<-`
[11:01:52.230]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.230]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.230]                   3L)]
[11:01:52.230]             }
[11:01:52.230]             function(cond) {
[11:01:52.230]                 is_error <- inherits(cond, "error")
[11:01:52.230]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.230]                   NULL)
[11:01:52.230]                 if (is_error) {
[11:01:52.230]                   sessionInformation <- function() {
[11:01:52.230]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.230]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.230]                       search = base::search(), system = base::Sys.info())
[11:01:52.230]                   }
[11:01:52.230]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.230]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.230]                     cond$call), session = sessionInformation(), 
[11:01:52.230]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.230]                   signalCondition(cond)
[11:01:52.230]                 }
[11:01:52.230]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.230]                 "immediateCondition"))) {
[11:01:52.230]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.230]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.230]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.230]                   if (TRUE && !signal) {
[11:01:52.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.230]                     {
[11:01:52.230]                       inherits <- base::inherits
[11:01:52.230]                       invokeRestart <- base::invokeRestart
[11:01:52.230]                       is.null <- base::is.null
[11:01:52.230]                       muffled <- FALSE
[11:01:52.230]                       if (inherits(cond, "message")) {
[11:01:52.230]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.230]                         if (muffled) 
[11:01:52.230]                           invokeRestart("muffleMessage")
[11:01:52.230]                       }
[11:01:52.230]                       else if (inherits(cond, "warning")) {
[11:01:52.230]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.230]                         if (muffled) 
[11:01:52.230]                           invokeRestart("muffleWarning")
[11:01:52.230]                       }
[11:01:52.230]                       else if (inherits(cond, "condition")) {
[11:01:52.230]                         if (!is.null(pattern)) {
[11:01:52.230]                           computeRestarts <- base::computeRestarts
[11:01:52.230]                           grepl <- base::grepl
[11:01:52.230]                           restarts <- computeRestarts(cond)
[11:01:52.230]                           for (restart in restarts) {
[11:01:52.230]                             name <- restart$name
[11:01:52.230]                             if (is.null(name)) 
[11:01:52.230]                               next
[11:01:52.230]                             if (!grepl(pattern, name)) 
[11:01:52.230]                               next
[11:01:52.230]                             invokeRestart(restart)
[11:01:52.230]                             muffled <- TRUE
[11:01:52.230]                             break
[11:01:52.230]                           }
[11:01:52.230]                         }
[11:01:52.230]                       }
[11:01:52.230]                       invisible(muffled)
[11:01:52.230]                     }
[11:01:52.230]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.230]                   }
[11:01:52.230]                 }
[11:01:52.230]                 else {
[11:01:52.230]                   if (TRUE) {
[11:01:52.230]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.230]                     {
[11:01:52.230]                       inherits <- base::inherits
[11:01:52.230]                       invokeRestart <- base::invokeRestart
[11:01:52.230]                       is.null <- base::is.null
[11:01:52.230]                       muffled <- FALSE
[11:01:52.230]                       if (inherits(cond, "message")) {
[11:01:52.230]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.230]                         if (muffled) 
[11:01:52.230]                           invokeRestart("muffleMessage")
[11:01:52.230]                       }
[11:01:52.230]                       else if (inherits(cond, "warning")) {
[11:01:52.230]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.230]                         if (muffled) 
[11:01:52.230]                           invokeRestart("muffleWarning")
[11:01:52.230]                       }
[11:01:52.230]                       else if (inherits(cond, "condition")) {
[11:01:52.230]                         if (!is.null(pattern)) {
[11:01:52.230]                           computeRestarts <- base::computeRestarts
[11:01:52.230]                           grepl <- base::grepl
[11:01:52.230]                           restarts <- computeRestarts(cond)
[11:01:52.230]                           for (restart in restarts) {
[11:01:52.230]                             name <- restart$name
[11:01:52.230]                             if (is.null(name)) 
[11:01:52.230]                               next
[11:01:52.230]                             if (!grepl(pattern, name)) 
[11:01:52.230]                               next
[11:01:52.230]                             invokeRestart(restart)
[11:01:52.230]                             muffled <- TRUE
[11:01:52.230]                             break
[11:01:52.230]                           }
[11:01:52.230]                         }
[11:01:52.230]                       }
[11:01:52.230]                       invisible(muffled)
[11:01:52.230]                     }
[11:01:52.230]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.230]                   }
[11:01:52.230]                 }
[11:01:52.230]             }
[11:01:52.230]         }))
[11:01:52.230]     }, error = function(ex) {
[11:01:52.230]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.230]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.230]                 ...future.rng), started = ...future.startTime, 
[11:01:52.230]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.230]             version = "1.8"), class = "FutureResult")
[11:01:52.230]     }, finally = {
[11:01:52.230]         if (!identical(...future.workdir, getwd())) 
[11:01:52.230]             setwd(...future.workdir)
[11:01:52.230]         {
[11:01:52.230]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.230]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.230]             }
[11:01:52.230]             base::options(...future.oldOptions)
[11:01:52.230]             if (.Platform$OS.type == "windows") {
[11:01:52.230]                 old_names <- names(...future.oldEnvVars)
[11:01:52.230]                 envs <- base::Sys.getenv()
[11:01:52.230]                 names <- names(envs)
[11:01:52.230]                 common <- intersect(names, old_names)
[11:01:52.230]                 added <- setdiff(names, old_names)
[11:01:52.230]                 removed <- setdiff(old_names, names)
[11:01:52.230]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.230]                   envs[common]]
[11:01:52.230]                 NAMES <- toupper(changed)
[11:01:52.230]                 args <- list()
[11:01:52.230]                 for (kk in seq_along(NAMES)) {
[11:01:52.230]                   name <- changed[[kk]]
[11:01:52.230]                   NAME <- NAMES[[kk]]
[11:01:52.230]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.230]                     next
[11:01:52.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.230]                 }
[11:01:52.230]                 NAMES <- toupper(added)
[11:01:52.230]                 for (kk in seq_along(NAMES)) {
[11:01:52.230]                   name <- added[[kk]]
[11:01:52.230]                   NAME <- NAMES[[kk]]
[11:01:52.230]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.230]                     next
[11:01:52.230]                   args[[name]] <- ""
[11:01:52.230]                 }
[11:01:52.230]                 NAMES <- toupper(removed)
[11:01:52.230]                 for (kk in seq_along(NAMES)) {
[11:01:52.230]                   name <- removed[[kk]]
[11:01:52.230]                   NAME <- NAMES[[kk]]
[11:01:52.230]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.230]                     next
[11:01:52.230]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.230]                 }
[11:01:52.230]                 if (length(args) > 0) 
[11:01:52.230]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.230]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.230]             }
[11:01:52.230]             else {
[11:01:52.230]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.230]             }
[11:01:52.230]             {
[11:01:52.230]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.230]                   0L) {
[11:01:52.230]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.230]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.230]                   base::options(opts)
[11:01:52.230]                 }
[11:01:52.230]                 {
[11:01:52.230]                   {
[11:01:52.230]                     NULL
[11:01:52.230]                     RNGkind("Mersenne-Twister")
[11:01:52.230]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.230]                       inherits = FALSE)
[11:01:52.230]                   }
[11:01:52.230]                   options(future.plan = NULL)
[11:01:52.230]                   if (is.na(NA_character_)) 
[11:01:52.230]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.230]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.230]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.230]                     .init = FALSE)
[11:01:52.230]                 }
[11:01:52.230]             }
[11:01:52.230]         }
[11:01:52.230]     })
[11:01:52.230]     if (TRUE) {
[11:01:52.230]         base::sink(type = "output", split = FALSE)
[11:01:52.230]         if (TRUE) {
[11:01:52.230]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.230]         }
[11:01:52.230]         else {
[11:01:52.230]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.230]         }
[11:01:52.230]         base::close(...future.stdout)
[11:01:52.230]         ...future.stdout <- NULL
[11:01:52.230]     }
[11:01:52.230]     ...future.result$conditions <- ...future.conditions
[11:01:52.230]     ...future.result$finished <- base::Sys.time()
[11:01:52.230]     ...future.result
[11:01:52.230] }
[11:01:52.231] plan(): Setting new future strategy stack:
[11:01:52.232] List of future strategies:
[11:01:52.232] 1. sequential:
[11:01:52.232]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.232]    - tweaked: FALSE
[11:01:52.232]    - call: NULL
[11:01:52.232] plan(): nbrOfWorkers() = 1
[11:01:52.233] plan(): Setting new future strategy stack:
[11:01:52.233] List of future strategies:
[11:01:52.233] 1. sequential:
[11:01:52.233]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.233]    - tweaked: FALSE
[11:01:52.233]    - call: plan(strategy)
[11:01:52.233] plan(): nbrOfWorkers() = 1
[11:01:52.233] SequentialFuture started (and completed)
[11:01:52.233] - Launch lazy future ... done
[11:01:52.233] run() for ‘SequentialFuture’ ... done
[11:01:52.234] resolved() for ‘SequentialFuture’ ...
[11:01:52.234] - state: ‘finished’
[11:01:52.234] - run: TRUE
[11:01:52.234] - result: ‘FutureResult’
[11:01:52.234] resolved() for ‘SequentialFuture’ ... done
[11:01:52.234] Future #1
[11:01:52.234] resolved() for ‘SequentialFuture’ ...
[11:01:52.234] - state: ‘finished’
[11:01:52.234] - run: TRUE
[11:01:52.234] - result: ‘FutureResult’
[11:01:52.234] resolved() for ‘SequentialFuture’ ... done
[11:01:52.235] A SequentialFuture was resolved
[11:01:52.235]  length: 0 (resolved future 1)
[11:01:52.235] resolve() on list ... DONE
[11:01:52.235] - globals: [1] ‘a’
[11:01:52.235] Resolving futures part of globals (recursively) ... DONE
[11:01:52.235] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[11:01:52.235] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[11:01:52.235] - globals: [1] ‘a’
[11:01:52.236] - packages: [1] ‘future’
[11:01:52.236] getGlobalsAndPackages() ... DONE
[11:01:52.236] run() for ‘Future’ ...
[11:01:52.236] - state: ‘created’
[11:01:52.236] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.236] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.236] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.237]   - Field: ‘label’
[11:01:52.237]   - Field: ‘local’
[11:01:52.237]   - Field: ‘owner’
[11:01:52.237]   - Field: ‘envir’
[11:01:52.237]   - Field: ‘packages’
[11:01:52.237]   - Field: ‘gc’
[11:01:52.237]   - Field: ‘conditions’
[11:01:52.237]   - Field: ‘expr’
[11:01:52.237]   - Field: ‘uuid’
[11:01:52.237]   - Field: ‘seed’
[11:01:52.237]   - Field: ‘version’
[11:01:52.237]   - Field: ‘result’
[11:01:52.238]   - Field: ‘asynchronous’
[11:01:52.238]   - Field: ‘calls’
[11:01:52.238]   - Field: ‘globals’
[11:01:52.238]   - Field: ‘stdout’
[11:01:52.238]   - Field: ‘earlySignal’
[11:01:52.238]   - Field: ‘lazy’
[11:01:52.238]   - Field: ‘state’
[11:01:52.238] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.238] - Launch lazy future ...
[11:01:52.238] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.238] Packages needed by future strategies (n = 0): <none>
[11:01:52.239] {
[11:01:52.239]     {
[11:01:52.239]         {
[11:01:52.239]             ...future.startTime <- base::Sys.time()
[11:01:52.239]             {
[11:01:52.239]                 {
[11:01:52.239]                   {
[11:01:52.239]                     {
[11:01:52.239]                       base::local({
[11:01:52.239]                         has_future <- base::requireNamespace("future", 
[11:01:52.239]                           quietly = TRUE)
[11:01:52.239]                         if (has_future) {
[11:01:52.239]                           ns <- base::getNamespace("future")
[11:01:52.239]                           version <- ns[[".package"]][["version"]]
[11:01:52.239]                           if (is.null(version)) 
[11:01:52.239]                             version <- utils::packageVersion("future")
[11:01:52.239]                         }
[11:01:52.239]                         else {
[11:01:52.239]                           version <- NULL
[11:01:52.239]                         }
[11:01:52.239]                         if (!has_future || version < "1.8.0") {
[11:01:52.239]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.239]                             "", base::R.version$version.string), 
[11:01:52.239]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.239]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.239]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.239]                               "release", "version")], collapse = " "), 
[11:01:52.239]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.239]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.239]                             info)
[11:01:52.239]                           info <- base::paste(info, collapse = "; ")
[11:01:52.239]                           if (!has_future) {
[11:01:52.239]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.239]                               info)
[11:01:52.239]                           }
[11:01:52.239]                           else {
[11:01:52.239]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.239]                               info, version)
[11:01:52.239]                           }
[11:01:52.239]                           base::stop(msg)
[11:01:52.239]                         }
[11:01:52.239]                       })
[11:01:52.239]                     }
[11:01:52.239]                     base::local({
[11:01:52.239]                       for (pkg in "future") {
[11:01:52.239]                         base::loadNamespace(pkg)
[11:01:52.239]                         base::library(pkg, character.only = TRUE)
[11:01:52.239]                       }
[11:01:52.239]                     })
[11:01:52.239]                   }
[11:01:52.239]                   ...future.strategy.old <- future::plan("list")
[11:01:52.239]                   options(future.plan = NULL)
[11:01:52.239]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.239]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.239]                 }
[11:01:52.239]                 ...future.workdir <- getwd()
[11:01:52.239]             }
[11:01:52.239]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.239]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.239]         }
[11:01:52.239]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.239]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.239]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.239]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.239]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.239]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.239]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.239]             base::names(...future.oldOptions))
[11:01:52.239]     }
[11:01:52.239]     if (FALSE) {
[11:01:52.239]     }
[11:01:52.239]     else {
[11:01:52.239]         if (TRUE) {
[11:01:52.239]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.239]                 open = "w")
[11:01:52.239]         }
[11:01:52.239]         else {
[11:01:52.239]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.239]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.239]         }
[11:01:52.239]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.239]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.239]             base::sink(type = "output", split = FALSE)
[11:01:52.239]             base::close(...future.stdout)
[11:01:52.239]         }, add = TRUE)
[11:01:52.239]     }
[11:01:52.239]     ...future.frame <- base::sys.nframe()
[11:01:52.239]     ...future.conditions <- base::list()
[11:01:52.239]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.239]     if (FALSE) {
[11:01:52.239]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.239]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.239]     }
[11:01:52.239]     ...future.result <- base::tryCatch({
[11:01:52.239]         base::withCallingHandlers({
[11:01:52.239]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:52.239]                 1))
[11:01:52.239]             future::FutureResult(value = ...future.value$value, 
[11:01:52.239]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.239]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.239]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.239]                     ...future.globalenv.names))
[11:01:52.239]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.239]         }, condition = base::local({
[11:01:52.239]             c <- base::c
[11:01:52.239]             inherits <- base::inherits
[11:01:52.239]             invokeRestart <- base::invokeRestart
[11:01:52.239]             length <- base::length
[11:01:52.239]             list <- base::list
[11:01:52.239]             seq.int <- base::seq.int
[11:01:52.239]             signalCondition <- base::signalCondition
[11:01:52.239]             sys.calls <- base::sys.calls
[11:01:52.239]             `[[` <- base::`[[`
[11:01:52.239]             `+` <- base::`+`
[11:01:52.239]             `<<-` <- base::`<<-`
[11:01:52.239]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.239]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.239]                   3L)]
[11:01:52.239]             }
[11:01:52.239]             function(cond) {
[11:01:52.239]                 is_error <- inherits(cond, "error")
[11:01:52.239]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.239]                   NULL)
[11:01:52.239]                 if (is_error) {
[11:01:52.239]                   sessionInformation <- function() {
[11:01:52.239]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.239]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.239]                       search = base::search(), system = base::Sys.info())
[11:01:52.239]                   }
[11:01:52.239]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.239]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.239]                     cond$call), session = sessionInformation(), 
[11:01:52.239]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.239]                   signalCondition(cond)
[11:01:52.239]                 }
[11:01:52.239]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.239]                 "immediateCondition"))) {
[11:01:52.239]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.239]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.239]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.239]                   if (TRUE && !signal) {
[11:01:52.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.239]                     {
[11:01:52.239]                       inherits <- base::inherits
[11:01:52.239]                       invokeRestart <- base::invokeRestart
[11:01:52.239]                       is.null <- base::is.null
[11:01:52.239]                       muffled <- FALSE
[11:01:52.239]                       if (inherits(cond, "message")) {
[11:01:52.239]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.239]                         if (muffled) 
[11:01:52.239]                           invokeRestart("muffleMessage")
[11:01:52.239]                       }
[11:01:52.239]                       else if (inherits(cond, "warning")) {
[11:01:52.239]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.239]                         if (muffled) 
[11:01:52.239]                           invokeRestart("muffleWarning")
[11:01:52.239]                       }
[11:01:52.239]                       else if (inherits(cond, "condition")) {
[11:01:52.239]                         if (!is.null(pattern)) {
[11:01:52.239]                           computeRestarts <- base::computeRestarts
[11:01:52.239]                           grepl <- base::grepl
[11:01:52.239]                           restarts <- computeRestarts(cond)
[11:01:52.239]                           for (restart in restarts) {
[11:01:52.239]                             name <- restart$name
[11:01:52.239]                             if (is.null(name)) 
[11:01:52.239]                               next
[11:01:52.239]                             if (!grepl(pattern, name)) 
[11:01:52.239]                               next
[11:01:52.239]                             invokeRestart(restart)
[11:01:52.239]                             muffled <- TRUE
[11:01:52.239]                             break
[11:01:52.239]                           }
[11:01:52.239]                         }
[11:01:52.239]                       }
[11:01:52.239]                       invisible(muffled)
[11:01:52.239]                     }
[11:01:52.239]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.239]                   }
[11:01:52.239]                 }
[11:01:52.239]                 else {
[11:01:52.239]                   if (TRUE) {
[11:01:52.239]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.239]                     {
[11:01:52.239]                       inherits <- base::inherits
[11:01:52.239]                       invokeRestart <- base::invokeRestart
[11:01:52.239]                       is.null <- base::is.null
[11:01:52.239]                       muffled <- FALSE
[11:01:52.239]                       if (inherits(cond, "message")) {
[11:01:52.239]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.239]                         if (muffled) 
[11:01:52.239]                           invokeRestart("muffleMessage")
[11:01:52.239]                       }
[11:01:52.239]                       else if (inherits(cond, "warning")) {
[11:01:52.239]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.239]                         if (muffled) 
[11:01:52.239]                           invokeRestart("muffleWarning")
[11:01:52.239]                       }
[11:01:52.239]                       else if (inherits(cond, "condition")) {
[11:01:52.239]                         if (!is.null(pattern)) {
[11:01:52.239]                           computeRestarts <- base::computeRestarts
[11:01:52.239]                           grepl <- base::grepl
[11:01:52.239]                           restarts <- computeRestarts(cond)
[11:01:52.239]                           for (restart in restarts) {
[11:01:52.239]                             name <- restart$name
[11:01:52.239]                             if (is.null(name)) 
[11:01:52.239]                               next
[11:01:52.239]                             if (!grepl(pattern, name)) 
[11:01:52.239]                               next
[11:01:52.239]                             invokeRestart(restart)
[11:01:52.239]                             muffled <- TRUE
[11:01:52.239]                             break
[11:01:52.239]                           }
[11:01:52.239]                         }
[11:01:52.239]                       }
[11:01:52.239]                       invisible(muffled)
[11:01:52.239]                     }
[11:01:52.239]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.239]                   }
[11:01:52.239]                 }
[11:01:52.239]             }
[11:01:52.239]         }))
[11:01:52.239]     }, error = function(ex) {
[11:01:52.239]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.239]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.239]                 ...future.rng), started = ...future.startTime, 
[11:01:52.239]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.239]             version = "1.8"), class = "FutureResult")
[11:01:52.239]     }, finally = {
[11:01:52.239]         if (!identical(...future.workdir, getwd())) 
[11:01:52.239]             setwd(...future.workdir)
[11:01:52.239]         {
[11:01:52.239]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.239]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.239]             }
[11:01:52.239]             base::options(...future.oldOptions)
[11:01:52.239]             if (.Platform$OS.type == "windows") {
[11:01:52.239]                 old_names <- names(...future.oldEnvVars)
[11:01:52.239]                 envs <- base::Sys.getenv()
[11:01:52.239]                 names <- names(envs)
[11:01:52.239]                 common <- intersect(names, old_names)
[11:01:52.239]                 added <- setdiff(names, old_names)
[11:01:52.239]                 removed <- setdiff(old_names, names)
[11:01:52.239]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.239]                   envs[common]]
[11:01:52.239]                 NAMES <- toupper(changed)
[11:01:52.239]                 args <- list()
[11:01:52.239]                 for (kk in seq_along(NAMES)) {
[11:01:52.239]                   name <- changed[[kk]]
[11:01:52.239]                   NAME <- NAMES[[kk]]
[11:01:52.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.239]                     next
[11:01:52.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.239]                 }
[11:01:52.239]                 NAMES <- toupper(added)
[11:01:52.239]                 for (kk in seq_along(NAMES)) {
[11:01:52.239]                   name <- added[[kk]]
[11:01:52.239]                   NAME <- NAMES[[kk]]
[11:01:52.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.239]                     next
[11:01:52.239]                   args[[name]] <- ""
[11:01:52.239]                 }
[11:01:52.239]                 NAMES <- toupper(removed)
[11:01:52.239]                 for (kk in seq_along(NAMES)) {
[11:01:52.239]                   name <- removed[[kk]]
[11:01:52.239]                   NAME <- NAMES[[kk]]
[11:01:52.239]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.239]                     next
[11:01:52.239]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.239]                 }
[11:01:52.239]                 if (length(args) > 0) 
[11:01:52.239]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.239]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.239]             }
[11:01:52.239]             else {
[11:01:52.239]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.239]             }
[11:01:52.239]             {
[11:01:52.239]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.239]                   0L) {
[11:01:52.239]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.239]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.239]                   base::options(opts)
[11:01:52.239]                 }
[11:01:52.239]                 {
[11:01:52.239]                   {
[11:01:52.239]                     NULL
[11:01:52.239]                     RNGkind("Mersenne-Twister")
[11:01:52.239]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.239]                       inherits = FALSE)
[11:01:52.239]                   }
[11:01:52.239]                   options(future.plan = NULL)
[11:01:52.239]                   if (is.na(NA_character_)) 
[11:01:52.239]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.239]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.239]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.239]                     .init = FALSE)
[11:01:52.239]                 }
[11:01:52.239]             }
[11:01:52.239]         }
[11:01:52.239]     })
[11:01:52.239]     if (TRUE) {
[11:01:52.239]         base::sink(type = "output", split = FALSE)
[11:01:52.239]         if (TRUE) {
[11:01:52.239]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.239]         }
[11:01:52.239]         else {
[11:01:52.239]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.239]         }
[11:01:52.239]         base::close(...future.stdout)
[11:01:52.239]         ...future.stdout <- NULL
[11:01:52.239]     }
[11:01:52.239]     ...future.result$conditions <- ...future.conditions
[11:01:52.239]     ...future.result$finished <- base::Sys.time()
[11:01:52.239]     ...future.result
[11:01:52.239] }
[11:01:52.240] assign_globals() ...
[11:01:52.241] List of 1
[11:01:52.241]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eecc1da028> 
[11:01:52.241]  - attr(*, "where")=List of 1
[11:01:52.241]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.241]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.241]  - attr(*, "resolved")= logi TRUE
[11:01:52.241]  - attr(*, "total_size")= num 3555
[11:01:52.241]  - attr(*, "already-done")= logi TRUE
[11:01:52.243] - copied ‘a’ to environment
[11:01:52.243] assign_globals() ... done
[11:01:52.243] plan(): Setting new future strategy stack:
[11:01:52.243] List of future strategies:
[11:01:52.243] 1. sequential:
[11:01:52.243]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.243]    - tweaked: FALSE
[11:01:52.243]    - call: NULL
[11:01:52.244] plan(): nbrOfWorkers() = 1
[11:01:52.245] plan(): Setting new future strategy stack:
[11:01:52.245] List of future strategies:
[11:01:52.245] 1. sequential:
[11:01:52.245]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.245]    - tweaked: FALSE
[11:01:52.245]    - call: plan(strategy)
[11:01:52.245] plan(): nbrOfWorkers() = 1
[11:01:52.246] SequentialFuture started (and completed)
[11:01:52.246] - Launch lazy future ... done
[11:01:52.246] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.247] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.247] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.247] 
[11:01:52.247] Searching for globals ... DONE
[11:01:52.247] - globals: [0] <none>
[11:01:52.247] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.248] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.248] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.249] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.249] Searching for globals ... DONE
[11:01:52.249] Resolving globals: TRUE
[11:01:52.249] Resolving any globals that are futures ...
[11:01:52.249] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.249] Resolving any globals that are futures ... DONE
[11:01:52.249] Resolving futures part of globals (recursively) ...
[11:01:52.249] resolve() on list ...
[11:01:52.250]  recursive: 99
[11:01:52.250]  length: 1
[11:01:52.250]  elements: ‘a’
[11:01:52.250] run() for ‘Future’ ...
[11:01:52.250] - state: ‘created’
[11:01:52.250] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.250] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.250] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.250]   - Field: ‘label’
[11:01:52.251]   - Field: ‘local’
[11:01:52.251]   - Field: ‘owner’
[11:01:52.251]   - Field: ‘envir’
[11:01:52.251]   - Field: ‘packages’
[11:01:52.251]   - Field: ‘gc’
[11:01:52.251]   - Field: ‘conditions’
[11:01:52.251]   - Field: ‘expr’
[11:01:52.251]   - Field: ‘uuid’
[11:01:52.251]   - Field: ‘seed’
[11:01:52.251]   - Field: ‘version’
[11:01:52.251]   - Field: ‘result’
[11:01:52.251]   - Field: ‘asynchronous’
[11:01:52.251]   - Field: ‘calls’
[11:01:52.252]   - Field: ‘globals’
[11:01:52.252]   - Field: ‘stdout’
[11:01:52.252]   - Field: ‘earlySignal’
[11:01:52.252]   - Field: ‘lazy’
[11:01:52.252]   - Field: ‘state’
[11:01:52.252] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.252] - Launch lazy future ...
[11:01:52.252] Packages needed by the future expression (n = 0): <none>
[11:01:52.252] Packages needed by future strategies (n = 0): <none>
[11:01:52.253] {
[11:01:52.253]     {
[11:01:52.253]         {
[11:01:52.253]             ...future.startTime <- base::Sys.time()
[11:01:52.253]             {
[11:01:52.253]                 {
[11:01:52.253]                   {
[11:01:52.253]                     base::local({
[11:01:52.253]                       has_future <- base::requireNamespace("future", 
[11:01:52.253]                         quietly = TRUE)
[11:01:52.253]                       if (has_future) {
[11:01:52.253]                         ns <- base::getNamespace("future")
[11:01:52.253]                         version <- ns[[".package"]][["version"]]
[11:01:52.253]                         if (is.null(version)) 
[11:01:52.253]                           version <- utils::packageVersion("future")
[11:01:52.253]                       }
[11:01:52.253]                       else {
[11:01:52.253]                         version <- NULL
[11:01:52.253]                       }
[11:01:52.253]                       if (!has_future || version < "1.8.0") {
[11:01:52.253]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.253]                           "", base::R.version$version.string), 
[11:01:52.253]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.253]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.253]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.253]                             "release", "version")], collapse = " "), 
[11:01:52.253]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.253]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.253]                           info)
[11:01:52.253]                         info <- base::paste(info, collapse = "; ")
[11:01:52.253]                         if (!has_future) {
[11:01:52.253]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.253]                             info)
[11:01:52.253]                         }
[11:01:52.253]                         else {
[11:01:52.253]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.253]                             info, version)
[11:01:52.253]                         }
[11:01:52.253]                         base::stop(msg)
[11:01:52.253]                       }
[11:01:52.253]                     })
[11:01:52.253]                   }
[11:01:52.253]                   ...future.strategy.old <- future::plan("list")
[11:01:52.253]                   options(future.plan = NULL)
[11:01:52.253]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.253]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.253]                 }
[11:01:52.253]                 ...future.workdir <- getwd()
[11:01:52.253]             }
[11:01:52.253]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.253]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.253]         }
[11:01:52.253]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.253]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.253]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.253]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.253]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.253]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.253]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.253]             base::names(...future.oldOptions))
[11:01:52.253]     }
[11:01:52.253]     if (FALSE) {
[11:01:52.253]     }
[11:01:52.253]     else {
[11:01:52.253]         if (TRUE) {
[11:01:52.253]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.253]                 open = "w")
[11:01:52.253]         }
[11:01:52.253]         else {
[11:01:52.253]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.253]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.253]         }
[11:01:52.253]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.253]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.253]             base::sink(type = "output", split = FALSE)
[11:01:52.253]             base::close(...future.stdout)
[11:01:52.253]         }, add = TRUE)
[11:01:52.253]     }
[11:01:52.253]     ...future.frame <- base::sys.nframe()
[11:01:52.253]     ...future.conditions <- base::list()
[11:01:52.253]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.253]     if (FALSE) {
[11:01:52.253]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.253]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.253]     }
[11:01:52.253]     ...future.result <- base::tryCatch({
[11:01:52.253]         base::withCallingHandlers({
[11:01:52.253]             ...future.value <- base::withVisible(base::local(1))
[11:01:52.253]             future::FutureResult(value = ...future.value$value, 
[11:01:52.253]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.253]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.253]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.253]                     ...future.globalenv.names))
[11:01:52.253]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.253]         }, condition = base::local({
[11:01:52.253]             c <- base::c
[11:01:52.253]             inherits <- base::inherits
[11:01:52.253]             invokeRestart <- base::invokeRestart
[11:01:52.253]             length <- base::length
[11:01:52.253]             list <- base::list
[11:01:52.253]             seq.int <- base::seq.int
[11:01:52.253]             signalCondition <- base::signalCondition
[11:01:52.253]             sys.calls <- base::sys.calls
[11:01:52.253]             `[[` <- base::`[[`
[11:01:52.253]             `+` <- base::`+`
[11:01:52.253]             `<<-` <- base::`<<-`
[11:01:52.253]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.253]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.253]                   3L)]
[11:01:52.253]             }
[11:01:52.253]             function(cond) {
[11:01:52.253]                 is_error <- inherits(cond, "error")
[11:01:52.253]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.253]                   NULL)
[11:01:52.253]                 if (is_error) {
[11:01:52.253]                   sessionInformation <- function() {
[11:01:52.253]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.253]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.253]                       search = base::search(), system = base::Sys.info())
[11:01:52.253]                   }
[11:01:52.253]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.253]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.253]                     cond$call), session = sessionInformation(), 
[11:01:52.253]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.253]                   signalCondition(cond)
[11:01:52.253]                 }
[11:01:52.253]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.253]                 "immediateCondition"))) {
[11:01:52.253]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.253]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.253]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.253]                   if (TRUE && !signal) {
[11:01:52.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.253]                     {
[11:01:52.253]                       inherits <- base::inherits
[11:01:52.253]                       invokeRestart <- base::invokeRestart
[11:01:52.253]                       is.null <- base::is.null
[11:01:52.253]                       muffled <- FALSE
[11:01:52.253]                       if (inherits(cond, "message")) {
[11:01:52.253]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.253]                         if (muffled) 
[11:01:52.253]                           invokeRestart("muffleMessage")
[11:01:52.253]                       }
[11:01:52.253]                       else if (inherits(cond, "warning")) {
[11:01:52.253]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.253]                         if (muffled) 
[11:01:52.253]                           invokeRestart("muffleWarning")
[11:01:52.253]                       }
[11:01:52.253]                       else if (inherits(cond, "condition")) {
[11:01:52.253]                         if (!is.null(pattern)) {
[11:01:52.253]                           computeRestarts <- base::computeRestarts
[11:01:52.253]                           grepl <- base::grepl
[11:01:52.253]                           restarts <- computeRestarts(cond)
[11:01:52.253]                           for (restart in restarts) {
[11:01:52.253]                             name <- restart$name
[11:01:52.253]                             if (is.null(name)) 
[11:01:52.253]                               next
[11:01:52.253]                             if (!grepl(pattern, name)) 
[11:01:52.253]                               next
[11:01:52.253]                             invokeRestart(restart)
[11:01:52.253]                             muffled <- TRUE
[11:01:52.253]                             break
[11:01:52.253]                           }
[11:01:52.253]                         }
[11:01:52.253]                       }
[11:01:52.253]                       invisible(muffled)
[11:01:52.253]                     }
[11:01:52.253]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.253]                   }
[11:01:52.253]                 }
[11:01:52.253]                 else {
[11:01:52.253]                   if (TRUE) {
[11:01:52.253]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.253]                     {
[11:01:52.253]                       inherits <- base::inherits
[11:01:52.253]                       invokeRestart <- base::invokeRestart
[11:01:52.253]                       is.null <- base::is.null
[11:01:52.253]                       muffled <- FALSE
[11:01:52.253]                       if (inherits(cond, "message")) {
[11:01:52.253]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.253]                         if (muffled) 
[11:01:52.253]                           invokeRestart("muffleMessage")
[11:01:52.253]                       }
[11:01:52.253]                       else if (inherits(cond, "warning")) {
[11:01:52.253]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.253]                         if (muffled) 
[11:01:52.253]                           invokeRestart("muffleWarning")
[11:01:52.253]                       }
[11:01:52.253]                       else if (inherits(cond, "condition")) {
[11:01:52.253]                         if (!is.null(pattern)) {
[11:01:52.253]                           computeRestarts <- base::computeRestarts
[11:01:52.253]                           grepl <- base::grepl
[11:01:52.253]                           restarts <- computeRestarts(cond)
[11:01:52.253]                           for (restart in restarts) {
[11:01:52.253]                             name <- restart$name
[11:01:52.253]                             if (is.null(name)) 
[11:01:52.253]                               next
[11:01:52.253]                             if (!grepl(pattern, name)) 
[11:01:52.253]                               next
[11:01:52.253]                             invokeRestart(restart)
[11:01:52.253]                             muffled <- TRUE
[11:01:52.253]                             break
[11:01:52.253]                           }
[11:01:52.253]                         }
[11:01:52.253]                       }
[11:01:52.253]                       invisible(muffled)
[11:01:52.253]                     }
[11:01:52.253]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.253]                   }
[11:01:52.253]                 }
[11:01:52.253]             }
[11:01:52.253]         }))
[11:01:52.253]     }, error = function(ex) {
[11:01:52.253]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.253]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.253]                 ...future.rng), started = ...future.startTime, 
[11:01:52.253]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.253]             version = "1.8"), class = "FutureResult")
[11:01:52.253]     }, finally = {
[11:01:52.253]         if (!identical(...future.workdir, getwd())) 
[11:01:52.253]             setwd(...future.workdir)
[11:01:52.253]         {
[11:01:52.253]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.253]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.253]             }
[11:01:52.253]             base::options(...future.oldOptions)
[11:01:52.253]             if (.Platform$OS.type == "windows") {
[11:01:52.253]                 old_names <- names(...future.oldEnvVars)
[11:01:52.253]                 envs <- base::Sys.getenv()
[11:01:52.253]                 names <- names(envs)
[11:01:52.253]                 common <- intersect(names, old_names)
[11:01:52.253]                 added <- setdiff(names, old_names)
[11:01:52.253]                 removed <- setdiff(old_names, names)
[11:01:52.253]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.253]                   envs[common]]
[11:01:52.253]                 NAMES <- toupper(changed)
[11:01:52.253]                 args <- list()
[11:01:52.253]                 for (kk in seq_along(NAMES)) {
[11:01:52.253]                   name <- changed[[kk]]
[11:01:52.253]                   NAME <- NAMES[[kk]]
[11:01:52.253]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.253]                     next
[11:01:52.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.253]                 }
[11:01:52.253]                 NAMES <- toupper(added)
[11:01:52.253]                 for (kk in seq_along(NAMES)) {
[11:01:52.253]                   name <- added[[kk]]
[11:01:52.253]                   NAME <- NAMES[[kk]]
[11:01:52.253]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.253]                     next
[11:01:52.253]                   args[[name]] <- ""
[11:01:52.253]                 }
[11:01:52.253]                 NAMES <- toupper(removed)
[11:01:52.253]                 for (kk in seq_along(NAMES)) {
[11:01:52.253]                   name <- removed[[kk]]
[11:01:52.253]                   NAME <- NAMES[[kk]]
[11:01:52.253]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.253]                     next
[11:01:52.253]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.253]                 }
[11:01:52.253]                 if (length(args) > 0) 
[11:01:52.253]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.253]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.253]             }
[11:01:52.253]             else {
[11:01:52.253]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.253]             }
[11:01:52.253]             {
[11:01:52.253]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.253]                   0L) {
[11:01:52.253]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.253]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.253]                   base::options(opts)
[11:01:52.253]                 }
[11:01:52.253]                 {
[11:01:52.253]                   {
[11:01:52.253]                     NULL
[11:01:52.253]                     RNGkind("Mersenne-Twister")
[11:01:52.253]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.253]                       inherits = FALSE)
[11:01:52.253]                   }
[11:01:52.253]                   options(future.plan = NULL)
[11:01:52.253]                   if (is.na(NA_character_)) 
[11:01:52.253]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.253]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.253]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.253]                     .init = FALSE)
[11:01:52.253]                 }
[11:01:52.253]             }
[11:01:52.253]         }
[11:01:52.253]     })
[11:01:52.253]     if (TRUE) {
[11:01:52.253]         base::sink(type = "output", split = FALSE)
[11:01:52.253]         if (TRUE) {
[11:01:52.253]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.253]         }
[11:01:52.253]         else {
[11:01:52.253]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.253]         }
[11:01:52.253]         base::close(...future.stdout)
[11:01:52.253]         ...future.stdout <- NULL
[11:01:52.253]     }
[11:01:52.253]     ...future.result$conditions <- ...future.conditions
[11:01:52.253]     ...future.result$finished <- base::Sys.time()
[11:01:52.253]     ...future.result
[11:01:52.253] }
[11:01:52.254] plan(): Setting new future strategy stack:
[11:01:52.254] List of future strategies:
[11:01:52.254] 1. sequential:
[11:01:52.254]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.254]    - tweaked: FALSE
[11:01:52.254]    - call: NULL
[11:01:52.255] plan(): nbrOfWorkers() = 1
[11:01:52.256] plan(): Setting new future strategy stack:
[11:01:52.256] List of future strategies:
[11:01:52.256] 1. sequential:
[11:01:52.256]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.256]    - tweaked: FALSE
[11:01:52.256]    - call: plan(strategy)
[11:01:52.256] plan(): nbrOfWorkers() = 1
[11:01:52.256] SequentialFuture started (and completed)
[11:01:52.256] - Launch lazy future ... done
[11:01:52.256] run() for ‘SequentialFuture’ ... done
[11:01:52.256] resolved() for ‘SequentialFuture’ ...
[11:01:52.257] - state: ‘finished’
[11:01:52.257] - run: TRUE
[11:01:52.257] - result: ‘FutureResult’
[11:01:52.257] resolved() for ‘SequentialFuture’ ... done
[11:01:52.257] Future #1
[11:01:52.257] resolved() for ‘SequentialFuture’ ...
[11:01:52.257] - state: ‘finished’
[11:01:52.257] - run: TRUE
[11:01:52.257] - result: ‘FutureResult’
[11:01:52.257] resolved() for ‘SequentialFuture’ ... done
[11:01:52.258] A SequentialFuture was resolved
[11:01:52.258]  length: 0 (resolved future 1)
[11:01:52.258] resolve() on list ... DONE
[11:01:52.258] - globals: [1] ‘a’
[11:01:52.258] Resolving futures part of globals (recursively) ... DONE
[11:01:52.258] The total size of the 1 globals is 3.47 KiB (3555 bytes)
[11:01:52.258] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.47 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.47 KiB of class ‘environment’)
[11:01:52.258] - globals: [1] ‘a’
[11:01:52.259] - packages: [1] ‘future’
[11:01:52.259] getGlobalsAndPackages() ... DONE
[11:01:52.259] run() for ‘Future’ ...
[11:01:52.259] - state: ‘created’
[11:01:52.259] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.259] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.259] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.260]   - Field: ‘label’
[11:01:52.260]   - Field: ‘local’
[11:01:52.260]   - Field: ‘owner’
[11:01:52.260]   - Field: ‘envir’
[11:01:52.260]   - Field: ‘packages’
[11:01:52.260]   - Field: ‘gc’
[11:01:52.260]   - Field: ‘conditions’
[11:01:52.260]   - Field: ‘expr’
[11:01:52.260]   - Field: ‘uuid’
[11:01:52.260]   - Field: ‘seed’
[11:01:52.260]   - Field: ‘version’
[11:01:52.260]   - Field: ‘result’
[11:01:52.261]   - Field: ‘asynchronous’
[11:01:52.261]   - Field: ‘calls’
[11:01:52.261]   - Field: ‘globals’
[11:01:52.261]   - Field: ‘stdout’
[11:01:52.261]   - Field: ‘earlySignal’
[11:01:52.261]   - Field: ‘lazy’
[11:01:52.261]   - Field: ‘state’
[11:01:52.261] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.261] - Launch lazy future ...
[11:01:52.261] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.261] Packages needed by future strategies (n = 0): <none>
[11:01:52.262] {
[11:01:52.262]     {
[11:01:52.262]         {
[11:01:52.262]             ...future.startTime <- base::Sys.time()
[11:01:52.262]             {
[11:01:52.262]                 {
[11:01:52.262]                   {
[11:01:52.262]                     {
[11:01:52.262]                       base::local({
[11:01:52.262]                         has_future <- base::requireNamespace("future", 
[11:01:52.262]                           quietly = TRUE)
[11:01:52.262]                         if (has_future) {
[11:01:52.262]                           ns <- base::getNamespace("future")
[11:01:52.262]                           version <- ns[[".package"]][["version"]]
[11:01:52.262]                           if (is.null(version)) 
[11:01:52.262]                             version <- utils::packageVersion("future")
[11:01:52.262]                         }
[11:01:52.262]                         else {
[11:01:52.262]                           version <- NULL
[11:01:52.262]                         }
[11:01:52.262]                         if (!has_future || version < "1.8.0") {
[11:01:52.262]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.262]                             "", base::R.version$version.string), 
[11:01:52.262]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.262]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.262]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.262]                               "release", "version")], collapse = " "), 
[11:01:52.262]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.262]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.262]                             info)
[11:01:52.262]                           info <- base::paste(info, collapse = "; ")
[11:01:52.262]                           if (!has_future) {
[11:01:52.262]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.262]                               info)
[11:01:52.262]                           }
[11:01:52.262]                           else {
[11:01:52.262]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.262]                               info, version)
[11:01:52.262]                           }
[11:01:52.262]                           base::stop(msg)
[11:01:52.262]                         }
[11:01:52.262]                       })
[11:01:52.262]                     }
[11:01:52.262]                     base::local({
[11:01:52.262]                       for (pkg in "future") {
[11:01:52.262]                         base::loadNamespace(pkg)
[11:01:52.262]                         base::library(pkg, character.only = TRUE)
[11:01:52.262]                       }
[11:01:52.262]                     })
[11:01:52.262]                   }
[11:01:52.262]                   ...future.strategy.old <- future::plan("list")
[11:01:52.262]                   options(future.plan = NULL)
[11:01:52.262]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.262]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.262]                 }
[11:01:52.262]                 ...future.workdir <- getwd()
[11:01:52.262]             }
[11:01:52.262]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.262]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.262]         }
[11:01:52.262]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.262]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.262]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.262]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.262]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.262]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.262]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.262]             base::names(...future.oldOptions))
[11:01:52.262]     }
[11:01:52.262]     if (FALSE) {
[11:01:52.262]     }
[11:01:52.262]     else {
[11:01:52.262]         if (TRUE) {
[11:01:52.262]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.262]                 open = "w")
[11:01:52.262]         }
[11:01:52.262]         else {
[11:01:52.262]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.262]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.262]         }
[11:01:52.262]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.262]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.262]             base::sink(type = "output", split = FALSE)
[11:01:52.262]             base::close(...future.stdout)
[11:01:52.262]         }, add = TRUE)
[11:01:52.262]     }
[11:01:52.262]     ...future.frame <- base::sys.nframe()
[11:01:52.262]     ...future.conditions <- base::list()
[11:01:52.262]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.262]     if (FALSE) {
[11:01:52.262]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.262]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.262]     }
[11:01:52.262]     ...future.result <- base::tryCatch({
[11:01:52.262]         base::withCallingHandlers({
[11:01:52.262]             ...future.value <- base::withVisible(base::local(value(a) + 
[11:01:52.262]                 1))
[11:01:52.262]             future::FutureResult(value = ...future.value$value, 
[11:01:52.262]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.262]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.262]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.262]                     ...future.globalenv.names))
[11:01:52.262]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.262]         }, condition = base::local({
[11:01:52.262]             c <- base::c
[11:01:52.262]             inherits <- base::inherits
[11:01:52.262]             invokeRestart <- base::invokeRestart
[11:01:52.262]             length <- base::length
[11:01:52.262]             list <- base::list
[11:01:52.262]             seq.int <- base::seq.int
[11:01:52.262]             signalCondition <- base::signalCondition
[11:01:52.262]             sys.calls <- base::sys.calls
[11:01:52.262]             `[[` <- base::`[[`
[11:01:52.262]             `+` <- base::`+`
[11:01:52.262]             `<<-` <- base::`<<-`
[11:01:52.262]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.262]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.262]                   3L)]
[11:01:52.262]             }
[11:01:52.262]             function(cond) {
[11:01:52.262]                 is_error <- inherits(cond, "error")
[11:01:52.262]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.262]                   NULL)
[11:01:52.262]                 if (is_error) {
[11:01:52.262]                   sessionInformation <- function() {
[11:01:52.262]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.262]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.262]                       search = base::search(), system = base::Sys.info())
[11:01:52.262]                   }
[11:01:52.262]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.262]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.262]                     cond$call), session = sessionInformation(), 
[11:01:52.262]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.262]                   signalCondition(cond)
[11:01:52.262]                 }
[11:01:52.262]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.262]                 "immediateCondition"))) {
[11:01:52.262]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.262]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.262]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.262]                   if (TRUE && !signal) {
[11:01:52.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.262]                     {
[11:01:52.262]                       inherits <- base::inherits
[11:01:52.262]                       invokeRestart <- base::invokeRestart
[11:01:52.262]                       is.null <- base::is.null
[11:01:52.262]                       muffled <- FALSE
[11:01:52.262]                       if (inherits(cond, "message")) {
[11:01:52.262]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.262]                         if (muffled) 
[11:01:52.262]                           invokeRestart("muffleMessage")
[11:01:52.262]                       }
[11:01:52.262]                       else if (inherits(cond, "warning")) {
[11:01:52.262]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.262]                         if (muffled) 
[11:01:52.262]                           invokeRestart("muffleWarning")
[11:01:52.262]                       }
[11:01:52.262]                       else if (inherits(cond, "condition")) {
[11:01:52.262]                         if (!is.null(pattern)) {
[11:01:52.262]                           computeRestarts <- base::computeRestarts
[11:01:52.262]                           grepl <- base::grepl
[11:01:52.262]                           restarts <- computeRestarts(cond)
[11:01:52.262]                           for (restart in restarts) {
[11:01:52.262]                             name <- restart$name
[11:01:52.262]                             if (is.null(name)) 
[11:01:52.262]                               next
[11:01:52.262]                             if (!grepl(pattern, name)) 
[11:01:52.262]                               next
[11:01:52.262]                             invokeRestart(restart)
[11:01:52.262]                             muffled <- TRUE
[11:01:52.262]                             break
[11:01:52.262]                           }
[11:01:52.262]                         }
[11:01:52.262]                       }
[11:01:52.262]                       invisible(muffled)
[11:01:52.262]                     }
[11:01:52.262]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.262]                   }
[11:01:52.262]                 }
[11:01:52.262]                 else {
[11:01:52.262]                   if (TRUE) {
[11:01:52.262]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.262]                     {
[11:01:52.262]                       inherits <- base::inherits
[11:01:52.262]                       invokeRestart <- base::invokeRestart
[11:01:52.262]                       is.null <- base::is.null
[11:01:52.262]                       muffled <- FALSE
[11:01:52.262]                       if (inherits(cond, "message")) {
[11:01:52.262]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.262]                         if (muffled) 
[11:01:52.262]                           invokeRestart("muffleMessage")
[11:01:52.262]                       }
[11:01:52.262]                       else if (inherits(cond, "warning")) {
[11:01:52.262]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.262]                         if (muffled) 
[11:01:52.262]                           invokeRestart("muffleWarning")
[11:01:52.262]                       }
[11:01:52.262]                       else if (inherits(cond, "condition")) {
[11:01:52.262]                         if (!is.null(pattern)) {
[11:01:52.262]                           computeRestarts <- base::computeRestarts
[11:01:52.262]                           grepl <- base::grepl
[11:01:52.262]                           restarts <- computeRestarts(cond)
[11:01:52.262]                           for (restart in restarts) {
[11:01:52.262]                             name <- restart$name
[11:01:52.262]                             if (is.null(name)) 
[11:01:52.262]                               next
[11:01:52.262]                             if (!grepl(pattern, name)) 
[11:01:52.262]                               next
[11:01:52.262]                             invokeRestart(restart)
[11:01:52.262]                             muffled <- TRUE
[11:01:52.262]                             break
[11:01:52.262]                           }
[11:01:52.262]                         }
[11:01:52.262]                       }
[11:01:52.262]                       invisible(muffled)
[11:01:52.262]                     }
[11:01:52.262]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.262]                   }
[11:01:52.262]                 }
[11:01:52.262]             }
[11:01:52.262]         }))
[11:01:52.262]     }, error = function(ex) {
[11:01:52.262]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.262]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.262]                 ...future.rng), started = ...future.startTime, 
[11:01:52.262]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.262]             version = "1.8"), class = "FutureResult")
[11:01:52.262]     }, finally = {
[11:01:52.262]         if (!identical(...future.workdir, getwd())) 
[11:01:52.262]             setwd(...future.workdir)
[11:01:52.262]         {
[11:01:52.262]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.262]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.262]             }
[11:01:52.262]             base::options(...future.oldOptions)
[11:01:52.262]             if (.Platform$OS.type == "windows") {
[11:01:52.262]                 old_names <- names(...future.oldEnvVars)
[11:01:52.262]                 envs <- base::Sys.getenv()
[11:01:52.262]                 names <- names(envs)
[11:01:52.262]                 common <- intersect(names, old_names)
[11:01:52.262]                 added <- setdiff(names, old_names)
[11:01:52.262]                 removed <- setdiff(old_names, names)
[11:01:52.262]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.262]                   envs[common]]
[11:01:52.262]                 NAMES <- toupper(changed)
[11:01:52.262]                 args <- list()
[11:01:52.262]                 for (kk in seq_along(NAMES)) {
[11:01:52.262]                   name <- changed[[kk]]
[11:01:52.262]                   NAME <- NAMES[[kk]]
[11:01:52.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.262]                     next
[11:01:52.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.262]                 }
[11:01:52.262]                 NAMES <- toupper(added)
[11:01:52.262]                 for (kk in seq_along(NAMES)) {
[11:01:52.262]                   name <- added[[kk]]
[11:01:52.262]                   NAME <- NAMES[[kk]]
[11:01:52.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.262]                     next
[11:01:52.262]                   args[[name]] <- ""
[11:01:52.262]                 }
[11:01:52.262]                 NAMES <- toupper(removed)
[11:01:52.262]                 for (kk in seq_along(NAMES)) {
[11:01:52.262]                   name <- removed[[kk]]
[11:01:52.262]                   NAME <- NAMES[[kk]]
[11:01:52.262]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.262]                     next
[11:01:52.262]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.262]                 }
[11:01:52.262]                 if (length(args) > 0) 
[11:01:52.262]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.262]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.262]             }
[11:01:52.262]             else {
[11:01:52.262]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.262]             }
[11:01:52.262]             {
[11:01:52.262]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.262]                   0L) {
[11:01:52.262]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.262]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.262]                   base::options(opts)
[11:01:52.262]                 }
[11:01:52.262]                 {
[11:01:52.262]                   {
[11:01:52.262]                     NULL
[11:01:52.262]                     RNGkind("Mersenne-Twister")
[11:01:52.262]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.262]                       inherits = FALSE)
[11:01:52.262]                   }
[11:01:52.262]                   options(future.plan = NULL)
[11:01:52.262]                   if (is.na(NA_character_)) 
[11:01:52.262]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.262]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.262]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.262]                     .init = FALSE)
[11:01:52.262]                 }
[11:01:52.262]             }
[11:01:52.262]         }
[11:01:52.262]     })
[11:01:52.262]     if (TRUE) {
[11:01:52.262]         base::sink(type = "output", split = FALSE)
[11:01:52.262]         if (TRUE) {
[11:01:52.262]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.262]         }
[11:01:52.262]         else {
[11:01:52.262]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.262]         }
[11:01:52.262]         base::close(...future.stdout)
[11:01:52.262]         ...future.stdout <- NULL
[11:01:52.262]     }
[11:01:52.262]     ...future.result$conditions <- ...future.conditions
[11:01:52.262]     ...future.result$finished <- base::Sys.time()
[11:01:52.262]     ...future.result
[11:01:52.262] }
[11:01:52.263] assign_globals() ...
[11:01:52.264] List of 1
[11:01:52.264]  $ a:Classes 'SequentialFuture', 'UniprocessFuture', 'Future', 'environment' <environment: 0x55eece85ca20> 
[11:01:52.264]  - attr(*, "where")=List of 1
[11:01:52.264]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.264]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.264]  - attr(*, "resolved")= logi TRUE
[11:01:52.264]  - attr(*, "total_size")= num 3555
[11:01:52.264]  - attr(*, "already-done")= logi TRUE
[11:01:52.266] - copied ‘a’ to environment
[11:01:52.266] assign_globals() ... done
[11:01:52.266] plan(): Setting new future strategy stack:
[11:01:52.266] List of future strategies:
[11:01:52.266] 1. sequential:
[11:01:52.266]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.266]    - tweaked: FALSE
[11:01:52.266]    - call: NULL
[11:01:52.267] plan(): nbrOfWorkers() = 1
[11:01:52.267] plan(): Setting new future strategy stack:
[11:01:52.268] List of future strategies:
[11:01:52.268] 1. sequential:
[11:01:52.268]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.268]    - tweaked: FALSE
[11:01:52.268]    - call: plan(strategy)
[11:01:52.268] plan(): nbrOfWorkers() = 1
[11:01:52.268] SequentialFuture started (and completed)
[11:01:52.268] - Launch lazy future ... done
[11:01:52.268] run() for ‘SequentialFuture’ ... done
value(b) = 2
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.269] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.269] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.270] - globals found: [2] ‘{’, ‘pkg’
[11:01:52.270] Searching for globals ... DONE
[11:01:52.270] Resolving globals: TRUE
[11:01:52.270] Resolving any globals that are futures ...
[11:01:52.270] - globals: [2] ‘{’, ‘pkg’
[11:01:52.270] Resolving any globals that are futures ... DONE
[11:01:52.270] Resolving futures part of globals (recursively) ...
[11:01:52.271] resolve() on list ...
[11:01:52.271]  recursive: 99
[11:01:52.271]  length: 1
[11:01:52.271]  elements: ‘pkg’
[11:01:52.271]  length: 0 (resolved future 1)
[11:01:52.271] resolve() on list ... DONE
[11:01:52.271] - globals: [1] ‘pkg’
[11:01:52.271] Resolving futures part of globals (recursively) ... DONE
[11:01:52.271] The total size of the 1 globals is 42 bytes (42 bytes)
[11:01:52.272] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[11:01:52.272] - globals: [1] ‘pkg’
[11:01:52.272] 
[11:01:52.273] getGlobalsAndPackages() ... DONE
[11:01:52.273] Packages needed by the future expression (n = 0): <none>
[11:01:52.273] Packages needed by future strategies (n = 0): <none>
[11:01:52.274] {
[11:01:52.274]     {
[11:01:52.274]         {
[11:01:52.274]             ...future.startTime <- base::Sys.time()
[11:01:52.274]             {
[11:01:52.274]                 {
[11:01:52.274]                   {
[11:01:52.274]                     base::local({
[11:01:52.274]                       has_future <- base::requireNamespace("future", 
[11:01:52.274]                         quietly = TRUE)
[11:01:52.274]                       if (has_future) {
[11:01:52.274]                         ns <- base::getNamespace("future")
[11:01:52.274]                         version <- ns[[".package"]][["version"]]
[11:01:52.274]                         if (is.null(version)) 
[11:01:52.274]                           version <- utils::packageVersion("future")
[11:01:52.274]                       }
[11:01:52.274]                       else {
[11:01:52.274]                         version <- NULL
[11:01:52.274]                       }
[11:01:52.274]                       if (!has_future || version < "1.8.0") {
[11:01:52.274]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.274]                           "", base::R.version$version.string), 
[11:01:52.274]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.274]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.274]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.274]                             "release", "version")], collapse = " "), 
[11:01:52.274]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.274]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.274]                           info)
[11:01:52.274]                         info <- base::paste(info, collapse = "; ")
[11:01:52.274]                         if (!has_future) {
[11:01:52.274]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.274]                             info)
[11:01:52.274]                         }
[11:01:52.274]                         else {
[11:01:52.274]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.274]                             info, version)
[11:01:52.274]                         }
[11:01:52.274]                         base::stop(msg)
[11:01:52.274]                       }
[11:01:52.274]                     })
[11:01:52.274]                   }
[11:01:52.274]                   ...future.strategy.old <- future::plan("list")
[11:01:52.274]                   options(future.plan = NULL)
[11:01:52.274]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.274]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.274]                 }
[11:01:52.274]                 ...future.workdir <- getwd()
[11:01:52.274]             }
[11:01:52.274]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.274]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.274]         }
[11:01:52.274]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.274]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.274]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.274]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.274]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.274]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.274]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.274]             base::names(...future.oldOptions))
[11:01:52.274]     }
[11:01:52.274]     if (FALSE) {
[11:01:52.274]     }
[11:01:52.274]     else {
[11:01:52.274]         if (TRUE) {
[11:01:52.274]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.274]                 open = "w")
[11:01:52.274]         }
[11:01:52.274]         else {
[11:01:52.274]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.274]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.274]         }
[11:01:52.274]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.274]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.274]             base::sink(type = "output", split = FALSE)
[11:01:52.274]             base::close(...future.stdout)
[11:01:52.274]         }, add = TRUE)
[11:01:52.274]     }
[11:01:52.274]     ...future.frame <- base::sys.nframe()
[11:01:52.274]     ...future.conditions <- base::list()
[11:01:52.274]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.274]     if (FALSE) {
[11:01:52.274]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.274]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.274]     }
[11:01:52.274]     ...future.result <- base::tryCatch({
[11:01:52.274]         base::withCallingHandlers({
[11:01:52.274]             ...future.value <- base::withVisible(base::local({
[11:01:52.274]                 pkg
[11:01:52.274]             }))
[11:01:52.274]             future::FutureResult(value = ...future.value$value, 
[11:01:52.274]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.274]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.274]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.274]                     ...future.globalenv.names))
[11:01:52.274]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.274]         }, condition = base::local({
[11:01:52.274]             c <- base::c
[11:01:52.274]             inherits <- base::inherits
[11:01:52.274]             invokeRestart <- base::invokeRestart
[11:01:52.274]             length <- base::length
[11:01:52.274]             list <- base::list
[11:01:52.274]             seq.int <- base::seq.int
[11:01:52.274]             signalCondition <- base::signalCondition
[11:01:52.274]             sys.calls <- base::sys.calls
[11:01:52.274]             `[[` <- base::`[[`
[11:01:52.274]             `+` <- base::`+`
[11:01:52.274]             `<<-` <- base::`<<-`
[11:01:52.274]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.274]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.274]                   3L)]
[11:01:52.274]             }
[11:01:52.274]             function(cond) {
[11:01:52.274]                 is_error <- inherits(cond, "error")
[11:01:52.274]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.274]                   NULL)
[11:01:52.274]                 if (is_error) {
[11:01:52.274]                   sessionInformation <- function() {
[11:01:52.274]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.274]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.274]                       search = base::search(), system = base::Sys.info())
[11:01:52.274]                   }
[11:01:52.274]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.274]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.274]                     cond$call), session = sessionInformation(), 
[11:01:52.274]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.274]                   signalCondition(cond)
[11:01:52.274]                 }
[11:01:52.274]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.274]                 "immediateCondition"))) {
[11:01:52.274]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.274]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.274]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.274]                   if (TRUE && !signal) {
[11:01:52.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.274]                     {
[11:01:52.274]                       inherits <- base::inherits
[11:01:52.274]                       invokeRestart <- base::invokeRestart
[11:01:52.274]                       is.null <- base::is.null
[11:01:52.274]                       muffled <- FALSE
[11:01:52.274]                       if (inherits(cond, "message")) {
[11:01:52.274]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.274]                         if (muffled) 
[11:01:52.274]                           invokeRestart("muffleMessage")
[11:01:52.274]                       }
[11:01:52.274]                       else if (inherits(cond, "warning")) {
[11:01:52.274]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.274]                         if (muffled) 
[11:01:52.274]                           invokeRestart("muffleWarning")
[11:01:52.274]                       }
[11:01:52.274]                       else if (inherits(cond, "condition")) {
[11:01:52.274]                         if (!is.null(pattern)) {
[11:01:52.274]                           computeRestarts <- base::computeRestarts
[11:01:52.274]                           grepl <- base::grepl
[11:01:52.274]                           restarts <- computeRestarts(cond)
[11:01:52.274]                           for (restart in restarts) {
[11:01:52.274]                             name <- restart$name
[11:01:52.274]                             if (is.null(name)) 
[11:01:52.274]                               next
[11:01:52.274]                             if (!grepl(pattern, name)) 
[11:01:52.274]                               next
[11:01:52.274]                             invokeRestart(restart)
[11:01:52.274]                             muffled <- TRUE
[11:01:52.274]                             break
[11:01:52.274]                           }
[11:01:52.274]                         }
[11:01:52.274]                       }
[11:01:52.274]                       invisible(muffled)
[11:01:52.274]                     }
[11:01:52.274]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.274]                   }
[11:01:52.274]                 }
[11:01:52.274]                 else {
[11:01:52.274]                   if (TRUE) {
[11:01:52.274]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.274]                     {
[11:01:52.274]                       inherits <- base::inherits
[11:01:52.274]                       invokeRestart <- base::invokeRestart
[11:01:52.274]                       is.null <- base::is.null
[11:01:52.274]                       muffled <- FALSE
[11:01:52.274]                       if (inherits(cond, "message")) {
[11:01:52.274]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.274]                         if (muffled) 
[11:01:52.274]                           invokeRestart("muffleMessage")
[11:01:52.274]                       }
[11:01:52.274]                       else if (inherits(cond, "warning")) {
[11:01:52.274]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.274]                         if (muffled) 
[11:01:52.274]                           invokeRestart("muffleWarning")
[11:01:52.274]                       }
[11:01:52.274]                       else if (inherits(cond, "condition")) {
[11:01:52.274]                         if (!is.null(pattern)) {
[11:01:52.274]                           computeRestarts <- base::computeRestarts
[11:01:52.274]                           grepl <- base::grepl
[11:01:52.274]                           restarts <- computeRestarts(cond)
[11:01:52.274]                           for (restart in restarts) {
[11:01:52.274]                             name <- restart$name
[11:01:52.274]                             if (is.null(name)) 
[11:01:52.274]                               next
[11:01:52.274]                             if (!grepl(pattern, name)) 
[11:01:52.274]                               next
[11:01:52.274]                             invokeRestart(restart)
[11:01:52.274]                             muffled <- TRUE
[11:01:52.274]                             break
[11:01:52.274]                           }
[11:01:52.274]                         }
[11:01:52.274]                       }
[11:01:52.274]                       invisible(muffled)
[11:01:52.274]                     }
[11:01:52.274]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.274]                   }
[11:01:52.274]                 }
[11:01:52.274]             }
[11:01:52.274]         }))
[11:01:52.274]     }, error = function(ex) {
[11:01:52.274]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.274]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.274]                 ...future.rng), started = ...future.startTime, 
[11:01:52.274]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.274]             version = "1.8"), class = "FutureResult")
[11:01:52.274]     }, finally = {
[11:01:52.274]         if (!identical(...future.workdir, getwd())) 
[11:01:52.274]             setwd(...future.workdir)
[11:01:52.274]         {
[11:01:52.274]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.274]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.274]             }
[11:01:52.274]             base::options(...future.oldOptions)
[11:01:52.274]             if (.Platform$OS.type == "windows") {
[11:01:52.274]                 old_names <- names(...future.oldEnvVars)
[11:01:52.274]                 envs <- base::Sys.getenv()
[11:01:52.274]                 names <- names(envs)
[11:01:52.274]                 common <- intersect(names, old_names)
[11:01:52.274]                 added <- setdiff(names, old_names)
[11:01:52.274]                 removed <- setdiff(old_names, names)
[11:01:52.274]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.274]                   envs[common]]
[11:01:52.274]                 NAMES <- toupper(changed)
[11:01:52.274]                 args <- list()
[11:01:52.274]                 for (kk in seq_along(NAMES)) {
[11:01:52.274]                   name <- changed[[kk]]
[11:01:52.274]                   NAME <- NAMES[[kk]]
[11:01:52.274]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.274]                     next
[11:01:52.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.274]                 }
[11:01:52.274]                 NAMES <- toupper(added)
[11:01:52.274]                 for (kk in seq_along(NAMES)) {
[11:01:52.274]                   name <- added[[kk]]
[11:01:52.274]                   NAME <- NAMES[[kk]]
[11:01:52.274]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.274]                     next
[11:01:52.274]                   args[[name]] <- ""
[11:01:52.274]                 }
[11:01:52.274]                 NAMES <- toupper(removed)
[11:01:52.274]                 for (kk in seq_along(NAMES)) {
[11:01:52.274]                   name <- removed[[kk]]
[11:01:52.274]                   NAME <- NAMES[[kk]]
[11:01:52.274]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.274]                     next
[11:01:52.274]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.274]                 }
[11:01:52.274]                 if (length(args) > 0) 
[11:01:52.274]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.274]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.274]             }
[11:01:52.274]             else {
[11:01:52.274]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.274]             }
[11:01:52.274]             {
[11:01:52.274]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.274]                   0L) {
[11:01:52.274]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.274]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.274]                   base::options(opts)
[11:01:52.274]                 }
[11:01:52.274]                 {
[11:01:52.274]                   {
[11:01:52.274]                     NULL
[11:01:52.274]                     RNGkind("Mersenne-Twister")
[11:01:52.274]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.274]                       inherits = FALSE)
[11:01:52.274]                   }
[11:01:52.274]                   options(future.plan = NULL)
[11:01:52.274]                   if (is.na(NA_character_)) 
[11:01:52.274]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.274]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.274]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.274]                     .init = FALSE)
[11:01:52.274]                 }
[11:01:52.274]             }
[11:01:52.274]         }
[11:01:52.274]     })
[11:01:52.274]     if (TRUE) {
[11:01:52.274]         base::sink(type = "output", split = FALSE)
[11:01:52.274]         if (TRUE) {
[11:01:52.274]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.274]         }
[11:01:52.274]         else {
[11:01:52.274]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.274]         }
[11:01:52.274]         base::close(...future.stdout)
[11:01:52.274]         ...future.stdout <- NULL
[11:01:52.274]     }
[11:01:52.274]     ...future.result$conditions <- ...future.conditions
[11:01:52.274]     ...future.result$finished <- base::Sys.time()
[11:01:52.274]     ...future.result
[11:01:52.274] }
[11:01:52.275] assign_globals() ...
[11:01:52.275] List of 1
[11:01:52.275]  $ pkg: chr "foo"
[11:01:52.275]  - attr(*, "where")=List of 1
[11:01:52.275]   ..$ pkg:<environment: R_EmptyEnv> 
[11:01:52.275]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.275]  - attr(*, "resolved")= logi TRUE
[11:01:52.275]  - attr(*, "total_size")= num 42
[11:01:52.277] - copied ‘pkg’ to environment
[11:01:52.277] assign_globals() ... done
[11:01:52.277] plan(): Setting new future strategy stack:
[11:01:52.278] List of future strategies:
[11:01:52.278] 1. sequential:
[11:01:52.278]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.278]    - tweaked: FALSE
[11:01:52.278]    - call: NULL
[11:01:52.278] plan(): nbrOfWorkers() = 1
[11:01:52.279] plan(): Setting new future strategy stack:
[11:01:52.279] List of future strategies:
[11:01:52.279] 1. sequential:
[11:01:52.279]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.279]    - tweaked: FALSE
[11:01:52.279]    - call: plan(strategy)
[11:01:52.279] plan(): nbrOfWorkers() = 1
[11:01:52.279] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.280] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.280] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.281] - globals found: [3] ‘{’, ‘<-’, ‘+’
[11:01:52.282] Searching for globals ... DONE
[11:01:52.282] Resolving globals: TRUE
[11:01:52.282] Resolving any globals that are futures ...
[11:01:52.282] - globals: [3] ‘{’, ‘<-’, ‘+’
[11:01:52.282] Resolving any globals that are futures ... DONE
[11:01:52.282] 
[11:01:52.282] 
[11:01:52.282] getGlobalsAndPackages() ... DONE
[11:01:52.283] run() for ‘Future’ ...
[11:01:52.283] - state: ‘created’
[11:01:52.283] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.283] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.283] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.283]   - Field: ‘label’
[11:01:52.283]   - Field: ‘local’
[11:01:52.283]   - Field: ‘owner’
[11:01:52.283]   - Field: ‘envir’
[11:01:52.284]   - Field: ‘packages’
[11:01:52.284]   - Field: ‘gc’
[11:01:52.284]   - Field: ‘conditions’
[11:01:52.284]   - Field: ‘expr’
[11:01:52.284]   - Field: ‘uuid’
[11:01:52.284]   - Field: ‘seed’
[11:01:52.284]   - Field: ‘version’
[11:01:52.284]   - Field: ‘result’
[11:01:52.284]   - Field: ‘asynchronous’
[11:01:52.284]   - Field: ‘calls’
[11:01:52.284]   - Field: ‘globals’
[11:01:52.284]   - Field: ‘stdout’
[11:01:52.285]   - Field: ‘earlySignal’
[11:01:52.285]   - Field: ‘lazy’
[11:01:52.285]   - Field: ‘state’
[11:01:52.285] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.285] - Launch lazy future ...
[11:01:52.285] Packages needed by the future expression (n = 0): <none>
[11:01:52.285] Packages needed by future strategies (n = 0): <none>
[11:01:52.285] {
[11:01:52.285]     {
[11:01:52.285]         {
[11:01:52.285]             ...future.startTime <- base::Sys.time()
[11:01:52.285]             {
[11:01:52.285]                 {
[11:01:52.285]                   {
[11:01:52.285]                     base::local({
[11:01:52.285]                       has_future <- base::requireNamespace("future", 
[11:01:52.285]                         quietly = TRUE)
[11:01:52.285]                       if (has_future) {
[11:01:52.285]                         ns <- base::getNamespace("future")
[11:01:52.285]                         version <- ns[[".package"]][["version"]]
[11:01:52.285]                         if (is.null(version)) 
[11:01:52.285]                           version <- utils::packageVersion("future")
[11:01:52.285]                       }
[11:01:52.285]                       else {
[11:01:52.285]                         version <- NULL
[11:01:52.285]                       }
[11:01:52.285]                       if (!has_future || version < "1.8.0") {
[11:01:52.285]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.285]                           "", base::R.version$version.string), 
[11:01:52.285]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.285]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.285]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.285]                             "release", "version")], collapse = " "), 
[11:01:52.285]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.285]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.285]                           info)
[11:01:52.285]                         info <- base::paste(info, collapse = "; ")
[11:01:52.285]                         if (!has_future) {
[11:01:52.285]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.285]                             info)
[11:01:52.285]                         }
[11:01:52.285]                         else {
[11:01:52.285]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.285]                             info, version)
[11:01:52.285]                         }
[11:01:52.285]                         base::stop(msg)
[11:01:52.285]                       }
[11:01:52.285]                     })
[11:01:52.285]                   }
[11:01:52.285]                   ...future.strategy.old <- future::plan("list")
[11:01:52.285]                   options(future.plan = NULL)
[11:01:52.285]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.285]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.285]                 }
[11:01:52.285]                 ...future.workdir <- getwd()
[11:01:52.285]             }
[11:01:52.285]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.285]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.285]         }
[11:01:52.285]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.285]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.285]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.285]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.285]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.285]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.285]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.285]             base::names(...future.oldOptions))
[11:01:52.285]     }
[11:01:52.285]     if (FALSE) {
[11:01:52.285]     }
[11:01:52.285]     else {
[11:01:52.285]         if (TRUE) {
[11:01:52.285]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.285]                 open = "w")
[11:01:52.285]         }
[11:01:52.285]         else {
[11:01:52.285]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.285]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.285]         }
[11:01:52.285]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.285]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.285]             base::sink(type = "output", split = FALSE)
[11:01:52.285]             base::close(...future.stdout)
[11:01:52.285]         }, add = TRUE)
[11:01:52.285]     }
[11:01:52.285]     ...future.frame <- base::sys.nframe()
[11:01:52.285]     ...future.conditions <- base::list()
[11:01:52.285]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.285]     if (FALSE) {
[11:01:52.285]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.285]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.285]     }
[11:01:52.285]     ...future.result <- base::tryCatch({
[11:01:52.285]         base::withCallingHandlers({
[11:01:52.285]             ...future.value <- base::withVisible(base::local({
[11:01:52.285]                 x <- 0
[11:01:52.285]                 x <- x + 1
[11:01:52.285]                 x
[11:01:52.285]             }))
[11:01:52.285]             future::FutureResult(value = ...future.value$value, 
[11:01:52.285]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.285]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.285]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.285]                     ...future.globalenv.names))
[11:01:52.285]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.285]         }, condition = base::local({
[11:01:52.285]             c <- base::c
[11:01:52.285]             inherits <- base::inherits
[11:01:52.285]             invokeRestart <- base::invokeRestart
[11:01:52.285]             length <- base::length
[11:01:52.285]             list <- base::list
[11:01:52.285]             seq.int <- base::seq.int
[11:01:52.285]             signalCondition <- base::signalCondition
[11:01:52.285]             sys.calls <- base::sys.calls
[11:01:52.285]             `[[` <- base::`[[`
[11:01:52.285]             `+` <- base::`+`
[11:01:52.285]             `<<-` <- base::`<<-`
[11:01:52.285]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.285]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.285]                   3L)]
[11:01:52.285]             }
[11:01:52.285]             function(cond) {
[11:01:52.285]                 is_error <- inherits(cond, "error")
[11:01:52.285]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.285]                   NULL)
[11:01:52.285]                 if (is_error) {
[11:01:52.285]                   sessionInformation <- function() {
[11:01:52.285]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.285]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.285]                       search = base::search(), system = base::Sys.info())
[11:01:52.285]                   }
[11:01:52.285]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.285]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.285]                     cond$call), session = sessionInformation(), 
[11:01:52.285]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.285]                   signalCondition(cond)
[11:01:52.285]                 }
[11:01:52.285]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.285]                 "immediateCondition"))) {
[11:01:52.285]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.285]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.285]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.285]                   if (TRUE && !signal) {
[11:01:52.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.285]                     {
[11:01:52.285]                       inherits <- base::inherits
[11:01:52.285]                       invokeRestart <- base::invokeRestart
[11:01:52.285]                       is.null <- base::is.null
[11:01:52.285]                       muffled <- FALSE
[11:01:52.285]                       if (inherits(cond, "message")) {
[11:01:52.285]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.285]                         if (muffled) 
[11:01:52.285]                           invokeRestart("muffleMessage")
[11:01:52.285]                       }
[11:01:52.285]                       else if (inherits(cond, "warning")) {
[11:01:52.285]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.285]                         if (muffled) 
[11:01:52.285]                           invokeRestart("muffleWarning")
[11:01:52.285]                       }
[11:01:52.285]                       else if (inherits(cond, "condition")) {
[11:01:52.285]                         if (!is.null(pattern)) {
[11:01:52.285]                           computeRestarts <- base::computeRestarts
[11:01:52.285]                           grepl <- base::grepl
[11:01:52.285]                           restarts <- computeRestarts(cond)
[11:01:52.285]                           for (restart in restarts) {
[11:01:52.285]                             name <- restart$name
[11:01:52.285]                             if (is.null(name)) 
[11:01:52.285]                               next
[11:01:52.285]                             if (!grepl(pattern, name)) 
[11:01:52.285]                               next
[11:01:52.285]                             invokeRestart(restart)
[11:01:52.285]                             muffled <- TRUE
[11:01:52.285]                             break
[11:01:52.285]                           }
[11:01:52.285]                         }
[11:01:52.285]                       }
[11:01:52.285]                       invisible(muffled)
[11:01:52.285]                     }
[11:01:52.285]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.285]                   }
[11:01:52.285]                 }
[11:01:52.285]                 else {
[11:01:52.285]                   if (TRUE) {
[11:01:52.285]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.285]                     {
[11:01:52.285]                       inherits <- base::inherits
[11:01:52.285]                       invokeRestart <- base::invokeRestart
[11:01:52.285]                       is.null <- base::is.null
[11:01:52.285]                       muffled <- FALSE
[11:01:52.285]                       if (inherits(cond, "message")) {
[11:01:52.285]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.285]                         if (muffled) 
[11:01:52.285]                           invokeRestart("muffleMessage")
[11:01:52.285]                       }
[11:01:52.285]                       else if (inherits(cond, "warning")) {
[11:01:52.285]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.285]                         if (muffled) 
[11:01:52.285]                           invokeRestart("muffleWarning")
[11:01:52.285]                       }
[11:01:52.285]                       else if (inherits(cond, "condition")) {
[11:01:52.285]                         if (!is.null(pattern)) {
[11:01:52.285]                           computeRestarts <- base::computeRestarts
[11:01:52.285]                           grepl <- base::grepl
[11:01:52.285]                           restarts <- computeRestarts(cond)
[11:01:52.285]                           for (restart in restarts) {
[11:01:52.285]                             name <- restart$name
[11:01:52.285]                             if (is.null(name)) 
[11:01:52.285]                               next
[11:01:52.285]                             if (!grepl(pattern, name)) 
[11:01:52.285]                               next
[11:01:52.285]                             invokeRestart(restart)
[11:01:52.285]                             muffled <- TRUE
[11:01:52.285]                             break
[11:01:52.285]                           }
[11:01:52.285]                         }
[11:01:52.285]                       }
[11:01:52.285]                       invisible(muffled)
[11:01:52.285]                     }
[11:01:52.285]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.285]                   }
[11:01:52.285]                 }
[11:01:52.285]             }
[11:01:52.285]         }))
[11:01:52.285]     }, error = function(ex) {
[11:01:52.285]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.285]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.285]                 ...future.rng), started = ...future.startTime, 
[11:01:52.285]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.285]             version = "1.8"), class = "FutureResult")
[11:01:52.285]     }, finally = {
[11:01:52.285]         if (!identical(...future.workdir, getwd())) 
[11:01:52.285]             setwd(...future.workdir)
[11:01:52.285]         {
[11:01:52.285]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.285]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.285]             }
[11:01:52.285]             base::options(...future.oldOptions)
[11:01:52.285]             if (.Platform$OS.type == "windows") {
[11:01:52.285]                 old_names <- names(...future.oldEnvVars)
[11:01:52.285]                 envs <- base::Sys.getenv()
[11:01:52.285]                 names <- names(envs)
[11:01:52.285]                 common <- intersect(names, old_names)
[11:01:52.285]                 added <- setdiff(names, old_names)
[11:01:52.285]                 removed <- setdiff(old_names, names)
[11:01:52.285]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.285]                   envs[common]]
[11:01:52.285]                 NAMES <- toupper(changed)
[11:01:52.285]                 args <- list()
[11:01:52.285]                 for (kk in seq_along(NAMES)) {
[11:01:52.285]                   name <- changed[[kk]]
[11:01:52.285]                   NAME <- NAMES[[kk]]
[11:01:52.285]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.285]                     next
[11:01:52.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.285]                 }
[11:01:52.285]                 NAMES <- toupper(added)
[11:01:52.285]                 for (kk in seq_along(NAMES)) {
[11:01:52.285]                   name <- added[[kk]]
[11:01:52.285]                   NAME <- NAMES[[kk]]
[11:01:52.285]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.285]                     next
[11:01:52.285]                   args[[name]] <- ""
[11:01:52.285]                 }
[11:01:52.285]                 NAMES <- toupper(removed)
[11:01:52.285]                 for (kk in seq_along(NAMES)) {
[11:01:52.285]                   name <- removed[[kk]]
[11:01:52.285]                   NAME <- NAMES[[kk]]
[11:01:52.285]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.285]                     next
[11:01:52.285]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.285]                 }
[11:01:52.285]                 if (length(args) > 0) 
[11:01:52.285]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.285]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.285]             }
[11:01:52.285]             else {
[11:01:52.285]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.285]             }
[11:01:52.285]             {
[11:01:52.285]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.285]                   0L) {
[11:01:52.285]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.285]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.285]                   base::options(opts)
[11:01:52.285]                 }
[11:01:52.285]                 {
[11:01:52.285]                   {
[11:01:52.285]                     NULL
[11:01:52.285]                     RNGkind("Mersenne-Twister")
[11:01:52.285]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.285]                       inherits = FALSE)
[11:01:52.285]                   }
[11:01:52.285]                   options(future.plan = NULL)
[11:01:52.285]                   if (is.na(NA_character_)) 
[11:01:52.285]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.285]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.285]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.285]                     .init = FALSE)
[11:01:52.285]                 }
[11:01:52.285]             }
[11:01:52.285]         }
[11:01:52.285]     })
[11:01:52.285]     if (TRUE) {
[11:01:52.285]         base::sink(type = "output", split = FALSE)
[11:01:52.285]         if (TRUE) {
[11:01:52.285]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.285]         }
[11:01:52.285]         else {
[11:01:52.285]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.285]         }
[11:01:52.285]         base::close(...future.stdout)
[11:01:52.285]         ...future.stdout <- NULL
[11:01:52.285]     }
[11:01:52.285]     ...future.result$conditions <- ...future.conditions
[11:01:52.285]     ...future.result$finished <- base::Sys.time()
[11:01:52.285]     ...future.result
[11:01:52.285] }
[11:01:52.287] plan(): Setting new future strategy stack:
[11:01:52.287] List of future strategies:
[11:01:52.287] 1. sequential:
[11:01:52.287]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.287]    - tweaked: FALSE
[11:01:52.287]    - call: NULL
[11:01:52.288] plan(): nbrOfWorkers() = 1
[11:01:52.288] plan(): Setting new future strategy stack:
[11:01:52.288] List of future strategies:
[11:01:52.288] 1. sequential:
[11:01:52.288]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.288]    - tweaked: FALSE
[11:01:52.288]    - call: plan(strategy)
[11:01:52.289] plan(): nbrOfWorkers() = 1
[11:01:52.289] SequentialFuture started (and completed)
[11:01:52.289] - Launch lazy future ... done
[11:01:52.289] run() for ‘SequentialFuture’ ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.290] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.290] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.291] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[11:01:52.291] Searching for globals ... DONE
[11:01:52.291] Resolving globals: TRUE
[11:01:52.291] Resolving any globals that are futures ...
[11:01:52.291] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[11:01:52.292] Resolving any globals that are futures ... DONE
[11:01:52.292] Resolving futures part of globals (recursively) ...
[11:01:52.292] resolve() on list ...
[11:01:52.292]  recursive: 99
[11:01:52.292]  length: 1
[11:01:52.292]  elements: ‘x’
[11:01:52.292]  length: 0 (resolved future 1)
[11:01:52.292] resolve() on list ... DONE
[11:01:52.293] - globals: [1] ‘x’
[11:01:52.293] Resolving futures part of globals (recursively) ... DONE
[11:01:52.293] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:52.293] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[11:01:52.293] - globals: [1] ‘x’
[11:01:52.293] 
[11:01:52.293] getGlobalsAndPackages() ... DONE
[11:01:52.294] run() for ‘Future’ ...
[11:01:52.294] - state: ‘created’
[11:01:52.294] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.294] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.294] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.294]   - Field: ‘label’
[11:01:52.294]   - Field: ‘local’
[11:01:52.294]   - Field: ‘owner’
[11:01:52.294]   - Field: ‘envir’
[11:01:52.294]   - Field: ‘packages’
[11:01:52.295]   - Field: ‘gc’
[11:01:52.295]   - Field: ‘conditions’
[11:01:52.295]   - Field: ‘expr’
[11:01:52.295]   - Field: ‘uuid’
[11:01:52.295]   - Field: ‘seed’
[11:01:52.295]   - Field: ‘version’
[11:01:52.295]   - Field: ‘result’
[11:01:52.295]   - Field: ‘asynchronous’
[11:01:52.295]   - Field: ‘calls’
[11:01:52.295]   - Field: ‘globals’
[11:01:52.295]   - Field: ‘stdout’
[11:01:52.295]   - Field: ‘earlySignal’
[11:01:52.296]   - Field: ‘lazy’
[11:01:52.296]   - Field: ‘state’
[11:01:52.296] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.296] - Launch lazy future ...
[11:01:52.296] Packages needed by the future expression (n = 0): <none>
[11:01:52.296] Packages needed by future strategies (n = 0): <none>
[11:01:52.296] {
[11:01:52.296]     {
[11:01:52.296]         {
[11:01:52.296]             ...future.startTime <- base::Sys.time()
[11:01:52.296]             {
[11:01:52.296]                 {
[11:01:52.296]                   {
[11:01:52.296]                     base::local({
[11:01:52.296]                       has_future <- base::requireNamespace("future", 
[11:01:52.296]                         quietly = TRUE)
[11:01:52.296]                       if (has_future) {
[11:01:52.296]                         ns <- base::getNamespace("future")
[11:01:52.296]                         version <- ns[[".package"]][["version"]]
[11:01:52.296]                         if (is.null(version)) 
[11:01:52.296]                           version <- utils::packageVersion("future")
[11:01:52.296]                       }
[11:01:52.296]                       else {
[11:01:52.296]                         version <- NULL
[11:01:52.296]                       }
[11:01:52.296]                       if (!has_future || version < "1.8.0") {
[11:01:52.296]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.296]                           "", base::R.version$version.string), 
[11:01:52.296]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.296]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.296]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.296]                             "release", "version")], collapse = " "), 
[11:01:52.296]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.296]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.296]                           info)
[11:01:52.296]                         info <- base::paste(info, collapse = "; ")
[11:01:52.296]                         if (!has_future) {
[11:01:52.296]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.296]                             info)
[11:01:52.296]                         }
[11:01:52.296]                         else {
[11:01:52.296]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.296]                             info, version)
[11:01:52.296]                         }
[11:01:52.296]                         base::stop(msg)
[11:01:52.296]                       }
[11:01:52.296]                     })
[11:01:52.296]                   }
[11:01:52.296]                   ...future.strategy.old <- future::plan("list")
[11:01:52.296]                   options(future.plan = NULL)
[11:01:52.296]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.296]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.296]                 }
[11:01:52.296]                 ...future.workdir <- getwd()
[11:01:52.296]             }
[11:01:52.296]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.296]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.296]         }
[11:01:52.296]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.296]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.296]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.296]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.296]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.296]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.296]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.296]             base::names(...future.oldOptions))
[11:01:52.296]     }
[11:01:52.296]     if (FALSE) {
[11:01:52.296]     }
[11:01:52.296]     else {
[11:01:52.296]         if (TRUE) {
[11:01:52.296]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.296]                 open = "w")
[11:01:52.296]         }
[11:01:52.296]         else {
[11:01:52.296]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.296]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.296]         }
[11:01:52.296]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.296]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.296]             base::sink(type = "output", split = FALSE)
[11:01:52.296]             base::close(...future.stdout)
[11:01:52.296]         }, add = TRUE)
[11:01:52.296]     }
[11:01:52.296]     ...future.frame <- base::sys.nframe()
[11:01:52.296]     ...future.conditions <- base::list()
[11:01:52.296]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.296]     if (FALSE) {
[11:01:52.296]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.296]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.296]     }
[11:01:52.296]     ...future.result <- base::tryCatch({
[11:01:52.296]         base::withCallingHandlers({
[11:01:52.296]             ...future.value <- base::withVisible(base::local({
[11:01:52.296]                 x <- x + 1
[11:01:52.296]                 x
[11:01:52.296]             }))
[11:01:52.296]             future::FutureResult(value = ...future.value$value, 
[11:01:52.296]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.296]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.296]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.296]                     ...future.globalenv.names))
[11:01:52.296]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.296]         }, condition = base::local({
[11:01:52.296]             c <- base::c
[11:01:52.296]             inherits <- base::inherits
[11:01:52.296]             invokeRestart <- base::invokeRestart
[11:01:52.296]             length <- base::length
[11:01:52.296]             list <- base::list
[11:01:52.296]             seq.int <- base::seq.int
[11:01:52.296]             signalCondition <- base::signalCondition
[11:01:52.296]             sys.calls <- base::sys.calls
[11:01:52.296]             `[[` <- base::`[[`
[11:01:52.296]             `+` <- base::`+`
[11:01:52.296]             `<<-` <- base::`<<-`
[11:01:52.296]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.296]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.296]                   3L)]
[11:01:52.296]             }
[11:01:52.296]             function(cond) {
[11:01:52.296]                 is_error <- inherits(cond, "error")
[11:01:52.296]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.296]                   NULL)
[11:01:52.296]                 if (is_error) {
[11:01:52.296]                   sessionInformation <- function() {
[11:01:52.296]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.296]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.296]                       search = base::search(), system = base::Sys.info())
[11:01:52.296]                   }
[11:01:52.296]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.296]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.296]                     cond$call), session = sessionInformation(), 
[11:01:52.296]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.296]                   signalCondition(cond)
[11:01:52.296]                 }
[11:01:52.296]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.296]                 "immediateCondition"))) {
[11:01:52.296]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.296]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.296]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.296]                   if (TRUE && !signal) {
[11:01:52.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.296]                     {
[11:01:52.296]                       inherits <- base::inherits
[11:01:52.296]                       invokeRestart <- base::invokeRestart
[11:01:52.296]                       is.null <- base::is.null
[11:01:52.296]                       muffled <- FALSE
[11:01:52.296]                       if (inherits(cond, "message")) {
[11:01:52.296]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.296]                         if (muffled) 
[11:01:52.296]                           invokeRestart("muffleMessage")
[11:01:52.296]                       }
[11:01:52.296]                       else if (inherits(cond, "warning")) {
[11:01:52.296]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.296]                         if (muffled) 
[11:01:52.296]                           invokeRestart("muffleWarning")
[11:01:52.296]                       }
[11:01:52.296]                       else if (inherits(cond, "condition")) {
[11:01:52.296]                         if (!is.null(pattern)) {
[11:01:52.296]                           computeRestarts <- base::computeRestarts
[11:01:52.296]                           grepl <- base::grepl
[11:01:52.296]                           restarts <- computeRestarts(cond)
[11:01:52.296]                           for (restart in restarts) {
[11:01:52.296]                             name <- restart$name
[11:01:52.296]                             if (is.null(name)) 
[11:01:52.296]                               next
[11:01:52.296]                             if (!grepl(pattern, name)) 
[11:01:52.296]                               next
[11:01:52.296]                             invokeRestart(restart)
[11:01:52.296]                             muffled <- TRUE
[11:01:52.296]                             break
[11:01:52.296]                           }
[11:01:52.296]                         }
[11:01:52.296]                       }
[11:01:52.296]                       invisible(muffled)
[11:01:52.296]                     }
[11:01:52.296]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.296]                   }
[11:01:52.296]                 }
[11:01:52.296]                 else {
[11:01:52.296]                   if (TRUE) {
[11:01:52.296]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.296]                     {
[11:01:52.296]                       inherits <- base::inherits
[11:01:52.296]                       invokeRestart <- base::invokeRestart
[11:01:52.296]                       is.null <- base::is.null
[11:01:52.296]                       muffled <- FALSE
[11:01:52.296]                       if (inherits(cond, "message")) {
[11:01:52.296]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.296]                         if (muffled) 
[11:01:52.296]                           invokeRestart("muffleMessage")
[11:01:52.296]                       }
[11:01:52.296]                       else if (inherits(cond, "warning")) {
[11:01:52.296]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.296]                         if (muffled) 
[11:01:52.296]                           invokeRestart("muffleWarning")
[11:01:52.296]                       }
[11:01:52.296]                       else if (inherits(cond, "condition")) {
[11:01:52.296]                         if (!is.null(pattern)) {
[11:01:52.296]                           computeRestarts <- base::computeRestarts
[11:01:52.296]                           grepl <- base::grepl
[11:01:52.296]                           restarts <- computeRestarts(cond)
[11:01:52.296]                           for (restart in restarts) {
[11:01:52.296]                             name <- restart$name
[11:01:52.296]                             if (is.null(name)) 
[11:01:52.296]                               next
[11:01:52.296]                             if (!grepl(pattern, name)) 
[11:01:52.296]                               next
[11:01:52.296]                             invokeRestart(restart)
[11:01:52.296]                             muffled <- TRUE
[11:01:52.296]                             break
[11:01:52.296]                           }
[11:01:52.296]                         }
[11:01:52.296]                       }
[11:01:52.296]                       invisible(muffled)
[11:01:52.296]                     }
[11:01:52.296]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.296]                   }
[11:01:52.296]                 }
[11:01:52.296]             }
[11:01:52.296]         }))
[11:01:52.296]     }, error = function(ex) {
[11:01:52.296]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.296]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.296]                 ...future.rng), started = ...future.startTime, 
[11:01:52.296]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.296]             version = "1.8"), class = "FutureResult")
[11:01:52.296]     }, finally = {
[11:01:52.296]         if (!identical(...future.workdir, getwd())) 
[11:01:52.296]             setwd(...future.workdir)
[11:01:52.296]         {
[11:01:52.296]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.296]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.296]             }
[11:01:52.296]             base::options(...future.oldOptions)
[11:01:52.296]             if (.Platform$OS.type == "windows") {
[11:01:52.296]                 old_names <- names(...future.oldEnvVars)
[11:01:52.296]                 envs <- base::Sys.getenv()
[11:01:52.296]                 names <- names(envs)
[11:01:52.296]                 common <- intersect(names, old_names)
[11:01:52.296]                 added <- setdiff(names, old_names)
[11:01:52.296]                 removed <- setdiff(old_names, names)
[11:01:52.296]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.296]                   envs[common]]
[11:01:52.296]                 NAMES <- toupper(changed)
[11:01:52.296]                 args <- list()
[11:01:52.296]                 for (kk in seq_along(NAMES)) {
[11:01:52.296]                   name <- changed[[kk]]
[11:01:52.296]                   NAME <- NAMES[[kk]]
[11:01:52.296]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.296]                     next
[11:01:52.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.296]                 }
[11:01:52.296]                 NAMES <- toupper(added)
[11:01:52.296]                 for (kk in seq_along(NAMES)) {
[11:01:52.296]                   name <- added[[kk]]
[11:01:52.296]                   NAME <- NAMES[[kk]]
[11:01:52.296]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.296]                     next
[11:01:52.296]                   args[[name]] <- ""
[11:01:52.296]                 }
[11:01:52.296]                 NAMES <- toupper(removed)
[11:01:52.296]                 for (kk in seq_along(NAMES)) {
[11:01:52.296]                   name <- removed[[kk]]
[11:01:52.296]                   NAME <- NAMES[[kk]]
[11:01:52.296]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.296]                     next
[11:01:52.296]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.296]                 }
[11:01:52.296]                 if (length(args) > 0) 
[11:01:52.296]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.296]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.296]             }
[11:01:52.296]             else {
[11:01:52.296]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.296]             }
[11:01:52.296]             {
[11:01:52.296]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.296]                   0L) {
[11:01:52.296]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.296]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.296]                   base::options(opts)
[11:01:52.296]                 }
[11:01:52.296]                 {
[11:01:52.296]                   {
[11:01:52.296]                     NULL
[11:01:52.296]                     RNGkind("Mersenne-Twister")
[11:01:52.296]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.296]                       inherits = FALSE)
[11:01:52.296]                   }
[11:01:52.296]                   options(future.plan = NULL)
[11:01:52.296]                   if (is.na(NA_character_)) 
[11:01:52.296]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.296]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.296]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.296]                     .init = FALSE)
[11:01:52.296]                 }
[11:01:52.296]             }
[11:01:52.296]         }
[11:01:52.296]     })
[11:01:52.296]     if (TRUE) {
[11:01:52.296]         base::sink(type = "output", split = FALSE)
[11:01:52.296]         if (TRUE) {
[11:01:52.296]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.296]         }
[11:01:52.296]         else {
[11:01:52.296]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.296]         }
[11:01:52.296]         base::close(...future.stdout)
[11:01:52.296]         ...future.stdout <- NULL
[11:01:52.296]     }
[11:01:52.296]     ...future.result$conditions <- ...future.conditions
[11:01:52.296]     ...future.result$finished <- base::Sys.time()
[11:01:52.296]     ...future.result
[11:01:52.296] }
[11:01:52.298] assign_globals() ...
[11:01:52.298] List of 1
[11:01:52.298]  $ x: num 1
[11:01:52.298]  - attr(*, "where")=List of 1
[11:01:52.298]   ..$ x:<environment: R_EmptyEnv> 
[11:01:52.298]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.298]  - attr(*, "resolved")= logi TRUE
[11:01:52.298]  - attr(*, "total_size")= num 39
[11:01:52.298]  - attr(*, "already-done")= logi TRUE
[11:01:52.302] - copied ‘x’ to environment
[11:01:52.302] assign_globals() ... done
[11:01:52.302] plan(): Setting new future strategy stack:
[11:01:52.302] List of future strategies:
[11:01:52.302] 1. sequential:
[11:01:52.302]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.302]    - tweaked: FALSE
[11:01:52.302]    - call: NULL
[11:01:52.302] plan(): nbrOfWorkers() = 1
[11:01:52.303] plan(): Setting new future strategy stack:
[11:01:52.303] List of future strategies:
[11:01:52.303] 1. sequential:
[11:01:52.303]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.303]    - tweaked: FALSE
[11:01:52.303]    - call: plan(strategy)
[11:01:52.304] plan(): nbrOfWorkers() = 1
[11:01:52.304] SequentialFuture started (and completed)
[11:01:52.304] - Launch lazy future ... done
[11:01:52.304] run() for ‘SequentialFuture’ ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.304] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.304] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.306] - globals found: [3] ‘{’, ‘<-’, ‘x’
[11:01:52.306] Searching for globals ... DONE
[11:01:52.306] Resolving globals: TRUE
[11:01:52.306] Resolving any globals that are futures ...
[11:01:52.307] - globals: [3] ‘{’, ‘<-’, ‘x’
[11:01:52.307] Resolving any globals that are futures ... DONE
[11:01:52.307] Resolving futures part of globals (recursively) ...
[11:01:52.307] resolve() on list ...
[11:01:52.307]  recursive: 99
[11:01:52.307]  length: 1
[11:01:52.307]  elements: ‘x’
[11:01:52.307]  length: 0 (resolved future 1)
[11:01:52.308] resolve() on list ... DONE
[11:01:52.308] - globals: [1] ‘x’
[11:01:52.308] Resolving futures part of globals (recursively) ... DONE
[11:01:52.308] The total size of the 1 globals is 260 bytes (260 bytes)
[11:01:52.308] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[11:01:52.308] - globals: [1] ‘x’
[11:01:52.308] 
[11:01:52.308] getGlobalsAndPackages() ... DONE
[11:01:52.309] run() for ‘Future’ ...
[11:01:52.309] - state: ‘created’
[11:01:52.309] - Future backend: ‘FutureStrategy’, ‘sequential’, ‘uniprocess’, ‘future’, ‘function’
[11:01:52.309] - Future class: ‘SequentialFuture’, ‘UniprocessFuture’, ‘Future’, ‘environment’
[11:01:52.309] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ...
[11:01:52.309]   - Field: ‘label’
[11:01:52.309]   - Field: ‘local’
[11:01:52.309]   - Field: ‘owner’
[11:01:52.310]   - Field: ‘envir’
[11:01:52.310]   - Field: ‘packages’
[11:01:52.310]   - Field: ‘gc’
[11:01:52.310]   - Field: ‘conditions’
[11:01:52.310]   - Field: ‘expr’
[11:01:52.310]   - Field: ‘uuid’
[11:01:52.310]   - Field: ‘seed’
[11:01:52.310]   - Field: ‘version’
[11:01:52.310]   - Field: ‘result’
[11:01:52.310]   - Field: ‘asynchronous’
[11:01:52.310]   - Field: ‘calls’
[11:01:52.310]   - Field: ‘globals’
[11:01:52.310]   - Field: ‘stdout’
[11:01:52.311]   - Field: ‘earlySignal’
[11:01:52.311]   - Field: ‘lazy’
[11:01:52.311]   - Field: ‘state’
[11:01:52.311] - Copy elements of temporary ‘SequentialFuture’ to final ‘Future’ object ... done
[11:01:52.311] - Launch lazy future ...
[11:01:52.311] Packages needed by the future expression (n = 0): <none>
[11:01:52.311] Packages needed by future strategies (n = 0): <none>
[11:01:52.311] {
[11:01:52.311]     {
[11:01:52.311]         {
[11:01:52.311]             ...future.startTime <- base::Sys.time()
[11:01:52.311]             {
[11:01:52.311]                 {
[11:01:52.311]                   {
[11:01:52.311]                     base::local({
[11:01:52.311]                       has_future <- base::requireNamespace("future", 
[11:01:52.311]                         quietly = TRUE)
[11:01:52.311]                       if (has_future) {
[11:01:52.311]                         ns <- base::getNamespace("future")
[11:01:52.311]                         version <- ns[[".package"]][["version"]]
[11:01:52.311]                         if (is.null(version)) 
[11:01:52.311]                           version <- utils::packageVersion("future")
[11:01:52.311]                       }
[11:01:52.311]                       else {
[11:01:52.311]                         version <- NULL
[11:01:52.311]                       }
[11:01:52.311]                       if (!has_future || version < "1.8.0") {
[11:01:52.311]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.311]                           "", base::R.version$version.string), 
[11:01:52.311]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.311]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.311]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.311]                             "release", "version")], collapse = " "), 
[11:01:52.311]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.311]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.311]                           info)
[11:01:52.311]                         info <- base::paste(info, collapse = "; ")
[11:01:52.311]                         if (!has_future) {
[11:01:52.311]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.311]                             info)
[11:01:52.311]                         }
[11:01:52.311]                         else {
[11:01:52.311]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.311]                             info, version)
[11:01:52.311]                         }
[11:01:52.311]                         base::stop(msg)
[11:01:52.311]                       }
[11:01:52.311]                     })
[11:01:52.311]                   }
[11:01:52.311]                   ...future.strategy.old <- future::plan("list")
[11:01:52.311]                   options(future.plan = NULL)
[11:01:52.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.311]                 }
[11:01:52.311]                 ...future.workdir <- getwd()
[11:01:52.311]             }
[11:01:52.311]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.311]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.311]         }
[11:01:52.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.311]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.311]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.311]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.311]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.311]             base::names(...future.oldOptions))
[11:01:52.311]     }
[11:01:52.311]     if (FALSE) {
[11:01:52.311]     }
[11:01:52.311]     else {
[11:01:52.311]         if (TRUE) {
[11:01:52.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.311]                 open = "w")
[11:01:52.311]         }
[11:01:52.311]         else {
[11:01:52.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.311]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.311]         }
[11:01:52.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.311]             base::sink(type = "output", split = FALSE)
[11:01:52.311]             base::close(...future.stdout)
[11:01:52.311]         }, add = TRUE)
[11:01:52.311]     }
[11:01:52.311]     ...future.frame <- base::sys.nframe()
[11:01:52.311]     ...future.conditions <- base::list()
[11:01:52.311]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.311]     if (FALSE) {
[11:01:52.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.311]     }
[11:01:52.311]     ...future.result <- base::tryCatch({
[11:01:52.311]         base::withCallingHandlers({
[11:01:52.311]             ...future.value <- base::withVisible(base::local({
[11:01:52.311]                 x <- x()
[11:01:52.311]                 x
[11:01:52.311]             }))
[11:01:52.311]             future::FutureResult(value = ...future.value$value, 
[11:01:52.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.311]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.311]                     ...future.globalenv.names))
[11:01:52.311]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.311]         }, condition = base::local({
[11:01:52.311]             c <- base::c
[11:01:52.311]             inherits <- base::inherits
[11:01:52.311]             invokeRestart <- base::invokeRestart
[11:01:52.311]             length <- base::length
[11:01:52.311]             list <- base::list
[11:01:52.311]             seq.int <- base::seq.int
[11:01:52.311]             signalCondition <- base::signalCondition
[11:01:52.311]             sys.calls <- base::sys.calls
[11:01:52.311]             `[[` <- base::`[[`
[11:01:52.311]             `+` <- base::`+`
[11:01:52.311]             `<<-` <- base::`<<-`
[11:01:52.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.311]                   3L)]
[11:01:52.311]             }
[11:01:52.311]             function(cond) {
[11:01:52.311]                 is_error <- inherits(cond, "error")
[11:01:52.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.311]                   NULL)
[11:01:52.311]                 if (is_error) {
[11:01:52.311]                   sessionInformation <- function() {
[11:01:52.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.311]                       search = base::search(), system = base::Sys.info())
[11:01:52.311]                   }
[11:01:52.311]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.311]                     cond$call), session = sessionInformation(), 
[11:01:52.311]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.311]                   signalCondition(cond)
[11:01:52.311]                 }
[11:01:52.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.311]                 "immediateCondition"))) {
[11:01:52.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.311]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.311]                   if (TRUE && !signal) {
[11:01:52.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.311]                     {
[11:01:52.311]                       inherits <- base::inherits
[11:01:52.311]                       invokeRestart <- base::invokeRestart
[11:01:52.311]                       is.null <- base::is.null
[11:01:52.311]                       muffled <- FALSE
[11:01:52.311]                       if (inherits(cond, "message")) {
[11:01:52.311]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.311]                         if (muffled) 
[11:01:52.311]                           invokeRestart("muffleMessage")
[11:01:52.311]                       }
[11:01:52.311]                       else if (inherits(cond, "warning")) {
[11:01:52.311]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.311]                         if (muffled) 
[11:01:52.311]                           invokeRestart("muffleWarning")
[11:01:52.311]                       }
[11:01:52.311]                       else if (inherits(cond, "condition")) {
[11:01:52.311]                         if (!is.null(pattern)) {
[11:01:52.311]                           computeRestarts <- base::computeRestarts
[11:01:52.311]                           grepl <- base::grepl
[11:01:52.311]                           restarts <- computeRestarts(cond)
[11:01:52.311]                           for (restart in restarts) {
[11:01:52.311]                             name <- restart$name
[11:01:52.311]                             if (is.null(name)) 
[11:01:52.311]                               next
[11:01:52.311]                             if (!grepl(pattern, name)) 
[11:01:52.311]                               next
[11:01:52.311]                             invokeRestart(restart)
[11:01:52.311]                             muffled <- TRUE
[11:01:52.311]                             break
[11:01:52.311]                           }
[11:01:52.311]                         }
[11:01:52.311]                       }
[11:01:52.311]                       invisible(muffled)
[11:01:52.311]                     }
[11:01:52.311]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.311]                   }
[11:01:52.311]                 }
[11:01:52.311]                 else {
[11:01:52.311]                   if (TRUE) {
[11:01:52.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.311]                     {
[11:01:52.311]                       inherits <- base::inherits
[11:01:52.311]                       invokeRestart <- base::invokeRestart
[11:01:52.311]                       is.null <- base::is.null
[11:01:52.311]                       muffled <- FALSE
[11:01:52.311]                       if (inherits(cond, "message")) {
[11:01:52.311]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.311]                         if (muffled) 
[11:01:52.311]                           invokeRestart("muffleMessage")
[11:01:52.311]                       }
[11:01:52.311]                       else if (inherits(cond, "warning")) {
[11:01:52.311]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.311]                         if (muffled) 
[11:01:52.311]                           invokeRestart("muffleWarning")
[11:01:52.311]                       }
[11:01:52.311]                       else if (inherits(cond, "condition")) {
[11:01:52.311]                         if (!is.null(pattern)) {
[11:01:52.311]                           computeRestarts <- base::computeRestarts
[11:01:52.311]                           grepl <- base::grepl
[11:01:52.311]                           restarts <- computeRestarts(cond)
[11:01:52.311]                           for (restart in restarts) {
[11:01:52.311]                             name <- restart$name
[11:01:52.311]                             if (is.null(name)) 
[11:01:52.311]                               next
[11:01:52.311]                             if (!grepl(pattern, name)) 
[11:01:52.311]                               next
[11:01:52.311]                             invokeRestart(restart)
[11:01:52.311]                             muffled <- TRUE
[11:01:52.311]                             break
[11:01:52.311]                           }
[11:01:52.311]                         }
[11:01:52.311]                       }
[11:01:52.311]                       invisible(muffled)
[11:01:52.311]                     }
[11:01:52.311]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.311]                   }
[11:01:52.311]                 }
[11:01:52.311]             }
[11:01:52.311]         }))
[11:01:52.311]     }, error = function(ex) {
[11:01:52.311]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.311]                 ...future.rng), started = ...future.startTime, 
[11:01:52.311]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.311]             version = "1.8"), class = "FutureResult")
[11:01:52.311]     }, finally = {
[11:01:52.311]         if (!identical(...future.workdir, getwd())) 
[11:01:52.311]             setwd(...future.workdir)
[11:01:52.311]         {
[11:01:52.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.311]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.311]             }
[11:01:52.311]             base::options(...future.oldOptions)
[11:01:52.311]             if (.Platform$OS.type == "windows") {
[11:01:52.311]                 old_names <- names(...future.oldEnvVars)
[11:01:52.311]                 envs <- base::Sys.getenv()
[11:01:52.311]                 names <- names(envs)
[11:01:52.311]                 common <- intersect(names, old_names)
[11:01:52.311]                 added <- setdiff(names, old_names)
[11:01:52.311]                 removed <- setdiff(old_names, names)
[11:01:52.311]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.311]                   envs[common]]
[11:01:52.311]                 NAMES <- toupper(changed)
[11:01:52.311]                 args <- list()
[11:01:52.311]                 for (kk in seq_along(NAMES)) {
[11:01:52.311]                   name <- changed[[kk]]
[11:01:52.311]                   NAME <- NAMES[[kk]]
[11:01:52.311]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.311]                     next
[11:01:52.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.311]                 }
[11:01:52.311]                 NAMES <- toupper(added)
[11:01:52.311]                 for (kk in seq_along(NAMES)) {
[11:01:52.311]                   name <- added[[kk]]
[11:01:52.311]                   NAME <- NAMES[[kk]]
[11:01:52.311]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.311]                     next
[11:01:52.311]                   args[[name]] <- ""
[11:01:52.311]                 }
[11:01:52.311]                 NAMES <- toupper(removed)
[11:01:52.311]                 for (kk in seq_along(NAMES)) {
[11:01:52.311]                   name <- removed[[kk]]
[11:01:52.311]                   NAME <- NAMES[[kk]]
[11:01:52.311]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.311]                     next
[11:01:52.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.311]                 }
[11:01:52.311]                 if (length(args) > 0) 
[11:01:52.311]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.311]             }
[11:01:52.311]             else {
[11:01:52.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.311]             }
[11:01:52.311]             {
[11:01:52.311]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.311]                   0L) {
[11:01:52.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.311]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.311]                   base::options(opts)
[11:01:52.311]                 }
[11:01:52.311]                 {
[11:01:52.311]                   {
[11:01:52.311]                     NULL
[11:01:52.311]                     RNGkind("Mersenne-Twister")
[11:01:52.311]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.311]                       inherits = FALSE)
[11:01:52.311]                   }
[11:01:52.311]                   options(future.plan = NULL)
[11:01:52.311]                   if (is.na(NA_character_)) 
[11:01:52.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.311]                     .init = FALSE)
[11:01:52.311]                 }
[11:01:52.311]             }
[11:01:52.311]         }
[11:01:52.311]     })
[11:01:52.311]     if (TRUE) {
[11:01:52.311]         base::sink(type = "output", split = FALSE)
[11:01:52.311]         if (TRUE) {
[11:01:52.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.311]         }
[11:01:52.311]         else {
[11:01:52.311]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.311]         }
[11:01:52.311]         base::close(...future.stdout)
[11:01:52.311]         ...future.stdout <- NULL
[11:01:52.311]     }
[11:01:52.311]     ...future.result$conditions <- ...future.conditions
[11:01:52.311]     ...future.result$finished <- base::Sys.time()
[11:01:52.311]     ...future.result
[11:01:52.311] }
[11:01:52.313] assign_globals() ...
[11:01:52.313] List of 1
[11:01:52.313]  $ x:function ()  
[11:01:52.313]  - attr(*, "where")=List of 1
[11:01:52.313]   ..$ x:<environment: R_EmptyEnv> 
[11:01:52.313]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.313]  - attr(*, "resolved")= logi TRUE
[11:01:52.313]  - attr(*, "total_size")= num 260
[11:01:52.313]  - attr(*, "already-done")= logi TRUE
[11:01:52.315] - reassign environment for ‘x’
[11:01:52.315] - copied ‘x’ to environment
[11:01:52.316] assign_globals() ... done
[11:01:52.316] plan(): Setting new future strategy stack:
[11:01:52.316] List of future strategies:
[11:01:52.316] 1. sequential:
[11:01:52.316]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.316]    - tweaked: FALSE
[11:01:52.316]    - call: NULL
[11:01:52.316] plan(): nbrOfWorkers() = 1
[11:01:52.317] plan(): Setting new future strategy stack:
[11:01:52.317] List of future strategies:
[11:01:52.317] 1. sequential:
[11:01:52.317]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.317]    - tweaked: FALSE
[11:01:52.317]    - call: plan(strategy)
[11:01:52.317] plan(): nbrOfWorkers() = 1
[11:01:52.318] SequentialFuture started (and completed)
[11:01:52.318] - Launch lazy future ... done
[11:01:52.318] run() for ‘SequentialFuture’ ... done
value(f) = ‘TRUE’
Testing with 1 cores ... DONE
Testing with 2 cores ...
availableCores(): 2
- Local variables with the same name as globals ...
- plan('multicore') ...
[11:01:52.325] plan(): Setting new future strategy stack:
[11:01:52.325] List of future strategies:
[11:01:52.325] 1. multicore:
[11:01:52.325]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.325]    - tweaked: FALSE
[11:01:52.325]    - call: plan(strategy)
[11:01:52.327] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.327] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.327] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.328] - globals found: [3] ‘{’, ‘<-’, ‘*’
[11:01:52.329] Searching for globals ... DONE
[11:01:52.329] Resolving globals: TRUE
[11:01:52.329] Resolving any globals that are futures ...
[11:01:52.329] - globals: [3] ‘{’, ‘<-’, ‘*’
[11:01:52.329] Resolving any globals that are futures ... DONE
[11:01:52.329] 
[11:01:52.329] 
[11:01:52.329] getGlobalsAndPackages() ... DONE
[11:01:52.330] run() for ‘Future’ ...
[11:01:52.330] - state: ‘created’
[11:01:52.330] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.331] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.331] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.332]   - Field: ‘label’
[11:01:52.332]   - Field: ‘local’
[11:01:52.332]   - Field: ‘owner’
[11:01:52.332]   - Field: ‘envir’
[11:01:52.332]   - Field: ‘workers’
[11:01:52.332]   - Field: ‘packages’
[11:01:52.332]   - Field: ‘gc’
[11:01:52.332]   - Field: ‘job’
[11:01:52.332]   - Field: ‘conditions’
[11:01:52.332]   - Field: ‘expr’
[11:01:52.332]   - Field: ‘uuid’
[11:01:52.332]   - Field: ‘seed’
[11:01:52.333]   - Field: ‘version’
[11:01:52.333]   - Field: ‘result’
[11:01:52.333]   - Field: ‘asynchronous’
[11:01:52.333]   - Field: ‘calls’
[11:01:52.333]   - Field: ‘globals’
[11:01:52.333]   - Field: ‘stdout’
[11:01:52.333]   - Field: ‘earlySignal’
[11:01:52.333]   - Field: ‘lazy’
[11:01:52.333]   - Field: ‘state’
[11:01:52.333] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.333] - Launch lazy future ...
[11:01:52.334] Packages needed by the future expression (n = 0): <none>
[11:01:52.334] Packages needed by future strategies (n = 0): <none>
[11:01:52.335] {
[11:01:52.335]     {
[11:01:52.335]         {
[11:01:52.335]             ...future.startTime <- base::Sys.time()
[11:01:52.335]             {
[11:01:52.335]                 {
[11:01:52.335]                   {
[11:01:52.335]                     {
[11:01:52.335]                       base::local({
[11:01:52.335]                         has_future <- base::requireNamespace("future", 
[11:01:52.335]                           quietly = TRUE)
[11:01:52.335]                         if (has_future) {
[11:01:52.335]                           ns <- base::getNamespace("future")
[11:01:52.335]                           version <- ns[[".package"]][["version"]]
[11:01:52.335]                           if (is.null(version)) 
[11:01:52.335]                             version <- utils::packageVersion("future")
[11:01:52.335]                         }
[11:01:52.335]                         else {
[11:01:52.335]                           version <- NULL
[11:01:52.335]                         }
[11:01:52.335]                         if (!has_future || version < "1.8.0") {
[11:01:52.335]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.335]                             "", base::R.version$version.string), 
[11:01:52.335]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.335]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.335]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.335]                               "release", "version")], collapse = " "), 
[11:01:52.335]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.335]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.335]                             info)
[11:01:52.335]                           info <- base::paste(info, collapse = "; ")
[11:01:52.335]                           if (!has_future) {
[11:01:52.335]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.335]                               info)
[11:01:52.335]                           }
[11:01:52.335]                           else {
[11:01:52.335]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.335]                               info, version)
[11:01:52.335]                           }
[11:01:52.335]                           base::stop(msg)
[11:01:52.335]                         }
[11:01:52.335]                       })
[11:01:52.335]                     }
[11:01:52.335]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.335]                     base::options(mc.cores = 1L)
[11:01:52.335]                   }
[11:01:52.335]                   ...future.strategy.old <- future::plan("list")
[11:01:52.335]                   options(future.plan = NULL)
[11:01:52.335]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.335]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.335]                 }
[11:01:52.335]                 ...future.workdir <- getwd()
[11:01:52.335]             }
[11:01:52.335]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.335]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.335]         }
[11:01:52.335]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.335]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.335]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.335]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.335]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.335]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.335]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.335]             base::names(...future.oldOptions))
[11:01:52.335]     }
[11:01:52.335]     if (FALSE) {
[11:01:52.335]     }
[11:01:52.335]     else {
[11:01:52.335]         if (TRUE) {
[11:01:52.335]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.335]                 open = "w")
[11:01:52.335]         }
[11:01:52.335]         else {
[11:01:52.335]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.335]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.335]         }
[11:01:52.335]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.335]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.335]             base::sink(type = "output", split = FALSE)
[11:01:52.335]             base::close(...future.stdout)
[11:01:52.335]         }, add = TRUE)
[11:01:52.335]     }
[11:01:52.335]     ...future.frame <- base::sys.nframe()
[11:01:52.335]     ...future.conditions <- base::list()
[11:01:52.335]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.335]     if (FALSE) {
[11:01:52.335]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.335]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.335]     }
[11:01:52.335]     ...future.result <- base::tryCatch({
[11:01:52.335]         base::withCallingHandlers({
[11:01:52.335]             ...future.value <- base::withVisible(base::local({
[11:01:52.335]                 withCallingHandlers({
[11:01:52.335]                   {
[11:01:52.335]                     b <- a
[11:01:52.335]                     a <- 2
[11:01:52.335]                     a * b
[11:01:52.335]                   }
[11:01:52.335]                 }, immediateCondition = function(cond) {
[11:01:52.335]                   save_rds <- function (object, pathname, ...) 
[11:01:52.335]                   {
[11:01:52.335]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.335]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.335]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.335]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.335]                         fi_tmp[["mtime"]])
[11:01:52.335]                     }
[11:01:52.335]                     tryCatch({
[11:01:52.335]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.335]                     }, error = function(ex) {
[11:01:52.335]                       msg <- conditionMessage(ex)
[11:01:52.335]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.335]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.335]                         fi_tmp[["mtime"]], msg)
[11:01:52.335]                       ex$message <- msg
[11:01:52.335]                       stop(ex)
[11:01:52.335]                     })
[11:01:52.335]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.335]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.335]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.335]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.335]                       fi <- file.info(pathname)
[11:01:52.335]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.335]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.335]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.335]                         fi[["size"]], fi[["mtime"]])
[11:01:52.335]                       stop(msg)
[11:01:52.335]                     }
[11:01:52.335]                     invisible(pathname)
[11:01:52.335]                   }
[11:01:52.335]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.335]                     rootPath = tempdir()) 
[11:01:52.335]                   {
[11:01:52.335]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.335]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.335]                       tmpdir = path, fileext = ".rds")
[11:01:52.335]                     save_rds(obj, file)
[11:01:52.335]                   }
[11:01:52.335]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.335]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.335]                   {
[11:01:52.335]                     inherits <- base::inherits
[11:01:52.335]                     invokeRestart <- base::invokeRestart
[11:01:52.335]                     is.null <- base::is.null
[11:01:52.335]                     muffled <- FALSE
[11:01:52.335]                     if (inherits(cond, "message")) {
[11:01:52.335]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.335]                       if (muffled) 
[11:01:52.335]                         invokeRestart("muffleMessage")
[11:01:52.335]                     }
[11:01:52.335]                     else if (inherits(cond, "warning")) {
[11:01:52.335]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.335]                       if (muffled) 
[11:01:52.335]                         invokeRestart("muffleWarning")
[11:01:52.335]                     }
[11:01:52.335]                     else if (inherits(cond, "condition")) {
[11:01:52.335]                       if (!is.null(pattern)) {
[11:01:52.335]                         computeRestarts <- base::computeRestarts
[11:01:52.335]                         grepl <- base::grepl
[11:01:52.335]                         restarts <- computeRestarts(cond)
[11:01:52.335]                         for (restart in restarts) {
[11:01:52.335]                           name <- restart$name
[11:01:52.335]                           if (is.null(name)) 
[11:01:52.335]                             next
[11:01:52.335]                           if (!grepl(pattern, name)) 
[11:01:52.335]                             next
[11:01:52.335]                           invokeRestart(restart)
[11:01:52.335]                           muffled <- TRUE
[11:01:52.335]                           break
[11:01:52.335]                         }
[11:01:52.335]                       }
[11:01:52.335]                     }
[11:01:52.335]                     invisible(muffled)
[11:01:52.335]                   }
[11:01:52.335]                   muffleCondition(cond)
[11:01:52.335]                 })
[11:01:52.335]             }))
[11:01:52.335]             future::FutureResult(value = ...future.value$value, 
[11:01:52.335]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.335]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.335]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.335]                     ...future.globalenv.names))
[11:01:52.335]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.335]         }, condition = base::local({
[11:01:52.335]             c <- base::c
[11:01:52.335]             inherits <- base::inherits
[11:01:52.335]             invokeRestart <- base::invokeRestart
[11:01:52.335]             length <- base::length
[11:01:52.335]             list <- base::list
[11:01:52.335]             seq.int <- base::seq.int
[11:01:52.335]             signalCondition <- base::signalCondition
[11:01:52.335]             sys.calls <- base::sys.calls
[11:01:52.335]             `[[` <- base::`[[`
[11:01:52.335]             `+` <- base::`+`
[11:01:52.335]             `<<-` <- base::`<<-`
[11:01:52.335]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.335]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.335]                   3L)]
[11:01:52.335]             }
[11:01:52.335]             function(cond) {
[11:01:52.335]                 is_error <- inherits(cond, "error")
[11:01:52.335]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.335]                   NULL)
[11:01:52.335]                 if (is_error) {
[11:01:52.335]                   sessionInformation <- function() {
[11:01:52.335]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.335]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.335]                       search = base::search(), system = base::Sys.info())
[11:01:52.335]                   }
[11:01:52.335]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.335]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.335]                     cond$call), session = sessionInformation(), 
[11:01:52.335]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.335]                   signalCondition(cond)
[11:01:52.335]                 }
[11:01:52.335]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.335]                 "immediateCondition"))) {
[11:01:52.335]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.335]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.335]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.335]                   if (TRUE && !signal) {
[11:01:52.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.335]                     {
[11:01:52.335]                       inherits <- base::inherits
[11:01:52.335]                       invokeRestart <- base::invokeRestart
[11:01:52.335]                       is.null <- base::is.null
[11:01:52.335]                       muffled <- FALSE
[11:01:52.335]                       if (inherits(cond, "message")) {
[11:01:52.335]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.335]                         if (muffled) 
[11:01:52.335]                           invokeRestart("muffleMessage")
[11:01:52.335]                       }
[11:01:52.335]                       else if (inherits(cond, "warning")) {
[11:01:52.335]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.335]                         if (muffled) 
[11:01:52.335]                           invokeRestart("muffleWarning")
[11:01:52.335]                       }
[11:01:52.335]                       else if (inherits(cond, "condition")) {
[11:01:52.335]                         if (!is.null(pattern)) {
[11:01:52.335]                           computeRestarts <- base::computeRestarts
[11:01:52.335]                           grepl <- base::grepl
[11:01:52.335]                           restarts <- computeRestarts(cond)
[11:01:52.335]                           for (restart in restarts) {
[11:01:52.335]                             name <- restart$name
[11:01:52.335]                             if (is.null(name)) 
[11:01:52.335]                               next
[11:01:52.335]                             if (!grepl(pattern, name)) 
[11:01:52.335]                               next
[11:01:52.335]                             invokeRestart(restart)
[11:01:52.335]                             muffled <- TRUE
[11:01:52.335]                             break
[11:01:52.335]                           }
[11:01:52.335]                         }
[11:01:52.335]                       }
[11:01:52.335]                       invisible(muffled)
[11:01:52.335]                     }
[11:01:52.335]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.335]                   }
[11:01:52.335]                 }
[11:01:52.335]                 else {
[11:01:52.335]                   if (TRUE) {
[11:01:52.335]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.335]                     {
[11:01:52.335]                       inherits <- base::inherits
[11:01:52.335]                       invokeRestart <- base::invokeRestart
[11:01:52.335]                       is.null <- base::is.null
[11:01:52.335]                       muffled <- FALSE
[11:01:52.335]                       if (inherits(cond, "message")) {
[11:01:52.335]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.335]                         if (muffled) 
[11:01:52.335]                           invokeRestart("muffleMessage")
[11:01:52.335]                       }
[11:01:52.335]                       else if (inherits(cond, "warning")) {
[11:01:52.335]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.335]                         if (muffled) 
[11:01:52.335]                           invokeRestart("muffleWarning")
[11:01:52.335]                       }
[11:01:52.335]                       else if (inherits(cond, "condition")) {
[11:01:52.335]                         if (!is.null(pattern)) {
[11:01:52.335]                           computeRestarts <- base::computeRestarts
[11:01:52.335]                           grepl <- base::grepl
[11:01:52.335]                           restarts <- computeRestarts(cond)
[11:01:52.335]                           for (restart in restarts) {
[11:01:52.335]                             name <- restart$name
[11:01:52.335]                             if (is.null(name)) 
[11:01:52.335]                               next
[11:01:52.335]                             if (!grepl(pattern, name)) 
[11:01:52.335]                               next
[11:01:52.335]                             invokeRestart(restart)
[11:01:52.335]                             muffled <- TRUE
[11:01:52.335]                             break
[11:01:52.335]                           }
[11:01:52.335]                         }
[11:01:52.335]                       }
[11:01:52.335]                       invisible(muffled)
[11:01:52.335]                     }
[11:01:52.335]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.335]                   }
[11:01:52.335]                 }
[11:01:52.335]             }
[11:01:52.335]         }))
[11:01:52.335]     }, error = function(ex) {
[11:01:52.335]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.335]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.335]                 ...future.rng), started = ...future.startTime, 
[11:01:52.335]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.335]             version = "1.8"), class = "FutureResult")
[11:01:52.335]     }, finally = {
[11:01:52.335]         if (!identical(...future.workdir, getwd())) 
[11:01:52.335]             setwd(...future.workdir)
[11:01:52.335]         {
[11:01:52.335]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.335]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.335]             }
[11:01:52.335]             base::options(...future.oldOptions)
[11:01:52.335]             if (.Platform$OS.type == "windows") {
[11:01:52.335]                 old_names <- names(...future.oldEnvVars)
[11:01:52.335]                 envs <- base::Sys.getenv()
[11:01:52.335]                 names <- names(envs)
[11:01:52.335]                 common <- intersect(names, old_names)
[11:01:52.335]                 added <- setdiff(names, old_names)
[11:01:52.335]                 removed <- setdiff(old_names, names)
[11:01:52.335]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.335]                   envs[common]]
[11:01:52.335]                 NAMES <- toupper(changed)
[11:01:52.335]                 args <- list()
[11:01:52.335]                 for (kk in seq_along(NAMES)) {
[11:01:52.335]                   name <- changed[[kk]]
[11:01:52.335]                   NAME <- NAMES[[kk]]
[11:01:52.335]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.335]                     next
[11:01:52.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.335]                 }
[11:01:52.335]                 NAMES <- toupper(added)
[11:01:52.335]                 for (kk in seq_along(NAMES)) {
[11:01:52.335]                   name <- added[[kk]]
[11:01:52.335]                   NAME <- NAMES[[kk]]
[11:01:52.335]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.335]                     next
[11:01:52.335]                   args[[name]] <- ""
[11:01:52.335]                 }
[11:01:52.335]                 NAMES <- toupper(removed)
[11:01:52.335]                 for (kk in seq_along(NAMES)) {
[11:01:52.335]                   name <- removed[[kk]]
[11:01:52.335]                   NAME <- NAMES[[kk]]
[11:01:52.335]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.335]                     next
[11:01:52.335]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.335]                 }
[11:01:52.335]                 if (length(args) > 0) 
[11:01:52.335]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.335]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.335]             }
[11:01:52.335]             else {
[11:01:52.335]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.335]             }
[11:01:52.335]             {
[11:01:52.335]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.335]                   0L) {
[11:01:52.335]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.335]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.335]                   base::options(opts)
[11:01:52.335]                 }
[11:01:52.335]                 {
[11:01:52.335]                   {
[11:01:52.335]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.335]                     NULL
[11:01:52.335]                   }
[11:01:52.335]                   options(future.plan = NULL)
[11:01:52.335]                   if (is.na(NA_character_)) 
[11:01:52.335]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.335]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.335]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.335]                     .init = FALSE)
[11:01:52.335]                 }
[11:01:52.335]             }
[11:01:52.335]         }
[11:01:52.335]     })
[11:01:52.335]     if (TRUE) {
[11:01:52.335]         base::sink(type = "output", split = FALSE)
[11:01:52.335]         if (TRUE) {
[11:01:52.335]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.335]         }
[11:01:52.335]         else {
[11:01:52.335]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.335]         }
[11:01:52.335]         base::close(...future.stdout)
[11:01:52.335]         ...future.stdout <- NULL
[11:01:52.335]     }
[11:01:52.335]     ...future.result$conditions <- ...future.conditions
[11:01:52.335]     ...future.result$finished <- base::Sys.time()
[11:01:52.335]     ...future.result
[11:01:52.335] }
[11:01:52.337] requestCore(): workers = 2
[11:01:52.340] MulticoreFuture started
[11:01:52.340] - Launch lazy future ... done
[11:01:52.340] plan(): Setting new future strategy stack:
[11:01:52.341] run() for ‘MulticoreFuture’ ... done
[11:01:52.341] List of future strategies:
[11:01:52.341] 1. sequential:
[11:01:52.341]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.341]    - tweaked: FALSE
[11:01:52.341]    - call: NULL
[11:01:52.342] plan(): nbrOfWorkers() = 1
[11:01:52.342] result() for MulticoreFuture ...
[11:01:52.344] plan(): Setting new future strategy stack:
[11:01:52.344] List of future strategies:
[11:01:52.344] 1. multicore:
[11:01:52.344]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.344]    - tweaked: FALSE
[11:01:52.344]    - call: plan(strategy)
[11:01:52.347] plan(): nbrOfWorkers() = 2
[11:01:52.352] result() for MulticoreFuture ...
[11:01:52.352] result() for MulticoreFuture ... done
[11:01:52.352] result() for MulticoreFuture ... done
[11:01:52.352] result() for MulticoreFuture ...
[11:01:52.352] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.353] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.353] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.355] - globals found: [3] ‘{’, ‘<-’, ‘*’
[11:01:52.355] Searching for globals ... DONE
[11:01:52.355] Resolving globals: TRUE
[11:01:52.355] Resolving any globals that are futures ...
[11:01:52.355] - globals: [3] ‘{’, ‘<-’, ‘*’
[11:01:52.356] Resolving any globals that are futures ... DONE
[11:01:52.356] 
[11:01:52.356] 
[11:01:52.356] getGlobalsAndPackages() ... DONE
[11:01:52.357] run() for ‘Future’ ...
[11:01:52.357] - state: ‘created’
[11:01:52.357] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.359] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.359]   - Field: ‘label’
[11:01:52.359]   - Field: ‘local’
[11:01:52.359]   - Field: ‘owner’
[11:01:52.360]   - Field: ‘envir’
[11:01:52.360]   - Field: ‘workers’
[11:01:52.360]   - Field: ‘packages’
[11:01:52.360]   - Field: ‘gc’
[11:01:52.360]   - Field: ‘job’
[11:01:52.360]   - Field: ‘conditions’
[11:01:52.360]   - Field: ‘expr’
[11:01:52.360]   - Field: ‘uuid’
[11:01:52.360]   - Field: ‘seed’
[11:01:52.361]   - Field: ‘version’
[11:01:52.361]   - Field: ‘result’
[11:01:52.361]   - Field: ‘asynchronous’
[11:01:52.361]   - Field: ‘calls’
[11:01:52.361]   - Field: ‘globals’
[11:01:52.361]   - Field: ‘stdout’
[11:01:52.361]   - Field: ‘earlySignal’
[11:01:52.361]   - Field: ‘lazy’
[11:01:52.361]   - Field: ‘state’
[11:01:52.362] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.362] - Launch lazy future ...
[11:01:52.362] Packages needed by the future expression (n = 0): <none>
[11:01:52.362] Packages needed by future strategies (n = 0): <none>
[11:01:52.363] {
[11:01:52.363]     {
[11:01:52.363]         {
[11:01:52.363]             ...future.startTime <- base::Sys.time()
[11:01:52.363]             {
[11:01:52.363]                 {
[11:01:52.363]                   {
[11:01:52.363]                     {
[11:01:52.363]                       base::local({
[11:01:52.363]                         has_future <- base::requireNamespace("future", 
[11:01:52.363]                           quietly = TRUE)
[11:01:52.363]                         if (has_future) {
[11:01:52.363]                           ns <- base::getNamespace("future")
[11:01:52.363]                           version <- ns[[".package"]][["version"]]
[11:01:52.363]                           if (is.null(version)) 
[11:01:52.363]                             version <- utils::packageVersion("future")
[11:01:52.363]                         }
[11:01:52.363]                         else {
[11:01:52.363]                           version <- NULL
[11:01:52.363]                         }
[11:01:52.363]                         if (!has_future || version < "1.8.0") {
[11:01:52.363]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.363]                             "", base::R.version$version.string), 
[11:01:52.363]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.363]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.363]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.363]                               "release", "version")], collapse = " "), 
[11:01:52.363]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.363]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.363]                             info)
[11:01:52.363]                           info <- base::paste(info, collapse = "; ")
[11:01:52.363]                           if (!has_future) {
[11:01:52.363]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.363]                               info)
[11:01:52.363]                           }
[11:01:52.363]                           else {
[11:01:52.363]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.363]                               info, version)
[11:01:52.363]                           }
[11:01:52.363]                           base::stop(msg)
[11:01:52.363]                         }
[11:01:52.363]                       })
[11:01:52.363]                     }
[11:01:52.363]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.363]                     base::options(mc.cores = 1L)
[11:01:52.363]                   }
[11:01:52.363]                   ...future.strategy.old <- future::plan("list")
[11:01:52.363]                   options(future.plan = NULL)
[11:01:52.363]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.363]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.363]                 }
[11:01:52.363]                 ...future.workdir <- getwd()
[11:01:52.363]             }
[11:01:52.363]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.363]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.363]         }
[11:01:52.363]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.363]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.363]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.363]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.363]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.363]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.363]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.363]             base::names(...future.oldOptions))
[11:01:52.363]     }
[11:01:52.363]     if (FALSE) {
[11:01:52.363]     }
[11:01:52.363]     else {
[11:01:52.363]         if (TRUE) {
[11:01:52.363]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.363]                 open = "w")
[11:01:52.363]         }
[11:01:52.363]         else {
[11:01:52.363]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.363]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.363]         }
[11:01:52.363]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.363]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.363]             base::sink(type = "output", split = FALSE)
[11:01:52.363]             base::close(...future.stdout)
[11:01:52.363]         }, add = TRUE)
[11:01:52.363]     }
[11:01:52.363]     ...future.frame <- base::sys.nframe()
[11:01:52.363]     ...future.conditions <- base::list()
[11:01:52.363]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.363]     if (FALSE) {
[11:01:52.363]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.363]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.363]     }
[11:01:52.363]     ...future.result <- base::tryCatch({
[11:01:52.363]         base::withCallingHandlers({
[11:01:52.363]             ...future.value <- base::withVisible(base::local({
[11:01:52.363]                 withCallingHandlers({
[11:01:52.363]                   {
[11:01:52.363]                     b <- a
[11:01:52.363]                     a <- 2
[11:01:52.363]                     a * b
[11:01:52.363]                   }
[11:01:52.363]                 }, immediateCondition = function(cond) {
[11:01:52.363]                   save_rds <- function (object, pathname, ...) 
[11:01:52.363]                   {
[11:01:52.363]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.363]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.363]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.363]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.363]                         fi_tmp[["mtime"]])
[11:01:52.363]                     }
[11:01:52.363]                     tryCatch({
[11:01:52.363]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.363]                     }, error = function(ex) {
[11:01:52.363]                       msg <- conditionMessage(ex)
[11:01:52.363]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.363]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.363]                         fi_tmp[["mtime"]], msg)
[11:01:52.363]                       ex$message <- msg
[11:01:52.363]                       stop(ex)
[11:01:52.363]                     })
[11:01:52.363]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.363]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.363]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.363]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.363]                       fi <- file.info(pathname)
[11:01:52.363]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.363]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.363]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.363]                         fi[["size"]], fi[["mtime"]])
[11:01:52.363]                       stop(msg)
[11:01:52.363]                     }
[11:01:52.363]                     invisible(pathname)
[11:01:52.363]                   }
[11:01:52.363]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.363]                     rootPath = tempdir()) 
[11:01:52.363]                   {
[11:01:52.363]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.363]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.363]                       tmpdir = path, fileext = ".rds")
[11:01:52.363]                     save_rds(obj, file)
[11:01:52.363]                   }
[11:01:52.363]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.363]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.363]                   {
[11:01:52.363]                     inherits <- base::inherits
[11:01:52.363]                     invokeRestart <- base::invokeRestart
[11:01:52.363]                     is.null <- base::is.null
[11:01:52.363]                     muffled <- FALSE
[11:01:52.363]                     if (inherits(cond, "message")) {
[11:01:52.363]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.363]                       if (muffled) 
[11:01:52.363]                         invokeRestart("muffleMessage")
[11:01:52.363]                     }
[11:01:52.363]                     else if (inherits(cond, "warning")) {
[11:01:52.363]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.363]                       if (muffled) 
[11:01:52.363]                         invokeRestart("muffleWarning")
[11:01:52.363]                     }
[11:01:52.363]                     else if (inherits(cond, "condition")) {
[11:01:52.363]                       if (!is.null(pattern)) {
[11:01:52.363]                         computeRestarts <- base::computeRestarts
[11:01:52.363]                         grepl <- base::grepl
[11:01:52.363]                         restarts <- computeRestarts(cond)
[11:01:52.363]                         for (restart in restarts) {
[11:01:52.363]                           name <- restart$name
[11:01:52.363]                           if (is.null(name)) 
[11:01:52.363]                             next
[11:01:52.363]                           if (!grepl(pattern, name)) 
[11:01:52.363]                             next
[11:01:52.363]                           invokeRestart(restart)
[11:01:52.363]                           muffled <- TRUE
[11:01:52.363]                           break
[11:01:52.363]                         }
[11:01:52.363]                       }
[11:01:52.363]                     }
[11:01:52.363]                     invisible(muffled)
[11:01:52.363]                   }
[11:01:52.363]                   muffleCondition(cond)
[11:01:52.363]                 })
[11:01:52.363]             }))
[11:01:52.363]             future::FutureResult(value = ...future.value$value, 
[11:01:52.363]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.363]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.363]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.363]                     ...future.globalenv.names))
[11:01:52.363]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.363]         }, condition = base::local({
[11:01:52.363]             c <- base::c
[11:01:52.363]             inherits <- base::inherits
[11:01:52.363]             invokeRestart <- base::invokeRestart
[11:01:52.363]             length <- base::length
[11:01:52.363]             list <- base::list
[11:01:52.363]             seq.int <- base::seq.int
[11:01:52.363]             signalCondition <- base::signalCondition
[11:01:52.363]             sys.calls <- base::sys.calls
[11:01:52.363]             `[[` <- base::`[[`
[11:01:52.363]             `+` <- base::`+`
[11:01:52.363]             `<<-` <- base::`<<-`
[11:01:52.363]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.363]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.363]                   3L)]
[11:01:52.363]             }
[11:01:52.363]             function(cond) {
[11:01:52.363]                 is_error <- inherits(cond, "error")
[11:01:52.363]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.363]                   NULL)
[11:01:52.363]                 if (is_error) {
[11:01:52.363]                   sessionInformation <- function() {
[11:01:52.363]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.363]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.363]                       search = base::search(), system = base::Sys.info())
[11:01:52.363]                   }
[11:01:52.363]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.363]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.363]                     cond$call), session = sessionInformation(), 
[11:01:52.363]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.363]                   signalCondition(cond)
[11:01:52.363]                 }
[11:01:52.363]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.363]                 "immediateCondition"))) {
[11:01:52.363]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.363]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.363]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.363]                   if (TRUE && !signal) {
[11:01:52.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.363]                     {
[11:01:52.363]                       inherits <- base::inherits
[11:01:52.363]                       invokeRestart <- base::invokeRestart
[11:01:52.363]                       is.null <- base::is.null
[11:01:52.363]                       muffled <- FALSE
[11:01:52.363]                       if (inherits(cond, "message")) {
[11:01:52.363]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.363]                         if (muffled) 
[11:01:52.363]                           invokeRestart("muffleMessage")
[11:01:52.363]                       }
[11:01:52.363]                       else if (inherits(cond, "warning")) {
[11:01:52.363]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.363]                         if (muffled) 
[11:01:52.363]                           invokeRestart("muffleWarning")
[11:01:52.363]                       }
[11:01:52.363]                       else if (inherits(cond, "condition")) {
[11:01:52.363]                         if (!is.null(pattern)) {
[11:01:52.363]                           computeRestarts <- base::computeRestarts
[11:01:52.363]                           grepl <- base::grepl
[11:01:52.363]                           restarts <- computeRestarts(cond)
[11:01:52.363]                           for (restart in restarts) {
[11:01:52.363]                             name <- restart$name
[11:01:52.363]                             if (is.null(name)) 
[11:01:52.363]                               next
[11:01:52.363]                             if (!grepl(pattern, name)) 
[11:01:52.363]                               next
[11:01:52.363]                             invokeRestart(restart)
[11:01:52.363]                             muffled <- TRUE
[11:01:52.363]                             break
[11:01:52.363]                           }
[11:01:52.363]                         }
[11:01:52.363]                       }
[11:01:52.363]                       invisible(muffled)
[11:01:52.363]                     }
[11:01:52.363]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.363]                   }
[11:01:52.363]                 }
[11:01:52.363]                 else {
[11:01:52.363]                   if (TRUE) {
[11:01:52.363]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.363]                     {
[11:01:52.363]                       inherits <- base::inherits
[11:01:52.363]                       invokeRestart <- base::invokeRestart
[11:01:52.363]                       is.null <- base::is.null
[11:01:52.363]                       muffled <- FALSE
[11:01:52.363]                       if (inherits(cond, "message")) {
[11:01:52.363]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.363]                         if (muffled) 
[11:01:52.363]                           invokeRestart("muffleMessage")
[11:01:52.363]                       }
[11:01:52.363]                       else if (inherits(cond, "warning")) {
[11:01:52.363]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.363]                         if (muffled) 
[11:01:52.363]                           invokeRestart("muffleWarning")
[11:01:52.363]                       }
[11:01:52.363]                       else if (inherits(cond, "condition")) {
[11:01:52.363]                         if (!is.null(pattern)) {
[11:01:52.363]                           computeRestarts <- base::computeRestarts
[11:01:52.363]                           grepl <- base::grepl
[11:01:52.363]                           restarts <- computeRestarts(cond)
[11:01:52.363]                           for (restart in restarts) {
[11:01:52.363]                             name <- restart$name
[11:01:52.363]                             if (is.null(name)) 
[11:01:52.363]                               next
[11:01:52.363]                             if (!grepl(pattern, name)) 
[11:01:52.363]                               next
[11:01:52.363]                             invokeRestart(restart)
[11:01:52.363]                             muffled <- TRUE
[11:01:52.363]                             break
[11:01:52.363]                           }
[11:01:52.363]                         }
[11:01:52.363]                       }
[11:01:52.363]                       invisible(muffled)
[11:01:52.363]                     }
[11:01:52.363]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.363]                   }
[11:01:52.363]                 }
[11:01:52.363]             }
[11:01:52.363]         }))
[11:01:52.363]     }, error = function(ex) {
[11:01:52.363]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.363]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.363]                 ...future.rng), started = ...future.startTime, 
[11:01:52.363]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.363]             version = "1.8"), class = "FutureResult")
[11:01:52.363]     }, finally = {
[11:01:52.363]         if (!identical(...future.workdir, getwd())) 
[11:01:52.363]             setwd(...future.workdir)
[11:01:52.363]         {
[11:01:52.363]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.363]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.363]             }
[11:01:52.363]             base::options(...future.oldOptions)
[11:01:52.363]             if (.Platform$OS.type == "windows") {
[11:01:52.363]                 old_names <- names(...future.oldEnvVars)
[11:01:52.363]                 envs <- base::Sys.getenv()
[11:01:52.363]                 names <- names(envs)
[11:01:52.363]                 common <- intersect(names, old_names)
[11:01:52.363]                 added <- setdiff(names, old_names)
[11:01:52.363]                 removed <- setdiff(old_names, names)
[11:01:52.363]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.363]                   envs[common]]
[11:01:52.363]                 NAMES <- toupper(changed)
[11:01:52.363]                 args <- list()
[11:01:52.363]                 for (kk in seq_along(NAMES)) {
[11:01:52.363]                   name <- changed[[kk]]
[11:01:52.363]                   NAME <- NAMES[[kk]]
[11:01:52.363]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.363]                     next
[11:01:52.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.363]                 }
[11:01:52.363]                 NAMES <- toupper(added)
[11:01:52.363]                 for (kk in seq_along(NAMES)) {
[11:01:52.363]                   name <- added[[kk]]
[11:01:52.363]                   NAME <- NAMES[[kk]]
[11:01:52.363]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.363]                     next
[11:01:52.363]                   args[[name]] <- ""
[11:01:52.363]                 }
[11:01:52.363]                 NAMES <- toupper(removed)
[11:01:52.363]                 for (kk in seq_along(NAMES)) {
[11:01:52.363]                   name <- removed[[kk]]
[11:01:52.363]                   NAME <- NAMES[[kk]]
[11:01:52.363]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.363]                     next
[11:01:52.363]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.363]                 }
[11:01:52.363]                 if (length(args) > 0) 
[11:01:52.363]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.363]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.363]             }
[11:01:52.363]             else {
[11:01:52.363]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.363]             }
[11:01:52.363]             {
[11:01:52.363]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.363]                   0L) {
[11:01:52.363]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.363]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.363]                   base::options(opts)
[11:01:52.363]                 }
[11:01:52.363]                 {
[11:01:52.363]                   {
[11:01:52.363]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.363]                     NULL
[11:01:52.363]                   }
[11:01:52.363]                   options(future.plan = NULL)
[11:01:52.363]                   if (is.na(NA_character_)) 
[11:01:52.363]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.363]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.363]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.363]                     .init = FALSE)
[11:01:52.363]                 }
[11:01:52.363]             }
[11:01:52.363]         }
[11:01:52.363]     })
[11:01:52.363]     if (TRUE) {
[11:01:52.363]         base::sink(type = "output", split = FALSE)
[11:01:52.363]         if (TRUE) {
[11:01:52.363]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.363]         }
[11:01:52.363]         else {
[11:01:52.363]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.363]         }
[11:01:52.363]         base::close(...future.stdout)
[11:01:52.363]         ...future.stdout <- NULL
[11:01:52.363]     }
[11:01:52.363]     ...future.result$conditions <- ...future.conditions
[11:01:52.363]     ...future.result$finished <- base::Sys.time()
[11:01:52.363]     ...future.result
[11:01:52.363] }
[11:01:52.365] requestCore(): workers = 2
[11:01:52.367] MulticoreFuture started
[11:01:52.367] - Launch lazy future ... done
[11:01:52.368] run() for ‘MulticoreFuture’ ... done
[11:01:52.368] result() for MulticoreFuture ...
[11:01:52.368] plan(): Setting new future strategy stack:
[11:01:52.368] List of future strategies:
[11:01:52.368] 1. sequential:
[11:01:52.368]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.368]    - tweaked: FALSE
[11:01:52.368]    - call: NULL
[11:01:52.375] plan(): nbrOfWorkers() = 1
[11:01:52.377] plan(): Setting new future strategy stack:
[11:01:52.377] List of future strategies:
[11:01:52.377] 1. multicore:
[11:01:52.377]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.377]    - tweaked: FALSE
[11:01:52.377]    - call: plan(strategy)
[11:01:52.381] plan(): nbrOfWorkers() = 2
[11:01:52.388] result() for MulticoreFuture ...
[11:01:52.388] result() for MulticoreFuture ... done
[11:01:52.388] signalConditions() ...
[11:01:52.388]  - include = ‘immediateCondition’
[11:01:52.388]  - exclude = 
[11:01:52.389]  - resignal = FALSE
[11:01:52.389]  - Number of conditions: 1
[11:01:52.389] signalConditions() ... done
[11:01:52.389] result() for MulticoreFuture ... done
[11:01:52.389] result() for MulticoreFuture ...
[11:01:52.389] result() for MulticoreFuture ... done
[11:01:52.389] signalConditions() ...
[11:01:52.390]  - include = ‘immediateCondition’
[11:01:52.390]  - exclude = 
[11:01:52.390]  - resignal = FALSE
[11:01:52.390]  - Number of conditions: 1
[11:01:52.390] signalConditions() ... done
[11:01:52.390] Future state: ‘finished’
[11:01:52.390] result() for MulticoreFuture ...
[11:01:52.390] result() for MulticoreFuture ... done
[11:01:52.391] signalConditions() ...
[11:01:52.391]  - include = ‘condition’
[11:01:52.391]  - exclude = ‘immediateCondition’
[11:01:52.391]  - resignal = TRUE
[11:01:52.391]  - Number of conditions: 1
[11:01:52.391]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:52.391] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 39
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:52"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.416] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.416] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.418] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.418] Searching for globals ... DONE
[11:01:52.418] Resolving globals: TRUE
[11:01:52.418] Resolving any globals that are futures ...
[11:01:52.418] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.418] Resolving any globals that are futures ... DONE
[11:01:52.419] Resolving futures part of globals (recursively) ...
[11:01:52.419] resolve() on list ...
[11:01:52.419]  recursive: 99
[11:01:52.419]  length: 1
[11:01:52.419]  elements: ‘ii’
[11:01:52.419]  length: 0 (resolved future 1)
[11:01:52.419] resolve() on list ... DONE
[11:01:52.420] - globals: [1] ‘ii’
[11:01:52.420] Resolving futures part of globals (recursively) ... DONE
[11:01:52.420] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:52.420] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.420] - globals: [1] ‘ii’
[11:01:52.420] 
[11:01:52.420] getGlobalsAndPackages() ... DONE
[11:01:52.421] run() for ‘Future’ ...
[11:01:52.421] - state: ‘created’
[11:01:52.421] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.422] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.423] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.423]   - Field: ‘label’
[11:01:52.423]   - Field: ‘local’
[11:01:52.423]   - Field: ‘owner’
[11:01:52.423]   - Field: ‘envir’
[11:01:52.423]   - Field: ‘workers’
[11:01:52.423]   - Field: ‘packages’
[11:01:52.423]   - Field: ‘gc’
[11:01:52.423]   - Field: ‘job’
[11:01:52.423]   - Field: ‘conditions’
[11:01:52.423]   - Field: ‘expr’
[11:01:52.424]   - Field: ‘uuid’
[11:01:52.424]   - Field: ‘seed’
[11:01:52.424]   - Field: ‘version’
[11:01:52.424]   - Field: ‘result’
[11:01:52.424]   - Field: ‘asynchronous’
[11:01:52.424]   - Field: ‘calls’
[11:01:52.424]   - Field: ‘globals’
[11:01:52.424]   - Field: ‘stdout’
[11:01:52.424]   - Field: ‘earlySignal’
[11:01:52.424]   - Field: ‘lazy’
[11:01:52.424]   - Field: ‘state’
[11:01:52.424] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.424] - Launch lazy future ...
[11:01:52.425] Packages needed by the future expression (n = 0): <none>
[11:01:52.425] Packages needed by future strategies (n = 0): <none>
[11:01:52.425] {
[11:01:52.425]     {
[11:01:52.425]         {
[11:01:52.425]             ...future.startTime <- base::Sys.time()
[11:01:52.425]             {
[11:01:52.425]                 {
[11:01:52.425]                   {
[11:01:52.425]                     {
[11:01:52.425]                       base::local({
[11:01:52.425]                         has_future <- base::requireNamespace("future", 
[11:01:52.425]                           quietly = TRUE)
[11:01:52.425]                         if (has_future) {
[11:01:52.425]                           ns <- base::getNamespace("future")
[11:01:52.425]                           version <- ns[[".package"]][["version"]]
[11:01:52.425]                           if (is.null(version)) 
[11:01:52.425]                             version <- utils::packageVersion("future")
[11:01:52.425]                         }
[11:01:52.425]                         else {
[11:01:52.425]                           version <- NULL
[11:01:52.425]                         }
[11:01:52.425]                         if (!has_future || version < "1.8.0") {
[11:01:52.425]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.425]                             "", base::R.version$version.string), 
[11:01:52.425]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.425]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.425]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.425]                               "release", "version")], collapse = " "), 
[11:01:52.425]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.425]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.425]                             info)
[11:01:52.425]                           info <- base::paste(info, collapse = "; ")
[11:01:52.425]                           if (!has_future) {
[11:01:52.425]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.425]                               info)
[11:01:52.425]                           }
[11:01:52.425]                           else {
[11:01:52.425]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.425]                               info, version)
[11:01:52.425]                           }
[11:01:52.425]                           base::stop(msg)
[11:01:52.425]                         }
[11:01:52.425]                       })
[11:01:52.425]                     }
[11:01:52.425]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.425]                     base::options(mc.cores = 1L)
[11:01:52.425]                   }
[11:01:52.425]                   ...future.strategy.old <- future::plan("list")
[11:01:52.425]                   options(future.plan = NULL)
[11:01:52.425]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.425]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.425]                 }
[11:01:52.425]                 ...future.workdir <- getwd()
[11:01:52.425]             }
[11:01:52.425]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.425]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.425]         }
[11:01:52.425]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.425]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.425]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.425]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.425]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.425]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.425]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.425]             base::names(...future.oldOptions))
[11:01:52.425]     }
[11:01:52.425]     if (FALSE) {
[11:01:52.425]     }
[11:01:52.425]     else {
[11:01:52.425]         if (TRUE) {
[11:01:52.425]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.425]                 open = "w")
[11:01:52.425]         }
[11:01:52.425]         else {
[11:01:52.425]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.425]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.425]         }
[11:01:52.425]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.425]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.425]             base::sink(type = "output", split = FALSE)
[11:01:52.425]             base::close(...future.stdout)
[11:01:52.425]         }, add = TRUE)
[11:01:52.425]     }
[11:01:52.425]     ...future.frame <- base::sys.nframe()
[11:01:52.425]     ...future.conditions <- base::list()
[11:01:52.425]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.425]     if (FALSE) {
[11:01:52.425]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.425]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.425]     }
[11:01:52.425]     ...future.result <- base::tryCatch({
[11:01:52.425]         base::withCallingHandlers({
[11:01:52.425]             ...future.value <- base::withVisible(base::local({
[11:01:52.425]                 withCallingHandlers({
[11:01:52.425]                   {
[11:01:52.425]                     b <- a * ii
[11:01:52.425]                     a <- 0
[11:01:52.425]                     b
[11:01:52.425]                   }
[11:01:52.425]                 }, immediateCondition = function(cond) {
[11:01:52.425]                   save_rds <- function (object, pathname, ...) 
[11:01:52.425]                   {
[11:01:52.425]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.425]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.425]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.425]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.425]                         fi_tmp[["mtime"]])
[11:01:52.425]                     }
[11:01:52.425]                     tryCatch({
[11:01:52.425]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.425]                     }, error = function(ex) {
[11:01:52.425]                       msg <- conditionMessage(ex)
[11:01:52.425]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.425]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.425]                         fi_tmp[["mtime"]], msg)
[11:01:52.425]                       ex$message <- msg
[11:01:52.425]                       stop(ex)
[11:01:52.425]                     })
[11:01:52.425]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.425]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.425]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.425]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.425]                       fi <- file.info(pathname)
[11:01:52.425]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.425]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.425]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.425]                         fi[["size"]], fi[["mtime"]])
[11:01:52.425]                       stop(msg)
[11:01:52.425]                     }
[11:01:52.425]                     invisible(pathname)
[11:01:52.425]                   }
[11:01:52.425]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.425]                     rootPath = tempdir()) 
[11:01:52.425]                   {
[11:01:52.425]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.425]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.425]                       tmpdir = path, fileext = ".rds")
[11:01:52.425]                     save_rds(obj, file)
[11:01:52.425]                   }
[11:01:52.425]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.425]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.425]                   {
[11:01:52.425]                     inherits <- base::inherits
[11:01:52.425]                     invokeRestart <- base::invokeRestart
[11:01:52.425]                     is.null <- base::is.null
[11:01:52.425]                     muffled <- FALSE
[11:01:52.425]                     if (inherits(cond, "message")) {
[11:01:52.425]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.425]                       if (muffled) 
[11:01:52.425]                         invokeRestart("muffleMessage")
[11:01:52.425]                     }
[11:01:52.425]                     else if (inherits(cond, "warning")) {
[11:01:52.425]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.425]                       if (muffled) 
[11:01:52.425]                         invokeRestart("muffleWarning")
[11:01:52.425]                     }
[11:01:52.425]                     else if (inherits(cond, "condition")) {
[11:01:52.425]                       if (!is.null(pattern)) {
[11:01:52.425]                         computeRestarts <- base::computeRestarts
[11:01:52.425]                         grepl <- base::grepl
[11:01:52.425]                         restarts <- computeRestarts(cond)
[11:01:52.425]                         for (restart in restarts) {
[11:01:52.425]                           name <- restart$name
[11:01:52.425]                           if (is.null(name)) 
[11:01:52.425]                             next
[11:01:52.425]                           if (!grepl(pattern, name)) 
[11:01:52.425]                             next
[11:01:52.425]                           invokeRestart(restart)
[11:01:52.425]                           muffled <- TRUE
[11:01:52.425]                           break
[11:01:52.425]                         }
[11:01:52.425]                       }
[11:01:52.425]                     }
[11:01:52.425]                     invisible(muffled)
[11:01:52.425]                   }
[11:01:52.425]                   muffleCondition(cond)
[11:01:52.425]                 })
[11:01:52.425]             }))
[11:01:52.425]             future::FutureResult(value = ...future.value$value, 
[11:01:52.425]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.425]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.425]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.425]                     ...future.globalenv.names))
[11:01:52.425]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.425]         }, condition = base::local({
[11:01:52.425]             c <- base::c
[11:01:52.425]             inherits <- base::inherits
[11:01:52.425]             invokeRestart <- base::invokeRestart
[11:01:52.425]             length <- base::length
[11:01:52.425]             list <- base::list
[11:01:52.425]             seq.int <- base::seq.int
[11:01:52.425]             signalCondition <- base::signalCondition
[11:01:52.425]             sys.calls <- base::sys.calls
[11:01:52.425]             `[[` <- base::`[[`
[11:01:52.425]             `+` <- base::`+`
[11:01:52.425]             `<<-` <- base::`<<-`
[11:01:52.425]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.425]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.425]                   3L)]
[11:01:52.425]             }
[11:01:52.425]             function(cond) {
[11:01:52.425]                 is_error <- inherits(cond, "error")
[11:01:52.425]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.425]                   NULL)
[11:01:52.425]                 if (is_error) {
[11:01:52.425]                   sessionInformation <- function() {
[11:01:52.425]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.425]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.425]                       search = base::search(), system = base::Sys.info())
[11:01:52.425]                   }
[11:01:52.425]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.425]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.425]                     cond$call), session = sessionInformation(), 
[11:01:52.425]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.425]                   signalCondition(cond)
[11:01:52.425]                 }
[11:01:52.425]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.425]                 "immediateCondition"))) {
[11:01:52.425]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.425]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.425]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.425]                   if (TRUE && !signal) {
[11:01:52.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.425]                     {
[11:01:52.425]                       inherits <- base::inherits
[11:01:52.425]                       invokeRestart <- base::invokeRestart
[11:01:52.425]                       is.null <- base::is.null
[11:01:52.425]                       muffled <- FALSE
[11:01:52.425]                       if (inherits(cond, "message")) {
[11:01:52.425]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.425]                         if (muffled) 
[11:01:52.425]                           invokeRestart("muffleMessage")
[11:01:52.425]                       }
[11:01:52.425]                       else if (inherits(cond, "warning")) {
[11:01:52.425]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.425]                         if (muffled) 
[11:01:52.425]                           invokeRestart("muffleWarning")
[11:01:52.425]                       }
[11:01:52.425]                       else if (inherits(cond, "condition")) {
[11:01:52.425]                         if (!is.null(pattern)) {
[11:01:52.425]                           computeRestarts <- base::computeRestarts
[11:01:52.425]                           grepl <- base::grepl
[11:01:52.425]                           restarts <- computeRestarts(cond)
[11:01:52.425]                           for (restart in restarts) {
[11:01:52.425]                             name <- restart$name
[11:01:52.425]                             if (is.null(name)) 
[11:01:52.425]                               next
[11:01:52.425]                             if (!grepl(pattern, name)) 
[11:01:52.425]                               next
[11:01:52.425]                             invokeRestart(restart)
[11:01:52.425]                             muffled <- TRUE
[11:01:52.425]                             break
[11:01:52.425]                           }
[11:01:52.425]                         }
[11:01:52.425]                       }
[11:01:52.425]                       invisible(muffled)
[11:01:52.425]                     }
[11:01:52.425]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.425]                   }
[11:01:52.425]                 }
[11:01:52.425]                 else {
[11:01:52.425]                   if (TRUE) {
[11:01:52.425]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.425]                     {
[11:01:52.425]                       inherits <- base::inherits
[11:01:52.425]                       invokeRestart <- base::invokeRestart
[11:01:52.425]                       is.null <- base::is.null
[11:01:52.425]                       muffled <- FALSE
[11:01:52.425]                       if (inherits(cond, "message")) {
[11:01:52.425]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.425]                         if (muffled) 
[11:01:52.425]                           invokeRestart("muffleMessage")
[11:01:52.425]                       }
[11:01:52.425]                       else if (inherits(cond, "warning")) {
[11:01:52.425]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.425]                         if (muffled) 
[11:01:52.425]                           invokeRestart("muffleWarning")
[11:01:52.425]                       }
[11:01:52.425]                       else if (inherits(cond, "condition")) {
[11:01:52.425]                         if (!is.null(pattern)) {
[11:01:52.425]                           computeRestarts <- base::computeRestarts
[11:01:52.425]                           grepl <- base::grepl
[11:01:52.425]                           restarts <- computeRestarts(cond)
[11:01:52.425]                           for (restart in restarts) {
[11:01:52.425]                             name <- restart$name
[11:01:52.425]                             if (is.null(name)) 
[11:01:52.425]                               next
[11:01:52.425]                             if (!grepl(pattern, name)) 
[11:01:52.425]                               next
[11:01:52.425]                             invokeRestart(restart)
[11:01:52.425]                             muffled <- TRUE
[11:01:52.425]                             break
[11:01:52.425]                           }
[11:01:52.425]                         }
[11:01:52.425]                       }
[11:01:52.425]                       invisible(muffled)
[11:01:52.425]                     }
[11:01:52.425]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.425]                   }
[11:01:52.425]                 }
[11:01:52.425]             }
[11:01:52.425]         }))
[11:01:52.425]     }, error = function(ex) {
[11:01:52.425]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.425]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.425]                 ...future.rng), started = ...future.startTime, 
[11:01:52.425]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.425]             version = "1.8"), class = "FutureResult")
[11:01:52.425]     }, finally = {
[11:01:52.425]         if (!identical(...future.workdir, getwd())) 
[11:01:52.425]             setwd(...future.workdir)
[11:01:52.425]         {
[11:01:52.425]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.425]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.425]             }
[11:01:52.425]             base::options(...future.oldOptions)
[11:01:52.425]             if (.Platform$OS.type == "windows") {
[11:01:52.425]                 old_names <- names(...future.oldEnvVars)
[11:01:52.425]                 envs <- base::Sys.getenv()
[11:01:52.425]                 names <- names(envs)
[11:01:52.425]                 common <- intersect(names, old_names)
[11:01:52.425]                 added <- setdiff(names, old_names)
[11:01:52.425]                 removed <- setdiff(old_names, names)
[11:01:52.425]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.425]                   envs[common]]
[11:01:52.425]                 NAMES <- toupper(changed)
[11:01:52.425]                 args <- list()
[11:01:52.425]                 for (kk in seq_along(NAMES)) {
[11:01:52.425]                   name <- changed[[kk]]
[11:01:52.425]                   NAME <- NAMES[[kk]]
[11:01:52.425]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.425]                     next
[11:01:52.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.425]                 }
[11:01:52.425]                 NAMES <- toupper(added)
[11:01:52.425]                 for (kk in seq_along(NAMES)) {
[11:01:52.425]                   name <- added[[kk]]
[11:01:52.425]                   NAME <- NAMES[[kk]]
[11:01:52.425]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.425]                     next
[11:01:52.425]                   args[[name]] <- ""
[11:01:52.425]                 }
[11:01:52.425]                 NAMES <- toupper(removed)
[11:01:52.425]                 for (kk in seq_along(NAMES)) {
[11:01:52.425]                   name <- removed[[kk]]
[11:01:52.425]                   NAME <- NAMES[[kk]]
[11:01:52.425]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.425]                     next
[11:01:52.425]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.425]                 }
[11:01:52.425]                 if (length(args) > 0) 
[11:01:52.425]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.425]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.425]             }
[11:01:52.425]             else {
[11:01:52.425]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.425]             }
[11:01:52.425]             {
[11:01:52.425]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.425]                   0L) {
[11:01:52.425]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.425]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.425]                   base::options(opts)
[11:01:52.425]                 }
[11:01:52.425]                 {
[11:01:52.425]                   {
[11:01:52.425]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.425]                     NULL
[11:01:52.425]                   }
[11:01:52.425]                   options(future.plan = NULL)
[11:01:52.425]                   if (is.na(NA_character_)) 
[11:01:52.425]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.425]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.425]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.425]                     .init = FALSE)
[11:01:52.425]                 }
[11:01:52.425]             }
[11:01:52.425]         }
[11:01:52.425]     })
[11:01:52.425]     if (TRUE) {
[11:01:52.425]         base::sink(type = "output", split = FALSE)
[11:01:52.425]         if (TRUE) {
[11:01:52.425]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.425]         }
[11:01:52.425]         else {
[11:01:52.425]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.425]         }
[11:01:52.425]         base::close(...future.stdout)
[11:01:52.425]         ...future.stdout <- NULL
[11:01:52.425]     }
[11:01:52.425]     ...future.result$conditions <- ...future.conditions
[11:01:52.425]     ...future.result$finished <- base::Sys.time()
[11:01:52.425]     ...future.result
[11:01:52.425] }
[11:01:52.427] assign_globals() ...
[11:01:52.428] List of 1
[11:01:52.428]  $ ii: int 1
[11:01:52.428]  - attr(*, "where")=List of 1
[11:01:52.428]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.428]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.428]  - attr(*, "resolved")= logi TRUE
[11:01:52.428]  - attr(*, "total_size")= num 35
[11:01:52.428]  - attr(*, "already-done")= logi TRUE
[11:01:52.430] - copied ‘ii’ to environment
[11:01:52.430] assign_globals() ... done
[11:01:52.430] requestCore(): workers = 2
[11:01:52.432] MulticoreFuture started
[11:01:52.432] - Launch lazy future ... done
[11:01:52.433] run() for ‘MulticoreFuture’ ... done
[11:01:52.433] plan(): Setting new future strategy stack:
[11:01:52.433] List of future strategies:
[11:01:52.433] 1. sequential:
[11:01:52.433]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.433]    - tweaked: FALSE
[11:01:52.433]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.434] plan(): nbrOfWorkers() = 1
[11:01:52.434] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.435] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.436] plan(): Setting new future strategy stack:
[11:01:52.436] List of future strategies:
[11:01:52.436] 1. multicore:
[11:01:52.436]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.436]    - tweaked: FALSE
[11:01:52.436]    - call: plan(strategy)
[11:01:52.438] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.438] Searching for globals ... DONE
[11:01:52.438] Resolving globals: TRUE
[11:01:52.439] Resolving any globals that are futures ...
[11:01:52.439] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.439] plan(): nbrOfWorkers() = 2
[11:01:52.439] Resolving any globals that are futures ... DONE
[11:01:52.440] Resolving futures part of globals (recursively) ...
[11:01:52.440] resolve() on list ...
[11:01:52.441]  recursive: 99
[11:01:52.441]  length: 1
[11:01:52.441]  elements: ‘ii’
[11:01:52.441]  length: 0 (resolved future 1)
[11:01:52.445] resolve() on list ... DONE
[11:01:52.446] - globals: [1] ‘ii’
[11:01:52.446] Resolving futures part of globals (recursively) ... DONE
[11:01:52.447] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:52.448] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.448] - globals: [1] ‘ii’
[11:01:52.448] 
[11:01:52.448] getGlobalsAndPackages() ... DONE
[11:01:52.449] run() for ‘Future’ ...
[11:01:52.449] - state: ‘created’
[11:01:52.450] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.453] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.453] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.454]   - Field: ‘label’
[11:01:52.454]   - Field: ‘local’
[11:01:52.454]   - Field: ‘owner’
[11:01:52.454]   - Field: ‘envir’
[11:01:52.455]   - Field: ‘workers’
[11:01:52.455]   - Field: ‘packages’
[11:01:52.455]   - Field: ‘gc’
[11:01:52.455]   - Field: ‘job’
[11:01:52.455]   - Field: ‘conditions’
[11:01:52.455]   - Field: ‘expr’
[11:01:52.456]   - Field: ‘uuid’
[11:01:52.456]   - Field: ‘seed’
[11:01:52.456]   - Field: ‘version’
[11:01:52.456]   - Field: ‘result’
[11:01:52.456]   - Field: ‘asynchronous’
[11:01:52.456]   - Field: ‘calls’
[11:01:52.457]   - Field: ‘globals’
[11:01:52.457]   - Field: ‘stdout’
[11:01:52.457]   - Field: ‘earlySignal’
[11:01:52.457]   - Field: ‘lazy’
[11:01:52.457]   - Field: ‘state’
[11:01:52.457] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.458] - Launch lazy future ...
[11:01:52.458] Packages needed by the future expression (n = 0): <none>
[11:01:52.458] Packages needed by future strategies (n = 0): <none>
[11:01:52.459] {
[11:01:52.459]     {
[11:01:52.459]         {
[11:01:52.459]             ...future.startTime <- base::Sys.time()
[11:01:52.459]             {
[11:01:52.459]                 {
[11:01:52.459]                   {
[11:01:52.459]                     {
[11:01:52.459]                       base::local({
[11:01:52.459]                         has_future <- base::requireNamespace("future", 
[11:01:52.459]                           quietly = TRUE)
[11:01:52.459]                         if (has_future) {
[11:01:52.459]                           ns <- base::getNamespace("future")
[11:01:52.459]                           version <- ns[[".package"]][["version"]]
[11:01:52.459]                           if (is.null(version)) 
[11:01:52.459]                             version <- utils::packageVersion("future")
[11:01:52.459]                         }
[11:01:52.459]                         else {
[11:01:52.459]                           version <- NULL
[11:01:52.459]                         }
[11:01:52.459]                         if (!has_future || version < "1.8.0") {
[11:01:52.459]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.459]                             "", base::R.version$version.string), 
[11:01:52.459]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.459]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.459]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.459]                               "release", "version")], collapse = " "), 
[11:01:52.459]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.459]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.459]                             info)
[11:01:52.459]                           info <- base::paste(info, collapse = "; ")
[11:01:52.459]                           if (!has_future) {
[11:01:52.459]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.459]                               info)
[11:01:52.459]                           }
[11:01:52.459]                           else {
[11:01:52.459]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.459]                               info, version)
[11:01:52.459]                           }
[11:01:52.459]                           base::stop(msg)
[11:01:52.459]                         }
[11:01:52.459]                       })
[11:01:52.459]                     }
[11:01:52.459]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.459]                     base::options(mc.cores = 1L)
[11:01:52.459]                   }
[11:01:52.459]                   ...future.strategy.old <- future::plan("list")
[11:01:52.459]                   options(future.plan = NULL)
[11:01:52.459]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.459]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.459]                 }
[11:01:52.459]                 ...future.workdir <- getwd()
[11:01:52.459]             }
[11:01:52.459]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.459]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.459]         }
[11:01:52.459]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.459]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.459]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.459]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.459]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.459]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.459]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.459]             base::names(...future.oldOptions))
[11:01:52.459]     }
[11:01:52.459]     if (FALSE) {
[11:01:52.459]     }
[11:01:52.459]     else {
[11:01:52.459]         if (TRUE) {
[11:01:52.459]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.459]                 open = "w")
[11:01:52.459]         }
[11:01:52.459]         else {
[11:01:52.459]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.459]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.459]         }
[11:01:52.459]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.459]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.459]             base::sink(type = "output", split = FALSE)
[11:01:52.459]             base::close(...future.stdout)
[11:01:52.459]         }, add = TRUE)
[11:01:52.459]     }
[11:01:52.459]     ...future.frame <- base::sys.nframe()
[11:01:52.459]     ...future.conditions <- base::list()
[11:01:52.459]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.459]     if (FALSE) {
[11:01:52.459]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.459]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.459]     }
[11:01:52.459]     ...future.result <- base::tryCatch({
[11:01:52.459]         base::withCallingHandlers({
[11:01:52.459]             ...future.value <- base::withVisible(base::local({
[11:01:52.459]                 withCallingHandlers({
[11:01:52.459]                   {
[11:01:52.459]                     b <- a * ii
[11:01:52.459]                     a <- 0
[11:01:52.459]                     b
[11:01:52.459]                   }
[11:01:52.459]                 }, immediateCondition = function(cond) {
[11:01:52.459]                   save_rds <- function (object, pathname, ...) 
[11:01:52.459]                   {
[11:01:52.459]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.459]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.459]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.459]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.459]                         fi_tmp[["mtime"]])
[11:01:52.459]                     }
[11:01:52.459]                     tryCatch({
[11:01:52.459]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.459]                     }, error = function(ex) {
[11:01:52.459]                       msg <- conditionMessage(ex)
[11:01:52.459]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.459]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.459]                         fi_tmp[["mtime"]], msg)
[11:01:52.459]                       ex$message <- msg
[11:01:52.459]                       stop(ex)
[11:01:52.459]                     })
[11:01:52.459]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.459]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.459]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.459]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.459]                       fi <- file.info(pathname)
[11:01:52.459]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.459]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.459]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.459]                         fi[["size"]], fi[["mtime"]])
[11:01:52.459]                       stop(msg)
[11:01:52.459]                     }
[11:01:52.459]                     invisible(pathname)
[11:01:52.459]                   }
[11:01:52.459]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.459]                     rootPath = tempdir()) 
[11:01:52.459]                   {
[11:01:52.459]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.459]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.459]                       tmpdir = path, fileext = ".rds")
[11:01:52.459]                     save_rds(obj, file)
[11:01:52.459]                   }
[11:01:52.459]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.459]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.459]                   {
[11:01:52.459]                     inherits <- base::inherits
[11:01:52.459]                     invokeRestart <- base::invokeRestart
[11:01:52.459]                     is.null <- base::is.null
[11:01:52.459]                     muffled <- FALSE
[11:01:52.459]                     if (inherits(cond, "message")) {
[11:01:52.459]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.459]                       if (muffled) 
[11:01:52.459]                         invokeRestart("muffleMessage")
[11:01:52.459]                     }
[11:01:52.459]                     else if (inherits(cond, "warning")) {
[11:01:52.459]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.459]                       if (muffled) 
[11:01:52.459]                         invokeRestart("muffleWarning")
[11:01:52.459]                     }
[11:01:52.459]                     else if (inherits(cond, "condition")) {
[11:01:52.459]                       if (!is.null(pattern)) {
[11:01:52.459]                         computeRestarts <- base::computeRestarts
[11:01:52.459]                         grepl <- base::grepl
[11:01:52.459]                         restarts <- computeRestarts(cond)
[11:01:52.459]                         for (restart in restarts) {
[11:01:52.459]                           name <- restart$name
[11:01:52.459]                           if (is.null(name)) 
[11:01:52.459]                             next
[11:01:52.459]                           if (!grepl(pattern, name)) 
[11:01:52.459]                             next
[11:01:52.459]                           invokeRestart(restart)
[11:01:52.459]                           muffled <- TRUE
[11:01:52.459]                           break
[11:01:52.459]                         }
[11:01:52.459]                       }
[11:01:52.459]                     }
[11:01:52.459]                     invisible(muffled)
[11:01:52.459]                   }
[11:01:52.459]                   muffleCondition(cond)
[11:01:52.459]                 })
[11:01:52.459]             }))
[11:01:52.459]             future::FutureResult(value = ...future.value$value, 
[11:01:52.459]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.459]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.459]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.459]                     ...future.globalenv.names))
[11:01:52.459]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.459]         }, condition = base::local({
[11:01:52.459]             c <- base::c
[11:01:52.459]             inherits <- base::inherits
[11:01:52.459]             invokeRestart <- base::invokeRestart
[11:01:52.459]             length <- base::length
[11:01:52.459]             list <- base::list
[11:01:52.459]             seq.int <- base::seq.int
[11:01:52.459]             signalCondition <- base::signalCondition
[11:01:52.459]             sys.calls <- base::sys.calls
[11:01:52.459]             `[[` <- base::`[[`
[11:01:52.459]             `+` <- base::`+`
[11:01:52.459]             `<<-` <- base::`<<-`
[11:01:52.459]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.459]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.459]                   3L)]
[11:01:52.459]             }
[11:01:52.459]             function(cond) {
[11:01:52.459]                 is_error <- inherits(cond, "error")
[11:01:52.459]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.459]                   NULL)
[11:01:52.459]                 if (is_error) {
[11:01:52.459]                   sessionInformation <- function() {
[11:01:52.459]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.459]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.459]                       search = base::search(), system = base::Sys.info())
[11:01:52.459]                   }
[11:01:52.459]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.459]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.459]                     cond$call), session = sessionInformation(), 
[11:01:52.459]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.459]                   signalCondition(cond)
[11:01:52.459]                 }
[11:01:52.459]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.459]                 "immediateCondition"))) {
[11:01:52.459]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.459]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.459]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.459]                   if (TRUE && !signal) {
[11:01:52.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.459]                     {
[11:01:52.459]                       inherits <- base::inherits
[11:01:52.459]                       invokeRestart <- base::invokeRestart
[11:01:52.459]                       is.null <- base::is.null
[11:01:52.459]                       muffled <- FALSE
[11:01:52.459]                       if (inherits(cond, "message")) {
[11:01:52.459]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.459]                         if (muffled) 
[11:01:52.459]                           invokeRestart("muffleMessage")
[11:01:52.459]                       }
[11:01:52.459]                       else if (inherits(cond, "warning")) {
[11:01:52.459]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.459]                         if (muffled) 
[11:01:52.459]                           invokeRestart("muffleWarning")
[11:01:52.459]                       }
[11:01:52.459]                       else if (inherits(cond, "condition")) {
[11:01:52.459]                         if (!is.null(pattern)) {
[11:01:52.459]                           computeRestarts <- base::computeRestarts
[11:01:52.459]                           grepl <- base::grepl
[11:01:52.459]                           restarts <- computeRestarts(cond)
[11:01:52.459]                           for (restart in restarts) {
[11:01:52.459]                             name <- restart$name
[11:01:52.459]                             if (is.null(name)) 
[11:01:52.459]                               next
[11:01:52.459]                             if (!grepl(pattern, name)) 
[11:01:52.459]                               next
[11:01:52.459]                             invokeRestart(restart)
[11:01:52.459]                             muffled <- TRUE
[11:01:52.459]                             break
[11:01:52.459]                           }
[11:01:52.459]                         }
[11:01:52.459]                       }
[11:01:52.459]                       invisible(muffled)
[11:01:52.459]                     }
[11:01:52.459]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.459]                   }
[11:01:52.459]                 }
[11:01:52.459]                 else {
[11:01:52.459]                   if (TRUE) {
[11:01:52.459]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.459]                     {
[11:01:52.459]                       inherits <- base::inherits
[11:01:52.459]                       invokeRestart <- base::invokeRestart
[11:01:52.459]                       is.null <- base::is.null
[11:01:52.459]                       muffled <- FALSE
[11:01:52.459]                       if (inherits(cond, "message")) {
[11:01:52.459]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.459]                         if (muffled) 
[11:01:52.459]                           invokeRestart("muffleMessage")
[11:01:52.459]                       }
[11:01:52.459]                       else if (inherits(cond, "warning")) {
[11:01:52.459]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.459]                         if (muffled) 
[11:01:52.459]                           invokeRestart("muffleWarning")
[11:01:52.459]                       }
[11:01:52.459]                       else if (inherits(cond, "condition")) {
[11:01:52.459]                         if (!is.null(pattern)) {
[11:01:52.459]                           computeRestarts <- base::computeRestarts
[11:01:52.459]                           grepl <- base::grepl
[11:01:52.459]                           restarts <- computeRestarts(cond)
[11:01:52.459]                           for (restart in restarts) {
[11:01:52.459]                             name <- restart$name
[11:01:52.459]                             if (is.null(name)) 
[11:01:52.459]                               next
[11:01:52.459]                             if (!grepl(pattern, name)) 
[11:01:52.459]                               next
[11:01:52.459]                             invokeRestart(restart)
[11:01:52.459]                             muffled <- TRUE
[11:01:52.459]                             break
[11:01:52.459]                           }
[11:01:52.459]                         }
[11:01:52.459]                       }
[11:01:52.459]                       invisible(muffled)
[11:01:52.459]                     }
[11:01:52.459]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.459]                   }
[11:01:52.459]                 }
[11:01:52.459]             }
[11:01:52.459]         }))
[11:01:52.459]     }, error = function(ex) {
[11:01:52.459]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.459]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.459]                 ...future.rng), started = ...future.startTime, 
[11:01:52.459]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.459]             version = "1.8"), class = "FutureResult")
[11:01:52.459]     }, finally = {
[11:01:52.459]         if (!identical(...future.workdir, getwd())) 
[11:01:52.459]             setwd(...future.workdir)
[11:01:52.459]         {
[11:01:52.459]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.459]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.459]             }
[11:01:52.459]             base::options(...future.oldOptions)
[11:01:52.459]             if (.Platform$OS.type == "windows") {
[11:01:52.459]                 old_names <- names(...future.oldEnvVars)
[11:01:52.459]                 envs <- base::Sys.getenv()
[11:01:52.459]                 names <- names(envs)
[11:01:52.459]                 common <- intersect(names, old_names)
[11:01:52.459]                 added <- setdiff(names, old_names)
[11:01:52.459]                 removed <- setdiff(old_names, names)
[11:01:52.459]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.459]                   envs[common]]
[11:01:52.459]                 NAMES <- toupper(changed)
[11:01:52.459]                 args <- list()
[11:01:52.459]                 for (kk in seq_along(NAMES)) {
[11:01:52.459]                   name <- changed[[kk]]
[11:01:52.459]                   NAME <- NAMES[[kk]]
[11:01:52.459]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.459]                     next
[11:01:52.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.459]                 }
[11:01:52.459]                 NAMES <- toupper(added)
[11:01:52.459]                 for (kk in seq_along(NAMES)) {
[11:01:52.459]                   name <- added[[kk]]
[11:01:52.459]                   NAME <- NAMES[[kk]]
[11:01:52.459]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.459]                     next
[11:01:52.459]                   args[[name]] <- ""
[11:01:52.459]                 }
[11:01:52.459]                 NAMES <- toupper(removed)
[11:01:52.459]                 for (kk in seq_along(NAMES)) {
[11:01:52.459]                   name <- removed[[kk]]
[11:01:52.459]                   NAME <- NAMES[[kk]]
[11:01:52.459]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.459]                     next
[11:01:52.459]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.459]                 }
[11:01:52.459]                 if (length(args) > 0) 
[11:01:52.459]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.459]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.459]             }
[11:01:52.459]             else {
[11:01:52.459]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.459]             }
[11:01:52.459]             {
[11:01:52.459]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.459]                   0L) {
[11:01:52.459]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.459]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.459]                   base::options(opts)
[11:01:52.459]                 }
[11:01:52.459]                 {
[11:01:52.459]                   {
[11:01:52.459]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.459]                     NULL
[11:01:52.459]                   }
[11:01:52.459]                   options(future.plan = NULL)
[11:01:52.459]                   if (is.na(NA_character_)) 
[11:01:52.459]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.459]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.459]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.459]                     .init = FALSE)
[11:01:52.459]                 }
[11:01:52.459]             }
[11:01:52.459]         }
[11:01:52.459]     })
[11:01:52.459]     if (TRUE) {
[11:01:52.459]         base::sink(type = "output", split = FALSE)
[11:01:52.459]         if (TRUE) {
[11:01:52.459]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.459]         }
[11:01:52.459]         else {
[11:01:52.459]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.459]         }
[11:01:52.459]         base::close(...future.stdout)
[11:01:52.459]         ...future.stdout <- NULL
[11:01:52.459]     }
[11:01:52.459]     ...future.result$conditions <- ...future.conditions
[11:01:52.459]     ...future.result$finished <- base::Sys.time()
[11:01:52.459]     ...future.result
[11:01:52.459] }
[11:01:52.462] assign_globals() ...
[11:01:52.462] List of 1
[11:01:52.462]  $ ii: int 2
[11:01:52.462]  - attr(*, "where")=List of 1
[11:01:52.462]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.462]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.462]  - attr(*, "resolved")= logi TRUE
[11:01:52.462]  - attr(*, "total_size")= num 35
[11:01:52.462]  - attr(*, "already-done")= logi TRUE
[11:01:52.466] - copied ‘ii’ to environment
[11:01:52.467] assign_globals() ... done
[11:01:52.467] requestCore(): workers = 2
[11:01:52.469] MulticoreFuture started
[11:01:52.470] - Launch lazy future ... done
[11:01:52.470] run() for ‘MulticoreFuture’ ... done
[11:01:52.470] plan(): Setting new future strategy stack:
[11:01:52.470] List of future strategies:
[11:01:52.470] 1. sequential:
[11:01:52.470]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.470]    - tweaked: FALSE
[11:01:52.470]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.472] plan(): nbrOfWorkers() = 1
[11:01:52.472] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.472] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.473] plan(): Setting new future strategy stack:
[11:01:52.474] List of future strategies:
[11:01:52.474] 1. multicore:
[11:01:52.474]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.474]    - tweaked: FALSE
[11:01:52.474]    - call: plan(strategy)
[11:01:52.475] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.476] Searching for globals ... DONE
[11:01:52.476] Resolving globals: TRUE
[11:01:52.476] Resolving any globals that are futures ...
[11:01:52.476] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.476] Resolving any globals that are futures ... DONE
[11:01:52.477] plan(): nbrOfWorkers() = 2
[11:01:52.477] Resolving futures part of globals (recursively) ...
[11:01:52.478] resolve() on list ...
[11:01:52.478]  recursive: 99
[11:01:52.478]  length: 1
[11:01:52.479]  elements: ‘ii’
[11:01:52.479]  length: 0 (resolved future 1)
[11:01:52.479] resolve() on list ... DONE
[11:01:52.479] - globals: [1] ‘ii’
[11:01:52.479] Resolving futures part of globals (recursively) ... DONE
[11:01:52.480] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:52.480] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.480] - globals: [1] ‘ii’
[11:01:52.481] 
[11:01:52.481] getGlobalsAndPackages() ... DONE
[11:01:52.481] run() for ‘Future’ ...
[11:01:52.481] - state: ‘created’
[11:01:52.482] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.484] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.485] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.485]   - Field: ‘label’
[11:01:52.485]   - Field: ‘local’
[11:01:52.485]   - Field: ‘owner’
[11:01:52.485]   - Field: ‘envir’
[11:01:52.486]   - Field: ‘workers’
[11:01:52.486]   - Field: ‘packages’
[11:01:52.486]   - Field: ‘gc’
[11:01:52.486]   - Field: ‘job’
[11:01:52.486]   - Field: ‘conditions’
[11:01:52.486]   - Field: ‘expr’
[11:01:52.487]   - Field: ‘uuid’
[11:01:52.487]   - Field: ‘seed’
[11:01:52.487]   - Field: ‘version’
[11:01:52.487]   - Field: ‘result’
[11:01:52.487]   - Field: ‘asynchronous’
[11:01:52.487]   - Field: ‘calls’
[11:01:52.488]   - Field: ‘globals’
[11:01:52.488]   - Field: ‘stdout’
[11:01:52.488]   - Field: ‘earlySignal’
[11:01:52.488]   - Field: ‘lazy’
[11:01:52.488]   - Field: ‘state’
[11:01:52.489] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.489] - Launch lazy future ...
[11:01:52.489] Packages needed by the future expression (n = 0): <none>
[11:01:52.489] Packages needed by future strategies (n = 0): <none>
[11:01:52.490] {
[11:01:52.490]     {
[11:01:52.490]         {
[11:01:52.490]             ...future.startTime <- base::Sys.time()
[11:01:52.490]             {
[11:01:52.490]                 {
[11:01:52.490]                   {
[11:01:52.490]                     {
[11:01:52.490]                       base::local({
[11:01:52.490]                         has_future <- base::requireNamespace("future", 
[11:01:52.490]                           quietly = TRUE)
[11:01:52.490]                         if (has_future) {
[11:01:52.490]                           ns <- base::getNamespace("future")
[11:01:52.490]                           version <- ns[[".package"]][["version"]]
[11:01:52.490]                           if (is.null(version)) 
[11:01:52.490]                             version <- utils::packageVersion("future")
[11:01:52.490]                         }
[11:01:52.490]                         else {
[11:01:52.490]                           version <- NULL
[11:01:52.490]                         }
[11:01:52.490]                         if (!has_future || version < "1.8.0") {
[11:01:52.490]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.490]                             "", base::R.version$version.string), 
[11:01:52.490]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.490]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.490]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.490]                               "release", "version")], collapse = " "), 
[11:01:52.490]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.490]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.490]                             info)
[11:01:52.490]                           info <- base::paste(info, collapse = "; ")
[11:01:52.490]                           if (!has_future) {
[11:01:52.490]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.490]                               info)
[11:01:52.490]                           }
[11:01:52.490]                           else {
[11:01:52.490]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.490]                               info, version)
[11:01:52.490]                           }
[11:01:52.490]                           base::stop(msg)
[11:01:52.490]                         }
[11:01:52.490]                       })
[11:01:52.490]                     }
[11:01:52.490]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.490]                     base::options(mc.cores = 1L)
[11:01:52.490]                   }
[11:01:52.490]                   ...future.strategy.old <- future::plan("list")
[11:01:52.490]                   options(future.plan = NULL)
[11:01:52.490]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.490]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.490]                 }
[11:01:52.490]                 ...future.workdir <- getwd()
[11:01:52.490]             }
[11:01:52.490]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.490]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.490]         }
[11:01:52.490]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.490]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.490]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.490]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.490]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.490]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.490]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.490]             base::names(...future.oldOptions))
[11:01:52.490]     }
[11:01:52.490]     if (FALSE) {
[11:01:52.490]     }
[11:01:52.490]     else {
[11:01:52.490]         if (TRUE) {
[11:01:52.490]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.490]                 open = "w")
[11:01:52.490]         }
[11:01:52.490]         else {
[11:01:52.490]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.490]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.490]         }
[11:01:52.490]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.490]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.490]             base::sink(type = "output", split = FALSE)
[11:01:52.490]             base::close(...future.stdout)
[11:01:52.490]         }, add = TRUE)
[11:01:52.490]     }
[11:01:52.490]     ...future.frame <- base::sys.nframe()
[11:01:52.490]     ...future.conditions <- base::list()
[11:01:52.490]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.490]     if (FALSE) {
[11:01:52.490]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.490]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.490]     }
[11:01:52.490]     ...future.result <- base::tryCatch({
[11:01:52.490]         base::withCallingHandlers({
[11:01:52.490]             ...future.value <- base::withVisible(base::local({
[11:01:52.490]                 withCallingHandlers({
[11:01:52.490]                   {
[11:01:52.490]                     b <- a * ii
[11:01:52.490]                     a <- 0
[11:01:52.490]                     b
[11:01:52.490]                   }
[11:01:52.490]                 }, immediateCondition = function(cond) {
[11:01:52.490]                   save_rds <- function (object, pathname, ...) 
[11:01:52.490]                   {
[11:01:52.490]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.490]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.490]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.490]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.490]                         fi_tmp[["mtime"]])
[11:01:52.490]                     }
[11:01:52.490]                     tryCatch({
[11:01:52.490]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.490]                     }, error = function(ex) {
[11:01:52.490]                       msg <- conditionMessage(ex)
[11:01:52.490]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.490]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.490]                         fi_tmp[["mtime"]], msg)
[11:01:52.490]                       ex$message <- msg
[11:01:52.490]                       stop(ex)
[11:01:52.490]                     })
[11:01:52.490]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.490]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.490]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.490]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.490]                       fi <- file.info(pathname)
[11:01:52.490]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.490]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.490]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.490]                         fi[["size"]], fi[["mtime"]])
[11:01:52.490]                       stop(msg)
[11:01:52.490]                     }
[11:01:52.490]                     invisible(pathname)
[11:01:52.490]                   }
[11:01:52.490]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.490]                     rootPath = tempdir()) 
[11:01:52.490]                   {
[11:01:52.490]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.490]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.490]                       tmpdir = path, fileext = ".rds")
[11:01:52.490]                     save_rds(obj, file)
[11:01:52.490]                   }
[11:01:52.490]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.490]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.490]                   {
[11:01:52.490]                     inherits <- base::inherits
[11:01:52.490]                     invokeRestart <- base::invokeRestart
[11:01:52.490]                     is.null <- base::is.null
[11:01:52.490]                     muffled <- FALSE
[11:01:52.490]                     if (inherits(cond, "message")) {
[11:01:52.490]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.490]                       if (muffled) 
[11:01:52.490]                         invokeRestart("muffleMessage")
[11:01:52.490]                     }
[11:01:52.490]                     else if (inherits(cond, "warning")) {
[11:01:52.490]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.490]                       if (muffled) 
[11:01:52.490]                         invokeRestart("muffleWarning")
[11:01:52.490]                     }
[11:01:52.490]                     else if (inherits(cond, "condition")) {
[11:01:52.490]                       if (!is.null(pattern)) {
[11:01:52.490]                         computeRestarts <- base::computeRestarts
[11:01:52.490]                         grepl <- base::grepl
[11:01:52.490]                         restarts <- computeRestarts(cond)
[11:01:52.490]                         for (restart in restarts) {
[11:01:52.490]                           name <- restart$name
[11:01:52.490]                           if (is.null(name)) 
[11:01:52.490]                             next
[11:01:52.490]                           if (!grepl(pattern, name)) 
[11:01:52.490]                             next
[11:01:52.490]                           invokeRestart(restart)
[11:01:52.490]                           muffled <- TRUE
[11:01:52.490]                           break
[11:01:52.490]                         }
[11:01:52.490]                       }
[11:01:52.490]                     }
[11:01:52.490]                     invisible(muffled)
[11:01:52.490]                   }
[11:01:52.490]                   muffleCondition(cond)
[11:01:52.490]                 })
[11:01:52.490]             }))
[11:01:52.490]             future::FutureResult(value = ...future.value$value, 
[11:01:52.490]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.490]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.490]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.490]                     ...future.globalenv.names))
[11:01:52.490]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.490]         }, condition = base::local({
[11:01:52.490]             c <- base::c
[11:01:52.490]             inherits <- base::inherits
[11:01:52.490]             invokeRestart <- base::invokeRestart
[11:01:52.490]             length <- base::length
[11:01:52.490]             list <- base::list
[11:01:52.490]             seq.int <- base::seq.int
[11:01:52.490]             signalCondition <- base::signalCondition
[11:01:52.490]             sys.calls <- base::sys.calls
[11:01:52.490]             `[[` <- base::`[[`
[11:01:52.490]             `+` <- base::`+`
[11:01:52.490]             `<<-` <- base::`<<-`
[11:01:52.490]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.490]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.490]                   3L)]
[11:01:52.490]             }
[11:01:52.490]             function(cond) {
[11:01:52.490]                 is_error <- inherits(cond, "error")
[11:01:52.490]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.490]                   NULL)
[11:01:52.490]                 if (is_error) {
[11:01:52.490]                   sessionInformation <- function() {
[11:01:52.490]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.490]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.490]                       search = base::search(), system = base::Sys.info())
[11:01:52.490]                   }
[11:01:52.490]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.490]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.490]                     cond$call), session = sessionInformation(), 
[11:01:52.490]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.490]                   signalCondition(cond)
[11:01:52.490]                 }
[11:01:52.490]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.490]                 "immediateCondition"))) {
[11:01:52.490]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.490]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.490]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.490]                   if (TRUE && !signal) {
[11:01:52.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.490]                     {
[11:01:52.490]                       inherits <- base::inherits
[11:01:52.490]                       invokeRestart <- base::invokeRestart
[11:01:52.490]                       is.null <- base::is.null
[11:01:52.490]                       muffled <- FALSE
[11:01:52.490]                       if (inherits(cond, "message")) {
[11:01:52.490]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.490]                         if (muffled) 
[11:01:52.490]                           invokeRestart("muffleMessage")
[11:01:52.490]                       }
[11:01:52.490]                       else if (inherits(cond, "warning")) {
[11:01:52.490]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.490]                         if (muffled) 
[11:01:52.490]                           invokeRestart("muffleWarning")
[11:01:52.490]                       }
[11:01:52.490]                       else if (inherits(cond, "condition")) {
[11:01:52.490]                         if (!is.null(pattern)) {
[11:01:52.490]                           computeRestarts <- base::computeRestarts
[11:01:52.490]                           grepl <- base::grepl
[11:01:52.490]                           restarts <- computeRestarts(cond)
[11:01:52.490]                           for (restart in restarts) {
[11:01:52.490]                             name <- restart$name
[11:01:52.490]                             if (is.null(name)) 
[11:01:52.490]                               next
[11:01:52.490]                             if (!grepl(pattern, name)) 
[11:01:52.490]                               next
[11:01:52.490]                             invokeRestart(restart)
[11:01:52.490]                             muffled <- TRUE
[11:01:52.490]                             break
[11:01:52.490]                           }
[11:01:52.490]                         }
[11:01:52.490]                       }
[11:01:52.490]                       invisible(muffled)
[11:01:52.490]                     }
[11:01:52.490]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.490]                   }
[11:01:52.490]                 }
[11:01:52.490]                 else {
[11:01:52.490]                   if (TRUE) {
[11:01:52.490]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.490]                     {
[11:01:52.490]                       inherits <- base::inherits
[11:01:52.490]                       invokeRestart <- base::invokeRestart
[11:01:52.490]                       is.null <- base::is.null
[11:01:52.490]                       muffled <- FALSE
[11:01:52.490]                       if (inherits(cond, "message")) {
[11:01:52.490]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.490]                         if (muffled) 
[11:01:52.490]                           invokeRestart("muffleMessage")
[11:01:52.490]                       }
[11:01:52.490]                       else if (inherits(cond, "warning")) {
[11:01:52.490]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.490]                         if (muffled) 
[11:01:52.490]                           invokeRestart("muffleWarning")
[11:01:52.490]                       }
[11:01:52.490]                       else if (inherits(cond, "condition")) {
[11:01:52.490]                         if (!is.null(pattern)) {
[11:01:52.490]                           computeRestarts <- base::computeRestarts
[11:01:52.490]                           grepl <- base::grepl
[11:01:52.490]                           restarts <- computeRestarts(cond)
[11:01:52.490]                           for (restart in restarts) {
[11:01:52.490]                             name <- restart$name
[11:01:52.490]                             if (is.null(name)) 
[11:01:52.490]                               next
[11:01:52.490]                             if (!grepl(pattern, name)) 
[11:01:52.490]                               next
[11:01:52.490]                             invokeRestart(restart)
[11:01:52.490]                             muffled <- TRUE
[11:01:52.490]                             break
[11:01:52.490]                           }
[11:01:52.490]                         }
[11:01:52.490]                       }
[11:01:52.490]                       invisible(muffled)
[11:01:52.490]                     }
[11:01:52.490]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.490]                   }
[11:01:52.490]                 }
[11:01:52.490]             }
[11:01:52.490]         }))
[11:01:52.490]     }, error = function(ex) {
[11:01:52.490]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.490]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.490]                 ...future.rng), started = ...future.startTime, 
[11:01:52.490]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.490]             version = "1.8"), class = "FutureResult")
[11:01:52.490]     }, finally = {
[11:01:52.490]         if (!identical(...future.workdir, getwd())) 
[11:01:52.490]             setwd(...future.workdir)
[11:01:52.490]         {
[11:01:52.490]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.490]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.490]             }
[11:01:52.490]             base::options(...future.oldOptions)
[11:01:52.490]             if (.Platform$OS.type == "windows") {
[11:01:52.490]                 old_names <- names(...future.oldEnvVars)
[11:01:52.490]                 envs <- base::Sys.getenv()
[11:01:52.490]                 names <- names(envs)
[11:01:52.490]                 common <- intersect(names, old_names)
[11:01:52.490]                 added <- setdiff(names, old_names)
[11:01:52.490]                 removed <- setdiff(old_names, names)
[11:01:52.490]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.490]                   envs[common]]
[11:01:52.490]                 NAMES <- toupper(changed)
[11:01:52.490]                 args <- list()
[11:01:52.490]                 for (kk in seq_along(NAMES)) {
[11:01:52.490]                   name <- changed[[kk]]
[11:01:52.490]                   NAME <- NAMES[[kk]]
[11:01:52.490]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.490]                     next
[11:01:52.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.490]                 }
[11:01:52.490]                 NAMES <- toupper(added)
[11:01:52.490]                 for (kk in seq_along(NAMES)) {
[11:01:52.490]                   name <- added[[kk]]
[11:01:52.490]                   NAME <- NAMES[[kk]]
[11:01:52.490]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.490]                     next
[11:01:52.490]                   args[[name]] <- ""
[11:01:52.490]                 }
[11:01:52.490]                 NAMES <- toupper(removed)
[11:01:52.490]                 for (kk in seq_along(NAMES)) {
[11:01:52.490]                   name <- removed[[kk]]
[11:01:52.490]                   NAME <- NAMES[[kk]]
[11:01:52.490]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.490]                     next
[11:01:52.490]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.490]                 }
[11:01:52.490]                 if (length(args) > 0) 
[11:01:52.490]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.490]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.490]             }
[11:01:52.490]             else {
[11:01:52.490]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.490]             }
[11:01:52.490]             {
[11:01:52.490]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.490]                   0L) {
[11:01:52.490]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.490]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.490]                   base::options(opts)
[11:01:52.490]                 }
[11:01:52.490]                 {
[11:01:52.490]                   {
[11:01:52.490]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.490]                     NULL
[11:01:52.490]                   }
[11:01:52.490]                   options(future.plan = NULL)
[11:01:52.490]                   if (is.na(NA_character_)) 
[11:01:52.490]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.490]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.490]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.490]                     .init = FALSE)
[11:01:52.490]                 }
[11:01:52.490]             }
[11:01:52.490]         }
[11:01:52.490]     })
[11:01:52.490]     if (TRUE) {
[11:01:52.490]         base::sink(type = "output", split = FALSE)
[11:01:52.490]         if (TRUE) {
[11:01:52.490]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.490]         }
[11:01:52.490]         else {
[11:01:52.490]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.490]         }
[11:01:52.490]         base::close(...future.stdout)
[11:01:52.490]         ...future.stdout <- NULL
[11:01:52.490]     }
[11:01:52.490]     ...future.result$conditions <- ...future.conditions
[11:01:52.490]     ...future.result$finished <- base::Sys.time()
[11:01:52.490]     ...future.result
[11:01:52.490] }
[11:01:52.494] assign_globals() ...
[11:01:52.494] List of 1
[11:01:52.494]  $ ii: int 3
[11:01:52.494]  - attr(*, "where")=List of 1
[11:01:52.494]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.494]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.494]  - attr(*, "resolved")= logi TRUE
[11:01:52.494]  - attr(*, "total_size")= num 35
[11:01:52.494]  - attr(*, "already-done")= logi TRUE
[11:01:52.503] - copied ‘ii’ to environment
[11:01:52.503] assign_globals() ... done
[11:01:52.503] requestCore(): workers = 2
[11:01:52.504] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:52.516] result() for MulticoreFuture ...
[11:01:52.517] result() for MulticoreFuture ...
[11:01:52.517] result() for MulticoreFuture ... done
[11:01:52.517] result() for MulticoreFuture ... done
[11:01:52.517] result() for MulticoreFuture ...
[11:01:52.518] result() for MulticoreFuture ... done
[11:01:52.520] MulticoreFuture started
[11:01:52.521] - Launch lazy future ... done
[11:01:52.521] plan(): Setting new future strategy stack:
[11:01:52.521] run() for ‘MulticoreFuture’ ... done
[11:01:52.522] result() for MulticoreFuture ...
[11:01:52.522] List of future strategies:
[11:01:52.522] 1. sequential:
[11:01:52.522]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.522]    - tweaked: FALSE
[11:01:52.522]    - call: NULL
[11:01:52.523] result() for MulticoreFuture ... done
[11:01:52.523] result() for MulticoreFuture ...
[11:01:52.523] plan(): nbrOfWorkers() = 1
[11:01:52.523] result() for MulticoreFuture ... done
[11:01:52.523] result() for MulticoreFuture ...
[11:01:52.525] plan(): Setting new future strategy stack:
[11:01:52.525] result() for MulticoreFuture ...
[11:01:52.525] result() for MulticoreFuture ... done
[11:01:52.525] result() for MulticoreFuture ... done
[11:01:52.525] List of future strategies:
[11:01:52.525] 1. multicore:
[11:01:52.525]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.525]    - tweaked: FALSE
[11:01:52.525]    - call: plan(strategy)
[11:01:52.526] result() for MulticoreFuture ...
[11:01:52.526] result() for MulticoreFuture ... done
[11:01:52.526] result() for MulticoreFuture ...
[11:01:52.528] plan(): nbrOfWorkers() = 2
[11:01:52.529] result() for MulticoreFuture ...
[11:01:52.529] result() for MulticoreFuture ... done
[11:01:52.529] result() for MulticoreFuture ... done
[11:01:52.529] result() for MulticoreFuture ...
[11:01:52.529] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.530] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.530] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.532] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.533] Searching for globals ... DONE
[11:01:52.533] Resolving globals: TRUE
[11:01:52.533] Resolving any globals that are futures ...
[11:01:52.533] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.533] Resolving any globals that are futures ... DONE
[11:01:52.533] Resolving futures part of globals (recursively) ...
[11:01:52.534] resolve() on list ...
[11:01:52.534]  recursive: 99
[11:01:52.534]  length: 1
[11:01:52.534]  elements: ‘ii’
[11:01:52.534]  length: 0 (resolved future 1)
[11:01:52.535] resolve() on list ... DONE
[11:01:52.535] - globals: [1] ‘ii’
[11:01:52.535] Resolving futures part of globals (recursively) ... DONE
[11:01:52.535] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:52.536] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.536] - globals: [1] ‘ii’
[11:01:52.536] 
[11:01:52.536] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.537] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.537] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.539] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.539] Searching for globals ... DONE
[11:01:52.539] Resolving globals: TRUE
[11:01:52.539] Resolving any globals that are futures ...
[11:01:52.539] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.539] Resolving any globals that are futures ... DONE
[11:01:52.540] Resolving futures part of globals (recursively) ...
[11:01:52.540] resolve() on list ...
[11:01:52.540]  recursive: 99
[11:01:52.540]  length: 1
[11:01:52.540]  elements: ‘ii’
[11:01:52.540]  length: 0 (resolved future 1)
[11:01:52.541] resolve() on list ... DONE
[11:01:52.541] - globals: [1] ‘ii’
[11:01:52.541] Resolving futures part of globals (recursively) ... DONE
[11:01:52.541] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:52.541] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.541] - globals: [1] ‘ii’
[11:01:52.542] 
[11:01:52.542] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.542] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.543] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.544] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.544] Searching for globals ... DONE
[11:01:52.544] Resolving globals: TRUE
[11:01:52.544] Resolving any globals that are futures ...
[11:01:52.545] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:52.545] Resolving any globals that are futures ... DONE
[11:01:52.545] Resolving futures part of globals (recursively) ...
[11:01:52.545] resolve() on list ...
[11:01:52.546]  recursive: 99
[11:01:52.546]  length: 1
[11:01:52.546]  elements: ‘ii’
[11:01:52.546]  length: 0 (resolved future 1)
[11:01:52.546] resolve() on list ... DONE
[11:01:52.546] - globals: [1] ‘ii’
[11:01:52.546] Resolving futures part of globals (recursively) ... DONE
[11:01:52.546] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:52.547] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.547] - globals: [1] ‘ii’
[11:01:52.547] 
[11:01:52.547] getGlobalsAndPackages() ... DONE
[11:01:52.547] run() for ‘Future’ ...
[11:01:52.548] - state: ‘created’
[11:01:52.549] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.551] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.552] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.552]   - Field: ‘label’
[11:01:52.552]   - Field: ‘local’
[11:01:52.552]   - Field: ‘owner’
[11:01:52.552]   - Field: ‘envir’
[11:01:52.552]   - Field: ‘workers’
[11:01:52.552]   - Field: ‘packages’
[11:01:52.552]   - Field: ‘gc’
[11:01:52.553]   - Field: ‘job’
[11:01:52.553]   - Field: ‘conditions’
[11:01:52.553]   - Field: ‘expr’
[11:01:52.553]   - Field: ‘uuid’
[11:01:52.553]   - Field: ‘seed’
[11:01:52.553]   - Field: ‘version’
[11:01:52.553]   - Field: ‘result’
[11:01:52.553]   - Field: ‘asynchronous’
[11:01:52.554]   - Field: ‘calls’
[11:01:52.554]   - Field: ‘globals’
[11:01:52.554]   - Field: ‘stdout’
[11:01:52.554]   - Field: ‘earlySignal’
[11:01:52.554]   - Field: ‘lazy’
[11:01:52.554]   - Field: ‘state’
[11:01:52.554] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.554] - Launch lazy future ...
[11:01:52.554] Packages needed by the future expression (n = 0): <none>
[11:01:52.555] Packages needed by future strategies (n = 0): <none>
[11:01:52.555] {
[11:01:52.555]     {
[11:01:52.555]         {
[11:01:52.555]             ...future.startTime <- base::Sys.time()
[11:01:52.555]             {
[11:01:52.555]                 {
[11:01:52.555]                   {
[11:01:52.555]                     {
[11:01:52.555]                       base::local({
[11:01:52.555]                         has_future <- base::requireNamespace("future", 
[11:01:52.555]                           quietly = TRUE)
[11:01:52.555]                         if (has_future) {
[11:01:52.555]                           ns <- base::getNamespace("future")
[11:01:52.555]                           version <- ns[[".package"]][["version"]]
[11:01:52.555]                           if (is.null(version)) 
[11:01:52.555]                             version <- utils::packageVersion("future")
[11:01:52.555]                         }
[11:01:52.555]                         else {
[11:01:52.555]                           version <- NULL
[11:01:52.555]                         }
[11:01:52.555]                         if (!has_future || version < "1.8.0") {
[11:01:52.555]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.555]                             "", base::R.version$version.string), 
[11:01:52.555]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.555]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.555]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.555]                               "release", "version")], collapse = " "), 
[11:01:52.555]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.555]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.555]                             info)
[11:01:52.555]                           info <- base::paste(info, collapse = "; ")
[11:01:52.555]                           if (!has_future) {
[11:01:52.555]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.555]                               info)
[11:01:52.555]                           }
[11:01:52.555]                           else {
[11:01:52.555]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.555]                               info, version)
[11:01:52.555]                           }
[11:01:52.555]                           base::stop(msg)
[11:01:52.555]                         }
[11:01:52.555]                       })
[11:01:52.555]                     }
[11:01:52.555]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.555]                     base::options(mc.cores = 1L)
[11:01:52.555]                   }
[11:01:52.555]                   ...future.strategy.old <- future::plan("list")
[11:01:52.555]                   options(future.plan = NULL)
[11:01:52.555]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.555]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.555]                 }
[11:01:52.555]                 ...future.workdir <- getwd()
[11:01:52.555]             }
[11:01:52.555]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.555]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.555]         }
[11:01:52.555]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.555]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.555]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.555]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.555]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.555]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.555]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.555]             base::names(...future.oldOptions))
[11:01:52.555]     }
[11:01:52.555]     if (FALSE) {
[11:01:52.555]     }
[11:01:52.555]     else {
[11:01:52.555]         if (TRUE) {
[11:01:52.555]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.555]                 open = "w")
[11:01:52.555]         }
[11:01:52.555]         else {
[11:01:52.555]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.555]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.555]         }
[11:01:52.555]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.555]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.555]             base::sink(type = "output", split = FALSE)
[11:01:52.555]             base::close(...future.stdout)
[11:01:52.555]         }, add = TRUE)
[11:01:52.555]     }
[11:01:52.555]     ...future.frame <- base::sys.nframe()
[11:01:52.555]     ...future.conditions <- base::list()
[11:01:52.555]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.555]     if (FALSE) {
[11:01:52.555]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.555]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.555]     }
[11:01:52.555]     ...future.result <- base::tryCatch({
[11:01:52.555]         base::withCallingHandlers({
[11:01:52.555]             ...future.value <- base::withVisible(base::local({
[11:01:52.555]                 withCallingHandlers({
[11:01:52.555]                   {
[11:01:52.555]                     b <- a * ii
[11:01:52.555]                     a <- 0
[11:01:52.555]                     b
[11:01:52.555]                   }
[11:01:52.555]                 }, immediateCondition = function(cond) {
[11:01:52.555]                   save_rds <- function (object, pathname, ...) 
[11:01:52.555]                   {
[11:01:52.555]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.555]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.555]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.555]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.555]                         fi_tmp[["mtime"]])
[11:01:52.555]                     }
[11:01:52.555]                     tryCatch({
[11:01:52.555]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.555]                     }, error = function(ex) {
[11:01:52.555]                       msg <- conditionMessage(ex)
[11:01:52.555]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.555]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.555]                         fi_tmp[["mtime"]], msg)
[11:01:52.555]                       ex$message <- msg
[11:01:52.555]                       stop(ex)
[11:01:52.555]                     })
[11:01:52.555]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.555]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.555]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.555]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.555]                       fi <- file.info(pathname)
[11:01:52.555]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.555]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.555]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.555]                         fi[["size"]], fi[["mtime"]])
[11:01:52.555]                       stop(msg)
[11:01:52.555]                     }
[11:01:52.555]                     invisible(pathname)
[11:01:52.555]                   }
[11:01:52.555]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.555]                     rootPath = tempdir()) 
[11:01:52.555]                   {
[11:01:52.555]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.555]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.555]                       tmpdir = path, fileext = ".rds")
[11:01:52.555]                     save_rds(obj, file)
[11:01:52.555]                   }
[11:01:52.555]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.555]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.555]                   {
[11:01:52.555]                     inherits <- base::inherits
[11:01:52.555]                     invokeRestart <- base::invokeRestart
[11:01:52.555]                     is.null <- base::is.null
[11:01:52.555]                     muffled <- FALSE
[11:01:52.555]                     if (inherits(cond, "message")) {
[11:01:52.555]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.555]                       if (muffled) 
[11:01:52.555]                         invokeRestart("muffleMessage")
[11:01:52.555]                     }
[11:01:52.555]                     else if (inherits(cond, "warning")) {
[11:01:52.555]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.555]                       if (muffled) 
[11:01:52.555]                         invokeRestart("muffleWarning")
[11:01:52.555]                     }
[11:01:52.555]                     else if (inherits(cond, "condition")) {
[11:01:52.555]                       if (!is.null(pattern)) {
[11:01:52.555]                         computeRestarts <- base::computeRestarts
[11:01:52.555]                         grepl <- base::grepl
[11:01:52.555]                         restarts <- computeRestarts(cond)
[11:01:52.555]                         for (restart in restarts) {
[11:01:52.555]                           name <- restart$name
[11:01:52.555]                           if (is.null(name)) 
[11:01:52.555]                             next
[11:01:52.555]                           if (!grepl(pattern, name)) 
[11:01:52.555]                             next
[11:01:52.555]                           invokeRestart(restart)
[11:01:52.555]                           muffled <- TRUE
[11:01:52.555]                           break
[11:01:52.555]                         }
[11:01:52.555]                       }
[11:01:52.555]                     }
[11:01:52.555]                     invisible(muffled)
[11:01:52.555]                   }
[11:01:52.555]                   muffleCondition(cond)
[11:01:52.555]                 })
[11:01:52.555]             }))
[11:01:52.555]             future::FutureResult(value = ...future.value$value, 
[11:01:52.555]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.555]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.555]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.555]                     ...future.globalenv.names))
[11:01:52.555]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.555]         }, condition = base::local({
[11:01:52.555]             c <- base::c
[11:01:52.555]             inherits <- base::inherits
[11:01:52.555]             invokeRestart <- base::invokeRestart
[11:01:52.555]             length <- base::length
[11:01:52.555]             list <- base::list
[11:01:52.555]             seq.int <- base::seq.int
[11:01:52.555]             signalCondition <- base::signalCondition
[11:01:52.555]             sys.calls <- base::sys.calls
[11:01:52.555]             `[[` <- base::`[[`
[11:01:52.555]             `+` <- base::`+`
[11:01:52.555]             `<<-` <- base::`<<-`
[11:01:52.555]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.555]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.555]                   3L)]
[11:01:52.555]             }
[11:01:52.555]             function(cond) {
[11:01:52.555]                 is_error <- inherits(cond, "error")
[11:01:52.555]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.555]                   NULL)
[11:01:52.555]                 if (is_error) {
[11:01:52.555]                   sessionInformation <- function() {
[11:01:52.555]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.555]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.555]                       search = base::search(), system = base::Sys.info())
[11:01:52.555]                   }
[11:01:52.555]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.555]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.555]                     cond$call), session = sessionInformation(), 
[11:01:52.555]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.555]                   signalCondition(cond)
[11:01:52.555]                 }
[11:01:52.555]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.555]                 "immediateCondition"))) {
[11:01:52.555]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.555]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.555]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.555]                   if (TRUE && !signal) {
[11:01:52.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.555]                     {
[11:01:52.555]                       inherits <- base::inherits
[11:01:52.555]                       invokeRestart <- base::invokeRestart
[11:01:52.555]                       is.null <- base::is.null
[11:01:52.555]                       muffled <- FALSE
[11:01:52.555]                       if (inherits(cond, "message")) {
[11:01:52.555]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.555]                         if (muffled) 
[11:01:52.555]                           invokeRestart("muffleMessage")
[11:01:52.555]                       }
[11:01:52.555]                       else if (inherits(cond, "warning")) {
[11:01:52.555]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.555]                         if (muffled) 
[11:01:52.555]                           invokeRestart("muffleWarning")
[11:01:52.555]                       }
[11:01:52.555]                       else if (inherits(cond, "condition")) {
[11:01:52.555]                         if (!is.null(pattern)) {
[11:01:52.555]                           computeRestarts <- base::computeRestarts
[11:01:52.555]                           grepl <- base::grepl
[11:01:52.555]                           restarts <- computeRestarts(cond)
[11:01:52.555]                           for (restart in restarts) {
[11:01:52.555]                             name <- restart$name
[11:01:52.555]                             if (is.null(name)) 
[11:01:52.555]                               next
[11:01:52.555]                             if (!grepl(pattern, name)) 
[11:01:52.555]                               next
[11:01:52.555]                             invokeRestart(restart)
[11:01:52.555]                             muffled <- TRUE
[11:01:52.555]                             break
[11:01:52.555]                           }
[11:01:52.555]                         }
[11:01:52.555]                       }
[11:01:52.555]                       invisible(muffled)
[11:01:52.555]                     }
[11:01:52.555]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.555]                   }
[11:01:52.555]                 }
[11:01:52.555]                 else {
[11:01:52.555]                   if (TRUE) {
[11:01:52.555]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.555]                     {
[11:01:52.555]                       inherits <- base::inherits
[11:01:52.555]                       invokeRestart <- base::invokeRestart
[11:01:52.555]                       is.null <- base::is.null
[11:01:52.555]                       muffled <- FALSE
[11:01:52.555]                       if (inherits(cond, "message")) {
[11:01:52.555]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.555]                         if (muffled) 
[11:01:52.555]                           invokeRestart("muffleMessage")
[11:01:52.555]                       }
[11:01:52.555]                       else if (inherits(cond, "warning")) {
[11:01:52.555]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.555]                         if (muffled) 
[11:01:52.555]                           invokeRestart("muffleWarning")
[11:01:52.555]                       }
[11:01:52.555]                       else if (inherits(cond, "condition")) {
[11:01:52.555]                         if (!is.null(pattern)) {
[11:01:52.555]                           computeRestarts <- base::computeRestarts
[11:01:52.555]                           grepl <- base::grepl
[11:01:52.555]                           restarts <- computeRestarts(cond)
[11:01:52.555]                           for (restart in restarts) {
[11:01:52.555]                             name <- restart$name
[11:01:52.555]                             if (is.null(name)) 
[11:01:52.555]                               next
[11:01:52.555]                             if (!grepl(pattern, name)) 
[11:01:52.555]                               next
[11:01:52.555]                             invokeRestart(restart)
[11:01:52.555]                             muffled <- TRUE
[11:01:52.555]                             break
[11:01:52.555]                           }
[11:01:52.555]                         }
[11:01:52.555]                       }
[11:01:52.555]                       invisible(muffled)
[11:01:52.555]                     }
[11:01:52.555]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.555]                   }
[11:01:52.555]                 }
[11:01:52.555]             }
[11:01:52.555]         }))
[11:01:52.555]     }, error = function(ex) {
[11:01:52.555]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.555]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.555]                 ...future.rng), started = ...future.startTime, 
[11:01:52.555]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.555]             version = "1.8"), class = "FutureResult")
[11:01:52.555]     }, finally = {
[11:01:52.555]         if (!identical(...future.workdir, getwd())) 
[11:01:52.555]             setwd(...future.workdir)
[11:01:52.555]         {
[11:01:52.555]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.555]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.555]             }
[11:01:52.555]             base::options(...future.oldOptions)
[11:01:52.555]             if (.Platform$OS.type == "windows") {
[11:01:52.555]                 old_names <- names(...future.oldEnvVars)
[11:01:52.555]                 envs <- base::Sys.getenv()
[11:01:52.555]                 names <- names(envs)
[11:01:52.555]                 common <- intersect(names, old_names)
[11:01:52.555]                 added <- setdiff(names, old_names)
[11:01:52.555]                 removed <- setdiff(old_names, names)
[11:01:52.555]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.555]                   envs[common]]
[11:01:52.555]                 NAMES <- toupper(changed)
[11:01:52.555]                 args <- list()
[11:01:52.555]                 for (kk in seq_along(NAMES)) {
[11:01:52.555]                   name <- changed[[kk]]
[11:01:52.555]                   NAME <- NAMES[[kk]]
[11:01:52.555]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.555]                     next
[11:01:52.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.555]                 }
[11:01:52.555]                 NAMES <- toupper(added)
[11:01:52.555]                 for (kk in seq_along(NAMES)) {
[11:01:52.555]                   name <- added[[kk]]
[11:01:52.555]                   NAME <- NAMES[[kk]]
[11:01:52.555]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.555]                     next
[11:01:52.555]                   args[[name]] <- ""
[11:01:52.555]                 }
[11:01:52.555]                 NAMES <- toupper(removed)
[11:01:52.555]                 for (kk in seq_along(NAMES)) {
[11:01:52.555]                   name <- removed[[kk]]
[11:01:52.555]                   NAME <- NAMES[[kk]]
[11:01:52.555]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.555]                     next
[11:01:52.555]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.555]                 }
[11:01:52.555]                 if (length(args) > 0) 
[11:01:52.555]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.555]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.555]             }
[11:01:52.555]             else {
[11:01:52.555]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.555]             }
[11:01:52.555]             {
[11:01:52.555]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.555]                   0L) {
[11:01:52.555]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.555]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.555]                   base::options(opts)
[11:01:52.555]                 }
[11:01:52.555]                 {
[11:01:52.555]                   {
[11:01:52.555]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.555]                     NULL
[11:01:52.555]                   }
[11:01:52.555]                   options(future.plan = NULL)
[11:01:52.555]                   if (is.na(NA_character_)) 
[11:01:52.555]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.555]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.555]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.555]                     .init = FALSE)
[11:01:52.555]                 }
[11:01:52.555]             }
[11:01:52.555]         }
[11:01:52.555]     })
[11:01:52.555]     if (TRUE) {
[11:01:52.555]         base::sink(type = "output", split = FALSE)
[11:01:52.555]         if (TRUE) {
[11:01:52.555]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.555]         }
[11:01:52.555]         else {
[11:01:52.555]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.555]         }
[11:01:52.555]         base::close(...future.stdout)
[11:01:52.555]         ...future.stdout <- NULL
[11:01:52.555]     }
[11:01:52.555]     ...future.result$conditions <- ...future.conditions
[11:01:52.555]     ...future.result$finished <- base::Sys.time()
[11:01:52.555]     ...future.result
[11:01:52.555] }
[11:01:52.557] assign_globals() ...
[11:01:52.558] List of 1
[11:01:52.558]  $ ii: int 1
[11:01:52.558]  - attr(*, "where")=List of 1
[11:01:52.558]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.558]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.558]  - attr(*, "resolved")= logi TRUE
[11:01:52.558]  - attr(*, "total_size")= num 35
[11:01:52.558]  - attr(*, "already-done")= logi TRUE
[11:01:52.560] - copied ‘ii’ to environment
[11:01:52.560] assign_globals() ... done
[11:01:52.560] requestCore(): workers = 2
[11:01:52.562] MulticoreFuture started
[11:01:52.562] - Launch lazy future ... done
[11:01:52.563] run() for ‘MulticoreFuture’ ... done
[11:01:52.563] result() for MulticoreFuture ...
[11:01:52.563] plan(): Setting new future strategy stack:
[11:01:52.563] List of future strategies:
[11:01:52.563] 1. sequential:
[11:01:52.563]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.563]    - tweaked: FALSE
[11:01:52.563]    - call: NULL
[11:01:52.564] plan(): nbrOfWorkers() = 1
[11:01:52.566] plan(): Setting new future strategy stack:
[11:01:52.566] List of future strategies:
[11:01:52.566] 1. multicore:
[11:01:52.566]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.566]    - tweaked: FALSE
[11:01:52.566]    - call: plan(strategy)
[11:01:52.569] plan(): nbrOfWorkers() = 2
[11:01:52.575] result() for MulticoreFuture ...
[11:01:52.575] result() for MulticoreFuture ... done
[11:01:52.575] signalConditions() ...
[11:01:52.575]  - include = ‘immediateCondition’
[11:01:52.576]  - exclude = 
[11:01:52.576]  - resignal = FALSE
[11:01:52.576]  - Number of conditions: 1
[11:01:52.576] signalConditions() ... done
[11:01:52.576] result() for MulticoreFuture ... done
[11:01:52.576] result() for MulticoreFuture ...
[11:01:52.576] result() for MulticoreFuture ... done
[11:01:52.576] signalConditions() ...
[11:01:52.576]  - include = ‘immediateCondition’
[11:01:52.577]  - exclude = 
[11:01:52.577]  - resignal = FALSE
[11:01:52.577]  - Number of conditions: 1
[11:01:52.577] signalConditions() ... done
[11:01:52.577] Future state: ‘finished’
[11:01:52.577] result() for MulticoreFuture ...
[11:01:52.577] result() for MulticoreFuture ... done
[11:01:52.577] signalConditions() ...
[11:01:52.578]  - include = ‘condition’
[11:01:52.578]  - exclude = ‘immediateCondition’
[11:01:52.578]  - resignal = TRUE
[11:01:52.578]  - Number of conditions: 1
[11:01:52.578]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:52.578] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     withCallingHandlers({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 45
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language local({     value <- value(future) ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language eval(quote({     value <- value(future) ...
  .. .. .. ..$ : language value(future)
  .. .. .. ..$ : language value.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.Future(future)
  .. .. .. ..$ : language run(future)
  .. .. .. ..$ : language run.MulticoreFuture(future)
  .. .. .. ..$ : language do.call(parallel::mcparallel, args = future.args, envir = envir)
  .. .. .. ..$ : language (function (expr, name, mc.set.seed = TRUE, silent = FALSE, mc.affinity = NULL,      mc.interactive = FALSE, detached = FALSE)  ...
  .. .. .. ..$ : language sendMaster(try(eval(expr, env), silent = TRUE), FALSE)
  .. .. .. ..$ : language serialize(what, NULL, xdr = FALSE)
  .. .. .. ..$ : language try(eval(expr, env), silent = TRUE)
  .. .. .. ..$ : language tryCatch(expr, error = function(e) {     call <- conditionCall(e) ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language eval(expr, env)
  .. .. .. ..$ : language base::tryCatch({     base::withCallingHandlers({ ...
  .. .. .. ..$ : language tryCatchList(expr, classes, parentenv, handlers)
  .. .. .. ..$ : language tryCatchOne(expr, names, parentenv, handlers[[1L]])
  .. .. .. ..$ : language doTryCatch(return(expr), name, parentenv, handler)
  .. .. .. ..$ : language base::withCallingHandlers({     ...future.value <- base::withVisible(base::local({ ...
  .. .. .. ..$ : language base::withVisible(base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language base::local({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval.parent(substitute(eval(quote(expr), envir)))
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(expr, p)
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     withCallingHandlers({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:11] ".GlobalEnv" "package:listenv" "package:future" "package:stats" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:52"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.606] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.606] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.607] 
[11:01:52.607] Searching for globals ... DONE
[11:01:52.608] - globals: [0] <none>
[11:01:52.608] getGlobalsAndPackages() ... DONE
[11:01:52.608] run() for ‘Future’ ...
[11:01:52.608] - state: ‘created’
[11:01:52.608] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.610] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.610] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.610]   - Field: ‘label’
[11:01:52.610]   - Field: ‘local’
[11:01:52.610]   - Field: ‘owner’
[11:01:52.610]   - Field: ‘envir’
[11:01:52.610]   - Field: ‘workers’
[11:01:52.610]   - Field: ‘packages’
[11:01:52.611]   - Field: ‘gc’
[11:01:52.611]   - Field: ‘job’
[11:01:52.611]   - Field: ‘conditions’
[11:01:52.611]   - Field: ‘expr’
[11:01:52.611]   - Field: ‘uuid’
[11:01:52.611]   - Field: ‘seed’
[11:01:52.611]   - Field: ‘version’
[11:01:52.611]   - Field: ‘result’
[11:01:52.611]   - Field: ‘asynchronous’
[11:01:52.611]   - Field: ‘calls’
[11:01:52.611]   - Field: ‘globals’
[11:01:52.611]   - Field: ‘stdout’
[11:01:52.611]   - Field: ‘earlySignal’
[11:01:52.612]   - Field: ‘lazy’
[11:01:52.612]   - Field: ‘state’
[11:01:52.612] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.612] - Launch lazy future ...
[11:01:52.612] Packages needed by the future expression (n = 0): <none>
[11:01:52.612] Packages needed by future strategies (n = 0): <none>
[11:01:52.613] {
[11:01:52.613]     {
[11:01:52.613]         {
[11:01:52.613]             ...future.startTime <- base::Sys.time()
[11:01:52.613]             {
[11:01:52.613]                 {
[11:01:52.613]                   {
[11:01:52.613]                     {
[11:01:52.613]                       base::local({
[11:01:52.613]                         has_future <- base::requireNamespace("future", 
[11:01:52.613]                           quietly = TRUE)
[11:01:52.613]                         if (has_future) {
[11:01:52.613]                           ns <- base::getNamespace("future")
[11:01:52.613]                           version <- ns[[".package"]][["version"]]
[11:01:52.613]                           if (is.null(version)) 
[11:01:52.613]                             version <- utils::packageVersion("future")
[11:01:52.613]                         }
[11:01:52.613]                         else {
[11:01:52.613]                           version <- NULL
[11:01:52.613]                         }
[11:01:52.613]                         if (!has_future || version < "1.8.0") {
[11:01:52.613]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.613]                             "", base::R.version$version.string), 
[11:01:52.613]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.613]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.613]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.613]                               "release", "version")], collapse = " "), 
[11:01:52.613]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.613]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.613]                             info)
[11:01:52.613]                           info <- base::paste(info, collapse = "; ")
[11:01:52.613]                           if (!has_future) {
[11:01:52.613]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.613]                               info)
[11:01:52.613]                           }
[11:01:52.613]                           else {
[11:01:52.613]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.613]                               info, version)
[11:01:52.613]                           }
[11:01:52.613]                           base::stop(msg)
[11:01:52.613]                         }
[11:01:52.613]                       })
[11:01:52.613]                     }
[11:01:52.613]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.613]                     base::options(mc.cores = 1L)
[11:01:52.613]                   }
[11:01:52.613]                   ...future.strategy.old <- future::plan("list")
[11:01:52.613]                   options(future.plan = NULL)
[11:01:52.613]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.613]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.613]                 }
[11:01:52.613]                 ...future.workdir <- getwd()
[11:01:52.613]             }
[11:01:52.613]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.613]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.613]         }
[11:01:52.613]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.613]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.613]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.613]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.613]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.613]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.613]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.613]             base::names(...future.oldOptions))
[11:01:52.613]     }
[11:01:52.613]     if (FALSE) {
[11:01:52.613]     }
[11:01:52.613]     else {
[11:01:52.613]         if (TRUE) {
[11:01:52.613]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.613]                 open = "w")
[11:01:52.613]         }
[11:01:52.613]         else {
[11:01:52.613]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.613]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.613]         }
[11:01:52.613]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.613]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.613]             base::sink(type = "output", split = FALSE)
[11:01:52.613]             base::close(...future.stdout)
[11:01:52.613]         }, add = TRUE)
[11:01:52.613]     }
[11:01:52.613]     ...future.frame <- base::sys.nframe()
[11:01:52.613]     ...future.conditions <- base::list()
[11:01:52.613]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.613]     if (FALSE) {
[11:01:52.613]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.613]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.613]     }
[11:01:52.613]     ...future.result <- base::tryCatch({
[11:01:52.613]         base::withCallingHandlers({
[11:01:52.613]             ...future.value <- base::withVisible(base::local({
[11:01:52.613]                 withCallingHandlers({
[11:01:52.613]                   1
[11:01:52.613]                 }, immediateCondition = function(cond) {
[11:01:52.613]                   save_rds <- function (object, pathname, ...) 
[11:01:52.613]                   {
[11:01:52.613]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.613]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.613]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.613]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.613]                         fi_tmp[["mtime"]])
[11:01:52.613]                     }
[11:01:52.613]                     tryCatch({
[11:01:52.613]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.613]                     }, error = function(ex) {
[11:01:52.613]                       msg <- conditionMessage(ex)
[11:01:52.613]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.613]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.613]                         fi_tmp[["mtime"]], msg)
[11:01:52.613]                       ex$message <- msg
[11:01:52.613]                       stop(ex)
[11:01:52.613]                     })
[11:01:52.613]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.613]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.613]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.613]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.613]                       fi <- file.info(pathname)
[11:01:52.613]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.613]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.613]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.613]                         fi[["size"]], fi[["mtime"]])
[11:01:52.613]                       stop(msg)
[11:01:52.613]                     }
[11:01:52.613]                     invisible(pathname)
[11:01:52.613]                   }
[11:01:52.613]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.613]                     rootPath = tempdir()) 
[11:01:52.613]                   {
[11:01:52.613]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.613]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.613]                       tmpdir = path, fileext = ".rds")
[11:01:52.613]                     save_rds(obj, file)
[11:01:52.613]                   }
[11:01:52.613]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.613]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.613]                   {
[11:01:52.613]                     inherits <- base::inherits
[11:01:52.613]                     invokeRestart <- base::invokeRestart
[11:01:52.613]                     is.null <- base::is.null
[11:01:52.613]                     muffled <- FALSE
[11:01:52.613]                     if (inherits(cond, "message")) {
[11:01:52.613]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.613]                       if (muffled) 
[11:01:52.613]                         invokeRestart("muffleMessage")
[11:01:52.613]                     }
[11:01:52.613]                     else if (inherits(cond, "warning")) {
[11:01:52.613]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.613]                       if (muffled) 
[11:01:52.613]                         invokeRestart("muffleWarning")
[11:01:52.613]                     }
[11:01:52.613]                     else if (inherits(cond, "condition")) {
[11:01:52.613]                       if (!is.null(pattern)) {
[11:01:52.613]                         computeRestarts <- base::computeRestarts
[11:01:52.613]                         grepl <- base::grepl
[11:01:52.613]                         restarts <- computeRestarts(cond)
[11:01:52.613]                         for (restart in restarts) {
[11:01:52.613]                           name <- restart$name
[11:01:52.613]                           if (is.null(name)) 
[11:01:52.613]                             next
[11:01:52.613]                           if (!grepl(pattern, name)) 
[11:01:52.613]                             next
[11:01:52.613]                           invokeRestart(restart)
[11:01:52.613]                           muffled <- TRUE
[11:01:52.613]                           break
[11:01:52.613]                         }
[11:01:52.613]                       }
[11:01:52.613]                     }
[11:01:52.613]                     invisible(muffled)
[11:01:52.613]                   }
[11:01:52.613]                   muffleCondition(cond)
[11:01:52.613]                 })
[11:01:52.613]             }))
[11:01:52.613]             future::FutureResult(value = ...future.value$value, 
[11:01:52.613]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.613]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.613]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.613]                     ...future.globalenv.names))
[11:01:52.613]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.613]         }, condition = base::local({
[11:01:52.613]             c <- base::c
[11:01:52.613]             inherits <- base::inherits
[11:01:52.613]             invokeRestart <- base::invokeRestart
[11:01:52.613]             length <- base::length
[11:01:52.613]             list <- base::list
[11:01:52.613]             seq.int <- base::seq.int
[11:01:52.613]             signalCondition <- base::signalCondition
[11:01:52.613]             sys.calls <- base::sys.calls
[11:01:52.613]             `[[` <- base::`[[`
[11:01:52.613]             `+` <- base::`+`
[11:01:52.613]             `<<-` <- base::`<<-`
[11:01:52.613]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.613]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.613]                   3L)]
[11:01:52.613]             }
[11:01:52.613]             function(cond) {
[11:01:52.613]                 is_error <- inherits(cond, "error")
[11:01:52.613]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.613]                   NULL)
[11:01:52.613]                 if (is_error) {
[11:01:52.613]                   sessionInformation <- function() {
[11:01:52.613]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.613]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.613]                       search = base::search(), system = base::Sys.info())
[11:01:52.613]                   }
[11:01:52.613]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.613]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.613]                     cond$call), session = sessionInformation(), 
[11:01:52.613]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.613]                   signalCondition(cond)
[11:01:52.613]                 }
[11:01:52.613]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.613]                 "immediateCondition"))) {
[11:01:52.613]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.613]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.613]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.613]                   if (TRUE && !signal) {
[11:01:52.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.613]                     {
[11:01:52.613]                       inherits <- base::inherits
[11:01:52.613]                       invokeRestart <- base::invokeRestart
[11:01:52.613]                       is.null <- base::is.null
[11:01:52.613]                       muffled <- FALSE
[11:01:52.613]                       if (inherits(cond, "message")) {
[11:01:52.613]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.613]                         if (muffled) 
[11:01:52.613]                           invokeRestart("muffleMessage")
[11:01:52.613]                       }
[11:01:52.613]                       else if (inherits(cond, "warning")) {
[11:01:52.613]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.613]                         if (muffled) 
[11:01:52.613]                           invokeRestart("muffleWarning")
[11:01:52.613]                       }
[11:01:52.613]                       else if (inherits(cond, "condition")) {
[11:01:52.613]                         if (!is.null(pattern)) {
[11:01:52.613]                           computeRestarts <- base::computeRestarts
[11:01:52.613]                           grepl <- base::grepl
[11:01:52.613]                           restarts <- computeRestarts(cond)
[11:01:52.613]                           for (restart in restarts) {
[11:01:52.613]                             name <- restart$name
[11:01:52.613]                             if (is.null(name)) 
[11:01:52.613]                               next
[11:01:52.613]                             if (!grepl(pattern, name)) 
[11:01:52.613]                               next
[11:01:52.613]                             invokeRestart(restart)
[11:01:52.613]                             muffled <- TRUE
[11:01:52.613]                             break
[11:01:52.613]                           }
[11:01:52.613]                         }
[11:01:52.613]                       }
[11:01:52.613]                       invisible(muffled)
[11:01:52.613]                     }
[11:01:52.613]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.613]                   }
[11:01:52.613]                 }
[11:01:52.613]                 else {
[11:01:52.613]                   if (TRUE) {
[11:01:52.613]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.613]                     {
[11:01:52.613]                       inherits <- base::inherits
[11:01:52.613]                       invokeRestart <- base::invokeRestart
[11:01:52.613]                       is.null <- base::is.null
[11:01:52.613]                       muffled <- FALSE
[11:01:52.613]                       if (inherits(cond, "message")) {
[11:01:52.613]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.613]                         if (muffled) 
[11:01:52.613]                           invokeRestart("muffleMessage")
[11:01:52.613]                       }
[11:01:52.613]                       else if (inherits(cond, "warning")) {
[11:01:52.613]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.613]                         if (muffled) 
[11:01:52.613]                           invokeRestart("muffleWarning")
[11:01:52.613]                       }
[11:01:52.613]                       else if (inherits(cond, "condition")) {
[11:01:52.613]                         if (!is.null(pattern)) {
[11:01:52.613]                           computeRestarts <- base::computeRestarts
[11:01:52.613]                           grepl <- base::grepl
[11:01:52.613]                           restarts <- computeRestarts(cond)
[11:01:52.613]                           for (restart in restarts) {
[11:01:52.613]                             name <- restart$name
[11:01:52.613]                             if (is.null(name)) 
[11:01:52.613]                               next
[11:01:52.613]                             if (!grepl(pattern, name)) 
[11:01:52.613]                               next
[11:01:52.613]                             invokeRestart(restart)
[11:01:52.613]                             muffled <- TRUE
[11:01:52.613]                             break
[11:01:52.613]                           }
[11:01:52.613]                         }
[11:01:52.613]                       }
[11:01:52.613]                       invisible(muffled)
[11:01:52.613]                     }
[11:01:52.613]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.613]                   }
[11:01:52.613]                 }
[11:01:52.613]             }
[11:01:52.613]         }))
[11:01:52.613]     }, error = function(ex) {
[11:01:52.613]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.613]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.613]                 ...future.rng), started = ...future.startTime, 
[11:01:52.613]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.613]             version = "1.8"), class = "FutureResult")
[11:01:52.613]     }, finally = {
[11:01:52.613]         if (!identical(...future.workdir, getwd())) 
[11:01:52.613]             setwd(...future.workdir)
[11:01:52.613]         {
[11:01:52.613]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.613]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.613]             }
[11:01:52.613]             base::options(...future.oldOptions)
[11:01:52.613]             if (.Platform$OS.type == "windows") {
[11:01:52.613]                 old_names <- names(...future.oldEnvVars)
[11:01:52.613]                 envs <- base::Sys.getenv()
[11:01:52.613]                 names <- names(envs)
[11:01:52.613]                 common <- intersect(names, old_names)
[11:01:52.613]                 added <- setdiff(names, old_names)
[11:01:52.613]                 removed <- setdiff(old_names, names)
[11:01:52.613]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.613]                   envs[common]]
[11:01:52.613]                 NAMES <- toupper(changed)
[11:01:52.613]                 args <- list()
[11:01:52.613]                 for (kk in seq_along(NAMES)) {
[11:01:52.613]                   name <- changed[[kk]]
[11:01:52.613]                   NAME <- NAMES[[kk]]
[11:01:52.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.613]                     next
[11:01:52.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.613]                 }
[11:01:52.613]                 NAMES <- toupper(added)
[11:01:52.613]                 for (kk in seq_along(NAMES)) {
[11:01:52.613]                   name <- added[[kk]]
[11:01:52.613]                   NAME <- NAMES[[kk]]
[11:01:52.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.613]                     next
[11:01:52.613]                   args[[name]] <- ""
[11:01:52.613]                 }
[11:01:52.613]                 NAMES <- toupper(removed)
[11:01:52.613]                 for (kk in seq_along(NAMES)) {
[11:01:52.613]                   name <- removed[[kk]]
[11:01:52.613]                   NAME <- NAMES[[kk]]
[11:01:52.613]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.613]                     next
[11:01:52.613]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.613]                 }
[11:01:52.613]                 if (length(args) > 0) 
[11:01:52.613]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.613]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.613]             }
[11:01:52.613]             else {
[11:01:52.613]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.613]             }
[11:01:52.613]             {
[11:01:52.613]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.613]                   0L) {
[11:01:52.613]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.613]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.613]                   base::options(opts)
[11:01:52.613]                 }
[11:01:52.613]                 {
[11:01:52.613]                   {
[11:01:52.613]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.613]                     NULL
[11:01:52.613]                   }
[11:01:52.613]                   options(future.plan = NULL)
[11:01:52.613]                   if (is.na(NA_character_)) 
[11:01:52.613]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.613]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.613]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.613]                     .init = FALSE)
[11:01:52.613]                 }
[11:01:52.613]             }
[11:01:52.613]         }
[11:01:52.613]     })
[11:01:52.613]     if (TRUE) {
[11:01:52.613]         base::sink(type = "output", split = FALSE)
[11:01:52.613]         if (TRUE) {
[11:01:52.613]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.613]         }
[11:01:52.613]         else {
[11:01:52.613]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.613]         }
[11:01:52.613]         base::close(...future.stdout)
[11:01:52.613]         ...future.stdout <- NULL
[11:01:52.613]     }
[11:01:52.613]     ...future.result$conditions <- ...future.conditions
[11:01:52.613]     ...future.result$finished <- base::Sys.time()
[11:01:52.613]     ...future.result
[11:01:52.613] }
[11:01:52.615] requestCore(): workers = 2
[11:01:52.617] MulticoreFuture started
[11:01:52.617] - Launch lazy future ... done
[11:01:52.617] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.618] plan(): Setting new future strategy stack:
[11:01:52.618] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.618] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.618] List of future strategies:
[11:01:52.618] 1. sequential:
[11:01:52.618]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.618]    - tweaked: FALSE
[11:01:52.618]    - call: NULL
[11:01:52.619] plan(): nbrOfWorkers() = 1
[11:01:52.620] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.620] Searching for globals ... DONE
[11:01:52.620] Resolving globals: TRUE
[11:01:52.621] plan(): Setting new future strategy stack:
[11:01:52.621] Resolving any globals that are futures ...
[11:01:52.621] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.621] Resolving any globals that are futures ... DONE
[11:01:52.621] List of future strategies:
[11:01:52.621] 1. multicore:
[11:01:52.621]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.621]    - tweaked: FALSE
[11:01:52.621]    - call: plan(strategy)
[11:01:52.622] Resolving futures part of globals (recursively) ...
[11:01:52.622] resolve() on list ...
[11:01:52.622]  recursive: 99
[11:01:52.622]  length: 1
[11:01:52.623]  elements: ‘a’
[11:01:52.624] plan(): nbrOfWorkers() = 2
[11:01:52.624] Future #1
[11:01:52.624] result() for MulticoreFuture ...
[11:01:52.625] result() for MulticoreFuture ...
[11:01:52.625] result() for MulticoreFuture ... done
[11:01:52.625] result() for MulticoreFuture ... done
[11:01:52.625] result() for MulticoreFuture ...
[11:01:52.626] result() for MulticoreFuture ... done
[11:01:52.626] A MulticoreFuture was resolved
[11:01:52.626]  length: 0 (resolved future 1)
[11:01:52.626] resolve() on list ... DONE
[11:01:52.626] - globals: [1] ‘a’
[11:01:52.626] Resolving futures part of globals (recursively) ... DONE
[11:01:52.627] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[11:01:52.627] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[11:01:52.627] - globals: [1] ‘a’
[11:01:52.627] - packages: [1] ‘future’
[11:01:52.628] getGlobalsAndPackages() ... DONE
[11:01:52.628] run() for ‘Future’ ...
[11:01:52.628] - state: ‘created’
[11:01:52.628] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.630] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.630] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.630]   - Field: ‘label’
[11:01:52.631]   - Field: ‘local’
[11:01:52.631]   - Field: ‘owner’
[11:01:52.631]   - Field: ‘envir’
[11:01:52.631]   - Field: ‘workers’
[11:01:52.631]   - Field: ‘packages’
[11:01:52.631]   - Field: ‘gc’
[11:01:52.631]   - Field: ‘job’
[11:01:52.631]   - Field: ‘conditions’
[11:01:52.631]   - Field: ‘expr’
[11:01:52.631]   - Field: ‘uuid’
[11:01:52.632]   - Field: ‘seed’
[11:01:52.632]   - Field: ‘version’
[11:01:52.632]   - Field: ‘result’
[11:01:52.632]   - Field: ‘asynchronous’
[11:01:52.632]   - Field: ‘calls’
[11:01:52.632]   - Field: ‘globals’
[11:01:52.632]   - Field: ‘stdout’
[11:01:52.632]   - Field: ‘earlySignal’
[11:01:52.632]   - Field: ‘lazy’
[11:01:52.633]   - Field: ‘state’
[11:01:52.633] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.633] - Launch lazy future ...
[11:01:52.633] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.633] Packages needed by future strategies (n = 0): <none>
[11:01:52.634] {
[11:01:52.634]     {
[11:01:52.634]         {
[11:01:52.634]             ...future.startTime <- base::Sys.time()
[11:01:52.634]             {
[11:01:52.634]                 {
[11:01:52.634]                   {
[11:01:52.634]                     {
[11:01:52.634]                       {
[11:01:52.634]                         base::local({
[11:01:52.634]                           has_future <- base::requireNamespace("future", 
[11:01:52.634]                             quietly = TRUE)
[11:01:52.634]                           if (has_future) {
[11:01:52.634]                             ns <- base::getNamespace("future")
[11:01:52.634]                             version <- ns[[".package"]][["version"]]
[11:01:52.634]                             if (is.null(version)) 
[11:01:52.634]                               version <- utils::packageVersion("future")
[11:01:52.634]                           }
[11:01:52.634]                           else {
[11:01:52.634]                             version <- NULL
[11:01:52.634]                           }
[11:01:52.634]                           if (!has_future || version < "1.8.0") {
[11:01:52.634]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.634]                               "", base::R.version$version.string), 
[11:01:52.634]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:52.634]                                 base::R.version$platform, 8 * 
[11:01:52.634]                                   base::.Machine$sizeof.pointer), 
[11:01:52.634]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.634]                                 "release", "version")], collapse = " "), 
[11:01:52.634]                               hostname = base::Sys.info()[["nodename"]])
[11:01:52.634]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.634]                               info)
[11:01:52.634]                             info <- base::paste(info, collapse = "; ")
[11:01:52.634]                             if (!has_future) {
[11:01:52.634]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.634]                                 info)
[11:01:52.634]                             }
[11:01:52.634]                             else {
[11:01:52.634]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.634]                                 info, version)
[11:01:52.634]                             }
[11:01:52.634]                             base::stop(msg)
[11:01:52.634]                           }
[11:01:52.634]                         })
[11:01:52.634]                       }
[11:01:52.634]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.634]                       base::options(mc.cores = 1L)
[11:01:52.634]                     }
[11:01:52.634]                     base::local({
[11:01:52.634]                       for (pkg in "future") {
[11:01:52.634]                         base::loadNamespace(pkg)
[11:01:52.634]                         base::library(pkg, character.only = TRUE)
[11:01:52.634]                       }
[11:01:52.634]                     })
[11:01:52.634]                   }
[11:01:52.634]                   ...future.strategy.old <- future::plan("list")
[11:01:52.634]                   options(future.plan = NULL)
[11:01:52.634]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.634]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.634]                 }
[11:01:52.634]                 ...future.workdir <- getwd()
[11:01:52.634]             }
[11:01:52.634]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.634]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.634]         }
[11:01:52.634]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.634]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.634]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.634]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.634]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.634]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.634]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.634]             base::names(...future.oldOptions))
[11:01:52.634]     }
[11:01:52.634]     if (FALSE) {
[11:01:52.634]     }
[11:01:52.634]     else {
[11:01:52.634]         if (TRUE) {
[11:01:52.634]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.634]                 open = "w")
[11:01:52.634]         }
[11:01:52.634]         else {
[11:01:52.634]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.634]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.634]         }
[11:01:52.634]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.634]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.634]             base::sink(type = "output", split = FALSE)
[11:01:52.634]             base::close(...future.stdout)
[11:01:52.634]         }, add = TRUE)
[11:01:52.634]     }
[11:01:52.634]     ...future.frame <- base::sys.nframe()
[11:01:52.634]     ...future.conditions <- base::list()
[11:01:52.634]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.634]     if (FALSE) {
[11:01:52.634]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.634]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.634]     }
[11:01:52.634]     ...future.result <- base::tryCatch({
[11:01:52.634]         base::withCallingHandlers({
[11:01:52.634]             ...future.value <- base::withVisible(base::local({
[11:01:52.634]                 withCallingHandlers({
[11:01:52.634]                   value(a) + 1
[11:01:52.634]                 }, immediateCondition = function(cond) {
[11:01:52.634]                   save_rds <- function (object, pathname, ...) 
[11:01:52.634]                   {
[11:01:52.634]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.634]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.634]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.634]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.634]                         fi_tmp[["mtime"]])
[11:01:52.634]                     }
[11:01:52.634]                     tryCatch({
[11:01:52.634]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.634]                     }, error = function(ex) {
[11:01:52.634]                       msg <- conditionMessage(ex)
[11:01:52.634]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.634]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.634]                         fi_tmp[["mtime"]], msg)
[11:01:52.634]                       ex$message <- msg
[11:01:52.634]                       stop(ex)
[11:01:52.634]                     })
[11:01:52.634]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.634]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.634]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.634]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.634]                       fi <- file.info(pathname)
[11:01:52.634]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.634]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.634]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.634]                         fi[["size"]], fi[["mtime"]])
[11:01:52.634]                       stop(msg)
[11:01:52.634]                     }
[11:01:52.634]                     invisible(pathname)
[11:01:52.634]                   }
[11:01:52.634]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.634]                     rootPath = tempdir()) 
[11:01:52.634]                   {
[11:01:52.634]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.634]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.634]                       tmpdir = path, fileext = ".rds")
[11:01:52.634]                     save_rds(obj, file)
[11:01:52.634]                   }
[11:01:52.634]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.634]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.634]                   {
[11:01:52.634]                     inherits <- base::inherits
[11:01:52.634]                     invokeRestart <- base::invokeRestart
[11:01:52.634]                     is.null <- base::is.null
[11:01:52.634]                     muffled <- FALSE
[11:01:52.634]                     if (inherits(cond, "message")) {
[11:01:52.634]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.634]                       if (muffled) 
[11:01:52.634]                         invokeRestart("muffleMessage")
[11:01:52.634]                     }
[11:01:52.634]                     else if (inherits(cond, "warning")) {
[11:01:52.634]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.634]                       if (muffled) 
[11:01:52.634]                         invokeRestart("muffleWarning")
[11:01:52.634]                     }
[11:01:52.634]                     else if (inherits(cond, "condition")) {
[11:01:52.634]                       if (!is.null(pattern)) {
[11:01:52.634]                         computeRestarts <- base::computeRestarts
[11:01:52.634]                         grepl <- base::grepl
[11:01:52.634]                         restarts <- computeRestarts(cond)
[11:01:52.634]                         for (restart in restarts) {
[11:01:52.634]                           name <- restart$name
[11:01:52.634]                           if (is.null(name)) 
[11:01:52.634]                             next
[11:01:52.634]                           if (!grepl(pattern, name)) 
[11:01:52.634]                             next
[11:01:52.634]                           invokeRestart(restart)
[11:01:52.634]                           muffled <- TRUE
[11:01:52.634]                           break
[11:01:52.634]                         }
[11:01:52.634]                       }
[11:01:52.634]                     }
[11:01:52.634]                     invisible(muffled)
[11:01:52.634]                   }
[11:01:52.634]                   muffleCondition(cond)
[11:01:52.634]                 })
[11:01:52.634]             }))
[11:01:52.634]             future::FutureResult(value = ...future.value$value, 
[11:01:52.634]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.634]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.634]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.634]                     ...future.globalenv.names))
[11:01:52.634]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.634]         }, condition = base::local({
[11:01:52.634]             c <- base::c
[11:01:52.634]             inherits <- base::inherits
[11:01:52.634]             invokeRestart <- base::invokeRestart
[11:01:52.634]             length <- base::length
[11:01:52.634]             list <- base::list
[11:01:52.634]             seq.int <- base::seq.int
[11:01:52.634]             signalCondition <- base::signalCondition
[11:01:52.634]             sys.calls <- base::sys.calls
[11:01:52.634]             `[[` <- base::`[[`
[11:01:52.634]             `+` <- base::`+`
[11:01:52.634]             `<<-` <- base::`<<-`
[11:01:52.634]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.634]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.634]                   3L)]
[11:01:52.634]             }
[11:01:52.634]             function(cond) {
[11:01:52.634]                 is_error <- inherits(cond, "error")
[11:01:52.634]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.634]                   NULL)
[11:01:52.634]                 if (is_error) {
[11:01:52.634]                   sessionInformation <- function() {
[11:01:52.634]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.634]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.634]                       search = base::search(), system = base::Sys.info())
[11:01:52.634]                   }
[11:01:52.634]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.634]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.634]                     cond$call), session = sessionInformation(), 
[11:01:52.634]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.634]                   signalCondition(cond)
[11:01:52.634]                 }
[11:01:52.634]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.634]                 "immediateCondition"))) {
[11:01:52.634]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.634]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.634]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.634]                   if (TRUE && !signal) {
[11:01:52.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.634]                     {
[11:01:52.634]                       inherits <- base::inherits
[11:01:52.634]                       invokeRestart <- base::invokeRestart
[11:01:52.634]                       is.null <- base::is.null
[11:01:52.634]                       muffled <- FALSE
[11:01:52.634]                       if (inherits(cond, "message")) {
[11:01:52.634]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.634]                         if (muffled) 
[11:01:52.634]                           invokeRestart("muffleMessage")
[11:01:52.634]                       }
[11:01:52.634]                       else if (inherits(cond, "warning")) {
[11:01:52.634]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.634]                         if (muffled) 
[11:01:52.634]                           invokeRestart("muffleWarning")
[11:01:52.634]                       }
[11:01:52.634]                       else if (inherits(cond, "condition")) {
[11:01:52.634]                         if (!is.null(pattern)) {
[11:01:52.634]                           computeRestarts <- base::computeRestarts
[11:01:52.634]                           grepl <- base::grepl
[11:01:52.634]                           restarts <- computeRestarts(cond)
[11:01:52.634]                           for (restart in restarts) {
[11:01:52.634]                             name <- restart$name
[11:01:52.634]                             if (is.null(name)) 
[11:01:52.634]                               next
[11:01:52.634]                             if (!grepl(pattern, name)) 
[11:01:52.634]                               next
[11:01:52.634]                             invokeRestart(restart)
[11:01:52.634]                             muffled <- TRUE
[11:01:52.634]                             break
[11:01:52.634]                           }
[11:01:52.634]                         }
[11:01:52.634]                       }
[11:01:52.634]                       invisible(muffled)
[11:01:52.634]                     }
[11:01:52.634]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.634]                   }
[11:01:52.634]                 }
[11:01:52.634]                 else {
[11:01:52.634]                   if (TRUE) {
[11:01:52.634]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.634]                     {
[11:01:52.634]                       inherits <- base::inherits
[11:01:52.634]                       invokeRestart <- base::invokeRestart
[11:01:52.634]                       is.null <- base::is.null
[11:01:52.634]                       muffled <- FALSE
[11:01:52.634]                       if (inherits(cond, "message")) {
[11:01:52.634]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.634]                         if (muffled) 
[11:01:52.634]                           invokeRestart("muffleMessage")
[11:01:52.634]                       }
[11:01:52.634]                       else if (inherits(cond, "warning")) {
[11:01:52.634]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.634]                         if (muffled) 
[11:01:52.634]                           invokeRestart("muffleWarning")
[11:01:52.634]                       }
[11:01:52.634]                       else if (inherits(cond, "condition")) {
[11:01:52.634]                         if (!is.null(pattern)) {
[11:01:52.634]                           computeRestarts <- base::computeRestarts
[11:01:52.634]                           grepl <- base::grepl
[11:01:52.634]                           restarts <- computeRestarts(cond)
[11:01:52.634]                           for (restart in restarts) {
[11:01:52.634]                             name <- restart$name
[11:01:52.634]                             if (is.null(name)) 
[11:01:52.634]                               next
[11:01:52.634]                             if (!grepl(pattern, name)) 
[11:01:52.634]                               next
[11:01:52.634]                             invokeRestart(restart)
[11:01:52.634]                             muffled <- TRUE
[11:01:52.634]                             break
[11:01:52.634]                           }
[11:01:52.634]                         }
[11:01:52.634]                       }
[11:01:52.634]                       invisible(muffled)
[11:01:52.634]                     }
[11:01:52.634]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.634]                   }
[11:01:52.634]                 }
[11:01:52.634]             }
[11:01:52.634]         }))
[11:01:52.634]     }, error = function(ex) {
[11:01:52.634]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.634]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.634]                 ...future.rng), started = ...future.startTime, 
[11:01:52.634]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.634]             version = "1.8"), class = "FutureResult")
[11:01:52.634]     }, finally = {
[11:01:52.634]         if (!identical(...future.workdir, getwd())) 
[11:01:52.634]             setwd(...future.workdir)
[11:01:52.634]         {
[11:01:52.634]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.634]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.634]             }
[11:01:52.634]             base::options(...future.oldOptions)
[11:01:52.634]             if (.Platform$OS.type == "windows") {
[11:01:52.634]                 old_names <- names(...future.oldEnvVars)
[11:01:52.634]                 envs <- base::Sys.getenv()
[11:01:52.634]                 names <- names(envs)
[11:01:52.634]                 common <- intersect(names, old_names)
[11:01:52.634]                 added <- setdiff(names, old_names)
[11:01:52.634]                 removed <- setdiff(old_names, names)
[11:01:52.634]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.634]                   envs[common]]
[11:01:52.634]                 NAMES <- toupper(changed)
[11:01:52.634]                 args <- list()
[11:01:52.634]                 for (kk in seq_along(NAMES)) {
[11:01:52.634]                   name <- changed[[kk]]
[11:01:52.634]                   NAME <- NAMES[[kk]]
[11:01:52.634]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.634]                     next
[11:01:52.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.634]                 }
[11:01:52.634]                 NAMES <- toupper(added)
[11:01:52.634]                 for (kk in seq_along(NAMES)) {
[11:01:52.634]                   name <- added[[kk]]
[11:01:52.634]                   NAME <- NAMES[[kk]]
[11:01:52.634]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.634]                     next
[11:01:52.634]                   args[[name]] <- ""
[11:01:52.634]                 }
[11:01:52.634]                 NAMES <- toupper(removed)
[11:01:52.634]                 for (kk in seq_along(NAMES)) {
[11:01:52.634]                   name <- removed[[kk]]
[11:01:52.634]                   NAME <- NAMES[[kk]]
[11:01:52.634]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.634]                     next
[11:01:52.634]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.634]                 }
[11:01:52.634]                 if (length(args) > 0) 
[11:01:52.634]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.634]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.634]             }
[11:01:52.634]             else {
[11:01:52.634]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.634]             }
[11:01:52.634]             {
[11:01:52.634]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.634]                   0L) {
[11:01:52.634]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.634]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.634]                   base::options(opts)
[11:01:52.634]                 }
[11:01:52.634]                 {
[11:01:52.634]                   {
[11:01:52.634]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.634]                     NULL
[11:01:52.634]                   }
[11:01:52.634]                   options(future.plan = NULL)
[11:01:52.634]                   if (is.na(NA_character_)) 
[11:01:52.634]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.634]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.634]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.634]                     .init = FALSE)
[11:01:52.634]                 }
[11:01:52.634]             }
[11:01:52.634]         }
[11:01:52.634]     })
[11:01:52.634]     if (TRUE) {
[11:01:52.634]         base::sink(type = "output", split = FALSE)
[11:01:52.634]         if (TRUE) {
[11:01:52.634]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.634]         }
[11:01:52.634]         else {
[11:01:52.634]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.634]         }
[11:01:52.634]         base::close(...future.stdout)
[11:01:52.634]         ...future.stdout <- NULL
[11:01:52.634]     }
[11:01:52.634]     ...future.result$conditions <- ...future.conditions
[11:01:52.634]     ...future.result$finished <- base::Sys.time()
[11:01:52.634]     ...future.result
[11:01:52.634] }
[11:01:52.637] assign_globals() ...
[11:01:52.637] List of 1
[11:01:52.637]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eecd8eb6d0> 
[11:01:52.637]  - attr(*, "where")=List of 1
[11:01:52.637]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.637]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.637]  - attr(*, "resolved")= logi TRUE
[11:01:52.637]  - attr(*, "total_size")= num 3815
[11:01:52.637]  - attr(*, "already-done")= logi TRUE
[11:01:52.642] - copied ‘a’ to environment
[11:01:52.642] assign_globals() ... done
[11:01:52.642] requestCore(): workers = 2
[11:01:52.644] MulticoreFuture started
[11:01:52.644] - Launch lazy future ... done
[11:01:52.645] run() for ‘MulticoreFuture’ ... done
[11:01:52.645] result() for MulticoreFuture ...
[11:01:52.645] plan(): Setting new future strategy stack:
[11:01:52.645] List of future strategies:
[11:01:52.645] 1. sequential:
[11:01:52.645]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.645]    - tweaked: FALSE
[11:01:52.645]    - call: NULL
[11:01:52.647] plan(): nbrOfWorkers() = 1
[11:01:52.650] plan(): Setting new future strategy stack:
[11:01:52.650] List of future strategies:
[11:01:52.650] 1. multicore:
[11:01:52.650]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.650]    - tweaked: FALSE
[11:01:52.650]    - call: plan(strategy)
[11:01:52.653] plan(): nbrOfWorkers() = 2
[11:01:52.654] result() for MulticoreFuture ...
[11:01:52.655] result() for MulticoreFuture ... done
[11:01:52.655] signalConditions() ...
[11:01:52.655]  - include = ‘immediateCondition’
[11:01:52.655]  - exclude = 
[11:01:52.655]  - resignal = FALSE
[11:01:52.655]  - Number of conditions: 4
[11:01:52.656] signalConditions() ... done
[11:01:52.656] result() for MulticoreFuture ... done
[11:01:52.656] result() for MulticoreFuture ...
[11:01:52.656] result() for MulticoreFuture ... done
[11:01:52.656] signalConditions() ...
[11:01:52.656]  - include = ‘immediateCondition’
[11:01:52.656]  - exclude = 
[11:01:52.656]  - resignal = FALSE
[11:01:52.657]  - Number of conditions: 4
[11:01:52.657] signalConditions() ... done
[11:01:52.657] Future state: ‘finished’
[11:01:52.657] result() for MulticoreFuture ...
[11:01:52.657] result() for MulticoreFuture ... done
[11:01:52.657] signalConditions() ...
[11:01:52.657]  - include = ‘condition’
[11:01:52.657]  - exclude = ‘immediateCondition’
[11:01:52.658]  - resignal = TRUE
[11:01:52.658]  - Number of conditions: 4
[11:01:52.658]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.648] result() for MulticoreFuture ...
[11:01:52.658]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.648] result() for MulticoreFuture ... done
[11:01:52.658]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.649] result() for MulticoreFuture ...
[11:01:52.658]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.649] result() for MulticoreFuture ... done
[11:01:52.658] signalConditions() ... done
value(b) = 2
[11:01:52.659] result() for MulticoreFuture ...
[11:01:52.659] result() for MulticoreFuture ... done
[11:01:52.659] result() for MulticoreFuture ...
[11:01:52.659] result() for MulticoreFuture ... done
[11:01:52.659] signalConditions() ...
[11:01:52.659]  - include = ‘immediateCondition’
[11:01:52.659]  - exclude = 
[11:01:52.659]  - resignal = FALSE
[11:01:52.660]  - Number of conditions: 4
[11:01:52.660] signalConditions() ... done
[11:01:52.660] Future state: ‘finished’
[11:01:52.660] result() for MulticoreFuture ...
[11:01:52.660] result() for MulticoreFuture ... done
[11:01:52.660] signalConditions() ...
[11:01:52.660]  - include = ‘condition’
[11:01:52.660]  - exclude = ‘immediateCondition’
[11:01:52.660]  - resignal = TRUE
[11:01:52.661]  - Number of conditions: 4
[11:01:52.661]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.648] result() for MulticoreFuture ...
[11:01:52.661]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.648] result() for MulticoreFuture ... done
[11:01:52.661]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.649] result() for MulticoreFuture ...
[11:01:52.661]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.649] result() for MulticoreFuture ... done
[11:01:52.661] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.662] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.662] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.663] 
[11:01:52.663] Searching for globals ... DONE
[11:01:52.663] - globals: [0] <none>
[11:01:52.663] getGlobalsAndPackages() ... DONE
[11:01:52.663] run() for ‘Future’ ...
[11:01:52.663] - state: ‘created’
[11:01:52.663] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.665] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.666] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.666]   - Field: ‘label’
[11:01:52.666]   - Field: ‘local’
[11:01:52.666]   - Field: ‘owner’
[11:01:52.666]   - Field: ‘envir’
[11:01:52.666]   - Field: ‘workers’
[11:01:52.666]   - Field: ‘packages’
[11:01:52.666]   - Field: ‘gc’
[11:01:52.667]   - Field: ‘job’
[11:01:52.667]   - Field: ‘conditions’
[11:01:52.667]   - Field: ‘expr’
[11:01:52.667]   - Field: ‘uuid’
[11:01:52.667]   - Field: ‘seed’
[11:01:52.667]   - Field: ‘version’
[11:01:52.667]   - Field: ‘result’
[11:01:52.667]   - Field: ‘asynchronous’
[11:01:52.667]   - Field: ‘calls’
[11:01:52.667]   - Field: ‘globals’
[11:01:52.668]   - Field: ‘stdout’
[11:01:52.668]   - Field: ‘earlySignal’
[11:01:52.668]   - Field: ‘lazy’
[11:01:52.668]   - Field: ‘state’
[11:01:52.668] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.668] - Launch lazy future ...
[11:01:52.668] Packages needed by the future expression (n = 0): <none>
[11:01:52.669] Packages needed by future strategies (n = 0): <none>
[11:01:52.669] {
[11:01:52.669]     {
[11:01:52.669]         {
[11:01:52.669]             ...future.startTime <- base::Sys.time()
[11:01:52.669]             {
[11:01:52.669]                 {
[11:01:52.669]                   {
[11:01:52.669]                     {
[11:01:52.669]                       base::local({
[11:01:52.669]                         has_future <- base::requireNamespace("future", 
[11:01:52.669]                           quietly = TRUE)
[11:01:52.669]                         if (has_future) {
[11:01:52.669]                           ns <- base::getNamespace("future")
[11:01:52.669]                           version <- ns[[".package"]][["version"]]
[11:01:52.669]                           if (is.null(version)) 
[11:01:52.669]                             version <- utils::packageVersion("future")
[11:01:52.669]                         }
[11:01:52.669]                         else {
[11:01:52.669]                           version <- NULL
[11:01:52.669]                         }
[11:01:52.669]                         if (!has_future || version < "1.8.0") {
[11:01:52.669]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.669]                             "", base::R.version$version.string), 
[11:01:52.669]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.669]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.669]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.669]                               "release", "version")], collapse = " "), 
[11:01:52.669]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.669]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.669]                             info)
[11:01:52.669]                           info <- base::paste(info, collapse = "; ")
[11:01:52.669]                           if (!has_future) {
[11:01:52.669]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.669]                               info)
[11:01:52.669]                           }
[11:01:52.669]                           else {
[11:01:52.669]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.669]                               info, version)
[11:01:52.669]                           }
[11:01:52.669]                           base::stop(msg)
[11:01:52.669]                         }
[11:01:52.669]                       })
[11:01:52.669]                     }
[11:01:52.669]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.669]                     base::options(mc.cores = 1L)
[11:01:52.669]                   }
[11:01:52.669]                   ...future.strategy.old <- future::plan("list")
[11:01:52.669]                   options(future.plan = NULL)
[11:01:52.669]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.669]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.669]                 }
[11:01:52.669]                 ...future.workdir <- getwd()
[11:01:52.669]             }
[11:01:52.669]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.669]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.669]         }
[11:01:52.669]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.669]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.669]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.669]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.669]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.669]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.669]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.669]             base::names(...future.oldOptions))
[11:01:52.669]     }
[11:01:52.669]     if (FALSE) {
[11:01:52.669]     }
[11:01:52.669]     else {
[11:01:52.669]         if (TRUE) {
[11:01:52.669]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.669]                 open = "w")
[11:01:52.669]         }
[11:01:52.669]         else {
[11:01:52.669]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.669]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.669]         }
[11:01:52.669]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.669]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.669]             base::sink(type = "output", split = FALSE)
[11:01:52.669]             base::close(...future.stdout)
[11:01:52.669]         }, add = TRUE)
[11:01:52.669]     }
[11:01:52.669]     ...future.frame <- base::sys.nframe()
[11:01:52.669]     ...future.conditions <- base::list()
[11:01:52.669]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.669]     if (FALSE) {
[11:01:52.669]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.669]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.669]     }
[11:01:52.669]     ...future.result <- base::tryCatch({
[11:01:52.669]         base::withCallingHandlers({
[11:01:52.669]             ...future.value <- base::withVisible(base::local({
[11:01:52.669]                 withCallingHandlers({
[11:01:52.669]                   1
[11:01:52.669]                 }, immediateCondition = function(cond) {
[11:01:52.669]                   save_rds <- function (object, pathname, ...) 
[11:01:52.669]                   {
[11:01:52.669]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.669]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.669]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.669]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.669]                         fi_tmp[["mtime"]])
[11:01:52.669]                     }
[11:01:52.669]                     tryCatch({
[11:01:52.669]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.669]                     }, error = function(ex) {
[11:01:52.669]                       msg <- conditionMessage(ex)
[11:01:52.669]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.669]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.669]                         fi_tmp[["mtime"]], msg)
[11:01:52.669]                       ex$message <- msg
[11:01:52.669]                       stop(ex)
[11:01:52.669]                     })
[11:01:52.669]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.669]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.669]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.669]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.669]                       fi <- file.info(pathname)
[11:01:52.669]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.669]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.669]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.669]                         fi[["size"]], fi[["mtime"]])
[11:01:52.669]                       stop(msg)
[11:01:52.669]                     }
[11:01:52.669]                     invisible(pathname)
[11:01:52.669]                   }
[11:01:52.669]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.669]                     rootPath = tempdir()) 
[11:01:52.669]                   {
[11:01:52.669]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.669]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.669]                       tmpdir = path, fileext = ".rds")
[11:01:52.669]                     save_rds(obj, file)
[11:01:52.669]                   }
[11:01:52.669]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.669]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.669]                   {
[11:01:52.669]                     inherits <- base::inherits
[11:01:52.669]                     invokeRestart <- base::invokeRestart
[11:01:52.669]                     is.null <- base::is.null
[11:01:52.669]                     muffled <- FALSE
[11:01:52.669]                     if (inherits(cond, "message")) {
[11:01:52.669]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.669]                       if (muffled) 
[11:01:52.669]                         invokeRestart("muffleMessage")
[11:01:52.669]                     }
[11:01:52.669]                     else if (inherits(cond, "warning")) {
[11:01:52.669]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.669]                       if (muffled) 
[11:01:52.669]                         invokeRestart("muffleWarning")
[11:01:52.669]                     }
[11:01:52.669]                     else if (inherits(cond, "condition")) {
[11:01:52.669]                       if (!is.null(pattern)) {
[11:01:52.669]                         computeRestarts <- base::computeRestarts
[11:01:52.669]                         grepl <- base::grepl
[11:01:52.669]                         restarts <- computeRestarts(cond)
[11:01:52.669]                         for (restart in restarts) {
[11:01:52.669]                           name <- restart$name
[11:01:52.669]                           if (is.null(name)) 
[11:01:52.669]                             next
[11:01:52.669]                           if (!grepl(pattern, name)) 
[11:01:52.669]                             next
[11:01:52.669]                           invokeRestart(restart)
[11:01:52.669]                           muffled <- TRUE
[11:01:52.669]                           break
[11:01:52.669]                         }
[11:01:52.669]                       }
[11:01:52.669]                     }
[11:01:52.669]                     invisible(muffled)
[11:01:52.669]                   }
[11:01:52.669]                   muffleCondition(cond)
[11:01:52.669]                 })
[11:01:52.669]             }))
[11:01:52.669]             future::FutureResult(value = ...future.value$value, 
[11:01:52.669]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.669]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.669]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.669]                     ...future.globalenv.names))
[11:01:52.669]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.669]         }, condition = base::local({
[11:01:52.669]             c <- base::c
[11:01:52.669]             inherits <- base::inherits
[11:01:52.669]             invokeRestart <- base::invokeRestart
[11:01:52.669]             length <- base::length
[11:01:52.669]             list <- base::list
[11:01:52.669]             seq.int <- base::seq.int
[11:01:52.669]             signalCondition <- base::signalCondition
[11:01:52.669]             sys.calls <- base::sys.calls
[11:01:52.669]             `[[` <- base::`[[`
[11:01:52.669]             `+` <- base::`+`
[11:01:52.669]             `<<-` <- base::`<<-`
[11:01:52.669]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.669]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.669]                   3L)]
[11:01:52.669]             }
[11:01:52.669]             function(cond) {
[11:01:52.669]                 is_error <- inherits(cond, "error")
[11:01:52.669]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.669]                   NULL)
[11:01:52.669]                 if (is_error) {
[11:01:52.669]                   sessionInformation <- function() {
[11:01:52.669]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.669]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.669]                       search = base::search(), system = base::Sys.info())
[11:01:52.669]                   }
[11:01:52.669]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.669]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.669]                     cond$call), session = sessionInformation(), 
[11:01:52.669]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.669]                   signalCondition(cond)
[11:01:52.669]                 }
[11:01:52.669]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.669]                 "immediateCondition"))) {
[11:01:52.669]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.669]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.669]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.669]                   if (TRUE && !signal) {
[11:01:52.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.669]                     {
[11:01:52.669]                       inherits <- base::inherits
[11:01:52.669]                       invokeRestart <- base::invokeRestart
[11:01:52.669]                       is.null <- base::is.null
[11:01:52.669]                       muffled <- FALSE
[11:01:52.669]                       if (inherits(cond, "message")) {
[11:01:52.669]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.669]                         if (muffled) 
[11:01:52.669]                           invokeRestart("muffleMessage")
[11:01:52.669]                       }
[11:01:52.669]                       else if (inherits(cond, "warning")) {
[11:01:52.669]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.669]                         if (muffled) 
[11:01:52.669]                           invokeRestart("muffleWarning")
[11:01:52.669]                       }
[11:01:52.669]                       else if (inherits(cond, "condition")) {
[11:01:52.669]                         if (!is.null(pattern)) {
[11:01:52.669]                           computeRestarts <- base::computeRestarts
[11:01:52.669]                           grepl <- base::grepl
[11:01:52.669]                           restarts <- computeRestarts(cond)
[11:01:52.669]                           for (restart in restarts) {
[11:01:52.669]                             name <- restart$name
[11:01:52.669]                             if (is.null(name)) 
[11:01:52.669]                               next
[11:01:52.669]                             if (!grepl(pattern, name)) 
[11:01:52.669]                               next
[11:01:52.669]                             invokeRestart(restart)
[11:01:52.669]                             muffled <- TRUE
[11:01:52.669]                             break
[11:01:52.669]                           }
[11:01:52.669]                         }
[11:01:52.669]                       }
[11:01:52.669]                       invisible(muffled)
[11:01:52.669]                     }
[11:01:52.669]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.669]                   }
[11:01:52.669]                 }
[11:01:52.669]                 else {
[11:01:52.669]                   if (TRUE) {
[11:01:52.669]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.669]                     {
[11:01:52.669]                       inherits <- base::inherits
[11:01:52.669]                       invokeRestart <- base::invokeRestart
[11:01:52.669]                       is.null <- base::is.null
[11:01:52.669]                       muffled <- FALSE
[11:01:52.669]                       if (inherits(cond, "message")) {
[11:01:52.669]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.669]                         if (muffled) 
[11:01:52.669]                           invokeRestart("muffleMessage")
[11:01:52.669]                       }
[11:01:52.669]                       else if (inherits(cond, "warning")) {
[11:01:52.669]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.669]                         if (muffled) 
[11:01:52.669]                           invokeRestart("muffleWarning")
[11:01:52.669]                       }
[11:01:52.669]                       else if (inherits(cond, "condition")) {
[11:01:52.669]                         if (!is.null(pattern)) {
[11:01:52.669]                           computeRestarts <- base::computeRestarts
[11:01:52.669]                           grepl <- base::grepl
[11:01:52.669]                           restarts <- computeRestarts(cond)
[11:01:52.669]                           for (restart in restarts) {
[11:01:52.669]                             name <- restart$name
[11:01:52.669]                             if (is.null(name)) 
[11:01:52.669]                               next
[11:01:52.669]                             if (!grepl(pattern, name)) 
[11:01:52.669]                               next
[11:01:52.669]                             invokeRestart(restart)
[11:01:52.669]                             muffled <- TRUE
[11:01:52.669]                             break
[11:01:52.669]                           }
[11:01:52.669]                         }
[11:01:52.669]                       }
[11:01:52.669]                       invisible(muffled)
[11:01:52.669]                     }
[11:01:52.669]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.669]                   }
[11:01:52.669]                 }
[11:01:52.669]             }
[11:01:52.669]         }))
[11:01:52.669]     }, error = function(ex) {
[11:01:52.669]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.669]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.669]                 ...future.rng), started = ...future.startTime, 
[11:01:52.669]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.669]             version = "1.8"), class = "FutureResult")
[11:01:52.669]     }, finally = {
[11:01:52.669]         if (!identical(...future.workdir, getwd())) 
[11:01:52.669]             setwd(...future.workdir)
[11:01:52.669]         {
[11:01:52.669]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.669]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.669]             }
[11:01:52.669]             base::options(...future.oldOptions)
[11:01:52.669]             if (.Platform$OS.type == "windows") {
[11:01:52.669]                 old_names <- names(...future.oldEnvVars)
[11:01:52.669]                 envs <- base::Sys.getenv()
[11:01:52.669]                 names <- names(envs)
[11:01:52.669]                 common <- intersect(names, old_names)
[11:01:52.669]                 added <- setdiff(names, old_names)
[11:01:52.669]                 removed <- setdiff(old_names, names)
[11:01:52.669]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.669]                   envs[common]]
[11:01:52.669]                 NAMES <- toupper(changed)
[11:01:52.669]                 args <- list()
[11:01:52.669]                 for (kk in seq_along(NAMES)) {
[11:01:52.669]                   name <- changed[[kk]]
[11:01:52.669]                   NAME <- NAMES[[kk]]
[11:01:52.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.669]                     next
[11:01:52.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.669]                 }
[11:01:52.669]                 NAMES <- toupper(added)
[11:01:52.669]                 for (kk in seq_along(NAMES)) {
[11:01:52.669]                   name <- added[[kk]]
[11:01:52.669]                   NAME <- NAMES[[kk]]
[11:01:52.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.669]                     next
[11:01:52.669]                   args[[name]] <- ""
[11:01:52.669]                 }
[11:01:52.669]                 NAMES <- toupper(removed)
[11:01:52.669]                 for (kk in seq_along(NAMES)) {
[11:01:52.669]                   name <- removed[[kk]]
[11:01:52.669]                   NAME <- NAMES[[kk]]
[11:01:52.669]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.669]                     next
[11:01:52.669]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.669]                 }
[11:01:52.669]                 if (length(args) > 0) 
[11:01:52.669]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.669]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.669]             }
[11:01:52.669]             else {
[11:01:52.669]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.669]             }
[11:01:52.669]             {
[11:01:52.669]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.669]                   0L) {
[11:01:52.669]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.669]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.669]                   base::options(opts)
[11:01:52.669]                 }
[11:01:52.669]                 {
[11:01:52.669]                   {
[11:01:52.669]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.669]                     NULL
[11:01:52.669]                   }
[11:01:52.669]                   options(future.plan = NULL)
[11:01:52.669]                   if (is.na(NA_character_)) 
[11:01:52.669]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.669]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.669]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.669]                     .init = FALSE)
[11:01:52.669]                 }
[11:01:52.669]             }
[11:01:52.669]         }
[11:01:52.669]     })
[11:01:52.669]     if (TRUE) {
[11:01:52.669]         base::sink(type = "output", split = FALSE)
[11:01:52.669]         if (TRUE) {
[11:01:52.669]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.669]         }
[11:01:52.669]         else {
[11:01:52.669]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.669]         }
[11:01:52.669]         base::close(...future.stdout)
[11:01:52.669]         ...future.stdout <- NULL
[11:01:52.669]     }
[11:01:52.669]     ...future.result$conditions <- ...future.conditions
[11:01:52.669]     ...future.result$finished <- base::Sys.time()
[11:01:52.669]     ...future.result
[11:01:52.669] }
[11:01:52.672] requestCore(): workers = 2
[11:01:52.673] MulticoreFuture started
[11:01:52.674] - Launch lazy future ... done
[11:01:52.674] run() for ‘MulticoreFuture’ ... done
[11:01:52.674] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.674] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.675] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.674] List of future strategies:
[11:01:52.674] 1. sequential:
[11:01:52.674]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.674]    - tweaked: FALSE
[11:01:52.674]    - call: NULL
[11:01:52.675] plan(): nbrOfWorkers() = 1
[11:01:52.677] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.677] Searching for globals ... DONE
[11:01:52.677] Resolving globals: TRUE
[11:01:52.677] plan(): Setting new future strategy stack:
[11:01:52.677] Resolving any globals that are futures ...
[11:01:52.677] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.677] Resolving any globals that are futures ... DONE
[11:01:52.677] List of future strategies:
[11:01:52.677] 1. multicore:
[11:01:52.677]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.677]    - tweaked: FALSE
[11:01:52.677]    - call: plan(strategy)
[11:01:52.678] Resolving futures part of globals (recursively) ...
[11:01:52.679] resolve() on list ...
[11:01:52.679]  recursive: 99
[11:01:52.679]  length: 1
[11:01:52.679]  elements: ‘a’
[11:01:52.680] plan(): nbrOfWorkers() = 2
[11:01:52.680] Future #1
[11:01:52.681] result() for MulticoreFuture ...
[11:01:52.681] result() for MulticoreFuture ...
[11:01:52.682] result() for MulticoreFuture ... done
[11:01:52.682] result() for MulticoreFuture ... done
[11:01:52.682] result() for MulticoreFuture ...
[11:01:52.684] result() for MulticoreFuture ... done
[11:01:52.685] A MulticoreFuture was resolved
[11:01:52.685]  length: 0 (resolved future 1)
[11:01:52.685] resolve() on list ... DONE
[11:01:52.685] - globals: [1] ‘a’
[11:01:52.685] Resolving futures part of globals (recursively) ... DONE
[11:01:52.685] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[11:01:52.686] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[11:01:52.686] - globals: [1] ‘a’
[11:01:52.686] - packages: [1] ‘future’
[11:01:52.686] getGlobalsAndPackages() ... DONE
[11:01:52.687] run() for ‘Future’ ...
[11:01:52.687] - state: ‘created’
[11:01:52.687] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.689] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.689] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.690]   - Field: ‘label’
[11:01:52.690]   - Field: ‘local’
[11:01:52.690]   - Field: ‘owner’
[11:01:52.690]   - Field: ‘envir’
[11:01:52.690]   - Field: ‘workers’
[11:01:52.690]   - Field: ‘packages’
[11:01:52.690]   - Field: ‘gc’
[11:01:52.690]   - Field: ‘job’
[11:01:52.691]   - Field: ‘conditions’
[11:01:52.691]   - Field: ‘expr’
[11:01:52.691]   - Field: ‘uuid’
[11:01:52.691]   - Field: ‘seed’
[11:01:52.691]   - Field: ‘version’
[11:01:52.691]   - Field: ‘result’
[11:01:52.691]   - Field: ‘asynchronous’
[11:01:52.691]   - Field: ‘calls’
[11:01:52.691]   - Field: ‘globals’
[11:01:52.691]   - Field: ‘stdout’
[11:01:52.692]   - Field: ‘earlySignal’
[11:01:52.692]   - Field: ‘lazy’
[11:01:52.692]   - Field: ‘state’
[11:01:52.692] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.692] - Launch lazy future ...
[11:01:52.692] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.692] Packages needed by future strategies (n = 0): <none>
[11:01:52.693] {
[11:01:52.693]     {
[11:01:52.693]         {
[11:01:52.693]             ...future.startTime <- base::Sys.time()
[11:01:52.693]             {
[11:01:52.693]                 {
[11:01:52.693]                   {
[11:01:52.693]                     {
[11:01:52.693]                       {
[11:01:52.693]                         base::local({
[11:01:52.693]                           has_future <- base::requireNamespace("future", 
[11:01:52.693]                             quietly = TRUE)
[11:01:52.693]                           if (has_future) {
[11:01:52.693]                             ns <- base::getNamespace("future")
[11:01:52.693]                             version <- ns[[".package"]][["version"]]
[11:01:52.693]                             if (is.null(version)) 
[11:01:52.693]                               version <- utils::packageVersion("future")
[11:01:52.693]                           }
[11:01:52.693]                           else {
[11:01:52.693]                             version <- NULL
[11:01:52.693]                           }
[11:01:52.693]                           if (!has_future || version < "1.8.0") {
[11:01:52.693]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.693]                               "", base::R.version$version.string), 
[11:01:52.693]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:52.693]                                 base::R.version$platform, 8 * 
[11:01:52.693]                                   base::.Machine$sizeof.pointer), 
[11:01:52.693]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.693]                                 "release", "version")], collapse = " "), 
[11:01:52.693]                               hostname = base::Sys.info()[["nodename"]])
[11:01:52.693]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.693]                               info)
[11:01:52.693]                             info <- base::paste(info, collapse = "; ")
[11:01:52.693]                             if (!has_future) {
[11:01:52.693]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.693]                                 info)
[11:01:52.693]                             }
[11:01:52.693]                             else {
[11:01:52.693]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.693]                                 info, version)
[11:01:52.693]                             }
[11:01:52.693]                             base::stop(msg)
[11:01:52.693]                           }
[11:01:52.693]                         })
[11:01:52.693]                       }
[11:01:52.693]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.693]                       base::options(mc.cores = 1L)
[11:01:52.693]                     }
[11:01:52.693]                     base::local({
[11:01:52.693]                       for (pkg in "future") {
[11:01:52.693]                         base::loadNamespace(pkg)
[11:01:52.693]                         base::library(pkg, character.only = TRUE)
[11:01:52.693]                       }
[11:01:52.693]                     })
[11:01:52.693]                   }
[11:01:52.693]                   ...future.strategy.old <- future::plan("list")
[11:01:52.693]                   options(future.plan = NULL)
[11:01:52.693]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.693]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.693]                 }
[11:01:52.693]                 ...future.workdir <- getwd()
[11:01:52.693]             }
[11:01:52.693]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.693]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.693]         }
[11:01:52.693]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.693]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.693]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.693]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.693]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.693]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.693]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.693]             base::names(...future.oldOptions))
[11:01:52.693]     }
[11:01:52.693]     if (FALSE) {
[11:01:52.693]     }
[11:01:52.693]     else {
[11:01:52.693]         if (TRUE) {
[11:01:52.693]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.693]                 open = "w")
[11:01:52.693]         }
[11:01:52.693]         else {
[11:01:52.693]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.693]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.693]         }
[11:01:52.693]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.693]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.693]             base::sink(type = "output", split = FALSE)
[11:01:52.693]             base::close(...future.stdout)
[11:01:52.693]         }, add = TRUE)
[11:01:52.693]     }
[11:01:52.693]     ...future.frame <- base::sys.nframe()
[11:01:52.693]     ...future.conditions <- base::list()
[11:01:52.693]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.693]     if (FALSE) {
[11:01:52.693]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.693]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.693]     }
[11:01:52.693]     ...future.result <- base::tryCatch({
[11:01:52.693]         base::withCallingHandlers({
[11:01:52.693]             ...future.value <- base::withVisible(base::local({
[11:01:52.693]                 withCallingHandlers({
[11:01:52.693]                   value(a) + 1
[11:01:52.693]                 }, immediateCondition = function(cond) {
[11:01:52.693]                   save_rds <- function (object, pathname, ...) 
[11:01:52.693]                   {
[11:01:52.693]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.693]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.693]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.693]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.693]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.693]                         fi_tmp[["mtime"]])
[11:01:52.693]                     }
[11:01:52.693]                     tryCatch({
[11:01:52.693]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.693]                     }, error = function(ex) {
[11:01:52.693]                       msg <- conditionMessage(ex)
[11:01:52.693]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.693]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.693]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.693]                         fi_tmp[["mtime"]], msg)
[11:01:52.693]                       ex$message <- msg
[11:01:52.693]                       stop(ex)
[11:01:52.693]                     })
[11:01:52.693]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.693]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.693]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.693]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.693]                       fi <- file.info(pathname)
[11:01:52.693]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.693]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.693]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.693]                         fi[["size"]], fi[["mtime"]])
[11:01:52.693]                       stop(msg)
[11:01:52.693]                     }
[11:01:52.693]                     invisible(pathname)
[11:01:52.693]                   }
[11:01:52.693]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.693]                     rootPath = tempdir()) 
[11:01:52.693]                   {
[11:01:52.693]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.693]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.693]                       tmpdir = path, fileext = ".rds")
[11:01:52.693]                     save_rds(obj, file)
[11:01:52.693]                   }
[11:01:52.693]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.693]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.693]                   {
[11:01:52.693]                     inherits <- base::inherits
[11:01:52.693]                     invokeRestart <- base::invokeRestart
[11:01:52.693]                     is.null <- base::is.null
[11:01:52.693]                     muffled <- FALSE
[11:01:52.693]                     if (inherits(cond, "message")) {
[11:01:52.693]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.693]                       if (muffled) 
[11:01:52.693]                         invokeRestart("muffleMessage")
[11:01:52.693]                     }
[11:01:52.693]                     else if (inherits(cond, "warning")) {
[11:01:52.693]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.693]                       if (muffled) 
[11:01:52.693]                         invokeRestart("muffleWarning")
[11:01:52.693]                     }
[11:01:52.693]                     else if (inherits(cond, "condition")) {
[11:01:52.693]                       if (!is.null(pattern)) {
[11:01:52.693]                         computeRestarts <- base::computeRestarts
[11:01:52.693]                         grepl <- base::grepl
[11:01:52.693]                         restarts <- computeRestarts(cond)
[11:01:52.693]                         for (restart in restarts) {
[11:01:52.693]                           name <- restart$name
[11:01:52.693]                           if (is.null(name)) 
[11:01:52.693]                             next
[11:01:52.693]                           if (!grepl(pattern, name)) 
[11:01:52.693]                             next
[11:01:52.693]                           invokeRestart(restart)
[11:01:52.693]                           muffled <- TRUE
[11:01:52.693]                           break
[11:01:52.693]                         }
[11:01:52.693]                       }
[11:01:52.693]                     }
[11:01:52.693]                     invisible(muffled)
[11:01:52.693]                   }
[11:01:52.693]                   muffleCondition(cond)
[11:01:52.693]                 })
[11:01:52.693]             }))
[11:01:52.693]             future::FutureResult(value = ...future.value$value, 
[11:01:52.693]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.693]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.693]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.693]                     ...future.globalenv.names))
[11:01:52.693]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.693]         }, condition = base::local({
[11:01:52.693]             c <- base::c
[11:01:52.693]             inherits <- base::inherits
[11:01:52.693]             invokeRestart <- base::invokeRestart
[11:01:52.693]             length <- base::length
[11:01:52.693]             list <- base::list
[11:01:52.693]             seq.int <- base::seq.int
[11:01:52.693]             signalCondition <- base::signalCondition
[11:01:52.693]             sys.calls <- base::sys.calls
[11:01:52.693]             `[[` <- base::`[[`
[11:01:52.693]             `+` <- base::`+`
[11:01:52.693]             `<<-` <- base::`<<-`
[11:01:52.693]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.693]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.693]                   3L)]
[11:01:52.693]             }
[11:01:52.693]             function(cond) {
[11:01:52.693]                 is_error <- inherits(cond, "error")
[11:01:52.693]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.693]                   NULL)
[11:01:52.693]                 if (is_error) {
[11:01:52.693]                   sessionInformation <- function() {
[11:01:52.693]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.693]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.693]                       search = base::search(), system = base::Sys.info())
[11:01:52.693]                   }
[11:01:52.693]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.693]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.693]                     cond$call), session = sessionInformation(), 
[11:01:52.693]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.693]                   signalCondition(cond)
[11:01:52.693]                 }
[11:01:52.693]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.693]                 "immediateCondition"))) {
[11:01:52.693]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.693]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.693]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.693]                   if (TRUE && !signal) {
[11:01:52.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.693]                     {
[11:01:52.693]                       inherits <- base::inherits
[11:01:52.693]                       invokeRestart <- base::invokeRestart
[11:01:52.693]                       is.null <- base::is.null
[11:01:52.693]                       muffled <- FALSE
[11:01:52.693]                       if (inherits(cond, "message")) {
[11:01:52.693]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.693]                         if (muffled) 
[11:01:52.693]                           invokeRestart("muffleMessage")
[11:01:52.693]                       }
[11:01:52.693]                       else if (inherits(cond, "warning")) {
[11:01:52.693]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.693]                         if (muffled) 
[11:01:52.693]                           invokeRestart("muffleWarning")
[11:01:52.693]                       }
[11:01:52.693]                       else if (inherits(cond, "condition")) {
[11:01:52.693]                         if (!is.null(pattern)) {
[11:01:52.693]                           computeRestarts <- base::computeRestarts
[11:01:52.693]                           grepl <- base::grepl
[11:01:52.693]                           restarts <- computeRestarts(cond)
[11:01:52.693]                           for (restart in restarts) {
[11:01:52.693]                             name <- restart$name
[11:01:52.693]                             if (is.null(name)) 
[11:01:52.693]                               next
[11:01:52.693]                             if (!grepl(pattern, name)) 
[11:01:52.693]                               next
[11:01:52.693]                             invokeRestart(restart)
[11:01:52.693]                             muffled <- TRUE
[11:01:52.693]                             break
[11:01:52.693]                           }
[11:01:52.693]                         }
[11:01:52.693]                       }
[11:01:52.693]                       invisible(muffled)
[11:01:52.693]                     }
[11:01:52.693]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.693]                   }
[11:01:52.693]                 }
[11:01:52.693]                 else {
[11:01:52.693]                   if (TRUE) {
[11:01:52.693]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.693]                     {
[11:01:52.693]                       inherits <- base::inherits
[11:01:52.693]                       invokeRestart <- base::invokeRestart
[11:01:52.693]                       is.null <- base::is.null
[11:01:52.693]                       muffled <- FALSE
[11:01:52.693]                       if (inherits(cond, "message")) {
[11:01:52.693]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.693]                         if (muffled) 
[11:01:52.693]                           invokeRestart("muffleMessage")
[11:01:52.693]                       }
[11:01:52.693]                       else if (inherits(cond, "warning")) {
[11:01:52.693]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.693]                         if (muffled) 
[11:01:52.693]                           invokeRestart("muffleWarning")
[11:01:52.693]                       }
[11:01:52.693]                       else if (inherits(cond, "condition")) {
[11:01:52.693]                         if (!is.null(pattern)) {
[11:01:52.693]                           computeRestarts <- base::computeRestarts
[11:01:52.693]                           grepl <- base::grepl
[11:01:52.693]                           restarts <- computeRestarts(cond)
[11:01:52.693]                           for (restart in restarts) {
[11:01:52.693]                             name <- restart$name
[11:01:52.693]                             if (is.null(name)) 
[11:01:52.693]                               next
[11:01:52.693]                             if (!grepl(pattern, name)) 
[11:01:52.693]                               next
[11:01:52.693]                             invokeRestart(restart)
[11:01:52.693]                             muffled <- TRUE
[11:01:52.693]                             break
[11:01:52.693]                           }
[11:01:52.693]                         }
[11:01:52.693]                       }
[11:01:52.693]                       invisible(muffled)
[11:01:52.693]                     }
[11:01:52.693]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.693]                   }
[11:01:52.693]                 }
[11:01:52.693]             }
[11:01:52.693]         }))
[11:01:52.693]     }, error = function(ex) {
[11:01:52.693]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.693]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.693]                 ...future.rng), started = ...future.startTime, 
[11:01:52.693]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.693]             version = "1.8"), class = "FutureResult")
[11:01:52.693]     }, finally = {
[11:01:52.693]         if (!identical(...future.workdir, getwd())) 
[11:01:52.693]             setwd(...future.workdir)
[11:01:52.693]         {
[11:01:52.693]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.693]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.693]             }
[11:01:52.693]             base::options(...future.oldOptions)
[11:01:52.693]             if (.Platform$OS.type == "windows") {
[11:01:52.693]                 old_names <- names(...future.oldEnvVars)
[11:01:52.693]                 envs <- base::Sys.getenv()
[11:01:52.693]                 names <- names(envs)
[11:01:52.693]                 common <- intersect(names, old_names)
[11:01:52.693]                 added <- setdiff(names, old_names)
[11:01:52.693]                 removed <- setdiff(old_names, names)
[11:01:52.693]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.693]                   envs[common]]
[11:01:52.693]                 NAMES <- toupper(changed)
[11:01:52.693]                 args <- list()
[11:01:52.693]                 for (kk in seq_along(NAMES)) {
[11:01:52.693]                   name <- changed[[kk]]
[11:01:52.693]                   NAME <- NAMES[[kk]]
[11:01:52.693]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.693]                     next
[11:01:52.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.693]                 }
[11:01:52.693]                 NAMES <- toupper(added)
[11:01:52.693]                 for (kk in seq_along(NAMES)) {
[11:01:52.693]                   name <- added[[kk]]
[11:01:52.693]                   NAME <- NAMES[[kk]]
[11:01:52.693]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.693]                     next
[11:01:52.693]                   args[[name]] <- ""
[11:01:52.693]                 }
[11:01:52.693]                 NAMES <- toupper(removed)
[11:01:52.693]                 for (kk in seq_along(NAMES)) {
[11:01:52.693]                   name <- removed[[kk]]
[11:01:52.693]                   NAME <- NAMES[[kk]]
[11:01:52.693]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.693]                     next
[11:01:52.693]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.693]                 }
[11:01:52.693]                 if (length(args) > 0) 
[11:01:52.693]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.693]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.693]             }
[11:01:52.693]             else {
[11:01:52.693]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.693]             }
[11:01:52.693]             {
[11:01:52.693]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.693]                   0L) {
[11:01:52.693]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.693]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.693]                   base::options(opts)
[11:01:52.693]                 }
[11:01:52.693]                 {
[11:01:52.693]                   {
[11:01:52.693]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.693]                     NULL
[11:01:52.693]                   }
[11:01:52.693]                   options(future.plan = NULL)
[11:01:52.693]                   if (is.na(NA_character_)) 
[11:01:52.693]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.693]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.693]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.693]                     .init = FALSE)
[11:01:52.693]                 }
[11:01:52.693]             }
[11:01:52.693]         }
[11:01:52.693]     })
[11:01:52.693]     if (TRUE) {
[11:01:52.693]         base::sink(type = "output", split = FALSE)
[11:01:52.693]         if (TRUE) {
[11:01:52.693]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.693]         }
[11:01:52.693]         else {
[11:01:52.693]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.693]         }
[11:01:52.693]         base::close(...future.stdout)
[11:01:52.693]         ...future.stdout <- NULL
[11:01:52.693]     }
[11:01:52.693]     ...future.result$conditions <- ...future.conditions
[11:01:52.693]     ...future.result$finished <- base::Sys.time()
[11:01:52.693]     ...future.result
[11:01:52.693] }
[11:01:52.695] assign_globals() ...
[11:01:52.695] List of 1
[11:01:52.695]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eece1e30b0> 
[11:01:52.695]  - attr(*, "where")=List of 1
[11:01:52.695]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.695]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.695]  - attr(*, "resolved")= logi TRUE
[11:01:52.695]  - attr(*, "total_size")= num 3815
[11:01:52.695]  - attr(*, "already-done")= logi TRUE
[11:01:52.698] - copied ‘a’ to environment
[11:01:52.699] assign_globals() ... done
[11:01:52.699] requestCore(): workers = 2
[11:01:52.700] MulticoreFuture started
[11:01:52.701] - Launch lazy future ... done
[11:01:52.701] run() for ‘MulticoreFuture’ ... done
[11:01:52.701] result() for MulticoreFuture ...
[11:01:52.701] plan(): Setting new future strategy stack:
[11:01:52.702] List of future strategies:
[11:01:52.702] 1. sequential:
[11:01:52.702]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.702]    - tweaked: FALSE
[11:01:52.702]    - call: NULL
[11:01:52.703] plan(): nbrOfWorkers() = 1
[11:01:52.706] plan(): Setting new future strategy stack:
[11:01:52.706] List of future strategies:
[11:01:52.706] 1. multicore:
[11:01:52.706]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.706]    - tweaked: FALSE
[11:01:52.706]    - call: plan(strategy)
[11:01:52.709] plan(): nbrOfWorkers() = 2
[11:01:52.710] result() for MulticoreFuture ...
[11:01:52.710] result() for MulticoreFuture ... done
[11:01:52.710] signalConditions() ...
[11:01:52.710]  - include = ‘immediateCondition’
[11:01:52.710]  - exclude = 
[11:01:52.710]  - resignal = FALSE
[11:01:52.710]  - Number of conditions: 4
[11:01:52.710] signalConditions() ... done
[11:01:52.711] result() for MulticoreFuture ... done
[11:01:52.711] result() for MulticoreFuture ...
[11:01:52.711] result() for MulticoreFuture ... done
[11:01:52.711] signalConditions() ...
[11:01:52.711]  - include = ‘immediateCondition’
[11:01:52.711]  - exclude = 
[11:01:52.711]  - resignal = FALSE
[11:01:52.711]  - Number of conditions: 4
[11:01:52.712] signalConditions() ... done
[11:01:52.712] Future state: ‘finished’
[11:01:52.712] result() for MulticoreFuture ...
[11:01:52.712] result() for MulticoreFuture ... done
[11:01:52.712] signalConditions() ...
[11:01:52.712]  - include = ‘condition’
[11:01:52.712]  - exclude = ‘immediateCondition’
[11:01:52.712]  - resignal = TRUE
[11:01:52.712]  - Number of conditions: 4
[11:01:52.713]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.704] result() for MulticoreFuture ...
[11:01:52.713]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.704] result() for MulticoreFuture ... done
[11:01:52.713]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.704] result() for MulticoreFuture ...
[11:01:52.713]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.705] result() for MulticoreFuture ... done
[11:01:52.713] signalConditions() ... done
value(b) = 2
[11:01:52.713] result() for MulticoreFuture ...
[11:01:52.714] result() for MulticoreFuture ... done
[11:01:52.714] result() for MulticoreFuture ...
[11:01:52.714] result() for MulticoreFuture ... done
[11:01:52.714] signalConditions() ...
[11:01:52.714]  - include = ‘immediateCondition’
[11:01:52.714]  - exclude = 
[11:01:52.714]  - resignal = FALSE
[11:01:52.714]  - Number of conditions: 4
[11:01:52.714] signalConditions() ... done
[11:01:52.714] Future state: ‘finished’
[11:01:52.715] result() for MulticoreFuture ...
[11:01:52.715] result() for MulticoreFuture ... done
[11:01:52.715] signalConditions() ...
[11:01:52.715]  - include = ‘condition’
[11:01:52.715]  - exclude = ‘immediateCondition’
[11:01:52.715]  - resignal = TRUE
[11:01:52.715]  - Number of conditions: 4
[11:01:52.715]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.704] result() for MulticoreFuture ...
[11:01:52.716]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.704] result() for MulticoreFuture ... done
[11:01:52.716]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.704] result() for MulticoreFuture ...
[11:01:52.716]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.705] result() for MulticoreFuture ... done
[11:01:52.716] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.716] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.717] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.717] 
[11:01:52.717] Searching for globals ... DONE
[11:01:52.718] - globals: [0] <none>
[11:01:52.718] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.718] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.718] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.722] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.722] Searching for globals ... DONE
[11:01:52.722] Resolving globals: TRUE
[11:01:52.722] Resolving any globals that are futures ...
[11:01:52.722] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.723] Resolving any globals that are futures ... DONE
[11:01:52.723] Resolving futures part of globals (recursively) ...
[11:01:52.723] resolve() on list ...
[11:01:52.723]  recursive: 99
[11:01:52.724]  length: 1
[11:01:52.724]  elements: ‘a’
[11:01:52.724] run() for ‘Future’ ...
[11:01:52.724] - state: ‘created’
[11:01:52.724] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.726] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.726] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.726]   - Field: ‘label’
[11:01:52.727]   - Field: ‘local’
[11:01:52.727]   - Field: ‘owner’
[11:01:52.727]   - Field: ‘envir’
[11:01:52.727]   - Field: ‘workers’
[11:01:52.727]   - Field: ‘packages’
[11:01:52.727]   - Field: ‘gc’
[11:01:52.727]   - Field: ‘job’
[11:01:52.727]   - Field: ‘conditions’
[11:01:52.727]   - Field: ‘expr’
[11:01:52.728]   - Field: ‘uuid’
[11:01:52.728]   - Field: ‘seed’
[11:01:52.728]   - Field: ‘version’
[11:01:52.728]   - Field: ‘result’
[11:01:52.728]   - Field: ‘asynchronous’
[11:01:52.728]   - Field: ‘calls’
[11:01:52.728]   - Field: ‘globals’
[11:01:52.728]   - Field: ‘stdout’
[11:01:52.728]   - Field: ‘earlySignal’
[11:01:52.729]   - Field: ‘lazy’
[11:01:52.729]   - Field: ‘state’
[11:01:52.729] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.729] - Launch lazy future ...
[11:01:52.729] Packages needed by the future expression (n = 0): <none>
[11:01:52.729] Packages needed by future strategies (n = 0): <none>
[11:01:52.730] {
[11:01:52.730]     {
[11:01:52.730]         {
[11:01:52.730]             ...future.startTime <- base::Sys.time()
[11:01:52.730]             {
[11:01:52.730]                 {
[11:01:52.730]                   {
[11:01:52.730]                     {
[11:01:52.730]                       base::local({
[11:01:52.730]                         has_future <- base::requireNamespace("future", 
[11:01:52.730]                           quietly = TRUE)
[11:01:52.730]                         if (has_future) {
[11:01:52.730]                           ns <- base::getNamespace("future")
[11:01:52.730]                           version <- ns[[".package"]][["version"]]
[11:01:52.730]                           if (is.null(version)) 
[11:01:52.730]                             version <- utils::packageVersion("future")
[11:01:52.730]                         }
[11:01:52.730]                         else {
[11:01:52.730]                           version <- NULL
[11:01:52.730]                         }
[11:01:52.730]                         if (!has_future || version < "1.8.0") {
[11:01:52.730]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.730]                             "", base::R.version$version.string), 
[11:01:52.730]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.730]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.730]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.730]                               "release", "version")], collapse = " "), 
[11:01:52.730]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.730]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.730]                             info)
[11:01:52.730]                           info <- base::paste(info, collapse = "; ")
[11:01:52.730]                           if (!has_future) {
[11:01:52.730]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.730]                               info)
[11:01:52.730]                           }
[11:01:52.730]                           else {
[11:01:52.730]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.730]                               info, version)
[11:01:52.730]                           }
[11:01:52.730]                           base::stop(msg)
[11:01:52.730]                         }
[11:01:52.730]                       })
[11:01:52.730]                     }
[11:01:52.730]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.730]                     base::options(mc.cores = 1L)
[11:01:52.730]                   }
[11:01:52.730]                   ...future.strategy.old <- future::plan("list")
[11:01:52.730]                   options(future.plan = NULL)
[11:01:52.730]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.730]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.730]                 }
[11:01:52.730]                 ...future.workdir <- getwd()
[11:01:52.730]             }
[11:01:52.730]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.730]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.730]         }
[11:01:52.730]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.730]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.730]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.730]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.730]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.730]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.730]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.730]             base::names(...future.oldOptions))
[11:01:52.730]     }
[11:01:52.730]     if (FALSE) {
[11:01:52.730]     }
[11:01:52.730]     else {
[11:01:52.730]         if (TRUE) {
[11:01:52.730]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.730]                 open = "w")
[11:01:52.730]         }
[11:01:52.730]         else {
[11:01:52.730]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.730]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.730]         }
[11:01:52.730]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.730]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.730]             base::sink(type = "output", split = FALSE)
[11:01:52.730]             base::close(...future.stdout)
[11:01:52.730]         }, add = TRUE)
[11:01:52.730]     }
[11:01:52.730]     ...future.frame <- base::sys.nframe()
[11:01:52.730]     ...future.conditions <- base::list()
[11:01:52.730]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.730]     if (FALSE) {
[11:01:52.730]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.730]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.730]     }
[11:01:52.730]     ...future.result <- base::tryCatch({
[11:01:52.730]         base::withCallingHandlers({
[11:01:52.730]             ...future.value <- base::withVisible(base::local({
[11:01:52.730]                 withCallingHandlers({
[11:01:52.730]                   1
[11:01:52.730]                 }, immediateCondition = function(cond) {
[11:01:52.730]                   save_rds <- function (object, pathname, ...) 
[11:01:52.730]                   {
[11:01:52.730]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.730]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.730]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.730]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.730]                         fi_tmp[["mtime"]])
[11:01:52.730]                     }
[11:01:52.730]                     tryCatch({
[11:01:52.730]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.730]                     }, error = function(ex) {
[11:01:52.730]                       msg <- conditionMessage(ex)
[11:01:52.730]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.730]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.730]                         fi_tmp[["mtime"]], msg)
[11:01:52.730]                       ex$message <- msg
[11:01:52.730]                       stop(ex)
[11:01:52.730]                     })
[11:01:52.730]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.730]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.730]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.730]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.730]                       fi <- file.info(pathname)
[11:01:52.730]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.730]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.730]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.730]                         fi[["size"]], fi[["mtime"]])
[11:01:52.730]                       stop(msg)
[11:01:52.730]                     }
[11:01:52.730]                     invisible(pathname)
[11:01:52.730]                   }
[11:01:52.730]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.730]                     rootPath = tempdir()) 
[11:01:52.730]                   {
[11:01:52.730]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.730]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.730]                       tmpdir = path, fileext = ".rds")
[11:01:52.730]                     save_rds(obj, file)
[11:01:52.730]                   }
[11:01:52.730]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.730]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.730]                   {
[11:01:52.730]                     inherits <- base::inherits
[11:01:52.730]                     invokeRestart <- base::invokeRestart
[11:01:52.730]                     is.null <- base::is.null
[11:01:52.730]                     muffled <- FALSE
[11:01:52.730]                     if (inherits(cond, "message")) {
[11:01:52.730]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.730]                       if (muffled) 
[11:01:52.730]                         invokeRestart("muffleMessage")
[11:01:52.730]                     }
[11:01:52.730]                     else if (inherits(cond, "warning")) {
[11:01:52.730]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.730]                       if (muffled) 
[11:01:52.730]                         invokeRestart("muffleWarning")
[11:01:52.730]                     }
[11:01:52.730]                     else if (inherits(cond, "condition")) {
[11:01:52.730]                       if (!is.null(pattern)) {
[11:01:52.730]                         computeRestarts <- base::computeRestarts
[11:01:52.730]                         grepl <- base::grepl
[11:01:52.730]                         restarts <- computeRestarts(cond)
[11:01:52.730]                         for (restart in restarts) {
[11:01:52.730]                           name <- restart$name
[11:01:52.730]                           if (is.null(name)) 
[11:01:52.730]                             next
[11:01:52.730]                           if (!grepl(pattern, name)) 
[11:01:52.730]                             next
[11:01:52.730]                           invokeRestart(restart)
[11:01:52.730]                           muffled <- TRUE
[11:01:52.730]                           break
[11:01:52.730]                         }
[11:01:52.730]                       }
[11:01:52.730]                     }
[11:01:52.730]                     invisible(muffled)
[11:01:52.730]                   }
[11:01:52.730]                   muffleCondition(cond)
[11:01:52.730]                 })
[11:01:52.730]             }))
[11:01:52.730]             future::FutureResult(value = ...future.value$value, 
[11:01:52.730]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.730]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.730]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.730]                     ...future.globalenv.names))
[11:01:52.730]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.730]         }, condition = base::local({
[11:01:52.730]             c <- base::c
[11:01:52.730]             inherits <- base::inherits
[11:01:52.730]             invokeRestart <- base::invokeRestart
[11:01:52.730]             length <- base::length
[11:01:52.730]             list <- base::list
[11:01:52.730]             seq.int <- base::seq.int
[11:01:52.730]             signalCondition <- base::signalCondition
[11:01:52.730]             sys.calls <- base::sys.calls
[11:01:52.730]             `[[` <- base::`[[`
[11:01:52.730]             `+` <- base::`+`
[11:01:52.730]             `<<-` <- base::`<<-`
[11:01:52.730]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.730]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.730]                   3L)]
[11:01:52.730]             }
[11:01:52.730]             function(cond) {
[11:01:52.730]                 is_error <- inherits(cond, "error")
[11:01:52.730]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.730]                   NULL)
[11:01:52.730]                 if (is_error) {
[11:01:52.730]                   sessionInformation <- function() {
[11:01:52.730]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.730]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.730]                       search = base::search(), system = base::Sys.info())
[11:01:52.730]                   }
[11:01:52.730]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.730]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.730]                     cond$call), session = sessionInformation(), 
[11:01:52.730]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.730]                   signalCondition(cond)
[11:01:52.730]                 }
[11:01:52.730]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.730]                 "immediateCondition"))) {
[11:01:52.730]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.730]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.730]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.730]                   if (TRUE && !signal) {
[11:01:52.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.730]                     {
[11:01:52.730]                       inherits <- base::inherits
[11:01:52.730]                       invokeRestart <- base::invokeRestart
[11:01:52.730]                       is.null <- base::is.null
[11:01:52.730]                       muffled <- FALSE
[11:01:52.730]                       if (inherits(cond, "message")) {
[11:01:52.730]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.730]                         if (muffled) 
[11:01:52.730]                           invokeRestart("muffleMessage")
[11:01:52.730]                       }
[11:01:52.730]                       else if (inherits(cond, "warning")) {
[11:01:52.730]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.730]                         if (muffled) 
[11:01:52.730]                           invokeRestart("muffleWarning")
[11:01:52.730]                       }
[11:01:52.730]                       else if (inherits(cond, "condition")) {
[11:01:52.730]                         if (!is.null(pattern)) {
[11:01:52.730]                           computeRestarts <- base::computeRestarts
[11:01:52.730]                           grepl <- base::grepl
[11:01:52.730]                           restarts <- computeRestarts(cond)
[11:01:52.730]                           for (restart in restarts) {
[11:01:52.730]                             name <- restart$name
[11:01:52.730]                             if (is.null(name)) 
[11:01:52.730]                               next
[11:01:52.730]                             if (!grepl(pattern, name)) 
[11:01:52.730]                               next
[11:01:52.730]                             invokeRestart(restart)
[11:01:52.730]                             muffled <- TRUE
[11:01:52.730]                             break
[11:01:52.730]                           }
[11:01:52.730]                         }
[11:01:52.730]                       }
[11:01:52.730]                       invisible(muffled)
[11:01:52.730]                     }
[11:01:52.730]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.730]                   }
[11:01:52.730]                 }
[11:01:52.730]                 else {
[11:01:52.730]                   if (TRUE) {
[11:01:52.730]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.730]                     {
[11:01:52.730]                       inherits <- base::inherits
[11:01:52.730]                       invokeRestart <- base::invokeRestart
[11:01:52.730]                       is.null <- base::is.null
[11:01:52.730]                       muffled <- FALSE
[11:01:52.730]                       if (inherits(cond, "message")) {
[11:01:52.730]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.730]                         if (muffled) 
[11:01:52.730]                           invokeRestart("muffleMessage")
[11:01:52.730]                       }
[11:01:52.730]                       else if (inherits(cond, "warning")) {
[11:01:52.730]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.730]                         if (muffled) 
[11:01:52.730]                           invokeRestart("muffleWarning")
[11:01:52.730]                       }
[11:01:52.730]                       else if (inherits(cond, "condition")) {
[11:01:52.730]                         if (!is.null(pattern)) {
[11:01:52.730]                           computeRestarts <- base::computeRestarts
[11:01:52.730]                           grepl <- base::grepl
[11:01:52.730]                           restarts <- computeRestarts(cond)
[11:01:52.730]                           for (restart in restarts) {
[11:01:52.730]                             name <- restart$name
[11:01:52.730]                             if (is.null(name)) 
[11:01:52.730]                               next
[11:01:52.730]                             if (!grepl(pattern, name)) 
[11:01:52.730]                               next
[11:01:52.730]                             invokeRestart(restart)
[11:01:52.730]                             muffled <- TRUE
[11:01:52.730]                             break
[11:01:52.730]                           }
[11:01:52.730]                         }
[11:01:52.730]                       }
[11:01:52.730]                       invisible(muffled)
[11:01:52.730]                     }
[11:01:52.730]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.730]                   }
[11:01:52.730]                 }
[11:01:52.730]             }
[11:01:52.730]         }))
[11:01:52.730]     }, error = function(ex) {
[11:01:52.730]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.730]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.730]                 ...future.rng), started = ...future.startTime, 
[11:01:52.730]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.730]             version = "1.8"), class = "FutureResult")
[11:01:52.730]     }, finally = {
[11:01:52.730]         if (!identical(...future.workdir, getwd())) 
[11:01:52.730]             setwd(...future.workdir)
[11:01:52.730]         {
[11:01:52.730]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.730]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.730]             }
[11:01:52.730]             base::options(...future.oldOptions)
[11:01:52.730]             if (.Platform$OS.type == "windows") {
[11:01:52.730]                 old_names <- names(...future.oldEnvVars)
[11:01:52.730]                 envs <- base::Sys.getenv()
[11:01:52.730]                 names <- names(envs)
[11:01:52.730]                 common <- intersect(names, old_names)
[11:01:52.730]                 added <- setdiff(names, old_names)
[11:01:52.730]                 removed <- setdiff(old_names, names)
[11:01:52.730]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.730]                   envs[common]]
[11:01:52.730]                 NAMES <- toupper(changed)
[11:01:52.730]                 args <- list()
[11:01:52.730]                 for (kk in seq_along(NAMES)) {
[11:01:52.730]                   name <- changed[[kk]]
[11:01:52.730]                   NAME <- NAMES[[kk]]
[11:01:52.730]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.730]                     next
[11:01:52.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.730]                 }
[11:01:52.730]                 NAMES <- toupper(added)
[11:01:52.730]                 for (kk in seq_along(NAMES)) {
[11:01:52.730]                   name <- added[[kk]]
[11:01:52.730]                   NAME <- NAMES[[kk]]
[11:01:52.730]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.730]                     next
[11:01:52.730]                   args[[name]] <- ""
[11:01:52.730]                 }
[11:01:52.730]                 NAMES <- toupper(removed)
[11:01:52.730]                 for (kk in seq_along(NAMES)) {
[11:01:52.730]                   name <- removed[[kk]]
[11:01:52.730]                   NAME <- NAMES[[kk]]
[11:01:52.730]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.730]                     next
[11:01:52.730]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.730]                 }
[11:01:52.730]                 if (length(args) > 0) 
[11:01:52.730]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.730]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.730]             }
[11:01:52.730]             else {
[11:01:52.730]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.730]             }
[11:01:52.730]             {
[11:01:52.730]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.730]                   0L) {
[11:01:52.730]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.730]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.730]                   base::options(opts)
[11:01:52.730]                 }
[11:01:52.730]                 {
[11:01:52.730]                   {
[11:01:52.730]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.730]                     NULL
[11:01:52.730]                   }
[11:01:52.730]                   options(future.plan = NULL)
[11:01:52.730]                   if (is.na(NA_character_)) 
[11:01:52.730]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.730]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.730]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.730]                     .init = FALSE)
[11:01:52.730]                 }
[11:01:52.730]             }
[11:01:52.730]         }
[11:01:52.730]     })
[11:01:52.730]     if (TRUE) {
[11:01:52.730]         base::sink(type = "output", split = FALSE)
[11:01:52.730]         if (TRUE) {
[11:01:52.730]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.730]         }
[11:01:52.730]         else {
[11:01:52.730]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.730]         }
[11:01:52.730]         base::close(...future.stdout)
[11:01:52.730]         ...future.stdout <- NULL
[11:01:52.730]     }
[11:01:52.730]     ...future.result$conditions <- ...future.conditions
[11:01:52.730]     ...future.result$finished <- base::Sys.time()
[11:01:52.730]     ...future.result
[11:01:52.730] }
[11:01:52.732] requestCore(): workers = 2
[11:01:52.734] MulticoreFuture started
[11:01:52.734] - Launch lazy future ... done
[11:01:52.734] run() for ‘MulticoreFuture’ ... done
[11:01:52.735] plan(): Setting new future strategy stack:
[11:01:52.735] List of future strategies:
[11:01:52.735] 1. sequential:
[11:01:52.735]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.735]    - tweaked: FALSE
[11:01:52.735]    - call: NULL
[11:01:52.736] plan(): nbrOfWorkers() = 1
[11:01:52.738] plan(): Setting new future strategy stack:
[11:01:52.738] List of future strategies:
[11:01:52.738] 1. multicore:
[11:01:52.738]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.738]    - tweaked: FALSE
[11:01:52.738]    - call: plan(strategy)
[11:01:52.741] plan(): nbrOfWorkers() = 2
[11:01:52.742] Future #1
[11:01:52.742] result() for MulticoreFuture ...
[11:01:52.743] result() for MulticoreFuture ...
[11:01:52.743] result() for MulticoreFuture ... done
[11:01:52.743] result() for MulticoreFuture ... done
[11:01:52.744] result() for MulticoreFuture ...
[11:01:52.744] result() for MulticoreFuture ... done
[11:01:52.744] A MulticoreFuture was resolved
[11:01:52.744]  length: 0 (resolved future 1)
[11:01:52.744] resolve() on list ... DONE
[11:01:52.744] - globals: [1] ‘a’
[11:01:52.744] Resolving futures part of globals (recursively) ... DONE
[11:01:52.745] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[11:01:52.745] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[11:01:52.745] - globals: [1] ‘a’
[11:01:52.745] - packages: [1] ‘future’
[11:01:52.746] getGlobalsAndPackages() ... DONE
[11:01:52.746] run() for ‘Future’ ...
[11:01:52.746] - state: ‘created’
[11:01:52.746] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.748] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.748] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.749]   - Field: ‘label’
[11:01:52.749]   - Field: ‘local’
[11:01:52.749]   - Field: ‘owner’
[11:01:52.749]   - Field: ‘envir’
[11:01:52.749]   - Field: ‘workers’
[11:01:52.749]   - Field: ‘packages’
[11:01:52.749]   - Field: ‘gc’
[11:01:52.749]   - Field: ‘job’
[11:01:52.749]   - Field: ‘conditions’
[11:01:52.750]   - Field: ‘expr’
[11:01:52.750]   - Field: ‘uuid’
[11:01:52.750]   - Field: ‘seed’
[11:01:52.750]   - Field: ‘version’
[11:01:52.750]   - Field: ‘result’
[11:01:52.750]   - Field: ‘asynchronous’
[11:01:52.750]   - Field: ‘calls’
[11:01:52.750]   - Field: ‘globals’
[11:01:52.750]   - Field: ‘stdout’
[11:01:52.751]   - Field: ‘earlySignal’
[11:01:52.751]   - Field: ‘lazy’
[11:01:52.751]   - Field: ‘state’
[11:01:52.751] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.751] - Launch lazy future ...
[11:01:52.751] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.751] Packages needed by future strategies (n = 0): <none>
[11:01:52.752] {
[11:01:52.752]     {
[11:01:52.752]         {
[11:01:52.752]             ...future.startTime <- base::Sys.time()
[11:01:52.752]             {
[11:01:52.752]                 {
[11:01:52.752]                   {
[11:01:52.752]                     {
[11:01:52.752]                       {
[11:01:52.752]                         base::local({
[11:01:52.752]                           has_future <- base::requireNamespace("future", 
[11:01:52.752]                             quietly = TRUE)
[11:01:52.752]                           if (has_future) {
[11:01:52.752]                             ns <- base::getNamespace("future")
[11:01:52.752]                             version <- ns[[".package"]][["version"]]
[11:01:52.752]                             if (is.null(version)) 
[11:01:52.752]                               version <- utils::packageVersion("future")
[11:01:52.752]                           }
[11:01:52.752]                           else {
[11:01:52.752]                             version <- NULL
[11:01:52.752]                           }
[11:01:52.752]                           if (!has_future || version < "1.8.0") {
[11:01:52.752]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.752]                               "", base::R.version$version.string), 
[11:01:52.752]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:52.752]                                 base::R.version$platform, 8 * 
[11:01:52.752]                                   base::.Machine$sizeof.pointer), 
[11:01:52.752]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.752]                                 "release", "version")], collapse = " "), 
[11:01:52.752]                               hostname = base::Sys.info()[["nodename"]])
[11:01:52.752]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.752]                               info)
[11:01:52.752]                             info <- base::paste(info, collapse = "; ")
[11:01:52.752]                             if (!has_future) {
[11:01:52.752]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.752]                                 info)
[11:01:52.752]                             }
[11:01:52.752]                             else {
[11:01:52.752]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.752]                                 info, version)
[11:01:52.752]                             }
[11:01:52.752]                             base::stop(msg)
[11:01:52.752]                           }
[11:01:52.752]                         })
[11:01:52.752]                       }
[11:01:52.752]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.752]                       base::options(mc.cores = 1L)
[11:01:52.752]                     }
[11:01:52.752]                     base::local({
[11:01:52.752]                       for (pkg in "future") {
[11:01:52.752]                         base::loadNamespace(pkg)
[11:01:52.752]                         base::library(pkg, character.only = TRUE)
[11:01:52.752]                       }
[11:01:52.752]                     })
[11:01:52.752]                   }
[11:01:52.752]                   ...future.strategy.old <- future::plan("list")
[11:01:52.752]                   options(future.plan = NULL)
[11:01:52.752]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.752]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.752]                 }
[11:01:52.752]                 ...future.workdir <- getwd()
[11:01:52.752]             }
[11:01:52.752]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.752]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.752]         }
[11:01:52.752]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.752]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.752]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.752]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.752]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.752]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.752]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.752]             base::names(...future.oldOptions))
[11:01:52.752]     }
[11:01:52.752]     if (FALSE) {
[11:01:52.752]     }
[11:01:52.752]     else {
[11:01:52.752]         if (TRUE) {
[11:01:52.752]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.752]                 open = "w")
[11:01:52.752]         }
[11:01:52.752]         else {
[11:01:52.752]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.752]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.752]         }
[11:01:52.752]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.752]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.752]             base::sink(type = "output", split = FALSE)
[11:01:52.752]             base::close(...future.stdout)
[11:01:52.752]         }, add = TRUE)
[11:01:52.752]     }
[11:01:52.752]     ...future.frame <- base::sys.nframe()
[11:01:52.752]     ...future.conditions <- base::list()
[11:01:52.752]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.752]     if (FALSE) {
[11:01:52.752]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.752]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.752]     }
[11:01:52.752]     ...future.result <- base::tryCatch({
[11:01:52.752]         base::withCallingHandlers({
[11:01:52.752]             ...future.value <- base::withVisible(base::local({
[11:01:52.752]                 withCallingHandlers({
[11:01:52.752]                   value(a) + 1
[11:01:52.752]                 }, immediateCondition = function(cond) {
[11:01:52.752]                   save_rds <- function (object, pathname, ...) 
[11:01:52.752]                   {
[11:01:52.752]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.752]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.752]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.752]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.752]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.752]                         fi_tmp[["mtime"]])
[11:01:52.752]                     }
[11:01:52.752]                     tryCatch({
[11:01:52.752]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.752]                     }, error = function(ex) {
[11:01:52.752]                       msg <- conditionMessage(ex)
[11:01:52.752]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.752]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.752]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.752]                         fi_tmp[["mtime"]], msg)
[11:01:52.752]                       ex$message <- msg
[11:01:52.752]                       stop(ex)
[11:01:52.752]                     })
[11:01:52.752]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.752]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.752]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.752]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.752]                       fi <- file.info(pathname)
[11:01:52.752]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.752]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.752]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.752]                         fi[["size"]], fi[["mtime"]])
[11:01:52.752]                       stop(msg)
[11:01:52.752]                     }
[11:01:52.752]                     invisible(pathname)
[11:01:52.752]                   }
[11:01:52.752]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.752]                     rootPath = tempdir()) 
[11:01:52.752]                   {
[11:01:52.752]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.752]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.752]                       tmpdir = path, fileext = ".rds")
[11:01:52.752]                     save_rds(obj, file)
[11:01:52.752]                   }
[11:01:52.752]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.752]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.752]                   {
[11:01:52.752]                     inherits <- base::inherits
[11:01:52.752]                     invokeRestart <- base::invokeRestart
[11:01:52.752]                     is.null <- base::is.null
[11:01:52.752]                     muffled <- FALSE
[11:01:52.752]                     if (inherits(cond, "message")) {
[11:01:52.752]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.752]                       if (muffled) 
[11:01:52.752]                         invokeRestart("muffleMessage")
[11:01:52.752]                     }
[11:01:52.752]                     else if (inherits(cond, "warning")) {
[11:01:52.752]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.752]                       if (muffled) 
[11:01:52.752]                         invokeRestart("muffleWarning")
[11:01:52.752]                     }
[11:01:52.752]                     else if (inherits(cond, "condition")) {
[11:01:52.752]                       if (!is.null(pattern)) {
[11:01:52.752]                         computeRestarts <- base::computeRestarts
[11:01:52.752]                         grepl <- base::grepl
[11:01:52.752]                         restarts <- computeRestarts(cond)
[11:01:52.752]                         for (restart in restarts) {
[11:01:52.752]                           name <- restart$name
[11:01:52.752]                           if (is.null(name)) 
[11:01:52.752]                             next
[11:01:52.752]                           if (!grepl(pattern, name)) 
[11:01:52.752]                             next
[11:01:52.752]                           invokeRestart(restart)
[11:01:52.752]                           muffled <- TRUE
[11:01:52.752]                           break
[11:01:52.752]                         }
[11:01:52.752]                       }
[11:01:52.752]                     }
[11:01:52.752]                     invisible(muffled)
[11:01:52.752]                   }
[11:01:52.752]                   muffleCondition(cond)
[11:01:52.752]                 })
[11:01:52.752]             }))
[11:01:52.752]             future::FutureResult(value = ...future.value$value, 
[11:01:52.752]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.752]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.752]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.752]                     ...future.globalenv.names))
[11:01:52.752]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.752]         }, condition = base::local({
[11:01:52.752]             c <- base::c
[11:01:52.752]             inherits <- base::inherits
[11:01:52.752]             invokeRestart <- base::invokeRestart
[11:01:52.752]             length <- base::length
[11:01:52.752]             list <- base::list
[11:01:52.752]             seq.int <- base::seq.int
[11:01:52.752]             signalCondition <- base::signalCondition
[11:01:52.752]             sys.calls <- base::sys.calls
[11:01:52.752]             `[[` <- base::`[[`
[11:01:52.752]             `+` <- base::`+`
[11:01:52.752]             `<<-` <- base::`<<-`
[11:01:52.752]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.752]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.752]                   3L)]
[11:01:52.752]             }
[11:01:52.752]             function(cond) {
[11:01:52.752]                 is_error <- inherits(cond, "error")
[11:01:52.752]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.752]                   NULL)
[11:01:52.752]                 if (is_error) {
[11:01:52.752]                   sessionInformation <- function() {
[11:01:52.752]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.752]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.752]                       search = base::search(), system = base::Sys.info())
[11:01:52.752]                   }
[11:01:52.752]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.752]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.752]                     cond$call), session = sessionInformation(), 
[11:01:52.752]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.752]                   signalCondition(cond)
[11:01:52.752]                 }
[11:01:52.752]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.752]                 "immediateCondition"))) {
[11:01:52.752]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.752]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.752]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.752]                   if (TRUE && !signal) {
[11:01:52.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.752]                     {
[11:01:52.752]                       inherits <- base::inherits
[11:01:52.752]                       invokeRestart <- base::invokeRestart
[11:01:52.752]                       is.null <- base::is.null
[11:01:52.752]                       muffled <- FALSE
[11:01:52.752]                       if (inherits(cond, "message")) {
[11:01:52.752]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.752]                         if (muffled) 
[11:01:52.752]                           invokeRestart("muffleMessage")
[11:01:52.752]                       }
[11:01:52.752]                       else if (inherits(cond, "warning")) {
[11:01:52.752]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.752]                         if (muffled) 
[11:01:52.752]                           invokeRestart("muffleWarning")
[11:01:52.752]                       }
[11:01:52.752]                       else if (inherits(cond, "condition")) {
[11:01:52.752]                         if (!is.null(pattern)) {
[11:01:52.752]                           computeRestarts <- base::computeRestarts
[11:01:52.752]                           grepl <- base::grepl
[11:01:52.752]                           restarts <- computeRestarts(cond)
[11:01:52.752]                           for (restart in restarts) {
[11:01:52.752]                             name <- restart$name
[11:01:52.752]                             if (is.null(name)) 
[11:01:52.752]                               next
[11:01:52.752]                             if (!grepl(pattern, name)) 
[11:01:52.752]                               next
[11:01:52.752]                             invokeRestart(restart)
[11:01:52.752]                             muffled <- TRUE
[11:01:52.752]                             break
[11:01:52.752]                           }
[11:01:52.752]                         }
[11:01:52.752]                       }
[11:01:52.752]                       invisible(muffled)
[11:01:52.752]                     }
[11:01:52.752]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.752]                   }
[11:01:52.752]                 }
[11:01:52.752]                 else {
[11:01:52.752]                   if (TRUE) {
[11:01:52.752]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.752]                     {
[11:01:52.752]                       inherits <- base::inherits
[11:01:52.752]                       invokeRestart <- base::invokeRestart
[11:01:52.752]                       is.null <- base::is.null
[11:01:52.752]                       muffled <- FALSE
[11:01:52.752]                       if (inherits(cond, "message")) {
[11:01:52.752]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.752]                         if (muffled) 
[11:01:52.752]                           invokeRestart("muffleMessage")
[11:01:52.752]                       }
[11:01:52.752]                       else if (inherits(cond, "warning")) {
[11:01:52.752]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.752]                         if (muffled) 
[11:01:52.752]                           invokeRestart("muffleWarning")
[11:01:52.752]                       }
[11:01:52.752]                       else if (inherits(cond, "condition")) {
[11:01:52.752]                         if (!is.null(pattern)) {
[11:01:52.752]                           computeRestarts <- base::computeRestarts
[11:01:52.752]                           grepl <- base::grepl
[11:01:52.752]                           restarts <- computeRestarts(cond)
[11:01:52.752]                           for (restart in restarts) {
[11:01:52.752]                             name <- restart$name
[11:01:52.752]                             if (is.null(name)) 
[11:01:52.752]                               next
[11:01:52.752]                             if (!grepl(pattern, name)) 
[11:01:52.752]                               next
[11:01:52.752]                             invokeRestart(restart)
[11:01:52.752]                             muffled <- TRUE
[11:01:52.752]                             break
[11:01:52.752]                           }
[11:01:52.752]                         }
[11:01:52.752]                       }
[11:01:52.752]                       invisible(muffled)
[11:01:52.752]                     }
[11:01:52.752]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.752]                   }
[11:01:52.752]                 }
[11:01:52.752]             }
[11:01:52.752]         }))
[11:01:52.752]     }, error = function(ex) {
[11:01:52.752]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.752]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.752]                 ...future.rng), started = ...future.startTime, 
[11:01:52.752]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.752]             version = "1.8"), class = "FutureResult")
[11:01:52.752]     }, finally = {
[11:01:52.752]         if (!identical(...future.workdir, getwd())) 
[11:01:52.752]             setwd(...future.workdir)
[11:01:52.752]         {
[11:01:52.752]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.752]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.752]             }
[11:01:52.752]             base::options(...future.oldOptions)
[11:01:52.752]             if (.Platform$OS.type == "windows") {
[11:01:52.752]                 old_names <- names(...future.oldEnvVars)
[11:01:52.752]                 envs <- base::Sys.getenv()
[11:01:52.752]                 names <- names(envs)
[11:01:52.752]                 common <- intersect(names, old_names)
[11:01:52.752]                 added <- setdiff(names, old_names)
[11:01:52.752]                 removed <- setdiff(old_names, names)
[11:01:52.752]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.752]                   envs[common]]
[11:01:52.752]                 NAMES <- toupper(changed)
[11:01:52.752]                 args <- list()
[11:01:52.752]                 for (kk in seq_along(NAMES)) {
[11:01:52.752]                   name <- changed[[kk]]
[11:01:52.752]                   NAME <- NAMES[[kk]]
[11:01:52.752]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.752]                     next
[11:01:52.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.752]                 }
[11:01:52.752]                 NAMES <- toupper(added)
[11:01:52.752]                 for (kk in seq_along(NAMES)) {
[11:01:52.752]                   name <- added[[kk]]
[11:01:52.752]                   NAME <- NAMES[[kk]]
[11:01:52.752]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.752]                     next
[11:01:52.752]                   args[[name]] <- ""
[11:01:52.752]                 }
[11:01:52.752]                 NAMES <- toupper(removed)
[11:01:52.752]                 for (kk in seq_along(NAMES)) {
[11:01:52.752]                   name <- removed[[kk]]
[11:01:52.752]                   NAME <- NAMES[[kk]]
[11:01:52.752]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.752]                     next
[11:01:52.752]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.752]                 }
[11:01:52.752]                 if (length(args) > 0) 
[11:01:52.752]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.752]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.752]             }
[11:01:52.752]             else {
[11:01:52.752]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.752]             }
[11:01:52.752]             {
[11:01:52.752]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.752]                   0L) {
[11:01:52.752]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.752]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.752]                   base::options(opts)
[11:01:52.752]                 }
[11:01:52.752]                 {
[11:01:52.752]                   {
[11:01:52.752]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.752]                     NULL
[11:01:52.752]                   }
[11:01:52.752]                   options(future.plan = NULL)
[11:01:52.752]                   if (is.na(NA_character_)) 
[11:01:52.752]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.752]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.752]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.752]                     .init = FALSE)
[11:01:52.752]                 }
[11:01:52.752]             }
[11:01:52.752]         }
[11:01:52.752]     })
[11:01:52.752]     if (TRUE) {
[11:01:52.752]         base::sink(type = "output", split = FALSE)
[11:01:52.752]         if (TRUE) {
[11:01:52.752]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.752]         }
[11:01:52.752]         else {
[11:01:52.752]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.752]         }
[11:01:52.752]         base::close(...future.stdout)
[11:01:52.752]         ...future.stdout <- NULL
[11:01:52.752]     }
[11:01:52.752]     ...future.result$conditions <- ...future.conditions
[11:01:52.752]     ...future.result$finished <- base::Sys.time()
[11:01:52.752]     ...future.result
[11:01:52.752] }
[11:01:52.755] assign_globals() ...
[11:01:52.755] List of 1
[11:01:52.755]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eece8fbe10> 
[11:01:52.755]  - attr(*, "where")=List of 1
[11:01:52.755]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.755]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.755]  - attr(*, "resolved")= logi TRUE
[11:01:52.755]  - attr(*, "total_size")= num 3835
[11:01:52.755]  - attr(*, "already-done")= logi TRUE
[11:01:52.760] - copied ‘a’ to environment
[11:01:52.760] assign_globals() ... done
[11:01:52.760] requestCore(): workers = 2
[11:01:52.762] MulticoreFuture started
[11:01:52.762] - Launch lazy future ... done
[11:01:52.763] run() for ‘MulticoreFuture’ ... done
[11:01:52.763] result() for MulticoreFuture ...
[11:01:52.763] plan(): Setting new future strategy stack:
[11:01:52.763] List of future strategies:
[11:01:52.763] 1. sequential:
[11:01:52.763]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.763]    - tweaked: FALSE
[11:01:52.763]    - call: NULL
[11:01:52.765] plan(): nbrOfWorkers() = 1
[11:01:52.768] plan(): Setting new future strategy stack:
[11:01:52.769] List of future strategies:
[11:01:52.769] 1. multicore:
[11:01:52.769]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.769]    - tweaked: FALSE
[11:01:52.769]    - call: plan(strategy)
[11:01:52.772] plan(): nbrOfWorkers() = 2
[11:01:52.772] result() for MulticoreFuture ...
[11:01:52.773] result() for MulticoreFuture ... done
[11:01:52.773] signalConditions() ...
[11:01:52.773]  - include = ‘immediateCondition’
[11:01:52.773]  - exclude = 
[11:01:52.773]  - resignal = FALSE
[11:01:52.773]  - Number of conditions: 4
[11:01:52.774] signalConditions() ... done
[11:01:52.774] result() for MulticoreFuture ... done
[11:01:52.774] result() for MulticoreFuture ...
[11:01:52.774] result() for MulticoreFuture ... done
[11:01:52.774] signalConditions() ...
[11:01:52.774]  - include = ‘immediateCondition’
[11:01:52.774]  - exclude = 
[11:01:52.775]  - resignal = FALSE
[11:01:52.775]  - Number of conditions: 4
[11:01:52.775] signalConditions() ... done
[11:01:52.775] Future state: ‘finished’
[11:01:52.775] result() for MulticoreFuture ...
[11:01:52.775] result() for MulticoreFuture ... done
[11:01:52.775] signalConditions() ...
[11:01:52.775]  - include = ‘condition’
[11:01:52.776]  - exclude = ‘immediateCondition’
[11:01:52.776]  - resignal = TRUE
[11:01:52.776]  - Number of conditions: 4
[11:01:52.776]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.766] result() for MulticoreFuture ...
[11:01:52.776]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.767] result() for MulticoreFuture ... done
[11:01:52.776]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.767] result() for MulticoreFuture ...
[11:01:52.776]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.767] result() for MulticoreFuture ... done
[11:01:52.777] signalConditions() ... done
value(b) = 2
[11:01:52.777] result() for MulticoreFuture ...
[11:01:52.777] result() for MulticoreFuture ... done
[11:01:52.777] result() for MulticoreFuture ...
[11:01:52.777] result() for MulticoreFuture ... done
[11:01:52.777] signalConditions() ...
[11:01:52.777]  - include = ‘immediateCondition’
[11:01:52.777]  - exclude = 
[11:01:52.778]  - resignal = FALSE
[11:01:52.778]  - Number of conditions: 4
[11:01:52.778] signalConditions() ... done
[11:01:52.778] Future state: ‘finished’
[11:01:52.778] result() for MulticoreFuture ...
[11:01:52.778] result() for MulticoreFuture ... done
[11:01:52.778] signalConditions() ...
[11:01:52.778]  - include = ‘condition’
[11:01:52.778]  - exclude = ‘immediateCondition’
[11:01:52.779]  - resignal = TRUE
[11:01:52.779]  - Number of conditions: 4
[11:01:52.779]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.766] result() for MulticoreFuture ...
[11:01:52.779]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.767] result() for MulticoreFuture ... done
[11:01:52.779]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.767] result() for MulticoreFuture ...
[11:01:52.779]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.767] result() for MulticoreFuture ... done
[11:01:52.779] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.780] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.780] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.781] 
[11:01:52.781] Searching for globals ... DONE
[11:01:52.781] - globals: [0] <none>
[11:01:52.781] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.781] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.782] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.783] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:52.783] Searching for globals ... DONE
[11:01:52.783] Resolving globals: TRUE
[11:01:52.783] Resolving any globals that are futures ...
[11:01:52.783] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:52.783] Resolving any globals that are futures ... DONE
[11:01:52.784] Resolving futures part of globals (recursively) ...
[11:01:52.784] resolve() on list ...
[11:01:52.784]  recursive: 99
[11:01:52.784]  length: 1
[11:01:52.784]  elements: ‘a’
[11:01:52.784] run() for ‘Future’ ...
[11:01:52.785] - state: ‘created’
[11:01:52.785] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.787] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.787] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.787]   - Field: ‘label’
[11:01:52.787]   - Field: ‘local’
[11:01:52.787]   - Field: ‘owner’
[11:01:52.787]   - Field: ‘envir’
[11:01:52.787]   - Field: ‘workers’
[11:01:52.787]   - Field: ‘packages’
[11:01:52.788]   - Field: ‘gc’
[11:01:52.788]   - Field: ‘job’
[11:01:52.788]   - Field: ‘conditions’
[11:01:52.788]   - Field: ‘expr’
[11:01:52.788]   - Field: ‘uuid’
[11:01:52.788]   - Field: ‘seed’
[11:01:52.788]   - Field: ‘version’
[11:01:52.788]   - Field: ‘result’
[11:01:52.788]   - Field: ‘asynchronous’
[11:01:52.789]   - Field: ‘calls’
[11:01:52.789]   - Field: ‘globals’
[11:01:52.789]   - Field: ‘stdout’
[11:01:52.789]   - Field: ‘earlySignal’
[11:01:52.789]   - Field: ‘lazy’
[11:01:52.789]   - Field: ‘state’
[11:01:52.789] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.789] - Launch lazy future ...
[11:01:52.790] Packages needed by the future expression (n = 0): <none>
[11:01:52.790] Packages needed by future strategies (n = 0): <none>
[11:01:52.790] {
[11:01:52.790]     {
[11:01:52.790]         {
[11:01:52.790]             ...future.startTime <- base::Sys.time()
[11:01:52.790]             {
[11:01:52.790]                 {
[11:01:52.790]                   {
[11:01:52.790]                     {
[11:01:52.790]                       base::local({
[11:01:52.790]                         has_future <- base::requireNamespace("future", 
[11:01:52.790]                           quietly = TRUE)
[11:01:52.790]                         if (has_future) {
[11:01:52.790]                           ns <- base::getNamespace("future")
[11:01:52.790]                           version <- ns[[".package"]][["version"]]
[11:01:52.790]                           if (is.null(version)) 
[11:01:52.790]                             version <- utils::packageVersion("future")
[11:01:52.790]                         }
[11:01:52.790]                         else {
[11:01:52.790]                           version <- NULL
[11:01:52.790]                         }
[11:01:52.790]                         if (!has_future || version < "1.8.0") {
[11:01:52.790]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.790]                             "", base::R.version$version.string), 
[11:01:52.790]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.790]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.790]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.790]                               "release", "version")], collapse = " "), 
[11:01:52.790]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.790]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.790]                             info)
[11:01:52.790]                           info <- base::paste(info, collapse = "; ")
[11:01:52.790]                           if (!has_future) {
[11:01:52.790]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.790]                               info)
[11:01:52.790]                           }
[11:01:52.790]                           else {
[11:01:52.790]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.790]                               info, version)
[11:01:52.790]                           }
[11:01:52.790]                           base::stop(msg)
[11:01:52.790]                         }
[11:01:52.790]                       })
[11:01:52.790]                     }
[11:01:52.790]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.790]                     base::options(mc.cores = 1L)
[11:01:52.790]                   }
[11:01:52.790]                   ...future.strategy.old <- future::plan("list")
[11:01:52.790]                   options(future.plan = NULL)
[11:01:52.790]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.790]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.790]                 }
[11:01:52.790]                 ...future.workdir <- getwd()
[11:01:52.790]             }
[11:01:52.790]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.790]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.790]         }
[11:01:52.790]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.790]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.790]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.790]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.790]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.790]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.790]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.790]             base::names(...future.oldOptions))
[11:01:52.790]     }
[11:01:52.790]     if (FALSE) {
[11:01:52.790]     }
[11:01:52.790]     else {
[11:01:52.790]         if (TRUE) {
[11:01:52.790]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.790]                 open = "w")
[11:01:52.790]         }
[11:01:52.790]         else {
[11:01:52.790]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.790]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.790]         }
[11:01:52.790]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.790]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.790]             base::sink(type = "output", split = FALSE)
[11:01:52.790]             base::close(...future.stdout)
[11:01:52.790]         }, add = TRUE)
[11:01:52.790]     }
[11:01:52.790]     ...future.frame <- base::sys.nframe()
[11:01:52.790]     ...future.conditions <- base::list()
[11:01:52.790]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.790]     if (FALSE) {
[11:01:52.790]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.790]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.790]     }
[11:01:52.790]     ...future.result <- base::tryCatch({
[11:01:52.790]         base::withCallingHandlers({
[11:01:52.790]             ...future.value <- base::withVisible(base::local({
[11:01:52.790]                 withCallingHandlers({
[11:01:52.790]                   1
[11:01:52.790]                 }, immediateCondition = function(cond) {
[11:01:52.790]                   save_rds <- function (object, pathname, ...) 
[11:01:52.790]                   {
[11:01:52.790]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.790]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.790]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.790]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.790]                         fi_tmp[["mtime"]])
[11:01:52.790]                     }
[11:01:52.790]                     tryCatch({
[11:01:52.790]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.790]                     }, error = function(ex) {
[11:01:52.790]                       msg <- conditionMessage(ex)
[11:01:52.790]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.790]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.790]                         fi_tmp[["mtime"]], msg)
[11:01:52.790]                       ex$message <- msg
[11:01:52.790]                       stop(ex)
[11:01:52.790]                     })
[11:01:52.790]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.790]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.790]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.790]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.790]                       fi <- file.info(pathname)
[11:01:52.790]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.790]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.790]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.790]                         fi[["size"]], fi[["mtime"]])
[11:01:52.790]                       stop(msg)
[11:01:52.790]                     }
[11:01:52.790]                     invisible(pathname)
[11:01:52.790]                   }
[11:01:52.790]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.790]                     rootPath = tempdir()) 
[11:01:52.790]                   {
[11:01:52.790]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.790]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.790]                       tmpdir = path, fileext = ".rds")
[11:01:52.790]                     save_rds(obj, file)
[11:01:52.790]                   }
[11:01:52.790]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.790]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.790]                   {
[11:01:52.790]                     inherits <- base::inherits
[11:01:52.790]                     invokeRestart <- base::invokeRestart
[11:01:52.790]                     is.null <- base::is.null
[11:01:52.790]                     muffled <- FALSE
[11:01:52.790]                     if (inherits(cond, "message")) {
[11:01:52.790]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.790]                       if (muffled) 
[11:01:52.790]                         invokeRestart("muffleMessage")
[11:01:52.790]                     }
[11:01:52.790]                     else if (inherits(cond, "warning")) {
[11:01:52.790]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.790]                       if (muffled) 
[11:01:52.790]                         invokeRestart("muffleWarning")
[11:01:52.790]                     }
[11:01:52.790]                     else if (inherits(cond, "condition")) {
[11:01:52.790]                       if (!is.null(pattern)) {
[11:01:52.790]                         computeRestarts <- base::computeRestarts
[11:01:52.790]                         grepl <- base::grepl
[11:01:52.790]                         restarts <- computeRestarts(cond)
[11:01:52.790]                         for (restart in restarts) {
[11:01:52.790]                           name <- restart$name
[11:01:52.790]                           if (is.null(name)) 
[11:01:52.790]                             next
[11:01:52.790]                           if (!grepl(pattern, name)) 
[11:01:52.790]                             next
[11:01:52.790]                           invokeRestart(restart)
[11:01:52.790]                           muffled <- TRUE
[11:01:52.790]                           break
[11:01:52.790]                         }
[11:01:52.790]                       }
[11:01:52.790]                     }
[11:01:52.790]                     invisible(muffled)
[11:01:52.790]                   }
[11:01:52.790]                   muffleCondition(cond)
[11:01:52.790]                 })
[11:01:52.790]             }))
[11:01:52.790]             future::FutureResult(value = ...future.value$value, 
[11:01:52.790]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.790]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.790]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.790]                     ...future.globalenv.names))
[11:01:52.790]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.790]         }, condition = base::local({
[11:01:52.790]             c <- base::c
[11:01:52.790]             inherits <- base::inherits
[11:01:52.790]             invokeRestart <- base::invokeRestart
[11:01:52.790]             length <- base::length
[11:01:52.790]             list <- base::list
[11:01:52.790]             seq.int <- base::seq.int
[11:01:52.790]             signalCondition <- base::signalCondition
[11:01:52.790]             sys.calls <- base::sys.calls
[11:01:52.790]             `[[` <- base::`[[`
[11:01:52.790]             `+` <- base::`+`
[11:01:52.790]             `<<-` <- base::`<<-`
[11:01:52.790]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.790]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.790]                   3L)]
[11:01:52.790]             }
[11:01:52.790]             function(cond) {
[11:01:52.790]                 is_error <- inherits(cond, "error")
[11:01:52.790]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.790]                   NULL)
[11:01:52.790]                 if (is_error) {
[11:01:52.790]                   sessionInformation <- function() {
[11:01:52.790]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.790]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.790]                       search = base::search(), system = base::Sys.info())
[11:01:52.790]                   }
[11:01:52.790]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.790]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.790]                     cond$call), session = sessionInformation(), 
[11:01:52.790]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.790]                   signalCondition(cond)
[11:01:52.790]                 }
[11:01:52.790]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.790]                 "immediateCondition"))) {
[11:01:52.790]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.790]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.790]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.790]                   if (TRUE && !signal) {
[11:01:52.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.790]                     {
[11:01:52.790]                       inherits <- base::inherits
[11:01:52.790]                       invokeRestart <- base::invokeRestart
[11:01:52.790]                       is.null <- base::is.null
[11:01:52.790]                       muffled <- FALSE
[11:01:52.790]                       if (inherits(cond, "message")) {
[11:01:52.790]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.790]                         if (muffled) 
[11:01:52.790]                           invokeRestart("muffleMessage")
[11:01:52.790]                       }
[11:01:52.790]                       else if (inherits(cond, "warning")) {
[11:01:52.790]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.790]                         if (muffled) 
[11:01:52.790]                           invokeRestart("muffleWarning")
[11:01:52.790]                       }
[11:01:52.790]                       else if (inherits(cond, "condition")) {
[11:01:52.790]                         if (!is.null(pattern)) {
[11:01:52.790]                           computeRestarts <- base::computeRestarts
[11:01:52.790]                           grepl <- base::grepl
[11:01:52.790]                           restarts <- computeRestarts(cond)
[11:01:52.790]                           for (restart in restarts) {
[11:01:52.790]                             name <- restart$name
[11:01:52.790]                             if (is.null(name)) 
[11:01:52.790]                               next
[11:01:52.790]                             if (!grepl(pattern, name)) 
[11:01:52.790]                               next
[11:01:52.790]                             invokeRestart(restart)
[11:01:52.790]                             muffled <- TRUE
[11:01:52.790]                             break
[11:01:52.790]                           }
[11:01:52.790]                         }
[11:01:52.790]                       }
[11:01:52.790]                       invisible(muffled)
[11:01:52.790]                     }
[11:01:52.790]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.790]                   }
[11:01:52.790]                 }
[11:01:52.790]                 else {
[11:01:52.790]                   if (TRUE) {
[11:01:52.790]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.790]                     {
[11:01:52.790]                       inherits <- base::inherits
[11:01:52.790]                       invokeRestart <- base::invokeRestart
[11:01:52.790]                       is.null <- base::is.null
[11:01:52.790]                       muffled <- FALSE
[11:01:52.790]                       if (inherits(cond, "message")) {
[11:01:52.790]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.790]                         if (muffled) 
[11:01:52.790]                           invokeRestart("muffleMessage")
[11:01:52.790]                       }
[11:01:52.790]                       else if (inherits(cond, "warning")) {
[11:01:52.790]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.790]                         if (muffled) 
[11:01:52.790]                           invokeRestart("muffleWarning")
[11:01:52.790]                       }
[11:01:52.790]                       else if (inherits(cond, "condition")) {
[11:01:52.790]                         if (!is.null(pattern)) {
[11:01:52.790]                           computeRestarts <- base::computeRestarts
[11:01:52.790]                           grepl <- base::grepl
[11:01:52.790]                           restarts <- computeRestarts(cond)
[11:01:52.790]                           for (restart in restarts) {
[11:01:52.790]                             name <- restart$name
[11:01:52.790]                             if (is.null(name)) 
[11:01:52.790]                               next
[11:01:52.790]                             if (!grepl(pattern, name)) 
[11:01:52.790]                               next
[11:01:52.790]                             invokeRestart(restart)
[11:01:52.790]                             muffled <- TRUE
[11:01:52.790]                             break
[11:01:52.790]                           }
[11:01:52.790]                         }
[11:01:52.790]                       }
[11:01:52.790]                       invisible(muffled)
[11:01:52.790]                     }
[11:01:52.790]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.790]                   }
[11:01:52.790]                 }
[11:01:52.790]             }
[11:01:52.790]         }))
[11:01:52.790]     }, error = function(ex) {
[11:01:52.790]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.790]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.790]                 ...future.rng), started = ...future.startTime, 
[11:01:52.790]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.790]             version = "1.8"), class = "FutureResult")
[11:01:52.790]     }, finally = {
[11:01:52.790]         if (!identical(...future.workdir, getwd())) 
[11:01:52.790]             setwd(...future.workdir)
[11:01:52.790]         {
[11:01:52.790]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.790]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.790]             }
[11:01:52.790]             base::options(...future.oldOptions)
[11:01:52.790]             if (.Platform$OS.type == "windows") {
[11:01:52.790]                 old_names <- names(...future.oldEnvVars)
[11:01:52.790]                 envs <- base::Sys.getenv()
[11:01:52.790]                 names <- names(envs)
[11:01:52.790]                 common <- intersect(names, old_names)
[11:01:52.790]                 added <- setdiff(names, old_names)
[11:01:52.790]                 removed <- setdiff(old_names, names)
[11:01:52.790]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.790]                   envs[common]]
[11:01:52.790]                 NAMES <- toupper(changed)
[11:01:52.790]                 args <- list()
[11:01:52.790]                 for (kk in seq_along(NAMES)) {
[11:01:52.790]                   name <- changed[[kk]]
[11:01:52.790]                   NAME <- NAMES[[kk]]
[11:01:52.790]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.790]                     next
[11:01:52.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.790]                 }
[11:01:52.790]                 NAMES <- toupper(added)
[11:01:52.790]                 for (kk in seq_along(NAMES)) {
[11:01:52.790]                   name <- added[[kk]]
[11:01:52.790]                   NAME <- NAMES[[kk]]
[11:01:52.790]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.790]                     next
[11:01:52.790]                   args[[name]] <- ""
[11:01:52.790]                 }
[11:01:52.790]                 NAMES <- toupper(removed)
[11:01:52.790]                 for (kk in seq_along(NAMES)) {
[11:01:52.790]                   name <- removed[[kk]]
[11:01:52.790]                   NAME <- NAMES[[kk]]
[11:01:52.790]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.790]                     next
[11:01:52.790]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.790]                 }
[11:01:52.790]                 if (length(args) > 0) 
[11:01:52.790]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.790]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.790]             }
[11:01:52.790]             else {
[11:01:52.790]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.790]             }
[11:01:52.790]             {
[11:01:52.790]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.790]                   0L) {
[11:01:52.790]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.790]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.790]                   base::options(opts)
[11:01:52.790]                 }
[11:01:52.790]                 {
[11:01:52.790]                   {
[11:01:52.790]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.790]                     NULL
[11:01:52.790]                   }
[11:01:52.790]                   options(future.plan = NULL)
[11:01:52.790]                   if (is.na(NA_character_)) 
[11:01:52.790]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.790]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.790]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.790]                     .init = FALSE)
[11:01:52.790]                 }
[11:01:52.790]             }
[11:01:52.790]         }
[11:01:52.790]     })
[11:01:52.790]     if (TRUE) {
[11:01:52.790]         base::sink(type = "output", split = FALSE)
[11:01:52.790]         if (TRUE) {
[11:01:52.790]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.790]         }
[11:01:52.790]         else {
[11:01:52.790]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.790]         }
[11:01:52.790]         base::close(...future.stdout)
[11:01:52.790]         ...future.stdout <- NULL
[11:01:52.790]     }
[11:01:52.790]     ...future.result$conditions <- ...future.conditions
[11:01:52.790]     ...future.result$finished <- base::Sys.time()
[11:01:52.790]     ...future.result
[11:01:52.790] }
[11:01:52.793] requestCore(): workers = 2
[11:01:52.794] MulticoreFuture started
[11:01:52.795] - Launch lazy future ... done
[11:01:52.795] run() for ‘MulticoreFuture’ ... done
[11:01:52.795] plan(): Setting new future strategy stack:
[11:01:52.796] List of future strategies:
[11:01:52.796] 1. sequential:
[11:01:52.796]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.796]    - tweaked: FALSE
[11:01:52.796]    - call: NULL
[11:01:52.797] plan(): nbrOfWorkers() = 1
[11:01:52.812] plan(): Setting new future strategy stack:
[11:01:52.812] List of future strategies:
[11:01:52.812] 1. multicore:
[11:01:52.812]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.812]    - tweaked: FALSE
[11:01:52.812]    - call: plan(strategy)
[11:01:52.814] plan(): nbrOfWorkers() = 2
[11:01:52.816] Future #1
[11:01:52.816] result() for MulticoreFuture ...
[11:01:52.817] result() for MulticoreFuture ...
[11:01:52.817] result() for MulticoreFuture ... done
[11:01:52.817] result() for MulticoreFuture ... done
[11:01:52.826] result() for MulticoreFuture ...
[11:01:52.826] result() for MulticoreFuture ... done
[11:01:52.826] A MulticoreFuture was resolved
[11:01:52.826]  length: 0 (resolved future 1)
[11:01:52.826] resolve() on list ... DONE
[11:01:52.826] - globals: [1] ‘a’
[11:01:52.826] Resolving futures part of globals (recursively) ... DONE
[11:01:52.827] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[11:01:52.827] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[11:01:52.827] - globals: [1] ‘a’
[11:01:52.827] - packages: [1] ‘future’
[11:01:52.827] getGlobalsAndPackages() ... DONE
[11:01:52.828] run() for ‘Future’ ...
[11:01:52.828] - state: ‘created’
[11:01:52.828] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.830] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.830] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.830]   - Field: ‘label’
[11:01:52.830]   - Field: ‘local’
[11:01:52.830]   - Field: ‘owner’
[11:01:52.830]   - Field: ‘envir’
[11:01:52.830]   - Field: ‘workers’
[11:01:52.830]   - Field: ‘packages’
[11:01:52.831]   - Field: ‘gc’
[11:01:52.831]   - Field: ‘job’
[11:01:52.831]   - Field: ‘conditions’
[11:01:52.831]   - Field: ‘expr’
[11:01:52.831]   - Field: ‘uuid’
[11:01:52.831]   - Field: ‘seed’
[11:01:52.831]   - Field: ‘version’
[11:01:52.831]   - Field: ‘result’
[11:01:52.831]   - Field: ‘asynchronous’
[11:01:52.832]   - Field: ‘calls’
[11:01:52.832]   - Field: ‘globals’
[11:01:52.832]   - Field: ‘stdout’
[11:01:52.832]   - Field: ‘earlySignal’
[11:01:52.832]   - Field: ‘lazy’
[11:01:52.832]   - Field: ‘state’
[11:01:52.832] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.832] - Launch lazy future ...
[11:01:52.833] Packages needed by the future expression (n = 1): ‘future’
[11:01:52.833] Packages needed by future strategies (n = 0): <none>
[11:01:52.833] {
[11:01:52.833]     {
[11:01:52.833]         {
[11:01:52.833]             ...future.startTime <- base::Sys.time()
[11:01:52.833]             {
[11:01:52.833]                 {
[11:01:52.833]                   {
[11:01:52.833]                     {
[11:01:52.833]                       {
[11:01:52.833]                         base::local({
[11:01:52.833]                           has_future <- base::requireNamespace("future", 
[11:01:52.833]                             quietly = TRUE)
[11:01:52.833]                           if (has_future) {
[11:01:52.833]                             ns <- base::getNamespace("future")
[11:01:52.833]                             version <- ns[[".package"]][["version"]]
[11:01:52.833]                             if (is.null(version)) 
[11:01:52.833]                               version <- utils::packageVersion("future")
[11:01:52.833]                           }
[11:01:52.833]                           else {
[11:01:52.833]                             version <- NULL
[11:01:52.833]                           }
[11:01:52.833]                           if (!has_future || version < "1.8.0") {
[11:01:52.833]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.833]                               "", base::R.version$version.string), 
[11:01:52.833]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:52.833]                                 base::R.version$platform, 8 * 
[11:01:52.833]                                   base::.Machine$sizeof.pointer), 
[11:01:52.833]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.833]                                 "release", "version")], collapse = " "), 
[11:01:52.833]                               hostname = base::Sys.info()[["nodename"]])
[11:01:52.833]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.833]                               info)
[11:01:52.833]                             info <- base::paste(info, collapse = "; ")
[11:01:52.833]                             if (!has_future) {
[11:01:52.833]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.833]                                 info)
[11:01:52.833]                             }
[11:01:52.833]                             else {
[11:01:52.833]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.833]                                 info, version)
[11:01:52.833]                             }
[11:01:52.833]                             base::stop(msg)
[11:01:52.833]                           }
[11:01:52.833]                         })
[11:01:52.833]                       }
[11:01:52.833]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.833]                       base::options(mc.cores = 1L)
[11:01:52.833]                     }
[11:01:52.833]                     base::local({
[11:01:52.833]                       for (pkg in "future") {
[11:01:52.833]                         base::loadNamespace(pkg)
[11:01:52.833]                         base::library(pkg, character.only = TRUE)
[11:01:52.833]                       }
[11:01:52.833]                     })
[11:01:52.833]                   }
[11:01:52.833]                   ...future.strategy.old <- future::plan("list")
[11:01:52.833]                   options(future.plan = NULL)
[11:01:52.833]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.833]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.833]                 }
[11:01:52.833]                 ...future.workdir <- getwd()
[11:01:52.833]             }
[11:01:52.833]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.833]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.833]         }
[11:01:52.833]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.833]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.833]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.833]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.833]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.833]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.833]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.833]             base::names(...future.oldOptions))
[11:01:52.833]     }
[11:01:52.833]     if (FALSE) {
[11:01:52.833]     }
[11:01:52.833]     else {
[11:01:52.833]         if (TRUE) {
[11:01:52.833]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.833]                 open = "w")
[11:01:52.833]         }
[11:01:52.833]         else {
[11:01:52.833]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.833]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.833]         }
[11:01:52.833]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.833]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.833]             base::sink(type = "output", split = FALSE)
[11:01:52.833]             base::close(...future.stdout)
[11:01:52.833]         }, add = TRUE)
[11:01:52.833]     }
[11:01:52.833]     ...future.frame <- base::sys.nframe()
[11:01:52.833]     ...future.conditions <- base::list()
[11:01:52.833]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.833]     if (FALSE) {
[11:01:52.833]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.833]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.833]     }
[11:01:52.833]     ...future.result <- base::tryCatch({
[11:01:52.833]         base::withCallingHandlers({
[11:01:52.833]             ...future.value <- base::withVisible(base::local({
[11:01:52.833]                 withCallingHandlers({
[11:01:52.833]                   value(a) + 1
[11:01:52.833]                 }, immediateCondition = function(cond) {
[11:01:52.833]                   save_rds <- function (object, pathname, ...) 
[11:01:52.833]                   {
[11:01:52.833]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.833]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.833]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.833]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.833]                         fi_tmp[["mtime"]])
[11:01:52.833]                     }
[11:01:52.833]                     tryCatch({
[11:01:52.833]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.833]                     }, error = function(ex) {
[11:01:52.833]                       msg <- conditionMessage(ex)
[11:01:52.833]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.833]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.833]                         fi_tmp[["mtime"]], msg)
[11:01:52.833]                       ex$message <- msg
[11:01:52.833]                       stop(ex)
[11:01:52.833]                     })
[11:01:52.833]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.833]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.833]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.833]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.833]                       fi <- file.info(pathname)
[11:01:52.833]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.833]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.833]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.833]                         fi[["size"]], fi[["mtime"]])
[11:01:52.833]                       stop(msg)
[11:01:52.833]                     }
[11:01:52.833]                     invisible(pathname)
[11:01:52.833]                   }
[11:01:52.833]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.833]                     rootPath = tempdir()) 
[11:01:52.833]                   {
[11:01:52.833]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.833]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.833]                       tmpdir = path, fileext = ".rds")
[11:01:52.833]                     save_rds(obj, file)
[11:01:52.833]                   }
[11:01:52.833]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.833]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.833]                   {
[11:01:52.833]                     inherits <- base::inherits
[11:01:52.833]                     invokeRestart <- base::invokeRestart
[11:01:52.833]                     is.null <- base::is.null
[11:01:52.833]                     muffled <- FALSE
[11:01:52.833]                     if (inherits(cond, "message")) {
[11:01:52.833]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.833]                       if (muffled) 
[11:01:52.833]                         invokeRestart("muffleMessage")
[11:01:52.833]                     }
[11:01:52.833]                     else if (inherits(cond, "warning")) {
[11:01:52.833]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.833]                       if (muffled) 
[11:01:52.833]                         invokeRestart("muffleWarning")
[11:01:52.833]                     }
[11:01:52.833]                     else if (inherits(cond, "condition")) {
[11:01:52.833]                       if (!is.null(pattern)) {
[11:01:52.833]                         computeRestarts <- base::computeRestarts
[11:01:52.833]                         grepl <- base::grepl
[11:01:52.833]                         restarts <- computeRestarts(cond)
[11:01:52.833]                         for (restart in restarts) {
[11:01:52.833]                           name <- restart$name
[11:01:52.833]                           if (is.null(name)) 
[11:01:52.833]                             next
[11:01:52.833]                           if (!grepl(pattern, name)) 
[11:01:52.833]                             next
[11:01:52.833]                           invokeRestart(restart)
[11:01:52.833]                           muffled <- TRUE
[11:01:52.833]                           break
[11:01:52.833]                         }
[11:01:52.833]                       }
[11:01:52.833]                     }
[11:01:52.833]                     invisible(muffled)
[11:01:52.833]                   }
[11:01:52.833]                   muffleCondition(cond)
[11:01:52.833]                 })
[11:01:52.833]             }))
[11:01:52.833]             future::FutureResult(value = ...future.value$value, 
[11:01:52.833]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.833]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.833]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.833]                     ...future.globalenv.names))
[11:01:52.833]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.833]         }, condition = base::local({
[11:01:52.833]             c <- base::c
[11:01:52.833]             inherits <- base::inherits
[11:01:52.833]             invokeRestart <- base::invokeRestart
[11:01:52.833]             length <- base::length
[11:01:52.833]             list <- base::list
[11:01:52.833]             seq.int <- base::seq.int
[11:01:52.833]             signalCondition <- base::signalCondition
[11:01:52.833]             sys.calls <- base::sys.calls
[11:01:52.833]             `[[` <- base::`[[`
[11:01:52.833]             `+` <- base::`+`
[11:01:52.833]             `<<-` <- base::`<<-`
[11:01:52.833]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.833]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.833]                   3L)]
[11:01:52.833]             }
[11:01:52.833]             function(cond) {
[11:01:52.833]                 is_error <- inherits(cond, "error")
[11:01:52.833]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.833]                   NULL)
[11:01:52.833]                 if (is_error) {
[11:01:52.833]                   sessionInformation <- function() {
[11:01:52.833]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.833]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.833]                       search = base::search(), system = base::Sys.info())
[11:01:52.833]                   }
[11:01:52.833]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.833]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.833]                     cond$call), session = sessionInformation(), 
[11:01:52.833]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.833]                   signalCondition(cond)
[11:01:52.833]                 }
[11:01:52.833]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.833]                 "immediateCondition"))) {
[11:01:52.833]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.833]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.833]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.833]                   if (TRUE && !signal) {
[11:01:52.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.833]                     {
[11:01:52.833]                       inherits <- base::inherits
[11:01:52.833]                       invokeRestart <- base::invokeRestart
[11:01:52.833]                       is.null <- base::is.null
[11:01:52.833]                       muffled <- FALSE
[11:01:52.833]                       if (inherits(cond, "message")) {
[11:01:52.833]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.833]                         if (muffled) 
[11:01:52.833]                           invokeRestart("muffleMessage")
[11:01:52.833]                       }
[11:01:52.833]                       else if (inherits(cond, "warning")) {
[11:01:52.833]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.833]                         if (muffled) 
[11:01:52.833]                           invokeRestart("muffleWarning")
[11:01:52.833]                       }
[11:01:52.833]                       else if (inherits(cond, "condition")) {
[11:01:52.833]                         if (!is.null(pattern)) {
[11:01:52.833]                           computeRestarts <- base::computeRestarts
[11:01:52.833]                           grepl <- base::grepl
[11:01:52.833]                           restarts <- computeRestarts(cond)
[11:01:52.833]                           for (restart in restarts) {
[11:01:52.833]                             name <- restart$name
[11:01:52.833]                             if (is.null(name)) 
[11:01:52.833]                               next
[11:01:52.833]                             if (!grepl(pattern, name)) 
[11:01:52.833]                               next
[11:01:52.833]                             invokeRestart(restart)
[11:01:52.833]                             muffled <- TRUE
[11:01:52.833]                             break
[11:01:52.833]                           }
[11:01:52.833]                         }
[11:01:52.833]                       }
[11:01:52.833]                       invisible(muffled)
[11:01:52.833]                     }
[11:01:52.833]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.833]                   }
[11:01:52.833]                 }
[11:01:52.833]                 else {
[11:01:52.833]                   if (TRUE) {
[11:01:52.833]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.833]                     {
[11:01:52.833]                       inherits <- base::inherits
[11:01:52.833]                       invokeRestart <- base::invokeRestart
[11:01:52.833]                       is.null <- base::is.null
[11:01:52.833]                       muffled <- FALSE
[11:01:52.833]                       if (inherits(cond, "message")) {
[11:01:52.833]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.833]                         if (muffled) 
[11:01:52.833]                           invokeRestart("muffleMessage")
[11:01:52.833]                       }
[11:01:52.833]                       else if (inherits(cond, "warning")) {
[11:01:52.833]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.833]                         if (muffled) 
[11:01:52.833]                           invokeRestart("muffleWarning")
[11:01:52.833]                       }
[11:01:52.833]                       else if (inherits(cond, "condition")) {
[11:01:52.833]                         if (!is.null(pattern)) {
[11:01:52.833]                           computeRestarts <- base::computeRestarts
[11:01:52.833]                           grepl <- base::grepl
[11:01:52.833]                           restarts <- computeRestarts(cond)
[11:01:52.833]                           for (restart in restarts) {
[11:01:52.833]                             name <- restart$name
[11:01:52.833]                             if (is.null(name)) 
[11:01:52.833]                               next
[11:01:52.833]                             if (!grepl(pattern, name)) 
[11:01:52.833]                               next
[11:01:52.833]                             invokeRestart(restart)
[11:01:52.833]                             muffled <- TRUE
[11:01:52.833]                             break
[11:01:52.833]                           }
[11:01:52.833]                         }
[11:01:52.833]                       }
[11:01:52.833]                       invisible(muffled)
[11:01:52.833]                     }
[11:01:52.833]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.833]                   }
[11:01:52.833]                 }
[11:01:52.833]             }
[11:01:52.833]         }))
[11:01:52.833]     }, error = function(ex) {
[11:01:52.833]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.833]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.833]                 ...future.rng), started = ...future.startTime, 
[11:01:52.833]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.833]             version = "1.8"), class = "FutureResult")
[11:01:52.833]     }, finally = {
[11:01:52.833]         if (!identical(...future.workdir, getwd())) 
[11:01:52.833]             setwd(...future.workdir)
[11:01:52.833]         {
[11:01:52.833]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.833]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.833]             }
[11:01:52.833]             base::options(...future.oldOptions)
[11:01:52.833]             if (.Platform$OS.type == "windows") {
[11:01:52.833]                 old_names <- names(...future.oldEnvVars)
[11:01:52.833]                 envs <- base::Sys.getenv()
[11:01:52.833]                 names <- names(envs)
[11:01:52.833]                 common <- intersect(names, old_names)
[11:01:52.833]                 added <- setdiff(names, old_names)
[11:01:52.833]                 removed <- setdiff(old_names, names)
[11:01:52.833]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.833]                   envs[common]]
[11:01:52.833]                 NAMES <- toupper(changed)
[11:01:52.833]                 args <- list()
[11:01:52.833]                 for (kk in seq_along(NAMES)) {
[11:01:52.833]                   name <- changed[[kk]]
[11:01:52.833]                   NAME <- NAMES[[kk]]
[11:01:52.833]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.833]                     next
[11:01:52.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.833]                 }
[11:01:52.833]                 NAMES <- toupper(added)
[11:01:52.833]                 for (kk in seq_along(NAMES)) {
[11:01:52.833]                   name <- added[[kk]]
[11:01:52.833]                   NAME <- NAMES[[kk]]
[11:01:52.833]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.833]                     next
[11:01:52.833]                   args[[name]] <- ""
[11:01:52.833]                 }
[11:01:52.833]                 NAMES <- toupper(removed)
[11:01:52.833]                 for (kk in seq_along(NAMES)) {
[11:01:52.833]                   name <- removed[[kk]]
[11:01:52.833]                   NAME <- NAMES[[kk]]
[11:01:52.833]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.833]                     next
[11:01:52.833]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.833]                 }
[11:01:52.833]                 if (length(args) > 0) 
[11:01:52.833]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.833]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.833]             }
[11:01:52.833]             else {
[11:01:52.833]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.833]             }
[11:01:52.833]             {
[11:01:52.833]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.833]                   0L) {
[11:01:52.833]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.833]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.833]                   base::options(opts)
[11:01:52.833]                 }
[11:01:52.833]                 {
[11:01:52.833]                   {
[11:01:52.833]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.833]                     NULL
[11:01:52.833]                   }
[11:01:52.833]                   options(future.plan = NULL)
[11:01:52.833]                   if (is.na(NA_character_)) 
[11:01:52.833]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.833]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.833]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.833]                     .init = FALSE)
[11:01:52.833]                 }
[11:01:52.833]             }
[11:01:52.833]         }
[11:01:52.833]     })
[11:01:52.833]     if (TRUE) {
[11:01:52.833]         base::sink(type = "output", split = FALSE)
[11:01:52.833]         if (TRUE) {
[11:01:52.833]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.833]         }
[11:01:52.833]         else {
[11:01:52.833]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.833]         }
[11:01:52.833]         base::close(...future.stdout)
[11:01:52.833]         ...future.stdout <- NULL
[11:01:52.833]     }
[11:01:52.833]     ...future.result$conditions <- ...future.conditions
[11:01:52.833]     ...future.result$finished <- base::Sys.time()
[11:01:52.833]     ...future.result
[11:01:52.833] }
[11:01:52.836] assign_globals() ...
[11:01:52.836] List of 1
[11:01:52.836]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eecde90ef8> 
[11:01:52.836]  - attr(*, "where")=List of 1
[11:01:52.836]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.836]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.836]  - attr(*, "resolved")= logi TRUE
[11:01:52.836]  - attr(*, "total_size")= num 3835
[11:01:52.836]  - attr(*, "already-done")= logi TRUE
[11:01:52.838] - copied ‘a’ to environment
[11:01:52.839] assign_globals() ... done
[11:01:52.839] requestCore(): workers = 2
[11:01:52.841] MulticoreFuture started
[11:01:52.841] - Launch lazy future ... done
[11:01:52.841] run() for ‘MulticoreFuture’ ... done
[11:01:52.841] result() for MulticoreFuture ...
[11:01:52.842] plan(): Setting new future strategy stack:
[11:01:52.842] List of future strategies:
[11:01:52.842] 1. sequential:
[11:01:52.842]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.842]    - tweaked: FALSE
[11:01:52.842]    - call: NULL
[11:01:52.843] plan(): nbrOfWorkers() = 1
[11:01:52.846] plan(): Setting new future strategy stack:
[11:01:52.847] List of future strategies:
[11:01:52.847] 1. multicore:
[11:01:52.847]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.847]    - tweaked: FALSE
[11:01:52.847]    - call: plan(strategy)
[11:01:52.850] plan(): nbrOfWorkers() = 2
[11:01:52.850] result() for MulticoreFuture ...
[11:01:52.851] result() for MulticoreFuture ... done
[11:01:52.851] signalConditions() ...
[11:01:52.851]  - include = ‘immediateCondition’
[11:01:52.851]  - exclude = 
[11:01:52.851]  - resignal = FALSE
[11:01:52.851]  - Number of conditions: 4
[11:01:52.851] signalConditions() ... done
[11:01:52.851] result() for MulticoreFuture ... done
[11:01:52.852] result() for MulticoreFuture ...
[11:01:52.852] result() for MulticoreFuture ... done
[11:01:52.852] signalConditions() ...
[11:01:52.852]  - include = ‘immediateCondition’
[11:01:52.852]  - exclude = 
[11:01:52.852]  - resignal = FALSE
[11:01:52.852]  - Number of conditions: 4
[11:01:52.852] signalConditions() ... done
[11:01:52.853] Future state: ‘finished’
[11:01:52.853] result() for MulticoreFuture ...
[11:01:52.853] result() for MulticoreFuture ... done
[11:01:52.853] signalConditions() ...
[11:01:52.853]  - include = ‘condition’
[11:01:52.853]  - exclude = ‘immediateCondition’
[11:01:52.853]  - resignal = TRUE
[11:01:52.853]  - Number of conditions: 4
[11:01:52.853]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ...
[11:01:52.854]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ... done
[11:01:52.854]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ...
[11:01:52.854]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ... done
[11:01:52.854] signalConditions() ... done
value(b) = 2
[11:01:52.854] result() for MulticoreFuture ...
[11:01:52.854] result() for MulticoreFuture ... done
[11:01:52.855] result() for MulticoreFuture ...
[11:01:52.855] result() for MulticoreFuture ... done
[11:01:52.855] signalConditions() ...
[11:01:52.855]  - include = ‘immediateCondition’
[11:01:52.855]  - exclude = 
[11:01:52.855]  - resignal = FALSE
[11:01:52.855]  - Number of conditions: 4
[11:01:52.855] signalConditions() ... done
[11:01:52.855] Future state: ‘finished’
[11:01:52.856] result() for MulticoreFuture ...
[11:01:52.856] result() for MulticoreFuture ... done
[11:01:52.856] signalConditions() ...
[11:01:52.856]  - include = ‘condition’
[11:01:52.856]  - exclude = ‘immediateCondition’
[11:01:52.856]  - resignal = TRUE
[11:01:52.856]  - Number of conditions: 4
[11:01:52.856]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ...
[11:01:52.856]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ... done
[11:01:52.857]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ...
[11:01:52.857]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:52.845] result() for MulticoreFuture ... done
[11:01:52.857] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.857] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.857] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:52.859] - globals found: [2] ‘{’, ‘pkg’
[11:01:52.859] Searching for globals ... DONE
[11:01:52.859] Resolving globals: TRUE
[11:01:52.859] Resolving any globals that are futures ...
[11:01:52.859] - globals: [2] ‘{’, ‘pkg’
[11:01:52.859] Resolving any globals that are futures ... DONE
[11:01:52.860] Resolving futures part of globals (recursively) ...
[11:01:52.860] resolve() on list ...
[11:01:52.860]  recursive: 99
[11:01:52.860]  length: 1
[11:01:52.860]  elements: ‘pkg’
[11:01:52.860]  length: 0 (resolved future 1)
[11:01:52.860] resolve() on list ... DONE
[11:01:52.861] - globals: [1] ‘pkg’
[11:01:52.861] Resolving futures part of globals (recursively) ... DONE
[11:01:52.861] The total size of the 1 globals is 42 bytes (42 bytes)
[11:01:52.861] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[11:01:52.861] - globals: [1] ‘pkg’
[11:01:52.862] 
[11:01:52.862] getGlobalsAndPackages() ... DONE
[11:01:52.862] Packages needed by the future expression (n = 0): <none>
[11:01:52.862] Packages needed by future strategies (n = 0): <none>
[11:01:52.865] {
[11:01:52.865]     {
[11:01:52.865]         {
[11:01:52.865]             ...future.startTime <- base::Sys.time()
[11:01:52.865]             {
[11:01:52.865]                 {
[11:01:52.865]                   {
[11:01:52.865]                     base::local({
[11:01:52.865]                       has_future <- base::requireNamespace("future", 
[11:01:52.865]                         quietly = TRUE)
[11:01:52.865]                       if (has_future) {
[11:01:52.865]                         ns <- base::getNamespace("future")
[11:01:52.865]                         version <- ns[[".package"]][["version"]]
[11:01:52.865]                         if (is.null(version)) 
[11:01:52.865]                           version <- utils::packageVersion("future")
[11:01:52.865]                       }
[11:01:52.865]                       else {
[11:01:52.865]                         version <- NULL
[11:01:52.865]                       }
[11:01:52.865]                       if (!has_future || version < "1.8.0") {
[11:01:52.865]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.865]                           "", base::R.version$version.string), 
[11:01:52.865]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:52.865]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.865]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.865]                             "release", "version")], collapse = " "), 
[11:01:52.865]                           hostname = base::Sys.info()[["nodename"]])
[11:01:52.865]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.865]                           info)
[11:01:52.865]                         info <- base::paste(info, collapse = "; ")
[11:01:52.865]                         if (!has_future) {
[11:01:52.865]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.865]                             info)
[11:01:52.865]                         }
[11:01:52.865]                         else {
[11:01:52.865]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.865]                             info, version)
[11:01:52.865]                         }
[11:01:52.865]                         base::stop(msg)
[11:01:52.865]                       }
[11:01:52.865]                     })
[11:01:52.865]                   }
[11:01:52.865]                   ...future.strategy.old <- future::plan("list")
[11:01:52.865]                   options(future.plan = NULL)
[11:01:52.865]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.865]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.865]                 }
[11:01:52.865]                 ...future.workdir <- getwd()
[11:01:52.865]             }
[11:01:52.865]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.865]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.865]         }
[11:01:52.865]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.865]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:52.865]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.865]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.865]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.865]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.865]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.865]             base::names(...future.oldOptions))
[11:01:52.865]     }
[11:01:52.865]     if (FALSE) {
[11:01:52.865]     }
[11:01:52.865]     else {
[11:01:52.865]         if (TRUE) {
[11:01:52.865]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.865]                 open = "w")
[11:01:52.865]         }
[11:01:52.865]         else {
[11:01:52.865]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.865]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.865]         }
[11:01:52.865]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.865]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.865]             base::sink(type = "output", split = FALSE)
[11:01:52.865]             base::close(...future.stdout)
[11:01:52.865]         }, add = TRUE)
[11:01:52.865]     }
[11:01:52.865]     ...future.frame <- base::sys.nframe()
[11:01:52.865]     ...future.conditions <- base::list()
[11:01:52.865]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.865]     if (FALSE) {
[11:01:52.865]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.865]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.865]     }
[11:01:52.865]     ...future.result <- base::tryCatch({
[11:01:52.865]         base::withCallingHandlers({
[11:01:52.865]             ...future.value <- base::withVisible(base::local({
[11:01:52.865]                 pkg
[11:01:52.865]             }))
[11:01:52.865]             future::FutureResult(value = ...future.value$value, 
[11:01:52.865]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.865]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.865]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.865]                     ...future.globalenv.names))
[11:01:52.865]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.865]         }, condition = base::local({
[11:01:52.865]             c <- base::c
[11:01:52.865]             inherits <- base::inherits
[11:01:52.865]             invokeRestart <- base::invokeRestart
[11:01:52.865]             length <- base::length
[11:01:52.865]             list <- base::list
[11:01:52.865]             seq.int <- base::seq.int
[11:01:52.865]             signalCondition <- base::signalCondition
[11:01:52.865]             sys.calls <- base::sys.calls
[11:01:52.865]             `[[` <- base::`[[`
[11:01:52.865]             `+` <- base::`+`
[11:01:52.865]             `<<-` <- base::`<<-`
[11:01:52.865]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.865]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.865]                   3L)]
[11:01:52.865]             }
[11:01:52.865]             function(cond) {
[11:01:52.865]                 is_error <- inherits(cond, "error")
[11:01:52.865]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.865]                   NULL)
[11:01:52.865]                 if (is_error) {
[11:01:52.865]                   sessionInformation <- function() {
[11:01:52.865]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.865]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.865]                       search = base::search(), system = base::Sys.info())
[11:01:52.865]                   }
[11:01:52.865]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.865]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.865]                     cond$call), session = sessionInformation(), 
[11:01:52.865]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.865]                   signalCondition(cond)
[11:01:52.865]                 }
[11:01:52.865]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.865]                 "immediateCondition"))) {
[11:01:52.865]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.865]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.865]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.865]                   if (TRUE && !signal) {
[11:01:52.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.865]                     {
[11:01:52.865]                       inherits <- base::inherits
[11:01:52.865]                       invokeRestart <- base::invokeRestart
[11:01:52.865]                       is.null <- base::is.null
[11:01:52.865]                       muffled <- FALSE
[11:01:52.865]                       if (inherits(cond, "message")) {
[11:01:52.865]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.865]                         if (muffled) 
[11:01:52.865]                           invokeRestart("muffleMessage")
[11:01:52.865]                       }
[11:01:52.865]                       else if (inherits(cond, "warning")) {
[11:01:52.865]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.865]                         if (muffled) 
[11:01:52.865]                           invokeRestart("muffleWarning")
[11:01:52.865]                       }
[11:01:52.865]                       else if (inherits(cond, "condition")) {
[11:01:52.865]                         if (!is.null(pattern)) {
[11:01:52.865]                           computeRestarts <- base::computeRestarts
[11:01:52.865]                           grepl <- base::grepl
[11:01:52.865]                           restarts <- computeRestarts(cond)
[11:01:52.865]                           for (restart in restarts) {
[11:01:52.865]                             name <- restart$name
[11:01:52.865]                             if (is.null(name)) 
[11:01:52.865]                               next
[11:01:52.865]                             if (!grepl(pattern, name)) 
[11:01:52.865]                               next
[11:01:52.865]                             invokeRestart(restart)
[11:01:52.865]                             muffled <- TRUE
[11:01:52.865]                             break
[11:01:52.865]                           }
[11:01:52.865]                         }
[11:01:52.865]                       }
[11:01:52.865]                       invisible(muffled)
[11:01:52.865]                     }
[11:01:52.865]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.865]                   }
[11:01:52.865]                 }
[11:01:52.865]                 else {
[11:01:52.865]                   if (TRUE) {
[11:01:52.865]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.865]                     {
[11:01:52.865]                       inherits <- base::inherits
[11:01:52.865]                       invokeRestart <- base::invokeRestart
[11:01:52.865]                       is.null <- base::is.null
[11:01:52.865]                       muffled <- FALSE
[11:01:52.865]                       if (inherits(cond, "message")) {
[11:01:52.865]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.865]                         if (muffled) 
[11:01:52.865]                           invokeRestart("muffleMessage")
[11:01:52.865]                       }
[11:01:52.865]                       else if (inherits(cond, "warning")) {
[11:01:52.865]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.865]                         if (muffled) 
[11:01:52.865]                           invokeRestart("muffleWarning")
[11:01:52.865]                       }
[11:01:52.865]                       else if (inherits(cond, "condition")) {
[11:01:52.865]                         if (!is.null(pattern)) {
[11:01:52.865]                           computeRestarts <- base::computeRestarts
[11:01:52.865]                           grepl <- base::grepl
[11:01:52.865]                           restarts <- computeRestarts(cond)
[11:01:52.865]                           for (restart in restarts) {
[11:01:52.865]                             name <- restart$name
[11:01:52.865]                             if (is.null(name)) 
[11:01:52.865]                               next
[11:01:52.865]                             if (!grepl(pattern, name)) 
[11:01:52.865]                               next
[11:01:52.865]                             invokeRestart(restart)
[11:01:52.865]                             muffled <- TRUE
[11:01:52.865]                             break
[11:01:52.865]                           }
[11:01:52.865]                         }
[11:01:52.865]                       }
[11:01:52.865]                       invisible(muffled)
[11:01:52.865]                     }
[11:01:52.865]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.865]                   }
[11:01:52.865]                 }
[11:01:52.865]             }
[11:01:52.865]         }))
[11:01:52.865]     }, error = function(ex) {
[11:01:52.865]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.865]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.865]                 ...future.rng), started = ...future.startTime, 
[11:01:52.865]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.865]             version = "1.8"), class = "FutureResult")
[11:01:52.865]     }, finally = {
[11:01:52.865]         if (!identical(...future.workdir, getwd())) 
[11:01:52.865]             setwd(...future.workdir)
[11:01:52.865]         {
[11:01:52.865]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.865]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.865]             }
[11:01:52.865]             base::options(...future.oldOptions)
[11:01:52.865]             if (.Platform$OS.type == "windows") {
[11:01:52.865]                 old_names <- names(...future.oldEnvVars)
[11:01:52.865]                 envs <- base::Sys.getenv()
[11:01:52.865]                 names <- names(envs)
[11:01:52.865]                 common <- intersect(names, old_names)
[11:01:52.865]                 added <- setdiff(names, old_names)
[11:01:52.865]                 removed <- setdiff(old_names, names)
[11:01:52.865]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.865]                   envs[common]]
[11:01:52.865]                 NAMES <- toupper(changed)
[11:01:52.865]                 args <- list()
[11:01:52.865]                 for (kk in seq_along(NAMES)) {
[11:01:52.865]                   name <- changed[[kk]]
[11:01:52.865]                   NAME <- NAMES[[kk]]
[11:01:52.865]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.865]                     next
[11:01:52.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.865]                 }
[11:01:52.865]                 NAMES <- toupper(added)
[11:01:52.865]                 for (kk in seq_along(NAMES)) {
[11:01:52.865]                   name <- added[[kk]]
[11:01:52.865]                   NAME <- NAMES[[kk]]
[11:01:52.865]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.865]                     next
[11:01:52.865]                   args[[name]] <- ""
[11:01:52.865]                 }
[11:01:52.865]                 NAMES <- toupper(removed)
[11:01:52.865]                 for (kk in seq_along(NAMES)) {
[11:01:52.865]                   name <- removed[[kk]]
[11:01:52.865]                   NAME <- NAMES[[kk]]
[11:01:52.865]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.865]                     next
[11:01:52.865]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.865]                 }
[11:01:52.865]                 if (length(args) > 0) 
[11:01:52.865]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.865]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.865]             }
[11:01:52.865]             else {
[11:01:52.865]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.865]             }
[11:01:52.865]             {
[11:01:52.865]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.865]                   0L) {
[11:01:52.865]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.865]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.865]                   base::options(opts)
[11:01:52.865]                 }
[11:01:52.865]                 {
[11:01:52.865]                   {
[11:01:52.865]                     NULL
[11:01:52.865]                     RNGkind("Mersenne-Twister")
[11:01:52.865]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:52.865]                       inherits = FALSE)
[11:01:52.865]                   }
[11:01:52.865]                   options(future.plan = NULL)
[11:01:52.865]                   if (is.na(NA_character_)) 
[11:01:52.865]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.865]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.865]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.865]                     .init = FALSE)
[11:01:52.865]                 }
[11:01:52.865]             }
[11:01:52.865]         }
[11:01:52.865]     })
[11:01:52.865]     if (TRUE) {
[11:01:52.865]         base::sink(type = "output", split = FALSE)
[11:01:52.865]         if (TRUE) {
[11:01:52.865]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.865]         }
[11:01:52.865]         else {
[11:01:52.865]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.865]         }
[11:01:52.865]         base::close(...future.stdout)
[11:01:52.865]         ...future.stdout <- NULL
[11:01:52.865]     }
[11:01:52.865]     ...future.result$conditions <- ...future.conditions
[11:01:52.865]     ...future.result$finished <- base::Sys.time()
[11:01:52.865]     ...future.result
[11:01:52.865] }
[11:01:52.866] assign_globals() ...
[11:01:52.867] List of 1
[11:01:52.867]  $ pkg: chr "foo"
[11:01:52.867]  - attr(*, "where")=List of 1
[11:01:52.867]   ..$ pkg:<environment: R_EmptyEnv> 
[11:01:52.867]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.867]  - attr(*, "resolved")= logi TRUE
[11:01:52.867]  - attr(*, "total_size")= num 42
[11:01:52.869] - copied ‘pkg’ to environment
[11:01:52.870] assign_globals() ... done
[11:01:52.870] plan(): Setting new future strategy stack:
[11:01:52.870] List of future strategies:
[11:01:52.870] 1. sequential:
[11:01:52.870]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.870]    - tweaked: FALSE
[11:01:52.870]    - call: NULL
[11:01:52.871] plan(): nbrOfWorkers() = 1
[11:01:52.871] plan(): Setting new future strategy stack:
[11:01:52.872] List of future strategies:
[11:01:52.872] 1. multicore:
[11:01:52.872]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.872]    - tweaked: FALSE
[11:01:52.872]    - call: plan(strategy)
[11:01:52.873] plan(): nbrOfWorkers() = 2
[11:01:52.874] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.875] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.875] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.877] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.877] Searching for globals ... DONE
[11:01:52.877] Resolving globals: TRUE
[11:01:52.877] Resolving any globals that are futures ...
[11:01:52.877] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.877] Resolving any globals that are futures ... DONE
[11:01:52.878] Resolving futures part of globals (recursively) ...
[11:01:52.878] resolve() on list ...
[11:01:52.878]  recursive: 99
[11:01:52.878]  length: 1
[11:01:52.878]  elements: ‘a’
[11:01:52.878]  length: 0 (resolved future 1)
[11:01:52.878] resolve() on list ... DONE
[11:01:52.878] - globals: [1] ‘a’
[11:01:52.878] Resolving futures part of globals (recursively) ... DONE
[11:01:52.879] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:52.879] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:52.879] - globals: [1] ‘a’
[11:01:52.879] 
[11:01:52.879] getGlobalsAndPackages() ... DONE
[11:01:52.879] run() for ‘Future’ ...
[11:01:52.880] - state: ‘created’
[11:01:52.880] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.881] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.881] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.881]   - Field: ‘label’
[11:01:52.881]   - Field: ‘local’
[11:01:52.882]   - Field: ‘owner’
[11:01:52.882]   - Field: ‘envir’
[11:01:52.882]   - Field: ‘workers’
[11:01:52.882]   - Field: ‘packages’
[11:01:52.882]   - Field: ‘gc’
[11:01:52.882]   - Field: ‘job’
[11:01:52.882]   - Field: ‘conditions’
[11:01:52.882]   - Field: ‘expr’
[11:01:52.882]   - Field: ‘uuid’
[11:01:52.882]   - Field: ‘seed’
[11:01:52.882]   - Field: ‘version’
[11:01:52.882]   - Field: ‘result’
[11:01:52.883]   - Field: ‘asynchronous’
[11:01:52.883]   - Field: ‘calls’
[11:01:52.883]   - Field: ‘globals’
[11:01:52.883]   - Field: ‘stdout’
[11:01:52.883]   - Field: ‘earlySignal’
[11:01:52.883]   - Field: ‘lazy’
[11:01:52.883]   - Field: ‘state’
[11:01:52.883] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.883] - Launch lazy future ...
[11:01:52.883] Packages needed by the future expression (n = 0): <none>
[11:01:52.884] Packages needed by future strategies (n = 0): <none>
[11:01:52.884] {
[11:01:52.884]     {
[11:01:52.884]         {
[11:01:52.884]             ...future.startTime <- base::Sys.time()
[11:01:52.884]             {
[11:01:52.884]                 {
[11:01:52.884]                   {
[11:01:52.884]                     {
[11:01:52.884]                       base::local({
[11:01:52.884]                         has_future <- base::requireNamespace("future", 
[11:01:52.884]                           quietly = TRUE)
[11:01:52.884]                         if (has_future) {
[11:01:52.884]                           ns <- base::getNamespace("future")
[11:01:52.884]                           version <- ns[[".package"]][["version"]]
[11:01:52.884]                           if (is.null(version)) 
[11:01:52.884]                             version <- utils::packageVersion("future")
[11:01:52.884]                         }
[11:01:52.884]                         else {
[11:01:52.884]                           version <- NULL
[11:01:52.884]                         }
[11:01:52.884]                         if (!has_future || version < "1.8.0") {
[11:01:52.884]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.884]                             "", base::R.version$version.string), 
[11:01:52.884]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.884]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.884]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.884]                               "release", "version")], collapse = " "), 
[11:01:52.884]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.884]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.884]                             info)
[11:01:52.884]                           info <- base::paste(info, collapse = "; ")
[11:01:52.884]                           if (!has_future) {
[11:01:52.884]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.884]                               info)
[11:01:52.884]                           }
[11:01:52.884]                           else {
[11:01:52.884]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.884]                               info, version)
[11:01:52.884]                           }
[11:01:52.884]                           base::stop(msg)
[11:01:52.884]                         }
[11:01:52.884]                       })
[11:01:52.884]                     }
[11:01:52.884]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.884]                     base::options(mc.cores = 1L)
[11:01:52.884]                   }
[11:01:52.884]                   ...future.strategy.old <- future::plan("list")
[11:01:52.884]                   options(future.plan = NULL)
[11:01:52.884]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.884]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.884]                 }
[11:01:52.884]                 ...future.workdir <- getwd()
[11:01:52.884]             }
[11:01:52.884]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.884]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.884]         }
[11:01:52.884]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.884]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.884]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.884]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.884]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.884]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.884]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.884]             base::names(...future.oldOptions))
[11:01:52.884]     }
[11:01:52.884]     if (FALSE) {
[11:01:52.884]     }
[11:01:52.884]     else {
[11:01:52.884]         if (TRUE) {
[11:01:52.884]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.884]                 open = "w")
[11:01:52.884]         }
[11:01:52.884]         else {
[11:01:52.884]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.884]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.884]         }
[11:01:52.884]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.884]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.884]             base::sink(type = "output", split = FALSE)
[11:01:52.884]             base::close(...future.stdout)
[11:01:52.884]         }, add = TRUE)
[11:01:52.884]     }
[11:01:52.884]     ...future.frame <- base::sys.nframe()
[11:01:52.884]     ...future.conditions <- base::list()
[11:01:52.884]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.884]     if (FALSE) {
[11:01:52.884]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.884]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.884]     }
[11:01:52.884]     ...future.result <- base::tryCatch({
[11:01:52.884]         base::withCallingHandlers({
[11:01:52.884]             ...future.value <- base::withVisible(base::local({
[11:01:52.884]                 withCallingHandlers({
[11:01:52.884]                   {
[11:01:52.884]                     b <- a
[11:01:52.884]                     a <- 2
[11:01:52.884]                     a * b
[11:01:52.884]                   }
[11:01:52.884]                 }, immediateCondition = function(cond) {
[11:01:52.884]                   save_rds <- function (object, pathname, ...) 
[11:01:52.884]                   {
[11:01:52.884]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.884]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.884]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.884]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.884]                         fi_tmp[["mtime"]])
[11:01:52.884]                     }
[11:01:52.884]                     tryCatch({
[11:01:52.884]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.884]                     }, error = function(ex) {
[11:01:52.884]                       msg <- conditionMessage(ex)
[11:01:52.884]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.884]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.884]                         fi_tmp[["mtime"]], msg)
[11:01:52.884]                       ex$message <- msg
[11:01:52.884]                       stop(ex)
[11:01:52.884]                     })
[11:01:52.884]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.884]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.884]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.884]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.884]                       fi <- file.info(pathname)
[11:01:52.884]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.884]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.884]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.884]                         fi[["size"]], fi[["mtime"]])
[11:01:52.884]                       stop(msg)
[11:01:52.884]                     }
[11:01:52.884]                     invisible(pathname)
[11:01:52.884]                   }
[11:01:52.884]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.884]                     rootPath = tempdir()) 
[11:01:52.884]                   {
[11:01:52.884]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.884]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.884]                       tmpdir = path, fileext = ".rds")
[11:01:52.884]                     save_rds(obj, file)
[11:01:52.884]                   }
[11:01:52.884]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.884]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.884]                   {
[11:01:52.884]                     inherits <- base::inherits
[11:01:52.884]                     invokeRestart <- base::invokeRestart
[11:01:52.884]                     is.null <- base::is.null
[11:01:52.884]                     muffled <- FALSE
[11:01:52.884]                     if (inherits(cond, "message")) {
[11:01:52.884]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.884]                       if (muffled) 
[11:01:52.884]                         invokeRestart("muffleMessage")
[11:01:52.884]                     }
[11:01:52.884]                     else if (inherits(cond, "warning")) {
[11:01:52.884]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.884]                       if (muffled) 
[11:01:52.884]                         invokeRestart("muffleWarning")
[11:01:52.884]                     }
[11:01:52.884]                     else if (inherits(cond, "condition")) {
[11:01:52.884]                       if (!is.null(pattern)) {
[11:01:52.884]                         computeRestarts <- base::computeRestarts
[11:01:52.884]                         grepl <- base::grepl
[11:01:52.884]                         restarts <- computeRestarts(cond)
[11:01:52.884]                         for (restart in restarts) {
[11:01:52.884]                           name <- restart$name
[11:01:52.884]                           if (is.null(name)) 
[11:01:52.884]                             next
[11:01:52.884]                           if (!grepl(pattern, name)) 
[11:01:52.884]                             next
[11:01:52.884]                           invokeRestart(restart)
[11:01:52.884]                           muffled <- TRUE
[11:01:52.884]                           break
[11:01:52.884]                         }
[11:01:52.884]                       }
[11:01:52.884]                     }
[11:01:52.884]                     invisible(muffled)
[11:01:52.884]                   }
[11:01:52.884]                   muffleCondition(cond)
[11:01:52.884]                 })
[11:01:52.884]             }))
[11:01:52.884]             future::FutureResult(value = ...future.value$value, 
[11:01:52.884]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.884]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.884]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.884]                     ...future.globalenv.names))
[11:01:52.884]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.884]         }, condition = base::local({
[11:01:52.884]             c <- base::c
[11:01:52.884]             inherits <- base::inherits
[11:01:52.884]             invokeRestart <- base::invokeRestart
[11:01:52.884]             length <- base::length
[11:01:52.884]             list <- base::list
[11:01:52.884]             seq.int <- base::seq.int
[11:01:52.884]             signalCondition <- base::signalCondition
[11:01:52.884]             sys.calls <- base::sys.calls
[11:01:52.884]             `[[` <- base::`[[`
[11:01:52.884]             `+` <- base::`+`
[11:01:52.884]             `<<-` <- base::`<<-`
[11:01:52.884]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.884]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.884]                   3L)]
[11:01:52.884]             }
[11:01:52.884]             function(cond) {
[11:01:52.884]                 is_error <- inherits(cond, "error")
[11:01:52.884]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.884]                   NULL)
[11:01:52.884]                 if (is_error) {
[11:01:52.884]                   sessionInformation <- function() {
[11:01:52.884]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.884]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.884]                       search = base::search(), system = base::Sys.info())
[11:01:52.884]                   }
[11:01:52.884]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.884]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.884]                     cond$call), session = sessionInformation(), 
[11:01:52.884]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.884]                   signalCondition(cond)
[11:01:52.884]                 }
[11:01:52.884]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.884]                 "immediateCondition"))) {
[11:01:52.884]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.884]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.884]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.884]                   if (TRUE && !signal) {
[11:01:52.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.884]                     {
[11:01:52.884]                       inherits <- base::inherits
[11:01:52.884]                       invokeRestart <- base::invokeRestart
[11:01:52.884]                       is.null <- base::is.null
[11:01:52.884]                       muffled <- FALSE
[11:01:52.884]                       if (inherits(cond, "message")) {
[11:01:52.884]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.884]                         if (muffled) 
[11:01:52.884]                           invokeRestart("muffleMessage")
[11:01:52.884]                       }
[11:01:52.884]                       else if (inherits(cond, "warning")) {
[11:01:52.884]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.884]                         if (muffled) 
[11:01:52.884]                           invokeRestart("muffleWarning")
[11:01:52.884]                       }
[11:01:52.884]                       else if (inherits(cond, "condition")) {
[11:01:52.884]                         if (!is.null(pattern)) {
[11:01:52.884]                           computeRestarts <- base::computeRestarts
[11:01:52.884]                           grepl <- base::grepl
[11:01:52.884]                           restarts <- computeRestarts(cond)
[11:01:52.884]                           for (restart in restarts) {
[11:01:52.884]                             name <- restart$name
[11:01:52.884]                             if (is.null(name)) 
[11:01:52.884]                               next
[11:01:52.884]                             if (!grepl(pattern, name)) 
[11:01:52.884]                               next
[11:01:52.884]                             invokeRestart(restart)
[11:01:52.884]                             muffled <- TRUE
[11:01:52.884]                             break
[11:01:52.884]                           }
[11:01:52.884]                         }
[11:01:52.884]                       }
[11:01:52.884]                       invisible(muffled)
[11:01:52.884]                     }
[11:01:52.884]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.884]                   }
[11:01:52.884]                 }
[11:01:52.884]                 else {
[11:01:52.884]                   if (TRUE) {
[11:01:52.884]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.884]                     {
[11:01:52.884]                       inherits <- base::inherits
[11:01:52.884]                       invokeRestart <- base::invokeRestart
[11:01:52.884]                       is.null <- base::is.null
[11:01:52.884]                       muffled <- FALSE
[11:01:52.884]                       if (inherits(cond, "message")) {
[11:01:52.884]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.884]                         if (muffled) 
[11:01:52.884]                           invokeRestart("muffleMessage")
[11:01:52.884]                       }
[11:01:52.884]                       else if (inherits(cond, "warning")) {
[11:01:52.884]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.884]                         if (muffled) 
[11:01:52.884]                           invokeRestart("muffleWarning")
[11:01:52.884]                       }
[11:01:52.884]                       else if (inherits(cond, "condition")) {
[11:01:52.884]                         if (!is.null(pattern)) {
[11:01:52.884]                           computeRestarts <- base::computeRestarts
[11:01:52.884]                           grepl <- base::grepl
[11:01:52.884]                           restarts <- computeRestarts(cond)
[11:01:52.884]                           for (restart in restarts) {
[11:01:52.884]                             name <- restart$name
[11:01:52.884]                             if (is.null(name)) 
[11:01:52.884]                               next
[11:01:52.884]                             if (!grepl(pattern, name)) 
[11:01:52.884]                               next
[11:01:52.884]                             invokeRestart(restart)
[11:01:52.884]                             muffled <- TRUE
[11:01:52.884]                             break
[11:01:52.884]                           }
[11:01:52.884]                         }
[11:01:52.884]                       }
[11:01:52.884]                       invisible(muffled)
[11:01:52.884]                     }
[11:01:52.884]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.884]                   }
[11:01:52.884]                 }
[11:01:52.884]             }
[11:01:52.884]         }))
[11:01:52.884]     }, error = function(ex) {
[11:01:52.884]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.884]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.884]                 ...future.rng), started = ...future.startTime, 
[11:01:52.884]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.884]             version = "1.8"), class = "FutureResult")
[11:01:52.884]     }, finally = {
[11:01:52.884]         if (!identical(...future.workdir, getwd())) 
[11:01:52.884]             setwd(...future.workdir)
[11:01:52.884]         {
[11:01:52.884]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.884]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.884]             }
[11:01:52.884]             base::options(...future.oldOptions)
[11:01:52.884]             if (.Platform$OS.type == "windows") {
[11:01:52.884]                 old_names <- names(...future.oldEnvVars)
[11:01:52.884]                 envs <- base::Sys.getenv()
[11:01:52.884]                 names <- names(envs)
[11:01:52.884]                 common <- intersect(names, old_names)
[11:01:52.884]                 added <- setdiff(names, old_names)
[11:01:52.884]                 removed <- setdiff(old_names, names)
[11:01:52.884]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.884]                   envs[common]]
[11:01:52.884]                 NAMES <- toupper(changed)
[11:01:52.884]                 args <- list()
[11:01:52.884]                 for (kk in seq_along(NAMES)) {
[11:01:52.884]                   name <- changed[[kk]]
[11:01:52.884]                   NAME <- NAMES[[kk]]
[11:01:52.884]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.884]                     next
[11:01:52.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.884]                 }
[11:01:52.884]                 NAMES <- toupper(added)
[11:01:52.884]                 for (kk in seq_along(NAMES)) {
[11:01:52.884]                   name <- added[[kk]]
[11:01:52.884]                   NAME <- NAMES[[kk]]
[11:01:52.884]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.884]                     next
[11:01:52.884]                   args[[name]] <- ""
[11:01:52.884]                 }
[11:01:52.884]                 NAMES <- toupper(removed)
[11:01:52.884]                 for (kk in seq_along(NAMES)) {
[11:01:52.884]                   name <- removed[[kk]]
[11:01:52.884]                   NAME <- NAMES[[kk]]
[11:01:52.884]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.884]                     next
[11:01:52.884]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.884]                 }
[11:01:52.884]                 if (length(args) > 0) 
[11:01:52.884]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.884]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.884]             }
[11:01:52.884]             else {
[11:01:52.884]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.884]             }
[11:01:52.884]             {
[11:01:52.884]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.884]                   0L) {
[11:01:52.884]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.884]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.884]                   base::options(opts)
[11:01:52.884]                 }
[11:01:52.884]                 {
[11:01:52.884]                   {
[11:01:52.884]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.884]                     NULL
[11:01:52.884]                   }
[11:01:52.884]                   options(future.plan = NULL)
[11:01:52.884]                   if (is.na(NA_character_)) 
[11:01:52.884]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.884]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.884]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.884]                     .init = FALSE)
[11:01:52.884]                 }
[11:01:52.884]             }
[11:01:52.884]         }
[11:01:52.884]     })
[11:01:52.884]     if (TRUE) {
[11:01:52.884]         base::sink(type = "output", split = FALSE)
[11:01:52.884]         if (TRUE) {
[11:01:52.884]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.884]         }
[11:01:52.884]         else {
[11:01:52.884]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.884]         }
[11:01:52.884]         base::close(...future.stdout)
[11:01:52.884]         ...future.stdout <- NULL
[11:01:52.884]     }
[11:01:52.884]     ...future.result$conditions <- ...future.conditions
[11:01:52.884]     ...future.result$finished <- base::Sys.time()
[11:01:52.884]     ...future.result
[11:01:52.884] }
[11:01:52.886] assign_globals() ...
[11:01:52.886] List of 1
[11:01:52.886]  $ a: num 3
[11:01:52.886]  - attr(*, "where")=List of 1
[11:01:52.886]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.886]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.886]  - attr(*, "resolved")= logi TRUE
[11:01:52.886]  - attr(*, "total_size")= num 39
[11:01:52.886]  - attr(*, "already-done")= logi TRUE
[11:01:52.889] - copied ‘a’ to environment
[11:01:52.889] assign_globals() ... done
[11:01:52.889] requestCore(): workers = 2
[11:01:52.891] MulticoreFuture started
[11:01:52.891] - Launch lazy future ... done
[11:01:52.891] run() for ‘MulticoreFuture’ ... done
[11:01:52.891] plan(): Setting new future strategy stack:
[11:01:52.892] result() for MulticoreFuture ...
[11:01:52.892] List of future strategies:
[11:01:52.892] 1. sequential:
[11:01:52.892]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.892]    - tweaked: FALSE
[11:01:52.892]    - call: NULL
[11:01:52.893] plan(): nbrOfWorkers() = 1
[11:01:52.900] plan(): Setting new future strategy stack:
[11:01:52.900] List of future strategies:
[11:01:52.900] 1. multicore:
[11:01:52.900]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.900]    - tweaked: FALSE
[11:01:52.900]    - call: plan(strategy)
[11:01:52.903] plan(): nbrOfWorkers() = 2
[11:01:52.904] result() for MulticoreFuture ...
[11:01:52.907] result() for MulticoreFuture ... done
[11:01:52.907] result() for MulticoreFuture ... done
[11:01:52.907] result() for MulticoreFuture ...
[11:01:52.907] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.909] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.909] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.912] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.912] Searching for globals ... DONE
[11:01:52.912] Resolving globals: TRUE
[11:01:52.912] Resolving any globals that are futures ...
[11:01:52.912] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:52.913] Resolving any globals that are futures ... DONE
[11:01:52.913] Resolving futures part of globals (recursively) ...
[11:01:52.913] resolve() on list ...
[11:01:52.913]  recursive: 99
[11:01:52.914]  length: 1
[11:01:52.914]  elements: ‘a’
[11:01:52.914]  length: 0 (resolved future 1)
[11:01:52.914] resolve() on list ... DONE
[11:01:52.914] - globals: [1] ‘a’
[11:01:52.914] Resolving futures part of globals (recursively) ... DONE
[11:01:52.914] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:52.915] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:52.915] - globals: [1] ‘a’
[11:01:52.915] 
[11:01:52.915] getGlobalsAndPackages() ... DONE
[11:01:52.915] run() for ‘Future’ ...
[11:01:52.916] - state: ‘created’
[11:01:52.916] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.918] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.918] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.918]   - Field: ‘label’
[11:01:52.918]   - Field: ‘local’
[11:01:52.918]   - Field: ‘owner’
[11:01:52.918]   - Field: ‘envir’
[11:01:52.918]   - Field: ‘workers’
[11:01:52.918]   - Field: ‘packages’
[11:01:52.918]   - Field: ‘gc’
[11:01:52.919]   - Field: ‘job’
[11:01:52.919]   - Field: ‘conditions’
[11:01:52.919]   - Field: ‘expr’
[11:01:52.919]   - Field: ‘uuid’
[11:01:52.919]   - Field: ‘seed’
[11:01:52.919]   - Field: ‘version’
[11:01:52.919]   - Field: ‘result’
[11:01:52.919]   - Field: ‘asynchronous’
[11:01:52.919]   - Field: ‘calls’
[11:01:52.919]   - Field: ‘globals’
[11:01:52.920]   - Field: ‘stdout’
[11:01:52.920]   - Field: ‘earlySignal’
[11:01:52.920]   - Field: ‘lazy’
[11:01:52.920]   - Field: ‘state’
[11:01:52.920] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.920] - Launch lazy future ...
[11:01:52.920] Packages needed by the future expression (n = 0): <none>
[11:01:52.921] Packages needed by future strategies (n = 0): <none>
[11:01:52.921] {
[11:01:52.921]     {
[11:01:52.921]         {
[11:01:52.921]             ...future.startTime <- base::Sys.time()
[11:01:52.921]             {
[11:01:52.921]                 {
[11:01:52.921]                   {
[11:01:52.921]                     {
[11:01:52.921]                       base::local({
[11:01:52.921]                         has_future <- base::requireNamespace("future", 
[11:01:52.921]                           quietly = TRUE)
[11:01:52.921]                         if (has_future) {
[11:01:52.921]                           ns <- base::getNamespace("future")
[11:01:52.921]                           version <- ns[[".package"]][["version"]]
[11:01:52.921]                           if (is.null(version)) 
[11:01:52.921]                             version <- utils::packageVersion("future")
[11:01:52.921]                         }
[11:01:52.921]                         else {
[11:01:52.921]                           version <- NULL
[11:01:52.921]                         }
[11:01:52.921]                         if (!has_future || version < "1.8.0") {
[11:01:52.921]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.921]                             "", base::R.version$version.string), 
[11:01:52.921]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.921]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.921]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.921]                               "release", "version")], collapse = " "), 
[11:01:52.921]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.921]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.921]                             info)
[11:01:52.921]                           info <- base::paste(info, collapse = "; ")
[11:01:52.921]                           if (!has_future) {
[11:01:52.921]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.921]                               info)
[11:01:52.921]                           }
[11:01:52.921]                           else {
[11:01:52.921]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.921]                               info, version)
[11:01:52.921]                           }
[11:01:52.921]                           base::stop(msg)
[11:01:52.921]                         }
[11:01:52.921]                       })
[11:01:52.921]                     }
[11:01:52.921]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.921]                     base::options(mc.cores = 1L)
[11:01:52.921]                   }
[11:01:52.921]                   ...future.strategy.old <- future::plan("list")
[11:01:52.921]                   options(future.plan = NULL)
[11:01:52.921]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.921]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.921]                 }
[11:01:52.921]                 ...future.workdir <- getwd()
[11:01:52.921]             }
[11:01:52.921]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.921]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.921]         }
[11:01:52.921]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.921]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.921]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.921]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.921]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.921]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.921]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.921]             base::names(...future.oldOptions))
[11:01:52.921]     }
[11:01:52.921]     if (FALSE) {
[11:01:52.921]     }
[11:01:52.921]     else {
[11:01:52.921]         if (TRUE) {
[11:01:52.921]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.921]                 open = "w")
[11:01:52.921]         }
[11:01:52.921]         else {
[11:01:52.921]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.921]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.921]         }
[11:01:52.921]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.921]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.921]             base::sink(type = "output", split = FALSE)
[11:01:52.921]             base::close(...future.stdout)
[11:01:52.921]         }, add = TRUE)
[11:01:52.921]     }
[11:01:52.921]     ...future.frame <- base::sys.nframe()
[11:01:52.921]     ...future.conditions <- base::list()
[11:01:52.921]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.921]     if (FALSE) {
[11:01:52.921]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.921]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.921]     }
[11:01:52.921]     ...future.result <- base::tryCatch({
[11:01:52.921]         base::withCallingHandlers({
[11:01:52.921]             ...future.value <- base::withVisible(base::local({
[11:01:52.921]                 withCallingHandlers({
[11:01:52.921]                   {
[11:01:52.921]                     b <- a
[11:01:52.921]                     a <- 2
[11:01:52.921]                     a * b
[11:01:52.921]                   }
[11:01:52.921]                 }, immediateCondition = function(cond) {
[11:01:52.921]                   save_rds <- function (object, pathname, ...) 
[11:01:52.921]                   {
[11:01:52.921]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.921]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.921]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.921]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.921]                         fi_tmp[["mtime"]])
[11:01:52.921]                     }
[11:01:52.921]                     tryCatch({
[11:01:52.921]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.921]                     }, error = function(ex) {
[11:01:52.921]                       msg <- conditionMessage(ex)
[11:01:52.921]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.921]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.921]                         fi_tmp[["mtime"]], msg)
[11:01:52.921]                       ex$message <- msg
[11:01:52.921]                       stop(ex)
[11:01:52.921]                     })
[11:01:52.921]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.921]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.921]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.921]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.921]                       fi <- file.info(pathname)
[11:01:52.921]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.921]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.921]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.921]                         fi[["size"]], fi[["mtime"]])
[11:01:52.921]                       stop(msg)
[11:01:52.921]                     }
[11:01:52.921]                     invisible(pathname)
[11:01:52.921]                   }
[11:01:52.921]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.921]                     rootPath = tempdir()) 
[11:01:52.921]                   {
[11:01:52.921]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.921]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.921]                       tmpdir = path, fileext = ".rds")
[11:01:52.921]                     save_rds(obj, file)
[11:01:52.921]                   }
[11:01:52.921]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.921]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.921]                   {
[11:01:52.921]                     inherits <- base::inherits
[11:01:52.921]                     invokeRestart <- base::invokeRestart
[11:01:52.921]                     is.null <- base::is.null
[11:01:52.921]                     muffled <- FALSE
[11:01:52.921]                     if (inherits(cond, "message")) {
[11:01:52.921]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.921]                       if (muffled) 
[11:01:52.921]                         invokeRestart("muffleMessage")
[11:01:52.921]                     }
[11:01:52.921]                     else if (inherits(cond, "warning")) {
[11:01:52.921]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.921]                       if (muffled) 
[11:01:52.921]                         invokeRestart("muffleWarning")
[11:01:52.921]                     }
[11:01:52.921]                     else if (inherits(cond, "condition")) {
[11:01:52.921]                       if (!is.null(pattern)) {
[11:01:52.921]                         computeRestarts <- base::computeRestarts
[11:01:52.921]                         grepl <- base::grepl
[11:01:52.921]                         restarts <- computeRestarts(cond)
[11:01:52.921]                         for (restart in restarts) {
[11:01:52.921]                           name <- restart$name
[11:01:52.921]                           if (is.null(name)) 
[11:01:52.921]                             next
[11:01:52.921]                           if (!grepl(pattern, name)) 
[11:01:52.921]                             next
[11:01:52.921]                           invokeRestart(restart)
[11:01:52.921]                           muffled <- TRUE
[11:01:52.921]                           break
[11:01:52.921]                         }
[11:01:52.921]                       }
[11:01:52.921]                     }
[11:01:52.921]                     invisible(muffled)
[11:01:52.921]                   }
[11:01:52.921]                   muffleCondition(cond)
[11:01:52.921]                 })
[11:01:52.921]             }))
[11:01:52.921]             future::FutureResult(value = ...future.value$value, 
[11:01:52.921]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.921]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.921]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.921]                     ...future.globalenv.names))
[11:01:52.921]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.921]         }, condition = base::local({
[11:01:52.921]             c <- base::c
[11:01:52.921]             inherits <- base::inherits
[11:01:52.921]             invokeRestart <- base::invokeRestart
[11:01:52.921]             length <- base::length
[11:01:52.921]             list <- base::list
[11:01:52.921]             seq.int <- base::seq.int
[11:01:52.921]             signalCondition <- base::signalCondition
[11:01:52.921]             sys.calls <- base::sys.calls
[11:01:52.921]             `[[` <- base::`[[`
[11:01:52.921]             `+` <- base::`+`
[11:01:52.921]             `<<-` <- base::`<<-`
[11:01:52.921]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.921]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.921]                   3L)]
[11:01:52.921]             }
[11:01:52.921]             function(cond) {
[11:01:52.921]                 is_error <- inherits(cond, "error")
[11:01:52.921]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.921]                   NULL)
[11:01:52.921]                 if (is_error) {
[11:01:52.921]                   sessionInformation <- function() {
[11:01:52.921]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.921]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.921]                       search = base::search(), system = base::Sys.info())
[11:01:52.921]                   }
[11:01:52.921]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.921]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.921]                     cond$call), session = sessionInformation(), 
[11:01:52.921]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.921]                   signalCondition(cond)
[11:01:52.921]                 }
[11:01:52.921]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.921]                 "immediateCondition"))) {
[11:01:52.921]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.921]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.921]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.921]                   if (TRUE && !signal) {
[11:01:52.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.921]                     {
[11:01:52.921]                       inherits <- base::inherits
[11:01:52.921]                       invokeRestart <- base::invokeRestart
[11:01:52.921]                       is.null <- base::is.null
[11:01:52.921]                       muffled <- FALSE
[11:01:52.921]                       if (inherits(cond, "message")) {
[11:01:52.921]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.921]                         if (muffled) 
[11:01:52.921]                           invokeRestart("muffleMessage")
[11:01:52.921]                       }
[11:01:52.921]                       else if (inherits(cond, "warning")) {
[11:01:52.921]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.921]                         if (muffled) 
[11:01:52.921]                           invokeRestart("muffleWarning")
[11:01:52.921]                       }
[11:01:52.921]                       else if (inherits(cond, "condition")) {
[11:01:52.921]                         if (!is.null(pattern)) {
[11:01:52.921]                           computeRestarts <- base::computeRestarts
[11:01:52.921]                           grepl <- base::grepl
[11:01:52.921]                           restarts <- computeRestarts(cond)
[11:01:52.921]                           for (restart in restarts) {
[11:01:52.921]                             name <- restart$name
[11:01:52.921]                             if (is.null(name)) 
[11:01:52.921]                               next
[11:01:52.921]                             if (!grepl(pattern, name)) 
[11:01:52.921]                               next
[11:01:52.921]                             invokeRestart(restart)
[11:01:52.921]                             muffled <- TRUE
[11:01:52.921]                             break
[11:01:52.921]                           }
[11:01:52.921]                         }
[11:01:52.921]                       }
[11:01:52.921]                       invisible(muffled)
[11:01:52.921]                     }
[11:01:52.921]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.921]                   }
[11:01:52.921]                 }
[11:01:52.921]                 else {
[11:01:52.921]                   if (TRUE) {
[11:01:52.921]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.921]                     {
[11:01:52.921]                       inherits <- base::inherits
[11:01:52.921]                       invokeRestart <- base::invokeRestart
[11:01:52.921]                       is.null <- base::is.null
[11:01:52.921]                       muffled <- FALSE
[11:01:52.921]                       if (inherits(cond, "message")) {
[11:01:52.921]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.921]                         if (muffled) 
[11:01:52.921]                           invokeRestart("muffleMessage")
[11:01:52.921]                       }
[11:01:52.921]                       else if (inherits(cond, "warning")) {
[11:01:52.921]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.921]                         if (muffled) 
[11:01:52.921]                           invokeRestart("muffleWarning")
[11:01:52.921]                       }
[11:01:52.921]                       else if (inherits(cond, "condition")) {
[11:01:52.921]                         if (!is.null(pattern)) {
[11:01:52.921]                           computeRestarts <- base::computeRestarts
[11:01:52.921]                           grepl <- base::grepl
[11:01:52.921]                           restarts <- computeRestarts(cond)
[11:01:52.921]                           for (restart in restarts) {
[11:01:52.921]                             name <- restart$name
[11:01:52.921]                             if (is.null(name)) 
[11:01:52.921]                               next
[11:01:52.921]                             if (!grepl(pattern, name)) 
[11:01:52.921]                               next
[11:01:52.921]                             invokeRestart(restart)
[11:01:52.921]                             muffled <- TRUE
[11:01:52.921]                             break
[11:01:52.921]                           }
[11:01:52.921]                         }
[11:01:52.921]                       }
[11:01:52.921]                       invisible(muffled)
[11:01:52.921]                     }
[11:01:52.921]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.921]                   }
[11:01:52.921]                 }
[11:01:52.921]             }
[11:01:52.921]         }))
[11:01:52.921]     }, error = function(ex) {
[11:01:52.921]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.921]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.921]                 ...future.rng), started = ...future.startTime, 
[11:01:52.921]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.921]             version = "1.8"), class = "FutureResult")
[11:01:52.921]     }, finally = {
[11:01:52.921]         if (!identical(...future.workdir, getwd())) 
[11:01:52.921]             setwd(...future.workdir)
[11:01:52.921]         {
[11:01:52.921]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.921]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.921]             }
[11:01:52.921]             base::options(...future.oldOptions)
[11:01:52.921]             if (.Platform$OS.type == "windows") {
[11:01:52.921]                 old_names <- names(...future.oldEnvVars)
[11:01:52.921]                 envs <- base::Sys.getenv()
[11:01:52.921]                 names <- names(envs)
[11:01:52.921]                 common <- intersect(names, old_names)
[11:01:52.921]                 added <- setdiff(names, old_names)
[11:01:52.921]                 removed <- setdiff(old_names, names)
[11:01:52.921]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.921]                   envs[common]]
[11:01:52.921]                 NAMES <- toupper(changed)
[11:01:52.921]                 args <- list()
[11:01:52.921]                 for (kk in seq_along(NAMES)) {
[11:01:52.921]                   name <- changed[[kk]]
[11:01:52.921]                   NAME <- NAMES[[kk]]
[11:01:52.921]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.921]                     next
[11:01:52.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.921]                 }
[11:01:52.921]                 NAMES <- toupper(added)
[11:01:52.921]                 for (kk in seq_along(NAMES)) {
[11:01:52.921]                   name <- added[[kk]]
[11:01:52.921]                   NAME <- NAMES[[kk]]
[11:01:52.921]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.921]                     next
[11:01:52.921]                   args[[name]] <- ""
[11:01:52.921]                 }
[11:01:52.921]                 NAMES <- toupper(removed)
[11:01:52.921]                 for (kk in seq_along(NAMES)) {
[11:01:52.921]                   name <- removed[[kk]]
[11:01:52.921]                   NAME <- NAMES[[kk]]
[11:01:52.921]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.921]                     next
[11:01:52.921]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.921]                 }
[11:01:52.921]                 if (length(args) > 0) 
[11:01:52.921]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.921]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.921]             }
[11:01:52.921]             else {
[11:01:52.921]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.921]             }
[11:01:52.921]             {
[11:01:52.921]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.921]                   0L) {
[11:01:52.921]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.921]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.921]                   base::options(opts)
[11:01:52.921]                 }
[11:01:52.921]                 {
[11:01:52.921]                   {
[11:01:52.921]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.921]                     NULL
[11:01:52.921]                   }
[11:01:52.921]                   options(future.plan = NULL)
[11:01:52.921]                   if (is.na(NA_character_)) 
[11:01:52.921]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.921]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.921]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.921]                     .init = FALSE)
[11:01:52.921]                 }
[11:01:52.921]             }
[11:01:52.921]         }
[11:01:52.921]     })
[11:01:52.921]     if (TRUE) {
[11:01:52.921]         base::sink(type = "output", split = FALSE)
[11:01:52.921]         if (TRUE) {
[11:01:52.921]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.921]         }
[11:01:52.921]         else {
[11:01:52.921]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.921]         }
[11:01:52.921]         base::close(...future.stdout)
[11:01:52.921]         ...future.stdout <- NULL
[11:01:52.921]     }
[11:01:52.921]     ...future.result$conditions <- ...future.conditions
[11:01:52.921]     ...future.result$finished <- base::Sys.time()
[11:01:52.921]     ...future.result
[11:01:52.921] }
[11:01:52.923] assign_globals() ...
[11:01:52.923] List of 1
[11:01:52.923]  $ a: num 3
[11:01:52.923]  - attr(*, "where")=List of 1
[11:01:52.923]   ..$ a:<environment: R_EmptyEnv> 
[11:01:52.923]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.923]  - attr(*, "resolved")= logi TRUE
[11:01:52.923]  - attr(*, "total_size")= num 39
[11:01:52.923]  - attr(*, "already-done")= logi TRUE
[11:01:52.926] - copied ‘a’ to environment
[11:01:52.926] assign_globals() ... done
[11:01:52.926] requestCore(): workers = 2
[11:01:52.928] MulticoreFuture started
[11:01:52.928] - Launch lazy future ... done
[11:01:52.929] run() for ‘MulticoreFuture’ ... done
[11:01:52.929] result() for MulticoreFuture ...
[11:01:52.929] plan(): Setting new future strategy stack:
[11:01:52.929] List of future strategies:
[11:01:52.929] 1. sequential:
[11:01:52.929]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.929]    - tweaked: FALSE
[11:01:52.929]    - call: NULL
[11:01:52.930] plan(): nbrOfWorkers() = 1
[11:01:52.932] plan(): Setting new future strategy stack:
[11:01:52.932] List of future strategies:
[11:01:52.932] 1. multicore:
[11:01:52.932]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.932]    - tweaked: FALSE
[11:01:52.932]    - call: plan(strategy)
[11:01:52.935] plan(): nbrOfWorkers() = 2
[11:01:52.936] result() for MulticoreFuture ...
[11:01:52.936] result() for MulticoreFuture ... done
[11:01:52.937] result() for MulticoreFuture ... done
[11:01:52.937] result() for MulticoreFuture ...
[11:01:52.937] result() for MulticoreFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.938] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.938] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.940] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.941] Searching for globals ... DONE
[11:01:52.941] Resolving globals: TRUE
[11:01:52.941] Resolving any globals that are futures ...
[11:01:52.941] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.941] Resolving any globals that are futures ... DONE
[11:01:52.942] Resolving futures part of globals (recursively) ...
[11:01:52.942] resolve() on list ...
[11:01:52.942]  recursive: 99
[11:01:52.942]  length: 2
[11:01:52.942]  elements: ‘a’, ‘ii’
[11:01:52.942]  length: 1 (resolved future 1)
[11:01:52.943]  length: 0 (resolved future 2)
[11:01:52.943] resolve() on list ... DONE
[11:01:52.945] - globals: [2] ‘a’, ‘ii’
[11:01:52.945] Resolving futures part of globals (recursively) ... DONE
[11:01:52.945] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.946] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.946] - globals: [2] ‘a’, ‘ii’
[11:01:52.946] 
[11:01:52.946] getGlobalsAndPackages() ... DONE
[11:01:52.947] run() for ‘Future’ ...
[11:01:52.947] - state: ‘created’
[11:01:52.947] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.949] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.949] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.949]   - Field: ‘label’
[11:01:52.949]   - Field: ‘local’
[11:01:52.950]   - Field: ‘owner’
[11:01:52.950]   - Field: ‘envir’
[11:01:52.950]   - Field: ‘workers’
[11:01:52.950]   - Field: ‘packages’
[11:01:52.950]   - Field: ‘gc’
[11:01:52.950]   - Field: ‘job’
[11:01:52.950]   - Field: ‘conditions’
[11:01:52.950]   - Field: ‘expr’
[11:01:52.951]   - Field: ‘uuid’
[11:01:52.951]   - Field: ‘seed’
[11:01:52.951]   - Field: ‘version’
[11:01:52.951]   - Field: ‘result’
[11:01:52.951]   - Field: ‘asynchronous’
[11:01:52.951]   - Field: ‘calls’
[11:01:52.951]   - Field: ‘globals’
[11:01:52.951]   - Field: ‘stdout’
[11:01:52.951]   - Field: ‘earlySignal’
[11:01:52.952]   - Field: ‘lazy’
[11:01:52.952]   - Field: ‘state’
[11:01:52.952] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.952] - Launch lazy future ...
[11:01:52.952] Packages needed by the future expression (n = 0): <none>
[11:01:52.952] Packages needed by future strategies (n = 0): <none>
[11:01:52.953] {
[11:01:52.953]     {
[11:01:52.953]         {
[11:01:52.953]             ...future.startTime <- base::Sys.time()
[11:01:52.953]             {
[11:01:52.953]                 {
[11:01:52.953]                   {
[11:01:52.953]                     {
[11:01:52.953]                       base::local({
[11:01:52.953]                         has_future <- base::requireNamespace("future", 
[11:01:52.953]                           quietly = TRUE)
[11:01:52.953]                         if (has_future) {
[11:01:52.953]                           ns <- base::getNamespace("future")
[11:01:52.953]                           version <- ns[[".package"]][["version"]]
[11:01:52.953]                           if (is.null(version)) 
[11:01:52.953]                             version <- utils::packageVersion("future")
[11:01:52.953]                         }
[11:01:52.953]                         else {
[11:01:52.953]                           version <- NULL
[11:01:52.953]                         }
[11:01:52.953]                         if (!has_future || version < "1.8.0") {
[11:01:52.953]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.953]                             "", base::R.version$version.string), 
[11:01:52.953]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.953]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.953]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.953]                               "release", "version")], collapse = " "), 
[11:01:52.953]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.953]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.953]                             info)
[11:01:52.953]                           info <- base::paste(info, collapse = "; ")
[11:01:52.953]                           if (!has_future) {
[11:01:52.953]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.953]                               info)
[11:01:52.953]                           }
[11:01:52.953]                           else {
[11:01:52.953]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.953]                               info, version)
[11:01:52.953]                           }
[11:01:52.953]                           base::stop(msg)
[11:01:52.953]                         }
[11:01:52.953]                       })
[11:01:52.953]                     }
[11:01:52.953]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.953]                     base::options(mc.cores = 1L)
[11:01:52.953]                   }
[11:01:52.953]                   ...future.strategy.old <- future::plan("list")
[11:01:52.953]                   options(future.plan = NULL)
[11:01:52.953]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.953]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.953]                 }
[11:01:52.953]                 ...future.workdir <- getwd()
[11:01:52.953]             }
[11:01:52.953]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.953]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.953]         }
[11:01:52.953]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.953]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.953]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.953]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.953]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.953]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.953]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.953]             base::names(...future.oldOptions))
[11:01:52.953]     }
[11:01:52.953]     if (FALSE) {
[11:01:52.953]     }
[11:01:52.953]     else {
[11:01:52.953]         if (TRUE) {
[11:01:52.953]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.953]                 open = "w")
[11:01:52.953]         }
[11:01:52.953]         else {
[11:01:52.953]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.953]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.953]         }
[11:01:52.953]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.953]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.953]             base::sink(type = "output", split = FALSE)
[11:01:52.953]             base::close(...future.stdout)
[11:01:52.953]         }, add = TRUE)
[11:01:52.953]     }
[11:01:52.953]     ...future.frame <- base::sys.nframe()
[11:01:52.953]     ...future.conditions <- base::list()
[11:01:52.953]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.953]     if (FALSE) {
[11:01:52.953]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.953]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.953]     }
[11:01:52.953]     ...future.result <- base::tryCatch({
[11:01:52.953]         base::withCallingHandlers({
[11:01:52.953]             ...future.value <- base::withVisible(base::local({
[11:01:52.953]                 withCallingHandlers({
[11:01:52.953]                   {
[11:01:52.953]                     b <- a * ii
[11:01:52.953]                     a <- 0
[11:01:52.953]                     b
[11:01:52.953]                   }
[11:01:52.953]                 }, immediateCondition = function(cond) {
[11:01:52.953]                   save_rds <- function (object, pathname, ...) 
[11:01:52.953]                   {
[11:01:52.953]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.953]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.953]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.953]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.953]                         fi_tmp[["mtime"]])
[11:01:52.953]                     }
[11:01:52.953]                     tryCatch({
[11:01:52.953]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.953]                     }, error = function(ex) {
[11:01:52.953]                       msg <- conditionMessage(ex)
[11:01:52.953]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.953]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.953]                         fi_tmp[["mtime"]], msg)
[11:01:52.953]                       ex$message <- msg
[11:01:52.953]                       stop(ex)
[11:01:52.953]                     })
[11:01:52.953]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.953]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.953]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.953]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.953]                       fi <- file.info(pathname)
[11:01:52.953]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.953]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.953]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.953]                         fi[["size"]], fi[["mtime"]])
[11:01:52.953]                       stop(msg)
[11:01:52.953]                     }
[11:01:52.953]                     invisible(pathname)
[11:01:52.953]                   }
[11:01:52.953]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.953]                     rootPath = tempdir()) 
[11:01:52.953]                   {
[11:01:52.953]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.953]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.953]                       tmpdir = path, fileext = ".rds")
[11:01:52.953]                     save_rds(obj, file)
[11:01:52.953]                   }
[11:01:52.953]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.953]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.953]                   {
[11:01:52.953]                     inherits <- base::inherits
[11:01:52.953]                     invokeRestart <- base::invokeRestart
[11:01:52.953]                     is.null <- base::is.null
[11:01:52.953]                     muffled <- FALSE
[11:01:52.953]                     if (inherits(cond, "message")) {
[11:01:52.953]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.953]                       if (muffled) 
[11:01:52.953]                         invokeRestart("muffleMessage")
[11:01:52.953]                     }
[11:01:52.953]                     else if (inherits(cond, "warning")) {
[11:01:52.953]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.953]                       if (muffled) 
[11:01:52.953]                         invokeRestart("muffleWarning")
[11:01:52.953]                     }
[11:01:52.953]                     else if (inherits(cond, "condition")) {
[11:01:52.953]                       if (!is.null(pattern)) {
[11:01:52.953]                         computeRestarts <- base::computeRestarts
[11:01:52.953]                         grepl <- base::grepl
[11:01:52.953]                         restarts <- computeRestarts(cond)
[11:01:52.953]                         for (restart in restarts) {
[11:01:52.953]                           name <- restart$name
[11:01:52.953]                           if (is.null(name)) 
[11:01:52.953]                             next
[11:01:52.953]                           if (!grepl(pattern, name)) 
[11:01:52.953]                             next
[11:01:52.953]                           invokeRestart(restart)
[11:01:52.953]                           muffled <- TRUE
[11:01:52.953]                           break
[11:01:52.953]                         }
[11:01:52.953]                       }
[11:01:52.953]                     }
[11:01:52.953]                     invisible(muffled)
[11:01:52.953]                   }
[11:01:52.953]                   muffleCondition(cond)
[11:01:52.953]                 })
[11:01:52.953]             }))
[11:01:52.953]             future::FutureResult(value = ...future.value$value, 
[11:01:52.953]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.953]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.953]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.953]                     ...future.globalenv.names))
[11:01:52.953]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.953]         }, condition = base::local({
[11:01:52.953]             c <- base::c
[11:01:52.953]             inherits <- base::inherits
[11:01:52.953]             invokeRestart <- base::invokeRestart
[11:01:52.953]             length <- base::length
[11:01:52.953]             list <- base::list
[11:01:52.953]             seq.int <- base::seq.int
[11:01:52.953]             signalCondition <- base::signalCondition
[11:01:52.953]             sys.calls <- base::sys.calls
[11:01:52.953]             `[[` <- base::`[[`
[11:01:52.953]             `+` <- base::`+`
[11:01:52.953]             `<<-` <- base::`<<-`
[11:01:52.953]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.953]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.953]                   3L)]
[11:01:52.953]             }
[11:01:52.953]             function(cond) {
[11:01:52.953]                 is_error <- inherits(cond, "error")
[11:01:52.953]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.953]                   NULL)
[11:01:52.953]                 if (is_error) {
[11:01:52.953]                   sessionInformation <- function() {
[11:01:52.953]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.953]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.953]                       search = base::search(), system = base::Sys.info())
[11:01:52.953]                   }
[11:01:52.953]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.953]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.953]                     cond$call), session = sessionInformation(), 
[11:01:52.953]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.953]                   signalCondition(cond)
[11:01:52.953]                 }
[11:01:52.953]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.953]                 "immediateCondition"))) {
[11:01:52.953]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.953]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.953]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.953]                   if (TRUE && !signal) {
[11:01:52.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.953]                     {
[11:01:52.953]                       inherits <- base::inherits
[11:01:52.953]                       invokeRestart <- base::invokeRestart
[11:01:52.953]                       is.null <- base::is.null
[11:01:52.953]                       muffled <- FALSE
[11:01:52.953]                       if (inherits(cond, "message")) {
[11:01:52.953]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.953]                         if (muffled) 
[11:01:52.953]                           invokeRestart("muffleMessage")
[11:01:52.953]                       }
[11:01:52.953]                       else if (inherits(cond, "warning")) {
[11:01:52.953]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.953]                         if (muffled) 
[11:01:52.953]                           invokeRestart("muffleWarning")
[11:01:52.953]                       }
[11:01:52.953]                       else if (inherits(cond, "condition")) {
[11:01:52.953]                         if (!is.null(pattern)) {
[11:01:52.953]                           computeRestarts <- base::computeRestarts
[11:01:52.953]                           grepl <- base::grepl
[11:01:52.953]                           restarts <- computeRestarts(cond)
[11:01:52.953]                           for (restart in restarts) {
[11:01:52.953]                             name <- restart$name
[11:01:52.953]                             if (is.null(name)) 
[11:01:52.953]                               next
[11:01:52.953]                             if (!grepl(pattern, name)) 
[11:01:52.953]                               next
[11:01:52.953]                             invokeRestart(restart)
[11:01:52.953]                             muffled <- TRUE
[11:01:52.953]                             break
[11:01:52.953]                           }
[11:01:52.953]                         }
[11:01:52.953]                       }
[11:01:52.953]                       invisible(muffled)
[11:01:52.953]                     }
[11:01:52.953]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.953]                   }
[11:01:52.953]                 }
[11:01:52.953]                 else {
[11:01:52.953]                   if (TRUE) {
[11:01:52.953]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.953]                     {
[11:01:52.953]                       inherits <- base::inherits
[11:01:52.953]                       invokeRestart <- base::invokeRestart
[11:01:52.953]                       is.null <- base::is.null
[11:01:52.953]                       muffled <- FALSE
[11:01:52.953]                       if (inherits(cond, "message")) {
[11:01:52.953]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.953]                         if (muffled) 
[11:01:52.953]                           invokeRestart("muffleMessage")
[11:01:52.953]                       }
[11:01:52.953]                       else if (inherits(cond, "warning")) {
[11:01:52.953]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.953]                         if (muffled) 
[11:01:52.953]                           invokeRestart("muffleWarning")
[11:01:52.953]                       }
[11:01:52.953]                       else if (inherits(cond, "condition")) {
[11:01:52.953]                         if (!is.null(pattern)) {
[11:01:52.953]                           computeRestarts <- base::computeRestarts
[11:01:52.953]                           grepl <- base::grepl
[11:01:52.953]                           restarts <- computeRestarts(cond)
[11:01:52.953]                           for (restart in restarts) {
[11:01:52.953]                             name <- restart$name
[11:01:52.953]                             if (is.null(name)) 
[11:01:52.953]                               next
[11:01:52.953]                             if (!grepl(pattern, name)) 
[11:01:52.953]                               next
[11:01:52.953]                             invokeRestart(restart)
[11:01:52.953]                             muffled <- TRUE
[11:01:52.953]                             break
[11:01:52.953]                           }
[11:01:52.953]                         }
[11:01:52.953]                       }
[11:01:52.953]                       invisible(muffled)
[11:01:52.953]                     }
[11:01:52.953]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.953]                   }
[11:01:52.953]                 }
[11:01:52.953]             }
[11:01:52.953]         }))
[11:01:52.953]     }, error = function(ex) {
[11:01:52.953]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.953]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.953]                 ...future.rng), started = ...future.startTime, 
[11:01:52.953]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.953]             version = "1.8"), class = "FutureResult")
[11:01:52.953]     }, finally = {
[11:01:52.953]         if (!identical(...future.workdir, getwd())) 
[11:01:52.953]             setwd(...future.workdir)
[11:01:52.953]         {
[11:01:52.953]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.953]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.953]             }
[11:01:52.953]             base::options(...future.oldOptions)
[11:01:52.953]             if (.Platform$OS.type == "windows") {
[11:01:52.953]                 old_names <- names(...future.oldEnvVars)
[11:01:52.953]                 envs <- base::Sys.getenv()
[11:01:52.953]                 names <- names(envs)
[11:01:52.953]                 common <- intersect(names, old_names)
[11:01:52.953]                 added <- setdiff(names, old_names)
[11:01:52.953]                 removed <- setdiff(old_names, names)
[11:01:52.953]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.953]                   envs[common]]
[11:01:52.953]                 NAMES <- toupper(changed)
[11:01:52.953]                 args <- list()
[11:01:52.953]                 for (kk in seq_along(NAMES)) {
[11:01:52.953]                   name <- changed[[kk]]
[11:01:52.953]                   NAME <- NAMES[[kk]]
[11:01:52.953]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.953]                     next
[11:01:52.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.953]                 }
[11:01:52.953]                 NAMES <- toupper(added)
[11:01:52.953]                 for (kk in seq_along(NAMES)) {
[11:01:52.953]                   name <- added[[kk]]
[11:01:52.953]                   NAME <- NAMES[[kk]]
[11:01:52.953]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.953]                     next
[11:01:52.953]                   args[[name]] <- ""
[11:01:52.953]                 }
[11:01:52.953]                 NAMES <- toupper(removed)
[11:01:52.953]                 for (kk in seq_along(NAMES)) {
[11:01:52.953]                   name <- removed[[kk]]
[11:01:52.953]                   NAME <- NAMES[[kk]]
[11:01:52.953]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.953]                     next
[11:01:52.953]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.953]                 }
[11:01:52.953]                 if (length(args) > 0) 
[11:01:52.953]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.953]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.953]             }
[11:01:52.953]             else {
[11:01:52.953]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.953]             }
[11:01:52.953]             {
[11:01:52.953]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.953]                   0L) {
[11:01:52.953]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.953]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.953]                   base::options(opts)
[11:01:52.953]                 }
[11:01:52.953]                 {
[11:01:52.953]                   {
[11:01:52.953]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.953]                     NULL
[11:01:52.953]                   }
[11:01:52.953]                   options(future.plan = NULL)
[11:01:52.953]                   if (is.na(NA_character_)) 
[11:01:52.953]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.953]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.953]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.953]                     .init = FALSE)
[11:01:52.953]                 }
[11:01:52.953]             }
[11:01:52.953]         }
[11:01:52.953]     })
[11:01:52.953]     if (TRUE) {
[11:01:52.953]         base::sink(type = "output", split = FALSE)
[11:01:52.953]         if (TRUE) {
[11:01:52.953]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.953]         }
[11:01:52.953]         else {
[11:01:52.953]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.953]         }
[11:01:52.953]         base::close(...future.stdout)
[11:01:52.953]         ...future.stdout <- NULL
[11:01:52.953]     }
[11:01:52.953]     ...future.result$conditions <- ...future.conditions
[11:01:52.953]     ...future.result$finished <- base::Sys.time()
[11:01:52.953]     ...future.result
[11:01:52.953] }
[11:01:52.955] assign_globals() ...
[11:01:52.955] List of 2
[11:01:52.955]  $ a : num 1
[11:01:52.955]  $ ii: int 1
[11:01:52.955]  - attr(*, "where")=List of 2
[11:01:52.955]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.955]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.955]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.955]  - attr(*, "resolved")= logi TRUE
[11:01:52.955]  - attr(*, "total_size")= num 74
[11:01:52.955]  - attr(*, "already-done")= logi TRUE
[11:01:52.959] - copied ‘a’ to environment
[11:01:52.959] - copied ‘ii’ to environment
[11:01:52.959] assign_globals() ... done
[11:01:52.959] requestCore(): workers = 2
[11:01:52.961] MulticoreFuture started
[11:01:52.961] - Launch lazy future ... done
[11:01:52.961] run() for ‘MulticoreFuture’ ... done
[11:01:52.962] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.962] getGlobalsAndPackages() ...
[11:01:52.962] List of future strategies:
[11:01:52.962] 1. sequential:
[11:01:52.962]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.962]    - tweaked: FALSE
[11:01:52.962]    - call: NULL
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.963] plan(): nbrOfWorkers() = 1
[11:01:52.963] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.965] plan(): Setting new future strategy stack:
[11:01:52.965] List of future strategies:
[11:01:52.965] 1. multicore:
[11:01:52.965]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.965]    - tweaked: FALSE
[11:01:52.965]    - call: plan(strategy)
[11:01:52.966] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.966] Searching for globals ... DONE
[11:01:52.967] Resolving globals: TRUE
[11:01:52.967] Resolving any globals that are futures ...
[11:01:52.967] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:52.967] Resolving any globals that are futures ... DONE
[11:01:52.967] plan(): nbrOfWorkers() = 2
[11:01:52.968] Resolving futures part of globals (recursively) ...
[11:01:52.968] resolve() on list ...
[11:01:52.968]  recursive: 99
[11:01:52.969]  length: 2
[11:01:52.969]  elements: ‘a’, ‘ii’
[11:01:52.969]  length: 1 (resolved future 1)
[11:01:52.969]  length: 0 (resolved future 2)
[11:01:52.969] resolve() on list ... DONE
[11:01:52.969] - globals: [2] ‘a’, ‘ii’
[11:01:52.969] Resolving futures part of globals (recursively) ... DONE
[11:01:52.970] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:52.970] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:52.970] - globals: [2] ‘a’, ‘ii’
[11:01:52.971] 
[11:01:52.971] getGlobalsAndPackages() ... DONE
[11:01:52.971] run() for ‘Future’ ...
[11:01:52.971] - state: ‘created’
[11:01:52.971] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:52.974] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:52.974] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:52.974]   - Field: ‘label’
[11:01:52.974]   - Field: ‘local’
[11:01:52.975]   - Field: ‘owner’
[11:01:52.975]   - Field: ‘envir’
[11:01:52.975]   - Field: ‘workers’
[11:01:52.975]   - Field: ‘packages’
[11:01:52.975]   - Field: ‘gc’
[11:01:52.975]   - Field: ‘job’
[11:01:52.975]   - Field: ‘conditions’
[11:01:52.976]   - Field: ‘expr’
[11:01:52.976]   - Field: ‘uuid’
[11:01:52.976]   - Field: ‘seed’
[11:01:52.976]   - Field: ‘version’
[11:01:52.976]   - Field: ‘result’
[11:01:52.976]   - Field: ‘asynchronous’
[11:01:52.976]   - Field: ‘calls’
[11:01:52.976]   - Field: ‘globals’
[11:01:52.977]   - Field: ‘stdout’
[11:01:52.977]   - Field: ‘earlySignal’
[11:01:52.977]   - Field: ‘lazy’
[11:01:52.977]   - Field: ‘state’
[11:01:52.977] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:52.980] - Launch lazy future ...
[11:01:52.981] Packages needed by the future expression (n = 0): <none>
[11:01:52.981] Packages needed by future strategies (n = 0): <none>
[11:01:52.982] {
[11:01:52.982]     {
[11:01:52.982]         {
[11:01:52.982]             ...future.startTime <- base::Sys.time()
[11:01:52.982]             {
[11:01:52.982]                 {
[11:01:52.982]                   {
[11:01:52.982]                     {
[11:01:52.982]                       base::local({
[11:01:52.982]                         has_future <- base::requireNamespace("future", 
[11:01:52.982]                           quietly = TRUE)
[11:01:52.982]                         if (has_future) {
[11:01:52.982]                           ns <- base::getNamespace("future")
[11:01:52.982]                           version <- ns[[".package"]][["version"]]
[11:01:52.982]                           if (is.null(version)) 
[11:01:52.982]                             version <- utils::packageVersion("future")
[11:01:52.982]                         }
[11:01:52.982]                         else {
[11:01:52.982]                           version <- NULL
[11:01:52.982]                         }
[11:01:52.982]                         if (!has_future || version < "1.8.0") {
[11:01:52.982]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:52.982]                             "", base::R.version$version.string), 
[11:01:52.982]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:52.982]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:52.982]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:52.982]                               "release", "version")], collapse = " "), 
[11:01:52.982]                             hostname = base::Sys.info()[["nodename"]])
[11:01:52.982]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:52.982]                             info)
[11:01:52.982]                           info <- base::paste(info, collapse = "; ")
[11:01:52.982]                           if (!has_future) {
[11:01:52.982]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:52.982]                               info)
[11:01:52.982]                           }
[11:01:52.982]                           else {
[11:01:52.982]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:52.982]                               info, version)
[11:01:52.982]                           }
[11:01:52.982]                           base::stop(msg)
[11:01:52.982]                         }
[11:01:52.982]                       })
[11:01:52.982]                     }
[11:01:52.982]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:52.982]                     base::options(mc.cores = 1L)
[11:01:52.982]                   }
[11:01:52.982]                   ...future.strategy.old <- future::plan("list")
[11:01:52.982]                   options(future.plan = NULL)
[11:01:52.982]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.982]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:52.982]                 }
[11:01:52.982]                 ...future.workdir <- getwd()
[11:01:52.982]             }
[11:01:52.982]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:52.982]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:52.982]         }
[11:01:52.982]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:52.982]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:52.982]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:52.982]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:52.982]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:52.982]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:52.982]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:52.982]             base::names(...future.oldOptions))
[11:01:52.982]     }
[11:01:52.982]     if (FALSE) {
[11:01:52.982]     }
[11:01:52.982]     else {
[11:01:52.982]         if (TRUE) {
[11:01:52.982]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:52.982]                 open = "w")
[11:01:52.982]         }
[11:01:52.982]         else {
[11:01:52.982]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:52.982]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:52.982]         }
[11:01:52.982]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:52.982]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:52.982]             base::sink(type = "output", split = FALSE)
[11:01:52.982]             base::close(...future.stdout)
[11:01:52.982]         }, add = TRUE)
[11:01:52.982]     }
[11:01:52.982]     ...future.frame <- base::sys.nframe()
[11:01:52.982]     ...future.conditions <- base::list()
[11:01:52.982]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:52.982]     if (FALSE) {
[11:01:52.982]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:52.982]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:52.982]     }
[11:01:52.982]     ...future.result <- base::tryCatch({
[11:01:52.982]         base::withCallingHandlers({
[11:01:52.982]             ...future.value <- base::withVisible(base::local({
[11:01:52.982]                 withCallingHandlers({
[11:01:52.982]                   {
[11:01:52.982]                     b <- a * ii
[11:01:52.982]                     a <- 0
[11:01:52.982]                     b
[11:01:52.982]                   }
[11:01:52.982]                 }, immediateCondition = function(cond) {
[11:01:52.982]                   save_rds <- function (object, pathname, ...) 
[11:01:52.982]                   {
[11:01:52.982]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:52.982]                     if (file_test("-f", pathname_tmp)) {
[11:01:52.982]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.982]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:52.982]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.982]                         fi_tmp[["mtime"]])
[11:01:52.982]                     }
[11:01:52.982]                     tryCatch({
[11:01:52.982]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:52.982]                     }, error = function(ex) {
[11:01:52.982]                       msg <- conditionMessage(ex)
[11:01:52.982]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.982]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:52.982]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.982]                         fi_tmp[["mtime"]], msg)
[11:01:52.982]                       ex$message <- msg
[11:01:52.982]                       stop(ex)
[11:01:52.982]                     })
[11:01:52.982]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:52.982]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:52.982]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:52.982]                       fi_tmp <- file.info(pathname_tmp)
[11:01:52.982]                       fi <- file.info(pathname)
[11:01:52.982]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:52.982]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:52.982]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:52.982]                         fi[["size"]], fi[["mtime"]])
[11:01:52.982]                       stop(msg)
[11:01:52.982]                     }
[11:01:52.982]                     invisible(pathname)
[11:01:52.982]                   }
[11:01:52.982]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:52.982]                     rootPath = tempdir()) 
[11:01:52.982]                   {
[11:01:52.982]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:52.982]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:52.982]                       tmpdir = path, fileext = ".rds")
[11:01:52.982]                     save_rds(obj, file)
[11:01:52.982]                   }
[11:01:52.982]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:52.982]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.982]                   {
[11:01:52.982]                     inherits <- base::inherits
[11:01:52.982]                     invokeRestart <- base::invokeRestart
[11:01:52.982]                     is.null <- base::is.null
[11:01:52.982]                     muffled <- FALSE
[11:01:52.982]                     if (inherits(cond, "message")) {
[11:01:52.982]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:52.982]                       if (muffled) 
[11:01:52.982]                         invokeRestart("muffleMessage")
[11:01:52.982]                     }
[11:01:52.982]                     else if (inherits(cond, "warning")) {
[11:01:52.982]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:52.982]                       if (muffled) 
[11:01:52.982]                         invokeRestart("muffleWarning")
[11:01:52.982]                     }
[11:01:52.982]                     else if (inherits(cond, "condition")) {
[11:01:52.982]                       if (!is.null(pattern)) {
[11:01:52.982]                         computeRestarts <- base::computeRestarts
[11:01:52.982]                         grepl <- base::grepl
[11:01:52.982]                         restarts <- computeRestarts(cond)
[11:01:52.982]                         for (restart in restarts) {
[11:01:52.982]                           name <- restart$name
[11:01:52.982]                           if (is.null(name)) 
[11:01:52.982]                             next
[11:01:52.982]                           if (!grepl(pattern, name)) 
[11:01:52.982]                             next
[11:01:52.982]                           invokeRestart(restart)
[11:01:52.982]                           muffled <- TRUE
[11:01:52.982]                           break
[11:01:52.982]                         }
[11:01:52.982]                       }
[11:01:52.982]                     }
[11:01:52.982]                     invisible(muffled)
[11:01:52.982]                   }
[11:01:52.982]                   muffleCondition(cond)
[11:01:52.982]                 })
[11:01:52.982]             }))
[11:01:52.982]             future::FutureResult(value = ...future.value$value, 
[11:01:52.982]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.982]                   ...future.rng), globalenv = if (FALSE) 
[11:01:52.982]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:52.982]                     ...future.globalenv.names))
[11:01:52.982]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:52.982]         }, condition = base::local({
[11:01:52.982]             c <- base::c
[11:01:52.982]             inherits <- base::inherits
[11:01:52.982]             invokeRestart <- base::invokeRestart
[11:01:52.982]             length <- base::length
[11:01:52.982]             list <- base::list
[11:01:52.982]             seq.int <- base::seq.int
[11:01:52.982]             signalCondition <- base::signalCondition
[11:01:52.982]             sys.calls <- base::sys.calls
[11:01:52.982]             `[[` <- base::`[[`
[11:01:52.982]             `+` <- base::`+`
[11:01:52.982]             `<<-` <- base::`<<-`
[11:01:52.982]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:52.982]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:52.982]                   3L)]
[11:01:52.982]             }
[11:01:52.982]             function(cond) {
[11:01:52.982]                 is_error <- inherits(cond, "error")
[11:01:52.982]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:52.982]                   NULL)
[11:01:52.982]                 if (is_error) {
[11:01:52.982]                   sessionInformation <- function() {
[11:01:52.982]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:52.982]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:52.982]                       search = base::search(), system = base::Sys.info())
[11:01:52.982]                   }
[11:01:52.982]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.982]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:52.982]                     cond$call), session = sessionInformation(), 
[11:01:52.982]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:52.982]                   signalCondition(cond)
[11:01:52.982]                 }
[11:01:52.982]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:52.982]                 "immediateCondition"))) {
[11:01:52.982]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:52.982]                   ...future.conditions[[length(...future.conditions) + 
[11:01:52.982]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:52.982]                   if (TRUE && !signal) {
[11:01:52.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.982]                     {
[11:01:52.982]                       inherits <- base::inherits
[11:01:52.982]                       invokeRestart <- base::invokeRestart
[11:01:52.982]                       is.null <- base::is.null
[11:01:52.982]                       muffled <- FALSE
[11:01:52.982]                       if (inherits(cond, "message")) {
[11:01:52.982]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.982]                         if (muffled) 
[11:01:52.982]                           invokeRestart("muffleMessage")
[11:01:52.982]                       }
[11:01:52.982]                       else if (inherits(cond, "warning")) {
[11:01:52.982]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.982]                         if (muffled) 
[11:01:52.982]                           invokeRestart("muffleWarning")
[11:01:52.982]                       }
[11:01:52.982]                       else if (inherits(cond, "condition")) {
[11:01:52.982]                         if (!is.null(pattern)) {
[11:01:52.982]                           computeRestarts <- base::computeRestarts
[11:01:52.982]                           grepl <- base::grepl
[11:01:52.982]                           restarts <- computeRestarts(cond)
[11:01:52.982]                           for (restart in restarts) {
[11:01:52.982]                             name <- restart$name
[11:01:52.982]                             if (is.null(name)) 
[11:01:52.982]                               next
[11:01:52.982]                             if (!grepl(pattern, name)) 
[11:01:52.982]                               next
[11:01:52.982]                             invokeRestart(restart)
[11:01:52.982]                             muffled <- TRUE
[11:01:52.982]                             break
[11:01:52.982]                           }
[11:01:52.982]                         }
[11:01:52.982]                       }
[11:01:52.982]                       invisible(muffled)
[11:01:52.982]                     }
[11:01:52.982]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.982]                   }
[11:01:52.982]                 }
[11:01:52.982]                 else {
[11:01:52.982]                   if (TRUE) {
[11:01:52.982]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:52.982]                     {
[11:01:52.982]                       inherits <- base::inherits
[11:01:52.982]                       invokeRestart <- base::invokeRestart
[11:01:52.982]                       is.null <- base::is.null
[11:01:52.982]                       muffled <- FALSE
[11:01:52.982]                       if (inherits(cond, "message")) {
[11:01:52.982]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:52.982]                         if (muffled) 
[11:01:52.982]                           invokeRestart("muffleMessage")
[11:01:52.982]                       }
[11:01:52.982]                       else if (inherits(cond, "warning")) {
[11:01:52.982]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:52.982]                         if (muffled) 
[11:01:52.982]                           invokeRestart("muffleWarning")
[11:01:52.982]                       }
[11:01:52.982]                       else if (inherits(cond, "condition")) {
[11:01:52.982]                         if (!is.null(pattern)) {
[11:01:52.982]                           computeRestarts <- base::computeRestarts
[11:01:52.982]                           grepl <- base::grepl
[11:01:52.982]                           restarts <- computeRestarts(cond)
[11:01:52.982]                           for (restart in restarts) {
[11:01:52.982]                             name <- restart$name
[11:01:52.982]                             if (is.null(name)) 
[11:01:52.982]                               next
[11:01:52.982]                             if (!grepl(pattern, name)) 
[11:01:52.982]                               next
[11:01:52.982]                             invokeRestart(restart)
[11:01:52.982]                             muffled <- TRUE
[11:01:52.982]                             break
[11:01:52.982]                           }
[11:01:52.982]                         }
[11:01:52.982]                       }
[11:01:52.982]                       invisible(muffled)
[11:01:52.982]                     }
[11:01:52.982]                     muffleCondition(cond, pattern = "^muffle")
[11:01:52.982]                   }
[11:01:52.982]                 }
[11:01:52.982]             }
[11:01:52.982]         }))
[11:01:52.982]     }, error = function(ex) {
[11:01:52.982]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:52.982]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:52.982]                 ...future.rng), started = ...future.startTime, 
[11:01:52.982]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:52.982]             version = "1.8"), class = "FutureResult")
[11:01:52.982]     }, finally = {
[11:01:52.982]         if (!identical(...future.workdir, getwd())) 
[11:01:52.982]             setwd(...future.workdir)
[11:01:52.982]         {
[11:01:52.982]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:52.982]                 ...future.oldOptions$nwarnings <- NULL
[11:01:52.982]             }
[11:01:52.982]             base::options(...future.oldOptions)
[11:01:52.982]             if (.Platform$OS.type == "windows") {
[11:01:52.982]                 old_names <- names(...future.oldEnvVars)
[11:01:52.982]                 envs <- base::Sys.getenv()
[11:01:52.982]                 names <- names(envs)
[11:01:52.982]                 common <- intersect(names, old_names)
[11:01:52.982]                 added <- setdiff(names, old_names)
[11:01:52.982]                 removed <- setdiff(old_names, names)
[11:01:52.982]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:52.982]                   envs[common]]
[11:01:52.982]                 NAMES <- toupper(changed)
[11:01:52.982]                 args <- list()
[11:01:52.982]                 for (kk in seq_along(NAMES)) {
[11:01:52.982]                   name <- changed[[kk]]
[11:01:52.982]                   NAME <- NAMES[[kk]]
[11:01:52.982]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.982]                     next
[11:01:52.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.982]                 }
[11:01:52.982]                 NAMES <- toupper(added)
[11:01:52.982]                 for (kk in seq_along(NAMES)) {
[11:01:52.982]                   name <- added[[kk]]
[11:01:52.982]                   NAME <- NAMES[[kk]]
[11:01:52.982]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.982]                     next
[11:01:52.982]                   args[[name]] <- ""
[11:01:52.982]                 }
[11:01:52.982]                 NAMES <- toupper(removed)
[11:01:52.982]                 for (kk in seq_along(NAMES)) {
[11:01:52.982]                   name <- removed[[kk]]
[11:01:52.982]                   NAME <- NAMES[[kk]]
[11:01:52.982]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:52.982]                     next
[11:01:52.982]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:52.982]                 }
[11:01:52.982]                 if (length(args) > 0) 
[11:01:52.982]                   base::do.call(base::Sys.setenv, args = args)
[11:01:52.982]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:52.982]             }
[11:01:52.982]             else {
[11:01:52.982]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:52.982]             }
[11:01:52.982]             {
[11:01:52.982]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:52.982]                   0L) {
[11:01:52.982]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:52.982]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:52.982]                   base::options(opts)
[11:01:52.982]                 }
[11:01:52.982]                 {
[11:01:52.982]                   {
[11:01:52.982]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:52.982]                     NULL
[11:01:52.982]                   }
[11:01:52.982]                   options(future.plan = NULL)
[11:01:52.982]                   if (is.na(NA_character_)) 
[11:01:52.982]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:52.982]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:52.982]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:52.982]                     .init = FALSE)
[11:01:52.982]                 }
[11:01:52.982]             }
[11:01:52.982]         }
[11:01:52.982]     })
[11:01:52.982]     if (TRUE) {
[11:01:52.982]         base::sink(type = "output", split = FALSE)
[11:01:52.982]         if (TRUE) {
[11:01:52.982]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:52.982]         }
[11:01:52.982]         else {
[11:01:52.982]             ...future.result["stdout"] <- base::list(NULL)
[11:01:52.982]         }
[11:01:52.982]         base::close(...future.stdout)
[11:01:52.982]         ...future.stdout <- NULL
[11:01:52.982]     }
[11:01:52.982]     ...future.result$conditions <- ...future.conditions
[11:01:52.982]     ...future.result$finished <- base::Sys.time()
[11:01:52.982]     ...future.result
[11:01:52.982] }
[11:01:52.985] assign_globals() ...
[11:01:52.985] List of 2
[11:01:52.985]  $ a : num 1
[11:01:52.985]  $ ii: int 2
[11:01:52.985]  - attr(*, "where")=List of 2
[11:01:52.985]   ..$ a :<environment: R_EmptyEnv> 
[11:01:52.985]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:52.985]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:52.985]  - attr(*, "resolved")= logi TRUE
[11:01:52.985]  - attr(*, "total_size")= num 74
[11:01:52.985]  - attr(*, "already-done")= logi TRUE
[11:01:52.990] - copied ‘a’ to environment
[11:01:52.990] - copied ‘ii’ to environment
[11:01:52.991] assign_globals() ... done
[11:01:52.991] requestCore(): workers = 2
[11:01:52.993] MulticoreFuture started
[11:01:52.993] - Launch lazy future ... done
[11:01:52.994] run() for ‘MulticoreFuture’ ... done
[11:01:52.994] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:52.995] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:52.995] List of future strategies:
[11:01:52.995] 1. sequential:
[11:01:52.995]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:52.995]    - tweaked: FALSE
[11:01:52.995]    - call: NULL
[11:01:52.996] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:52.996] plan(): nbrOfWorkers() = 1
[11:01:52.998] plan(): Setting new future strategy stack:
[11:01:52.998] List of future strategies:
[11:01:52.998] 1. multicore:
[11:01:52.998]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:52.998]    - tweaked: FALSE
[11:01:52.998]    - call: plan(strategy)
[11:01:53.000] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.000] Searching for globals ... DONE
[11:01:53.000] Resolving globals: TRUE
[11:01:53.000] Resolving any globals that are futures ...
[11:01:53.000] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.001] Resolving any globals that are futures ... DONE
[11:01:53.001] plan(): nbrOfWorkers() = 2
[11:01:53.001] Resolving futures part of globals (recursively) ...
[11:01:53.002] resolve() on list ...
[11:01:53.002]  recursive: 99
[11:01:53.002]  length: 2
[11:01:53.002]  elements: ‘a’, ‘ii’
[11:01:53.002]  length: 1 (resolved future 1)
[11:01:53.002]  length: 0 (resolved future 2)
[11:01:53.003] resolve() on list ... DONE
[11:01:53.003] - globals: [2] ‘a’, ‘ii’
[11:01:53.003] Resolving futures part of globals (recursively) ... DONE
[11:01:53.003] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:53.004] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:53.004] - globals: [2] ‘a’, ‘ii’
[11:01:53.004] 
[11:01:53.004] getGlobalsAndPackages() ... DONE
[11:01:53.005] run() for ‘Future’ ...
[11:01:53.005] - state: ‘created’
[11:01:53.005] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.007] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.008] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.008]   - Field: ‘label’
[11:01:53.008]   - Field: ‘local’
[11:01:53.008]   - Field: ‘owner’
[11:01:53.008]   - Field: ‘envir’
[11:01:53.008]   - Field: ‘workers’
[11:01:53.008]   - Field: ‘packages’
[11:01:53.009]   - Field: ‘gc’
[11:01:53.009]   - Field: ‘job’
[11:01:53.009]   - Field: ‘conditions’
[11:01:53.009]   - Field: ‘expr’
[11:01:53.009]   - Field: ‘uuid’
[11:01:53.009]   - Field: ‘seed’
[11:01:53.009]   - Field: ‘version’
[11:01:53.010]   - Field: ‘result’
[11:01:53.010]   - Field: ‘asynchronous’
[11:01:53.010]   - Field: ‘calls’
[11:01:53.010]   - Field: ‘globals’
[11:01:53.010]   - Field: ‘stdout’
[11:01:53.010]   - Field: ‘earlySignal’
[11:01:53.010]   - Field: ‘lazy’
[11:01:53.010]   - Field: ‘state’
[11:01:53.011] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.011] - Launch lazy future ...
[11:01:53.011] Packages needed by the future expression (n = 0): <none>
[11:01:53.011] Packages needed by future strategies (n = 0): <none>
[11:01:53.012] {
[11:01:53.012]     {
[11:01:53.012]         {
[11:01:53.012]             ...future.startTime <- base::Sys.time()
[11:01:53.012]             {
[11:01:53.012]                 {
[11:01:53.012]                   {
[11:01:53.012]                     {
[11:01:53.012]                       base::local({
[11:01:53.012]                         has_future <- base::requireNamespace("future", 
[11:01:53.012]                           quietly = TRUE)
[11:01:53.012]                         if (has_future) {
[11:01:53.012]                           ns <- base::getNamespace("future")
[11:01:53.012]                           version <- ns[[".package"]][["version"]]
[11:01:53.012]                           if (is.null(version)) 
[11:01:53.012]                             version <- utils::packageVersion("future")
[11:01:53.012]                         }
[11:01:53.012]                         else {
[11:01:53.012]                           version <- NULL
[11:01:53.012]                         }
[11:01:53.012]                         if (!has_future || version < "1.8.0") {
[11:01:53.012]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.012]                             "", base::R.version$version.string), 
[11:01:53.012]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.012]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.012]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.012]                               "release", "version")], collapse = " "), 
[11:01:53.012]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.012]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.012]                             info)
[11:01:53.012]                           info <- base::paste(info, collapse = "; ")
[11:01:53.012]                           if (!has_future) {
[11:01:53.012]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.012]                               info)
[11:01:53.012]                           }
[11:01:53.012]                           else {
[11:01:53.012]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.012]                               info, version)
[11:01:53.012]                           }
[11:01:53.012]                           base::stop(msg)
[11:01:53.012]                         }
[11:01:53.012]                       })
[11:01:53.012]                     }
[11:01:53.012]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.012]                     base::options(mc.cores = 1L)
[11:01:53.012]                   }
[11:01:53.012]                   ...future.strategy.old <- future::plan("list")
[11:01:53.012]                   options(future.plan = NULL)
[11:01:53.012]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.012]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.012]                 }
[11:01:53.012]                 ...future.workdir <- getwd()
[11:01:53.012]             }
[11:01:53.012]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.012]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.012]         }
[11:01:53.012]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.012]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.012]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.012]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.012]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.012]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.012]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.012]             base::names(...future.oldOptions))
[11:01:53.012]     }
[11:01:53.012]     if (FALSE) {
[11:01:53.012]     }
[11:01:53.012]     else {
[11:01:53.012]         if (TRUE) {
[11:01:53.012]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.012]                 open = "w")
[11:01:53.012]         }
[11:01:53.012]         else {
[11:01:53.012]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.012]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.012]         }
[11:01:53.012]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.012]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.012]             base::sink(type = "output", split = FALSE)
[11:01:53.012]             base::close(...future.stdout)
[11:01:53.012]         }, add = TRUE)
[11:01:53.012]     }
[11:01:53.012]     ...future.frame <- base::sys.nframe()
[11:01:53.012]     ...future.conditions <- base::list()
[11:01:53.012]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.012]     if (FALSE) {
[11:01:53.012]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.012]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.012]     }
[11:01:53.012]     ...future.result <- base::tryCatch({
[11:01:53.012]         base::withCallingHandlers({
[11:01:53.012]             ...future.value <- base::withVisible(base::local({
[11:01:53.012]                 withCallingHandlers({
[11:01:53.012]                   {
[11:01:53.012]                     b <- a * ii
[11:01:53.012]                     a <- 0
[11:01:53.012]                     b
[11:01:53.012]                   }
[11:01:53.012]                 }, immediateCondition = function(cond) {
[11:01:53.012]                   save_rds <- function (object, pathname, ...) 
[11:01:53.012]                   {
[11:01:53.012]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.012]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.012]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.012]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.012]                         fi_tmp[["mtime"]])
[11:01:53.012]                     }
[11:01:53.012]                     tryCatch({
[11:01:53.012]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.012]                     }, error = function(ex) {
[11:01:53.012]                       msg <- conditionMessage(ex)
[11:01:53.012]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.012]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.012]                         fi_tmp[["mtime"]], msg)
[11:01:53.012]                       ex$message <- msg
[11:01:53.012]                       stop(ex)
[11:01:53.012]                     })
[11:01:53.012]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.012]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.012]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.012]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.012]                       fi <- file.info(pathname)
[11:01:53.012]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.012]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.012]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.012]                         fi[["size"]], fi[["mtime"]])
[11:01:53.012]                       stop(msg)
[11:01:53.012]                     }
[11:01:53.012]                     invisible(pathname)
[11:01:53.012]                   }
[11:01:53.012]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.012]                     rootPath = tempdir()) 
[11:01:53.012]                   {
[11:01:53.012]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.012]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.012]                       tmpdir = path, fileext = ".rds")
[11:01:53.012]                     save_rds(obj, file)
[11:01:53.012]                   }
[11:01:53.012]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.012]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.012]                   {
[11:01:53.012]                     inherits <- base::inherits
[11:01:53.012]                     invokeRestart <- base::invokeRestart
[11:01:53.012]                     is.null <- base::is.null
[11:01:53.012]                     muffled <- FALSE
[11:01:53.012]                     if (inherits(cond, "message")) {
[11:01:53.012]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.012]                       if (muffled) 
[11:01:53.012]                         invokeRestart("muffleMessage")
[11:01:53.012]                     }
[11:01:53.012]                     else if (inherits(cond, "warning")) {
[11:01:53.012]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.012]                       if (muffled) 
[11:01:53.012]                         invokeRestart("muffleWarning")
[11:01:53.012]                     }
[11:01:53.012]                     else if (inherits(cond, "condition")) {
[11:01:53.012]                       if (!is.null(pattern)) {
[11:01:53.012]                         computeRestarts <- base::computeRestarts
[11:01:53.012]                         grepl <- base::grepl
[11:01:53.012]                         restarts <- computeRestarts(cond)
[11:01:53.012]                         for (restart in restarts) {
[11:01:53.012]                           name <- restart$name
[11:01:53.012]                           if (is.null(name)) 
[11:01:53.012]                             next
[11:01:53.012]                           if (!grepl(pattern, name)) 
[11:01:53.012]                             next
[11:01:53.012]                           invokeRestart(restart)
[11:01:53.012]                           muffled <- TRUE
[11:01:53.012]                           break
[11:01:53.012]                         }
[11:01:53.012]                       }
[11:01:53.012]                     }
[11:01:53.012]                     invisible(muffled)
[11:01:53.012]                   }
[11:01:53.012]                   muffleCondition(cond)
[11:01:53.012]                 })
[11:01:53.012]             }))
[11:01:53.012]             future::FutureResult(value = ...future.value$value, 
[11:01:53.012]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.012]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.012]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.012]                     ...future.globalenv.names))
[11:01:53.012]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.012]         }, condition = base::local({
[11:01:53.012]             c <- base::c
[11:01:53.012]             inherits <- base::inherits
[11:01:53.012]             invokeRestart <- base::invokeRestart
[11:01:53.012]             length <- base::length
[11:01:53.012]             list <- base::list
[11:01:53.012]             seq.int <- base::seq.int
[11:01:53.012]             signalCondition <- base::signalCondition
[11:01:53.012]             sys.calls <- base::sys.calls
[11:01:53.012]             `[[` <- base::`[[`
[11:01:53.012]             `+` <- base::`+`
[11:01:53.012]             `<<-` <- base::`<<-`
[11:01:53.012]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.012]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.012]                   3L)]
[11:01:53.012]             }
[11:01:53.012]             function(cond) {
[11:01:53.012]                 is_error <- inherits(cond, "error")
[11:01:53.012]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.012]                   NULL)
[11:01:53.012]                 if (is_error) {
[11:01:53.012]                   sessionInformation <- function() {
[11:01:53.012]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.012]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.012]                       search = base::search(), system = base::Sys.info())
[11:01:53.012]                   }
[11:01:53.012]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.012]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.012]                     cond$call), session = sessionInformation(), 
[11:01:53.012]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.012]                   signalCondition(cond)
[11:01:53.012]                 }
[11:01:53.012]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.012]                 "immediateCondition"))) {
[11:01:53.012]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.012]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.012]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.012]                   if (TRUE && !signal) {
[11:01:53.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.012]                     {
[11:01:53.012]                       inherits <- base::inherits
[11:01:53.012]                       invokeRestart <- base::invokeRestart
[11:01:53.012]                       is.null <- base::is.null
[11:01:53.012]                       muffled <- FALSE
[11:01:53.012]                       if (inherits(cond, "message")) {
[11:01:53.012]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.012]                         if (muffled) 
[11:01:53.012]                           invokeRestart("muffleMessage")
[11:01:53.012]                       }
[11:01:53.012]                       else if (inherits(cond, "warning")) {
[11:01:53.012]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.012]                         if (muffled) 
[11:01:53.012]                           invokeRestart("muffleWarning")
[11:01:53.012]                       }
[11:01:53.012]                       else if (inherits(cond, "condition")) {
[11:01:53.012]                         if (!is.null(pattern)) {
[11:01:53.012]                           computeRestarts <- base::computeRestarts
[11:01:53.012]                           grepl <- base::grepl
[11:01:53.012]                           restarts <- computeRestarts(cond)
[11:01:53.012]                           for (restart in restarts) {
[11:01:53.012]                             name <- restart$name
[11:01:53.012]                             if (is.null(name)) 
[11:01:53.012]                               next
[11:01:53.012]                             if (!grepl(pattern, name)) 
[11:01:53.012]                               next
[11:01:53.012]                             invokeRestart(restart)
[11:01:53.012]                             muffled <- TRUE
[11:01:53.012]                             break
[11:01:53.012]                           }
[11:01:53.012]                         }
[11:01:53.012]                       }
[11:01:53.012]                       invisible(muffled)
[11:01:53.012]                     }
[11:01:53.012]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.012]                   }
[11:01:53.012]                 }
[11:01:53.012]                 else {
[11:01:53.012]                   if (TRUE) {
[11:01:53.012]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.012]                     {
[11:01:53.012]                       inherits <- base::inherits
[11:01:53.012]                       invokeRestart <- base::invokeRestart
[11:01:53.012]                       is.null <- base::is.null
[11:01:53.012]                       muffled <- FALSE
[11:01:53.012]                       if (inherits(cond, "message")) {
[11:01:53.012]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.012]                         if (muffled) 
[11:01:53.012]                           invokeRestart("muffleMessage")
[11:01:53.012]                       }
[11:01:53.012]                       else if (inherits(cond, "warning")) {
[11:01:53.012]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.012]                         if (muffled) 
[11:01:53.012]                           invokeRestart("muffleWarning")
[11:01:53.012]                       }
[11:01:53.012]                       else if (inherits(cond, "condition")) {
[11:01:53.012]                         if (!is.null(pattern)) {
[11:01:53.012]                           computeRestarts <- base::computeRestarts
[11:01:53.012]                           grepl <- base::grepl
[11:01:53.012]                           restarts <- computeRestarts(cond)
[11:01:53.012]                           for (restart in restarts) {
[11:01:53.012]                             name <- restart$name
[11:01:53.012]                             if (is.null(name)) 
[11:01:53.012]                               next
[11:01:53.012]                             if (!grepl(pattern, name)) 
[11:01:53.012]                               next
[11:01:53.012]                             invokeRestart(restart)
[11:01:53.012]                             muffled <- TRUE
[11:01:53.012]                             break
[11:01:53.012]                           }
[11:01:53.012]                         }
[11:01:53.012]                       }
[11:01:53.012]                       invisible(muffled)
[11:01:53.012]                     }
[11:01:53.012]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.012]                   }
[11:01:53.012]                 }
[11:01:53.012]             }
[11:01:53.012]         }))
[11:01:53.012]     }, error = function(ex) {
[11:01:53.012]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.012]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.012]                 ...future.rng), started = ...future.startTime, 
[11:01:53.012]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.012]             version = "1.8"), class = "FutureResult")
[11:01:53.012]     }, finally = {
[11:01:53.012]         if (!identical(...future.workdir, getwd())) 
[11:01:53.012]             setwd(...future.workdir)
[11:01:53.012]         {
[11:01:53.012]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.012]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.012]             }
[11:01:53.012]             base::options(...future.oldOptions)
[11:01:53.012]             if (.Platform$OS.type == "windows") {
[11:01:53.012]                 old_names <- names(...future.oldEnvVars)
[11:01:53.012]                 envs <- base::Sys.getenv()
[11:01:53.012]                 names <- names(envs)
[11:01:53.012]                 common <- intersect(names, old_names)
[11:01:53.012]                 added <- setdiff(names, old_names)
[11:01:53.012]                 removed <- setdiff(old_names, names)
[11:01:53.012]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.012]                   envs[common]]
[11:01:53.012]                 NAMES <- toupper(changed)
[11:01:53.012]                 args <- list()
[11:01:53.012]                 for (kk in seq_along(NAMES)) {
[11:01:53.012]                   name <- changed[[kk]]
[11:01:53.012]                   NAME <- NAMES[[kk]]
[11:01:53.012]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.012]                     next
[11:01:53.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.012]                 }
[11:01:53.012]                 NAMES <- toupper(added)
[11:01:53.012]                 for (kk in seq_along(NAMES)) {
[11:01:53.012]                   name <- added[[kk]]
[11:01:53.012]                   NAME <- NAMES[[kk]]
[11:01:53.012]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.012]                     next
[11:01:53.012]                   args[[name]] <- ""
[11:01:53.012]                 }
[11:01:53.012]                 NAMES <- toupper(removed)
[11:01:53.012]                 for (kk in seq_along(NAMES)) {
[11:01:53.012]                   name <- removed[[kk]]
[11:01:53.012]                   NAME <- NAMES[[kk]]
[11:01:53.012]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.012]                     next
[11:01:53.012]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.012]                 }
[11:01:53.012]                 if (length(args) > 0) 
[11:01:53.012]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.012]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.012]             }
[11:01:53.012]             else {
[11:01:53.012]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.012]             }
[11:01:53.012]             {
[11:01:53.012]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.012]                   0L) {
[11:01:53.012]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.012]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.012]                   base::options(opts)
[11:01:53.012]                 }
[11:01:53.012]                 {
[11:01:53.012]                   {
[11:01:53.012]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.012]                     NULL
[11:01:53.012]                   }
[11:01:53.012]                   options(future.plan = NULL)
[11:01:53.012]                   if (is.na(NA_character_)) 
[11:01:53.012]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.012]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.012]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.012]                     .init = FALSE)
[11:01:53.012]                 }
[11:01:53.012]             }
[11:01:53.012]         }
[11:01:53.012]     })
[11:01:53.012]     if (TRUE) {
[11:01:53.012]         base::sink(type = "output", split = FALSE)
[11:01:53.012]         if (TRUE) {
[11:01:53.012]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.012]         }
[11:01:53.012]         else {
[11:01:53.012]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.012]         }
[11:01:53.012]         base::close(...future.stdout)
[11:01:53.012]         ...future.stdout <- NULL
[11:01:53.012]     }
[11:01:53.012]     ...future.result$conditions <- ...future.conditions
[11:01:53.012]     ...future.result$finished <- base::Sys.time()
[11:01:53.012]     ...future.result
[11:01:53.012] }
[11:01:53.015] assign_globals() ...
[11:01:53.015] List of 2
[11:01:53.015]  $ a : num 1
[11:01:53.015]  $ ii: int 3
[11:01:53.015]  - attr(*, "where")=List of 2
[11:01:53.015]   ..$ a :<environment: R_EmptyEnv> 
[11:01:53.015]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:53.015]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.015]  - attr(*, "resolved")= logi TRUE
[11:01:53.015]  - attr(*, "total_size")= num 74
[11:01:53.015]  - attr(*, "already-done")= logi TRUE
[11:01:53.020] - copied ‘a’ to environment
[11:01:53.020] - copied ‘ii’ to environment
[11:01:53.020] assign_globals() ... done
[11:01:53.023] requestCore(): workers = 2
[11:01:53.023] Poll #1 (0): usedCores() = 2, workers = 2
[11:01:53.045] result() for MulticoreFuture ...
[11:01:53.046] result() for MulticoreFuture ...
[11:01:53.046] result() for MulticoreFuture ... done
[11:01:53.046] result() for MulticoreFuture ... done
[11:01:53.046] result() for MulticoreFuture ...
[11:01:53.046] result() for MulticoreFuture ... done
[11:01:53.048] MulticoreFuture started
[11:01:53.049] - Launch lazy future ... done
[11:01:53.049] run() for ‘MulticoreFuture’ ... done
[11:01:53.050] result() for MulticoreFuture ...
[11:01:53.050] plan(): Setting new future strategy stack:
[11:01:53.050] result() for MulticoreFuture ... done
[11:01:53.050] result() for MulticoreFuture ...
[11:01:53.050] result() for MulticoreFuture ... done
[11:01:53.051] result() for MulticoreFuture ...
[11:01:53.050] List of future strategies:
[11:01:53.050] 1. sequential:
[11:01:53.050]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.050]    - tweaked: FALSE
[11:01:53.050]    - call: NULL
[11:01:53.051] plan(): nbrOfWorkers() = 1
[11:01:53.052] result() for MulticoreFuture ...
[11:01:53.053] result() for MulticoreFuture ... done
[11:01:53.053] result() for MulticoreFuture ... done
[11:01:53.053] result() for MulticoreFuture ...
[11:01:53.053] result() for MulticoreFuture ... done
[11:01:53.054] result() for MulticoreFuture ...
[11:01:53.054] plan(): Setting new future strategy stack:
[11:01:53.054] List of future strategies:
[11:01:53.054] 1. multicore:
[11:01:53.054]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.054]    - tweaked: FALSE
[11:01:53.054]    - call: plan(strategy)
[11:01:53.058] plan(): nbrOfWorkers() = 2
[11:01:53.058] result() for MulticoreFuture ...
[11:01:53.058] result() for MulticoreFuture ... done
[11:01:53.059] result() for MulticoreFuture ... done
[11:01:53.059] result() for MulticoreFuture ...
[11:01:53.059] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.060] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.061] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.063] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.063] Searching for globals ... DONE
[11:01:53.064] Resolving globals: TRUE
[11:01:53.064] Resolving any globals that are futures ...
[11:01:53.064] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.064] Resolving any globals that are futures ... DONE
[11:01:53.064] Resolving futures part of globals (recursively) ...
[11:01:53.065] resolve() on list ...
[11:01:53.065]  recursive: 99
[11:01:53.065]  length: 2
[11:01:53.065]  elements: ‘a’, ‘ii’
[11:01:53.065]  length: 1 (resolved future 1)
[11:01:53.065]  length: 0 (resolved future 2)
[11:01:53.065] resolve() on list ... DONE
[11:01:53.066] - globals: [2] ‘a’, ‘ii’
[11:01:53.066] Resolving futures part of globals (recursively) ... DONE
[11:01:53.066] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:53.069] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:53.069] - globals: [2] ‘a’, ‘ii’
[11:01:53.070] 
[11:01:53.070] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.071] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.071] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.074] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.074] Searching for globals ... DONE
[11:01:53.074] Resolving globals: TRUE
[11:01:53.074] Resolving any globals that are futures ...
[11:01:53.074] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.074] Resolving any globals that are futures ... DONE
[11:01:53.075] Resolving futures part of globals (recursively) ...
[11:01:53.075] resolve() on list ...
[11:01:53.075]  recursive: 99
[11:01:53.075]  length: 2
[11:01:53.075]  elements: ‘a’, ‘ii’
[11:01:53.075]  length: 1 (resolved future 1)
[11:01:53.075]  length: 0 (resolved future 2)
[11:01:53.076] resolve() on list ... DONE
[11:01:53.076] - globals: [2] ‘a’, ‘ii’
[11:01:53.076] Resolving futures part of globals (recursively) ... DONE
[11:01:53.076] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:53.076] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:53.077] - globals: [2] ‘a’, ‘ii’
[11:01:53.077] 
[11:01:53.077] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.077] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.078] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.080] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.080] Searching for globals ... DONE
[11:01:53.080] Resolving globals: TRUE
[11:01:53.080] Resolving any globals that are futures ...
[11:01:53.080] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:53.080] Resolving any globals that are futures ... DONE
[11:01:53.081] Resolving futures part of globals (recursively) ...
[11:01:53.081] resolve() on list ...
[11:01:53.081]  recursive: 99
[11:01:53.081]  length: 2
[11:01:53.081]  elements: ‘a’, ‘ii’
[11:01:53.081]  length: 1 (resolved future 1)
[11:01:53.081]  length: 0 (resolved future 2)
[11:01:53.081] resolve() on list ... DONE
[11:01:53.082] - globals: [2] ‘a’, ‘ii’
[11:01:53.082] Resolving futures part of globals (recursively) ... DONE
[11:01:53.082] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:53.082] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:53.082] - globals: [2] ‘a’, ‘ii’
[11:01:53.082] 
[11:01:53.083] getGlobalsAndPackages() ... DONE
[11:01:53.083] run() for ‘Future’ ...
[11:01:53.083] - state: ‘created’
[11:01:53.083] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.085] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.085] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.085]   - Field: ‘label’
[11:01:53.085]   - Field: ‘local’
[11:01:53.085]   - Field: ‘owner’
[11:01:53.085]   - Field: ‘envir’
[11:01:53.085]   - Field: ‘workers’
[11:01:53.085]   - Field: ‘packages’
[11:01:53.086]   - Field: ‘gc’
[11:01:53.086]   - Field: ‘job’
[11:01:53.086]   - Field: ‘conditions’
[11:01:53.086]   - Field: ‘expr’
[11:01:53.086]   - Field: ‘uuid’
[11:01:53.086]   - Field: ‘seed’
[11:01:53.086]   - Field: ‘version’
[11:01:53.086]   - Field: ‘result’
[11:01:53.086]   - Field: ‘asynchronous’
[11:01:53.086]   - Field: ‘calls’
[11:01:53.086]   - Field: ‘globals’
[11:01:53.086]   - Field: ‘stdout’
[11:01:53.087]   - Field: ‘earlySignal’
[11:01:53.087]   - Field: ‘lazy’
[11:01:53.087]   - Field: ‘state’
[11:01:53.087] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.087] - Launch lazy future ...
[11:01:53.087] Packages needed by the future expression (n = 0): <none>
[11:01:53.087] Packages needed by future strategies (n = 0): <none>
[11:01:53.088] {
[11:01:53.088]     {
[11:01:53.088]         {
[11:01:53.088]             ...future.startTime <- base::Sys.time()
[11:01:53.088]             {
[11:01:53.088]                 {
[11:01:53.088]                   {
[11:01:53.088]                     {
[11:01:53.088]                       base::local({
[11:01:53.088]                         has_future <- base::requireNamespace("future", 
[11:01:53.088]                           quietly = TRUE)
[11:01:53.088]                         if (has_future) {
[11:01:53.088]                           ns <- base::getNamespace("future")
[11:01:53.088]                           version <- ns[[".package"]][["version"]]
[11:01:53.088]                           if (is.null(version)) 
[11:01:53.088]                             version <- utils::packageVersion("future")
[11:01:53.088]                         }
[11:01:53.088]                         else {
[11:01:53.088]                           version <- NULL
[11:01:53.088]                         }
[11:01:53.088]                         if (!has_future || version < "1.8.0") {
[11:01:53.088]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.088]                             "", base::R.version$version.string), 
[11:01:53.088]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.088]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.088]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.088]                               "release", "version")], collapse = " "), 
[11:01:53.088]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.088]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.088]                             info)
[11:01:53.088]                           info <- base::paste(info, collapse = "; ")
[11:01:53.088]                           if (!has_future) {
[11:01:53.088]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.088]                               info)
[11:01:53.088]                           }
[11:01:53.088]                           else {
[11:01:53.088]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.088]                               info, version)
[11:01:53.088]                           }
[11:01:53.088]                           base::stop(msg)
[11:01:53.088]                         }
[11:01:53.088]                       })
[11:01:53.088]                     }
[11:01:53.088]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.088]                     base::options(mc.cores = 1L)
[11:01:53.088]                   }
[11:01:53.088]                   ...future.strategy.old <- future::plan("list")
[11:01:53.088]                   options(future.plan = NULL)
[11:01:53.088]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.088]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.088]                 }
[11:01:53.088]                 ...future.workdir <- getwd()
[11:01:53.088]             }
[11:01:53.088]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.088]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.088]         }
[11:01:53.088]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.088]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.088]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.088]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.088]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.088]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.088]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.088]             base::names(...future.oldOptions))
[11:01:53.088]     }
[11:01:53.088]     if (FALSE) {
[11:01:53.088]     }
[11:01:53.088]     else {
[11:01:53.088]         if (TRUE) {
[11:01:53.088]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.088]                 open = "w")
[11:01:53.088]         }
[11:01:53.088]         else {
[11:01:53.088]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.088]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.088]         }
[11:01:53.088]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.088]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.088]             base::sink(type = "output", split = FALSE)
[11:01:53.088]             base::close(...future.stdout)
[11:01:53.088]         }, add = TRUE)
[11:01:53.088]     }
[11:01:53.088]     ...future.frame <- base::sys.nframe()
[11:01:53.088]     ...future.conditions <- base::list()
[11:01:53.088]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.088]     if (FALSE) {
[11:01:53.088]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.088]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.088]     }
[11:01:53.088]     ...future.result <- base::tryCatch({
[11:01:53.088]         base::withCallingHandlers({
[11:01:53.088]             ...future.value <- base::withVisible(base::local({
[11:01:53.088]                 withCallingHandlers({
[11:01:53.088]                   {
[11:01:53.088]                     b <- a * ii
[11:01:53.088]                     a <- 0
[11:01:53.088]                     b
[11:01:53.088]                   }
[11:01:53.088]                 }, immediateCondition = function(cond) {
[11:01:53.088]                   save_rds <- function (object, pathname, ...) 
[11:01:53.088]                   {
[11:01:53.088]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.088]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.088]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.088]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.088]                         fi_tmp[["mtime"]])
[11:01:53.088]                     }
[11:01:53.088]                     tryCatch({
[11:01:53.088]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.088]                     }, error = function(ex) {
[11:01:53.088]                       msg <- conditionMessage(ex)
[11:01:53.088]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.088]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.088]                         fi_tmp[["mtime"]], msg)
[11:01:53.088]                       ex$message <- msg
[11:01:53.088]                       stop(ex)
[11:01:53.088]                     })
[11:01:53.088]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.088]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.088]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.088]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.088]                       fi <- file.info(pathname)
[11:01:53.088]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.088]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.088]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.088]                         fi[["size"]], fi[["mtime"]])
[11:01:53.088]                       stop(msg)
[11:01:53.088]                     }
[11:01:53.088]                     invisible(pathname)
[11:01:53.088]                   }
[11:01:53.088]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.088]                     rootPath = tempdir()) 
[11:01:53.088]                   {
[11:01:53.088]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.088]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.088]                       tmpdir = path, fileext = ".rds")
[11:01:53.088]                     save_rds(obj, file)
[11:01:53.088]                   }
[11:01:53.088]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.088]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.088]                   {
[11:01:53.088]                     inherits <- base::inherits
[11:01:53.088]                     invokeRestart <- base::invokeRestart
[11:01:53.088]                     is.null <- base::is.null
[11:01:53.088]                     muffled <- FALSE
[11:01:53.088]                     if (inherits(cond, "message")) {
[11:01:53.088]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.088]                       if (muffled) 
[11:01:53.088]                         invokeRestart("muffleMessage")
[11:01:53.088]                     }
[11:01:53.088]                     else if (inherits(cond, "warning")) {
[11:01:53.088]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.088]                       if (muffled) 
[11:01:53.088]                         invokeRestart("muffleWarning")
[11:01:53.088]                     }
[11:01:53.088]                     else if (inherits(cond, "condition")) {
[11:01:53.088]                       if (!is.null(pattern)) {
[11:01:53.088]                         computeRestarts <- base::computeRestarts
[11:01:53.088]                         grepl <- base::grepl
[11:01:53.088]                         restarts <- computeRestarts(cond)
[11:01:53.088]                         for (restart in restarts) {
[11:01:53.088]                           name <- restart$name
[11:01:53.088]                           if (is.null(name)) 
[11:01:53.088]                             next
[11:01:53.088]                           if (!grepl(pattern, name)) 
[11:01:53.088]                             next
[11:01:53.088]                           invokeRestart(restart)
[11:01:53.088]                           muffled <- TRUE
[11:01:53.088]                           break
[11:01:53.088]                         }
[11:01:53.088]                       }
[11:01:53.088]                     }
[11:01:53.088]                     invisible(muffled)
[11:01:53.088]                   }
[11:01:53.088]                   muffleCondition(cond)
[11:01:53.088]                 })
[11:01:53.088]             }))
[11:01:53.088]             future::FutureResult(value = ...future.value$value, 
[11:01:53.088]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.088]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.088]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.088]                     ...future.globalenv.names))
[11:01:53.088]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.088]         }, condition = base::local({
[11:01:53.088]             c <- base::c
[11:01:53.088]             inherits <- base::inherits
[11:01:53.088]             invokeRestart <- base::invokeRestart
[11:01:53.088]             length <- base::length
[11:01:53.088]             list <- base::list
[11:01:53.088]             seq.int <- base::seq.int
[11:01:53.088]             signalCondition <- base::signalCondition
[11:01:53.088]             sys.calls <- base::sys.calls
[11:01:53.088]             `[[` <- base::`[[`
[11:01:53.088]             `+` <- base::`+`
[11:01:53.088]             `<<-` <- base::`<<-`
[11:01:53.088]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.088]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.088]                   3L)]
[11:01:53.088]             }
[11:01:53.088]             function(cond) {
[11:01:53.088]                 is_error <- inherits(cond, "error")
[11:01:53.088]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.088]                   NULL)
[11:01:53.088]                 if (is_error) {
[11:01:53.088]                   sessionInformation <- function() {
[11:01:53.088]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.088]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.088]                       search = base::search(), system = base::Sys.info())
[11:01:53.088]                   }
[11:01:53.088]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.088]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.088]                     cond$call), session = sessionInformation(), 
[11:01:53.088]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.088]                   signalCondition(cond)
[11:01:53.088]                 }
[11:01:53.088]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.088]                 "immediateCondition"))) {
[11:01:53.088]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.088]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.088]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.088]                   if (TRUE && !signal) {
[11:01:53.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.088]                     {
[11:01:53.088]                       inherits <- base::inherits
[11:01:53.088]                       invokeRestart <- base::invokeRestart
[11:01:53.088]                       is.null <- base::is.null
[11:01:53.088]                       muffled <- FALSE
[11:01:53.088]                       if (inherits(cond, "message")) {
[11:01:53.088]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.088]                         if (muffled) 
[11:01:53.088]                           invokeRestart("muffleMessage")
[11:01:53.088]                       }
[11:01:53.088]                       else if (inherits(cond, "warning")) {
[11:01:53.088]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.088]                         if (muffled) 
[11:01:53.088]                           invokeRestart("muffleWarning")
[11:01:53.088]                       }
[11:01:53.088]                       else if (inherits(cond, "condition")) {
[11:01:53.088]                         if (!is.null(pattern)) {
[11:01:53.088]                           computeRestarts <- base::computeRestarts
[11:01:53.088]                           grepl <- base::grepl
[11:01:53.088]                           restarts <- computeRestarts(cond)
[11:01:53.088]                           for (restart in restarts) {
[11:01:53.088]                             name <- restart$name
[11:01:53.088]                             if (is.null(name)) 
[11:01:53.088]                               next
[11:01:53.088]                             if (!grepl(pattern, name)) 
[11:01:53.088]                               next
[11:01:53.088]                             invokeRestart(restart)
[11:01:53.088]                             muffled <- TRUE
[11:01:53.088]                             break
[11:01:53.088]                           }
[11:01:53.088]                         }
[11:01:53.088]                       }
[11:01:53.088]                       invisible(muffled)
[11:01:53.088]                     }
[11:01:53.088]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.088]                   }
[11:01:53.088]                 }
[11:01:53.088]                 else {
[11:01:53.088]                   if (TRUE) {
[11:01:53.088]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.088]                     {
[11:01:53.088]                       inherits <- base::inherits
[11:01:53.088]                       invokeRestart <- base::invokeRestart
[11:01:53.088]                       is.null <- base::is.null
[11:01:53.088]                       muffled <- FALSE
[11:01:53.088]                       if (inherits(cond, "message")) {
[11:01:53.088]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.088]                         if (muffled) 
[11:01:53.088]                           invokeRestart("muffleMessage")
[11:01:53.088]                       }
[11:01:53.088]                       else if (inherits(cond, "warning")) {
[11:01:53.088]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.088]                         if (muffled) 
[11:01:53.088]                           invokeRestart("muffleWarning")
[11:01:53.088]                       }
[11:01:53.088]                       else if (inherits(cond, "condition")) {
[11:01:53.088]                         if (!is.null(pattern)) {
[11:01:53.088]                           computeRestarts <- base::computeRestarts
[11:01:53.088]                           grepl <- base::grepl
[11:01:53.088]                           restarts <- computeRestarts(cond)
[11:01:53.088]                           for (restart in restarts) {
[11:01:53.088]                             name <- restart$name
[11:01:53.088]                             if (is.null(name)) 
[11:01:53.088]                               next
[11:01:53.088]                             if (!grepl(pattern, name)) 
[11:01:53.088]                               next
[11:01:53.088]                             invokeRestart(restart)
[11:01:53.088]                             muffled <- TRUE
[11:01:53.088]                             break
[11:01:53.088]                           }
[11:01:53.088]                         }
[11:01:53.088]                       }
[11:01:53.088]                       invisible(muffled)
[11:01:53.088]                     }
[11:01:53.088]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.088]                   }
[11:01:53.088]                 }
[11:01:53.088]             }
[11:01:53.088]         }))
[11:01:53.088]     }, error = function(ex) {
[11:01:53.088]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.088]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.088]                 ...future.rng), started = ...future.startTime, 
[11:01:53.088]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.088]             version = "1.8"), class = "FutureResult")
[11:01:53.088]     }, finally = {
[11:01:53.088]         if (!identical(...future.workdir, getwd())) 
[11:01:53.088]             setwd(...future.workdir)
[11:01:53.088]         {
[11:01:53.088]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.088]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.088]             }
[11:01:53.088]             base::options(...future.oldOptions)
[11:01:53.088]             if (.Platform$OS.type == "windows") {
[11:01:53.088]                 old_names <- names(...future.oldEnvVars)
[11:01:53.088]                 envs <- base::Sys.getenv()
[11:01:53.088]                 names <- names(envs)
[11:01:53.088]                 common <- intersect(names, old_names)
[11:01:53.088]                 added <- setdiff(names, old_names)
[11:01:53.088]                 removed <- setdiff(old_names, names)
[11:01:53.088]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.088]                   envs[common]]
[11:01:53.088]                 NAMES <- toupper(changed)
[11:01:53.088]                 args <- list()
[11:01:53.088]                 for (kk in seq_along(NAMES)) {
[11:01:53.088]                   name <- changed[[kk]]
[11:01:53.088]                   NAME <- NAMES[[kk]]
[11:01:53.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.088]                     next
[11:01:53.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.088]                 }
[11:01:53.088]                 NAMES <- toupper(added)
[11:01:53.088]                 for (kk in seq_along(NAMES)) {
[11:01:53.088]                   name <- added[[kk]]
[11:01:53.088]                   NAME <- NAMES[[kk]]
[11:01:53.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.088]                     next
[11:01:53.088]                   args[[name]] <- ""
[11:01:53.088]                 }
[11:01:53.088]                 NAMES <- toupper(removed)
[11:01:53.088]                 for (kk in seq_along(NAMES)) {
[11:01:53.088]                   name <- removed[[kk]]
[11:01:53.088]                   NAME <- NAMES[[kk]]
[11:01:53.088]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.088]                     next
[11:01:53.088]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.088]                 }
[11:01:53.088]                 if (length(args) > 0) 
[11:01:53.088]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.088]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.088]             }
[11:01:53.088]             else {
[11:01:53.088]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.088]             }
[11:01:53.088]             {
[11:01:53.088]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.088]                   0L) {
[11:01:53.088]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.088]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.088]                   base::options(opts)
[11:01:53.088]                 }
[11:01:53.088]                 {
[11:01:53.088]                   {
[11:01:53.088]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.088]                     NULL
[11:01:53.088]                   }
[11:01:53.088]                   options(future.plan = NULL)
[11:01:53.088]                   if (is.na(NA_character_)) 
[11:01:53.088]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.088]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.088]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.088]                     .init = FALSE)
[11:01:53.088]                 }
[11:01:53.088]             }
[11:01:53.088]         }
[11:01:53.088]     })
[11:01:53.088]     if (TRUE) {
[11:01:53.088]         base::sink(type = "output", split = FALSE)
[11:01:53.088]         if (TRUE) {
[11:01:53.088]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.088]         }
[11:01:53.088]         else {
[11:01:53.088]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.088]         }
[11:01:53.088]         base::close(...future.stdout)
[11:01:53.088]         ...future.stdout <- NULL
[11:01:53.088]     }
[11:01:53.088]     ...future.result$conditions <- ...future.conditions
[11:01:53.088]     ...future.result$finished <- base::Sys.time()
[11:01:53.088]     ...future.result
[11:01:53.088] }
[11:01:53.090] assign_globals() ...
[11:01:53.090] List of 2
[11:01:53.090]  $ a : num 1
[11:01:53.090]  $ ii: int 1
[11:01:53.090]  - attr(*, "where")=List of 2
[11:01:53.090]   ..$ a :<environment: R_EmptyEnv> 
[11:01:53.090]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:53.090]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.090]  - attr(*, "resolved")= logi TRUE
[11:01:53.090]  - attr(*, "total_size")= num 74
[11:01:53.090]  - attr(*, "already-done")= logi TRUE
[11:01:53.095] - copied ‘a’ to environment
[11:01:53.095] - copied ‘ii’ to environment
[11:01:53.095] assign_globals() ... done
[11:01:53.095] requestCore(): workers = 2
[11:01:53.097] MulticoreFuture started
[11:01:53.097] - Launch lazy future ... done
[11:01:53.098] run() for ‘MulticoreFuture’ ... done
[11:01:53.098] plan(): Setting new future strategy stack:
[11:01:53.098] result() for MulticoreFuture ...
[11:01:53.098] List of future strategies:
[11:01:53.098] 1. sequential:
[11:01:53.098]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.098]    - tweaked: FALSE
[11:01:53.098]    - call: NULL
[11:01:53.100] plan(): nbrOfWorkers() = 1
[11:01:53.102] plan(): Setting new future strategy stack:
[11:01:53.103] List of future strategies:
[11:01:53.103] 1. multicore:
[11:01:53.103]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.103]    - tweaked: FALSE
[11:01:53.103]    - call: plan(strategy)
[11:01:53.107] plan(): nbrOfWorkers() = 2
[11:01:53.108] result() for MulticoreFuture ...
[11:01:53.108] result() for MulticoreFuture ... done
[11:01:53.108] result() for MulticoreFuture ... done
[11:01:53.108] result() for MulticoreFuture ...
[11:01:53.109] result() for MulticoreFuture ... done
[11:01:53.109] run() for ‘Future’ ...
[11:01:53.109] - state: ‘created’
[11:01:53.109] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.112] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.112] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.112]   - Field: ‘label’
[11:01:53.113]   - Field: ‘local’
[11:01:53.113]   - Field: ‘owner’
[11:01:53.113]   - Field: ‘envir’
[11:01:53.113]   - Field: ‘workers’
[11:01:53.113]   - Field: ‘packages’
[11:01:53.113]   - Field: ‘gc’
[11:01:53.113]   - Field: ‘job’
[11:01:53.113]   - Field: ‘conditions’
[11:01:53.114]   - Field: ‘expr’
[11:01:53.114]   - Field: ‘uuid’
[11:01:53.114]   - Field: ‘seed’
[11:01:53.114]   - Field: ‘version’
[11:01:53.114]   - Field: ‘result’
[11:01:53.114]   - Field: ‘asynchronous’
[11:01:53.114]   - Field: ‘calls’
[11:01:53.114]   - Field: ‘globals’
[11:01:53.114]   - Field: ‘stdout’
[11:01:53.115]   - Field: ‘earlySignal’
[11:01:53.115]   - Field: ‘lazy’
[11:01:53.115]   - Field: ‘state’
[11:01:53.115] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.115] - Launch lazy future ...
[11:01:53.115] Packages needed by the future expression (n = 0): <none>
[11:01:53.115] Packages needed by future strategies (n = 0): <none>
[11:01:53.116] {
[11:01:53.116]     {
[11:01:53.116]         {
[11:01:53.116]             ...future.startTime <- base::Sys.time()
[11:01:53.116]             {
[11:01:53.116]                 {
[11:01:53.116]                   {
[11:01:53.116]                     {
[11:01:53.116]                       base::local({
[11:01:53.116]                         has_future <- base::requireNamespace("future", 
[11:01:53.116]                           quietly = TRUE)
[11:01:53.116]                         if (has_future) {
[11:01:53.116]                           ns <- base::getNamespace("future")
[11:01:53.116]                           version <- ns[[".package"]][["version"]]
[11:01:53.116]                           if (is.null(version)) 
[11:01:53.116]                             version <- utils::packageVersion("future")
[11:01:53.116]                         }
[11:01:53.116]                         else {
[11:01:53.116]                           version <- NULL
[11:01:53.116]                         }
[11:01:53.116]                         if (!has_future || version < "1.8.0") {
[11:01:53.116]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.116]                             "", base::R.version$version.string), 
[11:01:53.116]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.116]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.116]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.116]                               "release", "version")], collapse = " "), 
[11:01:53.116]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.116]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.116]                             info)
[11:01:53.116]                           info <- base::paste(info, collapse = "; ")
[11:01:53.116]                           if (!has_future) {
[11:01:53.116]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.116]                               info)
[11:01:53.116]                           }
[11:01:53.116]                           else {
[11:01:53.116]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.116]                               info, version)
[11:01:53.116]                           }
[11:01:53.116]                           base::stop(msg)
[11:01:53.116]                         }
[11:01:53.116]                       })
[11:01:53.116]                     }
[11:01:53.116]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.116]                     base::options(mc.cores = 1L)
[11:01:53.116]                   }
[11:01:53.116]                   ...future.strategy.old <- future::plan("list")
[11:01:53.116]                   options(future.plan = NULL)
[11:01:53.116]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.116]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.116]                 }
[11:01:53.116]                 ...future.workdir <- getwd()
[11:01:53.116]             }
[11:01:53.116]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.116]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.116]         }
[11:01:53.116]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.116]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.116]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.116]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.116]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.116]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.116]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.116]             base::names(...future.oldOptions))
[11:01:53.116]     }
[11:01:53.116]     if (FALSE) {
[11:01:53.116]     }
[11:01:53.116]     else {
[11:01:53.116]         if (TRUE) {
[11:01:53.116]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.116]                 open = "w")
[11:01:53.116]         }
[11:01:53.116]         else {
[11:01:53.116]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.116]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.116]         }
[11:01:53.116]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.116]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.116]             base::sink(type = "output", split = FALSE)
[11:01:53.116]             base::close(...future.stdout)
[11:01:53.116]         }, add = TRUE)
[11:01:53.116]     }
[11:01:53.116]     ...future.frame <- base::sys.nframe()
[11:01:53.116]     ...future.conditions <- base::list()
[11:01:53.116]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.116]     if (FALSE) {
[11:01:53.116]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.116]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.116]     }
[11:01:53.116]     ...future.result <- base::tryCatch({
[11:01:53.116]         base::withCallingHandlers({
[11:01:53.116]             ...future.value <- base::withVisible(base::local({
[11:01:53.116]                 withCallingHandlers({
[11:01:53.116]                   {
[11:01:53.116]                     b <- a * ii
[11:01:53.116]                     a <- 0
[11:01:53.116]                     b
[11:01:53.116]                   }
[11:01:53.116]                 }, immediateCondition = function(cond) {
[11:01:53.116]                   save_rds <- function (object, pathname, ...) 
[11:01:53.116]                   {
[11:01:53.116]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.116]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.116]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.116]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.116]                         fi_tmp[["mtime"]])
[11:01:53.116]                     }
[11:01:53.116]                     tryCatch({
[11:01:53.116]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.116]                     }, error = function(ex) {
[11:01:53.116]                       msg <- conditionMessage(ex)
[11:01:53.116]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.116]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.116]                         fi_tmp[["mtime"]], msg)
[11:01:53.116]                       ex$message <- msg
[11:01:53.116]                       stop(ex)
[11:01:53.116]                     })
[11:01:53.116]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.116]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.116]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.116]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.116]                       fi <- file.info(pathname)
[11:01:53.116]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.116]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.116]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.116]                         fi[["size"]], fi[["mtime"]])
[11:01:53.116]                       stop(msg)
[11:01:53.116]                     }
[11:01:53.116]                     invisible(pathname)
[11:01:53.116]                   }
[11:01:53.116]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.116]                     rootPath = tempdir()) 
[11:01:53.116]                   {
[11:01:53.116]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.116]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.116]                       tmpdir = path, fileext = ".rds")
[11:01:53.116]                     save_rds(obj, file)
[11:01:53.116]                   }
[11:01:53.116]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.116]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.116]                   {
[11:01:53.116]                     inherits <- base::inherits
[11:01:53.116]                     invokeRestart <- base::invokeRestart
[11:01:53.116]                     is.null <- base::is.null
[11:01:53.116]                     muffled <- FALSE
[11:01:53.116]                     if (inherits(cond, "message")) {
[11:01:53.116]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.116]                       if (muffled) 
[11:01:53.116]                         invokeRestart("muffleMessage")
[11:01:53.116]                     }
[11:01:53.116]                     else if (inherits(cond, "warning")) {
[11:01:53.116]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.116]                       if (muffled) 
[11:01:53.116]                         invokeRestart("muffleWarning")
[11:01:53.116]                     }
[11:01:53.116]                     else if (inherits(cond, "condition")) {
[11:01:53.116]                       if (!is.null(pattern)) {
[11:01:53.116]                         computeRestarts <- base::computeRestarts
[11:01:53.116]                         grepl <- base::grepl
[11:01:53.116]                         restarts <- computeRestarts(cond)
[11:01:53.116]                         for (restart in restarts) {
[11:01:53.116]                           name <- restart$name
[11:01:53.116]                           if (is.null(name)) 
[11:01:53.116]                             next
[11:01:53.116]                           if (!grepl(pattern, name)) 
[11:01:53.116]                             next
[11:01:53.116]                           invokeRestart(restart)
[11:01:53.116]                           muffled <- TRUE
[11:01:53.116]                           break
[11:01:53.116]                         }
[11:01:53.116]                       }
[11:01:53.116]                     }
[11:01:53.116]                     invisible(muffled)
[11:01:53.116]                   }
[11:01:53.116]                   muffleCondition(cond)
[11:01:53.116]                 })
[11:01:53.116]             }))
[11:01:53.116]             future::FutureResult(value = ...future.value$value, 
[11:01:53.116]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.116]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.116]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.116]                     ...future.globalenv.names))
[11:01:53.116]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.116]         }, condition = base::local({
[11:01:53.116]             c <- base::c
[11:01:53.116]             inherits <- base::inherits
[11:01:53.116]             invokeRestart <- base::invokeRestart
[11:01:53.116]             length <- base::length
[11:01:53.116]             list <- base::list
[11:01:53.116]             seq.int <- base::seq.int
[11:01:53.116]             signalCondition <- base::signalCondition
[11:01:53.116]             sys.calls <- base::sys.calls
[11:01:53.116]             `[[` <- base::`[[`
[11:01:53.116]             `+` <- base::`+`
[11:01:53.116]             `<<-` <- base::`<<-`
[11:01:53.116]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.116]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.116]                   3L)]
[11:01:53.116]             }
[11:01:53.116]             function(cond) {
[11:01:53.116]                 is_error <- inherits(cond, "error")
[11:01:53.116]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.116]                   NULL)
[11:01:53.116]                 if (is_error) {
[11:01:53.116]                   sessionInformation <- function() {
[11:01:53.116]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.116]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.116]                       search = base::search(), system = base::Sys.info())
[11:01:53.116]                   }
[11:01:53.116]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.116]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.116]                     cond$call), session = sessionInformation(), 
[11:01:53.116]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.116]                   signalCondition(cond)
[11:01:53.116]                 }
[11:01:53.116]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.116]                 "immediateCondition"))) {
[11:01:53.116]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.116]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.116]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.116]                   if (TRUE && !signal) {
[11:01:53.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.116]                     {
[11:01:53.116]                       inherits <- base::inherits
[11:01:53.116]                       invokeRestart <- base::invokeRestart
[11:01:53.116]                       is.null <- base::is.null
[11:01:53.116]                       muffled <- FALSE
[11:01:53.116]                       if (inherits(cond, "message")) {
[11:01:53.116]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.116]                         if (muffled) 
[11:01:53.116]                           invokeRestart("muffleMessage")
[11:01:53.116]                       }
[11:01:53.116]                       else if (inherits(cond, "warning")) {
[11:01:53.116]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.116]                         if (muffled) 
[11:01:53.116]                           invokeRestart("muffleWarning")
[11:01:53.116]                       }
[11:01:53.116]                       else if (inherits(cond, "condition")) {
[11:01:53.116]                         if (!is.null(pattern)) {
[11:01:53.116]                           computeRestarts <- base::computeRestarts
[11:01:53.116]                           grepl <- base::grepl
[11:01:53.116]                           restarts <- computeRestarts(cond)
[11:01:53.116]                           for (restart in restarts) {
[11:01:53.116]                             name <- restart$name
[11:01:53.116]                             if (is.null(name)) 
[11:01:53.116]                               next
[11:01:53.116]                             if (!grepl(pattern, name)) 
[11:01:53.116]                               next
[11:01:53.116]                             invokeRestart(restart)
[11:01:53.116]                             muffled <- TRUE
[11:01:53.116]                             break
[11:01:53.116]                           }
[11:01:53.116]                         }
[11:01:53.116]                       }
[11:01:53.116]                       invisible(muffled)
[11:01:53.116]                     }
[11:01:53.116]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.116]                   }
[11:01:53.116]                 }
[11:01:53.116]                 else {
[11:01:53.116]                   if (TRUE) {
[11:01:53.116]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.116]                     {
[11:01:53.116]                       inherits <- base::inherits
[11:01:53.116]                       invokeRestart <- base::invokeRestart
[11:01:53.116]                       is.null <- base::is.null
[11:01:53.116]                       muffled <- FALSE
[11:01:53.116]                       if (inherits(cond, "message")) {
[11:01:53.116]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.116]                         if (muffled) 
[11:01:53.116]                           invokeRestart("muffleMessage")
[11:01:53.116]                       }
[11:01:53.116]                       else if (inherits(cond, "warning")) {
[11:01:53.116]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.116]                         if (muffled) 
[11:01:53.116]                           invokeRestart("muffleWarning")
[11:01:53.116]                       }
[11:01:53.116]                       else if (inherits(cond, "condition")) {
[11:01:53.116]                         if (!is.null(pattern)) {
[11:01:53.116]                           computeRestarts <- base::computeRestarts
[11:01:53.116]                           grepl <- base::grepl
[11:01:53.116]                           restarts <- computeRestarts(cond)
[11:01:53.116]                           for (restart in restarts) {
[11:01:53.116]                             name <- restart$name
[11:01:53.116]                             if (is.null(name)) 
[11:01:53.116]                               next
[11:01:53.116]                             if (!grepl(pattern, name)) 
[11:01:53.116]                               next
[11:01:53.116]                             invokeRestart(restart)
[11:01:53.116]                             muffled <- TRUE
[11:01:53.116]                             break
[11:01:53.116]                           }
[11:01:53.116]                         }
[11:01:53.116]                       }
[11:01:53.116]                       invisible(muffled)
[11:01:53.116]                     }
[11:01:53.116]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.116]                   }
[11:01:53.116]                 }
[11:01:53.116]             }
[11:01:53.116]         }))
[11:01:53.116]     }, error = function(ex) {
[11:01:53.116]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.116]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.116]                 ...future.rng), started = ...future.startTime, 
[11:01:53.116]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.116]             version = "1.8"), class = "FutureResult")
[11:01:53.116]     }, finally = {
[11:01:53.116]         if (!identical(...future.workdir, getwd())) 
[11:01:53.116]             setwd(...future.workdir)
[11:01:53.116]         {
[11:01:53.116]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.116]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.116]             }
[11:01:53.116]             base::options(...future.oldOptions)
[11:01:53.116]             if (.Platform$OS.type == "windows") {
[11:01:53.116]                 old_names <- names(...future.oldEnvVars)
[11:01:53.116]                 envs <- base::Sys.getenv()
[11:01:53.116]                 names <- names(envs)
[11:01:53.116]                 common <- intersect(names, old_names)
[11:01:53.116]                 added <- setdiff(names, old_names)
[11:01:53.116]                 removed <- setdiff(old_names, names)
[11:01:53.116]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.116]                   envs[common]]
[11:01:53.116]                 NAMES <- toupper(changed)
[11:01:53.116]                 args <- list()
[11:01:53.116]                 for (kk in seq_along(NAMES)) {
[11:01:53.116]                   name <- changed[[kk]]
[11:01:53.116]                   NAME <- NAMES[[kk]]
[11:01:53.116]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.116]                     next
[11:01:53.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.116]                 }
[11:01:53.116]                 NAMES <- toupper(added)
[11:01:53.116]                 for (kk in seq_along(NAMES)) {
[11:01:53.116]                   name <- added[[kk]]
[11:01:53.116]                   NAME <- NAMES[[kk]]
[11:01:53.116]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.116]                     next
[11:01:53.116]                   args[[name]] <- ""
[11:01:53.116]                 }
[11:01:53.116]                 NAMES <- toupper(removed)
[11:01:53.116]                 for (kk in seq_along(NAMES)) {
[11:01:53.116]                   name <- removed[[kk]]
[11:01:53.116]                   NAME <- NAMES[[kk]]
[11:01:53.116]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.116]                     next
[11:01:53.116]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.116]                 }
[11:01:53.116]                 if (length(args) > 0) 
[11:01:53.116]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.116]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.116]             }
[11:01:53.116]             else {
[11:01:53.116]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.116]             }
[11:01:53.116]             {
[11:01:53.116]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.116]                   0L) {
[11:01:53.116]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.116]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.116]                   base::options(opts)
[11:01:53.116]                 }
[11:01:53.116]                 {
[11:01:53.116]                   {
[11:01:53.116]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.116]                     NULL
[11:01:53.116]                   }
[11:01:53.116]                   options(future.plan = NULL)
[11:01:53.116]                   if (is.na(NA_character_)) 
[11:01:53.116]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.116]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.116]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.116]                     .init = FALSE)
[11:01:53.116]                 }
[11:01:53.116]             }
[11:01:53.116]         }
[11:01:53.116]     })
[11:01:53.116]     if (TRUE) {
[11:01:53.116]         base::sink(type = "output", split = FALSE)
[11:01:53.116]         if (TRUE) {
[11:01:53.116]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.116]         }
[11:01:53.116]         else {
[11:01:53.116]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.116]         }
[11:01:53.116]         base::close(...future.stdout)
[11:01:53.116]         ...future.stdout <- NULL
[11:01:53.116]     }
[11:01:53.116]     ...future.result$conditions <- ...future.conditions
[11:01:53.116]     ...future.result$finished <- base::Sys.time()
[11:01:53.116]     ...future.result
[11:01:53.116] }
[11:01:53.119] assign_globals() ...
[11:01:53.119] List of 2
[11:01:53.119]  $ a : num 1
[11:01:53.119]  $ ii: int 2
[11:01:53.119]  - attr(*, "where")=List of 2
[11:01:53.119]   ..$ a :<environment: R_EmptyEnv> 
[11:01:53.119]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:53.119]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.119]  - attr(*, "resolved")= logi TRUE
[11:01:53.119]  - attr(*, "total_size")= num 74
[11:01:53.119]  - attr(*, "already-done")= logi TRUE
[11:01:53.122] - copied ‘a’ to environment
[11:01:53.122] - copied ‘ii’ to environment
[11:01:53.123] assign_globals() ... done
[11:01:53.123] requestCore(): workers = 2
[11:01:53.124] MulticoreFuture started
[11:01:53.125] - Launch lazy future ... done
[11:01:53.125] run() for ‘MulticoreFuture’ ... done
[11:01:53.125] result() for MulticoreFuture ...
[11:01:53.125] plan(): Setting new future strategy stack:
[11:01:53.125] List of future strategies:
[11:01:53.125] 1. sequential:
[11:01:53.125]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.125]    - tweaked: FALSE
[11:01:53.125]    - call: NULL
[11:01:53.126] plan(): nbrOfWorkers() = 1
[11:01:53.129] plan(): Setting new future strategy stack:
[11:01:53.129] List of future strategies:
[11:01:53.129] 1. multicore:
[11:01:53.129]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.129]    - tweaked: FALSE
[11:01:53.129]    - call: plan(strategy)
[11:01:53.132] plan(): nbrOfWorkers() = 2
[11:01:53.132] result() for MulticoreFuture ...
[11:01:53.133] result() for MulticoreFuture ... done
[11:01:53.133] result() for MulticoreFuture ... done
[11:01:53.133] result() for MulticoreFuture ...
[11:01:53.133] result() for MulticoreFuture ... done
[11:01:53.133] run() for ‘Future’ ...
[11:01:53.133] - state: ‘created’
[11:01:53.134] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.136] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.136] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.136]   - Field: ‘label’
[11:01:53.136]   - Field: ‘local’
[11:01:53.136]   - Field: ‘owner’
[11:01:53.137]   - Field: ‘envir’
[11:01:53.137]   - Field: ‘workers’
[11:01:53.137]   - Field: ‘packages’
[11:01:53.137]   - Field: ‘gc’
[11:01:53.137]   - Field: ‘job’
[11:01:53.137]   - Field: ‘conditions’
[11:01:53.137]   - Field: ‘expr’
[11:01:53.137]   - Field: ‘uuid’
[11:01:53.137]   - Field: ‘seed’
[11:01:53.137]   - Field: ‘version’
[11:01:53.138]   - Field: ‘result’
[11:01:53.138]   - Field: ‘asynchronous’
[11:01:53.138]   - Field: ‘calls’
[11:01:53.138]   - Field: ‘globals’
[11:01:53.138]   - Field: ‘stdout’
[11:01:53.138]   - Field: ‘earlySignal’
[11:01:53.138]   - Field: ‘lazy’
[11:01:53.138]   - Field: ‘state’
[11:01:53.138] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.139] - Launch lazy future ...
[11:01:53.139] Packages needed by the future expression (n = 0): <none>
[11:01:53.139] Packages needed by future strategies (n = 0): <none>
[11:01:53.139] {
[11:01:53.139]     {
[11:01:53.139]         {
[11:01:53.139]             ...future.startTime <- base::Sys.time()
[11:01:53.139]             {
[11:01:53.139]                 {
[11:01:53.139]                   {
[11:01:53.139]                     {
[11:01:53.139]                       base::local({
[11:01:53.139]                         has_future <- base::requireNamespace("future", 
[11:01:53.139]                           quietly = TRUE)
[11:01:53.139]                         if (has_future) {
[11:01:53.139]                           ns <- base::getNamespace("future")
[11:01:53.139]                           version <- ns[[".package"]][["version"]]
[11:01:53.139]                           if (is.null(version)) 
[11:01:53.139]                             version <- utils::packageVersion("future")
[11:01:53.139]                         }
[11:01:53.139]                         else {
[11:01:53.139]                           version <- NULL
[11:01:53.139]                         }
[11:01:53.139]                         if (!has_future || version < "1.8.0") {
[11:01:53.139]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.139]                             "", base::R.version$version.string), 
[11:01:53.139]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.139]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.139]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.139]                               "release", "version")], collapse = " "), 
[11:01:53.139]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.139]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.139]                             info)
[11:01:53.139]                           info <- base::paste(info, collapse = "; ")
[11:01:53.139]                           if (!has_future) {
[11:01:53.139]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.139]                               info)
[11:01:53.139]                           }
[11:01:53.139]                           else {
[11:01:53.139]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.139]                               info, version)
[11:01:53.139]                           }
[11:01:53.139]                           base::stop(msg)
[11:01:53.139]                         }
[11:01:53.139]                       })
[11:01:53.139]                     }
[11:01:53.139]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.139]                     base::options(mc.cores = 1L)
[11:01:53.139]                   }
[11:01:53.139]                   ...future.strategy.old <- future::plan("list")
[11:01:53.139]                   options(future.plan = NULL)
[11:01:53.139]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.139]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.139]                 }
[11:01:53.139]                 ...future.workdir <- getwd()
[11:01:53.139]             }
[11:01:53.139]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.139]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.139]         }
[11:01:53.139]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.139]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.139]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.139]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.139]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.139]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.139]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.139]             base::names(...future.oldOptions))
[11:01:53.139]     }
[11:01:53.139]     if (FALSE) {
[11:01:53.139]     }
[11:01:53.139]     else {
[11:01:53.139]         if (TRUE) {
[11:01:53.139]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.139]                 open = "w")
[11:01:53.139]         }
[11:01:53.139]         else {
[11:01:53.139]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.139]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.139]         }
[11:01:53.139]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.139]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.139]             base::sink(type = "output", split = FALSE)
[11:01:53.139]             base::close(...future.stdout)
[11:01:53.139]         }, add = TRUE)
[11:01:53.139]     }
[11:01:53.139]     ...future.frame <- base::sys.nframe()
[11:01:53.139]     ...future.conditions <- base::list()
[11:01:53.139]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.139]     if (FALSE) {
[11:01:53.139]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.139]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.139]     }
[11:01:53.139]     ...future.result <- base::tryCatch({
[11:01:53.139]         base::withCallingHandlers({
[11:01:53.139]             ...future.value <- base::withVisible(base::local({
[11:01:53.139]                 withCallingHandlers({
[11:01:53.139]                   {
[11:01:53.139]                     b <- a * ii
[11:01:53.139]                     a <- 0
[11:01:53.139]                     b
[11:01:53.139]                   }
[11:01:53.139]                 }, immediateCondition = function(cond) {
[11:01:53.139]                   save_rds <- function (object, pathname, ...) 
[11:01:53.139]                   {
[11:01:53.139]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.139]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.139]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.139]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.139]                         fi_tmp[["mtime"]])
[11:01:53.139]                     }
[11:01:53.139]                     tryCatch({
[11:01:53.139]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.139]                     }, error = function(ex) {
[11:01:53.139]                       msg <- conditionMessage(ex)
[11:01:53.139]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.139]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.139]                         fi_tmp[["mtime"]], msg)
[11:01:53.139]                       ex$message <- msg
[11:01:53.139]                       stop(ex)
[11:01:53.139]                     })
[11:01:53.139]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.139]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.139]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.139]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.139]                       fi <- file.info(pathname)
[11:01:53.139]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.139]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.139]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.139]                         fi[["size"]], fi[["mtime"]])
[11:01:53.139]                       stop(msg)
[11:01:53.139]                     }
[11:01:53.139]                     invisible(pathname)
[11:01:53.139]                   }
[11:01:53.139]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.139]                     rootPath = tempdir()) 
[11:01:53.139]                   {
[11:01:53.139]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.139]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.139]                       tmpdir = path, fileext = ".rds")
[11:01:53.139]                     save_rds(obj, file)
[11:01:53.139]                   }
[11:01:53.139]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.139]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.139]                   {
[11:01:53.139]                     inherits <- base::inherits
[11:01:53.139]                     invokeRestart <- base::invokeRestart
[11:01:53.139]                     is.null <- base::is.null
[11:01:53.139]                     muffled <- FALSE
[11:01:53.139]                     if (inherits(cond, "message")) {
[11:01:53.139]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.139]                       if (muffled) 
[11:01:53.139]                         invokeRestart("muffleMessage")
[11:01:53.139]                     }
[11:01:53.139]                     else if (inherits(cond, "warning")) {
[11:01:53.139]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.139]                       if (muffled) 
[11:01:53.139]                         invokeRestart("muffleWarning")
[11:01:53.139]                     }
[11:01:53.139]                     else if (inherits(cond, "condition")) {
[11:01:53.139]                       if (!is.null(pattern)) {
[11:01:53.139]                         computeRestarts <- base::computeRestarts
[11:01:53.139]                         grepl <- base::grepl
[11:01:53.139]                         restarts <- computeRestarts(cond)
[11:01:53.139]                         for (restart in restarts) {
[11:01:53.139]                           name <- restart$name
[11:01:53.139]                           if (is.null(name)) 
[11:01:53.139]                             next
[11:01:53.139]                           if (!grepl(pattern, name)) 
[11:01:53.139]                             next
[11:01:53.139]                           invokeRestart(restart)
[11:01:53.139]                           muffled <- TRUE
[11:01:53.139]                           break
[11:01:53.139]                         }
[11:01:53.139]                       }
[11:01:53.139]                     }
[11:01:53.139]                     invisible(muffled)
[11:01:53.139]                   }
[11:01:53.139]                   muffleCondition(cond)
[11:01:53.139]                 })
[11:01:53.139]             }))
[11:01:53.139]             future::FutureResult(value = ...future.value$value, 
[11:01:53.139]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.139]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.139]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.139]                     ...future.globalenv.names))
[11:01:53.139]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.139]         }, condition = base::local({
[11:01:53.139]             c <- base::c
[11:01:53.139]             inherits <- base::inherits
[11:01:53.139]             invokeRestart <- base::invokeRestart
[11:01:53.139]             length <- base::length
[11:01:53.139]             list <- base::list
[11:01:53.139]             seq.int <- base::seq.int
[11:01:53.139]             signalCondition <- base::signalCondition
[11:01:53.139]             sys.calls <- base::sys.calls
[11:01:53.139]             `[[` <- base::`[[`
[11:01:53.139]             `+` <- base::`+`
[11:01:53.139]             `<<-` <- base::`<<-`
[11:01:53.139]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.139]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.139]                   3L)]
[11:01:53.139]             }
[11:01:53.139]             function(cond) {
[11:01:53.139]                 is_error <- inherits(cond, "error")
[11:01:53.139]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.139]                   NULL)
[11:01:53.139]                 if (is_error) {
[11:01:53.139]                   sessionInformation <- function() {
[11:01:53.139]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.139]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.139]                       search = base::search(), system = base::Sys.info())
[11:01:53.139]                   }
[11:01:53.139]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.139]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.139]                     cond$call), session = sessionInformation(), 
[11:01:53.139]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.139]                   signalCondition(cond)
[11:01:53.139]                 }
[11:01:53.139]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.139]                 "immediateCondition"))) {
[11:01:53.139]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.139]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.139]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.139]                   if (TRUE && !signal) {
[11:01:53.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.139]                     {
[11:01:53.139]                       inherits <- base::inherits
[11:01:53.139]                       invokeRestart <- base::invokeRestart
[11:01:53.139]                       is.null <- base::is.null
[11:01:53.139]                       muffled <- FALSE
[11:01:53.139]                       if (inherits(cond, "message")) {
[11:01:53.139]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.139]                         if (muffled) 
[11:01:53.139]                           invokeRestart("muffleMessage")
[11:01:53.139]                       }
[11:01:53.139]                       else if (inherits(cond, "warning")) {
[11:01:53.139]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.139]                         if (muffled) 
[11:01:53.139]                           invokeRestart("muffleWarning")
[11:01:53.139]                       }
[11:01:53.139]                       else if (inherits(cond, "condition")) {
[11:01:53.139]                         if (!is.null(pattern)) {
[11:01:53.139]                           computeRestarts <- base::computeRestarts
[11:01:53.139]                           grepl <- base::grepl
[11:01:53.139]                           restarts <- computeRestarts(cond)
[11:01:53.139]                           for (restart in restarts) {
[11:01:53.139]                             name <- restart$name
[11:01:53.139]                             if (is.null(name)) 
[11:01:53.139]                               next
[11:01:53.139]                             if (!grepl(pattern, name)) 
[11:01:53.139]                               next
[11:01:53.139]                             invokeRestart(restart)
[11:01:53.139]                             muffled <- TRUE
[11:01:53.139]                             break
[11:01:53.139]                           }
[11:01:53.139]                         }
[11:01:53.139]                       }
[11:01:53.139]                       invisible(muffled)
[11:01:53.139]                     }
[11:01:53.139]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.139]                   }
[11:01:53.139]                 }
[11:01:53.139]                 else {
[11:01:53.139]                   if (TRUE) {
[11:01:53.139]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.139]                     {
[11:01:53.139]                       inherits <- base::inherits
[11:01:53.139]                       invokeRestart <- base::invokeRestart
[11:01:53.139]                       is.null <- base::is.null
[11:01:53.139]                       muffled <- FALSE
[11:01:53.139]                       if (inherits(cond, "message")) {
[11:01:53.139]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.139]                         if (muffled) 
[11:01:53.139]                           invokeRestart("muffleMessage")
[11:01:53.139]                       }
[11:01:53.139]                       else if (inherits(cond, "warning")) {
[11:01:53.139]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.139]                         if (muffled) 
[11:01:53.139]                           invokeRestart("muffleWarning")
[11:01:53.139]                       }
[11:01:53.139]                       else if (inherits(cond, "condition")) {
[11:01:53.139]                         if (!is.null(pattern)) {
[11:01:53.139]                           computeRestarts <- base::computeRestarts
[11:01:53.139]                           grepl <- base::grepl
[11:01:53.139]                           restarts <- computeRestarts(cond)
[11:01:53.139]                           for (restart in restarts) {
[11:01:53.139]                             name <- restart$name
[11:01:53.139]                             if (is.null(name)) 
[11:01:53.139]                               next
[11:01:53.139]                             if (!grepl(pattern, name)) 
[11:01:53.139]                               next
[11:01:53.139]                             invokeRestart(restart)
[11:01:53.139]                             muffled <- TRUE
[11:01:53.139]                             break
[11:01:53.139]                           }
[11:01:53.139]                         }
[11:01:53.139]                       }
[11:01:53.139]                       invisible(muffled)
[11:01:53.139]                     }
[11:01:53.139]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.139]                   }
[11:01:53.139]                 }
[11:01:53.139]             }
[11:01:53.139]         }))
[11:01:53.139]     }, error = function(ex) {
[11:01:53.139]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.139]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.139]                 ...future.rng), started = ...future.startTime, 
[11:01:53.139]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.139]             version = "1.8"), class = "FutureResult")
[11:01:53.139]     }, finally = {
[11:01:53.139]         if (!identical(...future.workdir, getwd())) 
[11:01:53.139]             setwd(...future.workdir)
[11:01:53.139]         {
[11:01:53.139]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.139]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.139]             }
[11:01:53.139]             base::options(...future.oldOptions)
[11:01:53.139]             if (.Platform$OS.type == "windows") {
[11:01:53.139]                 old_names <- names(...future.oldEnvVars)
[11:01:53.139]                 envs <- base::Sys.getenv()
[11:01:53.139]                 names <- names(envs)
[11:01:53.139]                 common <- intersect(names, old_names)
[11:01:53.139]                 added <- setdiff(names, old_names)
[11:01:53.139]                 removed <- setdiff(old_names, names)
[11:01:53.139]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.139]                   envs[common]]
[11:01:53.139]                 NAMES <- toupper(changed)
[11:01:53.139]                 args <- list()
[11:01:53.139]                 for (kk in seq_along(NAMES)) {
[11:01:53.139]                   name <- changed[[kk]]
[11:01:53.139]                   NAME <- NAMES[[kk]]
[11:01:53.139]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.139]                     next
[11:01:53.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.139]                 }
[11:01:53.139]                 NAMES <- toupper(added)
[11:01:53.139]                 for (kk in seq_along(NAMES)) {
[11:01:53.139]                   name <- added[[kk]]
[11:01:53.139]                   NAME <- NAMES[[kk]]
[11:01:53.139]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.139]                     next
[11:01:53.139]                   args[[name]] <- ""
[11:01:53.139]                 }
[11:01:53.139]                 NAMES <- toupper(removed)
[11:01:53.139]                 for (kk in seq_along(NAMES)) {
[11:01:53.139]                   name <- removed[[kk]]
[11:01:53.139]                   NAME <- NAMES[[kk]]
[11:01:53.139]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.139]                     next
[11:01:53.139]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.139]                 }
[11:01:53.139]                 if (length(args) > 0) 
[11:01:53.139]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.139]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.139]             }
[11:01:53.139]             else {
[11:01:53.139]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.139]             }
[11:01:53.139]             {
[11:01:53.139]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.139]                   0L) {
[11:01:53.139]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.139]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.139]                   base::options(opts)
[11:01:53.139]                 }
[11:01:53.139]                 {
[11:01:53.139]                   {
[11:01:53.139]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.139]                     NULL
[11:01:53.139]                   }
[11:01:53.139]                   options(future.plan = NULL)
[11:01:53.139]                   if (is.na(NA_character_)) 
[11:01:53.139]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.139]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.139]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.139]                     .init = FALSE)
[11:01:53.139]                 }
[11:01:53.139]             }
[11:01:53.139]         }
[11:01:53.139]     })
[11:01:53.139]     if (TRUE) {
[11:01:53.139]         base::sink(type = "output", split = FALSE)
[11:01:53.139]         if (TRUE) {
[11:01:53.139]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.139]         }
[11:01:53.139]         else {
[11:01:53.139]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.139]         }
[11:01:53.139]         base::close(...future.stdout)
[11:01:53.139]         ...future.stdout <- NULL
[11:01:53.139]     }
[11:01:53.139]     ...future.result$conditions <- ...future.conditions
[11:01:53.139]     ...future.result$finished <- base::Sys.time()
[11:01:53.139]     ...future.result
[11:01:53.139] }
[11:01:53.142] assign_globals() ...
[11:01:53.142] List of 2
[11:01:53.142]  $ a : num 1
[11:01:53.142]  $ ii: int 3
[11:01:53.142]  - attr(*, "where")=List of 2
[11:01:53.142]   ..$ a :<environment: R_EmptyEnv> 
[11:01:53.142]   ..$ ii:<environment: R_EmptyEnv> 
[11:01:53.142]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.142]  - attr(*, "resolved")= logi TRUE
[11:01:53.142]  - attr(*, "total_size")= num 74
[11:01:53.142]  - attr(*, "already-done")= logi TRUE
[11:01:53.149] - copied ‘a’ to environment
[11:01:53.149] - copied ‘ii’ to environment
[11:01:53.149] assign_globals() ... done
[11:01:53.149] requestCore(): workers = 2
[11:01:53.151] MulticoreFuture started
[11:01:53.152] - Launch lazy future ... done
[11:01:53.152] plan(): Setting new future strategy stack:
[11:01:53.152] run() for ‘MulticoreFuture’ ... done
[11:01:53.153] result() for MulticoreFuture ...
[11:01:53.152] List of future strategies:
[11:01:53.152] 1. sequential:
[11:01:53.152]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.152]    - tweaked: FALSE
[11:01:53.152]    - call: NULL
[11:01:53.154] plan(): nbrOfWorkers() = 1
[11:01:53.156] plan(): Setting new future strategy stack:
[11:01:53.157] List of future strategies:
[11:01:53.157] 1. multicore:
[11:01:53.157]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.157]    - tweaked: FALSE
[11:01:53.157]    - call: plan(strategy)
[11:01:53.161] plan(): nbrOfWorkers() = 2
[11:01:53.161] result() for MulticoreFuture ...
[11:01:53.162] result() for MulticoreFuture ... done
[11:01:53.162] result() for MulticoreFuture ... done
[11:01:53.162] result() for MulticoreFuture ...
[11:01:53.162] result() for MulticoreFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.163] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.163] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.164] 
[11:01:53.164] Searching for globals ... DONE
[11:01:53.164] - globals: [0] <none>
[11:01:53.165] getGlobalsAndPackages() ... DONE
[11:01:53.165] run() for ‘Future’ ...
[11:01:53.165] - state: ‘created’
[11:01:53.165] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.167] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.168] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.168]   - Field: ‘label’
[11:01:53.168]   - Field: ‘local’
[11:01:53.168]   - Field: ‘owner’
[11:01:53.168]   - Field: ‘envir’
[11:01:53.168]   - Field: ‘workers’
[11:01:53.168]   - Field: ‘packages’
[11:01:53.168]   - Field: ‘gc’
[11:01:53.169]   - Field: ‘job’
[11:01:53.169]   - Field: ‘conditions’
[11:01:53.169]   - Field: ‘expr’
[11:01:53.169]   - Field: ‘uuid’
[11:01:53.169]   - Field: ‘seed’
[11:01:53.169]   - Field: ‘version’
[11:01:53.169]   - Field: ‘result’
[11:01:53.169]   - Field: ‘asynchronous’
[11:01:53.169]   - Field: ‘calls’
[11:01:53.170]   - Field: ‘globals’
[11:01:53.170]   - Field: ‘stdout’
[11:01:53.170]   - Field: ‘earlySignal’
[11:01:53.170]   - Field: ‘lazy’
[11:01:53.170]   - Field: ‘state’
[11:01:53.170] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.170] - Launch lazy future ...
[11:01:53.171] Packages needed by the future expression (n = 0): <none>
[11:01:53.171] Packages needed by future strategies (n = 0): <none>
[11:01:53.171] {
[11:01:53.171]     {
[11:01:53.171]         {
[11:01:53.171]             ...future.startTime <- base::Sys.time()
[11:01:53.171]             {
[11:01:53.171]                 {
[11:01:53.171]                   {
[11:01:53.171]                     {
[11:01:53.171]                       base::local({
[11:01:53.171]                         has_future <- base::requireNamespace("future", 
[11:01:53.171]                           quietly = TRUE)
[11:01:53.171]                         if (has_future) {
[11:01:53.171]                           ns <- base::getNamespace("future")
[11:01:53.171]                           version <- ns[[".package"]][["version"]]
[11:01:53.171]                           if (is.null(version)) 
[11:01:53.171]                             version <- utils::packageVersion("future")
[11:01:53.171]                         }
[11:01:53.171]                         else {
[11:01:53.171]                           version <- NULL
[11:01:53.171]                         }
[11:01:53.171]                         if (!has_future || version < "1.8.0") {
[11:01:53.171]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.171]                             "", base::R.version$version.string), 
[11:01:53.171]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.171]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.171]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.171]                               "release", "version")], collapse = " "), 
[11:01:53.171]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.171]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.171]                             info)
[11:01:53.171]                           info <- base::paste(info, collapse = "; ")
[11:01:53.171]                           if (!has_future) {
[11:01:53.171]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.171]                               info)
[11:01:53.171]                           }
[11:01:53.171]                           else {
[11:01:53.171]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.171]                               info, version)
[11:01:53.171]                           }
[11:01:53.171]                           base::stop(msg)
[11:01:53.171]                         }
[11:01:53.171]                       })
[11:01:53.171]                     }
[11:01:53.171]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.171]                     base::options(mc.cores = 1L)
[11:01:53.171]                   }
[11:01:53.171]                   ...future.strategy.old <- future::plan("list")
[11:01:53.171]                   options(future.plan = NULL)
[11:01:53.171]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.171]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.171]                 }
[11:01:53.171]                 ...future.workdir <- getwd()
[11:01:53.171]             }
[11:01:53.171]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.171]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.171]         }
[11:01:53.171]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.171]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.171]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.171]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.171]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.171]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.171]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.171]             base::names(...future.oldOptions))
[11:01:53.171]     }
[11:01:53.171]     if (FALSE) {
[11:01:53.171]     }
[11:01:53.171]     else {
[11:01:53.171]         if (TRUE) {
[11:01:53.171]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.171]                 open = "w")
[11:01:53.171]         }
[11:01:53.171]         else {
[11:01:53.171]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.171]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.171]         }
[11:01:53.171]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.171]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.171]             base::sink(type = "output", split = FALSE)
[11:01:53.171]             base::close(...future.stdout)
[11:01:53.171]         }, add = TRUE)
[11:01:53.171]     }
[11:01:53.171]     ...future.frame <- base::sys.nframe()
[11:01:53.171]     ...future.conditions <- base::list()
[11:01:53.171]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.171]     if (FALSE) {
[11:01:53.171]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.171]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.171]     }
[11:01:53.171]     ...future.result <- base::tryCatch({
[11:01:53.171]         base::withCallingHandlers({
[11:01:53.171]             ...future.value <- base::withVisible(base::local({
[11:01:53.171]                 withCallingHandlers({
[11:01:53.171]                   1
[11:01:53.171]                 }, immediateCondition = function(cond) {
[11:01:53.171]                   save_rds <- function (object, pathname, ...) 
[11:01:53.171]                   {
[11:01:53.171]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.171]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.171]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.171]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.171]                         fi_tmp[["mtime"]])
[11:01:53.171]                     }
[11:01:53.171]                     tryCatch({
[11:01:53.171]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.171]                     }, error = function(ex) {
[11:01:53.171]                       msg <- conditionMessage(ex)
[11:01:53.171]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.171]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.171]                         fi_tmp[["mtime"]], msg)
[11:01:53.171]                       ex$message <- msg
[11:01:53.171]                       stop(ex)
[11:01:53.171]                     })
[11:01:53.171]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.171]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.171]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.171]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.171]                       fi <- file.info(pathname)
[11:01:53.171]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.171]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.171]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.171]                         fi[["size"]], fi[["mtime"]])
[11:01:53.171]                       stop(msg)
[11:01:53.171]                     }
[11:01:53.171]                     invisible(pathname)
[11:01:53.171]                   }
[11:01:53.171]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.171]                     rootPath = tempdir()) 
[11:01:53.171]                   {
[11:01:53.171]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.171]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.171]                       tmpdir = path, fileext = ".rds")
[11:01:53.171]                     save_rds(obj, file)
[11:01:53.171]                   }
[11:01:53.171]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.171]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.171]                   {
[11:01:53.171]                     inherits <- base::inherits
[11:01:53.171]                     invokeRestart <- base::invokeRestart
[11:01:53.171]                     is.null <- base::is.null
[11:01:53.171]                     muffled <- FALSE
[11:01:53.171]                     if (inherits(cond, "message")) {
[11:01:53.171]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.171]                       if (muffled) 
[11:01:53.171]                         invokeRestart("muffleMessage")
[11:01:53.171]                     }
[11:01:53.171]                     else if (inherits(cond, "warning")) {
[11:01:53.171]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.171]                       if (muffled) 
[11:01:53.171]                         invokeRestart("muffleWarning")
[11:01:53.171]                     }
[11:01:53.171]                     else if (inherits(cond, "condition")) {
[11:01:53.171]                       if (!is.null(pattern)) {
[11:01:53.171]                         computeRestarts <- base::computeRestarts
[11:01:53.171]                         grepl <- base::grepl
[11:01:53.171]                         restarts <- computeRestarts(cond)
[11:01:53.171]                         for (restart in restarts) {
[11:01:53.171]                           name <- restart$name
[11:01:53.171]                           if (is.null(name)) 
[11:01:53.171]                             next
[11:01:53.171]                           if (!grepl(pattern, name)) 
[11:01:53.171]                             next
[11:01:53.171]                           invokeRestart(restart)
[11:01:53.171]                           muffled <- TRUE
[11:01:53.171]                           break
[11:01:53.171]                         }
[11:01:53.171]                       }
[11:01:53.171]                     }
[11:01:53.171]                     invisible(muffled)
[11:01:53.171]                   }
[11:01:53.171]                   muffleCondition(cond)
[11:01:53.171]                 })
[11:01:53.171]             }))
[11:01:53.171]             future::FutureResult(value = ...future.value$value, 
[11:01:53.171]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.171]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.171]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.171]                     ...future.globalenv.names))
[11:01:53.171]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.171]         }, condition = base::local({
[11:01:53.171]             c <- base::c
[11:01:53.171]             inherits <- base::inherits
[11:01:53.171]             invokeRestart <- base::invokeRestart
[11:01:53.171]             length <- base::length
[11:01:53.171]             list <- base::list
[11:01:53.171]             seq.int <- base::seq.int
[11:01:53.171]             signalCondition <- base::signalCondition
[11:01:53.171]             sys.calls <- base::sys.calls
[11:01:53.171]             `[[` <- base::`[[`
[11:01:53.171]             `+` <- base::`+`
[11:01:53.171]             `<<-` <- base::`<<-`
[11:01:53.171]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.171]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.171]                   3L)]
[11:01:53.171]             }
[11:01:53.171]             function(cond) {
[11:01:53.171]                 is_error <- inherits(cond, "error")
[11:01:53.171]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.171]                   NULL)
[11:01:53.171]                 if (is_error) {
[11:01:53.171]                   sessionInformation <- function() {
[11:01:53.171]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.171]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.171]                       search = base::search(), system = base::Sys.info())
[11:01:53.171]                   }
[11:01:53.171]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.171]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.171]                     cond$call), session = sessionInformation(), 
[11:01:53.171]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.171]                   signalCondition(cond)
[11:01:53.171]                 }
[11:01:53.171]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.171]                 "immediateCondition"))) {
[11:01:53.171]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.171]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.171]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.171]                   if (TRUE && !signal) {
[11:01:53.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.171]                     {
[11:01:53.171]                       inherits <- base::inherits
[11:01:53.171]                       invokeRestart <- base::invokeRestart
[11:01:53.171]                       is.null <- base::is.null
[11:01:53.171]                       muffled <- FALSE
[11:01:53.171]                       if (inherits(cond, "message")) {
[11:01:53.171]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.171]                         if (muffled) 
[11:01:53.171]                           invokeRestart("muffleMessage")
[11:01:53.171]                       }
[11:01:53.171]                       else if (inherits(cond, "warning")) {
[11:01:53.171]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.171]                         if (muffled) 
[11:01:53.171]                           invokeRestart("muffleWarning")
[11:01:53.171]                       }
[11:01:53.171]                       else if (inherits(cond, "condition")) {
[11:01:53.171]                         if (!is.null(pattern)) {
[11:01:53.171]                           computeRestarts <- base::computeRestarts
[11:01:53.171]                           grepl <- base::grepl
[11:01:53.171]                           restarts <- computeRestarts(cond)
[11:01:53.171]                           for (restart in restarts) {
[11:01:53.171]                             name <- restart$name
[11:01:53.171]                             if (is.null(name)) 
[11:01:53.171]                               next
[11:01:53.171]                             if (!grepl(pattern, name)) 
[11:01:53.171]                               next
[11:01:53.171]                             invokeRestart(restart)
[11:01:53.171]                             muffled <- TRUE
[11:01:53.171]                             break
[11:01:53.171]                           }
[11:01:53.171]                         }
[11:01:53.171]                       }
[11:01:53.171]                       invisible(muffled)
[11:01:53.171]                     }
[11:01:53.171]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.171]                   }
[11:01:53.171]                 }
[11:01:53.171]                 else {
[11:01:53.171]                   if (TRUE) {
[11:01:53.171]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.171]                     {
[11:01:53.171]                       inherits <- base::inherits
[11:01:53.171]                       invokeRestart <- base::invokeRestart
[11:01:53.171]                       is.null <- base::is.null
[11:01:53.171]                       muffled <- FALSE
[11:01:53.171]                       if (inherits(cond, "message")) {
[11:01:53.171]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.171]                         if (muffled) 
[11:01:53.171]                           invokeRestart("muffleMessage")
[11:01:53.171]                       }
[11:01:53.171]                       else if (inherits(cond, "warning")) {
[11:01:53.171]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.171]                         if (muffled) 
[11:01:53.171]                           invokeRestart("muffleWarning")
[11:01:53.171]                       }
[11:01:53.171]                       else if (inherits(cond, "condition")) {
[11:01:53.171]                         if (!is.null(pattern)) {
[11:01:53.171]                           computeRestarts <- base::computeRestarts
[11:01:53.171]                           grepl <- base::grepl
[11:01:53.171]                           restarts <- computeRestarts(cond)
[11:01:53.171]                           for (restart in restarts) {
[11:01:53.171]                             name <- restart$name
[11:01:53.171]                             if (is.null(name)) 
[11:01:53.171]                               next
[11:01:53.171]                             if (!grepl(pattern, name)) 
[11:01:53.171]                               next
[11:01:53.171]                             invokeRestart(restart)
[11:01:53.171]                             muffled <- TRUE
[11:01:53.171]                             break
[11:01:53.171]                           }
[11:01:53.171]                         }
[11:01:53.171]                       }
[11:01:53.171]                       invisible(muffled)
[11:01:53.171]                     }
[11:01:53.171]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.171]                   }
[11:01:53.171]                 }
[11:01:53.171]             }
[11:01:53.171]         }))
[11:01:53.171]     }, error = function(ex) {
[11:01:53.171]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.171]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.171]                 ...future.rng), started = ...future.startTime, 
[11:01:53.171]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.171]             version = "1.8"), class = "FutureResult")
[11:01:53.171]     }, finally = {
[11:01:53.171]         if (!identical(...future.workdir, getwd())) 
[11:01:53.171]             setwd(...future.workdir)
[11:01:53.171]         {
[11:01:53.171]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.171]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.171]             }
[11:01:53.171]             base::options(...future.oldOptions)
[11:01:53.171]             if (.Platform$OS.type == "windows") {
[11:01:53.171]                 old_names <- names(...future.oldEnvVars)
[11:01:53.171]                 envs <- base::Sys.getenv()
[11:01:53.171]                 names <- names(envs)
[11:01:53.171]                 common <- intersect(names, old_names)
[11:01:53.171]                 added <- setdiff(names, old_names)
[11:01:53.171]                 removed <- setdiff(old_names, names)
[11:01:53.171]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.171]                   envs[common]]
[11:01:53.171]                 NAMES <- toupper(changed)
[11:01:53.171]                 args <- list()
[11:01:53.171]                 for (kk in seq_along(NAMES)) {
[11:01:53.171]                   name <- changed[[kk]]
[11:01:53.171]                   NAME <- NAMES[[kk]]
[11:01:53.171]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.171]                     next
[11:01:53.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.171]                 }
[11:01:53.171]                 NAMES <- toupper(added)
[11:01:53.171]                 for (kk in seq_along(NAMES)) {
[11:01:53.171]                   name <- added[[kk]]
[11:01:53.171]                   NAME <- NAMES[[kk]]
[11:01:53.171]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.171]                     next
[11:01:53.171]                   args[[name]] <- ""
[11:01:53.171]                 }
[11:01:53.171]                 NAMES <- toupper(removed)
[11:01:53.171]                 for (kk in seq_along(NAMES)) {
[11:01:53.171]                   name <- removed[[kk]]
[11:01:53.171]                   NAME <- NAMES[[kk]]
[11:01:53.171]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.171]                     next
[11:01:53.171]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.171]                 }
[11:01:53.171]                 if (length(args) > 0) 
[11:01:53.171]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.171]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.171]             }
[11:01:53.171]             else {
[11:01:53.171]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.171]             }
[11:01:53.171]             {
[11:01:53.171]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.171]                   0L) {
[11:01:53.171]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.171]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.171]                   base::options(opts)
[11:01:53.171]                 }
[11:01:53.171]                 {
[11:01:53.171]                   {
[11:01:53.171]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.171]                     NULL
[11:01:53.171]                   }
[11:01:53.171]                   options(future.plan = NULL)
[11:01:53.171]                   if (is.na(NA_character_)) 
[11:01:53.171]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.171]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.171]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.171]                     .init = FALSE)
[11:01:53.171]                 }
[11:01:53.171]             }
[11:01:53.171]         }
[11:01:53.171]     })
[11:01:53.171]     if (TRUE) {
[11:01:53.171]         base::sink(type = "output", split = FALSE)
[11:01:53.171]         if (TRUE) {
[11:01:53.171]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.171]         }
[11:01:53.171]         else {
[11:01:53.171]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.171]         }
[11:01:53.171]         base::close(...future.stdout)
[11:01:53.171]         ...future.stdout <- NULL
[11:01:53.171]     }
[11:01:53.171]     ...future.result$conditions <- ...future.conditions
[11:01:53.171]     ...future.result$finished <- base::Sys.time()
[11:01:53.171]     ...future.result
[11:01:53.171] }
[11:01:53.174] requestCore(): workers = 2
[11:01:53.175] MulticoreFuture started
[11:01:53.176] - Launch lazy future ... done
[11:01:53.176] run() for ‘MulticoreFuture’ ... done
[11:01:53.176] plan(): Setting new future strategy stack:
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.177] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.177] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.177] List of future strategies:
[11:01:53.177] 1. sequential:
[11:01:53.177]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.177]    - tweaked: FALSE
[11:01:53.177]    - call: NULL
[11:01:53.178] plan(): nbrOfWorkers() = 1
[11:01:53.179] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:53.179] Searching for globals ... DONE
[11:01:53.179] Resolving globals: TRUE
[11:01:53.179] Resolving any globals that are futures ...
[11:01:53.179] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:53.179] Resolving any globals that are futures ... DONE
[11:01:53.180] plan(): Setting new future strategy stack:
[11:01:53.180] List of future strategies:
[11:01:53.180] 1. multicore:
[11:01:53.180]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.180]    - tweaked: FALSE
[11:01:53.180]    - call: plan(strategy)
[11:01:53.180] Resolving futures part of globals (recursively) ...
[11:01:53.181] resolve() on list ...
[11:01:53.181]  recursive: 99
[11:01:53.181]  length: 1
[11:01:53.181]  elements: ‘a’
[11:01:53.182] plan(): nbrOfWorkers() = 2
[11:01:53.183] Future #1
[11:01:53.183] result() for MulticoreFuture ...
[11:01:53.184] result() for MulticoreFuture ...
[11:01:53.184] result() for MulticoreFuture ... done
[11:01:53.184] result() for MulticoreFuture ... done
[11:01:53.184] result() for MulticoreFuture ...
[11:01:53.185] result() for MulticoreFuture ... done
[11:01:53.185] A MulticoreFuture was resolved
[11:01:53.185]  length: 0 (resolved future 1)
[11:01:53.185] resolve() on list ... DONE
[11:01:53.185] - globals: [1] ‘a’
[11:01:53.185] Resolving futures part of globals (recursively) ... DONE
[11:01:53.186] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[11:01:53.186] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[11:01:53.186] - globals: [1] ‘a’
[11:01:53.186] - packages: [1] ‘future’
[11:01:53.187] getGlobalsAndPackages() ... DONE
[11:01:53.187] run() for ‘Future’ ...
[11:01:53.187] - state: ‘created’
[11:01:53.187] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.189] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.189] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.189]   - Field: ‘label’
[11:01:53.190]   - Field: ‘local’
[11:01:53.190]   - Field: ‘owner’
[11:01:53.190]   - Field: ‘envir’
[11:01:53.190]   - Field: ‘workers’
[11:01:53.190]   - Field: ‘packages’
[11:01:53.190]   - Field: ‘gc’
[11:01:53.190]   - Field: ‘job’
[11:01:53.190]   - Field: ‘conditions’
[11:01:53.190]   - Field: ‘expr’
[11:01:53.191]   - Field: ‘uuid’
[11:01:53.191]   - Field: ‘seed’
[11:01:53.191]   - Field: ‘version’
[11:01:53.191]   - Field: ‘result’
[11:01:53.191]   - Field: ‘asynchronous’
[11:01:53.191]   - Field: ‘calls’
[11:01:53.191]   - Field: ‘globals’
[11:01:53.191]   - Field: ‘stdout’
[11:01:53.191]   - Field: ‘earlySignal’
[11:01:53.191]   - Field: ‘lazy’
[11:01:53.192]   - Field: ‘state’
[11:01:53.192] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.192] - Launch lazy future ...
[11:01:53.192] Packages needed by the future expression (n = 1): ‘future’
[11:01:53.192] Packages needed by future strategies (n = 0): <none>
[11:01:53.195] {
[11:01:53.195]     {
[11:01:53.195]         {
[11:01:53.195]             ...future.startTime <- base::Sys.time()
[11:01:53.195]             {
[11:01:53.195]                 {
[11:01:53.195]                   {
[11:01:53.195]                     {
[11:01:53.195]                       {
[11:01:53.195]                         base::local({
[11:01:53.195]                           has_future <- base::requireNamespace("future", 
[11:01:53.195]                             quietly = TRUE)
[11:01:53.195]                           if (has_future) {
[11:01:53.195]                             ns <- base::getNamespace("future")
[11:01:53.195]                             version <- ns[[".package"]][["version"]]
[11:01:53.195]                             if (is.null(version)) 
[11:01:53.195]                               version <- utils::packageVersion("future")
[11:01:53.195]                           }
[11:01:53.195]                           else {
[11:01:53.195]                             version <- NULL
[11:01:53.195]                           }
[11:01:53.195]                           if (!has_future || version < "1.8.0") {
[11:01:53.195]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.195]                               "", base::R.version$version.string), 
[11:01:53.195]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:53.195]                                 base::R.version$platform, 8 * 
[11:01:53.195]                                   base::.Machine$sizeof.pointer), 
[11:01:53.195]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.195]                                 "release", "version")], collapse = " "), 
[11:01:53.195]                               hostname = base::Sys.info()[["nodename"]])
[11:01:53.195]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.195]                               info)
[11:01:53.195]                             info <- base::paste(info, collapse = "; ")
[11:01:53.195]                             if (!has_future) {
[11:01:53.195]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.195]                                 info)
[11:01:53.195]                             }
[11:01:53.195]                             else {
[11:01:53.195]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.195]                                 info, version)
[11:01:53.195]                             }
[11:01:53.195]                             base::stop(msg)
[11:01:53.195]                           }
[11:01:53.195]                         })
[11:01:53.195]                       }
[11:01:53.195]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.195]                       base::options(mc.cores = 1L)
[11:01:53.195]                     }
[11:01:53.195]                     base::local({
[11:01:53.195]                       for (pkg in "future") {
[11:01:53.195]                         base::loadNamespace(pkg)
[11:01:53.195]                         base::library(pkg, character.only = TRUE)
[11:01:53.195]                       }
[11:01:53.195]                     })
[11:01:53.195]                   }
[11:01:53.195]                   ...future.strategy.old <- future::plan("list")
[11:01:53.195]                   options(future.plan = NULL)
[11:01:53.195]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.195]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.195]                 }
[11:01:53.195]                 ...future.workdir <- getwd()
[11:01:53.195]             }
[11:01:53.195]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.195]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.195]         }
[11:01:53.195]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.195]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.195]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.195]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.195]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.195]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.195]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.195]             base::names(...future.oldOptions))
[11:01:53.195]     }
[11:01:53.195]     if (FALSE) {
[11:01:53.195]     }
[11:01:53.195]     else {
[11:01:53.195]         if (TRUE) {
[11:01:53.195]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.195]                 open = "w")
[11:01:53.195]         }
[11:01:53.195]         else {
[11:01:53.195]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.195]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.195]         }
[11:01:53.195]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.195]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.195]             base::sink(type = "output", split = FALSE)
[11:01:53.195]             base::close(...future.stdout)
[11:01:53.195]         }, add = TRUE)
[11:01:53.195]     }
[11:01:53.195]     ...future.frame <- base::sys.nframe()
[11:01:53.195]     ...future.conditions <- base::list()
[11:01:53.195]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.195]     if (FALSE) {
[11:01:53.195]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.195]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.195]     }
[11:01:53.195]     ...future.result <- base::tryCatch({
[11:01:53.195]         base::withCallingHandlers({
[11:01:53.195]             ...future.value <- base::withVisible(base::local({
[11:01:53.195]                 withCallingHandlers({
[11:01:53.195]                   value(a) + 1
[11:01:53.195]                 }, immediateCondition = function(cond) {
[11:01:53.195]                   save_rds <- function (object, pathname, ...) 
[11:01:53.195]                   {
[11:01:53.195]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.195]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.195]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.195]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.195]                         fi_tmp[["mtime"]])
[11:01:53.195]                     }
[11:01:53.195]                     tryCatch({
[11:01:53.195]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.195]                     }, error = function(ex) {
[11:01:53.195]                       msg <- conditionMessage(ex)
[11:01:53.195]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.195]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.195]                         fi_tmp[["mtime"]], msg)
[11:01:53.195]                       ex$message <- msg
[11:01:53.195]                       stop(ex)
[11:01:53.195]                     })
[11:01:53.195]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.195]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.195]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.195]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.195]                       fi <- file.info(pathname)
[11:01:53.195]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.195]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.195]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.195]                         fi[["size"]], fi[["mtime"]])
[11:01:53.195]                       stop(msg)
[11:01:53.195]                     }
[11:01:53.195]                     invisible(pathname)
[11:01:53.195]                   }
[11:01:53.195]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.195]                     rootPath = tempdir()) 
[11:01:53.195]                   {
[11:01:53.195]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.195]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.195]                       tmpdir = path, fileext = ".rds")
[11:01:53.195]                     save_rds(obj, file)
[11:01:53.195]                   }
[11:01:53.195]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.195]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.195]                   {
[11:01:53.195]                     inherits <- base::inherits
[11:01:53.195]                     invokeRestart <- base::invokeRestart
[11:01:53.195]                     is.null <- base::is.null
[11:01:53.195]                     muffled <- FALSE
[11:01:53.195]                     if (inherits(cond, "message")) {
[11:01:53.195]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.195]                       if (muffled) 
[11:01:53.195]                         invokeRestart("muffleMessage")
[11:01:53.195]                     }
[11:01:53.195]                     else if (inherits(cond, "warning")) {
[11:01:53.195]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.195]                       if (muffled) 
[11:01:53.195]                         invokeRestart("muffleWarning")
[11:01:53.195]                     }
[11:01:53.195]                     else if (inherits(cond, "condition")) {
[11:01:53.195]                       if (!is.null(pattern)) {
[11:01:53.195]                         computeRestarts <- base::computeRestarts
[11:01:53.195]                         grepl <- base::grepl
[11:01:53.195]                         restarts <- computeRestarts(cond)
[11:01:53.195]                         for (restart in restarts) {
[11:01:53.195]                           name <- restart$name
[11:01:53.195]                           if (is.null(name)) 
[11:01:53.195]                             next
[11:01:53.195]                           if (!grepl(pattern, name)) 
[11:01:53.195]                             next
[11:01:53.195]                           invokeRestart(restart)
[11:01:53.195]                           muffled <- TRUE
[11:01:53.195]                           break
[11:01:53.195]                         }
[11:01:53.195]                       }
[11:01:53.195]                     }
[11:01:53.195]                     invisible(muffled)
[11:01:53.195]                   }
[11:01:53.195]                   muffleCondition(cond)
[11:01:53.195]                 })
[11:01:53.195]             }))
[11:01:53.195]             future::FutureResult(value = ...future.value$value, 
[11:01:53.195]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.195]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.195]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.195]                     ...future.globalenv.names))
[11:01:53.195]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.195]         }, condition = base::local({
[11:01:53.195]             c <- base::c
[11:01:53.195]             inherits <- base::inherits
[11:01:53.195]             invokeRestart <- base::invokeRestart
[11:01:53.195]             length <- base::length
[11:01:53.195]             list <- base::list
[11:01:53.195]             seq.int <- base::seq.int
[11:01:53.195]             signalCondition <- base::signalCondition
[11:01:53.195]             sys.calls <- base::sys.calls
[11:01:53.195]             `[[` <- base::`[[`
[11:01:53.195]             `+` <- base::`+`
[11:01:53.195]             `<<-` <- base::`<<-`
[11:01:53.195]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.195]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.195]                   3L)]
[11:01:53.195]             }
[11:01:53.195]             function(cond) {
[11:01:53.195]                 is_error <- inherits(cond, "error")
[11:01:53.195]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.195]                   NULL)
[11:01:53.195]                 if (is_error) {
[11:01:53.195]                   sessionInformation <- function() {
[11:01:53.195]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.195]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.195]                       search = base::search(), system = base::Sys.info())
[11:01:53.195]                   }
[11:01:53.195]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.195]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.195]                     cond$call), session = sessionInformation(), 
[11:01:53.195]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.195]                   signalCondition(cond)
[11:01:53.195]                 }
[11:01:53.195]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.195]                 "immediateCondition"))) {
[11:01:53.195]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.195]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.195]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.195]                   if (TRUE && !signal) {
[11:01:53.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.195]                     {
[11:01:53.195]                       inherits <- base::inherits
[11:01:53.195]                       invokeRestart <- base::invokeRestart
[11:01:53.195]                       is.null <- base::is.null
[11:01:53.195]                       muffled <- FALSE
[11:01:53.195]                       if (inherits(cond, "message")) {
[11:01:53.195]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.195]                         if (muffled) 
[11:01:53.195]                           invokeRestart("muffleMessage")
[11:01:53.195]                       }
[11:01:53.195]                       else if (inherits(cond, "warning")) {
[11:01:53.195]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.195]                         if (muffled) 
[11:01:53.195]                           invokeRestart("muffleWarning")
[11:01:53.195]                       }
[11:01:53.195]                       else if (inherits(cond, "condition")) {
[11:01:53.195]                         if (!is.null(pattern)) {
[11:01:53.195]                           computeRestarts <- base::computeRestarts
[11:01:53.195]                           grepl <- base::grepl
[11:01:53.195]                           restarts <- computeRestarts(cond)
[11:01:53.195]                           for (restart in restarts) {
[11:01:53.195]                             name <- restart$name
[11:01:53.195]                             if (is.null(name)) 
[11:01:53.195]                               next
[11:01:53.195]                             if (!grepl(pattern, name)) 
[11:01:53.195]                               next
[11:01:53.195]                             invokeRestart(restart)
[11:01:53.195]                             muffled <- TRUE
[11:01:53.195]                             break
[11:01:53.195]                           }
[11:01:53.195]                         }
[11:01:53.195]                       }
[11:01:53.195]                       invisible(muffled)
[11:01:53.195]                     }
[11:01:53.195]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.195]                   }
[11:01:53.195]                 }
[11:01:53.195]                 else {
[11:01:53.195]                   if (TRUE) {
[11:01:53.195]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.195]                     {
[11:01:53.195]                       inherits <- base::inherits
[11:01:53.195]                       invokeRestart <- base::invokeRestart
[11:01:53.195]                       is.null <- base::is.null
[11:01:53.195]                       muffled <- FALSE
[11:01:53.195]                       if (inherits(cond, "message")) {
[11:01:53.195]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.195]                         if (muffled) 
[11:01:53.195]                           invokeRestart("muffleMessage")
[11:01:53.195]                       }
[11:01:53.195]                       else if (inherits(cond, "warning")) {
[11:01:53.195]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.195]                         if (muffled) 
[11:01:53.195]                           invokeRestart("muffleWarning")
[11:01:53.195]                       }
[11:01:53.195]                       else if (inherits(cond, "condition")) {
[11:01:53.195]                         if (!is.null(pattern)) {
[11:01:53.195]                           computeRestarts <- base::computeRestarts
[11:01:53.195]                           grepl <- base::grepl
[11:01:53.195]                           restarts <- computeRestarts(cond)
[11:01:53.195]                           for (restart in restarts) {
[11:01:53.195]                             name <- restart$name
[11:01:53.195]                             if (is.null(name)) 
[11:01:53.195]                               next
[11:01:53.195]                             if (!grepl(pattern, name)) 
[11:01:53.195]                               next
[11:01:53.195]                             invokeRestart(restart)
[11:01:53.195]                             muffled <- TRUE
[11:01:53.195]                             break
[11:01:53.195]                           }
[11:01:53.195]                         }
[11:01:53.195]                       }
[11:01:53.195]                       invisible(muffled)
[11:01:53.195]                     }
[11:01:53.195]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.195]                   }
[11:01:53.195]                 }
[11:01:53.195]             }
[11:01:53.195]         }))
[11:01:53.195]     }, error = function(ex) {
[11:01:53.195]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.195]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.195]                 ...future.rng), started = ...future.startTime, 
[11:01:53.195]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.195]             version = "1.8"), class = "FutureResult")
[11:01:53.195]     }, finally = {
[11:01:53.195]         if (!identical(...future.workdir, getwd())) 
[11:01:53.195]             setwd(...future.workdir)
[11:01:53.195]         {
[11:01:53.195]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.195]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.195]             }
[11:01:53.195]             base::options(...future.oldOptions)
[11:01:53.195]             if (.Platform$OS.type == "windows") {
[11:01:53.195]                 old_names <- names(...future.oldEnvVars)
[11:01:53.195]                 envs <- base::Sys.getenv()
[11:01:53.195]                 names <- names(envs)
[11:01:53.195]                 common <- intersect(names, old_names)
[11:01:53.195]                 added <- setdiff(names, old_names)
[11:01:53.195]                 removed <- setdiff(old_names, names)
[11:01:53.195]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.195]                   envs[common]]
[11:01:53.195]                 NAMES <- toupper(changed)
[11:01:53.195]                 args <- list()
[11:01:53.195]                 for (kk in seq_along(NAMES)) {
[11:01:53.195]                   name <- changed[[kk]]
[11:01:53.195]                   NAME <- NAMES[[kk]]
[11:01:53.195]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.195]                     next
[11:01:53.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.195]                 }
[11:01:53.195]                 NAMES <- toupper(added)
[11:01:53.195]                 for (kk in seq_along(NAMES)) {
[11:01:53.195]                   name <- added[[kk]]
[11:01:53.195]                   NAME <- NAMES[[kk]]
[11:01:53.195]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.195]                     next
[11:01:53.195]                   args[[name]] <- ""
[11:01:53.195]                 }
[11:01:53.195]                 NAMES <- toupper(removed)
[11:01:53.195]                 for (kk in seq_along(NAMES)) {
[11:01:53.195]                   name <- removed[[kk]]
[11:01:53.195]                   NAME <- NAMES[[kk]]
[11:01:53.195]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.195]                     next
[11:01:53.195]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.195]                 }
[11:01:53.195]                 if (length(args) > 0) 
[11:01:53.195]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.195]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.195]             }
[11:01:53.195]             else {
[11:01:53.195]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.195]             }
[11:01:53.195]             {
[11:01:53.195]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.195]                   0L) {
[11:01:53.195]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.195]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.195]                   base::options(opts)
[11:01:53.195]                 }
[11:01:53.195]                 {
[11:01:53.195]                   {
[11:01:53.195]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.195]                     NULL
[11:01:53.195]                   }
[11:01:53.195]                   options(future.plan = NULL)
[11:01:53.195]                   if (is.na(NA_character_)) 
[11:01:53.195]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.195]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.195]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.195]                     .init = FALSE)
[11:01:53.195]                 }
[11:01:53.195]             }
[11:01:53.195]         }
[11:01:53.195]     })
[11:01:53.195]     if (TRUE) {
[11:01:53.195]         base::sink(type = "output", split = FALSE)
[11:01:53.195]         if (TRUE) {
[11:01:53.195]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.195]         }
[11:01:53.195]         else {
[11:01:53.195]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.195]         }
[11:01:53.195]         base::close(...future.stdout)
[11:01:53.195]         ...future.stdout <- NULL
[11:01:53.195]     }
[11:01:53.195]     ...future.result$conditions <- ...future.conditions
[11:01:53.195]     ...future.result$finished <- base::Sys.time()
[11:01:53.195]     ...future.result
[11:01:53.195] }
[11:01:53.198] assign_globals() ...
[11:01:53.198] List of 1
[11:01:53.198]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eecd846820> 
[11:01:53.198]  - attr(*, "where")=List of 1
[11:01:53.198]   ..$ a:<environment: R_EmptyEnv> 
[11:01:53.198]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.198]  - attr(*, "resolved")= logi TRUE
[11:01:53.198]  - attr(*, "total_size")= num 3815
[11:01:53.198]  - attr(*, "already-done")= logi TRUE
[11:01:53.201] - copied ‘a’ to environment
[11:01:53.201] assign_globals() ... done
[11:01:53.202] requestCore(): workers = 2
[11:01:53.203] MulticoreFuture started
[11:01:53.204] - Launch lazy future ... done
[11:01:53.205] run() for ‘MulticoreFuture’ ... done
[11:01:53.205] result() for MulticoreFuture ...
[11:01:53.205] plan(): Setting new future strategy stack:
[11:01:53.205] List of future strategies:
[11:01:53.205] 1. sequential:
[11:01:53.205]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.205]    - tweaked: FALSE
[11:01:53.205]    - call: NULL
[11:01:53.207] plan(): nbrOfWorkers() = 1
[11:01:53.210] plan(): Setting new future strategy stack:
[11:01:53.211] List of future strategies:
[11:01:53.211] 1. multicore:
[11:01:53.211]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.211]    - tweaked: FALSE
[11:01:53.211]    - call: plan(strategy)
[11:01:53.214] plan(): nbrOfWorkers() = 2
[11:01:53.215] result() for MulticoreFuture ...
[11:01:53.215] result() for MulticoreFuture ... done
[11:01:53.215] signalConditions() ...
[11:01:53.215]  - include = ‘immediateCondition’
[11:01:53.216]  - exclude = 
[11:01:53.216]  - resignal = FALSE
[11:01:53.216]  - Number of conditions: 4
[11:01:53.216] signalConditions() ... done
[11:01:53.216] result() for MulticoreFuture ... done
[11:01:53.216] result() for MulticoreFuture ...
[11:01:53.216] result() for MulticoreFuture ... done
[11:01:53.217] signalConditions() ...
[11:01:53.217]  - include = ‘immediateCondition’
[11:01:53.217]  - exclude = 
[11:01:53.217]  - resignal = FALSE
[11:01:53.217]  - Number of conditions: 4
[11:01:53.217] signalConditions() ... done
[11:01:53.217] Future state: ‘finished’
[11:01:53.218] result() for MulticoreFuture ...
[11:01:53.218] result() for MulticoreFuture ... done
[11:01:53.218] signalConditions() ...
[11:01:53.218]  - include = ‘condition’
[11:01:53.218]  - exclude = ‘immediateCondition’
[11:01:53.218]  - resignal = TRUE
[11:01:53.218]  - Number of conditions: 4
[11:01:53.218]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.208] result() for MulticoreFuture ...
[11:01:53.219]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.208] result() for MulticoreFuture ... done
[11:01:53.219]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.209] result() for MulticoreFuture ...
[11:01:53.219]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.209] result() for MulticoreFuture ... done
[11:01:53.219] signalConditions() ... done
value(b) = 2
[11:01:53.219] result() for MulticoreFuture ...
[11:01:53.219] result() for MulticoreFuture ... done
[11:01:53.220] result() for MulticoreFuture ...
[11:01:53.220] result() for MulticoreFuture ... done
[11:01:53.220] signalConditions() ...
[11:01:53.220]  - include = ‘immediateCondition’
[11:01:53.220]  - exclude = 
[11:01:53.220]  - resignal = FALSE
[11:01:53.220]  - Number of conditions: 4
[11:01:53.220] signalConditions() ... done
[11:01:53.220] Future state: ‘finished’
[11:01:53.221] result() for MulticoreFuture ...
[11:01:53.221] result() for MulticoreFuture ... done
[11:01:53.221] signalConditions() ...
[11:01:53.221]  - include = ‘condition’
[11:01:53.221]  - exclude = ‘immediateCondition’
[11:01:53.221]  - resignal = TRUE
[11:01:53.221]  - Number of conditions: 4
[11:01:53.221]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.208] result() for MulticoreFuture ...
[11:01:53.221]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.208] result() for MulticoreFuture ... done
[11:01:53.222]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.209] result() for MulticoreFuture ...
[11:01:53.222]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.209] result() for MulticoreFuture ... done
[11:01:53.222] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.222] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.222] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.223] 
[11:01:53.223] Searching for globals ... DONE
[11:01:53.223] - globals: [0] <none>
[11:01:53.223] getGlobalsAndPackages() ... DONE
[11:01:53.224] run() for ‘Future’ ...
[11:01:53.224] - state: ‘created’
[11:01:53.224] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.226] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.226] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.226]   - Field: ‘label’
[11:01:53.226]   - Field: ‘local’
[11:01:53.226]   - Field: ‘owner’
[11:01:53.226]   - Field: ‘envir’
[11:01:53.227]   - Field: ‘workers’
[11:01:53.227]   - Field: ‘packages’
[11:01:53.227]   - Field: ‘gc’
[11:01:53.227]   - Field: ‘job’
[11:01:53.227]   - Field: ‘conditions’
[11:01:53.227]   - Field: ‘expr’
[11:01:53.227]   - Field: ‘uuid’
[11:01:53.227]   - Field: ‘seed’
[11:01:53.227]   - Field: ‘version’
[11:01:53.228]   - Field: ‘result’
[11:01:53.228]   - Field: ‘asynchronous’
[11:01:53.228]   - Field: ‘calls’
[11:01:53.228]   - Field: ‘globals’
[11:01:53.228]   - Field: ‘stdout’
[11:01:53.228]   - Field: ‘earlySignal’
[11:01:53.228]   - Field: ‘lazy’
[11:01:53.228]   - Field: ‘state’
[11:01:53.228] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.228] - Launch lazy future ...
[11:01:53.229] Packages needed by the future expression (n = 0): <none>
[11:01:53.229] Packages needed by future strategies (n = 0): <none>
[11:01:53.229] {
[11:01:53.229]     {
[11:01:53.229]         {
[11:01:53.229]             ...future.startTime <- base::Sys.time()
[11:01:53.229]             {
[11:01:53.229]                 {
[11:01:53.229]                   {
[11:01:53.229]                     {
[11:01:53.229]                       base::local({
[11:01:53.229]                         has_future <- base::requireNamespace("future", 
[11:01:53.229]                           quietly = TRUE)
[11:01:53.229]                         if (has_future) {
[11:01:53.229]                           ns <- base::getNamespace("future")
[11:01:53.229]                           version <- ns[[".package"]][["version"]]
[11:01:53.229]                           if (is.null(version)) 
[11:01:53.229]                             version <- utils::packageVersion("future")
[11:01:53.229]                         }
[11:01:53.229]                         else {
[11:01:53.229]                           version <- NULL
[11:01:53.229]                         }
[11:01:53.229]                         if (!has_future || version < "1.8.0") {
[11:01:53.229]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.229]                             "", base::R.version$version.string), 
[11:01:53.229]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.229]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.229]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.229]                               "release", "version")], collapse = " "), 
[11:01:53.229]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.229]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.229]                             info)
[11:01:53.229]                           info <- base::paste(info, collapse = "; ")
[11:01:53.229]                           if (!has_future) {
[11:01:53.229]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.229]                               info)
[11:01:53.229]                           }
[11:01:53.229]                           else {
[11:01:53.229]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.229]                               info, version)
[11:01:53.229]                           }
[11:01:53.229]                           base::stop(msg)
[11:01:53.229]                         }
[11:01:53.229]                       })
[11:01:53.229]                     }
[11:01:53.229]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.229]                     base::options(mc.cores = 1L)
[11:01:53.229]                   }
[11:01:53.229]                   ...future.strategy.old <- future::plan("list")
[11:01:53.229]                   options(future.plan = NULL)
[11:01:53.229]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.229]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.229]                 }
[11:01:53.229]                 ...future.workdir <- getwd()
[11:01:53.229]             }
[11:01:53.229]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.229]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.229]         }
[11:01:53.229]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.229]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.229]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.229]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.229]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.229]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.229]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.229]             base::names(...future.oldOptions))
[11:01:53.229]     }
[11:01:53.229]     if (FALSE) {
[11:01:53.229]     }
[11:01:53.229]     else {
[11:01:53.229]         if (TRUE) {
[11:01:53.229]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.229]                 open = "w")
[11:01:53.229]         }
[11:01:53.229]         else {
[11:01:53.229]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.229]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.229]         }
[11:01:53.229]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.229]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.229]             base::sink(type = "output", split = FALSE)
[11:01:53.229]             base::close(...future.stdout)
[11:01:53.229]         }, add = TRUE)
[11:01:53.229]     }
[11:01:53.229]     ...future.frame <- base::sys.nframe()
[11:01:53.229]     ...future.conditions <- base::list()
[11:01:53.229]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.229]     if (FALSE) {
[11:01:53.229]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.229]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.229]     }
[11:01:53.229]     ...future.result <- base::tryCatch({
[11:01:53.229]         base::withCallingHandlers({
[11:01:53.229]             ...future.value <- base::withVisible(base::local({
[11:01:53.229]                 withCallingHandlers({
[11:01:53.229]                   1
[11:01:53.229]                 }, immediateCondition = function(cond) {
[11:01:53.229]                   save_rds <- function (object, pathname, ...) 
[11:01:53.229]                   {
[11:01:53.229]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.229]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.229]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.229]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.229]                         fi_tmp[["mtime"]])
[11:01:53.229]                     }
[11:01:53.229]                     tryCatch({
[11:01:53.229]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.229]                     }, error = function(ex) {
[11:01:53.229]                       msg <- conditionMessage(ex)
[11:01:53.229]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.229]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.229]                         fi_tmp[["mtime"]], msg)
[11:01:53.229]                       ex$message <- msg
[11:01:53.229]                       stop(ex)
[11:01:53.229]                     })
[11:01:53.229]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.229]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.229]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.229]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.229]                       fi <- file.info(pathname)
[11:01:53.229]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.229]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.229]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.229]                         fi[["size"]], fi[["mtime"]])
[11:01:53.229]                       stop(msg)
[11:01:53.229]                     }
[11:01:53.229]                     invisible(pathname)
[11:01:53.229]                   }
[11:01:53.229]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.229]                     rootPath = tempdir()) 
[11:01:53.229]                   {
[11:01:53.229]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.229]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.229]                       tmpdir = path, fileext = ".rds")
[11:01:53.229]                     save_rds(obj, file)
[11:01:53.229]                   }
[11:01:53.229]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.229]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.229]                   {
[11:01:53.229]                     inherits <- base::inherits
[11:01:53.229]                     invokeRestart <- base::invokeRestart
[11:01:53.229]                     is.null <- base::is.null
[11:01:53.229]                     muffled <- FALSE
[11:01:53.229]                     if (inherits(cond, "message")) {
[11:01:53.229]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.229]                       if (muffled) 
[11:01:53.229]                         invokeRestart("muffleMessage")
[11:01:53.229]                     }
[11:01:53.229]                     else if (inherits(cond, "warning")) {
[11:01:53.229]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.229]                       if (muffled) 
[11:01:53.229]                         invokeRestart("muffleWarning")
[11:01:53.229]                     }
[11:01:53.229]                     else if (inherits(cond, "condition")) {
[11:01:53.229]                       if (!is.null(pattern)) {
[11:01:53.229]                         computeRestarts <- base::computeRestarts
[11:01:53.229]                         grepl <- base::grepl
[11:01:53.229]                         restarts <- computeRestarts(cond)
[11:01:53.229]                         for (restart in restarts) {
[11:01:53.229]                           name <- restart$name
[11:01:53.229]                           if (is.null(name)) 
[11:01:53.229]                             next
[11:01:53.229]                           if (!grepl(pattern, name)) 
[11:01:53.229]                             next
[11:01:53.229]                           invokeRestart(restart)
[11:01:53.229]                           muffled <- TRUE
[11:01:53.229]                           break
[11:01:53.229]                         }
[11:01:53.229]                       }
[11:01:53.229]                     }
[11:01:53.229]                     invisible(muffled)
[11:01:53.229]                   }
[11:01:53.229]                   muffleCondition(cond)
[11:01:53.229]                 })
[11:01:53.229]             }))
[11:01:53.229]             future::FutureResult(value = ...future.value$value, 
[11:01:53.229]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.229]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.229]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.229]                     ...future.globalenv.names))
[11:01:53.229]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.229]         }, condition = base::local({
[11:01:53.229]             c <- base::c
[11:01:53.229]             inherits <- base::inherits
[11:01:53.229]             invokeRestart <- base::invokeRestart
[11:01:53.229]             length <- base::length
[11:01:53.229]             list <- base::list
[11:01:53.229]             seq.int <- base::seq.int
[11:01:53.229]             signalCondition <- base::signalCondition
[11:01:53.229]             sys.calls <- base::sys.calls
[11:01:53.229]             `[[` <- base::`[[`
[11:01:53.229]             `+` <- base::`+`
[11:01:53.229]             `<<-` <- base::`<<-`
[11:01:53.229]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.229]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.229]                   3L)]
[11:01:53.229]             }
[11:01:53.229]             function(cond) {
[11:01:53.229]                 is_error <- inherits(cond, "error")
[11:01:53.229]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.229]                   NULL)
[11:01:53.229]                 if (is_error) {
[11:01:53.229]                   sessionInformation <- function() {
[11:01:53.229]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.229]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.229]                       search = base::search(), system = base::Sys.info())
[11:01:53.229]                   }
[11:01:53.229]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.229]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.229]                     cond$call), session = sessionInformation(), 
[11:01:53.229]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.229]                   signalCondition(cond)
[11:01:53.229]                 }
[11:01:53.229]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.229]                 "immediateCondition"))) {
[11:01:53.229]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.229]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.229]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.229]                   if (TRUE && !signal) {
[11:01:53.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.229]                     {
[11:01:53.229]                       inherits <- base::inherits
[11:01:53.229]                       invokeRestart <- base::invokeRestart
[11:01:53.229]                       is.null <- base::is.null
[11:01:53.229]                       muffled <- FALSE
[11:01:53.229]                       if (inherits(cond, "message")) {
[11:01:53.229]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.229]                         if (muffled) 
[11:01:53.229]                           invokeRestart("muffleMessage")
[11:01:53.229]                       }
[11:01:53.229]                       else if (inherits(cond, "warning")) {
[11:01:53.229]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.229]                         if (muffled) 
[11:01:53.229]                           invokeRestart("muffleWarning")
[11:01:53.229]                       }
[11:01:53.229]                       else if (inherits(cond, "condition")) {
[11:01:53.229]                         if (!is.null(pattern)) {
[11:01:53.229]                           computeRestarts <- base::computeRestarts
[11:01:53.229]                           grepl <- base::grepl
[11:01:53.229]                           restarts <- computeRestarts(cond)
[11:01:53.229]                           for (restart in restarts) {
[11:01:53.229]                             name <- restart$name
[11:01:53.229]                             if (is.null(name)) 
[11:01:53.229]                               next
[11:01:53.229]                             if (!grepl(pattern, name)) 
[11:01:53.229]                               next
[11:01:53.229]                             invokeRestart(restart)
[11:01:53.229]                             muffled <- TRUE
[11:01:53.229]                             break
[11:01:53.229]                           }
[11:01:53.229]                         }
[11:01:53.229]                       }
[11:01:53.229]                       invisible(muffled)
[11:01:53.229]                     }
[11:01:53.229]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.229]                   }
[11:01:53.229]                 }
[11:01:53.229]                 else {
[11:01:53.229]                   if (TRUE) {
[11:01:53.229]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.229]                     {
[11:01:53.229]                       inherits <- base::inherits
[11:01:53.229]                       invokeRestart <- base::invokeRestart
[11:01:53.229]                       is.null <- base::is.null
[11:01:53.229]                       muffled <- FALSE
[11:01:53.229]                       if (inherits(cond, "message")) {
[11:01:53.229]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.229]                         if (muffled) 
[11:01:53.229]                           invokeRestart("muffleMessage")
[11:01:53.229]                       }
[11:01:53.229]                       else if (inherits(cond, "warning")) {
[11:01:53.229]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.229]                         if (muffled) 
[11:01:53.229]                           invokeRestart("muffleWarning")
[11:01:53.229]                       }
[11:01:53.229]                       else if (inherits(cond, "condition")) {
[11:01:53.229]                         if (!is.null(pattern)) {
[11:01:53.229]                           computeRestarts <- base::computeRestarts
[11:01:53.229]                           grepl <- base::grepl
[11:01:53.229]                           restarts <- computeRestarts(cond)
[11:01:53.229]                           for (restart in restarts) {
[11:01:53.229]                             name <- restart$name
[11:01:53.229]                             if (is.null(name)) 
[11:01:53.229]                               next
[11:01:53.229]                             if (!grepl(pattern, name)) 
[11:01:53.229]                               next
[11:01:53.229]                             invokeRestart(restart)
[11:01:53.229]                             muffled <- TRUE
[11:01:53.229]                             break
[11:01:53.229]                           }
[11:01:53.229]                         }
[11:01:53.229]                       }
[11:01:53.229]                       invisible(muffled)
[11:01:53.229]                     }
[11:01:53.229]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.229]                   }
[11:01:53.229]                 }
[11:01:53.229]             }
[11:01:53.229]         }))
[11:01:53.229]     }, error = function(ex) {
[11:01:53.229]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.229]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.229]                 ...future.rng), started = ...future.startTime, 
[11:01:53.229]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.229]             version = "1.8"), class = "FutureResult")
[11:01:53.229]     }, finally = {
[11:01:53.229]         if (!identical(...future.workdir, getwd())) 
[11:01:53.229]             setwd(...future.workdir)
[11:01:53.229]         {
[11:01:53.229]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.229]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.229]             }
[11:01:53.229]             base::options(...future.oldOptions)
[11:01:53.229]             if (.Platform$OS.type == "windows") {
[11:01:53.229]                 old_names <- names(...future.oldEnvVars)
[11:01:53.229]                 envs <- base::Sys.getenv()
[11:01:53.229]                 names <- names(envs)
[11:01:53.229]                 common <- intersect(names, old_names)
[11:01:53.229]                 added <- setdiff(names, old_names)
[11:01:53.229]                 removed <- setdiff(old_names, names)
[11:01:53.229]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.229]                   envs[common]]
[11:01:53.229]                 NAMES <- toupper(changed)
[11:01:53.229]                 args <- list()
[11:01:53.229]                 for (kk in seq_along(NAMES)) {
[11:01:53.229]                   name <- changed[[kk]]
[11:01:53.229]                   NAME <- NAMES[[kk]]
[11:01:53.229]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.229]                     next
[11:01:53.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.229]                 }
[11:01:53.229]                 NAMES <- toupper(added)
[11:01:53.229]                 for (kk in seq_along(NAMES)) {
[11:01:53.229]                   name <- added[[kk]]
[11:01:53.229]                   NAME <- NAMES[[kk]]
[11:01:53.229]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.229]                     next
[11:01:53.229]                   args[[name]] <- ""
[11:01:53.229]                 }
[11:01:53.229]                 NAMES <- toupper(removed)
[11:01:53.229]                 for (kk in seq_along(NAMES)) {
[11:01:53.229]                   name <- removed[[kk]]
[11:01:53.229]                   NAME <- NAMES[[kk]]
[11:01:53.229]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.229]                     next
[11:01:53.229]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.229]                 }
[11:01:53.229]                 if (length(args) > 0) 
[11:01:53.229]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.229]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.229]             }
[11:01:53.229]             else {
[11:01:53.229]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.229]             }
[11:01:53.229]             {
[11:01:53.229]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.229]                   0L) {
[11:01:53.229]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.229]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.229]                   base::options(opts)
[11:01:53.229]                 }
[11:01:53.229]                 {
[11:01:53.229]                   {
[11:01:53.229]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.229]                     NULL
[11:01:53.229]                   }
[11:01:53.229]                   options(future.plan = NULL)
[11:01:53.229]                   if (is.na(NA_character_)) 
[11:01:53.229]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.229]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.229]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.229]                     .init = FALSE)
[11:01:53.229]                 }
[11:01:53.229]             }
[11:01:53.229]         }
[11:01:53.229]     })
[11:01:53.229]     if (TRUE) {
[11:01:53.229]         base::sink(type = "output", split = FALSE)
[11:01:53.229]         if (TRUE) {
[11:01:53.229]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.229]         }
[11:01:53.229]         else {
[11:01:53.229]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.229]         }
[11:01:53.229]         base::close(...future.stdout)
[11:01:53.229]         ...future.stdout <- NULL
[11:01:53.229]     }
[11:01:53.229]     ...future.result$conditions <- ...future.conditions
[11:01:53.229]     ...future.result$finished <- base::Sys.time()
[11:01:53.229]     ...future.result
[11:01:53.229] }
[11:01:53.232] requestCore(): workers = 2
[11:01:53.234] MulticoreFuture started
[11:01:53.234] - Launch lazy future ... done
[11:01:53.234] run() for ‘MulticoreFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.234] plan(): Setting new future strategy stack:
[11:01:53.235] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.235] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.235] List of future strategies:
[11:01:53.235] 1. sequential:
[11:01:53.235]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.235]    - tweaked: FALSE
[11:01:53.235]    - call: NULL
[11:01:53.236] plan(): nbrOfWorkers() = 1
[11:01:53.237] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:53.237] Searching for globals ... DONE
[11:01:53.237] Resolving globals: TRUE
[11:01:53.237] Resolving any globals that are futures ...
[11:01:53.237] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:53.238] Resolving any globals that are futures ... DONE
[11:01:53.238] plan(): Setting new future strategy stack:
[11:01:53.238] List of future strategies:
[11:01:53.238] 1. multicore:
[11:01:53.238]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.238]    - tweaked: FALSE
[11:01:53.238]    - call: plan(strategy)
[11:01:53.238] Resolving futures part of globals (recursively) ...
[11:01:53.239] resolve() on list ...
[11:01:53.239]  recursive: 99
[11:01:53.239]  length: 1
[11:01:53.239]  elements: ‘a’
[11:01:53.240] plan(): nbrOfWorkers() = 2
[11:01:53.241] Future #1
[11:01:53.241] result() for MulticoreFuture ...
[11:01:53.247] result() for MulticoreFuture ...
[11:01:53.247] result() for MulticoreFuture ... done
[11:01:53.247] result() for MulticoreFuture ... done
[11:01:53.248] result() for MulticoreFuture ...
[11:01:53.248] result() for MulticoreFuture ... done
[11:01:53.248] A MulticoreFuture was resolved
[11:01:53.249]  length: 0 (resolved future 1)
[11:01:53.249] resolve() on list ... DONE
[11:01:53.249] - globals: [1] ‘a’
[11:01:53.249] Resolving futures part of globals (recursively) ... DONE
[11:01:53.249] The total size of the 1 globals is 3.73 KiB (3815 bytes)
[11:01:53.250] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.73 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.73 KiB of class ‘environment’)
[11:01:53.250] - globals: [1] ‘a’
[11:01:53.250] - packages: [1] ‘future’
[11:01:53.250] getGlobalsAndPackages() ... DONE
[11:01:53.251] run() for ‘Future’ ...
[11:01:53.251] - state: ‘created’
[11:01:53.251] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.253] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.253] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.254]   - Field: ‘label’
[11:01:53.254]   - Field: ‘local’
[11:01:53.254]   - Field: ‘owner’
[11:01:53.254]   - Field: ‘envir’
[11:01:53.254]   - Field: ‘workers’
[11:01:53.254]   - Field: ‘packages’
[11:01:53.254]   - Field: ‘gc’
[11:01:53.254]   - Field: ‘job’
[11:01:53.254]   - Field: ‘conditions’
[11:01:53.255]   - Field: ‘expr’
[11:01:53.255]   - Field: ‘uuid’
[11:01:53.255]   - Field: ‘seed’
[11:01:53.255]   - Field: ‘version’
[11:01:53.255]   - Field: ‘result’
[11:01:53.255]   - Field: ‘asynchronous’
[11:01:53.255]   - Field: ‘calls’
[11:01:53.255]   - Field: ‘globals’
[11:01:53.256]   - Field: ‘stdout’
[11:01:53.256]   - Field: ‘earlySignal’
[11:01:53.256]   - Field: ‘lazy’
[11:01:53.256]   - Field: ‘state’
[11:01:53.256] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.256] - Launch lazy future ...
[11:01:53.256] Packages needed by the future expression (n = 1): ‘future’
[11:01:53.256] Packages needed by future strategies (n = 0): <none>
[11:01:53.257] {
[11:01:53.257]     {
[11:01:53.257]         {
[11:01:53.257]             ...future.startTime <- base::Sys.time()
[11:01:53.257]             {
[11:01:53.257]                 {
[11:01:53.257]                   {
[11:01:53.257]                     {
[11:01:53.257]                       {
[11:01:53.257]                         base::local({
[11:01:53.257]                           has_future <- base::requireNamespace("future", 
[11:01:53.257]                             quietly = TRUE)
[11:01:53.257]                           if (has_future) {
[11:01:53.257]                             ns <- base::getNamespace("future")
[11:01:53.257]                             version <- ns[[".package"]][["version"]]
[11:01:53.257]                             if (is.null(version)) 
[11:01:53.257]                               version <- utils::packageVersion("future")
[11:01:53.257]                           }
[11:01:53.257]                           else {
[11:01:53.257]                             version <- NULL
[11:01:53.257]                           }
[11:01:53.257]                           if (!has_future || version < "1.8.0") {
[11:01:53.257]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.257]                               "", base::R.version$version.string), 
[11:01:53.257]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:53.257]                                 base::R.version$platform, 8 * 
[11:01:53.257]                                   base::.Machine$sizeof.pointer), 
[11:01:53.257]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.257]                                 "release", "version")], collapse = " "), 
[11:01:53.257]                               hostname = base::Sys.info()[["nodename"]])
[11:01:53.257]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.257]                               info)
[11:01:53.257]                             info <- base::paste(info, collapse = "; ")
[11:01:53.257]                             if (!has_future) {
[11:01:53.257]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.257]                                 info)
[11:01:53.257]                             }
[11:01:53.257]                             else {
[11:01:53.257]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.257]                                 info, version)
[11:01:53.257]                             }
[11:01:53.257]                             base::stop(msg)
[11:01:53.257]                           }
[11:01:53.257]                         })
[11:01:53.257]                       }
[11:01:53.257]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.257]                       base::options(mc.cores = 1L)
[11:01:53.257]                     }
[11:01:53.257]                     base::local({
[11:01:53.257]                       for (pkg in "future") {
[11:01:53.257]                         base::loadNamespace(pkg)
[11:01:53.257]                         base::library(pkg, character.only = TRUE)
[11:01:53.257]                       }
[11:01:53.257]                     })
[11:01:53.257]                   }
[11:01:53.257]                   ...future.strategy.old <- future::plan("list")
[11:01:53.257]                   options(future.plan = NULL)
[11:01:53.257]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.257]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.257]                 }
[11:01:53.257]                 ...future.workdir <- getwd()
[11:01:53.257]             }
[11:01:53.257]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.257]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.257]         }
[11:01:53.257]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.257]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.257]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.257]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.257]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.257]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.257]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.257]             base::names(...future.oldOptions))
[11:01:53.257]     }
[11:01:53.257]     if (FALSE) {
[11:01:53.257]     }
[11:01:53.257]     else {
[11:01:53.257]         if (TRUE) {
[11:01:53.257]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.257]                 open = "w")
[11:01:53.257]         }
[11:01:53.257]         else {
[11:01:53.257]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.257]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.257]         }
[11:01:53.257]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.257]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.257]             base::sink(type = "output", split = FALSE)
[11:01:53.257]             base::close(...future.stdout)
[11:01:53.257]         }, add = TRUE)
[11:01:53.257]     }
[11:01:53.257]     ...future.frame <- base::sys.nframe()
[11:01:53.257]     ...future.conditions <- base::list()
[11:01:53.257]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.257]     if (FALSE) {
[11:01:53.257]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.257]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.257]     }
[11:01:53.257]     ...future.result <- base::tryCatch({
[11:01:53.257]         base::withCallingHandlers({
[11:01:53.257]             ...future.value <- base::withVisible(base::local({
[11:01:53.257]                 withCallingHandlers({
[11:01:53.257]                   value(a) + 1
[11:01:53.257]                 }, immediateCondition = function(cond) {
[11:01:53.257]                   save_rds <- function (object, pathname, ...) 
[11:01:53.257]                   {
[11:01:53.257]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.257]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.257]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.257]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.257]                         fi_tmp[["mtime"]])
[11:01:53.257]                     }
[11:01:53.257]                     tryCatch({
[11:01:53.257]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.257]                     }, error = function(ex) {
[11:01:53.257]                       msg <- conditionMessage(ex)
[11:01:53.257]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.257]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.257]                         fi_tmp[["mtime"]], msg)
[11:01:53.257]                       ex$message <- msg
[11:01:53.257]                       stop(ex)
[11:01:53.257]                     })
[11:01:53.257]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.257]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.257]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.257]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.257]                       fi <- file.info(pathname)
[11:01:53.257]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.257]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.257]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.257]                         fi[["size"]], fi[["mtime"]])
[11:01:53.257]                       stop(msg)
[11:01:53.257]                     }
[11:01:53.257]                     invisible(pathname)
[11:01:53.257]                   }
[11:01:53.257]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.257]                     rootPath = tempdir()) 
[11:01:53.257]                   {
[11:01:53.257]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.257]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.257]                       tmpdir = path, fileext = ".rds")
[11:01:53.257]                     save_rds(obj, file)
[11:01:53.257]                   }
[11:01:53.257]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.257]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.257]                   {
[11:01:53.257]                     inherits <- base::inherits
[11:01:53.257]                     invokeRestart <- base::invokeRestart
[11:01:53.257]                     is.null <- base::is.null
[11:01:53.257]                     muffled <- FALSE
[11:01:53.257]                     if (inherits(cond, "message")) {
[11:01:53.257]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.257]                       if (muffled) 
[11:01:53.257]                         invokeRestart("muffleMessage")
[11:01:53.257]                     }
[11:01:53.257]                     else if (inherits(cond, "warning")) {
[11:01:53.257]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.257]                       if (muffled) 
[11:01:53.257]                         invokeRestart("muffleWarning")
[11:01:53.257]                     }
[11:01:53.257]                     else if (inherits(cond, "condition")) {
[11:01:53.257]                       if (!is.null(pattern)) {
[11:01:53.257]                         computeRestarts <- base::computeRestarts
[11:01:53.257]                         grepl <- base::grepl
[11:01:53.257]                         restarts <- computeRestarts(cond)
[11:01:53.257]                         for (restart in restarts) {
[11:01:53.257]                           name <- restart$name
[11:01:53.257]                           if (is.null(name)) 
[11:01:53.257]                             next
[11:01:53.257]                           if (!grepl(pattern, name)) 
[11:01:53.257]                             next
[11:01:53.257]                           invokeRestart(restart)
[11:01:53.257]                           muffled <- TRUE
[11:01:53.257]                           break
[11:01:53.257]                         }
[11:01:53.257]                       }
[11:01:53.257]                     }
[11:01:53.257]                     invisible(muffled)
[11:01:53.257]                   }
[11:01:53.257]                   muffleCondition(cond)
[11:01:53.257]                 })
[11:01:53.257]             }))
[11:01:53.257]             future::FutureResult(value = ...future.value$value, 
[11:01:53.257]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.257]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.257]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.257]                     ...future.globalenv.names))
[11:01:53.257]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.257]         }, condition = base::local({
[11:01:53.257]             c <- base::c
[11:01:53.257]             inherits <- base::inherits
[11:01:53.257]             invokeRestart <- base::invokeRestart
[11:01:53.257]             length <- base::length
[11:01:53.257]             list <- base::list
[11:01:53.257]             seq.int <- base::seq.int
[11:01:53.257]             signalCondition <- base::signalCondition
[11:01:53.257]             sys.calls <- base::sys.calls
[11:01:53.257]             `[[` <- base::`[[`
[11:01:53.257]             `+` <- base::`+`
[11:01:53.257]             `<<-` <- base::`<<-`
[11:01:53.257]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.257]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.257]                   3L)]
[11:01:53.257]             }
[11:01:53.257]             function(cond) {
[11:01:53.257]                 is_error <- inherits(cond, "error")
[11:01:53.257]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.257]                   NULL)
[11:01:53.257]                 if (is_error) {
[11:01:53.257]                   sessionInformation <- function() {
[11:01:53.257]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.257]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.257]                       search = base::search(), system = base::Sys.info())
[11:01:53.257]                   }
[11:01:53.257]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.257]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.257]                     cond$call), session = sessionInformation(), 
[11:01:53.257]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.257]                   signalCondition(cond)
[11:01:53.257]                 }
[11:01:53.257]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.257]                 "immediateCondition"))) {
[11:01:53.257]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.257]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.257]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.257]                   if (TRUE && !signal) {
[11:01:53.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.257]                     {
[11:01:53.257]                       inherits <- base::inherits
[11:01:53.257]                       invokeRestart <- base::invokeRestart
[11:01:53.257]                       is.null <- base::is.null
[11:01:53.257]                       muffled <- FALSE
[11:01:53.257]                       if (inherits(cond, "message")) {
[11:01:53.257]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.257]                         if (muffled) 
[11:01:53.257]                           invokeRestart("muffleMessage")
[11:01:53.257]                       }
[11:01:53.257]                       else if (inherits(cond, "warning")) {
[11:01:53.257]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.257]                         if (muffled) 
[11:01:53.257]                           invokeRestart("muffleWarning")
[11:01:53.257]                       }
[11:01:53.257]                       else if (inherits(cond, "condition")) {
[11:01:53.257]                         if (!is.null(pattern)) {
[11:01:53.257]                           computeRestarts <- base::computeRestarts
[11:01:53.257]                           grepl <- base::grepl
[11:01:53.257]                           restarts <- computeRestarts(cond)
[11:01:53.257]                           for (restart in restarts) {
[11:01:53.257]                             name <- restart$name
[11:01:53.257]                             if (is.null(name)) 
[11:01:53.257]                               next
[11:01:53.257]                             if (!grepl(pattern, name)) 
[11:01:53.257]                               next
[11:01:53.257]                             invokeRestart(restart)
[11:01:53.257]                             muffled <- TRUE
[11:01:53.257]                             break
[11:01:53.257]                           }
[11:01:53.257]                         }
[11:01:53.257]                       }
[11:01:53.257]                       invisible(muffled)
[11:01:53.257]                     }
[11:01:53.257]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.257]                   }
[11:01:53.257]                 }
[11:01:53.257]                 else {
[11:01:53.257]                   if (TRUE) {
[11:01:53.257]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.257]                     {
[11:01:53.257]                       inherits <- base::inherits
[11:01:53.257]                       invokeRestart <- base::invokeRestart
[11:01:53.257]                       is.null <- base::is.null
[11:01:53.257]                       muffled <- FALSE
[11:01:53.257]                       if (inherits(cond, "message")) {
[11:01:53.257]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.257]                         if (muffled) 
[11:01:53.257]                           invokeRestart("muffleMessage")
[11:01:53.257]                       }
[11:01:53.257]                       else if (inherits(cond, "warning")) {
[11:01:53.257]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.257]                         if (muffled) 
[11:01:53.257]                           invokeRestart("muffleWarning")
[11:01:53.257]                       }
[11:01:53.257]                       else if (inherits(cond, "condition")) {
[11:01:53.257]                         if (!is.null(pattern)) {
[11:01:53.257]                           computeRestarts <- base::computeRestarts
[11:01:53.257]                           grepl <- base::grepl
[11:01:53.257]                           restarts <- computeRestarts(cond)
[11:01:53.257]                           for (restart in restarts) {
[11:01:53.257]                             name <- restart$name
[11:01:53.257]                             if (is.null(name)) 
[11:01:53.257]                               next
[11:01:53.257]                             if (!grepl(pattern, name)) 
[11:01:53.257]                               next
[11:01:53.257]                             invokeRestart(restart)
[11:01:53.257]                             muffled <- TRUE
[11:01:53.257]                             break
[11:01:53.257]                           }
[11:01:53.257]                         }
[11:01:53.257]                       }
[11:01:53.257]                       invisible(muffled)
[11:01:53.257]                     }
[11:01:53.257]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.257]                   }
[11:01:53.257]                 }
[11:01:53.257]             }
[11:01:53.257]         }))
[11:01:53.257]     }, error = function(ex) {
[11:01:53.257]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.257]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.257]                 ...future.rng), started = ...future.startTime, 
[11:01:53.257]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.257]             version = "1.8"), class = "FutureResult")
[11:01:53.257]     }, finally = {
[11:01:53.257]         if (!identical(...future.workdir, getwd())) 
[11:01:53.257]             setwd(...future.workdir)
[11:01:53.257]         {
[11:01:53.257]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.257]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.257]             }
[11:01:53.257]             base::options(...future.oldOptions)
[11:01:53.257]             if (.Platform$OS.type == "windows") {
[11:01:53.257]                 old_names <- names(...future.oldEnvVars)
[11:01:53.257]                 envs <- base::Sys.getenv()
[11:01:53.257]                 names <- names(envs)
[11:01:53.257]                 common <- intersect(names, old_names)
[11:01:53.257]                 added <- setdiff(names, old_names)
[11:01:53.257]                 removed <- setdiff(old_names, names)
[11:01:53.257]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.257]                   envs[common]]
[11:01:53.257]                 NAMES <- toupper(changed)
[11:01:53.257]                 args <- list()
[11:01:53.257]                 for (kk in seq_along(NAMES)) {
[11:01:53.257]                   name <- changed[[kk]]
[11:01:53.257]                   NAME <- NAMES[[kk]]
[11:01:53.257]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.257]                     next
[11:01:53.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.257]                 }
[11:01:53.257]                 NAMES <- toupper(added)
[11:01:53.257]                 for (kk in seq_along(NAMES)) {
[11:01:53.257]                   name <- added[[kk]]
[11:01:53.257]                   NAME <- NAMES[[kk]]
[11:01:53.257]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.257]                     next
[11:01:53.257]                   args[[name]] <- ""
[11:01:53.257]                 }
[11:01:53.257]                 NAMES <- toupper(removed)
[11:01:53.257]                 for (kk in seq_along(NAMES)) {
[11:01:53.257]                   name <- removed[[kk]]
[11:01:53.257]                   NAME <- NAMES[[kk]]
[11:01:53.257]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.257]                     next
[11:01:53.257]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.257]                 }
[11:01:53.257]                 if (length(args) > 0) 
[11:01:53.257]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.257]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.257]             }
[11:01:53.257]             else {
[11:01:53.257]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.257]             }
[11:01:53.257]             {
[11:01:53.257]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.257]                   0L) {
[11:01:53.257]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.257]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.257]                   base::options(opts)
[11:01:53.257]                 }
[11:01:53.257]                 {
[11:01:53.257]                   {
[11:01:53.257]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.257]                     NULL
[11:01:53.257]                   }
[11:01:53.257]                   options(future.plan = NULL)
[11:01:53.257]                   if (is.na(NA_character_)) 
[11:01:53.257]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.257]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.257]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.257]                     .init = FALSE)
[11:01:53.257]                 }
[11:01:53.257]             }
[11:01:53.257]         }
[11:01:53.257]     })
[11:01:53.257]     if (TRUE) {
[11:01:53.257]         base::sink(type = "output", split = FALSE)
[11:01:53.257]         if (TRUE) {
[11:01:53.257]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.257]         }
[11:01:53.257]         else {
[11:01:53.257]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.257]         }
[11:01:53.257]         base::close(...future.stdout)
[11:01:53.257]         ...future.stdout <- NULL
[11:01:53.257]     }
[11:01:53.257]     ...future.result$conditions <- ...future.conditions
[11:01:53.257]     ...future.result$finished <- base::Sys.time()
[11:01:53.257]     ...future.result
[11:01:53.257] }
[11:01:53.259] assign_globals() ...
[11:01:53.260] List of 1
[11:01:53.260]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eecdbc2398> 
[11:01:53.260]  - attr(*, "where")=List of 1
[11:01:53.260]   ..$ a:<environment: R_EmptyEnv> 
[11:01:53.260]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.260]  - attr(*, "resolved")= logi TRUE
[11:01:53.260]  - attr(*, "total_size")= num 3815
[11:01:53.260]  - attr(*, "already-done")= logi TRUE
[11:01:53.262] - copied ‘a’ to environment
[11:01:53.263] assign_globals() ... done
[11:01:53.263] requestCore(): workers = 2
[11:01:53.264] MulticoreFuture started
[11:01:53.265] - Launch lazy future ... done
[11:01:53.265] run() for ‘MulticoreFuture’ ... done
[11:01:53.265] result() for MulticoreFuture ...
[11:01:53.265] plan(): Setting new future strategy stack:
[11:01:53.266] List of future strategies:
[11:01:53.266] 1. sequential:
[11:01:53.266]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.266]    - tweaked: FALSE
[11:01:53.266]    - call: NULL
[11:01:53.267] plan(): nbrOfWorkers() = 1
[11:01:53.270] plan(): Setting new future strategy stack:
[11:01:53.270] List of future strategies:
[11:01:53.270] 1. multicore:
[11:01:53.270]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.270]    - tweaked: FALSE
[11:01:53.270]    - call: plan(strategy)
[11:01:53.273] plan(): nbrOfWorkers() = 2
[11:01:53.274] result() for MulticoreFuture ...
[11:01:53.274] result() for MulticoreFuture ... done
[11:01:53.274] signalConditions() ...
[11:01:53.274]  - include = ‘immediateCondition’
[11:01:53.274]  - exclude = 
[11:01:53.274]  - resignal = FALSE
[11:01:53.275]  - Number of conditions: 4
[11:01:53.275] signalConditions() ... done
[11:01:53.275] result() for MulticoreFuture ... done
[11:01:53.275] result() for MulticoreFuture ...
[11:01:53.275] result() for MulticoreFuture ... done
[11:01:53.275] signalConditions() ...
[11:01:53.275]  - include = ‘immediateCondition’
[11:01:53.275]  - exclude = 
[11:01:53.276]  - resignal = FALSE
[11:01:53.276]  - Number of conditions: 4
[11:01:53.276] signalConditions() ... done
[11:01:53.276] Future state: ‘finished’
[11:01:53.276] result() for MulticoreFuture ...
[11:01:53.276] result() for MulticoreFuture ... done
[11:01:53.276] signalConditions() ...
[11:01:53.276]  - include = ‘condition’
[11:01:53.276]  - exclude = ‘immediateCondition’
[11:01:53.277]  - resignal = TRUE
[11:01:53.277]  - Number of conditions: 4
[11:01:53.277]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.268] result() for MulticoreFuture ...
[11:01:53.277]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.268] result() for MulticoreFuture ... done
[11:01:53.277]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.269] result() for MulticoreFuture ...
[11:01:53.277]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.269] result() for MulticoreFuture ... done
[11:01:53.277] signalConditions() ... done
value(b) = 2
[11:01:53.278] result() for MulticoreFuture ...
[11:01:53.278] result() for MulticoreFuture ... done
[11:01:53.278] result() for MulticoreFuture ...
[11:01:53.278] result() for MulticoreFuture ... done
[11:01:53.278] signalConditions() ...
[11:01:53.278]  - include = ‘immediateCondition’
[11:01:53.278]  - exclude = 
[11:01:53.278]  - resignal = FALSE
[11:01:53.278]  - Number of conditions: 4
[11:01:53.279] signalConditions() ... done
[11:01:53.279] Future state: ‘finished’
[11:01:53.279] result() for MulticoreFuture ...
[11:01:53.279] result() for MulticoreFuture ... done
[11:01:53.279] signalConditions() ...
[11:01:53.279]  - include = ‘condition’
[11:01:53.279]  - exclude = ‘immediateCondition’
[11:01:53.279]  - resignal = TRUE
[11:01:53.279]  - Number of conditions: 4
[11:01:53.280]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.268] result() for MulticoreFuture ...
[11:01:53.280]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.268] result() for MulticoreFuture ... done
[11:01:53.280]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.269] result() for MulticoreFuture ...
[11:01:53.280]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.269] result() for MulticoreFuture ... done
[11:01:53.280] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.280] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.281] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.281] 
[11:01:53.281] Searching for globals ... DONE
[11:01:53.281] - globals: [0] <none>
[11:01:53.282] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.282] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.282] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.285] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:53.285] Searching for globals ... DONE
[11:01:53.286] Resolving globals: TRUE
[11:01:53.286] Resolving any globals that are futures ...
[11:01:53.286] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:53.286] Resolving any globals that are futures ... DONE
[11:01:53.287] Resolving futures part of globals (recursively) ...
[11:01:53.287] resolve() on list ...
[11:01:53.287]  recursive: 99
[11:01:53.287]  length: 1
[11:01:53.287]  elements: ‘a’
[11:01:53.288] run() for ‘Future’ ...
[11:01:53.288] - state: ‘created’
[11:01:53.288] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.290] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.290] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.290]   - Field: ‘label’
[11:01:53.290]   - Field: ‘local’
[11:01:53.291]   - Field: ‘owner’
[11:01:53.291]   - Field: ‘envir’
[11:01:53.291]   - Field: ‘workers’
[11:01:53.291]   - Field: ‘packages’
[11:01:53.291]   - Field: ‘gc’
[11:01:53.291]   - Field: ‘job’
[11:01:53.291]   - Field: ‘conditions’
[11:01:53.291]   - Field: ‘expr’
[11:01:53.292]   - Field: ‘uuid’
[11:01:53.292]   - Field: ‘seed’
[11:01:53.292]   - Field: ‘version’
[11:01:53.292]   - Field: ‘result’
[11:01:53.292]   - Field: ‘asynchronous’
[11:01:53.292]   - Field: ‘calls’
[11:01:53.292]   - Field: ‘globals’
[11:01:53.292]   - Field: ‘stdout’
[11:01:53.292]   - Field: ‘earlySignal’
[11:01:53.293]   - Field: ‘lazy’
[11:01:53.293]   - Field: ‘state’
[11:01:53.293] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.293] - Launch lazy future ...
[11:01:53.293] Packages needed by the future expression (n = 0): <none>
[11:01:53.293] Packages needed by future strategies (n = 0): <none>
[11:01:53.294] {
[11:01:53.294]     {
[11:01:53.294]         {
[11:01:53.294]             ...future.startTime <- base::Sys.time()
[11:01:53.294]             {
[11:01:53.294]                 {
[11:01:53.294]                   {
[11:01:53.294]                     {
[11:01:53.294]                       base::local({
[11:01:53.294]                         has_future <- base::requireNamespace("future", 
[11:01:53.294]                           quietly = TRUE)
[11:01:53.294]                         if (has_future) {
[11:01:53.294]                           ns <- base::getNamespace("future")
[11:01:53.294]                           version <- ns[[".package"]][["version"]]
[11:01:53.294]                           if (is.null(version)) 
[11:01:53.294]                             version <- utils::packageVersion("future")
[11:01:53.294]                         }
[11:01:53.294]                         else {
[11:01:53.294]                           version <- NULL
[11:01:53.294]                         }
[11:01:53.294]                         if (!has_future || version < "1.8.0") {
[11:01:53.294]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.294]                             "", base::R.version$version.string), 
[11:01:53.294]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.294]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.294]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.294]                               "release", "version")], collapse = " "), 
[11:01:53.294]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.294]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.294]                             info)
[11:01:53.294]                           info <- base::paste(info, collapse = "; ")
[11:01:53.294]                           if (!has_future) {
[11:01:53.294]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.294]                               info)
[11:01:53.294]                           }
[11:01:53.294]                           else {
[11:01:53.294]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.294]                               info, version)
[11:01:53.294]                           }
[11:01:53.294]                           base::stop(msg)
[11:01:53.294]                         }
[11:01:53.294]                       })
[11:01:53.294]                     }
[11:01:53.294]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.294]                     base::options(mc.cores = 1L)
[11:01:53.294]                   }
[11:01:53.294]                   ...future.strategy.old <- future::plan("list")
[11:01:53.294]                   options(future.plan = NULL)
[11:01:53.294]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.294]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.294]                 }
[11:01:53.294]                 ...future.workdir <- getwd()
[11:01:53.294]             }
[11:01:53.294]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.294]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.294]         }
[11:01:53.294]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.294]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.294]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.294]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.294]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.294]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.294]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.294]             base::names(...future.oldOptions))
[11:01:53.294]     }
[11:01:53.294]     if (FALSE) {
[11:01:53.294]     }
[11:01:53.294]     else {
[11:01:53.294]         if (TRUE) {
[11:01:53.294]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.294]                 open = "w")
[11:01:53.294]         }
[11:01:53.294]         else {
[11:01:53.294]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.294]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.294]         }
[11:01:53.294]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.294]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.294]             base::sink(type = "output", split = FALSE)
[11:01:53.294]             base::close(...future.stdout)
[11:01:53.294]         }, add = TRUE)
[11:01:53.294]     }
[11:01:53.294]     ...future.frame <- base::sys.nframe()
[11:01:53.294]     ...future.conditions <- base::list()
[11:01:53.294]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.294]     if (FALSE) {
[11:01:53.294]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.294]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.294]     }
[11:01:53.294]     ...future.result <- base::tryCatch({
[11:01:53.294]         base::withCallingHandlers({
[11:01:53.294]             ...future.value <- base::withVisible(base::local({
[11:01:53.294]                 withCallingHandlers({
[11:01:53.294]                   1
[11:01:53.294]                 }, immediateCondition = function(cond) {
[11:01:53.294]                   save_rds <- function (object, pathname, ...) 
[11:01:53.294]                   {
[11:01:53.294]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.294]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.294]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.294]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.294]                         fi_tmp[["mtime"]])
[11:01:53.294]                     }
[11:01:53.294]                     tryCatch({
[11:01:53.294]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.294]                     }, error = function(ex) {
[11:01:53.294]                       msg <- conditionMessage(ex)
[11:01:53.294]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.294]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.294]                         fi_tmp[["mtime"]], msg)
[11:01:53.294]                       ex$message <- msg
[11:01:53.294]                       stop(ex)
[11:01:53.294]                     })
[11:01:53.294]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.294]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.294]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.294]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.294]                       fi <- file.info(pathname)
[11:01:53.294]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.294]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.294]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.294]                         fi[["size"]], fi[["mtime"]])
[11:01:53.294]                       stop(msg)
[11:01:53.294]                     }
[11:01:53.294]                     invisible(pathname)
[11:01:53.294]                   }
[11:01:53.294]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.294]                     rootPath = tempdir()) 
[11:01:53.294]                   {
[11:01:53.294]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.294]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.294]                       tmpdir = path, fileext = ".rds")
[11:01:53.294]                     save_rds(obj, file)
[11:01:53.294]                   }
[11:01:53.294]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.294]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.294]                   {
[11:01:53.294]                     inherits <- base::inherits
[11:01:53.294]                     invokeRestart <- base::invokeRestart
[11:01:53.294]                     is.null <- base::is.null
[11:01:53.294]                     muffled <- FALSE
[11:01:53.294]                     if (inherits(cond, "message")) {
[11:01:53.294]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.294]                       if (muffled) 
[11:01:53.294]                         invokeRestart("muffleMessage")
[11:01:53.294]                     }
[11:01:53.294]                     else if (inherits(cond, "warning")) {
[11:01:53.294]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.294]                       if (muffled) 
[11:01:53.294]                         invokeRestart("muffleWarning")
[11:01:53.294]                     }
[11:01:53.294]                     else if (inherits(cond, "condition")) {
[11:01:53.294]                       if (!is.null(pattern)) {
[11:01:53.294]                         computeRestarts <- base::computeRestarts
[11:01:53.294]                         grepl <- base::grepl
[11:01:53.294]                         restarts <- computeRestarts(cond)
[11:01:53.294]                         for (restart in restarts) {
[11:01:53.294]                           name <- restart$name
[11:01:53.294]                           if (is.null(name)) 
[11:01:53.294]                             next
[11:01:53.294]                           if (!grepl(pattern, name)) 
[11:01:53.294]                             next
[11:01:53.294]                           invokeRestart(restart)
[11:01:53.294]                           muffled <- TRUE
[11:01:53.294]                           break
[11:01:53.294]                         }
[11:01:53.294]                       }
[11:01:53.294]                     }
[11:01:53.294]                     invisible(muffled)
[11:01:53.294]                   }
[11:01:53.294]                   muffleCondition(cond)
[11:01:53.294]                 })
[11:01:53.294]             }))
[11:01:53.294]             future::FutureResult(value = ...future.value$value, 
[11:01:53.294]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.294]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.294]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.294]                     ...future.globalenv.names))
[11:01:53.294]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.294]         }, condition = base::local({
[11:01:53.294]             c <- base::c
[11:01:53.294]             inherits <- base::inherits
[11:01:53.294]             invokeRestart <- base::invokeRestart
[11:01:53.294]             length <- base::length
[11:01:53.294]             list <- base::list
[11:01:53.294]             seq.int <- base::seq.int
[11:01:53.294]             signalCondition <- base::signalCondition
[11:01:53.294]             sys.calls <- base::sys.calls
[11:01:53.294]             `[[` <- base::`[[`
[11:01:53.294]             `+` <- base::`+`
[11:01:53.294]             `<<-` <- base::`<<-`
[11:01:53.294]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.294]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.294]                   3L)]
[11:01:53.294]             }
[11:01:53.294]             function(cond) {
[11:01:53.294]                 is_error <- inherits(cond, "error")
[11:01:53.294]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.294]                   NULL)
[11:01:53.294]                 if (is_error) {
[11:01:53.294]                   sessionInformation <- function() {
[11:01:53.294]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.294]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.294]                       search = base::search(), system = base::Sys.info())
[11:01:53.294]                   }
[11:01:53.294]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.294]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.294]                     cond$call), session = sessionInformation(), 
[11:01:53.294]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.294]                   signalCondition(cond)
[11:01:53.294]                 }
[11:01:53.294]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.294]                 "immediateCondition"))) {
[11:01:53.294]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.294]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.294]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.294]                   if (TRUE && !signal) {
[11:01:53.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.294]                     {
[11:01:53.294]                       inherits <- base::inherits
[11:01:53.294]                       invokeRestart <- base::invokeRestart
[11:01:53.294]                       is.null <- base::is.null
[11:01:53.294]                       muffled <- FALSE
[11:01:53.294]                       if (inherits(cond, "message")) {
[11:01:53.294]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.294]                         if (muffled) 
[11:01:53.294]                           invokeRestart("muffleMessage")
[11:01:53.294]                       }
[11:01:53.294]                       else if (inherits(cond, "warning")) {
[11:01:53.294]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.294]                         if (muffled) 
[11:01:53.294]                           invokeRestart("muffleWarning")
[11:01:53.294]                       }
[11:01:53.294]                       else if (inherits(cond, "condition")) {
[11:01:53.294]                         if (!is.null(pattern)) {
[11:01:53.294]                           computeRestarts <- base::computeRestarts
[11:01:53.294]                           grepl <- base::grepl
[11:01:53.294]                           restarts <- computeRestarts(cond)
[11:01:53.294]                           for (restart in restarts) {
[11:01:53.294]                             name <- restart$name
[11:01:53.294]                             if (is.null(name)) 
[11:01:53.294]                               next
[11:01:53.294]                             if (!grepl(pattern, name)) 
[11:01:53.294]                               next
[11:01:53.294]                             invokeRestart(restart)
[11:01:53.294]                             muffled <- TRUE
[11:01:53.294]                             break
[11:01:53.294]                           }
[11:01:53.294]                         }
[11:01:53.294]                       }
[11:01:53.294]                       invisible(muffled)
[11:01:53.294]                     }
[11:01:53.294]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.294]                   }
[11:01:53.294]                 }
[11:01:53.294]                 else {
[11:01:53.294]                   if (TRUE) {
[11:01:53.294]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.294]                     {
[11:01:53.294]                       inherits <- base::inherits
[11:01:53.294]                       invokeRestart <- base::invokeRestart
[11:01:53.294]                       is.null <- base::is.null
[11:01:53.294]                       muffled <- FALSE
[11:01:53.294]                       if (inherits(cond, "message")) {
[11:01:53.294]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.294]                         if (muffled) 
[11:01:53.294]                           invokeRestart("muffleMessage")
[11:01:53.294]                       }
[11:01:53.294]                       else if (inherits(cond, "warning")) {
[11:01:53.294]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.294]                         if (muffled) 
[11:01:53.294]                           invokeRestart("muffleWarning")
[11:01:53.294]                       }
[11:01:53.294]                       else if (inherits(cond, "condition")) {
[11:01:53.294]                         if (!is.null(pattern)) {
[11:01:53.294]                           computeRestarts <- base::computeRestarts
[11:01:53.294]                           grepl <- base::grepl
[11:01:53.294]                           restarts <- computeRestarts(cond)
[11:01:53.294]                           for (restart in restarts) {
[11:01:53.294]                             name <- restart$name
[11:01:53.294]                             if (is.null(name)) 
[11:01:53.294]                               next
[11:01:53.294]                             if (!grepl(pattern, name)) 
[11:01:53.294]                               next
[11:01:53.294]                             invokeRestart(restart)
[11:01:53.294]                             muffled <- TRUE
[11:01:53.294]                             break
[11:01:53.294]                           }
[11:01:53.294]                         }
[11:01:53.294]                       }
[11:01:53.294]                       invisible(muffled)
[11:01:53.294]                     }
[11:01:53.294]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.294]                   }
[11:01:53.294]                 }
[11:01:53.294]             }
[11:01:53.294]         }))
[11:01:53.294]     }, error = function(ex) {
[11:01:53.294]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.294]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.294]                 ...future.rng), started = ...future.startTime, 
[11:01:53.294]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.294]             version = "1.8"), class = "FutureResult")
[11:01:53.294]     }, finally = {
[11:01:53.294]         if (!identical(...future.workdir, getwd())) 
[11:01:53.294]             setwd(...future.workdir)
[11:01:53.294]         {
[11:01:53.294]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.294]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.294]             }
[11:01:53.294]             base::options(...future.oldOptions)
[11:01:53.294]             if (.Platform$OS.type == "windows") {
[11:01:53.294]                 old_names <- names(...future.oldEnvVars)
[11:01:53.294]                 envs <- base::Sys.getenv()
[11:01:53.294]                 names <- names(envs)
[11:01:53.294]                 common <- intersect(names, old_names)
[11:01:53.294]                 added <- setdiff(names, old_names)
[11:01:53.294]                 removed <- setdiff(old_names, names)
[11:01:53.294]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.294]                   envs[common]]
[11:01:53.294]                 NAMES <- toupper(changed)
[11:01:53.294]                 args <- list()
[11:01:53.294]                 for (kk in seq_along(NAMES)) {
[11:01:53.294]                   name <- changed[[kk]]
[11:01:53.294]                   NAME <- NAMES[[kk]]
[11:01:53.294]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.294]                     next
[11:01:53.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.294]                 }
[11:01:53.294]                 NAMES <- toupper(added)
[11:01:53.294]                 for (kk in seq_along(NAMES)) {
[11:01:53.294]                   name <- added[[kk]]
[11:01:53.294]                   NAME <- NAMES[[kk]]
[11:01:53.294]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.294]                     next
[11:01:53.294]                   args[[name]] <- ""
[11:01:53.294]                 }
[11:01:53.294]                 NAMES <- toupper(removed)
[11:01:53.294]                 for (kk in seq_along(NAMES)) {
[11:01:53.294]                   name <- removed[[kk]]
[11:01:53.294]                   NAME <- NAMES[[kk]]
[11:01:53.294]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.294]                     next
[11:01:53.294]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.294]                 }
[11:01:53.294]                 if (length(args) > 0) 
[11:01:53.294]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.294]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.294]             }
[11:01:53.294]             else {
[11:01:53.294]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.294]             }
[11:01:53.294]             {
[11:01:53.294]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.294]                   0L) {
[11:01:53.294]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.294]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.294]                   base::options(opts)
[11:01:53.294]                 }
[11:01:53.294]                 {
[11:01:53.294]                   {
[11:01:53.294]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.294]                     NULL
[11:01:53.294]                   }
[11:01:53.294]                   options(future.plan = NULL)
[11:01:53.294]                   if (is.na(NA_character_)) 
[11:01:53.294]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.294]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.294]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.294]                     .init = FALSE)
[11:01:53.294]                 }
[11:01:53.294]             }
[11:01:53.294]         }
[11:01:53.294]     })
[11:01:53.294]     if (TRUE) {
[11:01:53.294]         base::sink(type = "output", split = FALSE)
[11:01:53.294]         if (TRUE) {
[11:01:53.294]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.294]         }
[11:01:53.294]         else {
[11:01:53.294]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.294]         }
[11:01:53.294]         base::close(...future.stdout)
[11:01:53.294]         ...future.stdout <- NULL
[11:01:53.294]     }
[11:01:53.294]     ...future.result$conditions <- ...future.conditions
[11:01:53.294]     ...future.result$finished <- base::Sys.time()
[11:01:53.294]     ...future.result
[11:01:53.294] }
[11:01:53.296] requestCore(): workers = 2
[11:01:53.298] MulticoreFuture started
[11:01:53.298] - Launch lazy future ... done
[11:01:53.299] run() for ‘MulticoreFuture’ ... done
[11:01:53.299] plan(): Setting new future strategy stack:
[11:01:53.299] List of future strategies:
[11:01:53.299] 1. sequential:
[11:01:53.299]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.299]    - tweaked: FALSE
[11:01:53.299]    - call: NULL
[11:01:53.300] plan(): nbrOfWorkers() = 1
[11:01:53.302] plan(): Setting new future strategy stack:
[11:01:53.303] List of future strategies:
[11:01:53.303] 1. multicore:
[11:01:53.303]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.303]    - tweaked: FALSE
[11:01:53.303]    - call: plan(strategy)
[11:01:53.306] plan(): nbrOfWorkers() = 2
[11:01:53.306] Future #1
[11:01:53.306] result() for MulticoreFuture ...
[11:01:53.307] result() for MulticoreFuture ...
[11:01:53.307] result() for MulticoreFuture ... done
[11:01:53.308] result() for MulticoreFuture ... done
[11:01:53.308] result() for MulticoreFuture ...
[11:01:53.308] result() for MulticoreFuture ... done
[11:01:53.308] A MulticoreFuture was resolved
[11:01:53.308]  length: 0 (resolved future 1)
[11:01:53.308] resolve() on list ... DONE
[11:01:53.309] - globals: [1] ‘a’
[11:01:53.309] Resolving futures part of globals (recursively) ... DONE
[11:01:53.309] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[11:01:53.309] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[11:01:53.310] - globals: [1] ‘a’
[11:01:53.310] - packages: [1] ‘future’
[11:01:53.310] getGlobalsAndPackages() ... DONE
[11:01:53.310] run() for ‘Future’ ...
[11:01:53.310] - state: ‘created’
[11:01:53.311] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.313] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.313] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.313]   - Field: ‘label’
[11:01:53.313]   - Field: ‘local’
[11:01:53.313]   - Field: ‘owner’
[11:01:53.313]   - Field: ‘envir’
[11:01:53.313]   - Field: ‘workers’
[11:01:53.313]   - Field: ‘packages’
[11:01:53.314]   - Field: ‘gc’
[11:01:53.314]   - Field: ‘job’
[11:01:53.314]   - Field: ‘conditions’
[11:01:53.314]   - Field: ‘expr’
[11:01:53.314]   - Field: ‘uuid’
[11:01:53.314]   - Field: ‘seed’
[11:01:53.314]   - Field: ‘version’
[11:01:53.314]   - Field: ‘result’
[11:01:53.314]   - Field: ‘asynchronous’
[11:01:53.315]   - Field: ‘calls’
[11:01:53.315]   - Field: ‘globals’
[11:01:53.315]   - Field: ‘stdout’
[11:01:53.315]   - Field: ‘earlySignal’
[11:01:53.315]   - Field: ‘lazy’
[11:01:53.315]   - Field: ‘state’
[11:01:53.315] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.315] - Launch lazy future ...
[11:01:53.316] Packages needed by the future expression (n = 1): ‘future’
[11:01:53.316] Packages needed by future strategies (n = 0): <none>
[11:01:53.316] {
[11:01:53.316]     {
[11:01:53.316]         {
[11:01:53.316]             ...future.startTime <- base::Sys.time()
[11:01:53.316]             {
[11:01:53.316]                 {
[11:01:53.316]                   {
[11:01:53.316]                     {
[11:01:53.316]                       {
[11:01:53.316]                         base::local({
[11:01:53.316]                           has_future <- base::requireNamespace("future", 
[11:01:53.316]                             quietly = TRUE)
[11:01:53.316]                           if (has_future) {
[11:01:53.316]                             ns <- base::getNamespace("future")
[11:01:53.316]                             version <- ns[[".package"]][["version"]]
[11:01:53.316]                             if (is.null(version)) 
[11:01:53.316]                               version <- utils::packageVersion("future")
[11:01:53.316]                           }
[11:01:53.316]                           else {
[11:01:53.316]                             version <- NULL
[11:01:53.316]                           }
[11:01:53.316]                           if (!has_future || version < "1.8.0") {
[11:01:53.316]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.316]                               "", base::R.version$version.string), 
[11:01:53.316]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:53.316]                                 base::R.version$platform, 8 * 
[11:01:53.316]                                   base::.Machine$sizeof.pointer), 
[11:01:53.316]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.316]                                 "release", "version")], collapse = " "), 
[11:01:53.316]                               hostname = base::Sys.info()[["nodename"]])
[11:01:53.316]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.316]                               info)
[11:01:53.316]                             info <- base::paste(info, collapse = "; ")
[11:01:53.316]                             if (!has_future) {
[11:01:53.316]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.316]                                 info)
[11:01:53.316]                             }
[11:01:53.316]                             else {
[11:01:53.316]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.316]                                 info, version)
[11:01:53.316]                             }
[11:01:53.316]                             base::stop(msg)
[11:01:53.316]                           }
[11:01:53.316]                         })
[11:01:53.316]                       }
[11:01:53.316]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.316]                       base::options(mc.cores = 1L)
[11:01:53.316]                     }
[11:01:53.316]                     base::local({
[11:01:53.316]                       for (pkg in "future") {
[11:01:53.316]                         base::loadNamespace(pkg)
[11:01:53.316]                         base::library(pkg, character.only = TRUE)
[11:01:53.316]                       }
[11:01:53.316]                     })
[11:01:53.316]                   }
[11:01:53.316]                   ...future.strategy.old <- future::plan("list")
[11:01:53.316]                   options(future.plan = NULL)
[11:01:53.316]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.316]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.316]                 }
[11:01:53.316]                 ...future.workdir <- getwd()
[11:01:53.316]             }
[11:01:53.316]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.316]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.316]         }
[11:01:53.316]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.316]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.316]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.316]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.316]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.316]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.316]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.316]             base::names(...future.oldOptions))
[11:01:53.316]     }
[11:01:53.316]     if (FALSE) {
[11:01:53.316]     }
[11:01:53.316]     else {
[11:01:53.316]         if (TRUE) {
[11:01:53.316]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.316]                 open = "w")
[11:01:53.316]         }
[11:01:53.316]         else {
[11:01:53.316]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.316]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.316]         }
[11:01:53.316]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.316]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.316]             base::sink(type = "output", split = FALSE)
[11:01:53.316]             base::close(...future.stdout)
[11:01:53.316]         }, add = TRUE)
[11:01:53.316]     }
[11:01:53.316]     ...future.frame <- base::sys.nframe()
[11:01:53.316]     ...future.conditions <- base::list()
[11:01:53.316]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.316]     if (FALSE) {
[11:01:53.316]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.316]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.316]     }
[11:01:53.316]     ...future.result <- base::tryCatch({
[11:01:53.316]         base::withCallingHandlers({
[11:01:53.316]             ...future.value <- base::withVisible(base::local({
[11:01:53.316]                 withCallingHandlers({
[11:01:53.316]                   value(a) + 1
[11:01:53.316]                 }, immediateCondition = function(cond) {
[11:01:53.316]                   save_rds <- function (object, pathname, ...) 
[11:01:53.316]                   {
[11:01:53.316]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.316]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.316]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.316]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.316]                         fi_tmp[["mtime"]])
[11:01:53.316]                     }
[11:01:53.316]                     tryCatch({
[11:01:53.316]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.316]                     }, error = function(ex) {
[11:01:53.316]                       msg <- conditionMessage(ex)
[11:01:53.316]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.316]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.316]                         fi_tmp[["mtime"]], msg)
[11:01:53.316]                       ex$message <- msg
[11:01:53.316]                       stop(ex)
[11:01:53.316]                     })
[11:01:53.316]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.316]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.316]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.316]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.316]                       fi <- file.info(pathname)
[11:01:53.316]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.316]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.316]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.316]                         fi[["size"]], fi[["mtime"]])
[11:01:53.316]                       stop(msg)
[11:01:53.316]                     }
[11:01:53.316]                     invisible(pathname)
[11:01:53.316]                   }
[11:01:53.316]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.316]                     rootPath = tempdir()) 
[11:01:53.316]                   {
[11:01:53.316]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.316]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.316]                       tmpdir = path, fileext = ".rds")
[11:01:53.316]                     save_rds(obj, file)
[11:01:53.316]                   }
[11:01:53.316]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.316]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.316]                   {
[11:01:53.316]                     inherits <- base::inherits
[11:01:53.316]                     invokeRestart <- base::invokeRestart
[11:01:53.316]                     is.null <- base::is.null
[11:01:53.316]                     muffled <- FALSE
[11:01:53.316]                     if (inherits(cond, "message")) {
[11:01:53.316]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.316]                       if (muffled) 
[11:01:53.316]                         invokeRestart("muffleMessage")
[11:01:53.316]                     }
[11:01:53.316]                     else if (inherits(cond, "warning")) {
[11:01:53.316]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.316]                       if (muffled) 
[11:01:53.316]                         invokeRestart("muffleWarning")
[11:01:53.316]                     }
[11:01:53.316]                     else if (inherits(cond, "condition")) {
[11:01:53.316]                       if (!is.null(pattern)) {
[11:01:53.316]                         computeRestarts <- base::computeRestarts
[11:01:53.316]                         grepl <- base::grepl
[11:01:53.316]                         restarts <- computeRestarts(cond)
[11:01:53.316]                         for (restart in restarts) {
[11:01:53.316]                           name <- restart$name
[11:01:53.316]                           if (is.null(name)) 
[11:01:53.316]                             next
[11:01:53.316]                           if (!grepl(pattern, name)) 
[11:01:53.316]                             next
[11:01:53.316]                           invokeRestart(restart)
[11:01:53.316]                           muffled <- TRUE
[11:01:53.316]                           break
[11:01:53.316]                         }
[11:01:53.316]                       }
[11:01:53.316]                     }
[11:01:53.316]                     invisible(muffled)
[11:01:53.316]                   }
[11:01:53.316]                   muffleCondition(cond)
[11:01:53.316]                 })
[11:01:53.316]             }))
[11:01:53.316]             future::FutureResult(value = ...future.value$value, 
[11:01:53.316]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.316]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.316]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.316]                     ...future.globalenv.names))
[11:01:53.316]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.316]         }, condition = base::local({
[11:01:53.316]             c <- base::c
[11:01:53.316]             inherits <- base::inherits
[11:01:53.316]             invokeRestart <- base::invokeRestart
[11:01:53.316]             length <- base::length
[11:01:53.316]             list <- base::list
[11:01:53.316]             seq.int <- base::seq.int
[11:01:53.316]             signalCondition <- base::signalCondition
[11:01:53.316]             sys.calls <- base::sys.calls
[11:01:53.316]             `[[` <- base::`[[`
[11:01:53.316]             `+` <- base::`+`
[11:01:53.316]             `<<-` <- base::`<<-`
[11:01:53.316]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.316]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.316]                   3L)]
[11:01:53.316]             }
[11:01:53.316]             function(cond) {
[11:01:53.316]                 is_error <- inherits(cond, "error")
[11:01:53.316]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.316]                   NULL)
[11:01:53.316]                 if (is_error) {
[11:01:53.316]                   sessionInformation <- function() {
[11:01:53.316]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.316]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.316]                       search = base::search(), system = base::Sys.info())
[11:01:53.316]                   }
[11:01:53.316]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.316]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.316]                     cond$call), session = sessionInformation(), 
[11:01:53.316]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.316]                   signalCondition(cond)
[11:01:53.316]                 }
[11:01:53.316]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.316]                 "immediateCondition"))) {
[11:01:53.316]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.316]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.316]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.316]                   if (TRUE && !signal) {
[11:01:53.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.316]                     {
[11:01:53.316]                       inherits <- base::inherits
[11:01:53.316]                       invokeRestart <- base::invokeRestart
[11:01:53.316]                       is.null <- base::is.null
[11:01:53.316]                       muffled <- FALSE
[11:01:53.316]                       if (inherits(cond, "message")) {
[11:01:53.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.316]                         if (muffled) 
[11:01:53.316]                           invokeRestart("muffleMessage")
[11:01:53.316]                       }
[11:01:53.316]                       else if (inherits(cond, "warning")) {
[11:01:53.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.316]                         if (muffled) 
[11:01:53.316]                           invokeRestart("muffleWarning")
[11:01:53.316]                       }
[11:01:53.316]                       else if (inherits(cond, "condition")) {
[11:01:53.316]                         if (!is.null(pattern)) {
[11:01:53.316]                           computeRestarts <- base::computeRestarts
[11:01:53.316]                           grepl <- base::grepl
[11:01:53.316]                           restarts <- computeRestarts(cond)
[11:01:53.316]                           for (restart in restarts) {
[11:01:53.316]                             name <- restart$name
[11:01:53.316]                             if (is.null(name)) 
[11:01:53.316]                               next
[11:01:53.316]                             if (!grepl(pattern, name)) 
[11:01:53.316]                               next
[11:01:53.316]                             invokeRestart(restart)
[11:01:53.316]                             muffled <- TRUE
[11:01:53.316]                             break
[11:01:53.316]                           }
[11:01:53.316]                         }
[11:01:53.316]                       }
[11:01:53.316]                       invisible(muffled)
[11:01:53.316]                     }
[11:01:53.316]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.316]                   }
[11:01:53.316]                 }
[11:01:53.316]                 else {
[11:01:53.316]                   if (TRUE) {
[11:01:53.316]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.316]                     {
[11:01:53.316]                       inherits <- base::inherits
[11:01:53.316]                       invokeRestart <- base::invokeRestart
[11:01:53.316]                       is.null <- base::is.null
[11:01:53.316]                       muffled <- FALSE
[11:01:53.316]                       if (inherits(cond, "message")) {
[11:01:53.316]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.316]                         if (muffled) 
[11:01:53.316]                           invokeRestart("muffleMessage")
[11:01:53.316]                       }
[11:01:53.316]                       else if (inherits(cond, "warning")) {
[11:01:53.316]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.316]                         if (muffled) 
[11:01:53.316]                           invokeRestart("muffleWarning")
[11:01:53.316]                       }
[11:01:53.316]                       else if (inherits(cond, "condition")) {
[11:01:53.316]                         if (!is.null(pattern)) {
[11:01:53.316]                           computeRestarts <- base::computeRestarts
[11:01:53.316]                           grepl <- base::grepl
[11:01:53.316]                           restarts <- computeRestarts(cond)
[11:01:53.316]                           for (restart in restarts) {
[11:01:53.316]                             name <- restart$name
[11:01:53.316]                             if (is.null(name)) 
[11:01:53.316]                               next
[11:01:53.316]                             if (!grepl(pattern, name)) 
[11:01:53.316]                               next
[11:01:53.316]                             invokeRestart(restart)
[11:01:53.316]                             muffled <- TRUE
[11:01:53.316]                             break
[11:01:53.316]                           }
[11:01:53.316]                         }
[11:01:53.316]                       }
[11:01:53.316]                       invisible(muffled)
[11:01:53.316]                     }
[11:01:53.316]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.316]                   }
[11:01:53.316]                 }
[11:01:53.316]             }
[11:01:53.316]         }))
[11:01:53.316]     }, error = function(ex) {
[11:01:53.316]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.316]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.316]                 ...future.rng), started = ...future.startTime, 
[11:01:53.316]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.316]             version = "1.8"), class = "FutureResult")
[11:01:53.316]     }, finally = {
[11:01:53.316]         if (!identical(...future.workdir, getwd())) 
[11:01:53.316]             setwd(...future.workdir)
[11:01:53.316]         {
[11:01:53.316]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.316]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.316]             }
[11:01:53.316]             base::options(...future.oldOptions)
[11:01:53.316]             if (.Platform$OS.type == "windows") {
[11:01:53.316]                 old_names <- names(...future.oldEnvVars)
[11:01:53.316]                 envs <- base::Sys.getenv()
[11:01:53.316]                 names <- names(envs)
[11:01:53.316]                 common <- intersect(names, old_names)
[11:01:53.316]                 added <- setdiff(names, old_names)
[11:01:53.316]                 removed <- setdiff(old_names, names)
[11:01:53.316]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.316]                   envs[common]]
[11:01:53.316]                 NAMES <- toupper(changed)
[11:01:53.316]                 args <- list()
[11:01:53.316]                 for (kk in seq_along(NAMES)) {
[11:01:53.316]                   name <- changed[[kk]]
[11:01:53.316]                   NAME <- NAMES[[kk]]
[11:01:53.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.316]                     next
[11:01:53.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.316]                 }
[11:01:53.316]                 NAMES <- toupper(added)
[11:01:53.316]                 for (kk in seq_along(NAMES)) {
[11:01:53.316]                   name <- added[[kk]]
[11:01:53.316]                   NAME <- NAMES[[kk]]
[11:01:53.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.316]                     next
[11:01:53.316]                   args[[name]] <- ""
[11:01:53.316]                 }
[11:01:53.316]                 NAMES <- toupper(removed)
[11:01:53.316]                 for (kk in seq_along(NAMES)) {
[11:01:53.316]                   name <- removed[[kk]]
[11:01:53.316]                   NAME <- NAMES[[kk]]
[11:01:53.316]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.316]                     next
[11:01:53.316]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.316]                 }
[11:01:53.316]                 if (length(args) > 0) 
[11:01:53.316]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.316]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.316]             }
[11:01:53.316]             else {
[11:01:53.316]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.316]             }
[11:01:53.316]             {
[11:01:53.316]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.316]                   0L) {
[11:01:53.316]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.316]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.316]                   base::options(opts)
[11:01:53.316]                 }
[11:01:53.316]                 {
[11:01:53.316]                   {
[11:01:53.316]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.316]                     NULL
[11:01:53.316]                   }
[11:01:53.316]                   options(future.plan = NULL)
[11:01:53.316]                   if (is.na(NA_character_)) 
[11:01:53.316]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.316]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.316]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.316]                     .init = FALSE)
[11:01:53.316]                 }
[11:01:53.316]             }
[11:01:53.316]         }
[11:01:53.316]     })
[11:01:53.316]     if (TRUE) {
[11:01:53.316]         base::sink(type = "output", split = FALSE)
[11:01:53.316]         if (TRUE) {
[11:01:53.316]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.316]         }
[11:01:53.316]         else {
[11:01:53.316]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.316]         }
[11:01:53.316]         base::close(...future.stdout)
[11:01:53.316]         ...future.stdout <- NULL
[11:01:53.316]     }
[11:01:53.316]     ...future.result$conditions <- ...future.conditions
[11:01:53.316]     ...future.result$finished <- base::Sys.time()
[11:01:53.316]     ...future.result
[11:01:53.316] }
[11:01:53.319] assign_globals() ...
[11:01:53.319] List of 1
[11:01:53.319]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eece6c58a0> 
[11:01:53.319]  - attr(*, "where")=List of 1
[11:01:53.319]   ..$ a:<environment: R_EmptyEnv> 
[11:01:53.319]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.319]  - attr(*, "resolved")= logi TRUE
[11:01:53.319]  - attr(*, "total_size")= num 3835
[11:01:53.319]  - attr(*, "already-done")= logi TRUE
[11:01:53.322] - copied ‘a’ to environment
[11:01:53.322] assign_globals() ... done
[11:01:53.322] requestCore(): workers = 2
[11:01:53.324] MulticoreFuture started
[11:01:53.324] - Launch lazy future ... done
[11:01:53.325] run() for ‘MulticoreFuture’ ... done
[11:01:53.325] result() for MulticoreFuture ...
[11:01:53.325] plan(): Setting new future strategy stack:
[11:01:53.325] List of future strategies:
[11:01:53.325] 1. sequential:
[11:01:53.325]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.325]    - tweaked: FALSE
[11:01:53.325]    - call: NULL
[11:01:53.326] plan(): nbrOfWorkers() = 1
[11:01:53.335] plan(): Setting new future strategy stack:
[11:01:53.335] List of future strategies:
[11:01:53.335] 1. multicore:
[11:01:53.335]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.335]    - tweaked: FALSE
[11:01:53.335]    - call: plan(strategy)
[11:01:53.339] plan(): nbrOfWorkers() = 2
[11:01:53.339] result() for MulticoreFuture ...
[11:01:53.339] result() for MulticoreFuture ... done
[11:01:53.340] signalConditions() ...
[11:01:53.340]  - include = ‘immediateCondition’
[11:01:53.340]  - exclude = 
[11:01:53.340]  - resignal = FALSE
[11:01:53.340]  - Number of conditions: 4
[11:01:53.340] signalConditions() ... done
[11:01:53.340] result() for MulticoreFuture ... done
[11:01:53.343] result() for MulticoreFuture ...
[11:01:53.343] result() for MulticoreFuture ... done
[11:01:53.343] signalConditions() ...
[11:01:53.344]  - include = ‘immediateCondition’
[11:01:53.344]  - exclude = 
[11:01:53.344]  - resignal = FALSE
[11:01:53.344]  - Number of conditions: 4
[11:01:53.344] signalConditions() ... done
[11:01:53.345] Future state: ‘finished’
[11:01:53.345] result() for MulticoreFuture ...
[11:01:53.345] result() for MulticoreFuture ... done
[11:01:53.345] signalConditions() ...
[11:01:53.345]  - include = ‘condition’
[11:01:53.345]  - exclude = ‘immediateCondition’
[11:01:53.345]  - resignal = TRUE
[11:01:53.346]  - Number of conditions: 4
[11:01:53.346]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.328] result() for MulticoreFuture ...
[11:01:53.346]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.328] result() for MulticoreFuture ... done
[11:01:53.346]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.328] result() for MulticoreFuture ...
[11:01:53.346]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.333] result() for MulticoreFuture ... done
[11:01:53.347] signalConditions() ... done
value(b) = 2
[11:01:53.347] result() for MulticoreFuture ...
[11:01:53.347] result() for MulticoreFuture ... done
[11:01:53.347] result() for MulticoreFuture ...
[11:01:53.347] result() for MulticoreFuture ... done
[11:01:53.347] signalConditions() ...
[11:01:53.347]  - include = ‘immediateCondition’
[11:01:53.348]  - exclude = 
[11:01:53.348]  - resignal = FALSE
[11:01:53.348]  - Number of conditions: 4
[11:01:53.348] signalConditions() ... done
[11:01:53.348] Future state: ‘finished’
[11:01:53.348] result() for MulticoreFuture ...
[11:01:53.348] result() for MulticoreFuture ... done
[11:01:53.349] signalConditions() ...
[11:01:53.349]  - include = ‘condition’
[11:01:53.349]  - exclude = ‘immediateCondition’
[11:01:53.349]  - resignal = TRUE
[11:01:53.349]  - Number of conditions: 4
[11:01:53.349]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.328] result() for MulticoreFuture ...
[11:01:53.349]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.328] result() for MulticoreFuture ... done
[11:01:53.349]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.328] result() for MulticoreFuture ...
[11:01:53.350]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.333] result() for MulticoreFuture ... done
[11:01:53.350] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.350] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.350] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.351] 
[11:01:53.351] Searching for globals ... DONE
[11:01:53.351] - globals: [0] <none>
[11:01:53.351] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.352] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.352] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.353] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:53.353] Searching for globals ... DONE
[11:01:53.353] Resolving globals: TRUE
[11:01:53.353] Resolving any globals that are futures ...
[11:01:53.353] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:53.353] Resolving any globals that are futures ... DONE
[11:01:53.354] Resolving futures part of globals (recursively) ...
[11:01:53.354] resolve() on list ...
[11:01:53.354]  recursive: 99
[11:01:53.354]  length: 1
[11:01:53.354]  elements: ‘a’
[11:01:53.354] run() for ‘Future’ ...
[11:01:53.354] - state: ‘created’
[11:01:53.355] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.356] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.357] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.357]   - Field: ‘label’
[11:01:53.357]   - Field: ‘local’
[11:01:53.357]   - Field: ‘owner’
[11:01:53.357]   - Field: ‘envir’
[11:01:53.357]   - Field: ‘workers’
[11:01:53.357]   - Field: ‘packages’
[11:01:53.357]   - Field: ‘gc’
[11:01:53.357]   - Field: ‘job’
[11:01:53.358]   - Field: ‘conditions’
[11:01:53.358]   - Field: ‘expr’
[11:01:53.358]   - Field: ‘uuid’
[11:01:53.358]   - Field: ‘seed’
[11:01:53.358]   - Field: ‘version’
[11:01:53.358]   - Field: ‘result’
[11:01:53.358]   - Field: ‘asynchronous’
[11:01:53.358]   - Field: ‘calls’
[11:01:53.358]   - Field: ‘globals’
[11:01:53.358]   - Field: ‘stdout’
[11:01:53.358]   - Field: ‘earlySignal’
[11:01:53.359]   - Field: ‘lazy’
[11:01:53.359]   - Field: ‘state’
[11:01:53.359] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.359] - Launch lazy future ...
[11:01:53.359] Packages needed by the future expression (n = 0): <none>
[11:01:53.359] Packages needed by future strategies (n = 0): <none>
[11:01:53.360] {
[11:01:53.360]     {
[11:01:53.360]         {
[11:01:53.360]             ...future.startTime <- base::Sys.time()
[11:01:53.360]             {
[11:01:53.360]                 {
[11:01:53.360]                   {
[11:01:53.360]                     {
[11:01:53.360]                       base::local({
[11:01:53.360]                         has_future <- base::requireNamespace("future", 
[11:01:53.360]                           quietly = TRUE)
[11:01:53.360]                         if (has_future) {
[11:01:53.360]                           ns <- base::getNamespace("future")
[11:01:53.360]                           version <- ns[[".package"]][["version"]]
[11:01:53.360]                           if (is.null(version)) 
[11:01:53.360]                             version <- utils::packageVersion("future")
[11:01:53.360]                         }
[11:01:53.360]                         else {
[11:01:53.360]                           version <- NULL
[11:01:53.360]                         }
[11:01:53.360]                         if (!has_future || version < "1.8.0") {
[11:01:53.360]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.360]                             "", base::R.version$version.string), 
[11:01:53.360]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.360]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.360]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.360]                               "release", "version")], collapse = " "), 
[11:01:53.360]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.360]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.360]                             info)
[11:01:53.360]                           info <- base::paste(info, collapse = "; ")
[11:01:53.360]                           if (!has_future) {
[11:01:53.360]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.360]                               info)
[11:01:53.360]                           }
[11:01:53.360]                           else {
[11:01:53.360]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.360]                               info, version)
[11:01:53.360]                           }
[11:01:53.360]                           base::stop(msg)
[11:01:53.360]                         }
[11:01:53.360]                       })
[11:01:53.360]                     }
[11:01:53.360]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.360]                     base::options(mc.cores = 1L)
[11:01:53.360]                   }
[11:01:53.360]                   ...future.strategy.old <- future::plan("list")
[11:01:53.360]                   options(future.plan = NULL)
[11:01:53.360]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.360]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.360]                 }
[11:01:53.360]                 ...future.workdir <- getwd()
[11:01:53.360]             }
[11:01:53.360]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.360]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.360]         }
[11:01:53.360]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.360]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.360]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.360]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.360]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.360]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.360]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.360]             base::names(...future.oldOptions))
[11:01:53.360]     }
[11:01:53.360]     if (FALSE) {
[11:01:53.360]     }
[11:01:53.360]     else {
[11:01:53.360]         if (TRUE) {
[11:01:53.360]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.360]                 open = "w")
[11:01:53.360]         }
[11:01:53.360]         else {
[11:01:53.360]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.360]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.360]         }
[11:01:53.360]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.360]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.360]             base::sink(type = "output", split = FALSE)
[11:01:53.360]             base::close(...future.stdout)
[11:01:53.360]         }, add = TRUE)
[11:01:53.360]     }
[11:01:53.360]     ...future.frame <- base::sys.nframe()
[11:01:53.360]     ...future.conditions <- base::list()
[11:01:53.360]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.360]     if (FALSE) {
[11:01:53.360]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.360]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.360]     }
[11:01:53.360]     ...future.result <- base::tryCatch({
[11:01:53.360]         base::withCallingHandlers({
[11:01:53.360]             ...future.value <- base::withVisible(base::local({
[11:01:53.360]                 withCallingHandlers({
[11:01:53.360]                   1
[11:01:53.360]                 }, immediateCondition = function(cond) {
[11:01:53.360]                   save_rds <- function (object, pathname, ...) 
[11:01:53.360]                   {
[11:01:53.360]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.360]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.360]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.360]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.360]                         fi_tmp[["mtime"]])
[11:01:53.360]                     }
[11:01:53.360]                     tryCatch({
[11:01:53.360]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.360]                     }, error = function(ex) {
[11:01:53.360]                       msg <- conditionMessage(ex)
[11:01:53.360]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.360]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.360]                         fi_tmp[["mtime"]], msg)
[11:01:53.360]                       ex$message <- msg
[11:01:53.360]                       stop(ex)
[11:01:53.360]                     })
[11:01:53.360]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.360]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.360]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.360]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.360]                       fi <- file.info(pathname)
[11:01:53.360]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.360]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.360]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.360]                         fi[["size"]], fi[["mtime"]])
[11:01:53.360]                       stop(msg)
[11:01:53.360]                     }
[11:01:53.360]                     invisible(pathname)
[11:01:53.360]                   }
[11:01:53.360]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.360]                     rootPath = tempdir()) 
[11:01:53.360]                   {
[11:01:53.360]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.360]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.360]                       tmpdir = path, fileext = ".rds")
[11:01:53.360]                     save_rds(obj, file)
[11:01:53.360]                   }
[11:01:53.360]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.360]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.360]                   {
[11:01:53.360]                     inherits <- base::inherits
[11:01:53.360]                     invokeRestart <- base::invokeRestart
[11:01:53.360]                     is.null <- base::is.null
[11:01:53.360]                     muffled <- FALSE
[11:01:53.360]                     if (inherits(cond, "message")) {
[11:01:53.360]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.360]                       if (muffled) 
[11:01:53.360]                         invokeRestart("muffleMessage")
[11:01:53.360]                     }
[11:01:53.360]                     else if (inherits(cond, "warning")) {
[11:01:53.360]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.360]                       if (muffled) 
[11:01:53.360]                         invokeRestart("muffleWarning")
[11:01:53.360]                     }
[11:01:53.360]                     else if (inherits(cond, "condition")) {
[11:01:53.360]                       if (!is.null(pattern)) {
[11:01:53.360]                         computeRestarts <- base::computeRestarts
[11:01:53.360]                         grepl <- base::grepl
[11:01:53.360]                         restarts <- computeRestarts(cond)
[11:01:53.360]                         for (restart in restarts) {
[11:01:53.360]                           name <- restart$name
[11:01:53.360]                           if (is.null(name)) 
[11:01:53.360]                             next
[11:01:53.360]                           if (!grepl(pattern, name)) 
[11:01:53.360]                             next
[11:01:53.360]                           invokeRestart(restart)
[11:01:53.360]                           muffled <- TRUE
[11:01:53.360]                           break
[11:01:53.360]                         }
[11:01:53.360]                       }
[11:01:53.360]                     }
[11:01:53.360]                     invisible(muffled)
[11:01:53.360]                   }
[11:01:53.360]                   muffleCondition(cond)
[11:01:53.360]                 })
[11:01:53.360]             }))
[11:01:53.360]             future::FutureResult(value = ...future.value$value, 
[11:01:53.360]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.360]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.360]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.360]                     ...future.globalenv.names))
[11:01:53.360]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.360]         }, condition = base::local({
[11:01:53.360]             c <- base::c
[11:01:53.360]             inherits <- base::inherits
[11:01:53.360]             invokeRestart <- base::invokeRestart
[11:01:53.360]             length <- base::length
[11:01:53.360]             list <- base::list
[11:01:53.360]             seq.int <- base::seq.int
[11:01:53.360]             signalCondition <- base::signalCondition
[11:01:53.360]             sys.calls <- base::sys.calls
[11:01:53.360]             `[[` <- base::`[[`
[11:01:53.360]             `+` <- base::`+`
[11:01:53.360]             `<<-` <- base::`<<-`
[11:01:53.360]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.360]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.360]                   3L)]
[11:01:53.360]             }
[11:01:53.360]             function(cond) {
[11:01:53.360]                 is_error <- inherits(cond, "error")
[11:01:53.360]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.360]                   NULL)
[11:01:53.360]                 if (is_error) {
[11:01:53.360]                   sessionInformation <- function() {
[11:01:53.360]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.360]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.360]                       search = base::search(), system = base::Sys.info())
[11:01:53.360]                   }
[11:01:53.360]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.360]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.360]                     cond$call), session = sessionInformation(), 
[11:01:53.360]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.360]                   signalCondition(cond)
[11:01:53.360]                 }
[11:01:53.360]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.360]                 "immediateCondition"))) {
[11:01:53.360]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.360]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.360]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.360]                   if (TRUE && !signal) {
[11:01:53.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.360]                     {
[11:01:53.360]                       inherits <- base::inherits
[11:01:53.360]                       invokeRestart <- base::invokeRestart
[11:01:53.360]                       is.null <- base::is.null
[11:01:53.360]                       muffled <- FALSE
[11:01:53.360]                       if (inherits(cond, "message")) {
[11:01:53.360]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.360]                         if (muffled) 
[11:01:53.360]                           invokeRestart("muffleMessage")
[11:01:53.360]                       }
[11:01:53.360]                       else if (inherits(cond, "warning")) {
[11:01:53.360]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.360]                         if (muffled) 
[11:01:53.360]                           invokeRestart("muffleWarning")
[11:01:53.360]                       }
[11:01:53.360]                       else if (inherits(cond, "condition")) {
[11:01:53.360]                         if (!is.null(pattern)) {
[11:01:53.360]                           computeRestarts <- base::computeRestarts
[11:01:53.360]                           grepl <- base::grepl
[11:01:53.360]                           restarts <- computeRestarts(cond)
[11:01:53.360]                           for (restart in restarts) {
[11:01:53.360]                             name <- restart$name
[11:01:53.360]                             if (is.null(name)) 
[11:01:53.360]                               next
[11:01:53.360]                             if (!grepl(pattern, name)) 
[11:01:53.360]                               next
[11:01:53.360]                             invokeRestart(restart)
[11:01:53.360]                             muffled <- TRUE
[11:01:53.360]                             break
[11:01:53.360]                           }
[11:01:53.360]                         }
[11:01:53.360]                       }
[11:01:53.360]                       invisible(muffled)
[11:01:53.360]                     }
[11:01:53.360]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.360]                   }
[11:01:53.360]                 }
[11:01:53.360]                 else {
[11:01:53.360]                   if (TRUE) {
[11:01:53.360]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.360]                     {
[11:01:53.360]                       inherits <- base::inherits
[11:01:53.360]                       invokeRestart <- base::invokeRestart
[11:01:53.360]                       is.null <- base::is.null
[11:01:53.360]                       muffled <- FALSE
[11:01:53.360]                       if (inherits(cond, "message")) {
[11:01:53.360]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.360]                         if (muffled) 
[11:01:53.360]                           invokeRestart("muffleMessage")
[11:01:53.360]                       }
[11:01:53.360]                       else if (inherits(cond, "warning")) {
[11:01:53.360]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.360]                         if (muffled) 
[11:01:53.360]                           invokeRestart("muffleWarning")
[11:01:53.360]                       }
[11:01:53.360]                       else if (inherits(cond, "condition")) {
[11:01:53.360]                         if (!is.null(pattern)) {
[11:01:53.360]                           computeRestarts <- base::computeRestarts
[11:01:53.360]                           grepl <- base::grepl
[11:01:53.360]                           restarts <- computeRestarts(cond)
[11:01:53.360]                           for (restart in restarts) {
[11:01:53.360]                             name <- restart$name
[11:01:53.360]                             if (is.null(name)) 
[11:01:53.360]                               next
[11:01:53.360]                             if (!grepl(pattern, name)) 
[11:01:53.360]                               next
[11:01:53.360]                             invokeRestart(restart)
[11:01:53.360]                             muffled <- TRUE
[11:01:53.360]                             break
[11:01:53.360]                           }
[11:01:53.360]                         }
[11:01:53.360]                       }
[11:01:53.360]                       invisible(muffled)
[11:01:53.360]                     }
[11:01:53.360]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.360]                   }
[11:01:53.360]                 }
[11:01:53.360]             }
[11:01:53.360]         }))
[11:01:53.360]     }, error = function(ex) {
[11:01:53.360]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.360]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.360]                 ...future.rng), started = ...future.startTime, 
[11:01:53.360]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.360]             version = "1.8"), class = "FutureResult")
[11:01:53.360]     }, finally = {
[11:01:53.360]         if (!identical(...future.workdir, getwd())) 
[11:01:53.360]             setwd(...future.workdir)
[11:01:53.360]         {
[11:01:53.360]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.360]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.360]             }
[11:01:53.360]             base::options(...future.oldOptions)
[11:01:53.360]             if (.Platform$OS.type == "windows") {
[11:01:53.360]                 old_names <- names(...future.oldEnvVars)
[11:01:53.360]                 envs <- base::Sys.getenv()
[11:01:53.360]                 names <- names(envs)
[11:01:53.360]                 common <- intersect(names, old_names)
[11:01:53.360]                 added <- setdiff(names, old_names)
[11:01:53.360]                 removed <- setdiff(old_names, names)
[11:01:53.360]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.360]                   envs[common]]
[11:01:53.360]                 NAMES <- toupper(changed)
[11:01:53.360]                 args <- list()
[11:01:53.360]                 for (kk in seq_along(NAMES)) {
[11:01:53.360]                   name <- changed[[kk]]
[11:01:53.360]                   NAME <- NAMES[[kk]]
[11:01:53.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.360]                     next
[11:01:53.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.360]                 }
[11:01:53.360]                 NAMES <- toupper(added)
[11:01:53.360]                 for (kk in seq_along(NAMES)) {
[11:01:53.360]                   name <- added[[kk]]
[11:01:53.360]                   NAME <- NAMES[[kk]]
[11:01:53.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.360]                     next
[11:01:53.360]                   args[[name]] <- ""
[11:01:53.360]                 }
[11:01:53.360]                 NAMES <- toupper(removed)
[11:01:53.360]                 for (kk in seq_along(NAMES)) {
[11:01:53.360]                   name <- removed[[kk]]
[11:01:53.360]                   NAME <- NAMES[[kk]]
[11:01:53.360]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.360]                     next
[11:01:53.360]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.360]                 }
[11:01:53.360]                 if (length(args) > 0) 
[11:01:53.360]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.360]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.360]             }
[11:01:53.360]             else {
[11:01:53.360]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.360]             }
[11:01:53.360]             {
[11:01:53.360]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.360]                   0L) {
[11:01:53.360]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.360]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.360]                   base::options(opts)
[11:01:53.360]                 }
[11:01:53.360]                 {
[11:01:53.360]                   {
[11:01:53.360]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.360]                     NULL
[11:01:53.360]                   }
[11:01:53.360]                   options(future.plan = NULL)
[11:01:53.360]                   if (is.na(NA_character_)) 
[11:01:53.360]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.360]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.360]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.360]                     .init = FALSE)
[11:01:53.360]                 }
[11:01:53.360]             }
[11:01:53.360]         }
[11:01:53.360]     })
[11:01:53.360]     if (TRUE) {
[11:01:53.360]         base::sink(type = "output", split = FALSE)
[11:01:53.360]         if (TRUE) {
[11:01:53.360]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.360]         }
[11:01:53.360]         else {
[11:01:53.360]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.360]         }
[11:01:53.360]         base::close(...future.stdout)
[11:01:53.360]         ...future.stdout <- NULL
[11:01:53.360]     }
[11:01:53.360]     ...future.result$conditions <- ...future.conditions
[11:01:53.360]     ...future.result$finished <- base::Sys.time()
[11:01:53.360]     ...future.result
[11:01:53.360] }
[11:01:53.362] requestCore(): workers = 2
[11:01:53.364] MulticoreFuture started
[11:01:53.364] - Launch lazy future ... done
[11:01:53.364] run() for ‘MulticoreFuture’ ... done
[11:01:53.365] plan(): Setting new future strategy stack:
[11:01:53.365] List of future strategies:
[11:01:53.365] 1. sequential:
[11:01:53.365]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.365]    - tweaked: FALSE
[11:01:53.365]    - call: NULL
[11:01:53.366] plan(): nbrOfWorkers() = 1
[11:01:53.368] plan(): Setting new future strategy stack:
[11:01:53.368] List of future strategies:
[11:01:53.368] 1. multicore:
[11:01:53.368]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.368]    - tweaked: FALSE
[11:01:53.368]    - call: plan(strategy)
[11:01:53.371] plan(): nbrOfWorkers() = 2
[11:01:53.372] Future #1
[11:01:53.372] result() for MulticoreFuture ...
[11:01:53.373] result() for MulticoreFuture ...
[11:01:53.373] result() for MulticoreFuture ... done
[11:01:53.373] result() for MulticoreFuture ... done
[11:01:53.373] result() for MulticoreFuture ...
[11:01:53.373] result() for MulticoreFuture ... done
[11:01:53.373] A MulticoreFuture was resolved
[11:01:53.374]  length: 0 (resolved future 1)
[11:01:53.374] resolve() on list ... DONE
[11:01:53.374] - globals: [1] ‘a’
[11:01:53.374] Resolving futures part of globals (recursively) ... DONE
[11:01:53.374] The total size of the 1 globals is 3.75 KiB (3835 bytes)
[11:01:53.375] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 3.75 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.75 KiB of class ‘environment’)
[11:01:53.375] - globals: [1] ‘a’
[11:01:53.375] - packages: [1] ‘future’
[11:01:53.375] getGlobalsAndPackages() ... DONE
[11:01:53.375] run() for ‘Future’ ...
[11:01:53.376] - state: ‘created’
[11:01:53.376] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.378] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.378] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.378]   - Field: ‘label’
[11:01:53.378]   - Field: ‘local’
[11:01:53.378]   - Field: ‘owner’
[11:01:53.379]   - Field: ‘envir’
[11:01:53.379]   - Field: ‘workers’
[11:01:53.379]   - Field: ‘packages’
[11:01:53.381]   - Field: ‘gc’
[11:01:53.381]   - Field: ‘job’
[11:01:53.381]   - Field: ‘conditions’
[11:01:53.381]   - Field: ‘expr’
[11:01:53.381]   - Field: ‘uuid’
[11:01:53.382]   - Field: ‘seed’
[11:01:53.382]   - Field: ‘version’
[11:01:53.382]   - Field: ‘result’
[11:01:53.382]   - Field: ‘asynchronous’
[11:01:53.382]   - Field: ‘calls’
[11:01:53.383]   - Field: ‘globals’
[11:01:53.383]   - Field: ‘stdout’
[11:01:53.383]   - Field: ‘earlySignal’
[11:01:53.383]   - Field: ‘lazy’
[11:01:53.383]   - Field: ‘state’
[11:01:53.383] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.383] - Launch lazy future ...
[11:01:53.384] Packages needed by the future expression (n = 1): ‘future’
[11:01:53.384] Packages needed by future strategies (n = 0): <none>
[11:01:53.385] {
[11:01:53.385]     {
[11:01:53.385]         {
[11:01:53.385]             ...future.startTime <- base::Sys.time()
[11:01:53.385]             {
[11:01:53.385]                 {
[11:01:53.385]                   {
[11:01:53.385]                     {
[11:01:53.385]                       {
[11:01:53.385]                         base::local({
[11:01:53.385]                           has_future <- base::requireNamespace("future", 
[11:01:53.385]                             quietly = TRUE)
[11:01:53.385]                           if (has_future) {
[11:01:53.385]                             ns <- base::getNamespace("future")
[11:01:53.385]                             version <- ns[[".package"]][["version"]]
[11:01:53.385]                             if (is.null(version)) 
[11:01:53.385]                               version <- utils::packageVersion("future")
[11:01:53.385]                           }
[11:01:53.385]                           else {
[11:01:53.385]                             version <- NULL
[11:01:53.385]                           }
[11:01:53.385]                           if (!has_future || version < "1.8.0") {
[11:01:53.385]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.385]                               "", base::R.version$version.string), 
[11:01:53.385]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:53.385]                                 base::R.version$platform, 8 * 
[11:01:53.385]                                   base::.Machine$sizeof.pointer), 
[11:01:53.385]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.385]                                 "release", "version")], collapse = " "), 
[11:01:53.385]                               hostname = base::Sys.info()[["nodename"]])
[11:01:53.385]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.385]                               info)
[11:01:53.385]                             info <- base::paste(info, collapse = "; ")
[11:01:53.385]                             if (!has_future) {
[11:01:53.385]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.385]                                 info)
[11:01:53.385]                             }
[11:01:53.385]                             else {
[11:01:53.385]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.385]                                 info, version)
[11:01:53.385]                             }
[11:01:53.385]                             base::stop(msg)
[11:01:53.385]                           }
[11:01:53.385]                         })
[11:01:53.385]                       }
[11:01:53.385]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.385]                       base::options(mc.cores = 1L)
[11:01:53.385]                     }
[11:01:53.385]                     base::local({
[11:01:53.385]                       for (pkg in "future") {
[11:01:53.385]                         base::loadNamespace(pkg)
[11:01:53.385]                         base::library(pkg, character.only = TRUE)
[11:01:53.385]                       }
[11:01:53.385]                     })
[11:01:53.385]                   }
[11:01:53.385]                   ...future.strategy.old <- future::plan("list")
[11:01:53.385]                   options(future.plan = NULL)
[11:01:53.385]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.385]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.385]                 }
[11:01:53.385]                 ...future.workdir <- getwd()
[11:01:53.385]             }
[11:01:53.385]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.385]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.385]         }
[11:01:53.385]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.385]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.385]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.385]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.385]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.385]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.385]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.385]             base::names(...future.oldOptions))
[11:01:53.385]     }
[11:01:53.385]     if (FALSE) {
[11:01:53.385]     }
[11:01:53.385]     else {
[11:01:53.385]         if (TRUE) {
[11:01:53.385]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.385]                 open = "w")
[11:01:53.385]         }
[11:01:53.385]         else {
[11:01:53.385]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.385]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.385]         }
[11:01:53.385]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.385]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.385]             base::sink(type = "output", split = FALSE)
[11:01:53.385]             base::close(...future.stdout)
[11:01:53.385]         }, add = TRUE)
[11:01:53.385]     }
[11:01:53.385]     ...future.frame <- base::sys.nframe()
[11:01:53.385]     ...future.conditions <- base::list()
[11:01:53.385]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.385]     if (FALSE) {
[11:01:53.385]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.385]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.385]     }
[11:01:53.385]     ...future.result <- base::tryCatch({
[11:01:53.385]         base::withCallingHandlers({
[11:01:53.385]             ...future.value <- base::withVisible(base::local({
[11:01:53.385]                 withCallingHandlers({
[11:01:53.385]                   value(a) + 1
[11:01:53.385]                 }, immediateCondition = function(cond) {
[11:01:53.385]                   save_rds <- function (object, pathname, ...) 
[11:01:53.385]                   {
[11:01:53.385]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.385]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.385]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.385]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.385]                         fi_tmp[["mtime"]])
[11:01:53.385]                     }
[11:01:53.385]                     tryCatch({
[11:01:53.385]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.385]                     }, error = function(ex) {
[11:01:53.385]                       msg <- conditionMessage(ex)
[11:01:53.385]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.385]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.385]                         fi_tmp[["mtime"]], msg)
[11:01:53.385]                       ex$message <- msg
[11:01:53.385]                       stop(ex)
[11:01:53.385]                     })
[11:01:53.385]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.385]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.385]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.385]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.385]                       fi <- file.info(pathname)
[11:01:53.385]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.385]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.385]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.385]                         fi[["size"]], fi[["mtime"]])
[11:01:53.385]                       stop(msg)
[11:01:53.385]                     }
[11:01:53.385]                     invisible(pathname)
[11:01:53.385]                   }
[11:01:53.385]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.385]                     rootPath = tempdir()) 
[11:01:53.385]                   {
[11:01:53.385]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.385]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.385]                       tmpdir = path, fileext = ".rds")
[11:01:53.385]                     save_rds(obj, file)
[11:01:53.385]                   }
[11:01:53.385]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.385]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.385]                   {
[11:01:53.385]                     inherits <- base::inherits
[11:01:53.385]                     invokeRestart <- base::invokeRestart
[11:01:53.385]                     is.null <- base::is.null
[11:01:53.385]                     muffled <- FALSE
[11:01:53.385]                     if (inherits(cond, "message")) {
[11:01:53.385]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.385]                       if (muffled) 
[11:01:53.385]                         invokeRestart("muffleMessage")
[11:01:53.385]                     }
[11:01:53.385]                     else if (inherits(cond, "warning")) {
[11:01:53.385]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.385]                       if (muffled) 
[11:01:53.385]                         invokeRestart("muffleWarning")
[11:01:53.385]                     }
[11:01:53.385]                     else if (inherits(cond, "condition")) {
[11:01:53.385]                       if (!is.null(pattern)) {
[11:01:53.385]                         computeRestarts <- base::computeRestarts
[11:01:53.385]                         grepl <- base::grepl
[11:01:53.385]                         restarts <- computeRestarts(cond)
[11:01:53.385]                         for (restart in restarts) {
[11:01:53.385]                           name <- restart$name
[11:01:53.385]                           if (is.null(name)) 
[11:01:53.385]                             next
[11:01:53.385]                           if (!grepl(pattern, name)) 
[11:01:53.385]                             next
[11:01:53.385]                           invokeRestart(restart)
[11:01:53.385]                           muffled <- TRUE
[11:01:53.385]                           break
[11:01:53.385]                         }
[11:01:53.385]                       }
[11:01:53.385]                     }
[11:01:53.385]                     invisible(muffled)
[11:01:53.385]                   }
[11:01:53.385]                   muffleCondition(cond)
[11:01:53.385]                 })
[11:01:53.385]             }))
[11:01:53.385]             future::FutureResult(value = ...future.value$value, 
[11:01:53.385]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.385]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.385]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.385]                     ...future.globalenv.names))
[11:01:53.385]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.385]         }, condition = base::local({
[11:01:53.385]             c <- base::c
[11:01:53.385]             inherits <- base::inherits
[11:01:53.385]             invokeRestart <- base::invokeRestart
[11:01:53.385]             length <- base::length
[11:01:53.385]             list <- base::list
[11:01:53.385]             seq.int <- base::seq.int
[11:01:53.385]             signalCondition <- base::signalCondition
[11:01:53.385]             sys.calls <- base::sys.calls
[11:01:53.385]             `[[` <- base::`[[`
[11:01:53.385]             `+` <- base::`+`
[11:01:53.385]             `<<-` <- base::`<<-`
[11:01:53.385]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.385]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.385]                   3L)]
[11:01:53.385]             }
[11:01:53.385]             function(cond) {
[11:01:53.385]                 is_error <- inherits(cond, "error")
[11:01:53.385]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.385]                   NULL)
[11:01:53.385]                 if (is_error) {
[11:01:53.385]                   sessionInformation <- function() {
[11:01:53.385]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.385]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.385]                       search = base::search(), system = base::Sys.info())
[11:01:53.385]                   }
[11:01:53.385]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.385]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.385]                     cond$call), session = sessionInformation(), 
[11:01:53.385]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.385]                   signalCondition(cond)
[11:01:53.385]                 }
[11:01:53.385]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.385]                 "immediateCondition"))) {
[11:01:53.385]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.385]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.385]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.385]                   if (TRUE && !signal) {
[11:01:53.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.385]                     {
[11:01:53.385]                       inherits <- base::inherits
[11:01:53.385]                       invokeRestart <- base::invokeRestart
[11:01:53.385]                       is.null <- base::is.null
[11:01:53.385]                       muffled <- FALSE
[11:01:53.385]                       if (inherits(cond, "message")) {
[11:01:53.385]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.385]                         if (muffled) 
[11:01:53.385]                           invokeRestart("muffleMessage")
[11:01:53.385]                       }
[11:01:53.385]                       else if (inherits(cond, "warning")) {
[11:01:53.385]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.385]                         if (muffled) 
[11:01:53.385]                           invokeRestart("muffleWarning")
[11:01:53.385]                       }
[11:01:53.385]                       else if (inherits(cond, "condition")) {
[11:01:53.385]                         if (!is.null(pattern)) {
[11:01:53.385]                           computeRestarts <- base::computeRestarts
[11:01:53.385]                           grepl <- base::grepl
[11:01:53.385]                           restarts <- computeRestarts(cond)
[11:01:53.385]                           for (restart in restarts) {
[11:01:53.385]                             name <- restart$name
[11:01:53.385]                             if (is.null(name)) 
[11:01:53.385]                               next
[11:01:53.385]                             if (!grepl(pattern, name)) 
[11:01:53.385]                               next
[11:01:53.385]                             invokeRestart(restart)
[11:01:53.385]                             muffled <- TRUE
[11:01:53.385]                             break
[11:01:53.385]                           }
[11:01:53.385]                         }
[11:01:53.385]                       }
[11:01:53.385]                       invisible(muffled)
[11:01:53.385]                     }
[11:01:53.385]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.385]                   }
[11:01:53.385]                 }
[11:01:53.385]                 else {
[11:01:53.385]                   if (TRUE) {
[11:01:53.385]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.385]                     {
[11:01:53.385]                       inherits <- base::inherits
[11:01:53.385]                       invokeRestart <- base::invokeRestart
[11:01:53.385]                       is.null <- base::is.null
[11:01:53.385]                       muffled <- FALSE
[11:01:53.385]                       if (inherits(cond, "message")) {
[11:01:53.385]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.385]                         if (muffled) 
[11:01:53.385]                           invokeRestart("muffleMessage")
[11:01:53.385]                       }
[11:01:53.385]                       else if (inherits(cond, "warning")) {
[11:01:53.385]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.385]                         if (muffled) 
[11:01:53.385]                           invokeRestart("muffleWarning")
[11:01:53.385]                       }
[11:01:53.385]                       else if (inherits(cond, "condition")) {
[11:01:53.385]                         if (!is.null(pattern)) {
[11:01:53.385]                           computeRestarts <- base::computeRestarts
[11:01:53.385]                           grepl <- base::grepl
[11:01:53.385]                           restarts <- computeRestarts(cond)
[11:01:53.385]                           for (restart in restarts) {
[11:01:53.385]                             name <- restart$name
[11:01:53.385]                             if (is.null(name)) 
[11:01:53.385]                               next
[11:01:53.385]                             if (!grepl(pattern, name)) 
[11:01:53.385]                               next
[11:01:53.385]                             invokeRestart(restart)
[11:01:53.385]                             muffled <- TRUE
[11:01:53.385]                             break
[11:01:53.385]                           }
[11:01:53.385]                         }
[11:01:53.385]                       }
[11:01:53.385]                       invisible(muffled)
[11:01:53.385]                     }
[11:01:53.385]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.385]                   }
[11:01:53.385]                 }
[11:01:53.385]             }
[11:01:53.385]         }))
[11:01:53.385]     }, error = function(ex) {
[11:01:53.385]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.385]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.385]                 ...future.rng), started = ...future.startTime, 
[11:01:53.385]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.385]             version = "1.8"), class = "FutureResult")
[11:01:53.385]     }, finally = {
[11:01:53.385]         if (!identical(...future.workdir, getwd())) 
[11:01:53.385]             setwd(...future.workdir)
[11:01:53.385]         {
[11:01:53.385]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.385]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.385]             }
[11:01:53.385]             base::options(...future.oldOptions)
[11:01:53.385]             if (.Platform$OS.type == "windows") {
[11:01:53.385]                 old_names <- names(...future.oldEnvVars)
[11:01:53.385]                 envs <- base::Sys.getenv()
[11:01:53.385]                 names <- names(envs)
[11:01:53.385]                 common <- intersect(names, old_names)
[11:01:53.385]                 added <- setdiff(names, old_names)
[11:01:53.385]                 removed <- setdiff(old_names, names)
[11:01:53.385]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.385]                   envs[common]]
[11:01:53.385]                 NAMES <- toupper(changed)
[11:01:53.385]                 args <- list()
[11:01:53.385]                 for (kk in seq_along(NAMES)) {
[11:01:53.385]                   name <- changed[[kk]]
[11:01:53.385]                   NAME <- NAMES[[kk]]
[11:01:53.385]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.385]                     next
[11:01:53.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.385]                 }
[11:01:53.385]                 NAMES <- toupper(added)
[11:01:53.385]                 for (kk in seq_along(NAMES)) {
[11:01:53.385]                   name <- added[[kk]]
[11:01:53.385]                   NAME <- NAMES[[kk]]
[11:01:53.385]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.385]                     next
[11:01:53.385]                   args[[name]] <- ""
[11:01:53.385]                 }
[11:01:53.385]                 NAMES <- toupper(removed)
[11:01:53.385]                 for (kk in seq_along(NAMES)) {
[11:01:53.385]                   name <- removed[[kk]]
[11:01:53.385]                   NAME <- NAMES[[kk]]
[11:01:53.385]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.385]                     next
[11:01:53.385]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.385]                 }
[11:01:53.385]                 if (length(args) > 0) 
[11:01:53.385]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.385]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.385]             }
[11:01:53.385]             else {
[11:01:53.385]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.385]             }
[11:01:53.385]             {
[11:01:53.385]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.385]                   0L) {
[11:01:53.385]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.385]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.385]                   base::options(opts)
[11:01:53.385]                 }
[11:01:53.385]                 {
[11:01:53.385]                   {
[11:01:53.385]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.385]                     NULL
[11:01:53.385]                   }
[11:01:53.385]                   options(future.plan = NULL)
[11:01:53.385]                   if (is.na(NA_character_)) 
[11:01:53.385]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.385]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.385]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.385]                     .init = FALSE)
[11:01:53.385]                 }
[11:01:53.385]             }
[11:01:53.385]         }
[11:01:53.385]     })
[11:01:53.385]     if (TRUE) {
[11:01:53.385]         base::sink(type = "output", split = FALSE)
[11:01:53.385]         if (TRUE) {
[11:01:53.385]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.385]         }
[11:01:53.385]         else {
[11:01:53.385]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.385]         }
[11:01:53.385]         base::close(...future.stdout)
[11:01:53.385]         ...future.stdout <- NULL
[11:01:53.385]     }
[11:01:53.385]     ...future.result$conditions <- ...future.conditions
[11:01:53.385]     ...future.result$finished <- base::Sys.time()
[11:01:53.385]     ...future.result
[11:01:53.385] }
[11:01:53.387] assign_globals() ...
[11:01:53.387] List of 1
[11:01:53.387]  $ a:Classes 'MulticoreFuture', 'MultiprocessFuture', 'Future', 'environment' <environment: 0x55eecc9f8db0> 
[11:01:53.387]  - attr(*, "where")=List of 1
[11:01:53.387]   ..$ a:<environment: R_EmptyEnv> 
[11:01:53.387]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.387]  - attr(*, "resolved")= logi TRUE
[11:01:53.387]  - attr(*, "total_size")= num 3835
[11:01:53.387]  - attr(*, "already-done")= logi TRUE
[11:01:53.391] - copied ‘a’ to environment
[11:01:53.391] assign_globals() ... done
[11:01:53.391] requestCore(): workers = 2
[11:01:53.393] MulticoreFuture started
[11:01:53.393] - Launch lazy future ... done
[11:01:53.393] run() for ‘MulticoreFuture’ ... done
[11:01:53.394] result() for MulticoreFuture ...
[11:01:53.394] plan(): Setting new future strategy stack:
[11:01:53.394] List of future strategies:
[11:01:53.394] 1. sequential:
[11:01:53.394]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.394]    - tweaked: FALSE
[11:01:53.394]    - call: NULL
[11:01:53.395] plan(): nbrOfWorkers() = 1
[11:01:53.398] plan(): Setting new future strategy stack:
[11:01:53.398] List of future strategies:
[11:01:53.398] 1. multicore:
[11:01:53.398]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.398]    - tweaked: FALSE
[11:01:53.398]    - call: plan(strategy)
[11:01:53.401] plan(): nbrOfWorkers() = 2
[11:01:53.402] result() for MulticoreFuture ...
[11:01:53.402] result() for MulticoreFuture ... done
[11:01:53.403] signalConditions() ...
[11:01:53.403]  - include = ‘immediateCondition’
[11:01:53.403]  - exclude = 
[11:01:53.403]  - resignal = FALSE
[11:01:53.403]  - Number of conditions: 4
[11:01:53.403] signalConditions() ... done
[11:01:53.403] result() for MulticoreFuture ... done
[11:01:53.403] result() for MulticoreFuture ...
[11:01:53.404] result() for MulticoreFuture ... done
[11:01:53.404] signalConditions() ...
[11:01:53.404]  - include = ‘immediateCondition’
[11:01:53.404]  - exclude = 
[11:01:53.404]  - resignal = FALSE
[11:01:53.404]  - Number of conditions: 4
[11:01:53.404] signalConditions() ... done
[11:01:53.404] Future state: ‘finished’
[11:01:53.405] result() for MulticoreFuture ...
[11:01:53.405] result() for MulticoreFuture ... done
[11:01:53.405] signalConditions() ...
[11:01:53.405]  - include = ‘condition’
[11:01:53.405]  - exclude = ‘immediateCondition’
[11:01:53.405]  - resignal = TRUE
[11:01:53.405]  - Number of conditions: 4
[11:01:53.405]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.396] result() for MulticoreFuture ...
[11:01:53.406]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.397] result() for MulticoreFuture ... done
[11:01:53.406]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.397] result() for MulticoreFuture ...
[11:01:53.406]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.397] result() for MulticoreFuture ... done
[11:01:53.406] signalConditions() ... done
value(b) = 2
[11:01:53.406] result() for MulticoreFuture ...
[11:01:53.406] result() for MulticoreFuture ... done
[11:01:53.406] result() for MulticoreFuture ...
[11:01:53.407] result() for MulticoreFuture ... done
[11:01:53.407] signalConditions() ...
[11:01:53.407]  - include = ‘immediateCondition’
[11:01:53.407]  - exclude = 
[11:01:53.407]  - resignal = FALSE
[11:01:53.407]  - Number of conditions: 4
[11:01:53.407] signalConditions() ... done
[11:01:53.407] Future state: ‘finished’
[11:01:53.407] result() for MulticoreFuture ...
[11:01:53.408] result() for MulticoreFuture ... done
[11:01:53.408] signalConditions() ...
[11:01:53.408]  - include = ‘condition’
[11:01:53.408]  - exclude = ‘immediateCondition’
[11:01:53.408]  - resignal = TRUE
[11:01:53.408]  - Number of conditions: 4
[11:01:53.408]  - Condition #1: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.396] result() for MulticoreFuture ...
[11:01:53.408]  - Condition #2: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.397] result() for MulticoreFuture ... done
[11:01:53.409]  - Condition #3: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.397] result() for MulticoreFuture ...
[11:01:53.409]  - Condition #4: ‘simpleMessage’, ‘message’, ‘condition’
[11:01:53.397] result() for MulticoreFuture ... done
[11:01:53.409] signalConditions() ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.409] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.409] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.411] - globals found: [2] ‘{’, ‘pkg’
[11:01:53.411] Searching for globals ... DONE
[11:01:53.411] Resolving globals: TRUE
[11:01:53.411] Resolving any globals that are futures ...
[11:01:53.411] - globals: [2] ‘{’, ‘pkg’
[11:01:53.411] Resolving any globals that are futures ... DONE
[11:01:53.412] Resolving futures part of globals (recursively) ...
[11:01:53.412] resolve() on list ...
[11:01:53.412]  recursive: 99
[11:01:53.412]  length: 1
[11:01:53.412]  elements: ‘pkg’
[11:01:53.412]  length: 0 (resolved future 1)
[11:01:53.412] resolve() on list ... DONE
[11:01:53.413] - globals: [1] ‘pkg’
[11:01:53.413] Resolving futures part of globals (recursively) ... DONE
[11:01:53.413] The total size of the 1 globals is 42 bytes (42 bytes)
[11:01:53.413] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[11:01:53.413] - globals: [1] ‘pkg’
[11:01:53.414] 
[11:01:53.414] getGlobalsAndPackages() ... DONE
[11:01:53.414] Packages needed by the future expression (n = 0): <none>
[11:01:53.414] Packages needed by future strategies (n = 0): <none>
[11:01:53.415] {
[11:01:53.415]     {
[11:01:53.415]         {
[11:01:53.415]             ...future.startTime <- base::Sys.time()
[11:01:53.415]             {
[11:01:53.415]                 {
[11:01:53.415]                   {
[11:01:53.415]                     base::local({
[11:01:53.415]                       has_future <- base::requireNamespace("future", 
[11:01:53.415]                         quietly = TRUE)
[11:01:53.415]                       if (has_future) {
[11:01:53.415]                         ns <- base::getNamespace("future")
[11:01:53.415]                         version <- ns[[".package"]][["version"]]
[11:01:53.415]                         if (is.null(version)) 
[11:01:53.415]                           version <- utils::packageVersion("future")
[11:01:53.415]                       }
[11:01:53.415]                       else {
[11:01:53.415]                         version <- NULL
[11:01:53.415]                       }
[11:01:53.415]                       if (!has_future || version < "1.8.0") {
[11:01:53.415]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.415]                           "", base::R.version$version.string), 
[11:01:53.415]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:53.415]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.415]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.415]                             "release", "version")], collapse = " "), 
[11:01:53.415]                           hostname = base::Sys.info()[["nodename"]])
[11:01:53.415]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.415]                           info)
[11:01:53.415]                         info <- base::paste(info, collapse = "; ")
[11:01:53.415]                         if (!has_future) {
[11:01:53.415]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.415]                             info)
[11:01:53.415]                         }
[11:01:53.415]                         else {
[11:01:53.415]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.415]                             info, version)
[11:01:53.415]                         }
[11:01:53.415]                         base::stop(msg)
[11:01:53.415]                       }
[11:01:53.415]                     })
[11:01:53.415]                   }
[11:01:53.415]                   ...future.strategy.old <- future::plan("list")
[11:01:53.415]                   options(future.plan = NULL)
[11:01:53.415]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.415]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.415]                 }
[11:01:53.415]                 ...future.workdir <- getwd()
[11:01:53.415]             }
[11:01:53.415]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.415]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.415]         }
[11:01:53.415]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.415]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.415]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.415]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.415]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.415]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.415]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.415]             base::names(...future.oldOptions))
[11:01:53.415]     }
[11:01:53.415]     if (FALSE) {
[11:01:53.415]     }
[11:01:53.415]     else {
[11:01:53.415]         if (TRUE) {
[11:01:53.415]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.415]                 open = "w")
[11:01:53.415]         }
[11:01:53.415]         else {
[11:01:53.415]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.415]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.415]         }
[11:01:53.415]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.415]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.415]             base::sink(type = "output", split = FALSE)
[11:01:53.415]             base::close(...future.stdout)
[11:01:53.415]         }, add = TRUE)
[11:01:53.415]     }
[11:01:53.415]     ...future.frame <- base::sys.nframe()
[11:01:53.415]     ...future.conditions <- base::list()
[11:01:53.415]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.415]     if (FALSE) {
[11:01:53.415]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.415]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.415]     }
[11:01:53.415]     ...future.result <- base::tryCatch({
[11:01:53.415]         base::withCallingHandlers({
[11:01:53.415]             ...future.value <- base::withVisible(base::local({
[11:01:53.415]                 pkg
[11:01:53.415]             }))
[11:01:53.415]             future::FutureResult(value = ...future.value$value, 
[11:01:53.415]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.415]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.415]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.415]                     ...future.globalenv.names))
[11:01:53.415]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.415]         }, condition = base::local({
[11:01:53.415]             c <- base::c
[11:01:53.415]             inherits <- base::inherits
[11:01:53.415]             invokeRestart <- base::invokeRestart
[11:01:53.415]             length <- base::length
[11:01:53.415]             list <- base::list
[11:01:53.415]             seq.int <- base::seq.int
[11:01:53.415]             signalCondition <- base::signalCondition
[11:01:53.415]             sys.calls <- base::sys.calls
[11:01:53.415]             `[[` <- base::`[[`
[11:01:53.415]             `+` <- base::`+`
[11:01:53.415]             `<<-` <- base::`<<-`
[11:01:53.415]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.415]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.415]                   3L)]
[11:01:53.415]             }
[11:01:53.415]             function(cond) {
[11:01:53.415]                 is_error <- inherits(cond, "error")
[11:01:53.415]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.415]                   NULL)
[11:01:53.415]                 if (is_error) {
[11:01:53.415]                   sessionInformation <- function() {
[11:01:53.415]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.415]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.415]                       search = base::search(), system = base::Sys.info())
[11:01:53.415]                   }
[11:01:53.415]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.415]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.415]                     cond$call), session = sessionInformation(), 
[11:01:53.415]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.415]                   signalCondition(cond)
[11:01:53.415]                 }
[11:01:53.415]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.415]                 "immediateCondition"))) {
[11:01:53.415]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.415]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.415]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.415]                   if (TRUE && !signal) {
[11:01:53.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.415]                     {
[11:01:53.415]                       inherits <- base::inherits
[11:01:53.415]                       invokeRestart <- base::invokeRestart
[11:01:53.415]                       is.null <- base::is.null
[11:01:53.415]                       muffled <- FALSE
[11:01:53.415]                       if (inherits(cond, "message")) {
[11:01:53.415]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.415]                         if (muffled) 
[11:01:53.415]                           invokeRestart("muffleMessage")
[11:01:53.415]                       }
[11:01:53.415]                       else if (inherits(cond, "warning")) {
[11:01:53.415]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.415]                         if (muffled) 
[11:01:53.415]                           invokeRestart("muffleWarning")
[11:01:53.415]                       }
[11:01:53.415]                       else if (inherits(cond, "condition")) {
[11:01:53.415]                         if (!is.null(pattern)) {
[11:01:53.415]                           computeRestarts <- base::computeRestarts
[11:01:53.415]                           grepl <- base::grepl
[11:01:53.415]                           restarts <- computeRestarts(cond)
[11:01:53.415]                           for (restart in restarts) {
[11:01:53.415]                             name <- restart$name
[11:01:53.415]                             if (is.null(name)) 
[11:01:53.415]                               next
[11:01:53.415]                             if (!grepl(pattern, name)) 
[11:01:53.415]                               next
[11:01:53.415]                             invokeRestart(restart)
[11:01:53.415]                             muffled <- TRUE
[11:01:53.415]                             break
[11:01:53.415]                           }
[11:01:53.415]                         }
[11:01:53.415]                       }
[11:01:53.415]                       invisible(muffled)
[11:01:53.415]                     }
[11:01:53.415]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.415]                   }
[11:01:53.415]                 }
[11:01:53.415]                 else {
[11:01:53.415]                   if (TRUE) {
[11:01:53.415]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.415]                     {
[11:01:53.415]                       inherits <- base::inherits
[11:01:53.415]                       invokeRestart <- base::invokeRestart
[11:01:53.415]                       is.null <- base::is.null
[11:01:53.415]                       muffled <- FALSE
[11:01:53.415]                       if (inherits(cond, "message")) {
[11:01:53.415]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.415]                         if (muffled) 
[11:01:53.415]                           invokeRestart("muffleMessage")
[11:01:53.415]                       }
[11:01:53.415]                       else if (inherits(cond, "warning")) {
[11:01:53.415]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.415]                         if (muffled) 
[11:01:53.415]                           invokeRestart("muffleWarning")
[11:01:53.415]                       }
[11:01:53.415]                       else if (inherits(cond, "condition")) {
[11:01:53.415]                         if (!is.null(pattern)) {
[11:01:53.415]                           computeRestarts <- base::computeRestarts
[11:01:53.415]                           grepl <- base::grepl
[11:01:53.415]                           restarts <- computeRestarts(cond)
[11:01:53.415]                           for (restart in restarts) {
[11:01:53.415]                             name <- restart$name
[11:01:53.415]                             if (is.null(name)) 
[11:01:53.415]                               next
[11:01:53.415]                             if (!grepl(pattern, name)) 
[11:01:53.415]                               next
[11:01:53.415]                             invokeRestart(restart)
[11:01:53.415]                             muffled <- TRUE
[11:01:53.415]                             break
[11:01:53.415]                           }
[11:01:53.415]                         }
[11:01:53.415]                       }
[11:01:53.415]                       invisible(muffled)
[11:01:53.415]                     }
[11:01:53.415]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.415]                   }
[11:01:53.415]                 }
[11:01:53.415]             }
[11:01:53.415]         }))
[11:01:53.415]     }, error = function(ex) {
[11:01:53.415]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.415]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.415]                 ...future.rng), started = ...future.startTime, 
[11:01:53.415]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.415]             version = "1.8"), class = "FutureResult")
[11:01:53.415]     }, finally = {
[11:01:53.415]         if (!identical(...future.workdir, getwd())) 
[11:01:53.415]             setwd(...future.workdir)
[11:01:53.415]         {
[11:01:53.415]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.415]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.415]             }
[11:01:53.415]             base::options(...future.oldOptions)
[11:01:53.415]             if (.Platform$OS.type == "windows") {
[11:01:53.415]                 old_names <- names(...future.oldEnvVars)
[11:01:53.415]                 envs <- base::Sys.getenv()
[11:01:53.415]                 names <- names(envs)
[11:01:53.415]                 common <- intersect(names, old_names)
[11:01:53.415]                 added <- setdiff(names, old_names)
[11:01:53.415]                 removed <- setdiff(old_names, names)
[11:01:53.415]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.415]                   envs[common]]
[11:01:53.415]                 NAMES <- toupper(changed)
[11:01:53.415]                 args <- list()
[11:01:53.415]                 for (kk in seq_along(NAMES)) {
[11:01:53.415]                   name <- changed[[kk]]
[11:01:53.415]                   NAME <- NAMES[[kk]]
[11:01:53.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.415]                     next
[11:01:53.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.415]                 }
[11:01:53.415]                 NAMES <- toupper(added)
[11:01:53.415]                 for (kk in seq_along(NAMES)) {
[11:01:53.415]                   name <- added[[kk]]
[11:01:53.415]                   NAME <- NAMES[[kk]]
[11:01:53.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.415]                     next
[11:01:53.415]                   args[[name]] <- ""
[11:01:53.415]                 }
[11:01:53.415]                 NAMES <- toupper(removed)
[11:01:53.415]                 for (kk in seq_along(NAMES)) {
[11:01:53.415]                   name <- removed[[kk]]
[11:01:53.415]                   NAME <- NAMES[[kk]]
[11:01:53.415]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.415]                     next
[11:01:53.415]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.415]                 }
[11:01:53.415]                 if (length(args) > 0) 
[11:01:53.415]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.415]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.415]             }
[11:01:53.415]             else {
[11:01:53.415]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.415]             }
[11:01:53.415]             {
[11:01:53.415]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.415]                   0L) {
[11:01:53.415]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.415]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.415]                   base::options(opts)
[11:01:53.415]                 }
[11:01:53.415]                 {
[11:01:53.415]                   {
[11:01:53.415]                     NULL
[11:01:53.415]                     RNGkind("Mersenne-Twister")
[11:01:53.415]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:53.415]                       inherits = FALSE)
[11:01:53.415]                   }
[11:01:53.415]                   options(future.plan = NULL)
[11:01:53.415]                   if (is.na(NA_character_)) 
[11:01:53.415]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.415]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.415]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.415]                     .init = FALSE)
[11:01:53.415]                 }
[11:01:53.415]             }
[11:01:53.415]         }
[11:01:53.415]     })
[11:01:53.415]     if (TRUE) {
[11:01:53.415]         base::sink(type = "output", split = FALSE)
[11:01:53.415]         if (TRUE) {
[11:01:53.415]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.415]         }
[11:01:53.415]         else {
[11:01:53.415]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.415]         }
[11:01:53.415]         base::close(...future.stdout)
[11:01:53.415]         ...future.stdout <- NULL
[11:01:53.415]     }
[11:01:53.415]     ...future.result$conditions <- ...future.conditions
[11:01:53.415]     ...future.result$finished <- base::Sys.time()
[11:01:53.415]     ...future.result
[11:01:53.415] }
[11:01:53.417] assign_globals() ...
[11:01:53.417] List of 1
[11:01:53.417]  $ pkg: chr "foo"
[11:01:53.417]  - attr(*, "where")=List of 1
[11:01:53.417]   ..$ pkg:<environment: R_EmptyEnv> 
[11:01:53.417]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.417]  - attr(*, "resolved")= logi TRUE
[11:01:53.417]  - attr(*, "total_size")= num 42
[11:01:53.422] - copied ‘pkg’ to environment
[11:01:53.422] assign_globals() ... done
[11:01:53.422] plan(): Setting new future strategy stack:
[11:01:53.422] List of future strategies:
[11:01:53.422] 1. sequential:
[11:01:53.422]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.422]    - tweaked: FALSE
[11:01:53.422]    - call: NULL
[11:01:53.423] plan(): nbrOfWorkers() = 1
[11:01:53.424] plan(): Setting new future strategy stack:
[11:01:53.424] List of future strategies:
[11:01:53.424] 1. multicore:
[11:01:53.424]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.424]    - tweaked: FALSE
[11:01:53.424]    - call: plan(strategy)
[11:01:53.426] plan(): nbrOfWorkers() = 2
[11:01:53.426] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.427] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.427] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.429] - globals found: [3] ‘{’, ‘<-’, ‘+’
[11:01:53.429] Searching for globals ... DONE
[11:01:53.429] Resolving globals: TRUE
[11:01:53.429] Resolving any globals that are futures ...
[11:01:53.430] - globals: [3] ‘{’, ‘<-’, ‘+’
[11:01:53.430] Resolving any globals that are futures ... DONE
[11:01:53.430] 
[11:01:53.430] 
[11:01:53.430] getGlobalsAndPackages() ... DONE
[11:01:53.430] run() for ‘Future’ ...
[11:01:53.430] - state: ‘created’
[11:01:53.431] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.432] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.432] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.432]   - Field: ‘label’
[11:01:53.432]   - Field: ‘local’
[11:01:53.432]   - Field: ‘owner’
[11:01:53.433]   - Field: ‘envir’
[11:01:53.433]   - Field: ‘workers’
[11:01:53.433]   - Field: ‘packages’
[11:01:53.433]   - Field: ‘gc’
[11:01:53.433]   - Field: ‘job’
[11:01:53.433]   - Field: ‘conditions’
[11:01:53.433]   - Field: ‘expr’
[11:01:53.433]   - Field: ‘uuid’
[11:01:53.433]   - Field: ‘seed’
[11:01:53.433]   - Field: ‘version’
[11:01:53.433]   - Field: ‘result’
[11:01:53.433]   - Field: ‘asynchronous’
[11:01:53.434]   - Field: ‘calls’
[11:01:53.434]   - Field: ‘globals’
[11:01:53.434]   - Field: ‘stdout’
[11:01:53.434]   - Field: ‘earlySignal’
[11:01:53.434]   - Field: ‘lazy’
[11:01:53.434]   - Field: ‘state’
[11:01:53.434] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.434] - Launch lazy future ...
[11:01:53.434] Packages needed by the future expression (n = 0): <none>
[11:01:53.434] Packages needed by future strategies (n = 0): <none>
[11:01:53.435] {
[11:01:53.435]     {
[11:01:53.435]         {
[11:01:53.435]             ...future.startTime <- base::Sys.time()
[11:01:53.435]             {
[11:01:53.435]                 {
[11:01:53.435]                   {
[11:01:53.435]                     {
[11:01:53.435]                       base::local({
[11:01:53.435]                         has_future <- base::requireNamespace("future", 
[11:01:53.435]                           quietly = TRUE)
[11:01:53.435]                         if (has_future) {
[11:01:53.435]                           ns <- base::getNamespace("future")
[11:01:53.435]                           version <- ns[[".package"]][["version"]]
[11:01:53.435]                           if (is.null(version)) 
[11:01:53.435]                             version <- utils::packageVersion("future")
[11:01:53.435]                         }
[11:01:53.435]                         else {
[11:01:53.435]                           version <- NULL
[11:01:53.435]                         }
[11:01:53.435]                         if (!has_future || version < "1.8.0") {
[11:01:53.435]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.435]                             "", base::R.version$version.string), 
[11:01:53.435]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.435]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.435]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.435]                               "release", "version")], collapse = " "), 
[11:01:53.435]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.435]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.435]                             info)
[11:01:53.435]                           info <- base::paste(info, collapse = "; ")
[11:01:53.435]                           if (!has_future) {
[11:01:53.435]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.435]                               info)
[11:01:53.435]                           }
[11:01:53.435]                           else {
[11:01:53.435]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.435]                               info, version)
[11:01:53.435]                           }
[11:01:53.435]                           base::stop(msg)
[11:01:53.435]                         }
[11:01:53.435]                       })
[11:01:53.435]                     }
[11:01:53.435]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.435]                     base::options(mc.cores = 1L)
[11:01:53.435]                   }
[11:01:53.435]                   ...future.strategy.old <- future::plan("list")
[11:01:53.435]                   options(future.plan = NULL)
[11:01:53.435]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.435]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.435]                 }
[11:01:53.435]                 ...future.workdir <- getwd()
[11:01:53.435]             }
[11:01:53.435]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.435]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.435]         }
[11:01:53.435]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.435]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.435]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.435]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.435]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.435]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.435]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.435]             base::names(...future.oldOptions))
[11:01:53.435]     }
[11:01:53.435]     if (FALSE) {
[11:01:53.435]     }
[11:01:53.435]     else {
[11:01:53.435]         if (TRUE) {
[11:01:53.435]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.435]                 open = "w")
[11:01:53.435]         }
[11:01:53.435]         else {
[11:01:53.435]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.435]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.435]         }
[11:01:53.435]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.435]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.435]             base::sink(type = "output", split = FALSE)
[11:01:53.435]             base::close(...future.stdout)
[11:01:53.435]         }, add = TRUE)
[11:01:53.435]     }
[11:01:53.435]     ...future.frame <- base::sys.nframe()
[11:01:53.435]     ...future.conditions <- base::list()
[11:01:53.435]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.435]     if (FALSE) {
[11:01:53.435]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.435]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.435]     }
[11:01:53.435]     ...future.result <- base::tryCatch({
[11:01:53.435]         base::withCallingHandlers({
[11:01:53.435]             ...future.value <- base::withVisible(base::local({
[11:01:53.435]                 withCallingHandlers({
[11:01:53.435]                   {
[11:01:53.435]                     x <- 0
[11:01:53.435]                     x <- x + 1
[11:01:53.435]                     x
[11:01:53.435]                   }
[11:01:53.435]                 }, immediateCondition = function(cond) {
[11:01:53.435]                   save_rds <- function (object, pathname, ...) 
[11:01:53.435]                   {
[11:01:53.435]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.435]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.435]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.435]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.435]                         fi_tmp[["mtime"]])
[11:01:53.435]                     }
[11:01:53.435]                     tryCatch({
[11:01:53.435]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.435]                     }, error = function(ex) {
[11:01:53.435]                       msg <- conditionMessage(ex)
[11:01:53.435]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.435]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.435]                         fi_tmp[["mtime"]], msg)
[11:01:53.435]                       ex$message <- msg
[11:01:53.435]                       stop(ex)
[11:01:53.435]                     })
[11:01:53.435]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.435]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.435]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.435]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.435]                       fi <- file.info(pathname)
[11:01:53.435]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.435]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.435]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.435]                         fi[["size"]], fi[["mtime"]])
[11:01:53.435]                       stop(msg)
[11:01:53.435]                     }
[11:01:53.435]                     invisible(pathname)
[11:01:53.435]                   }
[11:01:53.435]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.435]                     rootPath = tempdir()) 
[11:01:53.435]                   {
[11:01:53.435]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.435]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.435]                       tmpdir = path, fileext = ".rds")
[11:01:53.435]                     save_rds(obj, file)
[11:01:53.435]                   }
[11:01:53.435]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.435]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.435]                   {
[11:01:53.435]                     inherits <- base::inherits
[11:01:53.435]                     invokeRestart <- base::invokeRestart
[11:01:53.435]                     is.null <- base::is.null
[11:01:53.435]                     muffled <- FALSE
[11:01:53.435]                     if (inherits(cond, "message")) {
[11:01:53.435]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.435]                       if (muffled) 
[11:01:53.435]                         invokeRestart("muffleMessage")
[11:01:53.435]                     }
[11:01:53.435]                     else if (inherits(cond, "warning")) {
[11:01:53.435]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.435]                       if (muffled) 
[11:01:53.435]                         invokeRestart("muffleWarning")
[11:01:53.435]                     }
[11:01:53.435]                     else if (inherits(cond, "condition")) {
[11:01:53.435]                       if (!is.null(pattern)) {
[11:01:53.435]                         computeRestarts <- base::computeRestarts
[11:01:53.435]                         grepl <- base::grepl
[11:01:53.435]                         restarts <- computeRestarts(cond)
[11:01:53.435]                         for (restart in restarts) {
[11:01:53.435]                           name <- restart$name
[11:01:53.435]                           if (is.null(name)) 
[11:01:53.435]                             next
[11:01:53.435]                           if (!grepl(pattern, name)) 
[11:01:53.435]                             next
[11:01:53.435]                           invokeRestart(restart)
[11:01:53.435]                           muffled <- TRUE
[11:01:53.435]                           break
[11:01:53.435]                         }
[11:01:53.435]                       }
[11:01:53.435]                     }
[11:01:53.435]                     invisible(muffled)
[11:01:53.435]                   }
[11:01:53.435]                   muffleCondition(cond)
[11:01:53.435]                 })
[11:01:53.435]             }))
[11:01:53.435]             future::FutureResult(value = ...future.value$value, 
[11:01:53.435]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.435]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.435]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.435]                     ...future.globalenv.names))
[11:01:53.435]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.435]         }, condition = base::local({
[11:01:53.435]             c <- base::c
[11:01:53.435]             inherits <- base::inherits
[11:01:53.435]             invokeRestart <- base::invokeRestart
[11:01:53.435]             length <- base::length
[11:01:53.435]             list <- base::list
[11:01:53.435]             seq.int <- base::seq.int
[11:01:53.435]             signalCondition <- base::signalCondition
[11:01:53.435]             sys.calls <- base::sys.calls
[11:01:53.435]             `[[` <- base::`[[`
[11:01:53.435]             `+` <- base::`+`
[11:01:53.435]             `<<-` <- base::`<<-`
[11:01:53.435]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.435]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.435]                   3L)]
[11:01:53.435]             }
[11:01:53.435]             function(cond) {
[11:01:53.435]                 is_error <- inherits(cond, "error")
[11:01:53.435]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.435]                   NULL)
[11:01:53.435]                 if (is_error) {
[11:01:53.435]                   sessionInformation <- function() {
[11:01:53.435]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.435]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.435]                       search = base::search(), system = base::Sys.info())
[11:01:53.435]                   }
[11:01:53.435]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.435]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.435]                     cond$call), session = sessionInformation(), 
[11:01:53.435]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.435]                   signalCondition(cond)
[11:01:53.435]                 }
[11:01:53.435]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.435]                 "immediateCondition"))) {
[11:01:53.435]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.435]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.435]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.435]                   if (TRUE && !signal) {
[11:01:53.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.435]                     {
[11:01:53.435]                       inherits <- base::inherits
[11:01:53.435]                       invokeRestart <- base::invokeRestart
[11:01:53.435]                       is.null <- base::is.null
[11:01:53.435]                       muffled <- FALSE
[11:01:53.435]                       if (inherits(cond, "message")) {
[11:01:53.435]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.435]                         if (muffled) 
[11:01:53.435]                           invokeRestart("muffleMessage")
[11:01:53.435]                       }
[11:01:53.435]                       else if (inherits(cond, "warning")) {
[11:01:53.435]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.435]                         if (muffled) 
[11:01:53.435]                           invokeRestart("muffleWarning")
[11:01:53.435]                       }
[11:01:53.435]                       else if (inherits(cond, "condition")) {
[11:01:53.435]                         if (!is.null(pattern)) {
[11:01:53.435]                           computeRestarts <- base::computeRestarts
[11:01:53.435]                           grepl <- base::grepl
[11:01:53.435]                           restarts <- computeRestarts(cond)
[11:01:53.435]                           for (restart in restarts) {
[11:01:53.435]                             name <- restart$name
[11:01:53.435]                             if (is.null(name)) 
[11:01:53.435]                               next
[11:01:53.435]                             if (!grepl(pattern, name)) 
[11:01:53.435]                               next
[11:01:53.435]                             invokeRestart(restart)
[11:01:53.435]                             muffled <- TRUE
[11:01:53.435]                             break
[11:01:53.435]                           }
[11:01:53.435]                         }
[11:01:53.435]                       }
[11:01:53.435]                       invisible(muffled)
[11:01:53.435]                     }
[11:01:53.435]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.435]                   }
[11:01:53.435]                 }
[11:01:53.435]                 else {
[11:01:53.435]                   if (TRUE) {
[11:01:53.435]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.435]                     {
[11:01:53.435]                       inherits <- base::inherits
[11:01:53.435]                       invokeRestart <- base::invokeRestart
[11:01:53.435]                       is.null <- base::is.null
[11:01:53.435]                       muffled <- FALSE
[11:01:53.435]                       if (inherits(cond, "message")) {
[11:01:53.435]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.435]                         if (muffled) 
[11:01:53.435]                           invokeRestart("muffleMessage")
[11:01:53.435]                       }
[11:01:53.435]                       else if (inherits(cond, "warning")) {
[11:01:53.435]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.435]                         if (muffled) 
[11:01:53.435]                           invokeRestart("muffleWarning")
[11:01:53.435]                       }
[11:01:53.435]                       else if (inherits(cond, "condition")) {
[11:01:53.435]                         if (!is.null(pattern)) {
[11:01:53.435]                           computeRestarts <- base::computeRestarts
[11:01:53.435]                           grepl <- base::grepl
[11:01:53.435]                           restarts <- computeRestarts(cond)
[11:01:53.435]                           for (restart in restarts) {
[11:01:53.435]                             name <- restart$name
[11:01:53.435]                             if (is.null(name)) 
[11:01:53.435]                               next
[11:01:53.435]                             if (!grepl(pattern, name)) 
[11:01:53.435]                               next
[11:01:53.435]                             invokeRestart(restart)
[11:01:53.435]                             muffled <- TRUE
[11:01:53.435]                             break
[11:01:53.435]                           }
[11:01:53.435]                         }
[11:01:53.435]                       }
[11:01:53.435]                       invisible(muffled)
[11:01:53.435]                     }
[11:01:53.435]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.435]                   }
[11:01:53.435]                 }
[11:01:53.435]             }
[11:01:53.435]         }))
[11:01:53.435]     }, error = function(ex) {
[11:01:53.435]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.435]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.435]                 ...future.rng), started = ...future.startTime, 
[11:01:53.435]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.435]             version = "1.8"), class = "FutureResult")
[11:01:53.435]     }, finally = {
[11:01:53.435]         if (!identical(...future.workdir, getwd())) 
[11:01:53.435]             setwd(...future.workdir)
[11:01:53.435]         {
[11:01:53.435]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.435]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.435]             }
[11:01:53.435]             base::options(...future.oldOptions)
[11:01:53.435]             if (.Platform$OS.type == "windows") {
[11:01:53.435]                 old_names <- names(...future.oldEnvVars)
[11:01:53.435]                 envs <- base::Sys.getenv()
[11:01:53.435]                 names <- names(envs)
[11:01:53.435]                 common <- intersect(names, old_names)
[11:01:53.435]                 added <- setdiff(names, old_names)
[11:01:53.435]                 removed <- setdiff(old_names, names)
[11:01:53.435]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.435]                   envs[common]]
[11:01:53.435]                 NAMES <- toupper(changed)
[11:01:53.435]                 args <- list()
[11:01:53.435]                 for (kk in seq_along(NAMES)) {
[11:01:53.435]                   name <- changed[[kk]]
[11:01:53.435]                   NAME <- NAMES[[kk]]
[11:01:53.435]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.435]                     next
[11:01:53.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.435]                 }
[11:01:53.435]                 NAMES <- toupper(added)
[11:01:53.435]                 for (kk in seq_along(NAMES)) {
[11:01:53.435]                   name <- added[[kk]]
[11:01:53.435]                   NAME <- NAMES[[kk]]
[11:01:53.435]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.435]                     next
[11:01:53.435]                   args[[name]] <- ""
[11:01:53.435]                 }
[11:01:53.435]                 NAMES <- toupper(removed)
[11:01:53.435]                 for (kk in seq_along(NAMES)) {
[11:01:53.435]                   name <- removed[[kk]]
[11:01:53.435]                   NAME <- NAMES[[kk]]
[11:01:53.435]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.435]                     next
[11:01:53.435]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.435]                 }
[11:01:53.435]                 if (length(args) > 0) 
[11:01:53.435]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.435]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.435]             }
[11:01:53.435]             else {
[11:01:53.435]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.435]             }
[11:01:53.435]             {
[11:01:53.435]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.435]                   0L) {
[11:01:53.435]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.435]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.435]                   base::options(opts)
[11:01:53.435]                 }
[11:01:53.435]                 {
[11:01:53.435]                   {
[11:01:53.435]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.435]                     NULL
[11:01:53.435]                   }
[11:01:53.435]                   options(future.plan = NULL)
[11:01:53.435]                   if (is.na(NA_character_)) 
[11:01:53.435]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.435]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.435]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.435]                     .init = FALSE)
[11:01:53.435]                 }
[11:01:53.435]             }
[11:01:53.435]         }
[11:01:53.435]     })
[11:01:53.435]     if (TRUE) {
[11:01:53.435]         base::sink(type = "output", split = FALSE)
[11:01:53.435]         if (TRUE) {
[11:01:53.435]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.435]         }
[11:01:53.435]         else {
[11:01:53.435]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.435]         }
[11:01:53.435]         base::close(...future.stdout)
[11:01:53.435]         ...future.stdout <- NULL
[11:01:53.435]     }
[11:01:53.435]     ...future.result$conditions <- ...future.conditions
[11:01:53.435]     ...future.result$finished <- base::Sys.time()
[11:01:53.435]     ...future.result
[11:01:53.435] }
[11:01:53.437] requestCore(): workers = 2
[11:01:53.439] MulticoreFuture started
[11:01:53.439] - Launch lazy future ... done
[11:01:53.439] run() for ‘MulticoreFuture’ ... done
[11:01:53.440] result() for MulticoreFuture ...
[11:01:53.440] plan(): Setting new future strategy stack:
[11:01:53.440] List of future strategies:
[11:01:53.440] 1. sequential:
[11:01:53.440]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.440]    - tweaked: FALSE
[11:01:53.440]    - call: NULL
[11:01:53.441] plan(): nbrOfWorkers() = 1
[11:01:53.443] plan(): Setting new future strategy stack:
[11:01:53.443] List of future strategies:
[11:01:53.443] 1. multicore:
[11:01:53.443]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.443]    - tweaked: FALSE
[11:01:53.443]    - call: plan(strategy)
[11:01:53.446] plan(): nbrOfWorkers() = 2
[11:01:53.447] result() for MulticoreFuture ...
[11:01:53.447] result() for MulticoreFuture ... done
[11:01:53.447] result() for MulticoreFuture ... done
[11:01:53.447] result() for MulticoreFuture ...
[11:01:53.447] result() for MulticoreFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.448] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.448] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.450] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[11:01:53.450] Searching for globals ... DONE
[11:01:53.450] Resolving globals: TRUE
[11:01:53.451] Resolving any globals that are futures ...
[11:01:53.451] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[11:01:53.451] Resolving any globals that are futures ... DONE
[11:01:53.451] Resolving futures part of globals (recursively) ...
[11:01:53.452] resolve() on list ...
[11:01:53.452]  recursive: 99
[11:01:53.452]  length: 1
[11:01:53.452]  elements: ‘x’
[11:01:53.452]  length: 0 (resolved future 1)
[11:01:53.452] resolve() on list ... DONE
[11:01:53.452] - globals: [1] ‘x’
[11:01:53.452] Resolving futures part of globals (recursively) ... DONE
[11:01:53.453] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:53.453] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[11:01:53.453] - globals: [1] ‘x’
[11:01:53.455] 
[11:01:53.455] getGlobalsAndPackages() ... DONE
[11:01:53.456] run() for ‘Future’ ...
[11:01:53.456] - state: ‘created’
[11:01:53.456] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.458] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.459] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.459]   - Field: ‘label’
[11:01:53.459]   - Field: ‘local’
[11:01:53.459]   - Field: ‘owner’
[11:01:53.459]   - Field: ‘envir’
[11:01:53.459]   - Field: ‘workers’
[11:01:53.459]   - Field: ‘packages’
[11:01:53.460]   - Field: ‘gc’
[11:01:53.460]   - Field: ‘job’
[11:01:53.460]   - Field: ‘conditions’
[11:01:53.460]   - Field: ‘expr’
[11:01:53.460]   - Field: ‘uuid’
[11:01:53.460]   - Field: ‘seed’
[11:01:53.460]   - Field: ‘version’
[11:01:53.460]   - Field: ‘result’
[11:01:53.460]   - Field: ‘asynchronous’
[11:01:53.461]   - Field: ‘calls’
[11:01:53.461]   - Field: ‘globals’
[11:01:53.461]   - Field: ‘stdout’
[11:01:53.461]   - Field: ‘earlySignal’
[11:01:53.461]   - Field: ‘lazy’
[11:01:53.461]   - Field: ‘state’
[11:01:53.461] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.461] - Launch lazy future ...
[11:01:53.462] Packages needed by the future expression (n = 0): <none>
[11:01:53.462] Packages needed by future strategies (n = 0): <none>
[11:01:53.462] {
[11:01:53.462]     {
[11:01:53.462]         {
[11:01:53.462]             ...future.startTime <- base::Sys.time()
[11:01:53.462]             {
[11:01:53.462]                 {
[11:01:53.462]                   {
[11:01:53.462]                     {
[11:01:53.462]                       base::local({
[11:01:53.462]                         has_future <- base::requireNamespace("future", 
[11:01:53.462]                           quietly = TRUE)
[11:01:53.462]                         if (has_future) {
[11:01:53.462]                           ns <- base::getNamespace("future")
[11:01:53.462]                           version <- ns[[".package"]][["version"]]
[11:01:53.462]                           if (is.null(version)) 
[11:01:53.462]                             version <- utils::packageVersion("future")
[11:01:53.462]                         }
[11:01:53.462]                         else {
[11:01:53.462]                           version <- NULL
[11:01:53.462]                         }
[11:01:53.462]                         if (!has_future || version < "1.8.0") {
[11:01:53.462]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.462]                             "", base::R.version$version.string), 
[11:01:53.462]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.462]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.462]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.462]                               "release", "version")], collapse = " "), 
[11:01:53.462]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.462]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.462]                             info)
[11:01:53.462]                           info <- base::paste(info, collapse = "; ")
[11:01:53.462]                           if (!has_future) {
[11:01:53.462]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.462]                               info)
[11:01:53.462]                           }
[11:01:53.462]                           else {
[11:01:53.462]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.462]                               info, version)
[11:01:53.462]                           }
[11:01:53.462]                           base::stop(msg)
[11:01:53.462]                         }
[11:01:53.462]                       })
[11:01:53.462]                     }
[11:01:53.462]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.462]                     base::options(mc.cores = 1L)
[11:01:53.462]                   }
[11:01:53.462]                   ...future.strategy.old <- future::plan("list")
[11:01:53.462]                   options(future.plan = NULL)
[11:01:53.462]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.462]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.462]                 }
[11:01:53.462]                 ...future.workdir <- getwd()
[11:01:53.462]             }
[11:01:53.462]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.462]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.462]         }
[11:01:53.462]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.462]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.462]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.462]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.462]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.462]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.462]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.462]             base::names(...future.oldOptions))
[11:01:53.462]     }
[11:01:53.462]     if (FALSE) {
[11:01:53.462]     }
[11:01:53.462]     else {
[11:01:53.462]         if (TRUE) {
[11:01:53.462]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.462]                 open = "w")
[11:01:53.462]         }
[11:01:53.462]         else {
[11:01:53.462]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.462]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.462]         }
[11:01:53.462]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.462]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.462]             base::sink(type = "output", split = FALSE)
[11:01:53.462]             base::close(...future.stdout)
[11:01:53.462]         }, add = TRUE)
[11:01:53.462]     }
[11:01:53.462]     ...future.frame <- base::sys.nframe()
[11:01:53.462]     ...future.conditions <- base::list()
[11:01:53.462]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.462]     if (FALSE) {
[11:01:53.462]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.462]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.462]     }
[11:01:53.462]     ...future.result <- base::tryCatch({
[11:01:53.462]         base::withCallingHandlers({
[11:01:53.462]             ...future.value <- base::withVisible(base::local({
[11:01:53.462]                 withCallingHandlers({
[11:01:53.462]                   {
[11:01:53.462]                     x <- x + 1
[11:01:53.462]                     x
[11:01:53.462]                   }
[11:01:53.462]                 }, immediateCondition = function(cond) {
[11:01:53.462]                   save_rds <- function (object, pathname, ...) 
[11:01:53.462]                   {
[11:01:53.462]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.462]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.462]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.462]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.462]                         fi_tmp[["mtime"]])
[11:01:53.462]                     }
[11:01:53.462]                     tryCatch({
[11:01:53.462]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.462]                     }, error = function(ex) {
[11:01:53.462]                       msg <- conditionMessage(ex)
[11:01:53.462]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.462]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.462]                         fi_tmp[["mtime"]], msg)
[11:01:53.462]                       ex$message <- msg
[11:01:53.462]                       stop(ex)
[11:01:53.462]                     })
[11:01:53.462]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.462]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.462]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.462]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.462]                       fi <- file.info(pathname)
[11:01:53.462]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.462]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.462]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.462]                         fi[["size"]], fi[["mtime"]])
[11:01:53.462]                       stop(msg)
[11:01:53.462]                     }
[11:01:53.462]                     invisible(pathname)
[11:01:53.462]                   }
[11:01:53.462]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.462]                     rootPath = tempdir()) 
[11:01:53.462]                   {
[11:01:53.462]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.462]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.462]                       tmpdir = path, fileext = ".rds")
[11:01:53.462]                     save_rds(obj, file)
[11:01:53.462]                   }
[11:01:53.462]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.462]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.462]                   {
[11:01:53.462]                     inherits <- base::inherits
[11:01:53.462]                     invokeRestart <- base::invokeRestart
[11:01:53.462]                     is.null <- base::is.null
[11:01:53.462]                     muffled <- FALSE
[11:01:53.462]                     if (inherits(cond, "message")) {
[11:01:53.462]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.462]                       if (muffled) 
[11:01:53.462]                         invokeRestart("muffleMessage")
[11:01:53.462]                     }
[11:01:53.462]                     else if (inherits(cond, "warning")) {
[11:01:53.462]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.462]                       if (muffled) 
[11:01:53.462]                         invokeRestart("muffleWarning")
[11:01:53.462]                     }
[11:01:53.462]                     else if (inherits(cond, "condition")) {
[11:01:53.462]                       if (!is.null(pattern)) {
[11:01:53.462]                         computeRestarts <- base::computeRestarts
[11:01:53.462]                         grepl <- base::grepl
[11:01:53.462]                         restarts <- computeRestarts(cond)
[11:01:53.462]                         for (restart in restarts) {
[11:01:53.462]                           name <- restart$name
[11:01:53.462]                           if (is.null(name)) 
[11:01:53.462]                             next
[11:01:53.462]                           if (!grepl(pattern, name)) 
[11:01:53.462]                             next
[11:01:53.462]                           invokeRestart(restart)
[11:01:53.462]                           muffled <- TRUE
[11:01:53.462]                           break
[11:01:53.462]                         }
[11:01:53.462]                       }
[11:01:53.462]                     }
[11:01:53.462]                     invisible(muffled)
[11:01:53.462]                   }
[11:01:53.462]                   muffleCondition(cond)
[11:01:53.462]                 })
[11:01:53.462]             }))
[11:01:53.462]             future::FutureResult(value = ...future.value$value, 
[11:01:53.462]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.462]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.462]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.462]                     ...future.globalenv.names))
[11:01:53.462]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.462]         }, condition = base::local({
[11:01:53.462]             c <- base::c
[11:01:53.462]             inherits <- base::inherits
[11:01:53.462]             invokeRestart <- base::invokeRestart
[11:01:53.462]             length <- base::length
[11:01:53.462]             list <- base::list
[11:01:53.462]             seq.int <- base::seq.int
[11:01:53.462]             signalCondition <- base::signalCondition
[11:01:53.462]             sys.calls <- base::sys.calls
[11:01:53.462]             `[[` <- base::`[[`
[11:01:53.462]             `+` <- base::`+`
[11:01:53.462]             `<<-` <- base::`<<-`
[11:01:53.462]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.462]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.462]                   3L)]
[11:01:53.462]             }
[11:01:53.462]             function(cond) {
[11:01:53.462]                 is_error <- inherits(cond, "error")
[11:01:53.462]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.462]                   NULL)
[11:01:53.462]                 if (is_error) {
[11:01:53.462]                   sessionInformation <- function() {
[11:01:53.462]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.462]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.462]                       search = base::search(), system = base::Sys.info())
[11:01:53.462]                   }
[11:01:53.462]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.462]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.462]                     cond$call), session = sessionInformation(), 
[11:01:53.462]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.462]                   signalCondition(cond)
[11:01:53.462]                 }
[11:01:53.462]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.462]                 "immediateCondition"))) {
[11:01:53.462]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.462]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.462]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.462]                   if (TRUE && !signal) {
[11:01:53.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.462]                     {
[11:01:53.462]                       inherits <- base::inherits
[11:01:53.462]                       invokeRestart <- base::invokeRestart
[11:01:53.462]                       is.null <- base::is.null
[11:01:53.462]                       muffled <- FALSE
[11:01:53.462]                       if (inherits(cond, "message")) {
[11:01:53.462]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.462]                         if (muffled) 
[11:01:53.462]                           invokeRestart("muffleMessage")
[11:01:53.462]                       }
[11:01:53.462]                       else if (inherits(cond, "warning")) {
[11:01:53.462]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.462]                         if (muffled) 
[11:01:53.462]                           invokeRestart("muffleWarning")
[11:01:53.462]                       }
[11:01:53.462]                       else if (inherits(cond, "condition")) {
[11:01:53.462]                         if (!is.null(pattern)) {
[11:01:53.462]                           computeRestarts <- base::computeRestarts
[11:01:53.462]                           grepl <- base::grepl
[11:01:53.462]                           restarts <- computeRestarts(cond)
[11:01:53.462]                           for (restart in restarts) {
[11:01:53.462]                             name <- restart$name
[11:01:53.462]                             if (is.null(name)) 
[11:01:53.462]                               next
[11:01:53.462]                             if (!grepl(pattern, name)) 
[11:01:53.462]                               next
[11:01:53.462]                             invokeRestart(restart)
[11:01:53.462]                             muffled <- TRUE
[11:01:53.462]                             break
[11:01:53.462]                           }
[11:01:53.462]                         }
[11:01:53.462]                       }
[11:01:53.462]                       invisible(muffled)
[11:01:53.462]                     }
[11:01:53.462]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.462]                   }
[11:01:53.462]                 }
[11:01:53.462]                 else {
[11:01:53.462]                   if (TRUE) {
[11:01:53.462]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.462]                     {
[11:01:53.462]                       inherits <- base::inherits
[11:01:53.462]                       invokeRestart <- base::invokeRestart
[11:01:53.462]                       is.null <- base::is.null
[11:01:53.462]                       muffled <- FALSE
[11:01:53.462]                       if (inherits(cond, "message")) {
[11:01:53.462]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.462]                         if (muffled) 
[11:01:53.462]                           invokeRestart("muffleMessage")
[11:01:53.462]                       }
[11:01:53.462]                       else if (inherits(cond, "warning")) {
[11:01:53.462]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.462]                         if (muffled) 
[11:01:53.462]                           invokeRestart("muffleWarning")
[11:01:53.462]                       }
[11:01:53.462]                       else if (inherits(cond, "condition")) {
[11:01:53.462]                         if (!is.null(pattern)) {
[11:01:53.462]                           computeRestarts <- base::computeRestarts
[11:01:53.462]                           grepl <- base::grepl
[11:01:53.462]                           restarts <- computeRestarts(cond)
[11:01:53.462]                           for (restart in restarts) {
[11:01:53.462]                             name <- restart$name
[11:01:53.462]                             if (is.null(name)) 
[11:01:53.462]                               next
[11:01:53.462]                             if (!grepl(pattern, name)) 
[11:01:53.462]                               next
[11:01:53.462]                             invokeRestart(restart)
[11:01:53.462]                             muffled <- TRUE
[11:01:53.462]                             break
[11:01:53.462]                           }
[11:01:53.462]                         }
[11:01:53.462]                       }
[11:01:53.462]                       invisible(muffled)
[11:01:53.462]                     }
[11:01:53.462]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.462]                   }
[11:01:53.462]                 }
[11:01:53.462]             }
[11:01:53.462]         }))
[11:01:53.462]     }, error = function(ex) {
[11:01:53.462]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.462]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.462]                 ...future.rng), started = ...future.startTime, 
[11:01:53.462]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.462]             version = "1.8"), class = "FutureResult")
[11:01:53.462]     }, finally = {
[11:01:53.462]         if (!identical(...future.workdir, getwd())) 
[11:01:53.462]             setwd(...future.workdir)
[11:01:53.462]         {
[11:01:53.462]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.462]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.462]             }
[11:01:53.462]             base::options(...future.oldOptions)
[11:01:53.462]             if (.Platform$OS.type == "windows") {
[11:01:53.462]                 old_names <- names(...future.oldEnvVars)
[11:01:53.462]                 envs <- base::Sys.getenv()
[11:01:53.462]                 names <- names(envs)
[11:01:53.462]                 common <- intersect(names, old_names)
[11:01:53.462]                 added <- setdiff(names, old_names)
[11:01:53.462]                 removed <- setdiff(old_names, names)
[11:01:53.462]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.462]                   envs[common]]
[11:01:53.462]                 NAMES <- toupper(changed)
[11:01:53.462]                 args <- list()
[11:01:53.462]                 for (kk in seq_along(NAMES)) {
[11:01:53.462]                   name <- changed[[kk]]
[11:01:53.462]                   NAME <- NAMES[[kk]]
[11:01:53.462]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.462]                     next
[11:01:53.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.462]                 }
[11:01:53.462]                 NAMES <- toupper(added)
[11:01:53.462]                 for (kk in seq_along(NAMES)) {
[11:01:53.462]                   name <- added[[kk]]
[11:01:53.462]                   NAME <- NAMES[[kk]]
[11:01:53.462]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.462]                     next
[11:01:53.462]                   args[[name]] <- ""
[11:01:53.462]                 }
[11:01:53.462]                 NAMES <- toupper(removed)
[11:01:53.462]                 for (kk in seq_along(NAMES)) {
[11:01:53.462]                   name <- removed[[kk]]
[11:01:53.462]                   NAME <- NAMES[[kk]]
[11:01:53.462]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.462]                     next
[11:01:53.462]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.462]                 }
[11:01:53.462]                 if (length(args) > 0) 
[11:01:53.462]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.462]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.462]             }
[11:01:53.462]             else {
[11:01:53.462]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.462]             }
[11:01:53.462]             {
[11:01:53.462]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.462]                   0L) {
[11:01:53.462]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.462]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.462]                   base::options(opts)
[11:01:53.462]                 }
[11:01:53.462]                 {
[11:01:53.462]                   {
[11:01:53.462]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.462]                     NULL
[11:01:53.462]                   }
[11:01:53.462]                   options(future.plan = NULL)
[11:01:53.462]                   if (is.na(NA_character_)) 
[11:01:53.462]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.462]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.462]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.462]                     .init = FALSE)
[11:01:53.462]                 }
[11:01:53.462]             }
[11:01:53.462]         }
[11:01:53.462]     })
[11:01:53.462]     if (TRUE) {
[11:01:53.462]         base::sink(type = "output", split = FALSE)
[11:01:53.462]         if (TRUE) {
[11:01:53.462]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.462]         }
[11:01:53.462]         else {
[11:01:53.462]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.462]         }
[11:01:53.462]         base::close(...future.stdout)
[11:01:53.462]         ...future.stdout <- NULL
[11:01:53.462]     }
[11:01:53.462]     ...future.result$conditions <- ...future.conditions
[11:01:53.462]     ...future.result$finished <- base::Sys.time()
[11:01:53.462]     ...future.result
[11:01:53.462] }
[11:01:53.465] assign_globals() ...
[11:01:53.465] List of 1
[11:01:53.465]  $ x: num 1
[11:01:53.465]  - attr(*, "where")=List of 1
[11:01:53.465]   ..$ x:<environment: R_EmptyEnv> 
[11:01:53.465]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.465]  - attr(*, "resolved")= logi TRUE
[11:01:53.465]  - attr(*, "total_size")= num 39
[11:01:53.465]  - attr(*, "already-done")= logi TRUE
[11:01:53.468] - copied ‘x’ to environment
[11:01:53.468] assign_globals() ... done
[11:01:53.468] requestCore(): workers = 2
[11:01:53.470] MulticoreFuture started
[11:01:53.470] - Launch lazy future ... done
[11:01:53.470] run() for ‘MulticoreFuture’ ... done
[11:01:53.470] result() for MulticoreFuture ...
[11:01:53.470] plan(): Setting new future strategy stack:
[11:01:53.471] List of future strategies:
[11:01:53.471] 1. sequential:
[11:01:53.471]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.471]    - tweaked: FALSE
[11:01:53.471]    - call: NULL
[11:01:53.472] plan(): nbrOfWorkers() = 1
[11:01:53.474] plan(): Setting new future strategy stack:
[11:01:53.474] List of future strategies:
[11:01:53.474] 1. multicore:
[11:01:53.474]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.474]    - tweaked: FALSE
[11:01:53.474]    - call: plan(strategy)
[11:01:53.477] plan(): nbrOfWorkers() = 2
[11:01:53.478] result() for MulticoreFuture ...
[11:01:53.478] result() for MulticoreFuture ... done
[11:01:53.478] result() for MulticoreFuture ... done
[11:01:53.478] result() for MulticoreFuture ...
[11:01:53.478] result() for MulticoreFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.479] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.479] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:53.481] - globals found: [3] ‘{’, ‘<-’, ‘x’
[11:01:53.481] Searching for globals ... DONE
[11:01:53.481] Resolving globals: TRUE
[11:01:53.482] Resolving any globals that are futures ...
[11:01:53.482] - globals: [3] ‘{’, ‘<-’, ‘x’
[11:01:53.482] Resolving any globals that are futures ... DONE
[11:01:53.482] Resolving futures part of globals (recursively) ...
[11:01:53.482] resolve() on list ...
[11:01:53.483]  recursive: 99
[11:01:53.483]  length: 1
[11:01:53.483]  elements: ‘x’
[11:01:53.483]  length: 0 (resolved future 1)
[11:01:53.483] resolve() on list ... DONE
[11:01:53.483] - globals: [1] ‘x’
[11:01:53.483] Resolving futures part of globals (recursively) ... DONE
[11:01:53.483] The total size of the 1 globals is 260 bytes (260 bytes)
[11:01:53.484] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[11:01:53.484] - globals: [1] ‘x’
[11:01:53.484] 
[11:01:53.484] getGlobalsAndPackages() ... DONE
[11:01:53.485] run() for ‘Future’ ...
[11:01:53.485] - state: ‘created’
[11:01:53.485] - Future backend: ‘FutureStrategy’, ‘multicore’, ‘multiprocess’, ‘future’, ‘function’
[11:01:53.487] - Future class: ‘MulticoreFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:53.487] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ...
[11:01:53.487]   - Field: ‘label’
[11:01:53.487]   - Field: ‘local’
[11:01:53.487]   - Field: ‘owner’
[11:01:53.487]   - Field: ‘envir’
[11:01:53.488]   - Field: ‘workers’
[11:01:53.488]   - Field: ‘packages’
[11:01:53.488]   - Field: ‘gc’
[11:01:53.488]   - Field: ‘job’
[11:01:53.488]   - Field: ‘conditions’
[11:01:53.488]   - Field: ‘expr’
[11:01:53.488]   - Field: ‘uuid’
[11:01:53.488]   - Field: ‘seed’
[11:01:53.488]   - Field: ‘version’
[11:01:53.489]   - Field: ‘result’
[11:01:53.489]   - Field: ‘asynchronous’
[11:01:53.489]   - Field: ‘calls’
[11:01:53.489]   - Field: ‘globals’
[11:01:53.489]   - Field: ‘stdout’
[11:01:53.489]   - Field: ‘earlySignal’
[11:01:53.489]   - Field: ‘lazy’
[11:01:53.491]   - Field: ‘state’
[11:01:53.491] - Copy elements of temporary ‘MulticoreFuture’ to final ‘Future’ object ... done
[11:01:53.492] - Launch lazy future ...
[11:01:53.492] Packages needed by the future expression (n = 0): <none>
[11:01:53.492] Packages needed by future strategies (n = 0): <none>
[11:01:53.493] {
[11:01:53.493]     {
[11:01:53.493]         {
[11:01:53.493]             ...future.startTime <- base::Sys.time()
[11:01:53.493]             {
[11:01:53.493]                 {
[11:01:53.493]                   {
[11:01:53.493]                     {
[11:01:53.493]                       base::local({
[11:01:53.493]                         has_future <- base::requireNamespace("future", 
[11:01:53.493]                           quietly = TRUE)
[11:01:53.493]                         if (has_future) {
[11:01:53.493]                           ns <- base::getNamespace("future")
[11:01:53.493]                           version <- ns[[".package"]][["version"]]
[11:01:53.493]                           if (is.null(version)) 
[11:01:53.493]                             version <- utils::packageVersion("future")
[11:01:53.493]                         }
[11:01:53.493]                         else {
[11:01:53.493]                           version <- NULL
[11:01:53.493]                         }
[11:01:53.493]                         if (!has_future || version < "1.8.0") {
[11:01:53.493]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:53.493]                             "", base::R.version$version.string), 
[11:01:53.493]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:53.493]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:53.493]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:53.493]                               "release", "version")], collapse = " "), 
[11:01:53.493]                             hostname = base::Sys.info()[["nodename"]])
[11:01:53.493]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:53.493]                             info)
[11:01:53.493]                           info <- base::paste(info, collapse = "; ")
[11:01:53.493]                           if (!has_future) {
[11:01:53.493]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:53.493]                               info)
[11:01:53.493]                           }
[11:01:53.493]                           else {
[11:01:53.493]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:53.493]                               info, version)
[11:01:53.493]                           }
[11:01:53.493]                           base::stop(msg)
[11:01:53.493]                         }
[11:01:53.493]                       })
[11:01:53.493]                     }
[11:01:53.493]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:53.493]                     base::options(mc.cores = 1L)
[11:01:53.493]                   }
[11:01:53.493]                   ...future.strategy.old <- future::plan("list")
[11:01:53.493]                   options(future.plan = NULL)
[11:01:53.493]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.493]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:53.493]                 }
[11:01:53.493]                 ...future.workdir <- getwd()
[11:01:53.493]             }
[11:01:53.493]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:53.493]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:53.493]         }
[11:01:53.493]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:53.493]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:53.493]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:53.493]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:53.493]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:53.493]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:53.493]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:53.493]             base::names(...future.oldOptions))
[11:01:53.493]     }
[11:01:53.493]     if (FALSE) {
[11:01:53.493]     }
[11:01:53.493]     else {
[11:01:53.493]         if (TRUE) {
[11:01:53.493]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:53.493]                 open = "w")
[11:01:53.493]         }
[11:01:53.493]         else {
[11:01:53.493]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:53.493]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:53.493]         }
[11:01:53.493]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:53.493]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:53.493]             base::sink(type = "output", split = FALSE)
[11:01:53.493]             base::close(...future.stdout)
[11:01:53.493]         }, add = TRUE)
[11:01:53.493]     }
[11:01:53.493]     ...future.frame <- base::sys.nframe()
[11:01:53.493]     ...future.conditions <- base::list()
[11:01:53.493]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:53.493]     if (FALSE) {
[11:01:53.493]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:53.493]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:53.493]     }
[11:01:53.493]     ...future.result <- base::tryCatch({
[11:01:53.493]         base::withCallingHandlers({
[11:01:53.493]             ...future.value <- base::withVisible(base::local({
[11:01:53.493]                 withCallingHandlers({
[11:01:53.493]                   {
[11:01:53.493]                     x <- x()
[11:01:53.493]                     x
[11:01:53.493]                   }
[11:01:53.493]                 }, immediateCondition = function(cond) {
[11:01:53.493]                   save_rds <- function (object, pathname, ...) 
[11:01:53.493]                   {
[11:01:53.493]                     pathname_tmp <- sprintf("%s.tmp", pathname)
[11:01:53.493]                     if (file_test("-f", pathname_tmp)) {
[11:01:53.493]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.493]                       stopf("Cannot save RDS file because a temporary save file already exists: %s (%0.f bytes; last modified on %s)", 
[11:01:53.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.493]                         fi_tmp[["mtime"]])
[11:01:53.493]                     }
[11:01:53.493]                     tryCatch({
[11:01:53.493]                       saveRDS(object, file = pathname_tmp, ...)
[11:01:53.493]                     }, error = function(ex) {
[11:01:53.493]                       msg <- conditionMessage(ex)
[11:01:53.493]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.493]                       msg <- sprintf("saveRDS() failed to save to temporary file %s (%.0f bytes; last modified on %s). The reason was: %s", 
[11:01:53.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.493]                         fi_tmp[["mtime"]], msg)
[11:01:53.493]                       ex$message <- msg
[11:01:53.493]                       stop(ex)
[11:01:53.493]                     })
[11:01:53.493]                     stopifnot(file_test("-f", pathname_tmp))
[11:01:53.493]                     res <- file.rename(from = pathname_tmp, to = pathname)
[11:01:53.493]                     if (!res || file_test("-f", pathname_tmp)) {
[11:01:53.493]                       fi_tmp <- file.info(pathname_tmp)
[11:01:53.493]                       fi <- file.info(pathname)
[11:01:53.493]                       msg <- sprintf("save_rds() failed to rename temporary save file %s (%0.f bytes; last modified on %s) to %s (%0.f bytes; last modified on %s)", 
[11:01:53.493]                         sQuote(pathname_tmp), fi_tmp[["size"]], 
[11:01:53.493]                         fi_tmp[["mtime"]], sQuote(pathname), 
[11:01:53.493]                         fi[["size"]], fi[["mtime"]])
[11:01:53.493]                       stop(msg)
[11:01:53.493]                     }
[11:01:53.493]                     invisible(pathname)
[11:01:53.493]                   }
[11:01:53.493]                   saveImmediateCondition <- function (cond, path = immediateConditionsPath(rootPath = rootPath), 
[11:01:53.493]                     rootPath = tempdir()) 
[11:01:53.493]                   {
[11:01:53.493]                     obj <- list(time = Sys.time(), condition = cond)
[11:01:53.493]                     file <- tempfile(pattern = class(cond)[1], 
[11:01:53.493]                       tmpdir = path, fileext = ".rds")
[11:01:53.493]                     save_rds(obj, file)
[11:01:53.493]                   }
[11:01:53.493]                   saveImmediateCondition(cond, path = "/tmp/RtmpcOfttc/.future/immediateConditions")
[11:01:53.493]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.493]                   {
[11:01:53.493]                     inherits <- base::inherits
[11:01:53.493]                     invokeRestart <- base::invokeRestart
[11:01:53.493]                     is.null <- base::is.null
[11:01:53.493]                     muffled <- FALSE
[11:01:53.493]                     if (inherits(cond, "message")) {
[11:01:53.493]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:53.493]                       if (muffled) 
[11:01:53.493]                         invokeRestart("muffleMessage")
[11:01:53.493]                     }
[11:01:53.493]                     else if (inherits(cond, "warning")) {
[11:01:53.493]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:53.493]                       if (muffled) 
[11:01:53.493]                         invokeRestart("muffleWarning")
[11:01:53.493]                     }
[11:01:53.493]                     else if (inherits(cond, "condition")) {
[11:01:53.493]                       if (!is.null(pattern)) {
[11:01:53.493]                         computeRestarts <- base::computeRestarts
[11:01:53.493]                         grepl <- base::grepl
[11:01:53.493]                         restarts <- computeRestarts(cond)
[11:01:53.493]                         for (restart in restarts) {
[11:01:53.493]                           name <- restart$name
[11:01:53.493]                           if (is.null(name)) 
[11:01:53.493]                             next
[11:01:53.493]                           if (!grepl(pattern, name)) 
[11:01:53.493]                             next
[11:01:53.493]                           invokeRestart(restart)
[11:01:53.493]                           muffled <- TRUE
[11:01:53.493]                           break
[11:01:53.493]                         }
[11:01:53.493]                       }
[11:01:53.493]                     }
[11:01:53.493]                     invisible(muffled)
[11:01:53.493]                   }
[11:01:53.493]                   muffleCondition(cond)
[11:01:53.493]                 })
[11:01:53.493]             }))
[11:01:53.493]             future::FutureResult(value = ...future.value$value, 
[11:01:53.493]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.493]                   ...future.rng), globalenv = if (FALSE) 
[11:01:53.493]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:53.493]                     ...future.globalenv.names))
[11:01:53.493]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:53.493]         }, condition = base::local({
[11:01:53.493]             c <- base::c
[11:01:53.493]             inherits <- base::inherits
[11:01:53.493]             invokeRestart <- base::invokeRestart
[11:01:53.493]             length <- base::length
[11:01:53.493]             list <- base::list
[11:01:53.493]             seq.int <- base::seq.int
[11:01:53.493]             signalCondition <- base::signalCondition
[11:01:53.493]             sys.calls <- base::sys.calls
[11:01:53.493]             `[[` <- base::`[[`
[11:01:53.493]             `+` <- base::`+`
[11:01:53.493]             `<<-` <- base::`<<-`
[11:01:53.493]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:53.493]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:53.493]                   3L)]
[11:01:53.493]             }
[11:01:53.493]             function(cond) {
[11:01:53.493]                 is_error <- inherits(cond, "error")
[11:01:53.493]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:53.493]                   NULL)
[11:01:53.493]                 if (is_error) {
[11:01:53.493]                   sessionInformation <- function() {
[11:01:53.493]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:53.493]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:53.493]                       search = base::search(), system = base::Sys.info())
[11:01:53.493]                   }
[11:01:53.493]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.493]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:53.493]                     cond$call), session = sessionInformation(), 
[11:01:53.493]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:53.493]                   signalCondition(cond)
[11:01:53.493]                 }
[11:01:53.493]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:53.493]                 "immediateCondition"))) {
[11:01:53.493]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:53.493]                   ...future.conditions[[length(...future.conditions) + 
[11:01:53.493]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:53.493]                   if (TRUE && !signal) {
[11:01:53.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.493]                     {
[11:01:53.493]                       inherits <- base::inherits
[11:01:53.493]                       invokeRestart <- base::invokeRestart
[11:01:53.493]                       is.null <- base::is.null
[11:01:53.493]                       muffled <- FALSE
[11:01:53.493]                       if (inherits(cond, "message")) {
[11:01:53.493]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.493]                         if (muffled) 
[11:01:53.493]                           invokeRestart("muffleMessage")
[11:01:53.493]                       }
[11:01:53.493]                       else if (inherits(cond, "warning")) {
[11:01:53.493]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.493]                         if (muffled) 
[11:01:53.493]                           invokeRestart("muffleWarning")
[11:01:53.493]                       }
[11:01:53.493]                       else if (inherits(cond, "condition")) {
[11:01:53.493]                         if (!is.null(pattern)) {
[11:01:53.493]                           computeRestarts <- base::computeRestarts
[11:01:53.493]                           grepl <- base::grepl
[11:01:53.493]                           restarts <- computeRestarts(cond)
[11:01:53.493]                           for (restart in restarts) {
[11:01:53.493]                             name <- restart$name
[11:01:53.493]                             if (is.null(name)) 
[11:01:53.493]                               next
[11:01:53.493]                             if (!grepl(pattern, name)) 
[11:01:53.493]                               next
[11:01:53.493]                             invokeRestart(restart)
[11:01:53.493]                             muffled <- TRUE
[11:01:53.493]                             break
[11:01:53.493]                           }
[11:01:53.493]                         }
[11:01:53.493]                       }
[11:01:53.493]                       invisible(muffled)
[11:01:53.493]                     }
[11:01:53.493]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.493]                   }
[11:01:53.493]                 }
[11:01:53.493]                 else {
[11:01:53.493]                   if (TRUE) {
[11:01:53.493]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:53.493]                     {
[11:01:53.493]                       inherits <- base::inherits
[11:01:53.493]                       invokeRestart <- base::invokeRestart
[11:01:53.493]                       is.null <- base::is.null
[11:01:53.493]                       muffled <- FALSE
[11:01:53.493]                       if (inherits(cond, "message")) {
[11:01:53.493]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:53.493]                         if (muffled) 
[11:01:53.493]                           invokeRestart("muffleMessage")
[11:01:53.493]                       }
[11:01:53.493]                       else if (inherits(cond, "warning")) {
[11:01:53.493]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:53.493]                         if (muffled) 
[11:01:53.493]                           invokeRestart("muffleWarning")
[11:01:53.493]                       }
[11:01:53.493]                       else if (inherits(cond, "condition")) {
[11:01:53.493]                         if (!is.null(pattern)) {
[11:01:53.493]                           computeRestarts <- base::computeRestarts
[11:01:53.493]                           grepl <- base::grepl
[11:01:53.493]                           restarts <- computeRestarts(cond)
[11:01:53.493]                           for (restart in restarts) {
[11:01:53.493]                             name <- restart$name
[11:01:53.493]                             if (is.null(name)) 
[11:01:53.493]                               next
[11:01:53.493]                             if (!grepl(pattern, name)) 
[11:01:53.493]                               next
[11:01:53.493]                             invokeRestart(restart)
[11:01:53.493]                             muffled <- TRUE
[11:01:53.493]                             break
[11:01:53.493]                           }
[11:01:53.493]                         }
[11:01:53.493]                       }
[11:01:53.493]                       invisible(muffled)
[11:01:53.493]                     }
[11:01:53.493]                     muffleCondition(cond, pattern = "^muffle")
[11:01:53.493]                   }
[11:01:53.493]                 }
[11:01:53.493]             }
[11:01:53.493]         }))
[11:01:53.493]     }, error = function(ex) {
[11:01:53.493]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:53.493]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:53.493]                 ...future.rng), started = ...future.startTime, 
[11:01:53.493]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:53.493]             version = "1.8"), class = "FutureResult")
[11:01:53.493]     }, finally = {
[11:01:53.493]         if (!identical(...future.workdir, getwd())) 
[11:01:53.493]             setwd(...future.workdir)
[11:01:53.493]         {
[11:01:53.493]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:53.493]                 ...future.oldOptions$nwarnings <- NULL
[11:01:53.493]             }
[11:01:53.493]             base::options(...future.oldOptions)
[11:01:53.493]             if (.Platform$OS.type == "windows") {
[11:01:53.493]                 old_names <- names(...future.oldEnvVars)
[11:01:53.493]                 envs <- base::Sys.getenv()
[11:01:53.493]                 names <- names(envs)
[11:01:53.493]                 common <- intersect(names, old_names)
[11:01:53.493]                 added <- setdiff(names, old_names)
[11:01:53.493]                 removed <- setdiff(old_names, names)
[11:01:53.493]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:53.493]                   envs[common]]
[11:01:53.493]                 NAMES <- toupper(changed)
[11:01:53.493]                 args <- list()
[11:01:53.493]                 for (kk in seq_along(NAMES)) {
[11:01:53.493]                   name <- changed[[kk]]
[11:01:53.493]                   NAME <- NAMES[[kk]]
[11:01:53.493]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.493]                     next
[11:01:53.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.493]                 }
[11:01:53.493]                 NAMES <- toupper(added)
[11:01:53.493]                 for (kk in seq_along(NAMES)) {
[11:01:53.493]                   name <- added[[kk]]
[11:01:53.493]                   NAME <- NAMES[[kk]]
[11:01:53.493]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.493]                     next
[11:01:53.493]                   args[[name]] <- ""
[11:01:53.493]                 }
[11:01:53.493]                 NAMES <- toupper(removed)
[11:01:53.493]                 for (kk in seq_along(NAMES)) {
[11:01:53.493]                   name <- removed[[kk]]
[11:01:53.493]                   NAME <- NAMES[[kk]]
[11:01:53.493]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:53.493]                     next
[11:01:53.493]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:53.493]                 }
[11:01:53.493]                 if (length(args) > 0) 
[11:01:53.493]                   base::do.call(base::Sys.setenv, args = args)
[11:01:53.493]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:53.493]             }
[11:01:53.493]             else {
[11:01:53.493]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:53.493]             }
[11:01:53.493]             {
[11:01:53.493]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:53.493]                   0L) {
[11:01:53.493]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:53.493]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:53.493]                   base::options(opts)
[11:01:53.493]                 }
[11:01:53.493]                 {
[11:01:53.493]                   {
[11:01:53.493]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:53.493]                     NULL
[11:01:53.493]                   }
[11:01:53.493]                   options(future.plan = NULL)
[11:01:53.493]                   if (is.na(NA_character_)) 
[11:01:53.493]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:53.493]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:53.493]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:53.493]                     .init = FALSE)
[11:01:53.493]                 }
[11:01:53.493]             }
[11:01:53.493]         }
[11:01:53.493]     })
[11:01:53.493]     if (TRUE) {
[11:01:53.493]         base::sink(type = "output", split = FALSE)
[11:01:53.493]         if (TRUE) {
[11:01:53.493]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:53.493]         }
[11:01:53.493]         else {
[11:01:53.493]             ...future.result["stdout"] <- base::list(NULL)
[11:01:53.493]         }
[11:01:53.493]         base::close(...future.stdout)
[11:01:53.493]         ...future.stdout <- NULL
[11:01:53.493]     }
[11:01:53.493]     ...future.result$conditions <- ...future.conditions
[11:01:53.493]     ...future.result$finished <- base::Sys.time()
[11:01:53.493]     ...future.result
[11:01:53.493] }
[11:01:53.495] assign_globals() ...
[11:01:53.496] List of 1
[11:01:53.496]  $ x:function ()  
[11:01:53.496]  - attr(*, "where")=List of 1
[11:01:53.496]   ..$ x:<environment: R_EmptyEnv> 
[11:01:53.496]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:53.496]  - attr(*, "resolved")= logi TRUE
[11:01:53.496]  - attr(*, "total_size")= num 260
[11:01:53.496]  - attr(*, "already-done")= logi TRUE
[11:01:53.499] - reassign environment for ‘x’
[11:01:53.499] - copied ‘x’ to environment
[11:01:53.499] assign_globals() ... done
[11:01:53.499] requestCore(): workers = 2
[11:01:53.501] MulticoreFuture started
[11:01:53.501] - Launch lazy future ... done
[11:01:53.502] run() for ‘MulticoreFuture’ ... done
[11:01:53.502] result() for MulticoreFuture ...
[11:01:53.502] plan(): Setting new future strategy stack:
[11:01:53.502] List of future strategies:
[11:01:53.502] 1. sequential:
[11:01:53.502]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:53.502]    - tweaked: FALSE
[11:01:53.502]    - call: NULL
[11:01:53.503] plan(): nbrOfWorkers() = 1
[11:01:53.506] plan(): Setting new future strategy stack:
[11:01:53.506] List of future strategies:
[11:01:53.506] 1. multicore:
[11:01:53.506]    - args: function (..., workers = availableCores(constraints = "multicore"), envir = parent.frame())
[11:01:53.506]    - tweaked: FALSE
[11:01:53.506]    - call: plan(strategy)
[11:01:53.509] plan(): nbrOfWorkers() = 2
[11:01:53.510] result() for MulticoreFuture ...
[11:01:53.510] result() for MulticoreFuture ... done
[11:01:53.510] result() for MulticoreFuture ... done
[11:01:53.510] result() for MulticoreFuture ...
[11:01:53.510] result() for MulticoreFuture ... done
value(f) = ‘TRUE’
- plan('multisession') ...
[11:01:53.511] plan(): Setting new future strategy stack:
[11:01:53.511] List of future strategies:
[11:01:53.511] 1. multisession:
[11:01:53.511]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:53.511]    - tweaked: FALSE
[11:01:53.511]    - call: plan(strategy)
[11:01:53.512] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[11:01:53.512] multisession:
[11:01:53.512] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:53.512] - tweaked: FALSE
[11:01:53.512] - call: plan(strategy)
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:53.517] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:53.517] Not searching for globals
[11:01:53.517] - globals: [0] <none>
[11:01:53.518] getGlobalsAndPackages() ... DONE
[11:01:54.004] Packages needed by the future expression (n = 0): <none>
[11:01:54.004] Packages needed by future strategies (n = 0): <none>
[11:01:54.004] {
[11:01:54.004]     {
[11:01:54.004]         {
[11:01:54.004]             ...future.startTime <- base::Sys.time()
[11:01:54.004]             {
[11:01:54.004]                 {
[11:01:54.004]                   {
[11:01:54.004]                     {
[11:01:54.004]                       base::local({
[11:01:54.004]                         has_future <- base::requireNamespace("future", 
[11:01:54.004]                           quietly = TRUE)
[11:01:54.004]                         if (has_future) {
[11:01:54.004]                           ns <- base::getNamespace("future")
[11:01:54.004]                           version <- ns[[".package"]][["version"]]
[11:01:54.004]                           if (is.null(version)) 
[11:01:54.004]                             version <- utils::packageVersion("future")
[11:01:54.004]                         }
[11:01:54.004]                         else {
[11:01:54.004]                           version <- NULL
[11:01:54.004]                         }
[11:01:54.004]                         if (!has_future || version < "1.8.0") {
[11:01:54.004]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.004]                             "", base::R.version$version.string), 
[11:01:54.004]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.004]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.004]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.004]                               "release", "version")], collapse = " "), 
[11:01:54.004]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.004]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.004]                             info)
[11:01:54.004]                           info <- base::paste(info, collapse = "; ")
[11:01:54.004]                           if (!has_future) {
[11:01:54.004]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.004]                               info)
[11:01:54.004]                           }
[11:01:54.004]                           else {
[11:01:54.004]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.004]                               info, version)
[11:01:54.004]                           }
[11:01:54.004]                           base::stop(msg)
[11:01:54.004]                         }
[11:01:54.004]                       })
[11:01:54.004]                     }
[11:01:54.004]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.004]                     base::options(mc.cores = 1L)
[11:01:54.004]                   }
[11:01:54.004]                   ...future.strategy.old <- future::plan("list")
[11:01:54.004]                   options(future.plan = NULL)
[11:01:54.004]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.004]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.004]                 }
[11:01:54.004]                 ...future.workdir <- getwd()
[11:01:54.004]             }
[11:01:54.004]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.004]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.004]         }
[11:01:54.004]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.004]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:54.004]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.004]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.004]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.004]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.004]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.004]             base::names(...future.oldOptions))
[11:01:54.004]     }
[11:01:54.004]     if (FALSE) {
[11:01:54.004]     }
[11:01:54.004]     else {
[11:01:54.004]         if (TRUE) {
[11:01:54.004]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.004]                 open = "w")
[11:01:54.004]         }
[11:01:54.004]         else {
[11:01:54.004]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.004]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.004]         }
[11:01:54.004]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.004]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.004]             base::sink(type = "output", split = FALSE)
[11:01:54.004]             base::close(...future.stdout)
[11:01:54.004]         }, add = TRUE)
[11:01:54.004]     }
[11:01:54.004]     ...future.frame <- base::sys.nframe()
[11:01:54.004]     ...future.conditions <- base::list()
[11:01:54.004]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.004]     if (FALSE) {
[11:01:54.004]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.004]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.004]     }
[11:01:54.004]     ...future.result <- base::tryCatch({
[11:01:54.004]         base::withCallingHandlers({
[11:01:54.004]             ...future.value <- base::withVisible(base::local({
[11:01:54.004]                 ...future.makeSendCondition <- base::local({
[11:01:54.004]                   sendCondition <- NULL
[11:01:54.004]                   function(frame = 1L) {
[11:01:54.004]                     if (is.function(sendCondition)) 
[11:01:54.004]                       return(sendCondition)
[11:01:54.004]                     ns <- getNamespace("parallel")
[11:01:54.004]                     if (exists("sendData", mode = "function", 
[11:01:54.004]                       envir = ns)) {
[11:01:54.004]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.004]                         envir = ns)
[11:01:54.004]                       envir <- sys.frame(frame)
[11:01:54.004]                       master <- NULL
[11:01:54.004]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.004]                         !identical(envir, emptyenv())) {
[11:01:54.004]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.004]                           inherits = FALSE)) {
[11:01:54.004]                           master <- get("master", mode = "list", 
[11:01:54.004]                             envir = envir, inherits = FALSE)
[11:01:54.004]                           if (inherits(master, c("SOCKnode", 
[11:01:54.004]                             "SOCK0node"))) {
[11:01:54.004]                             sendCondition <<- function(cond) {
[11:01:54.004]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.004]                                 success = TRUE)
[11:01:54.004]                               parallel_sendData(master, data)
[11:01:54.004]                             }
[11:01:54.004]                             return(sendCondition)
[11:01:54.004]                           }
[11:01:54.004]                         }
[11:01:54.004]                         frame <- frame + 1L
[11:01:54.004]                         envir <- sys.frame(frame)
[11:01:54.004]                       }
[11:01:54.004]                     }
[11:01:54.004]                     sendCondition <<- function(cond) NULL
[11:01:54.004]                   }
[11:01:54.004]                 })
[11:01:54.004]                 withCallingHandlers({
[11:01:54.004]                   NA
[11:01:54.004]                 }, immediateCondition = function(cond) {
[11:01:54.004]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.004]                   sendCondition(cond)
[11:01:54.004]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.004]                   {
[11:01:54.004]                     inherits <- base::inherits
[11:01:54.004]                     invokeRestart <- base::invokeRestart
[11:01:54.004]                     is.null <- base::is.null
[11:01:54.004]                     muffled <- FALSE
[11:01:54.004]                     if (inherits(cond, "message")) {
[11:01:54.004]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.004]                       if (muffled) 
[11:01:54.004]                         invokeRestart("muffleMessage")
[11:01:54.004]                     }
[11:01:54.004]                     else if (inherits(cond, "warning")) {
[11:01:54.004]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.004]                       if (muffled) 
[11:01:54.004]                         invokeRestart("muffleWarning")
[11:01:54.004]                     }
[11:01:54.004]                     else if (inherits(cond, "condition")) {
[11:01:54.004]                       if (!is.null(pattern)) {
[11:01:54.004]                         computeRestarts <- base::computeRestarts
[11:01:54.004]                         grepl <- base::grepl
[11:01:54.004]                         restarts <- computeRestarts(cond)
[11:01:54.004]                         for (restart in restarts) {
[11:01:54.004]                           name <- restart$name
[11:01:54.004]                           if (is.null(name)) 
[11:01:54.004]                             next
[11:01:54.004]                           if (!grepl(pattern, name)) 
[11:01:54.004]                             next
[11:01:54.004]                           invokeRestart(restart)
[11:01:54.004]                           muffled <- TRUE
[11:01:54.004]                           break
[11:01:54.004]                         }
[11:01:54.004]                       }
[11:01:54.004]                     }
[11:01:54.004]                     invisible(muffled)
[11:01:54.004]                   }
[11:01:54.004]                   muffleCondition(cond)
[11:01:54.004]                 })
[11:01:54.004]             }))
[11:01:54.004]             future::FutureResult(value = ...future.value$value, 
[11:01:54.004]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.004]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.004]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.004]                     ...future.globalenv.names))
[11:01:54.004]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.004]         }, condition = base::local({
[11:01:54.004]             c <- base::c
[11:01:54.004]             inherits <- base::inherits
[11:01:54.004]             invokeRestart <- base::invokeRestart
[11:01:54.004]             length <- base::length
[11:01:54.004]             list <- base::list
[11:01:54.004]             seq.int <- base::seq.int
[11:01:54.004]             signalCondition <- base::signalCondition
[11:01:54.004]             sys.calls <- base::sys.calls
[11:01:54.004]             `[[` <- base::`[[`
[11:01:54.004]             `+` <- base::`+`
[11:01:54.004]             `<<-` <- base::`<<-`
[11:01:54.004]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.004]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.004]                   3L)]
[11:01:54.004]             }
[11:01:54.004]             function(cond) {
[11:01:54.004]                 is_error <- inherits(cond, "error")
[11:01:54.004]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.004]                   NULL)
[11:01:54.004]                 if (is_error) {
[11:01:54.004]                   sessionInformation <- function() {
[11:01:54.004]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.004]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.004]                       search = base::search(), system = base::Sys.info())
[11:01:54.004]                   }
[11:01:54.004]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.004]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.004]                     cond$call), session = sessionInformation(), 
[11:01:54.004]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.004]                   signalCondition(cond)
[11:01:54.004]                 }
[11:01:54.004]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.004]                 "immediateCondition"))) {
[11:01:54.004]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.004]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.004]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.004]                   if (TRUE && !signal) {
[11:01:54.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.004]                     {
[11:01:54.004]                       inherits <- base::inherits
[11:01:54.004]                       invokeRestart <- base::invokeRestart
[11:01:54.004]                       is.null <- base::is.null
[11:01:54.004]                       muffled <- FALSE
[11:01:54.004]                       if (inherits(cond, "message")) {
[11:01:54.004]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.004]                         if (muffled) 
[11:01:54.004]                           invokeRestart("muffleMessage")
[11:01:54.004]                       }
[11:01:54.004]                       else if (inherits(cond, "warning")) {
[11:01:54.004]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.004]                         if (muffled) 
[11:01:54.004]                           invokeRestart("muffleWarning")
[11:01:54.004]                       }
[11:01:54.004]                       else if (inherits(cond, "condition")) {
[11:01:54.004]                         if (!is.null(pattern)) {
[11:01:54.004]                           computeRestarts <- base::computeRestarts
[11:01:54.004]                           grepl <- base::grepl
[11:01:54.004]                           restarts <- computeRestarts(cond)
[11:01:54.004]                           for (restart in restarts) {
[11:01:54.004]                             name <- restart$name
[11:01:54.004]                             if (is.null(name)) 
[11:01:54.004]                               next
[11:01:54.004]                             if (!grepl(pattern, name)) 
[11:01:54.004]                               next
[11:01:54.004]                             invokeRestart(restart)
[11:01:54.004]                             muffled <- TRUE
[11:01:54.004]                             break
[11:01:54.004]                           }
[11:01:54.004]                         }
[11:01:54.004]                       }
[11:01:54.004]                       invisible(muffled)
[11:01:54.004]                     }
[11:01:54.004]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.004]                   }
[11:01:54.004]                 }
[11:01:54.004]                 else {
[11:01:54.004]                   if (TRUE) {
[11:01:54.004]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.004]                     {
[11:01:54.004]                       inherits <- base::inherits
[11:01:54.004]                       invokeRestart <- base::invokeRestart
[11:01:54.004]                       is.null <- base::is.null
[11:01:54.004]                       muffled <- FALSE
[11:01:54.004]                       if (inherits(cond, "message")) {
[11:01:54.004]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.004]                         if (muffled) 
[11:01:54.004]                           invokeRestart("muffleMessage")
[11:01:54.004]                       }
[11:01:54.004]                       else if (inherits(cond, "warning")) {
[11:01:54.004]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.004]                         if (muffled) 
[11:01:54.004]                           invokeRestart("muffleWarning")
[11:01:54.004]                       }
[11:01:54.004]                       else if (inherits(cond, "condition")) {
[11:01:54.004]                         if (!is.null(pattern)) {
[11:01:54.004]                           computeRestarts <- base::computeRestarts
[11:01:54.004]                           grepl <- base::grepl
[11:01:54.004]                           restarts <- computeRestarts(cond)
[11:01:54.004]                           for (restart in restarts) {
[11:01:54.004]                             name <- restart$name
[11:01:54.004]                             if (is.null(name)) 
[11:01:54.004]                               next
[11:01:54.004]                             if (!grepl(pattern, name)) 
[11:01:54.004]                               next
[11:01:54.004]                             invokeRestart(restart)
[11:01:54.004]                             muffled <- TRUE
[11:01:54.004]                             break
[11:01:54.004]                           }
[11:01:54.004]                         }
[11:01:54.004]                       }
[11:01:54.004]                       invisible(muffled)
[11:01:54.004]                     }
[11:01:54.004]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.004]                   }
[11:01:54.004]                 }
[11:01:54.004]             }
[11:01:54.004]         }))
[11:01:54.004]     }, error = function(ex) {
[11:01:54.004]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.004]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.004]                 ...future.rng), started = ...future.startTime, 
[11:01:54.004]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.004]             version = "1.8"), class = "FutureResult")
[11:01:54.004]     }, finally = {
[11:01:54.004]         if (!identical(...future.workdir, getwd())) 
[11:01:54.004]             setwd(...future.workdir)
[11:01:54.004]         {
[11:01:54.004]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.004]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.004]             }
[11:01:54.004]             base::options(...future.oldOptions)
[11:01:54.004]             if (.Platform$OS.type == "windows") {
[11:01:54.004]                 old_names <- names(...future.oldEnvVars)
[11:01:54.004]                 envs <- base::Sys.getenv()
[11:01:54.004]                 names <- names(envs)
[11:01:54.004]                 common <- intersect(names, old_names)
[11:01:54.004]                 added <- setdiff(names, old_names)
[11:01:54.004]                 removed <- setdiff(old_names, names)
[11:01:54.004]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.004]                   envs[common]]
[11:01:54.004]                 NAMES <- toupper(changed)
[11:01:54.004]                 args <- list()
[11:01:54.004]                 for (kk in seq_along(NAMES)) {
[11:01:54.004]                   name <- changed[[kk]]
[11:01:54.004]                   NAME <- NAMES[[kk]]
[11:01:54.004]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.004]                     next
[11:01:54.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.004]                 }
[11:01:54.004]                 NAMES <- toupper(added)
[11:01:54.004]                 for (kk in seq_along(NAMES)) {
[11:01:54.004]                   name <- added[[kk]]
[11:01:54.004]                   NAME <- NAMES[[kk]]
[11:01:54.004]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.004]                     next
[11:01:54.004]                   args[[name]] <- ""
[11:01:54.004]                 }
[11:01:54.004]                 NAMES <- toupper(removed)
[11:01:54.004]                 for (kk in seq_along(NAMES)) {
[11:01:54.004]                   name <- removed[[kk]]
[11:01:54.004]                   NAME <- NAMES[[kk]]
[11:01:54.004]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.004]                     next
[11:01:54.004]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.004]                 }
[11:01:54.004]                 if (length(args) > 0) 
[11:01:54.004]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.004]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.004]             }
[11:01:54.004]             else {
[11:01:54.004]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.004]             }
[11:01:54.004]             {
[11:01:54.004]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.004]                   0L) {
[11:01:54.004]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.004]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.004]                   base::options(opts)
[11:01:54.004]                 }
[11:01:54.004]                 {
[11:01:54.004]                   {
[11:01:54.004]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.004]                     NULL
[11:01:54.004]                   }
[11:01:54.004]                   options(future.plan = NULL)
[11:01:54.004]                   if (is.na(NA_character_)) 
[11:01:54.004]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.004]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.004]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.004]                     .init = FALSE)
[11:01:54.004]                 }
[11:01:54.004]             }
[11:01:54.004]         }
[11:01:54.004]     })
[11:01:54.004]     if (TRUE) {
[11:01:54.004]         base::sink(type = "output", split = FALSE)
[11:01:54.004]         if (TRUE) {
[11:01:54.004]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.004]         }
[11:01:54.004]         else {
[11:01:54.004]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.004]         }
[11:01:54.004]         base::close(...future.stdout)
[11:01:54.004]         ...future.stdout <- NULL
[11:01:54.004]     }
[11:01:54.004]     ...future.result$conditions <- ...future.conditions
[11:01:54.004]     ...future.result$finished <- base::Sys.time()
[11:01:54.004]     ...future.result
[11:01:54.004] }
[11:01:54.055] MultisessionFuture started
[11:01:54.055] result() for ClusterFuture ...
[11:01:54.056] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.056] - Validating connection of MultisessionFuture
[11:01:54.085] - received message: FutureResult
[11:01:54.086] - Received FutureResult
[11:01:54.086] - Erased future from FutureRegistry
[11:01:54.086] result() for ClusterFuture ...
[11:01:54.086] - result already collected: FutureResult
[11:01:54.086] result() for ClusterFuture ... done
[11:01:54.086] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.086] result() for ClusterFuture ... done
[11:01:54.086] result() for ClusterFuture ...
[11:01:54.086] - result already collected: FutureResult
[11:01:54.086] result() for ClusterFuture ... done
[11:01:54.087] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[11:01:54.088] plan(): nbrOfWorkers() = 2
Method for identifying globals: 'conservative' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.089] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.089] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.090] - globals found: [3] ‘{’, ‘<-’, ‘*’
[11:01:54.090] Searching for globals ... DONE
[11:01:54.090] Resolving globals: TRUE
[11:01:54.090] Resolving any globals that are futures ...
[11:01:54.090] - globals: [3] ‘{’, ‘<-’, ‘*’
[11:01:54.091] Resolving any globals that are futures ... DONE
[11:01:54.091] 
[11:01:54.091] 
[11:01:54.091] getGlobalsAndPackages() ... DONE
[11:01:54.091] run() for ‘Future’ ...
[11:01:54.091] - state: ‘created’
[11:01:54.091] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.105] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.106] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.106]   - Field: ‘node’
[11:01:54.106]   - Field: ‘label’
[11:01:54.106]   - Field: ‘local’
[11:01:54.106]   - Field: ‘owner’
[11:01:54.106]   - Field: ‘envir’
[11:01:54.106]   - Field: ‘workers’
[11:01:54.106]   - Field: ‘packages’
[11:01:54.106]   - Field: ‘gc’
[11:01:54.106]   - Field: ‘conditions’
[11:01:54.106]   - Field: ‘persistent’
[11:01:54.107]   - Field: ‘expr’
[11:01:54.107]   - Field: ‘uuid’
[11:01:54.107]   - Field: ‘seed’
[11:01:54.107]   - Field: ‘version’
[11:01:54.107]   - Field: ‘result’
[11:01:54.107]   - Field: ‘asynchronous’
[11:01:54.107]   - Field: ‘calls’
[11:01:54.107]   - Field: ‘globals’
[11:01:54.107]   - Field: ‘stdout’
[11:01:54.107]   - Field: ‘earlySignal’
[11:01:54.107]   - Field: ‘lazy’
[11:01:54.107]   - Field: ‘state’
[11:01:54.108] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.108] - Launch lazy future ...
[11:01:54.108] Packages needed by the future expression (n = 0): <none>
[11:01:54.108] Packages needed by future strategies (n = 0): <none>
[11:01:54.109] {
[11:01:54.109]     {
[11:01:54.109]         {
[11:01:54.109]             ...future.startTime <- base::Sys.time()
[11:01:54.109]             {
[11:01:54.109]                 {
[11:01:54.109]                   {
[11:01:54.109]                     {
[11:01:54.109]                       base::local({
[11:01:54.109]                         has_future <- base::requireNamespace("future", 
[11:01:54.109]                           quietly = TRUE)
[11:01:54.109]                         if (has_future) {
[11:01:54.109]                           ns <- base::getNamespace("future")
[11:01:54.109]                           version <- ns[[".package"]][["version"]]
[11:01:54.109]                           if (is.null(version)) 
[11:01:54.109]                             version <- utils::packageVersion("future")
[11:01:54.109]                         }
[11:01:54.109]                         else {
[11:01:54.109]                           version <- NULL
[11:01:54.109]                         }
[11:01:54.109]                         if (!has_future || version < "1.8.0") {
[11:01:54.109]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.109]                             "", base::R.version$version.string), 
[11:01:54.109]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.109]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.109]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.109]                               "release", "version")], collapse = " "), 
[11:01:54.109]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.109]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.109]                             info)
[11:01:54.109]                           info <- base::paste(info, collapse = "; ")
[11:01:54.109]                           if (!has_future) {
[11:01:54.109]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.109]                               info)
[11:01:54.109]                           }
[11:01:54.109]                           else {
[11:01:54.109]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.109]                               info, version)
[11:01:54.109]                           }
[11:01:54.109]                           base::stop(msg)
[11:01:54.109]                         }
[11:01:54.109]                       })
[11:01:54.109]                     }
[11:01:54.109]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.109]                     base::options(mc.cores = 1L)
[11:01:54.109]                   }
[11:01:54.109]                   ...future.strategy.old <- future::plan("list")
[11:01:54.109]                   options(future.plan = NULL)
[11:01:54.109]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.109]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.109]                 }
[11:01:54.109]                 ...future.workdir <- getwd()
[11:01:54.109]             }
[11:01:54.109]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.109]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.109]         }
[11:01:54.109]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.109]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.109]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.109]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.109]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.109]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.109]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.109]             base::names(...future.oldOptions))
[11:01:54.109]     }
[11:01:54.109]     if (FALSE) {
[11:01:54.109]     }
[11:01:54.109]     else {
[11:01:54.109]         if (TRUE) {
[11:01:54.109]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.109]                 open = "w")
[11:01:54.109]         }
[11:01:54.109]         else {
[11:01:54.109]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.109]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.109]         }
[11:01:54.109]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.109]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.109]             base::sink(type = "output", split = FALSE)
[11:01:54.109]             base::close(...future.stdout)
[11:01:54.109]         }, add = TRUE)
[11:01:54.109]     }
[11:01:54.109]     ...future.frame <- base::sys.nframe()
[11:01:54.109]     ...future.conditions <- base::list()
[11:01:54.109]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.109]     if (FALSE) {
[11:01:54.109]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.109]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.109]     }
[11:01:54.109]     ...future.result <- base::tryCatch({
[11:01:54.109]         base::withCallingHandlers({
[11:01:54.109]             ...future.value <- base::withVisible(base::local({
[11:01:54.109]                 ...future.makeSendCondition <- base::local({
[11:01:54.109]                   sendCondition <- NULL
[11:01:54.109]                   function(frame = 1L) {
[11:01:54.109]                     if (is.function(sendCondition)) 
[11:01:54.109]                       return(sendCondition)
[11:01:54.109]                     ns <- getNamespace("parallel")
[11:01:54.109]                     if (exists("sendData", mode = "function", 
[11:01:54.109]                       envir = ns)) {
[11:01:54.109]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.109]                         envir = ns)
[11:01:54.109]                       envir <- sys.frame(frame)
[11:01:54.109]                       master <- NULL
[11:01:54.109]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.109]                         !identical(envir, emptyenv())) {
[11:01:54.109]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.109]                           inherits = FALSE)) {
[11:01:54.109]                           master <- get("master", mode = "list", 
[11:01:54.109]                             envir = envir, inherits = FALSE)
[11:01:54.109]                           if (inherits(master, c("SOCKnode", 
[11:01:54.109]                             "SOCK0node"))) {
[11:01:54.109]                             sendCondition <<- function(cond) {
[11:01:54.109]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.109]                                 success = TRUE)
[11:01:54.109]                               parallel_sendData(master, data)
[11:01:54.109]                             }
[11:01:54.109]                             return(sendCondition)
[11:01:54.109]                           }
[11:01:54.109]                         }
[11:01:54.109]                         frame <- frame + 1L
[11:01:54.109]                         envir <- sys.frame(frame)
[11:01:54.109]                       }
[11:01:54.109]                     }
[11:01:54.109]                     sendCondition <<- function(cond) NULL
[11:01:54.109]                   }
[11:01:54.109]                 })
[11:01:54.109]                 withCallingHandlers({
[11:01:54.109]                   {
[11:01:54.109]                     b <- a
[11:01:54.109]                     a <- 2
[11:01:54.109]                     a * b
[11:01:54.109]                   }
[11:01:54.109]                 }, immediateCondition = function(cond) {
[11:01:54.109]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.109]                   sendCondition(cond)
[11:01:54.109]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.109]                   {
[11:01:54.109]                     inherits <- base::inherits
[11:01:54.109]                     invokeRestart <- base::invokeRestart
[11:01:54.109]                     is.null <- base::is.null
[11:01:54.109]                     muffled <- FALSE
[11:01:54.109]                     if (inherits(cond, "message")) {
[11:01:54.109]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.109]                       if (muffled) 
[11:01:54.109]                         invokeRestart("muffleMessage")
[11:01:54.109]                     }
[11:01:54.109]                     else if (inherits(cond, "warning")) {
[11:01:54.109]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.109]                       if (muffled) 
[11:01:54.109]                         invokeRestart("muffleWarning")
[11:01:54.109]                     }
[11:01:54.109]                     else if (inherits(cond, "condition")) {
[11:01:54.109]                       if (!is.null(pattern)) {
[11:01:54.109]                         computeRestarts <- base::computeRestarts
[11:01:54.109]                         grepl <- base::grepl
[11:01:54.109]                         restarts <- computeRestarts(cond)
[11:01:54.109]                         for (restart in restarts) {
[11:01:54.109]                           name <- restart$name
[11:01:54.109]                           if (is.null(name)) 
[11:01:54.109]                             next
[11:01:54.109]                           if (!grepl(pattern, name)) 
[11:01:54.109]                             next
[11:01:54.109]                           invokeRestart(restart)
[11:01:54.109]                           muffled <- TRUE
[11:01:54.109]                           break
[11:01:54.109]                         }
[11:01:54.109]                       }
[11:01:54.109]                     }
[11:01:54.109]                     invisible(muffled)
[11:01:54.109]                   }
[11:01:54.109]                   muffleCondition(cond)
[11:01:54.109]                 })
[11:01:54.109]             }))
[11:01:54.109]             future::FutureResult(value = ...future.value$value, 
[11:01:54.109]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.109]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.109]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.109]                     ...future.globalenv.names))
[11:01:54.109]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.109]         }, condition = base::local({
[11:01:54.109]             c <- base::c
[11:01:54.109]             inherits <- base::inherits
[11:01:54.109]             invokeRestart <- base::invokeRestart
[11:01:54.109]             length <- base::length
[11:01:54.109]             list <- base::list
[11:01:54.109]             seq.int <- base::seq.int
[11:01:54.109]             signalCondition <- base::signalCondition
[11:01:54.109]             sys.calls <- base::sys.calls
[11:01:54.109]             `[[` <- base::`[[`
[11:01:54.109]             `+` <- base::`+`
[11:01:54.109]             `<<-` <- base::`<<-`
[11:01:54.109]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.109]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.109]                   3L)]
[11:01:54.109]             }
[11:01:54.109]             function(cond) {
[11:01:54.109]                 is_error <- inherits(cond, "error")
[11:01:54.109]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.109]                   NULL)
[11:01:54.109]                 if (is_error) {
[11:01:54.109]                   sessionInformation <- function() {
[11:01:54.109]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.109]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.109]                       search = base::search(), system = base::Sys.info())
[11:01:54.109]                   }
[11:01:54.109]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.109]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.109]                     cond$call), session = sessionInformation(), 
[11:01:54.109]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.109]                   signalCondition(cond)
[11:01:54.109]                 }
[11:01:54.109]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.109]                 "immediateCondition"))) {
[11:01:54.109]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.109]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.109]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.109]                   if (TRUE && !signal) {
[11:01:54.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.109]                     {
[11:01:54.109]                       inherits <- base::inherits
[11:01:54.109]                       invokeRestart <- base::invokeRestart
[11:01:54.109]                       is.null <- base::is.null
[11:01:54.109]                       muffled <- FALSE
[11:01:54.109]                       if (inherits(cond, "message")) {
[11:01:54.109]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.109]                         if (muffled) 
[11:01:54.109]                           invokeRestart("muffleMessage")
[11:01:54.109]                       }
[11:01:54.109]                       else if (inherits(cond, "warning")) {
[11:01:54.109]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.109]                         if (muffled) 
[11:01:54.109]                           invokeRestart("muffleWarning")
[11:01:54.109]                       }
[11:01:54.109]                       else if (inherits(cond, "condition")) {
[11:01:54.109]                         if (!is.null(pattern)) {
[11:01:54.109]                           computeRestarts <- base::computeRestarts
[11:01:54.109]                           grepl <- base::grepl
[11:01:54.109]                           restarts <- computeRestarts(cond)
[11:01:54.109]                           for (restart in restarts) {
[11:01:54.109]                             name <- restart$name
[11:01:54.109]                             if (is.null(name)) 
[11:01:54.109]                               next
[11:01:54.109]                             if (!grepl(pattern, name)) 
[11:01:54.109]                               next
[11:01:54.109]                             invokeRestart(restart)
[11:01:54.109]                             muffled <- TRUE
[11:01:54.109]                             break
[11:01:54.109]                           }
[11:01:54.109]                         }
[11:01:54.109]                       }
[11:01:54.109]                       invisible(muffled)
[11:01:54.109]                     }
[11:01:54.109]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.109]                   }
[11:01:54.109]                 }
[11:01:54.109]                 else {
[11:01:54.109]                   if (TRUE) {
[11:01:54.109]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.109]                     {
[11:01:54.109]                       inherits <- base::inherits
[11:01:54.109]                       invokeRestart <- base::invokeRestart
[11:01:54.109]                       is.null <- base::is.null
[11:01:54.109]                       muffled <- FALSE
[11:01:54.109]                       if (inherits(cond, "message")) {
[11:01:54.109]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.109]                         if (muffled) 
[11:01:54.109]                           invokeRestart("muffleMessage")
[11:01:54.109]                       }
[11:01:54.109]                       else if (inherits(cond, "warning")) {
[11:01:54.109]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.109]                         if (muffled) 
[11:01:54.109]                           invokeRestart("muffleWarning")
[11:01:54.109]                       }
[11:01:54.109]                       else if (inherits(cond, "condition")) {
[11:01:54.109]                         if (!is.null(pattern)) {
[11:01:54.109]                           computeRestarts <- base::computeRestarts
[11:01:54.109]                           grepl <- base::grepl
[11:01:54.109]                           restarts <- computeRestarts(cond)
[11:01:54.109]                           for (restart in restarts) {
[11:01:54.109]                             name <- restart$name
[11:01:54.109]                             if (is.null(name)) 
[11:01:54.109]                               next
[11:01:54.109]                             if (!grepl(pattern, name)) 
[11:01:54.109]                               next
[11:01:54.109]                             invokeRestart(restart)
[11:01:54.109]                             muffled <- TRUE
[11:01:54.109]                             break
[11:01:54.109]                           }
[11:01:54.109]                         }
[11:01:54.109]                       }
[11:01:54.109]                       invisible(muffled)
[11:01:54.109]                     }
[11:01:54.109]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.109]                   }
[11:01:54.109]                 }
[11:01:54.109]             }
[11:01:54.109]         }))
[11:01:54.109]     }, error = function(ex) {
[11:01:54.109]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.109]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.109]                 ...future.rng), started = ...future.startTime, 
[11:01:54.109]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.109]             version = "1.8"), class = "FutureResult")
[11:01:54.109]     }, finally = {
[11:01:54.109]         if (!identical(...future.workdir, getwd())) 
[11:01:54.109]             setwd(...future.workdir)
[11:01:54.109]         {
[11:01:54.109]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.109]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.109]             }
[11:01:54.109]             base::options(...future.oldOptions)
[11:01:54.109]             if (.Platform$OS.type == "windows") {
[11:01:54.109]                 old_names <- names(...future.oldEnvVars)
[11:01:54.109]                 envs <- base::Sys.getenv()
[11:01:54.109]                 names <- names(envs)
[11:01:54.109]                 common <- intersect(names, old_names)
[11:01:54.109]                 added <- setdiff(names, old_names)
[11:01:54.109]                 removed <- setdiff(old_names, names)
[11:01:54.109]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.109]                   envs[common]]
[11:01:54.109]                 NAMES <- toupper(changed)
[11:01:54.109]                 args <- list()
[11:01:54.109]                 for (kk in seq_along(NAMES)) {
[11:01:54.109]                   name <- changed[[kk]]
[11:01:54.109]                   NAME <- NAMES[[kk]]
[11:01:54.109]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.109]                     next
[11:01:54.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.109]                 }
[11:01:54.109]                 NAMES <- toupper(added)
[11:01:54.109]                 for (kk in seq_along(NAMES)) {
[11:01:54.109]                   name <- added[[kk]]
[11:01:54.109]                   NAME <- NAMES[[kk]]
[11:01:54.109]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.109]                     next
[11:01:54.109]                   args[[name]] <- ""
[11:01:54.109]                 }
[11:01:54.109]                 NAMES <- toupper(removed)
[11:01:54.109]                 for (kk in seq_along(NAMES)) {
[11:01:54.109]                   name <- removed[[kk]]
[11:01:54.109]                   NAME <- NAMES[[kk]]
[11:01:54.109]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.109]                     next
[11:01:54.109]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.109]                 }
[11:01:54.109]                 if (length(args) > 0) 
[11:01:54.109]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.109]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.109]             }
[11:01:54.109]             else {
[11:01:54.109]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.109]             }
[11:01:54.109]             {
[11:01:54.109]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.109]                   0L) {
[11:01:54.109]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.109]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.109]                   base::options(opts)
[11:01:54.109]                 }
[11:01:54.109]                 {
[11:01:54.109]                   {
[11:01:54.109]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.109]                     NULL
[11:01:54.109]                   }
[11:01:54.109]                   options(future.plan = NULL)
[11:01:54.109]                   if (is.na(NA_character_)) 
[11:01:54.109]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.109]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.109]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.109]                     .init = FALSE)
[11:01:54.109]                 }
[11:01:54.109]             }
[11:01:54.109]         }
[11:01:54.109]     })
[11:01:54.109]     if (TRUE) {
[11:01:54.109]         base::sink(type = "output", split = FALSE)
[11:01:54.109]         if (TRUE) {
[11:01:54.109]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.109]         }
[11:01:54.109]         else {
[11:01:54.109]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.109]         }
[11:01:54.109]         base::close(...future.stdout)
[11:01:54.109]         ...future.stdout <- NULL
[11:01:54.109]     }
[11:01:54.109]     ...future.result$conditions <- ...future.conditions
[11:01:54.109]     ...future.result$finished <- base::Sys.time()
[11:01:54.109]     ...future.result
[11:01:54.109] }
[11:01:54.111] MultisessionFuture started
[11:01:54.112] - Launch lazy future ... done
[11:01:54.112] run() for ‘MultisessionFuture’ ... done
[11:01:54.112] result() for ClusterFuture ...
[11:01:54.112] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.112] - Validating connection of MultisessionFuture
[11:01:54.156] - received message: FutureResult
[11:01:54.157] - Received FutureResult
[11:01:54.157] - Erased future from FutureRegistry
[11:01:54.157] result() for ClusterFuture ...
[11:01:54.157] - result already collected: FutureResult
[11:01:54.157] result() for ClusterFuture ... done
[11:01:54.157] signalConditions() ...
[11:01:54.157]  - include = ‘immediateCondition’
[11:01:54.157]  - exclude = 
[11:01:54.157]  - resignal = FALSE
[11:01:54.158]  - Number of conditions: 1
[11:01:54.158] signalConditions() ... done
[11:01:54.158] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.158] result() for ClusterFuture ... done
[11:01:54.158] result() for ClusterFuture ...
[11:01:54.158] - result already collected: FutureResult
[11:01:54.158] result() for ClusterFuture ... done
[11:01:54.158] signalConditions() ...
[11:01:54.158]  - include = ‘immediateCondition’
[11:01:54.158]  - exclude = 
[11:01:54.158]  - resignal = FALSE
[11:01:54.158]  - Number of conditions: 1
[11:01:54.159] signalConditions() ... done
[11:01:54.159] Future state: ‘finished’
[11:01:54.159] result() for ClusterFuture ...
[11:01:54.159] - result already collected: FutureResult
[11:01:54.159] result() for ClusterFuture ... done
[11:01:54.159] signalConditions() ...
[11:01:54.159]  - include = ‘condition’
[11:01:54.159]  - exclude = ‘immediateCondition’
[11:01:54.159]  - resignal = TRUE
[11:01:54.159]  - Number of conditions: 1
[11:01:54.159]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:54.160] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:54"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.174] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.174] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.176] - globals found: [3] ‘{’, ‘<-’, ‘*’
[11:01:54.176] Searching for globals ... DONE
[11:01:54.176] Resolving globals: TRUE
[11:01:54.176] Resolving any globals that are futures ...
[11:01:54.176] - globals: [3] ‘{’, ‘<-’, ‘*’
[11:01:54.176] Resolving any globals that are futures ... DONE
[11:01:54.177] 
[11:01:54.177] 
[11:01:54.177] getGlobalsAndPackages() ... DONE
[11:01:54.177] run() for ‘Future’ ...
[11:01:54.177] - state: ‘created’
[11:01:54.178] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.192] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.192] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.192]   - Field: ‘node’
[11:01:54.193]   - Field: ‘label’
[11:01:54.193]   - Field: ‘local’
[11:01:54.193]   - Field: ‘owner’
[11:01:54.193]   - Field: ‘envir’
[11:01:54.193]   - Field: ‘workers’
[11:01:54.193]   - Field: ‘packages’
[11:01:54.193]   - Field: ‘gc’
[11:01:54.193]   - Field: ‘conditions’
[11:01:54.193]   - Field: ‘persistent’
[11:01:54.193]   - Field: ‘expr’
[11:01:54.193]   - Field: ‘uuid’
[11:01:54.194]   - Field: ‘seed’
[11:01:54.194]   - Field: ‘version’
[11:01:54.194]   - Field: ‘result’
[11:01:54.194]   - Field: ‘asynchronous’
[11:01:54.194]   - Field: ‘calls’
[11:01:54.194]   - Field: ‘globals’
[11:01:54.194]   - Field: ‘stdout’
[11:01:54.194]   - Field: ‘earlySignal’
[11:01:54.194]   - Field: ‘lazy’
[11:01:54.195]   - Field: ‘state’
[11:01:54.195] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.195] - Launch lazy future ...
[11:01:54.195] Packages needed by the future expression (n = 0): <none>
[11:01:54.195] Packages needed by future strategies (n = 0): <none>
[11:01:54.196] {
[11:01:54.196]     {
[11:01:54.196]         {
[11:01:54.196]             ...future.startTime <- base::Sys.time()
[11:01:54.196]             {
[11:01:54.196]                 {
[11:01:54.196]                   {
[11:01:54.196]                     {
[11:01:54.196]                       base::local({
[11:01:54.196]                         has_future <- base::requireNamespace("future", 
[11:01:54.196]                           quietly = TRUE)
[11:01:54.196]                         if (has_future) {
[11:01:54.196]                           ns <- base::getNamespace("future")
[11:01:54.196]                           version <- ns[[".package"]][["version"]]
[11:01:54.196]                           if (is.null(version)) 
[11:01:54.196]                             version <- utils::packageVersion("future")
[11:01:54.196]                         }
[11:01:54.196]                         else {
[11:01:54.196]                           version <- NULL
[11:01:54.196]                         }
[11:01:54.196]                         if (!has_future || version < "1.8.0") {
[11:01:54.196]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.196]                             "", base::R.version$version.string), 
[11:01:54.196]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.196]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.196]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.196]                               "release", "version")], collapse = " "), 
[11:01:54.196]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.196]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.196]                             info)
[11:01:54.196]                           info <- base::paste(info, collapse = "; ")
[11:01:54.196]                           if (!has_future) {
[11:01:54.196]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.196]                               info)
[11:01:54.196]                           }
[11:01:54.196]                           else {
[11:01:54.196]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.196]                               info, version)
[11:01:54.196]                           }
[11:01:54.196]                           base::stop(msg)
[11:01:54.196]                         }
[11:01:54.196]                       })
[11:01:54.196]                     }
[11:01:54.196]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.196]                     base::options(mc.cores = 1L)
[11:01:54.196]                   }
[11:01:54.196]                   ...future.strategy.old <- future::plan("list")
[11:01:54.196]                   options(future.plan = NULL)
[11:01:54.196]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.196]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.196]                 }
[11:01:54.196]                 ...future.workdir <- getwd()
[11:01:54.196]             }
[11:01:54.196]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.196]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.196]         }
[11:01:54.196]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.196]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.196]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.196]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.196]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.196]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.196]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.196]             base::names(...future.oldOptions))
[11:01:54.196]     }
[11:01:54.196]     if (FALSE) {
[11:01:54.196]     }
[11:01:54.196]     else {
[11:01:54.196]         if (TRUE) {
[11:01:54.196]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.196]                 open = "w")
[11:01:54.196]         }
[11:01:54.196]         else {
[11:01:54.196]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.196]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.196]         }
[11:01:54.196]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.196]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.196]             base::sink(type = "output", split = FALSE)
[11:01:54.196]             base::close(...future.stdout)
[11:01:54.196]         }, add = TRUE)
[11:01:54.196]     }
[11:01:54.196]     ...future.frame <- base::sys.nframe()
[11:01:54.196]     ...future.conditions <- base::list()
[11:01:54.196]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.196]     if (FALSE) {
[11:01:54.196]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.196]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.196]     }
[11:01:54.196]     ...future.result <- base::tryCatch({
[11:01:54.196]         base::withCallingHandlers({
[11:01:54.196]             ...future.value <- base::withVisible(base::local({
[11:01:54.196]                 ...future.makeSendCondition <- base::local({
[11:01:54.196]                   sendCondition <- NULL
[11:01:54.196]                   function(frame = 1L) {
[11:01:54.196]                     if (is.function(sendCondition)) 
[11:01:54.196]                       return(sendCondition)
[11:01:54.196]                     ns <- getNamespace("parallel")
[11:01:54.196]                     if (exists("sendData", mode = "function", 
[11:01:54.196]                       envir = ns)) {
[11:01:54.196]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.196]                         envir = ns)
[11:01:54.196]                       envir <- sys.frame(frame)
[11:01:54.196]                       master <- NULL
[11:01:54.196]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.196]                         !identical(envir, emptyenv())) {
[11:01:54.196]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.196]                           inherits = FALSE)) {
[11:01:54.196]                           master <- get("master", mode = "list", 
[11:01:54.196]                             envir = envir, inherits = FALSE)
[11:01:54.196]                           if (inherits(master, c("SOCKnode", 
[11:01:54.196]                             "SOCK0node"))) {
[11:01:54.196]                             sendCondition <<- function(cond) {
[11:01:54.196]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.196]                                 success = TRUE)
[11:01:54.196]                               parallel_sendData(master, data)
[11:01:54.196]                             }
[11:01:54.196]                             return(sendCondition)
[11:01:54.196]                           }
[11:01:54.196]                         }
[11:01:54.196]                         frame <- frame + 1L
[11:01:54.196]                         envir <- sys.frame(frame)
[11:01:54.196]                       }
[11:01:54.196]                     }
[11:01:54.196]                     sendCondition <<- function(cond) NULL
[11:01:54.196]                   }
[11:01:54.196]                 })
[11:01:54.196]                 withCallingHandlers({
[11:01:54.196]                   {
[11:01:54.196]                     b <- a
[11:01:54.196]                     a <- 2
[11:01:54.196]                     a * b
[11:01:54.196]                   }
[11:01:54.196]                 }, immediateCondition = function(cond) {
[11:01:54.196]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.196]                   sendCondition(cond)
[11:01:54.196]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.196]                   {
[11:01:54.196]                     inherits <- base::inherits
[11:01:54.196]                     invokeRestart <- base::invokeRestart
[11:01:54.196]                     is.null <- base::is.null
[11:01:54.196]                     muffled <- FALSE
[11:01:54.196]                     if (inherits(cond, "message")) {
[11:01:54.196]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.196]                       if (muffled) 
[11:01:54.196]                         invokeRestart("muffleMessage")
[11:01:54.196]                     }
[11:01:54.196]                     else if (inherits(cond, "warning")) {
[11:01:54.196]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.196]                       if (muffled) 
[11:01:54.196]                         invokeRestart("muffleWarning")
[11:01:54.196]                     }
[11:01:54.196]                     else if (inherits(cond, "condition")) {
[11:01:54.196]                       if (!is.null(pattern)) {
[11:01:54.196]                         computeRestarts <- base::computeRestarts
[11:01:54.196]                         grepl <- base::grepl
[11:01:54.196]                         restarts <- computeRestarts(cond)
[11:01:54.196]                         for (restart in restarts) {
[11:01:54.196]                           name <- restart$name
[11:01:54.196]                           if (is.null(name)) 
[11:01:54.196]                             next
[11:01:54.196]                           if (!grepl(pattern, name)) 
[11:01:54.196]                             next
[11:01:54.196]                           invokeRestart(restart)
[11:01:54.196]                           muffled <- TRUE
[11:01:54.196]                           break
[11:01:54.196]                         }
[11:01:54.196]                       }
[11:01:54.196]                     }
[11:01:54.196]                     invisible(muffled)
[11:01:54.196]                   }
[11:01:54.196]                   muffleCondition(cond)
[11:01:54.196]                 })
[11:01:54.196]             }))
[11:01:54.196]             future::FutureResult(value = ...future.value$value, 
[11:01:54.196]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.196]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.196]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.196]                     ...future.globalenv.names))
[11:01:54.196]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.196]         }, condition = base::local({
[11:01:54.196]             c <- base::c
[11:01:54.196]             inherits <- base::inherits
[11:01:54.196]             invokeRestart <- base::invokeRestart
[11:01:54.196]             length <- base::length
[11:01:54.196]             list <- base::list
[11:01:54.196]             seq.int <- base::seq.int
[11:01:54.196]             signalCondition <- base::signalCondition
[11:01:54.196]             sys.calls <- base::sys.calls
[11:01:54.196]             `[[` <- base::`[[`
[11:01:54.196]             `+` <- base::`+`
[11:01:54.196]             `<<-` <- base::`<<-`
[11:01:54.196]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.196]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.196]                   3L)]
[11:01:54.196]             }
[11:01:54.196]             function(cond) {
[11:01:54.196]                 is_error <- inherits(cond, "error")
[11:01:54.196]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.196]                   NULL)
[11:01:54.196]                 if (is_error) {
[11:01:54.196]                   sessionInformation <- function() {
[11:01:54.196]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.196]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.196]                       search = base::search(), system = base::Sys.info())
[11:01:54.196]                   }
[11:01:54.196]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.196]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.196]                     cond$call), session = sessionInformation(), 
[11:01:54.196]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.196]                   signalCondition(cond)
[11:01:54.196]                 }
[11:01:54.196]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.196]                 "immediateCondition"))) {
[11:01:54.196]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.196]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.196]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.196]                   if (TRUE && !signal) {
[11:01:54.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.196]                     {
[11:01:54.196]                       inherits <- base::inherits
[11:01:54.196]                       invokeRestart <- base::invokeRestart
[11:01:54.196]                       is.null <- base::is.null
[11:01:54.196]                       muffled <- FALSE
[11:01:54.196]                       if (inherits(cond, "message")) {
[11:01:54.196]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.196]                         if (muffled) 
[11:01:54.196]                           invokeRestart("muffleMessage")
[11:01:54.196]                       }
[11:01:54.196]                       else if (inherits(cond, "warning")) {
[11:01:54.196]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.196]                         if (muffled) 
[11:01:54.196]                           invokeRestart("muffleWarning")
[11:01:54.196]                       }
[11:01:54.196]                       else if (inherits(cond, "condition")) {
[11:01:54.196]                         if (!is.null(pattern)) {
[11:01:54.196]                           computeRestarts <- base::computeRestarts
[11:01:54.196]                           grepl <- base::grepl
[11:01:54.196]                           restarts <- computeRestarts(cond)
[11:01:54.196]                           for (restart in restarts) {
[11:01:54.196]                             name <- restart$name
[11:01:54.196]                             if (is.null(name)) 
[11:01:54.196]                               next
[11:01:54.196]                             if (!grepl(pattern, name)) 
[11:01:54.196]                               next
[11:01:54.196]                             invokeRestart(restart)
[11:01:54.196]                             muffled <- TRUE
[11:01:54.196]                             break
[11:01:54.196]                           }
[11:01:54.196]                         }
[11:01:54.196]                       }
[11:01:54.196]                       invisible(muffled)
[11:01:54.196]                     }
[11:01:54.196]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.196]                   }
[11:01:54.196]                 }
[11:01:54.196]                 else {
[11:01:54.196]                   if (TRUE) {
[11:01:54.196]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.196]                     {
[11:01:54.196]                       inherits <- base::inherits
[11:01:54.196]                       invokeRestart <- base::invokeRestart
[11:01:54.196]                       is.null <- base::is.null
[11:01:54.196]                       muffled <- FALSE
[11:01:54.196]                       if (inherits(cond, "message")) {
[11:01:54.196]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.196]                         if (muffled) 
[11:01:54.196]                           invokeRestart("muffleMessage")
[11:01:54.196]                       }
[11:01:54.196]                       else if (inherits(cond, "warning")) {
[11:01:54.196]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.196]                         if (muffled) 
[11:01:54.196]                           invokeRestart("muffleWarning")
[11:01:54.196]                       }
[11:01:54.196]                       else if (inherits(cond, "condition")) {
[11:01:54.196]                         if (!is.null(pattern)) {
[11:01:54.196]                           computeRestarts <- base::computeRestarts
[11:01:54.196]                           grepl <- base::grepl
[11:01:54.196]                           restarts <- computeRestarts(cond)
[11:01:54.196]                           for (restart in restarts) {
[11:01:54.196]                             name <- restart$name
[11:01:54.196]                             if (is.null(name)) 
[11:01:54.196]                               next
[11:01:54.196]                             if (!grepl(pattern, name)) 
[11:01:54.196]                               next
[11:01:54.196]                             invokeRestart(restart)
[11:01:54.196]                             muffled <- TRUE
[11:01:54.196]                             break
[11:01:54.196]                           }
[11:01:54.196]                         }
[11:01:54.196]                       }
[11:01:54.196]                       invisible(muffled)
[11:01:54.196]                     }
[11:01:54.196]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.196]                   }
[11:01:54.196]                 }
[11:01:54.196]             }
[11:01:54.196]         }))
[11:01:54.196]     }, error = function(ex) {
[11:01:54.196]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.196]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.196]                 ...future.rng), started = ...future.startTime, 
[11:01:54.196]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.196]             version = "1.8"), class = "FutureResult")
[11:01:54.196]     }, finally = {
[11:01:54.196]         if (!identical(...future.workdir, getwd())) 
[11:01:54.196]             setwd(...future.workdir)
[11:01:54.196]         {
[11:01:54.196]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.196]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.196]             }
[11:01:54.196]             base::options(...future.oldOptions)
[11:01:54.196]             if (.Platform$OS.type == "windows") {
[11:01:54.196]                 old_names <- names(...future.oldEnvVars)
[11:01:54.196]                 envs <- base::Sys.getenv()
[11:01:54.196]                 names <- names(envs)
[11:01:54.196]                 common <- intersect(names, old_names)
[11:01:54.196]                 added <- setdiff(names, old_names)
[11:01:54.196]                 removed <- setdiff(old_names, names)
[11:01:54.196]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.196]                   envs[common]]
[11:01:54.196]                 NAMES <- toupper(changed)
[11:01:54.196]                 args <- list()
[11:01:54.196]                 for (kk in seq_along(NAMES)) {
[11:01:54.196]                   name <- changed[[kk]]
[11:01:54.196]                   NAME <- NAMES[[kk]]
[11:01:54.196]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.196]                     next
[11:01:54.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.196]                 }
[11:01:54.196]                 NAMES <- toupper(added)
[11:01:54.196]                 for (kk in seq_along(NAMES)) {
[11:01:54.196]                   name <- added[[kk]]
[11:01:54.196]                   NAME <- NAMES[[kk]]
[11:01:54.196]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.196]                     next
[11:01:54.196]                   args[[name]] <- ""
[11:01:54.196]                 }
[11:01:54.196]                 NAMES <- toupper(removed)
[11:01:54.196]                 for (kk in seq_along(NAMES)) {
[11:01:54.196]                   name <- removed[[kk]]
[11:01:54.196]                   NAME <- NAMES[[kk]]
[11:01:54.196]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.196]                     next
[11:01:54.196]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.196]                 }
[11:01:54.196]                 if (length(args) > 0) 
[11:01:54.196]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.196]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.196]             }
[11:01:54.196]             else {
[11:01:54.196]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.196]             }
[11:01:54.196]             {
[11:01:54.196]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.196]                   0L) {
[11:01:54.196]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.196]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.196]                   base::options(opts)
[11:01:54.196]                 }
[11:01:54.196]                 {
[11:01:54.196]                   {
[11:01:54.196]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.196]                     NULL
[11:01:54.196]                   }
[11:01:54.196]                   options(future.plan = NULL)
[11:01:54.196]                   if (is.na(NA_character_)) 
[11:01:54.196]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.196]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.196]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.196]                     .init = FALSE)
[11:01:54.196]                 }
[11:01:54.196]             }
[11:01:54.196]         }
[11:01:54.196]     })
[11:01:54.196]     if (TRUE) {
[11:01:54.196]         base::sink(type = "output", split = FALSE)
[11:01:54.196]         if (TRUE) {
[11:01:54.196]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.196]         }
[11:01:54.196]         else {
[11:01:54.196]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.196]         }
[11:01:54.196]         base::close(...future.stdout)
[11:01:54.196]         ...future.stdout <- NULL
[11:01:54.196]     }
[11:01:54.196]     ...future.result$conditions <- ...future.conditions
[11:01:54.196]     ...future.result$finished <- base::Sys.time()
[11:01:54.196]     ...future.result
[11:01:54.196] }
[11:01:54.199] MultisessionFuture started
[11:01:54.199] - Launch lazy future ... done
[11:01:54.199] run() for ‘MultisessionFuture’ ... done
[11:01:54.199] result() for ClusterFuture ...
[11:01:54.199] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.200] - Validating connection of MultisessionFuture
[11:01:54.241] - received message: FutureResult
[11:01:54.242] - Received FutureResult
[11:01:54.242] - Erased future from FutureRegistry
[11:01:54.242] result() for ClusterFuture ...
[11:01:54.242] - result already collected: FutureResult
[11:01:54.242] result() for ClusterFuture ... done
[11:01:54.242] signalConditions() ...
[11:01:54.242]  - include = ‘immediateCondition’
[11:01:54.242]  - exclude = 
[11:01:54.242]  - resignal = FALSE
[11:01:54.243]  - Number of conditions: 1
[11:01:54.243] signalConditions() ... done
[11:01:54.243] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.243] result() for ClusterFuture ... done
[11:01:54.243] result() for ClusterFuture ...
[11:01:54.243] - result already collected: FutureResult
[11:01:54.243] result() for ClusterFuture ... done
[11:01:54.243] signalConditions() ...
[11:01:54.243]  - include = ‘immediateCondition’
[11:01:54.243]  - exclude = 
[11:01:54.244]  - resignal = FALSE
[11:01:54.244]  - Number of conditions: 1
[11:01:54.244] signalConditions() ... done
[11:01:54.244] Future state: ‘finished’
[11:01:54.244] result() for ClusterFuture ...
[11:01:54.244] - result already collected: FutureResult
[11:01:54.244] result() for ClusterFuture ... done
[11:01:54.244] signalConditions() ...
[11:01:54.244]  - include = ‘condition’
[11:01:54.245]  - exclude = ‘immediateCondition’
[11:01:54.245]  - resignal = TRUE
[11:01:54.245]  - Number of conditions: 1
[11:01:54.245]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:54.245] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language y %<-% {     b <- a ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:54"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.261] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.262] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.263] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.263] Searching for globals ... DONE
[11:01:54.263] Resolving globals: TRUE
[11:01:54.264] Resolving any globals that are futures ...
[11:01:54.264] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.264] Resolving any globals that are futures ... DONE
[11:01:54.264] Resolving futures part of globals (recursively) ...
[11:01:54.264] resolve() on list ...
[11:01:54.265]  recursive: 99
[11:01:54.265]  length: 1
[11:01:54.265]  elements: ‘ii’
[11:01:54.265]  length: 0 (resolved future 1)
[11:01:54.265] resolve() on list ... DONE
[11:01:54.265] - globals: [1] ‘ii’
[11:01:54.265] Resolving futures part of globals (recursively) ... DONE
[11:01:54.265] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:54.266] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:54.266] - globals: [1] ‘ii’
[11:01:54.266] 
[11:01:54.266] getGlobalsAndPackages() ... DONE
[11:01:54.266] run() for ‘Future’ ...
[11:01:54.267] - state: ‘created’
[11:01:54.267] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.283] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.283] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.283]   - Field: ‘node’
[11:01:54.283]   - Field: ‘label’
[11:01:54.283]   - Field: ‘local’
[11:01:54.284]   - Field: ‘owner’
[11:01:54.284]   - Field: ‘envir’
[11:01:54.284]   - Field: ‘workers’
[11:01:54.284]   - Field: ‘packages’
[11:01:54.284]   - Field: ‘gc’
[11:01:54.284]   - Field: ‘conditions’
[11:01:54.284]   - Field: ‘persistent’
[11:01:54.284]   - Field: ‘expr’
[11:01:54.284]   - Field: ‘uuid’
[11:01:54.284]   - Field: ‘seed’
[11:01:54.284]   - Field: ‘version’
[11:01:54.284]   - Field: ‘result’
[11:01:54.285]   - Field: ‘asynchronous’
[11:01:54.285]   - Field: ‘calls’
[11:01:54.285]   - Field: ‘globals’
[11:01:54.285]   - Field: ‘stdout’
[11:01:54.285]   - Field: ‘earlySignal’
[11:01:54.285]   - Field: ‘lazy’
[11:01:54.285]   - Field: ‘state’
[11:01:54.285] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.285] - Launch lazy future ...
[11:01:54.285] Packages needed by the future expression (n = 0): <none>
[11:01:54.286] Packages needed by future strategies (n = 0): <none>
[11:01:54.286] {
[11:01:54.286]     {
[11:01:54.286]         {
[11:01:54.286]             ...future.startTime <- base::Sys.time()
[11:01:54.286]             {
[11:01:54.286]                 {
[11:01:54.286]                   {
[11:01:54.286]                     {
[11:01:54.286]                       base::local({
[11:01:54.286]                         has_future <- base::requireNamespace("future", 
[11:01:54.286]                           quietly = TRUE)
[11:01:54.286]                         if (has_future) {
[11:01:54.286]                           ns <- base::getNamespace("future")
[11:01:54.286]                           version <- ns[[".package"]][["version"]]
[11:01:54.286]                           if (is.null(version)) 
[11:01:54.286]                             version <- utils::packageVersion("future")
[11:01:54.286]                         }
[11:01:54.286]                         else {
[11:01:54.286]                           version <- NULL
[11:01:54.286]                         }
[11:01:54.286]                         if (!has_future || version < "1.8.0") {
[11:01:54.286]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.286]                             "", base::R.version$version.string), 
[11:01:54.286]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.286]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.286]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.286]                               "release", "version")], collapse = " "), 
[11:01:54.286]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.286]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.286]                             info)
[11:01:54.286]                           info <- base::paste(info, collapse = "; ")
[11:01:54.286]                           if (!has_future) {
[11:01:54.286]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.286]                               info)
[11:01:54.286]                           }
[11:01:54.286]                           else {
[11:01:54.286]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.286]                               info, version)
[11:01:54.286]                           }
[11:01:54.286]                           base::stop(msg)
[11:01:54.286]                         }
[11:01:54.286]                       })
[11:01:54.286]                     }
[11:01:54.286]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.286]                     base::options(mc.cores = 1L)
[11:01:54.286]                   }
[11:01:54.286]                   ...future.strategy.old <- future::plan("list")
[11:01:54.286]                   options(future.plan = NULL)
[11:01:54.286]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.286]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.286]                 }
[11:01:54.286]                 ...future.workdir <- getwd()
[11:01:54.286]             }
[11:01:54.286]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.286]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.286]         }
[11:01:54.286]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.286]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.286]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.286]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.286]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.286]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.286]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.286]             base::names(...future.oldOptions))
[11:01:54.286]     }
[11:01:54.286]     if (FALSE) {
[11:01:54.286]     }
[11:01:54.286]     else {
[11:01:54.286]         if (TRUE) {
[11:01:54.286]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.286]                 open = "w")
[11:01:54.286]         }
[11:01:54.286]         else {
[11:01:54.286]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.286]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.286]         }
[11:01:54.286]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.286]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.286]             base::sink(type = "output", split = FALSE)
[11:01:54.286]             base::close(...future.stdout)
[11:01:54.286]         }, add = TRUE)
[11:01:54.286]     }
[11:01:54.286]     ...future.frame <- base::sys.nframe()
[11:01:54.286]     ...future.conditions <- base::list()
[11:01:54.286]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.286]     if (FALSE) {
[11:01:54.286]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.286]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.286]     }
[11:01:54.286]     ...future.result <- base::tryCatch({
[11:01:54.286]         base::withCallingHandlers({
[11:01:54.286]             ...future.value <- base::withVisible(base::local({
[11:01:54.286]                 ...future.makeSendCondition <- base::local({
[11:01:54.286]                   sendCondition <- NULL
[11:01:54.286]                   function(frame = 1L) {
[11:01:54.286]                     if (is.function(sendCondition)) 
[11:01:54.286]                       return(sendCondition)
[11:01:54.286]                     ns <- getNamespace("parallel")
[11:01:54.286]                     if (exists("sendData", mode = "function", 
[11:01:54.286]                       envir = ns)) {
[11:01:54.286]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.286]                         envir = ns)
[11:01:54.286]                       envir <- sys.frame(frame)
[11:01:54.286]                       master <- NULL
[11:01:54.286]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.286]                         !identical(envir, emptyenv())) {
[11:01:54.286]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.286]                           inherits = FALSE)) {
[11:01:54.286]                           master <- get("master", mode = "list", 
[11:01:54.286]                             envir = envir, inherits = FALSE)
[11:01:54.286]                           if (inherits(master, c("SOCKnode", 
[11:01:54.286]                             "SOCK0node"))) {
[11:01:54.286]                             sendCondition <<- function(cond) {
[11:01:54.286]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.286]                                 success = TRUE)
[11:01:54.286]                               parallel_sendData(master, data)
[11:01:54.286]                             }
[11:01:54.286]                             return(sendCondition)
[11:01:54.286]                           }
[11:01:54.286]                         }
[11:01:54.286]                         frame <- frame + 1L
[11:01:54.286]                         envir <- sys.frame(frame)
[11:01:54.286]                       }
[11:01:54.286]                     }
[11:01:54.286]                     sendCondition <<- function(cond) NULL
[11:01:54.286]                   }
[11:01:54.286]                 })
[11:01:54.286]                 withCallingHandlers({
[11:01:54.286]                   {
[11:01:54.286]                     b <- a * ii
[11:01:54.286]                     a <- 0
[11:01:54.286]                     b
[11:01:54.286]                   }
[11:01:54.286]                 }, immediateCondition = function(cond) {
[11:01:54.286]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.286]                   sendCondition(cond)
[11:01:54.286]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.286]                   {
[11:01:54.286]                     inherits <- base::inherits
[11:01:54.286]                     invokeRestart <- base::invokeRestart
[11:01:54.286]                     is.null <- base::is.null
[11:01:54.286]                     muffled <- FALSE
[11:01:54.286]                     if (inherits(cond, "message")) {
[11:01:54.286]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.286]                       if (muffled) 
[11:01:54.286]                         invokeRestart("muffleMessage")
[11:01:54.286]                     }
[11:01:54.286]                     else if (inherits(cond, "warning")) {
[11:01:54.286]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.286]                       if (muffled) 
[11:01:54.286]                         invokeRestart("muffleWarning")
[11:01:54.286]                     }
[11:01:54.286]                     else if (inherits(cond, "condition")) {
[11:01:54.286]                       if (!is.null(pattern)) {
[11:01:54.286]                         computeRestarts <- base::computeRestarts
[11:01:54.286]                         grepl <- base::grepl
[11:01:54.286]                         restarts <- computeRestarts(cond)
[11:01:54.286]                         for (restart in restarts) {
[11:01:54.286]                           name <- restart$name
[11:01:54.286]                           if (is.null(name)) 
[11:01:54.286]                             next
[11:01:54.286]                           if (!grepl(pattern, name)) 
[11:01:54.286]                             next
[11:01:54.286]                           invokeRestart(restart)
[11:01:54.286]                           muffled <- TRUE
[11:01:54.286]                           break
[11:01:54.286]                         }
[11:01:54.286]                       }
[11:01:54.286]                     }
[11:01:54.286]                     invisible(muffled)
[11:01:54.286]                   }
[11:01:54.286]                   muffleCondition(cond)
[11:01:54.286]                 })
[11:01:54.286]             }))
[11:01:54.286]             future::FutureResult(value = ...future.value$value, 
[11:01:54.286]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.286]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.286]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.286]                     ...future.globalenv.names))
[11:01:54.286]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.286]         }, condition = base::local({
[11:01:54.286]             c <- base::c
[11:01:54.286]             inherits <- base::inherits
[11:01:54.286]             invokeRestart <- base::invokeRestart
[11:01:54.286]             length <- base::length
[11:01:54.286]             list <- base::list
[11:01:54.286]             seq.int <- base::seq.int
[11:01:54.286]             signalCondition <- base::signalCondition
[11:01:54.286]             sys.calls <- base::sys.calls
[11:01:54.286]             `[[` <- base::`[[`
[11:01:54.286]             `+` <- base::`+`
[11:01:54.286]             `<<-` <- base::`<<-`
[11:01:54.286]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.286]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.286]                   3L)]
[11:01:54.286]             }
[11:01:54.286]             function(cond) {
[11:01:54.286]                 is_error <- inherits(cond, "error")
[11:01:54.286]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.286]                   NULL)
[11:01:54.286]                 if (is_error) {
[11:01:54.286]                   sessionInformation <- function() {
[11:01:54.286]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.286]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.286]                       search = base::search(), system = base::Sys.info())
[11:01:54.286]                   }
[11:01:54.286]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.286]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.286]                     cond$call), session = sessionInformation(), 
[11:01:54.286]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.286]                   signalCondition(cond)
[11:01:54.286]                 }
[11:01:54.286]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.286]                 "immediateCondition"))) {
[11:01:54.286]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.286]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.286]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.286]                   if (TRUE && !signal) {
[11:01:54.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.286]                     {
[11:01:54.286]                       inherits <- base::inherits
[11:01:54.286]                       invokeRestart <- base::invokeRestart
[11:01:54.286]                       is.null <- base::is.null
[11:01:54.286]                       muffled <- FALSE
[11:01:54.286]                       if (inherits(cond, "message")) {
[11:01:54.286]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.286]                         if (muffled) 
[11:01:54.286]                           invokeRestart("muffleMessage")
[11:01:54.286]                       }
[11:01:54.286]                       else if (inherits(cond, "warning")) {
[11:01:54.286]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.286]                         if (muffled) 
[11:01:54.286]                           invokeRestart("muffleWarning")
[11:01:54.286]                       }
[11:01:54.286]                       else if (inherits(cond, "condition")) {
[11:01:54.286]                         if (!is.null(pattern)) {
[11:01:54.286]                           computeRestarts <- base::computeRestarts
[11:01:54.286]                           grepl <- base::grepl
[11:01:54.286]                           restarts <- computeRestarts(cond)
[11:01:54.286]                           for (restart in restarts) {
[11:01:54.286]                             name <- restart$name
[11:01:54.286]                             if (is.null(name)) 
[11:01:54.286]                               next
[11:01:54.286]                             if (!grepl(pattern, name)) 
[11:01:54.286]                               next
[11:01:54.286]                             invokeRestart(restart)
[11:01:54.286]                             muffled <- TRUE
[11:01:54.286]                             break
[11:01:54.286]                           }
[11:01:54.286]                         }
[11:01:54.286]                       }
[11:01:54.286]                       invisible(muffled)
[11:01:54.286]                     }
[11:01:54.286]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.286]                   }
[11:01:54.286]                 }
[11:01:54.286]                 else {
[11:01:54.286]                   if (TRUE) {
[11:01:54.286]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.286]                     {
[11:01:54.286]                       inherits <- base::inherits
[11:01:54.286]                       invokeRestart <- base::invokeRestart
[11:01:54.286]                       is.null <- base::is.null
[11:01:54.286]                       muffled <- FALSE
[11:01:54.286]                       if (inherits(cond, "message")) {
[11:01:54.286]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.286]                         if (muffled) 
[11:01:54.286]                           invokeRestart("muffleMessage")
[11:01:54.286]                       }
[11:01:54.286]                       else if (inherits(cond, "warning")) {
[11:01:54.286]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.286]                         if (muffled) 
[11:01:54.286]                           invokeRestart("muffleWarning")
[11:01:54.286]                       }
[11:01:54.286]                       else if (inherits(cond, "condition")) {
[11:01:54.286]                         if (!is.null(pattern)) {
[11:01:54.286]                           computeRestarts <- base::computeRestarts
[11:01:54.286]                           grepl <- base::grepl
[11:01:54.286]                           restarts <- computeRestarts(cond)
[11:01:54.286]                           for (restart in restarts) {
[11:01:54.286]                             name <- restart$name
[11:01:54.286]                             if (is.null(name)) 
[11:01:54.286]                               next
[11:01:54.286]                             if (!grepl(pattern, name)) 
[11:01:54.286]                               next
[11:01:54.286]                             invokeRestart(restart)
[11:01:54.286]                             muffled <- TRUE
[11:01:54.286]                             break
[11:01:54.286]                           }
[11:01:54.286]                         }
[11:01:54.286]                       }
[11:01:54.286]                       invisible(muffled)
[11:01:54.286]                     }
[11:01:54.286]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.286]                   }
[11:01:54.286]                 }
[11:01:54.286]             }
[11:01:54.286]         }))
[11:01:54.286]     }, error = function(ex) {
[11:01:54.286]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.286]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.286]                 ...future.rng), started = ...future.startTime, 
[11:01:54.286]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.286]             version = "1.8"), class = "FutureResult")
[11:01:54.286]     }, finally = {
[11:01:54.286]         if (!identical(...future.workdir, getwd())) 
[11:01:54.286]             setwd(...future.workdir)
[11:01:54.286]         {
[11:01:54.286]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.286]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.286]             }
[11:01:54.286]             base::options(...future.oldOptions)
[11:01:54.286]             if (.Platform$OS.type == "windows") {
[11:01:54.286]                 old_names <- names(...future.oldEnvVars)
[11:01:54.286]                 envs <- base::Sys.getenv()
[11:01:54.286]                 names <- names(envs)
[11:01:54.286]                 common <- intersect(names, old_names)
[11:01:54.286]                 added <- setdiff(names, old_names)
[11:01:54.286]                 removed <- setdiff(old_names, names)
[11:01:54.286]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.286]                   envs[common]]
[11:01:54.286]                 NAMES <- toupper(changed)
[11:01:54.286]                 args <- list()
[11:01:54.286]                 for (kk in seq_along(NAMES)) {
[11:01:54.286]                   name <- changed[[kk]]
[11:01:54.286]                   NAME <- NAMES[[kk]]
[11:01:54.286]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.286]                     next
[11:01:54.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.286]                 }
[11:01:54.286]                 NAMES <- toupper(added)
[11:01:54.286]                 for (kk in seq_along(NAMES)) {
[11:01:54.286]                   name <- added[[kk]]
[11:01:54.286]                   NAME <- NAMES[[kk]]
[11:01:54.286]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.286]                     next
[11:01:54.286]                   args[[name]] <- ""
[11:01:54.286]                 }
[11:01:54.286]                 NAMES <- toupper(removed)
[11:01:54.286]                 for (kk in seq_along(NAMES)) {
[11:01:54.286]                   name <- removed[[kk]]
[11:01:54.286]                   NAME <- NAMES[[kk]]
[11:01:54.286]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.286]                     next
[11:01:54.286]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.286]                 }
[11:01:54.286]                 if (length(args) > 0) 
[11:01:54.286]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.286]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.286]             }
[11:01:54.286]             else {
[11:01:54.286]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.286]             }
[11:01:54.286]             {
[11:01:54.286]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.286]                   0L) {
[11:01:54.286]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.286]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.286]                   base::options(opts)
[11:01:54.286]                 }
[11:01:54.286]                 {
[11:01:54.286]                   {
[11:01:54.286]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.286]                     NULL
[11:01:54.286]                   }
[11:01:54.286]                   options(future.plan = NULL)
[11:01:54.286]                   if (is.na(NA_character_)) 
[11:01:54.286]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.286]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.286]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.286]                     .init = FALSE)
[11:01:54.286]                 }
[11:01:54.286]             }
[11:01:54.286]         }
[11:01:54.286]     })
[11:01:54.286]     if (TRUE) {
[11:01:54.286]         base::sink(type = "output", split = FALSE)
[11:01:54.286]         if (TRUE) {
[11:01:54.286]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.286]         }
[11:01:54.286]         else {
[11:01:54.286]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.286]         }
[11:01:54.286]         base::close(...future.stdout)
[11:01:54.286]         ...future.stdout <- NULL
[11:01:54.286]     }
[11:01:54.286]     ...future.result$conditions <- ...future.conditions
[11:01:54.286]     ...future.result$finished <- base::Sys.time()
[11:01:54.286]     ...future.result
[11:01:54.286] }
[11:01:54.288] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:01:54.289] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:54.289] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:54.289] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:01:54.289] MultisessionFuture started
[11:01:54.289] - Launch lazy future ... done
[11:01:54.290] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.290] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.290] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.291] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.292] Searching for globals ... DONE
[11:01:54.292] Resolving globals: TRUE
[11:01:54.292] Resolving any globals that are futures ...
[11:01:54.292] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.292] Resolving any globals that are futures ... DONE
[11:01:54.292] Resolving futures part of globals (recursively) ...
[11:01:54.292] resolve() on list ...
[11:01:54.293]  recursive: 99
[11:01:54.293]  length: 1
[11:01:54.293]  elements: ‘ii’
[11:01:54.293]  length: 0 (resolved future 1)
[11:01:54.293] resolve() on list ... DONE
[11:01:54.293] - globals: [1] ‘ii’
[11:01:54.293] Resolving futures part of globals (recursively) ... DONE
[11:01:54.293] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:54.293] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:54.294] - globals: [1] ‘ii’
[11:01:54.294] 
[11:01:54.294] getGlobalsAndPackages() ... DONE
[11:01:54.294] run() for ‘Future’ ...
[11:01:54.294] - state: ‘created’
[11:01:54.294] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.308] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.308] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.308]   - Field: ‘node’
[11:01:54.308]   - Field: ‘label’
[11:01:54.308]   - Field: ‘local’
[11:01:54.308]   - Field: ‘owner’
[11:01:54.308]   - Field: ‘envir’
[11:01:54.308]   - Field: ‘workers’
[11:01:54.309]   - Field: ‘packages’
[11:01:54.309]   - Field: ‘gc’
[11:01:54.309]   - Field: ‘conditions’
[11:01:54.309]   - Field: ‘persistent’
[11:01:54.309]   - Field: ‘expr’
[11:01:54.309]   - Field: ‘uuid’
[11:01:54.309]   - Field: ‘seed’
[11:01:54.309]   - Field: ‘version’
[11:01:54.309]   - Field: ‘result’
[11:01:54.309]   - Field: ‘asynchronous’
[11:01:54.309]   - Field: ‘calls’
[11:01:54.309]   - Field: ‘globals’
[11:01:54.310]   - Field: ‘stdout’
[11:01:54.310]   - Field: ‘earlySignal’
[11:01:54.310]   - Field: ‘lazy’
[11:01:54.310]   - Field: ‘state’
[11:01:54.310] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.310] - Launch lazy future ...
[11:01:54.310] Packages needed by the future expression (n = 0): <none>
[11:01:54.310] Packages needed by future strategies (n = 0): <none>
[11:01:54.311] {
[11:01:54.311]     {
[11:01:54.311]         {
[11:01:54.311]             ...future.startTime <- base::Sys.time()
[11:01:54.311]             {
[11:01:54.311]                 {
[11:01:54.311]                   {
[11:01:54.311]                     {
[11:01:54.311]                       base::local({
[11:01:54.311]                         has_future <- base::requireNamespace("future", 
[11:01:54.311]                           quietly = TRUE)
[11:01:54.311]                         if (has_future) {
[11:01:54.311]                           ns <- base::getNamespace("future")
[11:01:54.311]                           version <- ns[[".package"]][["version"]]
[11:01:54.311]                           if (is.null(version)) 
[11:01:54.311]                             version <- utils::packageVersion("future")
[11:01:54.311]                         }
[11:01:54.311]                         else {
[11:01:54.311]                           version <- NULL
[11:01:54.311]                         }
[11:01:54.311]                         if (!has_future || version < "1.8.0") {
[11:01:54.311]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.311]                             "", base::R.version$version.string), 
[11:01:54.311]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.311]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.311]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.311]                               "release", "version")], collapse = " "), 
[11:01:54.311]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.311]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.311]                             info)
[11:01:54.311]                           info <- base::paste(info, collapse = "; ")
[11:01:54.311]                           if (!has_future) {
[11:01:54.311]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.311]                               info)
[11:01:54.311]                           }
[11:01:54.311]                           else {
[11:01:54.311]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.311]                               info, version)
[11:01:54.311]                           }
[11:01:54.311]                           base::stop(msg)
[11:01:54.311]                         }
[11:01:54.311]                       })
[11:01:54.311]                     }
[11:01:54.311]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.311]                     base::options(mc.cores = 1L)
[11:01:54.311]                   }
[11:01:54.311]                   ...future.strategy.old <- future::plan("list")
[11:01:54.311]                   options(future.plan = NULL)
[11:01:54.311]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.311]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.311]                 }
[11:01:54.311]                 ...future.workdir <- getwd()
[11:01:54.311]             }
[11:01:54.311]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.311]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.311]         }
[11:01:54.311]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.311]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.311]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.311]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.311]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.311]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.311]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.311]             base::names(...future.oldOptions))
[11:01:54.311]     }
[11:01:54.311]     if (FALSE) {
[11:01:54.311]     }
[11:01:54.311]     else {
[11:01:54.311]         if (TRUE) {
[11:01:54.311]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.311]                 open = "w")
[11:01:54.311]         }
[11:01:54.311]         else {
[11:01:54.311]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.311]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.311]         }
[11:01:54.311]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.311]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.311]             base::sink(type = "output", split = FALSE)
[11:01:54.311]             base::close(...future.stdout)
[11:01:54.311]         }, add = TRUE)
[11:01:54.311]     }
[11:01:54.311]     ...future.frame <- base::sys.nframe()
[11:01:54.311]     ...future.conditions <- base::list()
[11:01:54.311]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.311]     if (FALSE) {
[11:01:54.311]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.311]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.311]     }
[11:01:54.311]     ...future.result <- base::tryCatch({
[11:01:54.311]         base::withCallingHandlers({
[11:01:54.311]             ...future.value <- base::withVisible(base::local({
[11:01:54.311]                 ...future.makeSendCondition <- base::local({
[11:01:54.311]                   sendCondition <- NULL
[11:01:54.311]                   function(frame = 1L) {
[11:01:54.311]                     if (is.function(sendCondition)) 
[11:01:54.311]                       return(sendCondition)
[11:01:54.311]                     ns <- getNamespace("parallel")
[11:01:54.311]                     if (exists("sendData", mode = "function", 
[11:01:54.311]                       envir = ns)) {
[11:01:54.311]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.311]                         envir = ns)
[11:01:54.311]                       envir <- sys.frame(frame)
[11:01:54.311]                       master <- NULL
[11:01:54.311]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.311]                         !identical(envir, emptyenv())) {
[11:01:54.311]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.311]                           inherits = FALSE)) {
[11:01:54.311]                           master <- get("master", mode = "list", 
[11:01:54.311]                             envir = envir, inherits = FALSE)
[11:01:54.311]                           if (inherits(master, c("SOCKnode", 
[11:01:54.311]                             "SOCK0node"))) {
[11:01:54.311]                             sendCondition <<- function(cond) {
[11:01:54.311]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.311]                                 success = TRUE)
[11:01:54.311]                               parallel_sendData(master, data)
[11:01:54.311]                             }
[11:01:54.311]                             return(sendCondition)
[11:01:54.311]                           }
[11:01:54.311]                         }
[11:01:54.311]                         frame <- frame + 1L
[11:01:54.311]                         envir <- sys.frame(frame)
[11:01:54.311]                       }
[11:01:54.311]                     }
[11:01:54.311]                     sendCondition <<- function(cond) NULL
[11:01:54.311]                   }
[11:01:54.311]                 })
[11:01:54.311]                 withCallingHandlers({
[11:01:54.311]                   {
[11:01:54.311]                     b <- a * ii
[11:01:54.311]                     a <- 0
[11:01:54.311]                     b
[11:01:54.311]                   }
[11:01:54.311]                 }, immediateCondition = function(cond) {
[11:01:54.311]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.311]                   sendCondition(cond)
[11:01:54.311]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.311]                   {
[11:01:54.311]                     inherits <- base::inherits
[11:01:54.311]                     invokeRestart <- base::invokeRestart
[11:01:54.311]                     is.null <- base::is.null
[11:01:54.311]                     muffled <- FALSE
[11:01:54.311]                     if (inherits(cond, "message")) {
[11:01:54.311]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.311]                       if (muffled) 
[11:01:54.311]                         invokeRestart("muffleMessage")
[11:01:54.311]                     }
[11:01:54.311]                     else if (inherits(cond, "warning")) {
[11:01:54.311]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.311]                       if (muffled) 
[11:01:54.311]                         invokeRestart("muffleWarning")
[11:01:54.311]                     }
[11:01:54.311]                     else if (inherits(cond, "condition")) {
[11:01:54.311]                       if (!is.null(pattern)) {
[11:01:54.311]                         computeRestarts <- base::computeRestarts
[11:01:54.311]                         grepl <- base::grepl
[11:01:54.311]                         restarts <- computeRestarts(cond)
[11:01:54.311]                         for (restart in restarts) {
[11:01:54.311]                           name <- restart$name
[11:01:54.311]                           if (is.null(name)) 
[11:01:54.311]                             next
[11:01:54.311]                           if (!grepl(pattern, name)) 
[11:01:54.311]                             next
[11:01:54.311]                           invokeRestart(restart)
[11:01:54.311]                           muffled <- TRUE
[11:01:54.311]                           break
[11:01:54.311]                         }
[11:01:54.311]                       }
[11:01:54.311]                     }
[11:01:54.311]                     invisible(muffled)
[11:01:54.311]                   }
[11:01:54.311]                   muffleCondition(cond)
[11:01:54.311]                 })
[11:01:54.311]             }))
[11:01:54.311]             future::FutureResult(value = ...future.value$value, 
[11:01:54.311]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.311]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.311]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.311]                     ...future.globalenv.names))
[11:01:54.311]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.311]         }, condition = base::local({
[11:01:54.311]             c <- base::c
[11:01:54.311]             inherits <- base::inherits
[11:01:54.311]             invokeRestart <- base::invokeRestart
[11:01:54.311]             length <- base::length
[11:01:54.311]             list <- base::list
[11:01:54.311]             seq.int <- base::seq.int
[11:01:54.311]             signalCondition <- base::signalCondition
[11:01:54.311]             sys.calls <- base::sys.calls
[11:01:54.311]             `[[` <- base::`[[`
[11:01:54.311]             `+` <- base::`+`
[11:01:54.311]             `<<-` <- base::`<<-`
[11:01:54.311]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.311]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.311]                   3L)]
[11:01:54.311]             }
[11:01:54.311]             function(cond) {
[11:01:54.311]                 is_error <- inherits(cond, "error")
[11:01:54.311]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.311]                   NULL)
[11:01:54.311]                 if (is_error) {
[11:01:54.311]                   sessionInformation <- function() {
[11:01:54.311]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.311]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.311]                       search = base::search(), system = base::Sys.info())
[11:01:54.311]                   }
[11:01:54.311]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.311]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.311]                     cond$call), session = sessionInformation(), 
[11:01:54.311]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.311]                   signalCondition(cond)
[11:01:54.311]                 }
[11:01:54.311]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.311]                 "immediateCondition"))) {
[11:01:54.311]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.311]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.311]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.311]                   if (TRUE && !signal) {
[11:01:54.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.311]                     {
[11:01:54.311]                       inherits <- base::inherits
[11:01:54.311]                       invokeRestart <- base::invokeRestart
[11:01:54.311]                       is.null <- base::is.null
[11:01:54.311]                       muffled <- FALSE
[11:01:54.311]                       if (inherits(cond, "message")) {
[11:01:54.311]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.311]                         if (muffled) 
[11:01:54.311]                           invokeRestart("muffleMessage")
[11:01:54.311]                       }
[11:01:54.311]                       else if (inherits(cond, "warning")) {
[11:01:54.311]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.311]                         if (muffled) 
[11:01:54.311]                           invokeRestart("muffleWarning")
[11:01:54.311]                       }
[11:01:54.311]                       else if (inherits(cond, "condition")) {
[11:01:54.311]                         if (!is.null(pattern)) {
[11:01:54.311]                           computeRestarts <- base::computeRestarts
[11:01:54.311]                           grepl <- base::grepl
[11:01:54.311]                           restarts <- computeRestarts(cond)
[11:01:54.311]                           for (restart in restarts) {
[11:01:54.311]                             name <- restart$name
[11:01:54.311]                             if (is.null(name)) 
[11:01:54.311]                               next
[11:01:54.311]                             if (!grepl(pattern, name)) 
[11:01:54.311]                               next
[11:01:54.311]                             invokeRestart(restart)
[11:01:54.311]                             muffled <- TRUE
[11:01:54.311]                             break
[11:01:54.311]                           }
[11:01:54.311]                         }
[11:01:54.311]                       }
[11:01:54.311]                       invisible(muffled)
[11:01:54.311]                     }
[11:01:54.311]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.311]                   }
[11:01:54.311]                 }
[11:01:54.311]                 else {
[11:01:54.311]                   if (TRUE) {
[11:01:54.311]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.311]                     {
[11:01:54.311]                       inherits <- base::inherits
[11:01:54.311]                       invokeRestart <- base::invokeRestart
[11:01:54.311]                       is.null <- base::is.null
[11:01:54.311]                       muffled <- FALSE
[11:01:54.311]                       if (inherits(cond, "message")) {
[11:01:54.311]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.311]                         if (muffled) 
[11:01:54.311]                           invokeRestart("muffleMessage")
[11:01:54.311]                       }
[11:01:54.311]                       else if (inherits(cond, "warning")) {
[11:01:54.311]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.311]                         if (muffled) 
[11:01:54.311]                           invokeRestart("muffleWarning")
[11:01:54.311]                       }
[11:01:54.311]                       else if (inherits(cond, "condition")) {
[11:01:54.311]                         if (!is.null(pattern)) {
[11:01:54.311]                           computeRestarts <- base::computeRestarts
[11:01:54.311]                           grepl <- base::grepl
[11:01:54.311]                           restarts <- computeRestarts(cond)
[11:01:54.311]                           for (restart in restarts) {
[11:01:54.311]                             name <- restart$name
[11:01:54.311]                             if (is.null(name)) 
[11:01:54.311]                               next
[11:01:54.311]                             if (!grepl(pattern, name)) 
[11:01:54.311]                               next
[11:01:54.311]                             invokeRestart(restart)
[11:01:54.311]                             muffled <- TRUE
[11:01:54.311]                             break
[11:01:54.311]                           }
[11:01:54.311]                         }
[11:01:54.311]                       }
[11:01:54.311]                       invisible(muffled)
[11:01:54.311]                     }
[11:01:54.311]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.311]                   }
[11:01:54.311]                 }
[11:01:54.311]             }
[11:01:54.311]         }))
[11:01:54.311]     }, error = function(ex) {
[11:01:54.311]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.311]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.311]                 ...future.rng), started = ...future.startTime, 
[11:01:54.311]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.311]             version = "1.8"), class = "FutureResult")
[11:01:54.311]     }, finally = {
[11:01:54.311]         if (!identical(...future.workdir, getwd())) 
[11:01:54.311]             setwd(...future.workdir)
[11:01:54.311]         {
[11:01:54.311]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.311]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.311]             }
[11:01:54.311]             base::options(...future.oldOptions)
[11:01:54.311]             if (.Platform$OS.type == "windows") {
[11:01:54.311]                 old_names <- names(...future.oldEnvVars)
[11:01:54.311]                 envs <- base::Sys.getenv()
[11:01:54.311]                 names <- names(envs)
[11:01:54.311]                 common <- intersect(names, old_names)
[11:01:54.311]                 added <- setdiff(names, old_names)
[11:01:54.311]                 removed <- setdiff(old_names, names)
[11:01:54.311]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.311]                   envs[common]]
[11:01:54.311]                 NAMES <- toupper(changed)
[11:01:54.311]                 args <- list()
[11:01:54.311]                 for (kk in seq_along(NAMES)) {
[11:01:54.311]                   name <- changed[[kk]]
[11:01:54.311]                   NAME <- NAMES[[kk]]
[11:01:54.311]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.311]                     next
[11:01:54.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.311]                 }
[11:01:54.311]                 NAMES <- toupper(added)
[11:01:54.311]                 for (kk in seq_along(NAMES)) {
[11:01:54.311]                   name <- added[[kk]]
[11:01:54.311]                   NAME <- NAMES[[kk]]
[11:01:54.311]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.311]                     next
[11:01:54.311]                   args[[name]] <- ""
[11:01:54.311]                 }
[11:01:54.311]                 NAMES <- toupper(removed)
[11:01:54.311]                 for (kk in seq_along(NAMES)) {
[11:01:54.311]                   name <- removed[[kk]]
[11:01:54.311]                   NAME <- NAMES[[kk]]
[11:01:54.311]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.311]                     next
[11:01:54.311]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.311]                 }
[11:01:54.311]                 if (length(args) > 0) 
[11:01:54.311]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.311]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.311]             }
[11:01:54.311]             else {
[11:01:54.311]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.311]             }
[11:01:54.311]             {
[11:01:54.311]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.311]                   0L) {
[11:01:54.311]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.311]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.311]                   base::options(opts)
[11:01:54.311]                 }
[11:01:54.311]                 {
[11:01:54.311]                   {
[11:01:54.311]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.311]                     NULL
[11:01:54.311]                   }
[11:01:54.311]                   options(future.plan = NULL)
[11:01:54.311]                   if (is.na(NA_character_)) 
[11:01:54.311]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.311]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.311]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.311]                     .init = FALSE)
[11:01:54.311]                 }
[11:01:54.311]             }
[11:01:54.311]         }
[11:01:54.311]     })
[11:01:54.311]     if (TRUE) {
[11:01:54.311]         base::sink(type = "output", split = FALSE)
[11:01:54.311]         if (TRUE) {
[11:01:54.311]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.311]         }
[11:01:54.311]         else {
[11:01:54.311]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.311]         }
[11:01:54.311]         base::close(...future.stdout)
[11:01:54.311]         ...future.stdout <- NULL
[11:01:54.311]     }
[11:01:54.311]     ...future.result$conditions <- ...future.conditions
[11:01:54.311]     ...future.result$finished <- base::Sys.time()
[11:01:54.311]     ...future.result
[11:01:54.311] }
[11:01:54.362] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[11:01:54.363] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:01:54.363] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:01:54.363] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[11:01:54.364] MultisessionFuture started
[11:01:54.364] - Launch lazy future ... done
[11:01:54.364] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.364] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.365] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.366] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.366] Searching for globals ... DONE
[11:01:54.366] Resolving globals: TRUE
[11:01:54.366] Resolving any globals that are futures ...
[11:01:54.366] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.366] Resolving any globals that are futures ... DONE
[11:01:54.367] Resolving futures part of globals (recursively) ...
[11:01:54.367] resolve() on list ...
[11:01:54.367]  recursive: 99
[11:01:54.367]  length: 1
[11:01:54.367]  elements: ‘ii’
[11:01:54.367]  length: 0 (resolved future 1)
[11:01:54.367] resolve() on list ... DONE
[11:01:54.367] - globals: [1] ‘ii’
[11:01:54.368] Resolving futures part of globals (recursively) ... DONE
[11:01:54.368] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:54.368] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:54.368] - globals: [1] ‘ii’
[11:01:54.368] 
[11:01:54.368] getGlobalsAndPackages() ... DONE
[11:01:54.369] run() for ‘Future’ ...
[11:01:54.369] - state: ‘created’
[11:01:54.369] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.384] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.384] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.385]   - Field: ‘node’
[11:01:54.385]   - Field: ‘label’
[11:01:54.385]   - Field: ‘local’
[11:01:54.385]   - Field: ‘owner’
[11:01:54.385]   - Field: ‘envir’
[11:01:54.385]   - Field: ‘workers’
[11:01:54.385]   - Field: ‘packages’
[11:01:54.385]   - Field: ‘gc’
[11:01:54.385]   - Field: ‘conditions’
[11:01:54.385]   - Field: ‘persistent’
[11:01:54.385]   - Field: ‘expr’
[11:01:54.385]   - Field: ‘uuid’
[11:01:54.386]   - Field: ‘seed’
[11:01:54.386]   - Field: ‘version’
[11:01:54.386]   - Field: ‘result’
[11:01:54.386]   - Field: ‘asynchronous’
[11:01:54.386]   - Field: ‘calls’
[11:01:54.386]   - Field: ‘globals’
[11:01:54.386]   - Field: ‘stdout’
[11:01:54.386]   - Field: ‘earlySignal’
[11:01:54.386]   - Field: ‘lazy’
[11:01:54.386]   - Field: ‘state’
[11:01:54.386] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.386] - Launch lazy future ...
[11:01:54.387] Packages needed by the future expression (n = 0): <none>
[11:01:54.387] Packages needed by future strategies (n = 0): <none>
[11:01:54.387] {
[11:01:54.387]     {
[11:01:54.387]         {
[11:01:54.387]             ...future.startTime <- base::Sys.time()
[11:01:54.387]             {
[11:01:54.387]                 {
[11:01:54.387]                   {
[11:01:54.387]                     {
[11:01:54.387]                       base::local({
[11:01:54.387]                         has_future <- base::requireNamespace("future", 
[11:01:54.387]                           quietly = TRUE)
[11:01:54.387]                         if (has_future) {
[11:01:54.387]                           ns <- base::getNamespace("future")
[11:01:54.387]                           version <- ns[[".package"]][["version"]]
[11:01:54.387]                           if (is.null(version)) 
[11:01:54.387]                             version <- utils::packageVersion("future")
[11:01:54.387]                         }
[11:01:54.387]                         else {
[11:01:54.387]                           version <- NULL
[11:01:54.387]                         }
[11:01:54.387]                         if (!has_future || version < "1.8.0") {
[11:01:54.387]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.387]                             "", base::R.version$version.string), 
[11:01:54.387]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.387]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.387]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.387]                               "release", "version")], collapse = " "), 
[11:01:54.387]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.387]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.387]                             info)
[11:01:54.387]                           info <- base::paste(info, collapse = "; ")
[11:01:54.387]                           if (!has_future) {
[11:01:54.387]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.387]                               info)
[11:01:54.387]                           }
[11:01:54.387]                           else {
[11:01:54.387]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.387]                               info, version)
[11:01:54.387]                           }
[11:01:54.387]                           base::stop(msg)
[11:01:54.387]                         }
[11:01:54.387]                       })
[11:01:54.387]                     }
[11:01:54.387]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.387]                     base::options(mc.cores = 1L)
[11:01:54.387]                   }
[11:01:54.387]                   ...future.strategy.old <- future::plan("list")
[11:01:54.387]                   options(future.plan = NULL)
[11:01:54.387]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.387]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.387]                 }
[11:01:54.387]                 ...future.workdir <- getwd()
[11:01:54.387]             }
[11:01:54.387]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.387]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.387]         }
[11:01:54.387]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.387]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.387]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.387]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.387]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.387]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.387]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.387]             base::names(...future.oldOptions))
[11:01:54.387]     }
[11:01:54.387]     if (FALSE) {
[11:01:54.387]     }
[11:01:54.387]     else {
[11:01:54.387]         if (TRUE) {
[11:01:54.387]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.387]                 open = "w")
[11:01:54.387]         }
[11:01:54.387]         else {
[11:01:54.387]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.387]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.387]         }
[11:01:54.387]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.387]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.387]             base::sink(type = "output", split = FALSE)
[11:01:54.387]             base::close(...future.stdout)
[11:01:54.387]         }, add = TRUE)
[11:01:54.387]     }
[11:01:54.387]     ...future.frame <- base::sys.nframe()
[11:01:54.387]     ...future.conditions <- base::list()
[11:01:54.387]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.387]     if (FALSE) {
[11:01:54.387]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.387]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.387]     }
[11:01:54.387]     ...future.result <- base::tryCatch({
[11:01:54.387]         base::withCallingHandlers({
[11:01:54.387]             ...future.value <- base::withVisible(base::local({
[11:01:54.387]                 ...future.makeSendCondition <- base::local({
[11:01:54.387]                   sendCondition <- NULL
[11:01:54.387]                   function(frame = 1L) {
[11:01:54.387]                     if (is.function(sendCondition)) 
[11:01:54.387]                       return(sendCondition)
[11:01:54.387]                     ns <- getNamespace("parallel")
[11:01:54.387]                     if (exists("sendData", mode = "function", 
[11:01:54.387]                       envir = ns)) {
[11:01:54.387]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.387]                         envir = ns)
[11:01:54.387]                       envir <- sys.frame(frame)
[11:01:54.387]                       master <- NULL
[11:01:54.387]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.387]                         !identical(envir, emptyenv())) {
[11:01:54.387]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.387]                           inherits = FALSE)) {
[11:01:54.387]                           master <- get("master", mode = "list", 
[11:01:54.387]                             envir = envir, inherits = FALSE)
[11:01:54.387]                           if (inherits(master, c("SOCKnode", 
[11:01:54.387]                             "SOCK0node"))) {
[11:01:54.387]                             sendCondition <<- function(cond) {
[11:01:54.387]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.387]                                 success = TRUE)
[11:01:54.387]                               parallel_sendData(master, data)
[11:01:54.387]                             }
[11:01:54.387]                             return(sendCondition)
[11:01:54.387]                           }
[11:01:54.387]                         }
[11:01:54.387]                         frame <- frame + 1L
[11:01:54.387]                         envir <- sys.frame(frame)
[11:01:54.387]                       }
[11:01:54.387]                     }
[11:01:54.387]                     sendCondition <<- function(cond) NULL
[11:01:54.387]                   }
[11:01:54.387]                 })
[11:01:54.387]                 withCallingHandlers({
[11:01:54.387]                   {
[11:01:54.387]                     b <- a * ii
[11:01:54.387]                     a <- 0
[11:01:54.387]                     b
[11:01:54.387]                   }
[11:01:54.387]                 }, immediateCondition = function(cond) {
[11:01:54.387]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.387]                   sendCondition(cond)
[11:01:54.387]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.387]                   {
[11:01:54.387]                     inherits <- base::inherits
[11:01:54.387]                     invokeRestart <- base::invokeRestart
[11:01:54.387]                     is.null <- base::is.null
[11:01:54.387]                     muffled <- FALSE
[11:01:54.387]                     if (inherits(cond, "message")) {
[11:01:54.387]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.387]                       if (muffled) 
[11:01:54.387]                         invokeRestart("muffleMessage")
[11:01:54.387]                     }
[11:01:54.387]                     else if (inherits(cond, "warning")) {
[11:01:54.387]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.387]                       if (muffled) 
[11:01:54.387]                         invokeRestart("muffleWarning")
[11:01:54.387]                     }
[11:01:54.387]                     else if (inherits(cond, "condition")) {
[11:01:54.387]                       if (!is.null(pattern)) {
[11:01:54.387]                         computeRestarts <- base::computeRestarts
[11:01:54.387]                         grepl <- base::grepl
[11:01:54.387]                         restarts <- computeRestarts(cond)
[11:01:54.387]                         for (restart in restarts) {
[11:01:54.387]                           name <- restart$name
[11:01:54.387]                           if (is.null(name)) 
[11:01:54.387]                             next
[11:01:54.387]                           if (!grepl(pattern, name)) 
[11:01:54.387]                             next
[11:01:54.387]                           invokeRestart(restart)
[11:01:54.387]                           muffled <- TRUE
[11:01:54.387]                           break
[11:01:54.387]                         }
[11:01:54.387]                       }
[11:01:54.387]                     }
[11:01:54.387]                     invisible(muffled)
[11:01:54.387]                   }
[11:01:54.387]                   muffleCondition(cond)
[11:01:54.387]                 })
[11:01:54.387]             }))
[11:01:54.387]             future::FutureResult(value = ...future.value$value, 
[11:01:54.387]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.387]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.387]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.387]                     ...future.globalenv.names))
[11:01:54.387]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.387]         }, condition = base::local({
[11:01:54.387]             c <- base::c
[11:01:54.387]             inherits <- base::inherits
[11:01:54.387]             invokeRestart <- base::invokeRestart
[11:01:54.387]             length <- base::length
[11:01:54.387]             list <- base::list
[11:01:54.387]             seq.int <- base::seq.int
[11:01:54.387]             signalCondition <- base::signalCondition
[11:01:54.387]             sys.calls <- base::sys.calls
[11:01:54.387]             `[[` <- base::`[[`
[11:01:54.387]             `+` <- base::`+`
[11:01:54.387]             `<<-` <- base::`<<-`
[11:01:54.387]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.387]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.387]                   3L)]
[11:01:54.387]             }
[11:01:54.387]             function(cond) {
[11:01:54.387]                 is_error <- inherits(cond, "error")
[11:01:54.387]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.387]                   NULL)
[11:01:54.387]                 if (is_error) {
[11:01:54.387]                   sessionInformation <- function() {
[11:01:54.387]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.387]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.387]                       search = base::search(), system = base::Sys.info())
[11:01:54.387]                   }
[11:01:54.387]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.387]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.387]                     cond$call), session = sessionInformation(), 
[11:01:54.387]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.387]                   signalCondition(cond)
[11:01:54.387]                 }
[11:01:54.387]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.387]                 "immediateCondition"))) {
[11:01:54.387]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.387]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.387]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.387]                   if (TRUE && !signal) {
[11:01:54.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.387]                     {
[11:01:54.387]                       inherits <- base::inherits
[11:01:54.387]                       invokeRestart <- base::invokeRestart
[11:01:54.387]                       is.null <- base::is.null
[11:01:54.387]                       muffled <- FALSE
[11:01:54.387]                       if (inherits(cond, "message")) {
[11:01:54.387]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.387]                         if (muffled) 
[11:01:54.387]                           invokeRestart("muffleMessage")
[11:01:54.387]                       }
[11:01:54.387]                       else if (inherits(cond, "warning")) {
[11:01:54.387]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.387]                         if (muffled) 
[11:01:54.387]                           invokeRestart("muffleWarning")
[11:01:54.387]                       }
[11:01:54.387]                       else if (inherits(cond, "condition")) {
[11:01:54.387]                         if (!is.null(pattern)) {
[11:01:54.387]                           computeRestarts <- base::computeRestarts
[11:01:54.387]                           grepl <- base::grepl
[11:01:54.387]                           restarts <- computeRestarts(cond)
[11:01:54.387]                           for (restart in restarts) {
[11:01:54.387]                             name <- restart$name
[11:01:54.387]                             if (is.null(name)) 
[11:01:54.387]                               next
[11:01:54.387]                             if (!grepl(pattern, name)) 
[11:01:54.387]                               next
[11:01:54.387]                             invokeRestart(restart)
[11:01:54.387]                             muffled <- TRUE
[11:01:54.387]                             break
[11:01:54.387]                           }
[11:01:54.387]                         }
[11:01:54.387]                       }
[11:01:54.387]                       invisible(muffled)
[11:01:54.387]                     }
[11:01:54.387]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.387]                   }
[11:01:54.387]                 }
[11:01:54.387]                 else {
[11:01:54.387]                   if (TRUE) {
[11:01:54.387]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.387]                     {
[11:01:54.387]                       inherits <- base::inherits
[11:01:54.387]                       invokeRestart <- base::invokeRestart
[11:01:54.387]                       is.null <- base::is.null
[11:01:54.387]                       muffled <- FALSE
[11:01:54.387]                       if (inherits(cond, "message")) {
[11:01:54.387]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.387]                         if (muffled) 
[11:01:54.387]                           invokeRestart("muffleMessage")
[11:01:54.387]                       }
[11:01:54.387]                       else if (inherits(cond, "warning")) {
[11:01:54.387]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.387]                         if (muffled) 
[11:01:54.387]                           invokeRestart("muffleWarning")
[11:01:54.387]                       }
[11:01:54.387]                       else if (inherits(cond, "condition")) {
[11:01:54.387]                         if (!is.null(pattern)) {
[11:01:54.387]                           computeRestarts <- base::computeRestarts
[11:01:54.387]                           grepl <- base::grepl
[11:01:54.387]                           restarts <- computeRestarts(cond)
[11:01:54.387]                           for (restart in restarts) {
[11:01:54.387]                             name <- restart$name
[11:01:54.387]                             if (is.null(name)) 
[11:01:54.387]                               next
[11:01:54.387]                             if (!grepl(pattern, name)) 
[11:01:54.387]                               next
[11:01:54.387]                             invokeRestart(restart)
[11:01:54.387]                             muffled <- TRUE
[11:01:54.387]                             break
[11:01:54.387]                           }
[11:01:54.387]                         }
[11:01:54.387]                       }
[11:01:54.387]                       invisible(muffled)
[11:01:54.387]                     }
[11:01:54.387]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.387]                   }
[11:01:54.387]                 }
[11:01:54.387]             }
[11:01:54.387]         }))
[11:01:54.387]     }, error = function(ex) {
[11:01:54.387]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.387]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.387]                 ...future.rng), started = ...future.startTime, 
[11:01:54.387]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.387]             version = "1.8"), class = "FutureResult")
[11:01:54.387]     }, finally = {
[11:01:54.387]         if (!identical(...future.workdir, getwd())) 
[11:01:54.387]             setwd(...future.workdir)
[11:01:54.387]         {
[11:01:54.387]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.387]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.387]             }
[11:01:54.387]             base::options(...future.oldOptions)
[11:01:54.387]             if (.Platform$OS.type == "windows") {
[11:01:54.387]                 old_names <- names(...future.oldEnvVars)
[11:01:54.387]                 envs <- base::Sys.getenv()
[11:01:54.387]                 names <- names(envs)
[11:01:54.387]                 common <- intersect(names, old_names)
[11:01:54.387]                 added <- setdiff(names, old_names)
[11:01:54.387]                 removed <- setdiff(old_names, names)
[11:01:54.387]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.387]                   envs[common]]
[11:01:54.387]                 NAMES <- toupper(changed)
[11:01:54.387]                 args <- list()
[11:01:54.387]                 for (kk in seq_along(NAMES)) {
[11:01:54.387]                   name <- changed[[kk]]
[11:01:54.387]                   NAME <- NAMES[[kk]]
[11:01:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.387]                     next
[11:01:54.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.387]                 }
[11:01:54.387]                 NAMES <- toupper(added)
[11:01:54.387]                 for (kk in seq_along(NAMES)) {
[11:01:54.387]                   name <- added[[kk]]
[11:01:54.387]                   NAME <- NAMES[[kk]]
[11:01:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.387]                     next
[11:01:54.387]                   args[[name]] <- ""
[11:01:54.387]                 }
[11:01:54.387]                 NAMES <- toupper(removed)
[11:01:54.387]                 for (kk in seq_along(NAMES)) {
[11:01:54.387]                   name <- removed[[kk]]
[11:01:54.387]                   NAME <- NAMES[[kk]]
[11:01:54.387]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.387]                     next
[11:01:54.387]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.387]                 }
[11:01:54.387]                 if (length(args) > 0) 
[11:01:54.387]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.387]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.387]             }
[11:01:54.387]             else {
[11:01:54.387]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.387]             }
[11:01:54.387]             {
[11:01:54.387]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.387]                   0L) {
[11:01:54.387]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.387]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.387]                   base::options(opts)
[11:01:54.387]                 }
[11:01:54.387]                 {
[11:01:54.387]                   {
[11:01:54.387]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.387]                     NULL
[11:01:54.387]                   }
[11:01:54.387]                   options(future.plan = NULL)
[11:01:54.387]                   if (is.na(NA_character_)) 
[11:01:54.387]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.387]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.387]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.387]                     .init = FALSE)
[11:01:54.387]                 }
[11:01:54.387]             }
[11:01:54.387]         }
[11:01:54.387]     })
[11:01:54.387]     if (TRUE) {
[11:01:54.387]         base::sink(type = "output", split = FALSE)
[11:01:54.387]         if (TRUE) {
[11:01:54.387]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.387]         }
[11:01:54.387]         else {
[11:01:54.387]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.387]         }
[11:01:54.387]         base::close(...future.stdout)
[11:01:54.387]         ...future.stdout <- NULL
[11:01:54.387]     }
[11:01:54.387]     ...future.result$conditions <- ...future.conditions
[11:01:54.387]     ...future.result$finished <- base::Sys.time()
[11:01:54.387]     ...future.result
[11:01:54.387] }
[11:01:54.389] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:54.400] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.400] - Validating connection of MultisessionFuture
[11:01:54.401] - received message: FutureResult
[11:01:54.401] - Received FutureResult
[11:01:54.401] - Erased future from FutureRegistry
[11:01:54.401] result() for ClusterFuture ...
[11:01:54.401] - result already collected: FutureResult
[11:01:54.401] result() for ClusterFuture ... done
[11:01:54.401] signalConditions() ...
[11:01:54.401]  - include = ‘immediateCondition’
[11:01:54.402]  - exclude = 
[11:01:54.402]  - resignal = FALSE
[11:01:54.402]  - Number of conditions: 1
[11:01:54.402] signalConditions() ... done
[11:01:54.402] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.402] result() for ClusterFuture ...
[11:01:54.402] - result already collected: FutureResult
[11:01:54.402] result() for ClusterFuture ... done
[11:01:54.402] result() for ClusterFuture ...
[11:01:54.402] - result already collected: FutureResult
[11:01:54.402] result() for ClusterFuture ... done
[11:01:54.403] signalConditions() ...
[11:01:54.403]  - include = ‘immediateCondition’
[11:01:54.403]  - exclude = 
[11:01:54.403]  - resignal = FALSE
[11:01:54.403]  - Number of conditions: 1
[11:01:54.403] signalConditions() ... done
[11:01:54.404] Exporting 1 global objects (344 bytes) to cluster node #1 ...
[11:01:54.404] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:54.404] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:54.404] Exporting 1 global objects (344 bytes) to cluster node #1 ... DONE
[11:01:54.405] MultisessionFuture started
[11:01:54.405] - Launch lazy future ... done
[11:01:54.405] run() for ‘MultisessionFuture’ ... done
[11:01:54.405] result() for ClusterFuture ...
[11:01:54.406] - result already collected: FutureResult
[11:01:54.406] result() for ClusterFuture ... done
[11:01:54.406] result() for ClusterFuture ...
[11:01:54.406] - result already collected: FutureResult
[11:01:54.406] result() for ClusterFuture ... done
[11:01:54.406] signalConditions() ...
[11:01:54.406]  - include = ‘immediateCondition’
[11:01:54.407]  - exclude = 
[11:01:54.407]  - resignal = FALSE
[11:01:54.407]  - Number of conditions: 1
[11:01:54.407] signalConditions() ... done
[11:01:54.407] Future state: ‘finished’
[11:01:54.407] result() for ClusterFuture ...
[11:01:54.408] - result already collected: FutureResult
[11:01:54.408] result() for ClusterFuture ... done
[11:01:54.408] signalConditions() ...
[11:01:54.408]  - include = ‘condition’
[11:01:54.408]  - exclude = ‘immediateCondition’
[11:01:54.408]  - resignal = TRUE
[11:01:54.408]  - Number of conditions: 1
[11:01:54.408]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:54.409] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 9
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:54"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.425] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.425] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.426] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.426] Searching for globals ... DONE
[11:01:54.426] Resolving globals: TRUE
[11:01:54.426] Resolving any globals that are futures ...
[11:01:54.427] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.427] Resolving any globals that are futures ... DONE
[11:01:54.427] Resolving futures part of globals (recursively) ...
[11:01:54.427] resolve() on list ...
[11:01:54.427]  recursive: 99
[11:01:54.427]  length: 1
[11:01:54.427]  elements: ‘ii’
[11:01:54.428]  length: 0 (resolved future 1)
[11:01:54.428] resolve() on list ... DONE
[11:01:54.428] - globals: [1] ‘ii’
[11:01:54.428] Resolving futures part of globals (recursively) ... DONE
[11:01:54.428] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:54.428] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:54.428] - globals: [1] ‘ii’
[11:01:54.428] 
[11:01:54.429] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.429] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.429] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.430] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.431] Searching for globals ... DONE
[11:01:54.431] Resolving globals: TRUE
[11:01:54.431] Resolving any globals that are futures ...
[11:01:54.431] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.431] Resolving any globals that are futures ... DONE
[11:01:54.431] Resolving futures part of globals (recursively) ...
[11:01:54.431] resolve() on list ...
[11:01:54.432]  recursive: 99
[11:01:54.432]  length: 1
[11:01:54.432]  elements: ‘ii’
[11:01:54.432]  length: 0 (resolved future 1)
[11:01:54.432] resolve() on list ... DONE
[11:01:54.432] - globals: [1] ‘ii’
[11:01:54.432] Resolving futures part of globals (recursively) ... DONE
[11:01:54.432] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:54.432] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:54.433] - globals: [1] ‘ii’
[11:01:54.433] 
[11:01:54.433] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.433] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.433] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.435] - globals found: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.435] Searching for globals ... DONE
[11:01:54.435] Resolving globals: TRUE
[11:01:54.435] Resolving any globals that are futures ...
[11:01:54.435] - globals: [4] ‘{’, ‘<-’, ‘*’, ‘ii’
[11:01:54.435] Resolving any globals that are futures ... DONE
[11:01:54.435] Resolving futures part of globals (recursively) ...
[11:01:54.436] resolve() on list ...
[11:01:54.436]  recursive: 99
[11:01:54.436]  length: 1
[11:01:54.436]  elements: ‘ii’
[11:01:54.436]  length: 0 (resolved future 1)
[11:01:54.436] resolve() on list ... DONE
[11:01:54.436] - globals: [1] ‘ii’
[11:01:54.436] Resolving futures part of globals (recursively) ... DONE
[11:01:54.436] The total size of the 1 globals is 35 bytes (35 bytes)
[11:01:54.437] The total size of the 1 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 35 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘ii’ (35 bytes of class ‘numeric’)
[11:01:54.437] - globals: [1] ‘ii’
[11:01:54.437] 
[11:01:54.437] getGlobalsAndPackages() ... DONE
[11:01:54.437] run() for ‘Future’ ...
[11:01:54.437] - state: ‘created’
[11:01:54.437] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.452] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.452] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.452]   - Field: ‘node’
[11:01:54.452]   - Field: ‘label’
[11:01:54.453]   - Field: ‘local’
[11:01:54.453]   - Field: ‘owner’
[11:01:54.453]   - Field: ‘envir’
[11:01:54.453]   - Field: ‘workers’
[11:01:54.453]   - Field: ‘packages’
[11:01:54.453]   - Field: ‘gc’
[11:01:54.453]   - Field: ‘conditions’
[11:01:54.453]   - Field: ‘persistent’
[11:01:54.453]   - Field: ‘expr’
[11:01:54.453]   - Field: ‘uuid’
[11:01:54.453]   - Field: ‘seed’
[11:01:54.453]   - Field: ‘version’
[11:01:54.454]   - Field: ‘result’
[11:01:54.454]   - Field: ‘asynchronous’
[11:01:54.454]   - Field: ‘calls’
[11:01:54.454]   - Field: ‘globals’
[11:01:54.454]   - Field: ‘stdout’
[11:01:54.454]   - Field: ‘earlySignal’
[11:01:54.454]   - Field: ‘lazy’
[11:01:54.454]   - Field: ‘state’
[11:01:54.454] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.454] - Launch lazy future ...
[11:01:54.455] Packages needed by the future expression (n = 0): <none>
[11:01:54.455] Packages needed by future strategies (n = 0): <none>
[11:01:54.455] {
[11:01:54.455]     {
[11:01:54.455]         {
[11:01:54.455]             ...future.startTime <- base::Sys.time()
[11:01:54.455]             {
[11:01:54.455]                 {
[11:01:54.455]                   {
[11:01:54.455]                     {
[11:01:54.455]                       base::local({
[11:01:54.455]                         has_future <- base::requireNamespace("future", 
[11:01:54.455]                           quietly = TRUE)
[11:01:54.455]                         if (has_future) {
[11:01:54.455]                           ns <- base::getNamespace("future")
[11:01:54.455]                           version <- ns[[".package"]][["version"]]
[11:01:54.455]                           if (is.null(version)) 
[11:01:54.455]                             version <- utils::packageVersion("future")
[11:01:54.455]                         }
[11:01:54.455]                         else {
[11:01:54.455]                           version <- NULL
[11:01:54.455]                         }
[11:01:54.455]                         if (!has_future || version < "1.8.0") {
[11:01:54.455]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.455]                             "", base::R.version$version.string), 
[11:01:54.455]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.455]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.455]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.455]                               "release", "version")], collapse = " "), 
[11:01:54.455]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.455]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.455]                             info)
[11:01:54.455]                           info <- base::paste(info, collapse = "; ")
[11:01:54.455]                           if (!has_future) {
[11:01:54.455]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.455]                               info)
[11:01:54.455]                           }
[11:01:54.455]                           else {
[11:01:54.455]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.455]                               info, version)
[11:01:54.455]                           }
[11:01:54.455]                           base::stop(msg)
[11:01:54.455]                         }
[11:01:54.455]                       })
[11:01:54.455]                     }
[11:01:54.455]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.455]                     base::options(mc.cores = 1L)
[11:01:54.455]                   }
[11:01:54.455]                   ...future.strategy.old <- future::plan("list")
[11:01:54.455]                   options(future.plan = NULL)
[11:01:54.455]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.455]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.455]                 }
[11:01:54.455]                 ...future.workdir <- getwd()
[11:01:54.455]             }
[11:01:54.455]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.455]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.455]         }
[11:01:54.455]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.455]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.455]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.455]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.455]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.455]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.455]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.455]             base::names(...future.oldOptions))
[11:01:54.455]     }
[11:01:54.455]     if (FALSE) {
[11:01:54.455]     }
[11:01:54.455]     else {
[11:01:54.455]         if (TRUE) {
[11:01:54.455]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.455]                 open = "w")
[11:01:54.455]         }
[11:01:54.455]         else {
[11:01:54.455]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.455]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.455]         }
[11:01:54.455]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.455]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.455]             base::sink(type = "output", split = FALSE)
[11:01:54.455]             base::close(...future.stdout)
[11:01:54.455]         }, add = TRUE)
[11:01:54.455]     }
[11:01:54.455]     ...future.frame <- base::sys.nframe()
[11:01:54.455]     ...future.conditions <- base::list()
[11:01:54.455]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.455]     if (FALSE) {
[11:01:54.455]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.455]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.455]     }
[11:01:54.455]     ...future.result <- base::tryCatch({
[11:01:54.455]         base::withCallingHandlers({
[11:01:54.455]             ...future.value <- base::withVisible(base::local({
[11:01:54.455]                 ...future.makeSendCondition <- base::local({
[11:01:54.455]                   sendCondition <- NULL
[11:01:54.455]                   function(frame = 1L) {
[11:01:54.455]                     if (is.function(sendCondition)) 
[11:01:54.455]                       return(sendCondition)
[11:01:54.455]                     ns <- getNamespace("parallel")
[11:01:54.455]                     if (exists("sendData", mode = "function", 
[11:01:54.455]                       envir = ns)) {
[11:01:54.455]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.455]                         envir = ns)
[11:01:54.455]                       envir <- sys.frame(frame)
[11:01:54.455]                       master <- NULL
[11:01:54.455]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.455]                         !identical(envir, emptyenv())) {
[11:01:54.455]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.455]                           inherits = FALSE)) {
[11:01:54.455]                           master <- get("master", mode = "list", 
[11:01:54.455]                             envir = envir, inherits = FALSE)
[11:01:54.455]                           if (inherits(master, c("SOCKnode", 
[11:01:54.455]                             "SOCK0node"))) {
[11:01:54.455]                             sendCondition <<- function(cond) {
[11:01:54.455]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.455]                                 success = TRUE)
[11:01:54.455]                               parallel_sendData(master, data)
[11:01:54.455]                             }
[11:01:54.455]                             return(sendCondition)
[11:01:54.455]                           }
[11:01:54.455]                         }
[11:01:54.455]                         frame <- frame + 1L
[11:01:54.455]                         envir <- sys.frame(frame)
[11:01:54.455]                       }
[11:01:54.455]                     }
[11:01:54.455]                     sendCondition <<- function(cond) NULL
[11:01:54.455]                   }
[11:01:54.455]                 })
[11:01:54.455]                 withCallingHandlers({
[11:01:54.455]                   {
[11:01:54.455]                     b <- a * ii
[11:01:54.455]                     a <- 0
[11:01:54.455]                     b
[11:01:54.455]                   }
[11:01:54.455]                 }, immediateCondition = function(cond) {
[11:01:54.455]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.455]                   sendCondition(cond)
[11:01:54.455]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.455]                   {
[11:01:54.455]                     inherits <- base::inherits
[11:01:54.455]                     invokeRestart <- base::invokeRestart
[11:01:54.455]                     is.null <- base::is.null
[11:01:54.455]                     muffled <- FALSE
[11:01:54.455]                     if (inherits(cond, "message")) {
[11:01:54.455]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.455]                       if (muffled) 
[11:01:54.455]                         invokeRestart("muffleMessage")
[11:01:54.455]                     }
[11:01:54.455]                     else if (inherits(cond, "warning")) {
[11:01:54.455]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.455]                       if (muffled) 
[11:01:54.455]                         invokeRestart("muffleWarning")
[11:01:54.455]                     }
[11:01:54.455]                     else if (inherits(cond, "condition")) {
[11:01:54.455]                       if (!is.null(pattern)) {
[11:01:54.455]                         computeRestarts <- base::computeRestarts
[11:01:54.455]                         grepl <- base::grepl
[11:01:54.455]                         restarts <- computeRestarts(cond)
[11:01:54.455]                         for (restart in restarts) {
[11:01:54.455]                           name <- restart$name
[11:01:54.455]                           if (is.null(name)) 
[11:01:54.455]                             next
[11:01:54.455]                           if (!grepl(pattern, name)) 
[11:01:54.455]                             next
[11:01:54.455]                           invokeRestart(restart)
[11:01:54.455]                           muffled <- TRUE
[11:01:54.455]                           break
[11:01:54.455]                         }
[11:01:54.455]                       }
[11:01:54.455]                     }
[11:01:54.455]                     invisible(muffled)
[11:01:54.455]                   }
[11:01:54.455]                   muffleCondition(cond)
[11:01:54.455]                 })
[11:01:54.455]             }))
[11:01:54.455]             future::FutureResult(value = ...future.value$value, 
[11:01:54.455]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.455]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.455]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.455]                     ...future.globalenv.names))
[11:01:54.455]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.455]         }, condition = base::local({
[11:01:54.455]             c <- base::c
[11:01:54.455]             inherits <- base::inherits
[11:01:54.455]             invokeRestart <- base::invokeRestart
[11:01:54.455]             length <- base::length
[11:01:54.455]             list <- base::list
[11:01:54.455]             seq.int <- base::seq.int
[11:01:54.455]             signalCondition <- base::signalCondition
[11:01:54.455]             sys.calls <- base::sys.calls
[11:01:54.455]             `[[` <- base::`[[`
[11:01:54.455]             `+` <- base::`+`
[11:01:54.455]             `<<-` <- base::`<<-`
[11:01:54.455]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.455]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.455]                   3L)]
[11:01:54.455]             }
[11:01:54.455]             function(cond) {
[11:01:54.455]                 is_error <- inherits(cond, "error")
[11:01:54.455]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.455]                   NULL)
[11:01:54.455]                 if (is_error) {
[11:01:54.455]                   sessionInformation <- function() {
[11:01:54.455]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.455]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.455]                       search = base::search(), system = base::Sys.info())
[11:01:54.455]                   }
[11:01:54.455]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.455]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.455]                     cond$call), session = sessionInformation(), 
[11:01:54.455]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.455]                   signalCondition(cond)
[11:01:54.455]                 }
[11:01:54.455]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.455]                 "immediateCondition"))) {
[11:01:54.455]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.455]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.455]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.455]                   if (TRUE && !signal) {
[11:01:54.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.455]                     {
[11:01:54.455]                       inherits <- base::inherits
[11:01:54.455]                       invokeRestart <- base::invokeRestart
[11:01:54.455]                       is.null <- base::is.null
[11:01:54.455]                       muffled <- FALSE
[11:01:54.455]                       if (inherits(cond, "message")) {
[11:01:54.455]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.455]                         if (muffled) 
[11:01:54.455]                           invokeRestart("muffleMessage")
[11:01:54.455]                       }
[11:01:54.455]                       else if (inherits(cond, "warning")) {
[11:01:54.455]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.455]                         if (muffled) 
[11:01:54.455]                           invokeRestart("muffleWarning")
[11:01:54.455]                       }
[11:01:54.455]                       else if (inherits(cond, "condition")) {
[11:01:54.455]                         if (!is.null(pattern)) {
[11:01:54.455]                           computeRestarts <- base::computeRestarts
[11:01:54.455]                           grepl <- base::grepl
[11:01:54.455]                           restarts <- computeRestarts(cond)
[11:01:54.455]                           for (restart in restarts) {
[11:01:54.455]                             name <- restart$name
[11:01:54.455]                             if (is.null(name)) 
[11:01:54.455]                               next
[11:01:54.455]                             if (!grepl(pattern, name)) 
[11:01:54.455]                               next
[11:01:54.455]                             invokeRestart(restart)
[11:01:54.455]                             muffled <- TRUE
[11:01:54.455]                             break
[11:01:54.455]                           }
[11:01:54.455]                         }
[11:01:54.455]                       }
[11:01:54.455]                       invisible(muffled)
[11:01:54.455]                     }
[11:01:54.455]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.455]                   }
[11:01:54.455]                 }
[11:01:54.455]                 else {
[11:01:54.455]                   if (TRUE) {
[11:01:54.455]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.455]                     {
[11:01:54.455]                       inherits <- base::inherits
[11:01:54.455]                       invokeRestart <- base::invokeRestart
[11:01:54.455]                       is.null <- base::is.null
[11:01:54.455]                       muffled <- FALSE
[11:01:54.455]                       if (inherits(cond, "message")) {
[11:01:54.455]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.455]                         if (muffled) 
[11:01:54.455]                           invokeRestart("muffleMessage")
[11:01:54.455]                       }
[11:01:54.455]                       else if (inherits(cond, "warning")) {
[11:01:54.455]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.455]                         if (muffled) 
[11:01:54.455]                           invokeRestart("muffleWarning")
[11:01:54.455]                       }
[11:01:54.455]                       else if (inherits(cond, "condition")) {
[11:01:54.455]                         if (!is.null(pattern)) {
[11:01:54.455]                           computeRestarts <- base::computeRestarts
[11:01:54.455]                           grepl <- base::grepl
[11:01:54.455]                           restarts <- computeRestarts(cond)
[11:01:54.455]                           for (restart in restarts) {
[11:01:54.455]                             name <- restart$name
[11:01:54.455]                             if (is.null(name)) 
[11:01:54.455]                               next
[11:01:54.455]                             if (!grepl(pattern, name)) 
[11:01:54.455]                               next
[11:01:54.455]                             invokeRestart(restart)
[11:01:54.455]                             muffled <- TRUE
[11:01:54.455]                             break
[11:01:54.455]                           }
[11:01:54.455]                         }
[11:01:54.455]                       }
[11:01:54.455]                       invisible(muffled)
[11:01:54.455]                     }
[11:01:54.455]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.455]                   }
[11:01:54.455]                 }
[11:01:54.455]             }
[11:01:54.455]         }))
[11:01:54.455]     }, error = function(ex) {
[11:01:54.455]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.455]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.455]                 ...future.rng), started = ...future.startTime, 
[11:01:54.455]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.455]             version = "1.8"), class = "FutureResult")
[11:01:54.455]     }, finally = {
[11:01:54.455]         if (!identical(...future.workdir, getwd())) 
[11:01:54.455]             setwd(...future.workdir)
[11:01:54.455]         {
[11:01:54.455]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.455]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.455]             }
[11:01:54.455]             base::options(...future.oldOptions)
[11:01:54.455]             if (.Platform$OS.type == "windows") {
[11:01:54.455]                 old_names <- names(...future.oldEnvVars)
[11:01:54.455]                 envs <- base::Sys.getenv()
[11:01:54.455]                 names <- names(envs)
[11:01:54.455]                 common <- intersect(names, old_names)
[11:01:54.455]                 added <- setdiff(names, old_names)
[11:01:54.455]                 removed <- setdiff(old_names, names)
[11:01:54.455]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.455]                   envs[common]]
[11:01:54.455]                 NAMES <- toupper(changed)
[11:01:54.455]                 args <- list()
[11:01:54.455]                 for (kk in seq_along(NAMES)) {
[11:01:54.455]                   name <- changed[[kk]]
[11:01:54.455]                   NAME <- NAMES[[kk]]
[11:01:54.455]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.455]                     next
[11:01:54.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.455]                 }
[11:01:54.455]                 NAMES <- toupper(added)
[11:01:54.455]                 for (kk in seq_along(NAMES)) {
[11:01:54.455]                   name <- added[[kk]]
[11:01:54.455]                   NAME <- NAMES[[kk]]
[11:01:54.455]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.455]                     next
[11:01:54.455]                   args[[name]] <- ""
[11:01:54.455]                 }
[11:01:54.455]                 NAMES <- toupper(removed)
[11:01:54.455]                 for (kk in seq_along(NAMES)) {
[11:01:54.455]                   name <- removed[[kk]]
[11:01:54.455]                   NAME <- NAMES[[kk]]
[11:01:54.455]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.455]                     next
[11:01:54.455]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.455]                 }
[11:01:54.455]                 if (length(args) > 0) 
[11:01:54.455]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.455]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.455]             }
[11:01:54.455]             else {
[11:01:54.455]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.455]             }
[11:01:54.455]             {
[11:01:54.455]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.455]                   0L) {
[11:01:54.455]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.455]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.455]                   base::options(opts)
[11:01:54.455]                 }
[11:01:54.455]                 {
[11:01:54.455]                   {
[11:01:54.455]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.455]                     NULL
[11:01:54.455]                   }
[11:01:54.455]                   options(future.plan = NULL)
[11:01:54.455]                   if (is.na(NA_character_)) 
[11:01:54.455]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.455]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.455]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.455]                     .init = FALSE)
[11:01:54.455]                 }
[11:01:54.455]             }
[11:01:54.455]         }
[11:01:54.455]     })
[11:01:54.455]     if (TRUE) {
[11:01:54.455]         base::sink(type = "output", split = FALSE)
[11:01:54.455]         if (TRUE) {
[11:01:54.455]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.455]         }
[11:01:54.455]         else {
[11:01:54.455]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.455]         }
[11:01:54.455]         base::close(...future.stdout)
[11:01:54.455]         ...future.stdout <- NULL
[11:01:54.455]     }
[11:01:54.455]     ...future.result$conditions <- ...future.conditions
[11:01:54.455]     ...future.result$finished <- base::Sys.time()
[11:01:54.455]     ...future.result
[11:01:54.455] }
[11:01:54.457] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:54.468] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.468] - Validating connection of MultisessionFuture
[11:01:54.469] - received message: FutureResult
[11:01:54.469] - Received FutureResult
[11:01:54.469] - Erased future from FutureRegistry
[11:01:54.469] result() for ClusterFuture ...
[11:01:54.469] - result already collected: FutureResult
[11:01:54.469] result() for ClusterFuture ... done
[11:01:54.469] signalConditions() ...
[11:01:54.469]  - include = ‘immediateCondition’
[11:01:54.470]  - exclude = 
[11:01:54.470]  - resignal = FALSE
[11:01:54.471]  - Number of conditions: 1
[11:01:54.472] signalConditions() ... done
[11:01:54.472] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.472] result() for ClusterFuture ...
[11:01:54.472] - result already collected: FutureResult
[11:01:54.472] result() for ClusterFuture ... done
[11:01:54.472] result() for ClusterFuture ...
[11:01:54.472] - result already collected: FutureResult
[11:01:54.472] result() for ClusterFuture ... done
[11:01:54.472] signalConditions() ...
[11:01:54.472]  - include = ‘immediateCondition’
[11:01:54.472]  - exclude = 
[11:01:54.472]  - resignal = FALSE
[11:01:54.473]  - Number of conditions: 1
[11:01:54.473] signalConditions() ... done
[11:01:54.473] Exporting 1 global objects (344 bytes) to cluster node #2 ...
[11:01:54.473] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:01:54.474] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:01:54.474] Exporting 1 global objects (344 bytes) to cluster node #2 ... DONE
[11:01:54.474] MultisessionFuture started
[11:01:54.474] - Launch lazy future ... done
[11:01:54.474] run() for ‘MultisessionFuture’ ... done
[11:01:54.475] result() for ClusterFuture ...
[11:01:54.475] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.475] - Validating connection of MultisessionFuture
[11:01:54.520] - received message: FutureResult
[11:01:54.520] - Received FutureResult
[11:01:54.520] - Erased future from FutureRegistry
[11:01:54.520] result() for ClusterFuture ...
[11:01:54.520] - result already collected: FutureResult
[11:01:54.520] result() for ClusterFuture ... done
[11:01:54.521] signalConditions() ...
[11:01:54.521]  - include = ‘immediateCondition’
[11:01:54.521]  - exclude = 
[11:01:54.521]  - resignal = FALSE
[11:01:54.521]  - Number of conditions: 1
[11:01:54.521] signalConditions() ... done
[11:01:54.521] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.521] result() for ClusterFuture ... done
[11:01:54.521] result() for ClusterFuture ...
[11:01:54.521] - result already collected: FutureResult
[11:01:54.521] result() for ClusterFuture ... done
[11:01:54.521] signalConditions() ...
[11:01:54.521]  - include = ‘immediateCondition’
[11:01:54.522]  - exclude = 
[11:01:54.522]  - resignal = FALSE
[11:01:54.522]  - Number of conditions: 1
[11:01:54.522] signalConditions() ... done
[11:01:54.522] Future state: ‘finished’
[11:01:54.522] result() for ClusterFuture ...
[11:01:54.522] - result already collected: FutureResult
[11:01:54.522] result() for ClusterFuture ... done
[11:01:54.522] signalConditions() ...
[11:01:54.522]  - include = ‘condition’
[11:01:54.522]  - exclude = ‘immediateCondition’
[11:01:54.522]  - resignal = TRUE
[11:01:54.523]  - Number of conditions: 1
[11:01:54.523]  - Condition #1: ‘simpleError’, ‘error’, ‘condition’
[11:01:54.523] signalConditions() ... done
List of 1
 $ res: 'try-error' chr "Error in eval(quote({ : object 'a' not found\n"
  ..- attr(*, "condition")=List of 3
  .. ..$ message    : chr "object 'a' not found"
  .. ..$ call       : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. ..$ future.info:List of 5
  .. .. ..$ condition:List of 2
  .. .. .. ..$ message: chr "object 'a' not found"
  .. .. .. ..$ call   : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
  .. .. ..$ calls    :List of 12
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language eval(fassignment, envir = envir, enclos = baseenv())
  .. .. .. ..$ : language res[[ii]] %<-% {     b <- a * ii ...
  .. .. .. ..$ : language futureAssignInternal(target, expr, envir = envir, substitute = FALSE)
  .. .. .. ..$ : language futureAssign(name, expr, envir = envir, assign.env = assign.env, substitute = FALSE)
  .. .. .. ..$ : language do.call(future::future, args = future.args, envir = assign.env)
  .. .. .. ..$ : language (function (expr, envir = parent.frame(), substitute = TRUE, lazy = FALSE,      seed = FALSE, globals = TRUE, pack| __truncated__ ...
  .. .. .. ..$ : language Future(expr, substitute = FALSE, envir = envir, lazy = TRUE, seed = seed,      globals = globals, packages = pack| __truncated__ ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. .. ..$ : language withCallingHandlers({     { ...
  .. .. .. ..$ : language eval(quote({     ...future.makeSendCondition <- base::local({ ...
  .. .. ..$ session  :List of 6
  .. .. .. ..$ r         :List of 14
  .. .. .. .. ..$ platform      : chr "x86_64-pc-linux-gnu"
  .. .. .. .. ..$ arch          : chr "x86_64"
  .. .. .. .. ..$ os            : chr "linux-gnu"
  .. .. .. .. ..$ system        : chr "x86_64, linux-gnu"
  .. .. .. .. ..$ status        : chr ""
  .. .. .. .. ..$ major         : chr "4"
  .. .. .. .. ..$ minor         : chr "4.3"
  .. .. .. .. ..$ year          : chr "2025"
  .. .. .. .. ..$ month         : chr "02"
  .. .. .. .. ..$ day           : chr "28"
  .. .. .. .. ..$ svn rev       : chr "87843"
  .. .. .. .. ..$ language      : chr "R"
  .. .. .. .. ..$ version.string: chr "R version 4.4.3 (2025-02-28)"
  .. .. .. .. ..$ nickname      : chr "Trophy Case"
  .. .. .. ..$ locale    : chr "LC_CTYPE=en_US.UTF-8;LC_NUMERIC=C;LC_TIME=en_US.UTF-8;LC_COLLATE=en_US.UTF-8;LC_MONETARY=en_US.UTF-8;LC_MESSAGE"| __truncated__
  .. .. .. ..$ rngkind   : chr [1:3] "Mersenne-Twister" "Inversion" "Rejection"
  .. .. .. ..$ namespaces: chr [1:16] "compiler" "parallelly" "graphics" "tools" ...
  .. .. .. ..$ search    : chr [1:9] ".GlobalEnv" "package:stats" "package:graphics" "package:grDevices" ...
  .. .. .. ..$ system    : Named chr [1:8] "Linux" "6.11.0-1012-azure" "#12~24.04.1-Ubuntu SMP Mon Mar 10 19:00:39 UTC 2025" "173ee284ba16" ...
  .. .. .. .. ..- attr(*, "names")= chr [1:8] "sysname" "release" "version" "nodename" ...
  .. .. ..$ timestamp: POSIXct[1:1], format: "2025-05-06 11:01:54"
  .. .. ..$ signaled : int 1
  .. ..- attr(*, "class")= chr [1:3] "simpleError" "error" "condition"
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.535] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.535] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.536] 
[11:01:54.536] Searching for globals ... DONE
[11:01:54.536] - globals: [0] <none>
[11:01:54.536] getGlobalsAndPackages() ... DONE
[11:01:54.536] run() for ‘Future’ ...
[11:01:54.537] - state: ‘created’
[11:01:54.537] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.552] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.552] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.552]   - Field: ‘node’
[11:01:54.553]   - Field: ‘label’
[11:01:54.553]   - Field: ‘local’
[11:01:54.553]   - Field: ‘owner’
[11:01:54.553]   - Field: ‘envir’
[11:01:54.553]   - Field: ‘workers’
[11:01:54.553]   - Field: ‘packages’
[11:01:54.553]   - Field: ‘gc’
[11:01:54.553]   - Field: ‘conditions’
[11:01:54.553]   - Field: ‘persistent’
[11:01:54.554]   - Field: ‘expr’
[11:01:54.554]   - Field: ‘uuid’
[11:01:54.554]   - Field: ‘seed’
[11:01:54.554]   - Field: ‘version’
[11:01:54.554]   - Field: ‘result’
[11:01:54.554]   - Field: ‘asynchronous’
[11:01:54.554]   - Field: ‘calls’
[11:01:54.554]   - Field: ‘globals’
[11:01:54.555]   - Field: ‘stdout’
[11:01:54.555]   - Field: ‘earlySignal’
[11:01:54.555]   - Field: ‘lazy’
[11:01:54.555]   - Field: ‘state’
[11:01:54.555] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.555] - Launch lazy future ...
[11:01:54.556] Packages needed by the future expression (n = 0): <none>
[11:01:54.556] Packages needed by future strategies (n = 0): <none>
[11:01:54.556] {
[11:01:54.556]     {
[11:01:54.556]         {
[11:01:54.556]             ...future.startTime <- base::Sys.time()
[11:01:54.556]             {
[11:01:54.556]                 {
[11:01:54.556]                   {
[11:01:54.556]                     {
[11:01:54.556]                       base::local({
[11:01:54.556]                         has_future <- base::requireNamespace("future", 
[11:01:54.556]                           quietly = TRUE)
[11:01:54.556]                         if (has_future) {
[11:01:54.556]                           ns <- base::getNamespace("future")
[11:01:54.556]                           version <- ns[[".package"]][["version"]]
[11:01:54.556]                           if (is.null(version)) 
[11:01:54.556]                             version <- utils::packageVersion("future")
[11:01:54.556]                         }
[11:01:54.556]                         else {
[11:01:54.556]                           version <- NULL
[11:01:54.556]                         }
[11:01:54.556]                         if (!has_future || version < "1.8.0") {
[11:01:54.556]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.556]                             "", base::R.version$version.string), 
[11:01:54.556]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.556]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.556]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.556]                               "release", "version")], collapse = " "), 
[11:01:54.556]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.556]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.556]                             info)
[11:01:54.556]                           info <- base::paste(info, collapse = "; ")
[11:01:54.556]                           if (!has_future) {
[11:01:54.556]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.556]                               info)
[11:01:54.556]                           }
[11:01:54.556]                           else {
[11:01:54.556]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.556]                               info, version)
[11:01:54.556]                           }
[11:01:54.556]                           base::stop(msg)
[11:01:54.556]                         }
[11:01:54.556]                       })
[11:01:54.556]                     }
[11:01:54.556]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.556]                     base::options(mc.cores = 1L)
[11:01:54.556]                   }
[11:01:54.556]                   ...future.strategy.old <- future::plan("list")
[11:01:54.556]                   options(future.plan = NULL)
[11:01:54.556]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.556]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.556]                 }
[11:01:54.556]                 ...future.workdir <- getwd()
[11:01:54.556]             }
[11:01:54.556]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.556]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.556]         }
[11:01:54.556]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.556]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.556]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.556]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.556]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.556]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.556]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.556]             base::names(...future.oldOptions))
[11:01:54.556]     }
[11:01:54.556]     if (FALSE) {
[11:01:54.556]     }
[11:01:54.556]     else {
[11:01:54.556]         if (TRUE) {
[11:01:54.556]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.556]                 open = "w")
[11:01:54.556]         }
[11:01:54.556]         else {
[11:01:54.556]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.556]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.556]         }
[11:01:54.556]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.556]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.556]             base::sink(type = "output", split = FALSE)
[11:01:54.556]             base::close(...future.stdout)
[11:01:54.556]         }, add = TRUE)
[11:01:54.556]     }
[11:01:54.556]     ...future.frame <- base::sys.nframe()
[11:01:54.556]     ...future.conditions <- base::list()
[11:01:54.556]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.556]     if (FALSE) {
[11:01:54.556]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.556]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.556]     }
[11:01:54.556]     ...future.result <- base::tryCatch({
[11:01:54.556]         base::withCallingHandlers({
[11:01:54.556]             ...future.value <- base::withVisible(base::local({
[11:01:54.556]                 ...future.makeSendCondition <- base::local({
[11:01:54.556]                   sendCondition <- NULL
[11:01:54.556]                   function(frame = 1L) {
[11:01:54.556]                     if (is.function(sendCondition)) 
[11:01:54.556]                       return(sendCondition)
[11:01:54.556]                     ns <- getNamespace("parallel")
[11:01:54.556]                     if (exists("sendData", mode = "function", 
[11:01:54.556]                       envir = ns)) {
[11:01:54.556]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.556]                         envir = ns)
[11:01:54.556]                       envir <- sys.frame(frame)
[11:01:54.556]                       master <- NULL
[11:01:54.556]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.556]                         !identical(envir, emptyenv())) {
[11:01:54.556]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.556]                           inherits = FALSE)) {
[11:01:54.556]                           master <- get("master", mode = "list", 
[11:01:54.556]                             envir = envir, inherits = FALSE)
[11:01:54.556]                           if (inherits(master, c("SOCKnode", 
[11:01:54.556]                             "SOCK0node"))) {
[11:01:54.556]                             sendCondition <<- function(cond) {
[11:01:54.556]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.556]                                 success = TRUE)
[11:01:54.556]                               parallel_sendData(master, data)
[11:01:54.556]                             }
[11:01:54.556]                             return(sendCondition)
[11:01:54.556]                           }
[11:01:54.556]                         }
[11:01:54.556]                         frame <- frame + 1L
[11:01:54.556]                         envir <- sys.frame(frame)
[11:01:54.556]                       }
[11:01:54.556]                     }
[11:01:54.556]                     sendCondition <<- function(cond) NULL
[11:01:54.556]                   }
[11:01:54.556]                 })
[11:01:54.556]                 withCallingHandlers({
[11:01:54.556]                   1
[11:01:54.556]                 }, immediateCondition = function(cond) {
[11:01:54.556]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.556]                   sendCondition(cond)
[11:01:54.556]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.556]                   {
[11:01:54.556]                     inherits <- base::inherits
[11:01:54.556]                     invokeRestart <- base::invokeRestart
[11:01:54.556]                     is.null <- base::is.null
[11:01:54.556]                     muffled <- FALSE
[11:01:54.556]                     if (inherits(cond, "message")) {
[11:01:54.556]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.556]                       if (muffled) 
[11:01:54.556]                         invokeRestart("muffleMessage")
[11:01:54.556]                     }
[11:01:54.556]                     else if (inherits(cond, "warning")) {
[11:01:54.556]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.556]                       if (muffled) 
[11:01:54.556]                         invokeRestart("muffleWarning")
[11:01:54.556]                     }
[11:01:54.556]                     else if (inherits(cond, "condition")) {
[11:01:54.556]                       if (!is.null(pattern)) {
[11:01:54.556]                         computeRestarts <- base::computeRestarts
[11:01:54.556]                         grepl <- base::grepl
[11:01:54.556]                         restarts <- computeRestarts(cond)
[11:01:54.556]                         for (restart in restarts) {
[11:01:54.556]                           name <- restart$name
[11:01:54.556]                           if (is.null(name)) 
[11:01:54.556]                             next
[11:01:54.556]                           if (!grepl(pattern, name)) 
[11:01:54.556]                             next
[11:01:54.556]                           invokeRestart(restart)
[11:01:54.556]                           muffled <- TRUE
[11:01:54.556]                           break
[11:01:54.556]                         }
[11:01:54.556]                       }
[11:01:54.556]                     }
[11:01:54.556]                     invisible(muffled)
[11:01:54.556]                   }
[11:01:54.556]                   muffleCondition(cond)
[11:01:54.556]                 })
[11:01:54.556]             }))
[11:01:54.556]             future::FutureResult(value = ...future.value$value, 
[11:01:54.556]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.556]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.556]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.556]                     ...future.globalenv.names))
[11:01:54.556]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.556]         }, condition = base::local({
[11:01:54.556]             c <- base::c
[11:01:54.556]             inherits <- base::inherits
[11:01:54.556]             invokeRestart <- base::invokeRestart
[11:01:54.556]             length <- base::length
[11:01:54.556]             list <- base::list
[11:01:54.556]             seq.int <- base::seq.int
[11:01:54.556]             signalCondition <- base::signalCondition
[11:01:54.556]             sys.calls <- base::sys.calls
[11:01:54.556]             `[[` <- base::`[[`
[11:01:54.556]             `+` <- base::`+`
[11:01:54.556]             `<<-` <- base::`<<-`
[11:01:54.556]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.556]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.556]                   3L)]
[11:01:54.556]             }
[11:01:54.556]             function(cond) {
[11:01:54.556]                 is_error <- inherits(cond, "error")
[11:01:54.556]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.556]                   NULL)
[11:01:54.556]                 if (is_error) {
[11:01:54.556]                   sessionInformation <- function() {
[11:01:54.556]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.556]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.556]                       search = base::search(), system = base::Sys.info())
[11:01:54.556]                   }
[11:01:54.556]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.556]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.556]                     cond$call), session = sessionInformation(), 
[11:01:54.556]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.556]                   signalCondition(cond)
[11:01:54.556]                 }
[11:01:54.556]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.556]                 "immediateCondition"))) {
[11:01:54.556]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.556]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.556]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.556]                   if (TRUE && !signal) {
[11:01:54.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.556]                     {
[11:01:54.556]                       inherits <- base::inherits
[11:01:54.556]                       invokeRestart <- base::invokeRestart
[11:01:54.556]                       is.null <- base::is.null
[11:01:54.556]                       muffled <- FALSE
[11:01:54.556]                       if (inherits(cond, "message")) {
[11:01:54.556]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.556]                         if (muffled) 
[11:01:54.556]                           invokeRestart("muffleMessage")
[11:01:54.556]                       }
[11:01:54.556]                       else if (inherits(cond, "warning")) {
[11:01:54.556]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.556]                         if (muffled) 
[11:01:54.556]                           invokeRestart("muffleWarning")
[11:01:54.556]                       }
[11:01:54.556]                       else if (inherits(cond, "condition")) {
[11:01:54.556]                         if (!is.null(pattern)) {
[11:01:54.556]                           computeRestarts <- base::computeRestarts
[11:01:54.556]                           grepl <- base::grepl
[11:01:54.556]                           restarts <- computeRestarts(cond)
[11:01:54.556]                           for (restart in restarts) {
[11:01:54.556]                             name <- restart$name
[11:01:54.556]                             if (is.null(name)) 
[11:01:54.556]                               next
[11:01:54.556]                             if (!grepl(pattern, name)) 
[11:01:54.556]                               next
[11:01:54.556]                             invokeRestart(restart)
[11:01:54.556]                             muffled <- TRUE
[11:01:54.556]                             break
[11:01:54.556]                           }
[11:01:54.556]                         }
[11:01:54.556]                       }
[11:01:54.556]                       invisible(muffled)
[11:01:54.556]                     }
[11:01:54.556]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.556]                   }
[11:01:54.556]                 }
[11:01:54.556]                 else {
[11:01:54.556]                   if (TRUE) {
[11:01:54.556]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.556]                     {
[11:01:54.556]                       inherits <- base::inherits
[11:01:54.556]                       invokeRestart <- base::invokeRestart
[11:01:54.556]                       is.null <- base::is.null
[11:01:54.556]                       muffled <- FALSE
[11:01:54.556]                       if (inherits(cond, "message")) {
[11:01:54.556]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.556]                         if (muffled) 
[11:01:54.556]                           invokeRestart("muffleMessage")
[11:01:54.556]                       }
[11:01:54.556]                       else if (inherits(cond, "warning")) {
[11:01:54.556]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.556]                         if (muffled) 
[11:01:54.556]                           invokeRestart("muffleWarning")
[11:01:54.556]                       }
[11:01:54.556]                       else if (inherits(cond, "condition")) {
[11:01:54.556]                         if (!is.null(pattern)) {
[11:01:54.556]                           computeRestarts <- base::computeRestarts
[11:01:54.556]                           grepl <- base::grepl
[11:01:54.556]                           restarts <- computeRestarts(cond)
[11:01:54.556]                           for (restart in restarts) {
[11:01:54.556]                             name <- restart$name
[11:01:54.556]                             if (is.null(name)) 
[11:01:54.556]                               next
[11:01:54.556]                             if (!grepl(pattern, name)) 
[11:01:54.556]                               next
[11:01:54.556]                             invokeRestart(restart)
[11:01:54.556]                             muffled <- TRUE
[11:01:54.556]                             break
[11:01:54.556]                           }
[11:01:54.556]                         }
[11:01:54.556]                       }
[11:01:54.556]                       invisible(muffled)
[11:01:54.556]                     }
[11:01:54.556]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.556]                   }
[11:01:54.556]                 }
[11:01:54.556]             }
[11:01:54.556]         }))
[11:01:54.556]     }, error = function(ex) {
[11:01:54.556]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.556]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.556]                 ...future.rng), started = ...future.startTime, 
[11:01:54.556]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.556]             version = "1.8"), class = "FutureResult")
[11:01:54.556]     }, finally = {
[11:01:54.556]         if (!identical(...future.workdir, getwd())) 
[11:01:54.556]             setwd(...future.workdir)
[11:01:54.556]         {
[11:01:54.556]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.556]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.556]             }
[11:01:54.556]             base::options(...future.oldOptions)
[11:01:54.556]             if (.Platform$OS.type == "windows") {
[11:01:54.556]                 old_names <- names(...future.oldEnvVars)
[11:01:54.556]                 envs <- base::Sys.getenv()
[11:01:54.556]                 names <- names(envs)
[11:01:54.556]                 common <- intersect(names, old_names)
[11:01:54.556]                 added <- setdiff(names, old_names)
[11:01:54.556]                 removed <- setdiff(old_names, names)
[11:01:54.556]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.556]                   envs[common]]
[11:01:54.556]                 NAMES <- toupper(changed)
[11:01:54.556]                 args <- list()
[11:01:54.556]                 for (kk in seq_along(NAMES)) {
[11:01:54.556]                   name <- changed[[kk]]
[11:01:54.556]                   NAME <- NAMES[[kk]]
[11:01:54.556]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.556]                     next
[11:01:54.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.556]                 }
[11:01:54.556]                 NAMES <- toupper(added)
[11:01:54.556]                 for (kk in seq_along(NAMES)) {
[11:01:54.556]                   name <- added[[kk]]
[11:01:54.556]                   NAME <- NAMES[[kk]]
[11:01:54.556]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.556]                     next
[11:01:54.556]                   args[[name]] <- ""
[11:01:54.556]                 }
[11:01:54.556]                 NAMES <- toupper(removed)
[11:01:54.556]                 for (kk in seq_along(NAMES)) {
[11:01:54.556]                   name <- removed[[kk]]
[11:01:54.556]                   NAME <- NAMES[[kk]]
[11:01:54.556]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.556]                     next
[11:01:54.556]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.556]                 }
[11:01:54.556]                 if (length(args) > 0) 
[11:01:54.556]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.556]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.556]             }
[11:01:54.556]             else {
[11:01:54.556]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.556]             }
[11:01:54.556]             {
[11:01:54.556]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.556]                   0L) {
[11:01:54.556]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.556]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.556]                   base::options(opts)
[11:01:54.556]                 }
[11:01:54.556]                 {
[11:01:54.556]                   {
[11:01:54.556]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.556]                     NULL
[11:01:54.556]                   }
[11:01:54.556]                   options(future.plan = NULL)
[11:01:54.556]                   if (is.na(NA_character_)) 
[11:01:54.556]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.556]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.556]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.556]                     .init = FALSE)
[11:01:54.556]                 }
[11:01:54.556]             }
[11:01:54.556]         }
[11:01:54.556]     })
[11:01:54.556]     if (TRUE) {
[11:01:54.556]         base::sink(type = "output", split = FALSE)
[11:01:54.556]         if (TRUE) {
[11:01:54.556]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.556]         }
[11:01:54.556]         else {
[11:01:54.556]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.556]         }
[11:01:54.556]         base::close(...future.stdout)
[11:01:54.556]         ...future.stdout <- NULL
[11:01:54.556]     }
[11:01:54.556]     ...future.result$conditions <- ...future.conditions
[11:01:54.556]     ...future.result$finished <- base::Sys.time()
[11:01:54.556]     ...future.result
[11:01:54.556] }
[11:01:54.561] MultisessionFuture started
[11:01:54.561] - Launch lazy future ... done
[11:01:54.561] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.561] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.561] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.563] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:54.563] Searching for globals ... DONE
[11:01:54.563] Resolving globals: TRUE
[11:01:54.563] Resolving any globals that are futures ...
[11:01:54.563] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:54.563] Resolving any globals that are futures ... DONE
[11:01:54.563] Resolving futures part of globals (recursively) ...
[11:01:54.564] resolve() on list ...
[11:01:54.564]  recursive: 99
[11:01:54.564]  length: 1
[11:01:54.564]  elements: ‘a’
[11:01:54.606] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.606] - Validating connection of MultisessionFuture
[11:01:54.606] - received message: FutureResult
[11:01:54.606] - Received FutureResult
[11:01:54.606] - Erased future from FutureRegistry
[11:01:54.606] result() for ClusterFuture ...
[11:01:54.606] - result already collected: FutureResult
[11:01:54.606] result() for ClusterFuture ... done
[11:01:54.606] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.607] Future #1
[11:01:54.607] result() for ClusterFuture ...
[11:01:54.607] - result already collected: FutureResult
[11:01:54.607] result() for ClusterFuture ... done
[11:01:54.607] result() for ClusterFuture ...
[11:01:54.607] - result already collected: FutureResult
[11:01:54.607] result() for ClusterFuture ... done
[11:01:54.607] A MultisessionFuture was resolved
[11:01:54.607]  length: 0 (resolved future 1)
[11:01:54.607] resolve() on list ... DONE
[11:01:54.607] - globals: [1] ‘a’
[11:01:54.608] Resolving futures part of globals (recursively) ... DONE
[11:01:54.618] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[11:01:54.619] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[11:01:54.619] - globals: [1] ‘a’
[11:01:54.619] - packages: [1] ‘future’
[11:01:54.619] getGlobalsAndPackages() ... DONE
[11:01:54.619] run() for ‘Future’ ...
[11:01:54.619] - state: ‘created’
[11:01:54.619] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.633] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.633] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.633]   - Field: ‘node’
[11:01:54.633]   - Field: ‘label’
[11:01:54.633]   - Field: ‘local’
[11:01:54.633]   - Field: ‘owner’
[11:01:54.634]   - Field: ‘envir’
[11:01:54.634]   - Field: ‘workers’
[11:01:54.634]   - Field: ‘packages’
[11:01:54.634]   - Field: ‘gc’
[11:01:54.634]   - Field: ‘conditions’
[11:01:54.634]   - Field: ‘persistent’
[11:01:54.634]   - Field: ‘expr’
[11:01:54.634]   - Field: ‘uuid’
[11:01:54.634]   - Field: ‘seed’
[11:01:54.634]   - Field: ‘version’
[11:01:54.634]   - Field: ‘result’
[11:01:54.635]   - Field: ‘asynchronous’
[11:01:54.635]   - Field: ‘calls’
[11:01:54.635]   - Field: ‘globals’
[11:01:54.635]   - Field: ‘stdout’
[11:01:54.635]   - Field: ‘earlySignal’
[11:01:54.635]   - Field: ‘lazy’
[11:01:54.635]   - Field: ‘state’
[11:01:54.635] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.635] - Launch lazy future ...
[11:01:54.635] Packages needed by the future expression (n = 1): ‘future’
[11:01:54.636] Packages needed by future strategies (n = 0): <none>
[11:01:54.636] {
[11:01:54.636]     {
[11:01:54.636]         {
[11:01:54.636]             ...future.startTime <- base::Sys.time()
[11:01:54.636]             {
[11:01:54.636]                 {
[11:01:54.636]                   {
[11:01:54.636]                     {
[11:01:54.636]                       {
[11:01:54.636]                         base::local({
[11:01:54.636]                           has_future <- base::requireNamespace("future", 
[11:01:54.636]                             quietly = TRUE)
[11:01:54.636]                           if (has_future) {
[11:01:54.636]                             ns <- base::getNamespace("future")
[11:01:54.636]                             version <- ns[[".package"]][["version"]]
[11:01:54.636]                             if (is.null(version)) 
[11:01:54.636]                               version <- utils::packageVersion("future")
[11:01:54.636]                           }
[11:01:54.636]                           else {
[11:01:54.636]                             version <- NULL
[11:01:54.636]                           }
[11:01:54.636]                           if (!has_future || version < "1.8.0") {
[11:01:54.636]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.636]                               "", base::R.version$version.string), 
[11:01:54.636]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:54.636]                                 base::R.version$platform, 8 * 
[11:01:54.636]                                   base::.Machine$sizeof.pointer), 
[11:01:54.636]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.636]                                 "release", "version")], collapse = " "), 
[11:01:54.636]                               hostname = base::Sys.info()[["nodename"]])
[11:01:54.636]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.636]                               info)
[11:01:54.636]                             info <- base::paste(info, collapse = "; ")
[11:01:54.636]                             if (!has_future) {
[11:01:54.636]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.636]                                 info)
[11:01:54.636]                             }
[11:01:54.636]                             else {
[11:01:54.636]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.636]                                 info, version)
[11:01:54.636]                             }
[11:01:54.636]                             base::stop(msg)
[11:01:54.636]                           }
[11:01:54.636]                         })
[11:01:54.636]                       }
[11:01:54.636]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.636]                       base::options(mc.cores = 1L)
[11:01:54.636]                     }
[11:01:54.636]                     base::local({
[11:01:54.636]                       for (pkg in "future") {
[11:01:54.636]                         base::loadNamespace(pkg)
[11:01:54.636]                         base::library(pkg, character.only = TRUE)
[11:01:54.636]                       }
[11:01:54.636]                     })
[11:01:54.636]                   }
[11:01:54.636]                   ...future.strategy.old <- future::plan("list")
[11:01:54.636]                   options(future.plan = NULL)
[11:01:54.636]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.636]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.636]                 }
[11:01:54.636]                 ...future.workdir <- getwd()
[11:01:54.636]             }
[11:01:54.636]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.636]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.636]         }
[11:01:54.636]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.636]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.636]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.636]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.636]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.636]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.636]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.636]             base::names(...future.oldOptions))
[11:01:54.636]     }
[11:01:54.636]     if (FALSE) {
[11:01:54.636]     }
[11:01:54.636]     else {
[11:01:54.636]         if (TRUE) {
[11:01:54.636]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.636]                 open = "w")
[11:01:54.636]         }
[11:01:54.636]         else {
[11:01:54.636]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.636]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.636]         }
[11:01:54.636]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.636]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.636]             base::sink(type = "output", split = FALSE)
[11:01:54.636]             base::close(...future.stdout)
[11:01:54.636]         }, add = TRUE)
[11:01:54.636]     }
[11:01:54.636]     ...future.frame <- base::sys.nframe()
[11:01:54.636]     ...future.conditions <- base::list()
[11:01:54.636]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.636]     if (FALSE) {
[11:01:54.636]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.636]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.636]     }
[11:01:54.636]     ...future.result <- base::tryCatch({
[11:01:54.636]         base::withCallingHandlers({
[11:01:54.636]             ...future.value <- base::withVisible(base::local({
[11:01:54.636]                 ...future.makeSendCondition <- base::local({
[11:01:54.636]                   sendCondition <- NULL
[11:01:54.636]                   function(frame = 1L) {
[11:01:54.636]                     if (is.function(sendCondition)) 
[11:01:54.636]                       return(sendCondition)
[11:01:54.636]                     ns <- getNamespace("parallel")
[11:01:54.636]                     if (exists("sendData", mode = "function", 
[11:01:54.636]                       envir = ns)) {
[11:01:54.636]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.636]                         envir = ns)
[11:01:54.636]                       envir <- sys.frame(frame)
[11:01:54.636]                       master <- NULL
[11:01:54.636]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.636]                         !identical(envir, emptyenv())) {
[11:01:54.636]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.636]                           inherits = FALSE)) {
[11:01:54.636]                           master <- get("master", mode = "list", 
[11:01:54.636]                             envir = envir, inherits = FALSE)
[11:01:54.636]                           if (inherits(master, c("SOCKnode", 
[11:01:54.636]                             "SOCK0node"))) {
[11:01:54.636]                             sendCondition <<- function(cond) {
[11:01:54.636]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.636]                                 success = TRUE)
[11:01:54.636]                               parallel_sendData(master, data)
[11:01:54.636]                             }
[11:01:54.636]                             return(sendCondition)
[11:01:54.636]                           }
[11:01:54.636]                         }
[11:01:54.636]                         frame <- frame + 1L
[11:01:54.636]                         envir <- sys.frame(frame)
[11:01:54.636]                       }
[11:01:54.636]                     }
[11:01:54.636]                     sendCondition <<- function(cond) NULL
[11:01:54.636]                   }
[11:01:54.636]                 })
[11:01:54.636]                 withCallingHandlers({
[11:01:54.636]                   value(a) + 1
[11:01:54.636]                 }, immediateCondition = function(cond) {
[11:01:54.636]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.636]                   sendCondition(cond)
[11:01:54.636]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.636]                   {
[11:01:54.636]                     inherits <- base::inherits
[11:01:54.636]                     invokeRestart <- base::invokeRestart
[11:01:54.636]                     is.null <- base::is.null
[11:01:54.636]                     muffled <- FALSE
[11:01:54.636]                     if (inherits(cond, "message")) {
[11:01:54.636]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.636]                       if (muffled) 
[11:01:54.636]                         invokeRestart("muffleMessage")
[11:01:54.636]                     }
[11:01:54.636]                     else if (inherits(cond, "warning")) {
[11:01:54.636]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.636]                       if (muffled) 
[11:01:54.636]                         invokeRestart("muffleWarning")
[11:01:54.636]                     }
[11:01:54.636]                     else if (inherits(cond, "condition")) {
[11:01:54.636]                       if (!is.null(pattern)) {
[11:01:54.636]                         computeRestarts <- base::computeRestarts
[11:01:54.636]                         grepl <- base::grepl
[11:01:54.636]                         restarts <- computeRestarts(cond)
[11:01:54.636]                         for (restart in restarts) {
[11:01:54.636]                           name <- restart$name
[11:01:54.636]                           if (is.null(name)) 
[11:01:54.636]                             next
[11:01:54.636]                           if (!grepl(pattern, name)) 
[11:01:54.636]                             next
[11:01:54.636]                           invokeRestart(restart)
[11:01:54.636]                           muffled <- TRUE
[11:01:54.636]                           break
[11:01:54.636]                         }
[11:01:54.636]                       }
[11:01:54.636]                     }
[11:01:54.636]                     invisible(muffled)
[11:01:54.636]                   }
[11:01:54.636]                   muffleCondition(cond)
[11:01:54.636]                 })
[11:01:54.636]             }))
[11:01:54.636]             future::FutureResult(value = ...future.value$value, 
[11:01:54.636]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.636]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.636]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.636]                     ...future.globalenv.names))
[11:01:54.636]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.636]         }, condition = base::local({
[11:01:54.636]             c <- base::c
[11:01:54.636]             inherits <- base::inherits
[11:01:54.636]             invokeRestart <- base::invokeRestart
[11:01:54.636]             length <- base::length
[11:01:54.636]             list <- base::list
[11:01:54.636]             seq.int <- base::seq.int
[11:01:54.636]             signalCondition <- base::signalCondition
[11:01:54.636]             sys.calls <- base::sys.calls
[11:01:54.636]             `[[` <- base::`[[`
[11:01:54.636]             `+` <- base::`+`
[11:01:54.636]             `<<-` <- base::`<<-`
[11:01:54.636]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.636]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.636]                   3L)]
[11:01:54.636]             }
[11:01:54.636]             function(cond) {
[11:01:54.636]                 is_error <- inherits(cond, "error")
[11:01:54.636]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.636]                   NULL)
[11:01:54.636]                 if (is_error) {
[11:01:54.636]                   sessionInformation <- function() {
[11:01:54.636]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.636]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.636]                       search = base::search(), system = base::Sys.info())
[11:01:54.636]                   }
[11:01:54.636]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.636]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.636]                     cond$call), session = sessionInformation(), 
[11:01:54.636]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.636]                   signalCondition(cond)
[11:01:54.636]                 }
[11:01:54.636]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.636]                 "immediateCondition"))) {
[11:01:54.636]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.636]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.636]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.636]                   if (TRUE && !signal) {
[11:01:54.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.636]                     {
[11:01:54.636]                       inherits <- base::inherits
[11:01:54.636]                       invokeRestart <- base::invokeRestart
[11:01:54.636]                       is.null <- base::is.null
[11:01:54.636]                       muffled <- FALSE
[11:01:54.636]                       if (inherits(cond, "message")) {
[11:01:54.636]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.636]                         if (muffled) 
[11:01:54.636]                           invokeRestart("muffleMessage")
[11:01:54.636]                       }
[11:01:54.636]                       else if (inherits(cond, "warning")) {
[11:01:54.636]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.636]                         if (muffled) 
[11:01:54.636]                           invokeRestart("muffleWarning")
[11:01:54.636]                       }
[11:01:54.636]                       else if (inherits(cond, "condition")) {
[11:01:54.636]                         if (!is.null(pattern)) {
[11:01:54.636]                           computeRestarts <- base::computeRestarts
[11:01:54.636]                           grepl <- base::grepl
[11:01:54.636]                           restarts <- computeRestarts(cond)
[11:01:54.636]                           for (restart in restarts) {
[11:01:54.636]                             name <- restart$name
[11:01:54.636]                             if (is.null(name)) 
[11:01:54.636]                               next
[11:01:54.636]                             if (!grepl(pattern, name)) 
[11:01:54.636]                               next
[11:01:54.636]                             invokeRestart(restart)
[11:01:54.636]                             muffled <- TRUE
[11:01:54.636]                             break
[11:01:54.636]                           }
[11:01:54.636]                         }
[11:01:54.636]                       }
[11:01:54.636]                       invisible(muffled)
[11:01:54.636]                     }
[11:01:54.636]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.636]                   }
[11:01:54.636]                 }
[11:01:54.636]                 else {
[11:01:54.636]                   if (TRUE) {
[11:01:54.636]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.636]                     {
[11:01:54.636]                       inherits <- base::inherits
[11:01:54.636]                       invokeRestart <- base::invokeRestart
[11:01:54.636]                       is.null <- base::is.null
[11:01:54.636]                       muffled <- FALSE
[11:01:54.636]                       if (inherits(cond, "message")) {
[11:01:54.636]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.636]                         if (muffled) 
[11:01:54.636]                           invokeRestart("muffleMessage")
[11:01:54.636]                       }
[11:01:54.636]                       else if (inherits(cond, "warning")) {
[11:01:54.636]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.636]                         if (muffled) 
[11:01:54.636]                           invokeRestart("muffleWarning")
[11:01:54.636]                       }
[11:01:54.636]                       else if (inherits(cond, "condition")) {
[11:01:54.636]                         if (!is.null(pattern)) {
[11:01:54.636]                           computeRestarts <- base::computeRestarts
[11:01:54.636]                           grepl <- base::grepl
[11:01:54.636]                           restarts <- computeRestarts(cond)
[11:01:54.636]                           for (restart in restarts) {
[11:01:54.636]                             name <- restart$name
[11:01:54.636]                             if (is.null(name)) 
[11:01:54.636]                               next
[11:01:54.636]                             if (!grepl(pattern, name)) 
[11:01:54.636]                               next
[11:01:54.636]                             invokeRestart(restart)
[11:01:54.636]                             muffled <- TRUE
[11:01:54.636]                             break
[11:01:54.636]                           }
[11:01:54.636]                         }
[11:01:54.636]                       }
[11:01:54.636]                       invisible(muffled)
[11:01:54.636]                     }
[11:01:54.636]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.636]                   }
[11:01:54.636]                 }
[11:01:54.636]             }
[11:01:54.636]         }))
[11:01:54.636]     }, error = function(ex) {
[11:01:54.636]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.636]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.636]                 ...future.rng), started = ...future.startTime, 
[11:01:54.636]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.636]             version = "1.8"), class = "FutureResult")
[11:01:54.636]     }, finally = {
[11:01:54.636]         if (!identical(...future.workdir, getwd())) 
[11:01:54.636]             setwd(...future.workdir)
[11:01:54.636]         {
[11:01:54.636]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.636]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.636]             }
[11:01:54.636]             base::options(...future.oldOptions)
[11:01:54.636]             if (.Platform$OS.type == "windows") {
[11:01:54.636]                 old_names <- names(...future.oldEnvVars)
[11:01:54.636]                 envs <- base::Sys.getenv()
[11:01:54.636]                 names <- names(envs)
[11:01:54.636]                 common <- intersect(names, old_names)
[11:01:54.636]                 added <- setdiff(names, old_names)
[11:01:54.636]                 removed <- setdiff(old_names, names)
[11:01:54.636]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.636]                   envs[common]]
[11:01:54.636]                 NAMES <- toupper(changed)
[11:01:54.636]                 args <- list()
[11:01:54.636]                 for (kk in seq_along(NAMES)) {
[11:01:54.636]                   name <- changed[[kk]]
[11:01:54.636]                   NAME <- NAMES[[kk]]
[11:01:54.636]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.636]                     next
[11:01:54.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.636]                 }
[11:01:54.636]                 NAMES <- toupper(added)
[11:01:54.636]                 for (kk in seq_along(NAMES)) {
[11:01:54.636]                   name <- added[[kk]]
[11:01:54.636]                   NAME <- NAMES[[kk]]
[11:01:54.636]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.636]                     next
[11:01:54.636]                   args[[name]] <- ""
[11:01:54.636]                 }
[11:01:54.636]                 NAMES <- toupper(removed)
[11:01:54.636]                 for (kk in seq_along(NAMES)) {
[11:01:54.636]                   name <- removed[[kk]]
[11:01:54.636]                   NAME <- NAMES[[kk]]
[11:01:54.636]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.636]                     next
[11:01:54.636]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.636]                 }
[11:01:54.636]                 if (length(args) > 0) 
[11:01:54.636]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.636]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.636]             }
[11:01:54.636]             else {
[11:01:54.636]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.636]             }
[11:01:54.636]             {
[11:01:54.636]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.636]                   0L) {
[11:01:54.636]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.636]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.636]                   base::options(opts)
[11:01:54.636]                 }
[11:01:54.636]                 {
[11:01:54.636]                   {
[11:01:54.636]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.636]                     NULL
[11:01:54.636]                   }
[11:01:54.636]                   options(future.plan = NULL)
[11:01:54.636]                   if (is.na(NA_character_)) 
[11:01:54.636]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.636]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.636]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.636]                     .init = FALSE)
[11:01:54.636]                 }
[11:01:54.636]             }
[11:01:54.636]         }
[11:01:54.636]     })
[11:01:54.636]     if (TRUE) {
[11:01:54.636]         base::sink(type = "output", split = FALSE)
[11:01:54.636]         if (TRUE) {
[11:01:54.636]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.636]         }
[11:01:54.636]         else {
[11:01:54.636]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.636]         }
[11:01:54.636]         base::close(...future.stdout)
[11:01:54.636]         ...future.stdout <- NULL
[11:01:54.636]     }
[11:01:54.636]     ...future.result$conditions <- ...future.conditions
[11:01:54.636]     ...future.result$finished <- base::Sys.time()
[11:01:54.636]     ...future.result
[11:01:54.636] }
[11:01:54.649] Exporting 1 global objects (313.44 KiB) to cluster node #2 ...
[11:01:54.660] Exporting ‘a’ (313.23 KiB) to cluster node #2 ...
[11:01:54.713] Exporting ‘a’ (313.23 KiB) to cluster node #2 ... DONE
[11:01:54.713] Exporting 1 global objects (313.44 KiB) to cluster node #2 ... DONE
[11:01:54.713] MultisessionFuture started
[11:01:54.714] - Launch lazy future ... done
[11:01:54.714] run() for ‘MultisessionFuture’ ... done
[11:01:54.714] result() for ClusterFuture ...
[11:01:54.714] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.714] - Validating connection of MultisessionFuture
[11:01:54.758] - received message: FutureResult
[11:01:54.759] - Received FutureResult
[11:01:54.759] - Erased future from FutureRegistry
[11:01:54.759] result() for ClusterFuture ...
[11:01:54.759] - result already collected: FutureResult
[11:01:54.759] result() for ClusterFuture ... done
[11:01:54.759] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.759] result() for ClusterFuture ... done
[11:01:54.759] result() for ClusterFuture ...
[11:01:54.759] - result already collected: FutureResult
[11:01:54.760] result() for ClusterFuture ... done
value(b) = 2
[11:01:54.760] result() for ClusterFuture ...
[11:01:54.760] - result already collected: FutureResult
[11:01:54.760] result() for ClusterFuture ... done
[11:01:54.760] result() for ClusterFuture ...
[11:01:54.760] - result already collected: FutureResult
[11:01:54.760] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.760] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.761] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.761] 
[11:01:54.761] Searching for globals ... DONE
[11:01:54.761] - globals: [0] <none>
[11:01:54.761] getGlobalsAndPackages() ... DONE
[11:01:54.762] run() for ‘Future’ ...
[11:01:54.762] - state: ‘created’
[11:01:54.762] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.775] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.776] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.776]   - Field: ‘node’
[11:01:54.776]   - Field: ‘label’
[11:01:54.776]   - Field: ‘local’
[11:01:54.776]   - Field: ‘owner’
[11:01:54.776]   - Field: ‘envir’
[11:01:54.776]   - Field: ‘workers’
[11:01:54.776]   - Field: ‘packages’
[11:01:54.776]   - Field: ‘gc’
[11:01:54.776]   - Field: ‘conditions’
[11:01:54.776]   - Field: ‘persistent’
[11:01:54.777]   - Field: ‘expr’
[11:01:54.777]   - Field: ‘uuid’
[11:01:54.777]   - Field: ‘seed’
[11:01:54.777]   - Field: ‘version’
[11:01:54.777]   - Field: ‘result’
[11:01:54.777]   - Field: ‘asynchronous’
[11:01:54.777]   - Field: ‘calls’
[11:01:54.777]   - Field: ‘globals’
[11:01:54.777]   - Field: ‘stdout’
[11:01:54.777]   - Field: ‘earlySignal’
[11:01:54.777]   - Field: ‘lazy’
[11:01:54.777]   - Field: ‘state’
[11:01:54.778] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.778] - Launch lazy future ...
[11:01:54.778] Packages needed by the future expression (n = 0): <none>
[11:01:54.778] Packages needed by future strategies (n = 0): <none>
[11:01:54.778] {
[11:01:54.778]     {
[11:01:54.778]         {
[11:01:54.778]             ...future.startTime <- base::Sys.time()
[11:01:54.778]             {
[11:01:54.778]                 {
[11:01:54.778]                   {
[11:01:54.778]                     {
[11:01:54.778]                       base::local({
[11:01:54.778]                         has_future <- base::requireNamespace("future", 
[11:01:54.778]                           quietly = TRUE)
[11:01:54.778]                         if (has_future) {
[11:01:54.778]                           ns <- base::getNamespace("future")
[11:01:54.778]                           version <- ns[[".package"]][["version"]]
[11:01:54.778]                           if (is.null(version)) 
[11:01:54.778]                             version <- utils::packageVersion("future")
[11:01:54.778]                         }
[11:01:54.778]                         else {
[11:01:54.778]                           version <- NULL
[11:01:54.778]                         }
[11:01:54.778]                         if (!has_future || version < "1.8.0") {
[11:01:54.778]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.778]                             "", base::R.version$version.string), 
[11:01:54.778]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:54.778]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:54.778]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.778]                               "release", "version")], collapse = " "), 
[11:01:54.778]                             hostname = base::Sys.info()[["nodename"]])
[11:01:54.778]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.778]                             info)
[11:01:54.778]                           info <- base::paste(info, collapse = "; ")
[11:01:54.778]                           if (!has_future) {
[11:01:54.778]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.778]                               info)
[11:01:54.778]                           }
[11:01:54.778]                           else {
[11:01:54.778]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.778]                               info, version)
[11:01:54.778]                           }
[11:01:54.778]                           base::stop(msg)
[11:01:54.778]                         }
[11:01:54.778]                       })
[11:01:54.778]                     }
[11:01:54.778]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.778]                     base::options(mc.cores = 1L)
[11:01:54.778]                   }
[11:01:54.778]                   ...future.strategy.old <- future::plan("list")
[11:01:54.778]                   options(future.plan = NULL)
[11:01:54.778]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.778]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.778]                 }
[11:01:54.778]                 ...future.workdir <- getwd()
[11:01:54.778]             }
[11:01:54.778]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.778]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.778]         }
[11:01:54.778]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.778]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.778]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.778]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.778]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.778]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.778]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.778]             base::names(...future.oldOptions))
[11:01:54.778]     }
[11:01:54.778]     if (FALSE) {
[11:01:54.778]     }
[11:01:54.778]     else {
[11:01:54.778]         if (TRUE) {
[11:01:54.778]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.778]                 open = "w")
[11:01:54.778]         }
[11:01:54.778]         else {
[11:01:54.778]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.778]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.778]         }
[11:01:54.778]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.778]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.778]             base::sink(type = "output", split = FALSE)
[11:01:54.778]             base::close(...future.stdout)
[11:01:54.778]         }, add = TRUE)
[11:01:54.778]     }
[11:01:54.778]     ...future.frame <- base::sys.nframe()
[11:01:54.778]     ...future.conditions <- base::list()
[11:01:54.778]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.778]     if (FALSE) {
[11:01:54.778]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.778]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.778]     }
[11:01:54.778]     ...future.result <- base::tryCatch({
[11:01:54.778]         base::withCallingHandlers({
[11:01:54.778]             ...future.value <- base::withVisible(base::local({
[11:01:54.778]                 ...future.makeSendCondition <- base::local({
[11:01:54.778]                   sendCondition <- NULL
[11:01:54.778]                   function(frame = 1L) {
[11:01:54.778]                     if (is.function(sendCondition)) 
[11:01:54.778]                       return(sendCondition)
[11:01:54.778]                     ns <- getNamespace("parallel")
[11:01:54.778]                     if (exists("sendData", mode = "function", 
[11:01:54.778]                       envir = ns)) {
[11:01:54.778]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.778]                         envir = ns)
[11:01:54.778]                       envir <- sys.frame(frame)
[11:01:54.778]                       master <- NULL
[11:01:54.778]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.778]                         !identical(envir, emptyenv())) {
[11:01:54.778]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.778]                           inherits = FALSE)) {
[11:01:54.778]                           master <- get("master", mode = "list", 
[11:01:54.778]                             envir = envir, inherits = FALSE)
[11:01:54.778]                           if (inherits(master, c("SOCKnode", 
[11:01:54.778]                             "SOCK0node"))) {
[11:01:54.778]                             sendCondition <<- function(cond) {
[11:01:54.778]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.778]                                 success = TRUE)
[11:01:54.778]                               parallel_sendData(master, data)
[11:01:54.778]                             }
[11:01:54.778]                             return(sendCondition)
[11:01:54.778]                           }
[11:01:54.778]                         }
[11:01:54.778]                         frame <- frame + 1L
[11:01:54.778]                         envir <- sys.frame(frame)
[11:01:54.778]                       }
[11:01:54.778]                     }
[11:01:54.778]                     sendCondition <<- function(cond) NULL
[11:01:54.778]                   }
[11:01:54.778]                 })
[11:01:54.778]                 withCallingHandlers({
[11:01:54.778]                   1
[11:01:54.778]                 }, immediateCondition = function(cond) {
[11:01:54.778]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.778]                   sendCondition(cond)
[11:01:54.778]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.778]                   {
[11:01:54.778]                     inherits <- base::inherits
[11:01:54.778]                     invokeRestart <- base::invokeRestart
[11:01:54.778]                     is.null <- base::is.null
[11:01:54.778]                     muffled <- FALSE
[11:01:54.778]                     if (inherits(cond, "message")) {
[11:01:54.778]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.778]                       if (muffled) 
[11:01:54.778]                         invokeRestart("muffleMessage")
[11:01:54.778]                     }
[11:01:54.778]                     else if (inherits(cond, "warning")) {
[11:01:54.778]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.778]                       if (muffled) 
[11:01:54.778]                         invokeRestart("muffleWarning")
[11:01:54.778]                     }
[11:01:54.778]                     else if (inherits(cond, "condition")) {
[11:01:54.778]                       if (!is.null(pattern)) {
[11:01:54.778]                         computeRestarts <- base::computeRestarts
[11:01:54.778]                         grepl <- base::grepl
[11:01:54.778]                         restarts <- computeRestarts(cond)
[11:01:54.778]                         for (restart in restarts) {
[11:01:54.778]                           name <- restart$name
[11:01:54.778]                           if (is.null(name)) 
[11:01:54.778]                             next
[11:01:54.778]                           if (!grepl(pattern, name)) 
[11:01:54.778]                             next
[11:01:54.778]                           invokeRestart(restart)
[11:01:54.778]                           muffled <- TRUE
[11:01:54.778]                           break
[11:01:54.778]                         }
[11:01:54.778]                       }
[11:01:54.778]                     }
[11:01:54.778]                     invisible(muffled)
[11:01:54.778]                   }
[11:01:54.778]                   muffleCondition(cond)
[11:01:54.778]                 })
[11:01:54.778]             }))
[11:01:54.778]             future::FutureResult(value = ...future.value$value, 
[11:01:54.778]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.778]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.778]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.778]                     ...future.globalenv.names))
[11:01:54.778]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.778]         }, condition = base::local({
[11:01:54.778]             c <- base::c
[11:01:54.778]             inherits <- base::inherits
[11:01:54.778]             invokeRestart <- base::invokeRestart
[11:01:54.778]             length <- base::length
[11:01:54.778]             list <- base::list
[11:01:54.778]             seq.int <- base::seq.int
[11:01:54.778]             signalCondition <- base::signalCondition
[11:01:54.778]             sys.calls <- base::sys.calls
[11:01:54.778]             `[[` <- base::`[[`
[11:01:54.778]             `+` <- base::`+`
[11:01:54.778]             `<<-` <- base::`<<-`
[11:01:54.778]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.778]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.778]                   3L)]
[11:01:54.778]             }
[11:01:54.778]             function(cond) {
[11:01:54.778]                 is_error <- inherits(cond, "error")
[11:01:54.778]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.778]                   NULL)
[11:01:54.778]                 if (is_error) {
[11:01:54.778]                   sessionInformation <- function() {
[11:01:54.778]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.778]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.778]                       search = base::search(), system = base::Sys.info())
[11:01:54.778]                   }
[11:01:54.778]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.778]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.778]                     cond$call), session = sessionInformation(), 
[11:01:54.778]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.778]                   signalCondition(cond)
[11:01:54.778]                 }
[11:01:54.778]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.778]                 "immediateCondition"))) {
[11:01:54.778]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.778]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.778]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.778]                   if (TRUE && !signal) {
[11:01:54.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.778]                     {
[11:01:54.778]                       inherits <- base::inherits
[11:01:54.778]                       invokeRestart <- base::invokeRestart
[11:01:54.778]                       is.null <- base::is.null
[11:01:54.778]                       muffled <- FALSE
[11:01:54.778]                       if (inherits(cond, "message")) {
[11:01:54.778]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.778]                         if (muffled) 
[11:01:54.778]                           invokeRestart("muffleMessage")
[11:01:54.778]                       }
[11:01:54.778]                       else if (inherits(cond, "warning")) {
[11:01:54.778]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.778]                         if (muffled) 
[11:01:54.778]                           invokeRestart("muffleWarning")
[11:01:54.778]                       }
[11:01:54.778]                       else if (inherits(cond, "condition")) {
[11:01:54.778]                         if (!is.null(pattern)) {
[11:01:54.778]                           computeRestarts <- base::computeRestarts
[11:01:54.778]                           grepl <- base::grepl
[11:01:54.778]                           restarts <- computeRestarts(cond)
[11:01:54.778]                           for (restart in restarts) {
[11:01:54.778]                             name <- restart$name
[11:01:54.778]                             if (is.null(name)) 
[11:01:54.778]                               next
[11:01:54.778]                             if (!grepl(pattern, name)) 
[11:01:54.778]                               next
[11:01:54.778]                             invokeRestart(restart)
[11:01:54.778]                             muffled <- TRUE
[11:01:54.778]                             break
[11:01:54.778]                           }
[11:01:54.778]                         }
[11:01:54.778]                       }
[11:01:54.778]                       invisible(muffled)
[11:01:54.778]                     }
[11:01:54.778]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.778]                   }
[11:01:54.778]                 }
[11:01:54.778]                 else {
[11:01:54.778]                   if (TRUE) {
[11:01:54.778]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.778]                     {
[11:01:54.778]                       inherits <- base::inherits
[11:01:54.778]                       invokeRestart <- base::invokeRestart
[11:01:54.778]                       is.null <- base::is.null
[11:01:54.778]                       muffled <- FALSE
[11:01:54.778]                       if (inherits(cond, "message")) {
[11:01:54.778]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.778]                         if (muffled) 
[11:01:54.778]                           invokeRestart("muffleMessage")
[11:01:54.778]                       }
[11:01:54.778]                       else if (inherits(cond, "warning")) {
[11:01:54.778]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.778]                         if (muffled) 
[11:01:54.778]                           invokeRestart("muffleWarning")
[11:01:54.778]                       }
[11:01:54.778]                       else if (inherits(cond, "condition")) {
[11:01:54.778]                         if (!is.null(pattern)) {
[11:01:54.778]                           computeRestarts <- base::computeRestarts
[11:01:54.778]                           grepl <- base::grepl
[11:01:54.778]                           restarts <- computeRestarts(cond)
[11:01:54.778]                           for (restart in restarts) {
[11:01:54.778]                             name <- restart$name
[11:01:54.778]                             if (is.null(name)) 
[11:01:54.778]                               next
[11:01:54.778]                             if (!grepl(pattern, name)) 
[11:01:54.778]                               next
[11:01:54.778]                             invokeRestart(restart)
[11:01:54.778]                             muffled <- TRUE
[11:01:54.778]                             break
[11:01:54.778]                           }
[11:01:54.778]                         }
[11:01:54.778]                       }
[11:01:54.778]                       invisible(muffled)
[11:01:54.778]                     }
[11:01:54.778]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.778]                   }
[11:01:54.778]                 }
[11:01:54.778]             }
[11:01:54.778]         }))
[11:01:54.778]     }, error = function(ex) {
[11:01:54.778]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.778]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.778]                 ...future.rng), started = ...future.startTime, 
[11:01:54.778]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.778]             version = "1.8"), class = "FutureResult")
[11:01:54.778]     }, finally = {
[11:01:54.778]         if (!identical(...future.workdir, getwd())) 
[11:01:54.778]             setwd(...future.workdir)
[11:01:54.778]         {
[11:01:54.778]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.778]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.778]             }
[11:01:54.778]             base::options(...future.oldOptions)
[11:01:54.778]             if (.Platform$OS.type == "windows") {
[11:01:54.778]                 old_names <- names(...future.oldEnvVars)
[11:01:54.778]                 envs <- base::Sys.getenv()
[11:01:54.778]                 names <- names(envs)
[11:01:54.778]                 common <- intersect(names, old_names)
[11:01:54.778]                 added <- setdiff(names, old_names)
[11:01:54.778]                 removed <- setdiff(old_names, names)
[11:01:54.778]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.778]                   envs[common]]
[11:01:54.778]                 NAMES <- toupper(changed)
[11:01:54.778]                 args <- list()
[11:01:54.778]                 for (kk in seq_along(NAMES)) {
[11:01:54.778]                   name <- changed[[kk]]
[11:01:54.778]                   NAME <- NAMES[[kk]]
[11:01:54.778]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.778]                     next
[11:01:54.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.778]                 }
[11:01:54.778]                 NAMES <- toupper(added)
[11:01:54.778]                 for (kk in seq_along(NAMES)) {
[11:01:54.778]                   name <- added[[kk]]
[11:01:54.778]                   NAME <- NAMES[[kk]]
[11:01:54.778]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.778]                     next
[11:01:54.778]                   args[[name]] <- ""
[11:01:54.778]                 }
[11:01:54.778]                 NAMES <- toupper(removed)
[11:01:54.778]                 for (kk in seq_along(NAMES)) {
[11:01:54.778]                   name <- removed[[kk]]
[11:01:54.778]                   NAME <- NAMES[[kk]]
[11:01:54.778]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.778]                     next
[11:01:54.778]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.778]                 }
[11:01:54.778]                 if (length(args) > 0) 
[11:01:54.778]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.778]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.778]             }
[11:01:54.778]             else {
[11:01:54.778]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.778]             }
[11:01:54.778]             {
[11:01:54.778]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.778]                   0L) {
[11:01:54.778]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.778]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.778]                   base::options(opts)
[11:01:54.778]                 }
[11:01:54.778]                 {
[11:01:54.778]                   {
[11:01:54.778]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.778]                     NULL
[11:01:54.778]                   }
[11:01:54.778]                   options(future.plan = NULL)
[11:01:54.778]                   if (is.na(NA_character_)) 
[11:01:54.778]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.778]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.778]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.778]                     .init = FALSE)
[11:01:54.778]                 }
[11:01:54.778]             }
[11:01:54.778]         }
[11:01:54.778]     })
[11:01:54.778]     if (TRUE) {
[11:01:54.778]         base::sink(type = "output", split = FALSE)
[11:01:54.778]         if (TRUE) {
[11:01:54.778]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.778]         }
[11:01:54.778]         else {
[11:01:54.778]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.778]         }
[11:01:54.778]         base::close(...future.stdout)
[11:01:54.778]         ...future.stdout <- NULL
[11:01:54.778]     }
[11:01:54.778]     ...future.result$conditions <- ...future.conditions
[11:01:54.778]     ...future.result$finished <- base::Sys.time()
[11:01:54.778]     ...future.result
[11:01:54.778] }
[11:01:54.781] MultisessionFuture started
[11:01:54.781] - Launch lazy future ... done
[11:01:54.781] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.782] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.782] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.783] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:54.783] Searching for globals ... DONE
[11:01:54.783] Resolving globals: TRUE
[11:01:54.783] Resolving any globals that are futures ...
[11:01:54.783] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:54.783] Resolving any globals that are futures ... DONE
[11:01:54.783] Resolving futures part of globals (recursively) ...
[11:01:54.784] resolve() on list ...
[11:01:54.784]  recursive: 99
[11:01:54.784]  length: 1
[11:01:54.784]  elements: ‘a’
[11:01:54.826] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.826] - Validating connection of MultisessionFuture
[11:01:54.826] - received message: FutureResult
[11:01:54.826] - Received FutureResult
[11:01:54.826] - Erased future from FutureRegistry
[11:01:54.826] result() for ClusterFuture ...
[11:01:54.826] - result already collected: FutureResult
[11:01:54.827] result() for ClusterFuture ... done
[11:01:54.827] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.827] Future #1
[11:01:54.827] result() for ClusterFuture ...
[11:01:54.827] - result already collected: FutureResult
[11:01:54.827] result() for ClusterFuture ... done
[11:01:54.827] result() for ClusterFuture ...
[11:01:54.827] - result already collected: FutureResult
[11:01:54.827] result() for ClusterFuture ... done
[11:01:54.827] A MultisessionFuture was resolved
[11:01:54.827]  length: 0 (resolved future 1)
[11:01:54.828] resolve() on list ... DONE
[11:01:54.828] - globals: [1] ‘a’
[11:01:54.828] Resolving futures part of globals (recursively) ... DONE
[11:01:54.839] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[11:01:54.839] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[11:01:54.839] - globals: [1] ‘a’
[11:01:54.839] - packages: [1] ‘future’
[11:01:54.839] getGlobalsAndPackages() ... DONE
[11:01:54.840] run() for ‘Future’ ...
[11:01:54.840] - state: ‘created’
[11:01:54.840] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.854] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.854] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.854]   - Field: ‘node’
[11:01:54.854]   - Field: ‘label’
[11:01:54.854]   - Field: ‘local’
[11:01:54.854]   - Field: ‘owner’
[11:01:54.855]   - Field: ‘envir’
[11:01:54.855]   - Field: ‘workers’
[11:01:54.855]   - Field: ‘packages’
[11:01:54.855]   - Field: ‘gc’
[11:01:54.855]   - Field: ‘conditions’
[11:01:54.855]   - Field: ‘persistent’
[11:01:54.855]   - Field: ‘expr’
[11:01:54.855]   - Field: ‘uuid’
[11:01:54.855]   - Field: ‘seed’
[11:01:54.855]   - Field: ‘version’
[11:01:54.855]   - Field: ‘result’
[11:01:54.855]   - Field: ‘asynchronous’
[11:01:54.856]   - Field: ‘calls’
[11:01:54.856]   - Field: ‘globals’
[11:01:54.856]   - Field: ‘stdout’
[11:01:54.858]   - Field: ‘earlySignal’
[11:01:54.858]   - Field: ‘lazy’
[11:01:54.858]   - Field: ‘state’
[11:01:54.858] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.858] - Launch lazy future ...
[11:01:54.858] Packages needed by the future expression (n = 1): ‘future’
[11:01:54.858] Packages needed by future strategies (n = 0): <none>
[11:01:54.859] {
[11:01:54.859]     {
[11:01:54.859]         {
[11:01:54.859]             ...future.startTime <- base::Sys.time()
[11:01:54.859]             {
[11:01:54.859]                 {
[11:01:54.859]                   {
[11:01:54.859]                     {
[11:01:54.859]                       {
[11:01:54.859]                         base::local({
[11:01:54.859]                           has_future <- base::requireNamespace("future", 
[11:01:54.859]                             quietly = TRUE)
[11:01:54.859]                           if (has_future) {
[11:01:54.859]                             ns <- base::getNamespace("future")
[11:01:54.859]                             version <- ns[[".package"]][["version"]]
[11:01:54.859]                             if (is.null(version)) 
[11:01:54.859]                               version <- utils::packageVersion("future")
[11:01:54.859]                           }
[11:01:54.859]                           else {
[11:01:54.859]                             version <- NULL
[11:01:54.859]                           }
[11:01:54.859]                           if (!has_future || version < "1.8.0") {
[11:01:54.859]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:54.859]                               "", base::R.version$version.string), 
[11:01:54.859]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:54.859]                                 base::R.version$platform, 8 * 
[11:01:54.859]                                   base::.Machine$sizeof.pointer), 
[11:01:54.859]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:54.859]                                 "release", "version")], collapse = " "), 
[11:01:54.859]                               hostname = base::Sys.info()[["nodename"]])
[11:01:54.859]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:54.859]                               info)
[11:01:54.859]                             info <- base::paste(info, collapse = "; ")
[11:01:54.859]                             if (!has_future) {
[11:01:54.859]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:54.859]                                 info)
[11:01:54.859]                             }
[11:01:54.859]                             else {
[11:01:54.859]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:54.859]                                 info, version)
[11:01:54.859]                             }
[11:01:54.859]                             base::stop(msg)
[11:01:54.859]                           }
[11:01:54.859]                         })
[11:01:54.859]                       }
[11:01:54.859]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:54.859]                       base::options(mc.cores = 1L)
[11:01:54.859]                     }
[11:01:54.859]                     base::local({
[11:01:54.859]                       for (pkg in "future") {
[11:01:54.859]                         base::loadNamespace(pkg)
[11:01:54.859]                         base::library(pkg, character.only = TRUE)
[11:01:54.859]                       }
[11:01:54.859]                     })
[11:01:54.859]                   }
[11:01:54.859]                   ...future.strategy.old <- future::plan("list")
[11:01:54.859]                   options(future.plan = NULL)
[11:01:54.859]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.859]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:54.859]                 }
[11:01:54.859]                 ...future.workdir <- getwd()
[11:01:54.859]             }
[11:01:54.859]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:54.859]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:54.859]         }
[11:01:54.859]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:54.859]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:54.859]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:54.859]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:54.859]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:54.859]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:54.859]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:54.859]             base::names(...future.oldOptions))
[11:01:54.859]     }
[11:01:54.859]     if (FALSE) {
[11:01:54.859]     }
[11:01:54.859]     else {
[11:01:54.859]         if (TRUE) {
[11:01:54.859]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:54.859]                 open = "w")
[11:01:54.859]         }
[11:01:54.859]         else {
[11:01:54.859]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:54.859]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:54.859]         }
[11:01:54.859]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:54.859]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:54.859]             base::sink(type = "output", split = FALSE)
[11:01:54.859]             base::close(...future.stdout)
[11:01:54.859]         }, add = TRUE)
[11:01:54.859]     }
[11:01:54.859]     ...future.frame <- base::sys.nframe()
[11:01:54.859]     ...future.conditions <- base::list()
[11:01:54.859]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:54.859]     if (FALSE) {
[11:01:54.859]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:54.859]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:54.859]     }
[11:01:54.859]     ...future.result <- base::tryCatch({
[11:01:54.859]         base::withCallingHandlers({
[11:01:54.859]             ...future.value <- base::withVisible(base::local({
[11:01:54.859]                 ...future.makeSendCondition <- base::local({
[11:01:54.859]                   sendCondition <- NULL
[11:01:54.859]                   function(frame = 1L) {
[11:01:54.859]                     if (is.function(sendCondition)) 
[11:01:54.859]                       return(sendCondition)
[11:01:54.859]                     ns <- getNamespace("parallel")
[11:01:54.859]                     if (exists("sendData", mode = "function", 
[11:01:54.859]                       envir = ns)) {
[11:01:54.859]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:54.859]                         envir = ns)
[11:01:54.859]                       envir <- sys.frame(frame)
[11:01:54.859]                       master <- NULL
[11:01:54.859]                       while (!identical(envir, .GlobalEnv) && 
[11:01:54.859]                         !identical(envir, emptyenv())) {
[11:01:54.859]                         if (exists("master", mode = "list", envir = envir, 
[11:01:54.859]                           inherits = FALSE)) {
[11:01:54.859]                           master <- get("master", mode = "list", 
[11:01:54.859]                             envir = envir, inherits = FALSE)
[11:01:54.859]                           if (inherits(master, c("SOCKnode", 
[11:01:54.859]                             "SOCK0node"))) {
[11:01:54.859]                             sendCondition <<- function(cond) {
[11:01:54.859]                               data <- list(type = "VALUE", value = cond, 
[11:01:54.859]                                 success = TRUE)
[11:01:54.859]                               parallel_sendData(master, data)
[11:01:54.859]                             }
[11:01:54.859]                             return(sendCondition)
[11:01:54.859]                           }
[11:01:54.859]                         }
[11:01:54.859]                         frame <- frame + 1L
[11:01:54.859]                         envir <- sys.frame(frame)
[11:01:54.859]                       }
[11:01:54.859]                     }
[11:01:54.859]                     sendCondition <<- function(cond) NULL
[11:01:54.859]                   }
[11:01:54.859]                 })
[11:01:54.859]                 withCallingHandlers({
[11:01:54.859]                   value(a) + 1
[11:01:54.859]                 }, immediateCondition = function(cond) {
[11:01:54.859]                   sendCondition <- ...future.makeSendCondition()
[11:01:54.859]                   sendCondition(cond)
[11:01:54.859]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.859]                   {
[11:01:54.859]                     inherits <- base::inherits
[11:01:54.859]                     invokeRestart <- base::invokeRestart
[11:01:54.859]                     is.null <- base::is.null
[11:01:54.859]                     muffled <- FALSE
[11:01:54.859]                     if (inherits(cond, "message")) {
[11:01:54.859]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:54.859]                       if (muffled) 
[11:01:54.859]                         invokeRestart("muffleMessage")
[11:01:54.859]                     }
[11:01:54.859]                     else if (inherits(cond, "warning")) {
[11:01:54.859]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:54.859]                       if (muffled) 
[11:01:54.859]                         invokeRestart("muffleWarning")
[11:01:54.859]                     }
[11:01:54.859]                     else if (inherits(cond, "condition")) {
[11:01:54.859]                       if (!is.null(pattern)) {
[11:01:54.859]                         computeRestarts <- base::computeRestarts
[11:01:54.859]                         grepl <- base::grepl
[11:01:54.859]                         restarts <- computeRestarts(cond)
[11:01:54.859]                         for (restart in restarts) {
[11:01:54.859]                           name <- restart$name
[11:01:54.859]                           if (is.null(name)) 
[11:01:54.859]                             next
[11:01:54.859]                           if (!grepl(pattern, name)) 
[11:01:54.859]                             next
[11:01:54.859]                           invokeRestart(restart)
[11:01:54.859]                           muffled <- TRUE
[11:01:54.859]                           break
[11:01:54.859]                         }
[11:01:54.859]                       }
[11:01:54.859]                     }
[11:01:54.859]                     invisible(muffled)
[11:01:54.859]                   }
[11:01:54.859]                   muffleCondition(cond)
[11:01:54.859]                 })
[11:01:54.859]             }))
[11:01:54.859]             future::FutureResult(value = ...future.value$value, 
[11:01:54.859]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.859]                   ...future.rng), globalenv = if (FALSE) 
[11:01:54.859]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:54.859]                     ...future.globalenv.names))
[11:01:54.859]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:54.859]         }, condition = base::local({
[11:01:54.859]             c <- base::c
[11:01:54.859]             inherits <- base::inherits
[11:01:54.859]             invokeRestart <- base::invokeRestart
[11:01:54.859]             length <- base::length
[11:01:54.859]             list <- base::list
[11:01:54.859]             seq.int <- base::seq.int
[11:01:54.859]             signalCondition <- base::signalCondition
[11:01:54.859]             sys.calls <- base::sys.calls
[11:01:54.859]             `[[` <- base::`[[`
[11:01:54.859]             `+` <- base::`+`
[11:01:54.859]             `<<-` <- base::`<<-`
[11:01:54.859]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:54.859]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:54.859]                   3L)]
[11:01:54.859]             }
[11:01:54.859]             function(cond) {
[11:01:54.859]                 is_error <- inherits(cond, "error")
[11:01:54.859]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:54.859]                   NULL)
[11:01:54.859]                 if (is_error) {
[11:01:54.859]                   sessionInformation <- function() {
[11:01:54.859]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:54.859]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:54.859]                       search = base::search(), system = base::Sys.info())
[11:01:54.859]                   }
[11:01:54.859]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.859]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:54.859]                     cond$call), session = sessionInformation(), 
[11:01:54.859]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:54.859]                   signalCondition(cond)
[11:01:54.859]                 }
[11:01:54.859]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:54.859]                 "immediateCondition"))) {
[11:01:54.859]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:54.859]                   ...future.conditions[[length(...future.conditions) + 
[11:01:54.859]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:54.859]                   if (TRUE && !signal) {
[11:01:54.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.859]                     {
[11:01:54.859]                       inherits <- base::inherits
[11:01:54.859]                       invokeRestart <- base::invokeRestart
[11:01:54.859]                       is.null <- base::is.null
[11:01:54.859]                       muffled <- FALSE
[11:01:54.859]                       if (inherits(cond, "message")) {
[11:01:54.859]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.859]                         if (muffled) 
[11:01:54.859]                           invokeRestart("muffleMessage")
[11:01:54.859]                       }
[11:01:54.859]                       else if (inherits(cond, "warning")) {
[11:01:54.859]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.859]                         if (muffled) 
[11:01:54.859]                           invokeRestart("muffleWarning")
[11:01:54.859]                       }
[11:01:54.859]                       else if (inherits(cond, "condition")) {
[11:01:54.859]                         if (!is.null(pattern)) {
[11:01:54.859]                           computeRestarts <- base::computeRestarts
[11:01:54.859]                           grepl <- base::grepl
[11:01:54.859]                           restarts <- computeRestarts(cond)
[11:01:54.859]                           for (restart in restarts) {
[11:01:54.859]                             name <- restart$name
[11:01:54.859]                             if (is.null(name)) 
[11:01:54.859]                               next
[11:01:54.859]                             if (!grepl(pattern, name)) 
[11:01:54.859]                               next
[11:01:54.859]                             invokeRestart(restart)
[11:01:54.859]                             muffled <- TRUE
[11:01:54.859]                             break
[11:01:54.859]                           }
[11:01:54.859]                         }
[11:01:54.859]                       }
[11:01:54.859]                       invisible(muffled)
[11:01:54.859]                     }
[11:01:54.859]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.859]                   }
[11:01:54.859]                 }
[11:01:54.859]                 else {
[11:01:54.859]                   if (TRUE) {
[11:01:54.859]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:54.859]                     {
[11:01:54.859]                       inherits <- base::inherits
[11:01:54.859]                       invokeRestart <- base::invokeRestart
[11:01:54.859]                       is.null <- base::is.null
[11:01:54.859]                       muffled <- FALSE
[11:01:54.859]                       if (inherits(cond, "message")) {
[11:01:54.859]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:54.859]                         if (muffled) 
[11:01:54.859]                           invokeRestart("muffleMessage")
[11:01:54.859]                       }
[11:01:54.859]                       else if (inherits(cond, "warning")) {
[11:01:54.859]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:54.859]                         if (muffled) 
[11:01:54.859]                           invokeRestart("muffleWarning")
[11:01:54.859]                       }
[11:01:54.859]                       else if (inherits(cond, "condition")) {
[11:01:54.859]                         if (!is.null(pattern)) {
[11:01:54.859]                           computeRestarts <- base::computeRestarts
[11:01:54.859]                           grepl <- base::grepl
[11:01:54.859]                           restarts <- computeRestarts(cond)
[11:01:54.859]                           for (restart in restarts) {
[11:01:54.859]                             name <- restart$name
[11:01:54.859]                             if (is.null(name)) 
[11:01:54.859]                               next
[11:01:54.859]                             if (!grepl(pattern, name)) 
[11:01:54.859]                               next
[11:01:54.859]                             invokeRestart(restart)
[11:01:54.859]                             muffled <- TRUE
[11:01:54.859]                             break
[11:01:54.859]                           }
[11:01:54.859]                         }
[11:01:54.859]                       }
[11:01:54.859]                       invisible(muffled)
[11:01:54.859]                     }
[11:01:54.859]                     muffleCondition(cond, pattern = "^muffle")
[11:01:54.859]                   }
[11:01:54.859]                 }
[11:01:54.859]             }
[11:01:54.859]         }))
[11:01:54.859]     }, error = function(ex) {
[11:01:54.859]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:54.859]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:54.859]                 ...future.rng), started = ...future.startTime, 
[11:01:54.859]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:54.859]             version = "1.8"), class = "FutureResult")
[11:01:54.859]     }, finally = {
[11:01:54.859]         if (!identical(...future.workdir, getwd())) 
[11:01:54.859]             setwd(...future.workdir)
[11:01:54.859]         {
[11:01:54.859]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:54.859]                 ...future.oldOptions$nwarnings <- NULL
[11:01:54.859]             }
[11:01:54.859]             base::options(...future.oldOptions)
[11:01:54.859]             if (.Platform$OS.type == "windows") {
[11:01:54.859]                 old_names <- names(...future.oldEnvVars)
[11:01:54.859]                 envs <- base::Sys.getenv()
[11:01:54.859]                 names <- names(envs)
[11:01:54.859]                 common <- intersect(names, old_names)
[11:01:54.859]                 added <- setdiff(names, old_names)
[11:01:54.859]                 removed <- setdiff(old_names, names)
[11:01:54.859]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:54.859]                   envs[common]]
[11:01:54.859]                 NAMES <- toupper(changed)
[11:01:54.859]                 args <- list()
[11:01:54.859]                 for (kk in seq_along(NAMES)) {
[11:01:54.859]                   name <- changed[[kk]]
[11:01:54.859]                   NAME <- NAMES[[kk]]
[11:01:54.859]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.859]                     next
[11:01:54.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.859]                 }
[11:01:54.859]                 NAMES <- toupper(added)
[11:01:54.859]                 for (kk in seq_along(NAMES)) {
[11:01:54.859]                   name <- added[[kk]]
[11:01:54.859]                   NAME <- NAMES[[kk]]
[11:01:54.859]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.859]                     next
[11:01:54.859]                   args[[name]] <- ""
[11:01:54.859]                 }
[11:01:54.859]                 NAMES <- toupper(removed)
[11:01:54.859]                 for (kk in seq_along(NAMES)) {
[11:01:54.859]                   name <- removed[[kk]]
[11:01:54.859]                   NAME <- NAMES[[kk]]
[11:01:54.859]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:54.859]                     next
[11:01:54.859]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:54.859]                 }
[11:01:54.859]                 if (length(args) > 0) 
[11:01:54.859]                   base::do.call(base::Sys.setenv, args = args)
[11:01:54.859]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:54.859]             }
[11:01:54.859]             else {
[11:01:54.859]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:54.859]             }
[11:01:54.859]             {
[11:01:54.859]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:54.859]                   0L) {
[11:01:54.859]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:54.859]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:54.859]                   base::options(opts)
[11:01:54.859]                 }
[11:01:54.859]                 {
[11:01:54.859]                   {
[11:01:54.859]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:54.859]                     NULL
[11:01:54.859]                   }
[11:01:54.859]                   options(future.plan = NULL)
[11:01:54.859]                   if (is.na(NA_character_)) 
[11:01:54.859]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:54.859]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:54.859]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:54.859]                     .init = FALSE)
[11:01:54.859]                 }
[11:01:54.859]             }
[11:01:54.859]         }
[11:01:54.859]     })
[11:01:54.859]     if (TRUE) {
[11:01:54.859]         base::sink(type = "output", split = FALSE)
[11:01:54.859]         if (TRUE) {
[11:01:54.859]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:54.859]         }
[11:01:54.859]         else {
[11:01:54.859]             ...future.result["stdout"] <- base::list(NULL)
[11:01:54.859]         }
[11:01:54.859]         base::close(...future.stdout)
[11:01:54.859]         ...future.stdout <- NULL
[11:01:54.859]     }
[11:01:54.859]     ...future.result$conditions <- ...future.conditions
[11:01:54.859]     ...future.result$finished <- base::Sys.time()
[11:01:54.859]     ...future.result
[11:01:54.859] }
[11:01:54.872] Exporting 1 global objects (313.44 KiB) to cluster node #2 ...
[11:01:54.883] Exporting ‘a’ (313.23 KiB) to cluster node #2 ...
[11:01:54.935] Exporting ‘a’ (313.23 KiB) to cluster node #2 ... DONE
[11:01:54.935] Exporting 1 global objects (313.44 KiB) to cluster node #2 ... DONE
[11:01:54.936] MultisessionFuture started
[11:01:54.936] - Launch lazy future ... done
[11:01:54.936] run() for ‘MultisessionFuture’ ... done
[11:01:54.936] result() for ClusterFuture ...
[11:01:54.936] receiveMessageFromWorker() for ClusterFuture ...
[11:01:54.936] - Validating connection of MultisessionFuture
[11:01:54.978] - received message: FutureResult
[11:01:54.978] - Received FutureResult
[11:01:54.978] - Erased future from FutureRegistry
[11:01:54.978] result() for ClusterFuture ...
[11:01:54.978] - result already collected: FutureResult
[11:01:54.979] result() for ClusterFuture ... done
[11:01:54.979] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:54.979] result() for ClusterFuture ... done
[11:01:54.979] result() for ClusterFuture ...
[11:01:54.979] - result already collected: FutureResult
[11:01:54.979] result() for ClusterFuture ... done
value(b) = 2
[11:01:54.979] result() for ClusterFuture ...
[11:01:54.979] - result already collected: FutureResult
[11:01:54.979] result() for ClusterFuture ... done
[11:01:54.979] result() for ClusterFuture ...
[11:01:54.979] - result already collected: FutureResult
[11:01:54.980] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.980] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.980] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.980] 
[11:01:54.981] Searching for globals ... DONE
[11:01:54.981] - globals: [0] <none>
[11:01:54.981] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:54.981] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:54.981] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:54.982] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:54.982] Searching for globals ... DONE
[11:01:54.982] Resolving globals: TRUE
[11:01:54.982] Resolving any globals that are futures ...
[11:01:54.982] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:54.982] Resolving any globals that are futures ... DONE
[11:01:54.983] Resolving futures part of globals (recursively) ...
[11:01:54.983] resolve() on list ...
[11:01:54.983]  recursive: 99
[11:01:54.983]  length: 1
[11:01:54.983]  elements: ‘a’
[11:01:54.983] run() for ‘Future’ ...
[11:01:54.983] - state: ‘created’
[11:01:54.984] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:54.997] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:54.997] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:54.997]   - Field: ‘node’
[11:01:54.997]   - Field: ‘label’
[11:01:54.997]   - Field: ‘local’
[11:01:54.998]   - Field: ‘owner’
[11:01:54.998]   - Field: ‘envir’
[11:01:54.998]   - Field: ‘workers’
[11:01:54.998]   - Field: ‘packages’
[11:01:54.998]   - Field: ‘gc’
[11:01:54.998]   - Field: ‘conditions’
[11:01:54.998]   - Field: ‘persistent’
[11:01:54.998]   - Field: ‘expr’
[11:01:54.998]   - Field: ‘uuid’
[11:01:54.998]   - Field: ‘seed’
[11:01:54.998]   - Field: ‘version’
[11:01:54.998]   - Field: ‘result’
[11:01:54.999]   - Field: ‘asynchronous’
[11:01:54.999]   - Field: ‘calls’
[11:01:54.999]   - Field: ‘globals’
[11:01:54.999]   - Field: ‘stdout’
[11:01:54.999]   - Field: ‘earlySignal’
[11:01:54.999]   - Field: ‘lazy’
[11:01:54.999]   - Field: ‘state’
[11:01:54.999] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:54.999] - Launch lazy future ...
[11:01:54.999] Packages needed by the future expression (n = 0): <none>
[11:01:55.000] Packages needed by future strategies (n = 0): <none>
[11:01:55.000] {
[11:01:55.000]     {
[11:01:55.000]         {
[11:01:55.000]             ...future.startTime <- base::Sys.time()
[11:01:55.000]             {
[11:01:55.000]                 {
[11:01:55.000]                   {
[11:01:55.000]                     {
[11:01:55.000]                       base::local({
[11:01:55.000]                         has_future <- base::requireNamespace("future", 
[11:01:55.000]                           quietly = TRUE)
[11:01:55.000]                         if (has_future) {
[11:01:55.000]                           ns <- base::getNamespace("future")
[11:01:55.000]                           version <- ns[[".package"]][["version"]]
[11:01:55.000]                           if (is.null(version)) 
[11:01:55.000]                             version <- utils::packageVersion("future")
[11:01:55.000]                         }
[11:01:55.000]                         else {
[11:01:55.000]                           version <- NULL
[11:01:55.000]                         }
[11:01:55.000]                         if (!has_future || version < "1.8.0") {
[11:01:55.000]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.000]                             "", base::R.version$version.string), 
[11:01:55.000]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.000]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.000]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.000]                               "release", "version")], collapse = " "), 
[11:01:55.000]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.000]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.000]                             info)
[11:01:55.000]                           info <- base::paste(info, collapse = "; ")
[11:01:55.000]                           if (!has_future) {
[11:01:55.000]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.000]                               info)
[11:01:55.000]                           }
[11:01:55.000]                           else {
[11:01:55.000]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.000]                               info, version)
[11:01:55.000]                           }
[11:01:55.000]                           base::stop(msg)
[11:01:55.000]                         }
[11:01:55.000]                       })
[11:01:55.000]                     }
[11:01:55.000]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.000]                     base::options(mc.cores = 1L)
[11:01:55.000]                   }
[11:01:55.000]                   ...future.strategy.old <- future::plan("list")
[11:01:55.000]                   options(future.plan = NULL)
[11:01:55.000]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.000]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.000]                 }
[11:01:55.000]                 ...future.workdir <- getwd()
[11:01:55.000]             }
[11:01:55.000]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.000]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.000]         }
[11:01:55.000]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.000]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:55.000]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.000]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.000]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.000]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.000]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.000]             base::names(...future.oldOptions))
[11:01:55.000]     }
[11:01:55.000]     if (FALSE) {
[11:01:55.000]     }
[11:01:55.000]     else {
[11:01:55.000]         if (TRUE) {
[11:01:55.000]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.000]                 open = "w")
[11:01:55.000]         }
[11:01:55.000]         else {
[11:01:55.000]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.000]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.000]         }
[11:01:55.000]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.000]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.000]             base::sink(type = "output", split = FALSE)
[11:01:55.000]             base::close(...future.stdout)
[11:01:55.000]         }, add = TRUE)
[11:01:55.000]     }
[11:01:55.000]     ...future.frame <- base::sys.nframe()
[11:01:55.000]     ...future.conditions <- base::list()
[11:01:55.000]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.000]     if (FALSE) {
[11:01:55.000]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.000]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.000]     }
[11:01:55.000]     ...future.result <- base::tryCatch({
[11:01:55.000]         base::withCallingHandlers({
[11:01:55.000]             ...future.value <- base::withVisible(base::local({
[11:01:55.000]                 ...future.makeSendCondition <- base::local({
[11:01:55.000]                   sendCondition <- NULL
[11:01:55.000]                   function(frame = 1L) {
[11:01:55.000]                     if (is.function(sendCondition)) 
[11:01:55.000]                       return(sendCondition)
[11:01:55.000]                     ns <- getNamespace("parallel")
[11:01:55.000]                     if (exists("sendData", mode = "function", 
[11:01:55.000]                       envir = ns)) {
[11:01:55.000]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.000]                         envir = ns)
[11:01:55.000]                       envir <- sys.frame(frame)
[11:01:55.000]                       master <- NULL
[11:01:55.000]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.000]                         !identical(envir, emptyenv())) {
[11:01:55.000]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.000]                           inherits = FALSE)) {
[11:01:55.000]                           master <- get("master", mode = "list", 
[11:01:55.000]                             envir = envir, inherits = FALSE)
[11:01:55.000]                           if (inherits(master, c("SOCKnode", 
[11:01:55.000]                             "SOCK0node"))) {
[11:01:55.000]                             sendCondition <<- function(cond) {
[11:01:55.000]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.000]                                 success = TRUE)
[11:01:55.000]                               parallel_sendData(master, data)
[11:01:55.000]                             }
[11:01:55.000]                             return(sendCondition)
[11:01:55.000]                           }
[11:01:55.000]                         }
[11:01:55.000]                         frame <- frame + 1L
[11:01:55.000]                         envir <- sys.frame(frame)
[11:01:55.000]                       }
[11:01:55.000]                     }
[11:01:55.000]                     sendCondition <<- function(cond) NULL
[11:01:55.000]                   }
[11:01:55.000]                 })
[11:01:55.000]                 withCallingHandlers({
[11:01:55.000]                   1
[11:01:55.000]                 }, immediateCondition = function(cond) {
[11:01:55.000]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.000]                   sendCondition(cond)
[11:01:55.000]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.000]                   {
[11:01:55.000]                     inherits <- base::inherits
[11:01:55.000]                     invokeRestart <- base::invokeRestart
[11:01:55.000]                     is.null <- base::is.null
[11:01:55.000]                     muffled <- FALSE
[11:01:55.000]                     if (inherits(cond, "message")) {
[11:01:55.000]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.000]                       if (muffled) 
[11:01:55.000]                         invokeRestart("muffleMessage")
[11:01:55.000]                     }
[11:01:55.000]                     else if (inherits(cond, "warning")) {
[11:01:55.000]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.000]                       if (muffled) 
[11:01:55.000]                         invokeRestart("muffleWarning")
[11:01:55.000]                     }
[11:01:55.000]                     else if (inherits(cond, "condition")) {
[11:01:55.000]                       if (!is.null(pattern)) {
[11:01:55.000]                         computeRestarts <- base::computeRestarts
[11:01:55.000]                         grepl <- base::grepl
[11:01:55.000]                         restarts <- computeRestarts(cond)
[11:01:55.000]                         for (restart in restarts) {
[11:01:55.000]                           name <- restart$name
[11:01:55.000]                           if (is.null(name)) 
[11:01:55.000]                             next
[11:01:55.000]                           if (!grepl(pattern, name)) 
[11:01:55.000]                             next
[11:01:55.000]                           invokeRestart(restart)
[11:01:55.000]                           muffled <- TRUE
[11:01:55.000]                           break
[11:01:55.000]                         }
[11:01:55.000]                       }
[11:01:55.000]                     }
[11:01:55.000]                     invisible(muffled)
[11:01:55.000]                   }
[11:01:55.000]                   muffleCondition(cond)
[11:01:55.000]                 })
[11:01:55.000]             }))
[11:01:55.000]             future::FutureResult(value = ...future.value$value, 
[11:01:55.000]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.000]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.000]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.000]                     ...future.globalenv.names))
[11:01:55.000]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.000]         }, condition = base::local({
[11:01:55.000]             c <- base::c
[11:01:55.000]             inherits <- base::inherits
[11:01:55.000]             invokeRestart <- base::invokeRestart
[11:01:55.000]             length <- base::length
[11:01:55.000]             list <- base::list
[11:01:55.000]             seq.int <- base::seq.int
[11:01:55.000]             signalCondition <- base::signalCondition
[11:01:55.000]             sys.calls <- base::sys.calls
[11:01:55.000]             `[[` <- base::`[[`
[11:01:55.000]             `+` <- base::`+`
[11:01:55.000]             `<<-` <- base::`<<-`
[11:01:55.000]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.000]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.000]                   3L)]
[11:01:55.000]             }
[11:01:55.000]             function(cond) {
[11:01:55.000]                 is_error <- inherits(cond, "error")
[11:01:55.000]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.000]                   NULL)
[11:01:55.000]                 if (is_error) {
[11:01:55.000]                   sessionInformation <- function() {
[11:01:55.000]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.000]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.000]                       search = base::search(), system = base::Sys.info())
[11:01:55.000]                   }
[11:01:55.000]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.000]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.000]                     cond$call), session = sessionInformation(), 
[11:01:55.000]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.000]                   signalCondition(cond)
[11:01:55.000]                 }
[11:01:55.000]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.000]                 "immediateCondition"))) {
[11:01:55.000]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.000]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.000]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.000]                   if (TRUE && !signal) {
[11:01:55.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.000]                     {
[11:01:55.000]                       inherits <- base::inherits
[11:01:55.000]                       invokeRestart <- base::invokeRestart
[11:01:55.000]                       is.null <- base::is.null
[11:01:55.000]                       muffled <- FALSE
[11:01:55.000]                       if (inherits(cond, "message")) {
[11:01:55.000]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.000]                         if (muffled) 
[11:01:55.000]                           invokeRestart("muffleMessage")
[11:01:55.000]                       }
[11:01:55.000]                       else if (inherits(cond, "warning")) {
[11:01:55.000]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.000]                         if (muffled) 
[11:01:55.000]                           invokeRestart("muffleWarning")
[11:01:55.000]                       }
[11:01:55.000]                       else if (inherits(cond, "condition")) {
[11:01:55.000]                         if (!is.null(pattern)) {
[11:01:55.000]                           computeRestarts <- base::computeRestarts
[11:01:55.000]                           grepl <- base::grepl
[11:01:55.000]                           restarts <- computeRestarts(cond)
[11:01:55.000]                           for (restart in restarts) {
[11:01:55.000]                             name <- restart$name
[11:01:55.000]                             if (is.null(name)) 
[11:01:55.000]                               next
[11:01:55.000]                             if (!grepl(pattern, name)) 
[11:01:55.000]                               next
[11:01:55.000]                             invokeRestart(restart)
[11:01:55.000]                             muffled <- TRUE
[11:01:55.000]                             break
[11:01:55.000]                           }
[11:01:55.000]                         }
[11:01:55.000]                       }
[11:01:55.000]                       invisible(muffled)
[11:01:55.000]                     }
[11:01:55.000]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.000]                   }
[11:01:55.000]                 }
[11:01:55.000]                 else {
[11:01:55.000]                   if (TRUE) {
[11:01:55.000]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.000]                     {
[11:01:55.000]                       inherits <- base::inherits
[11:01:55.000]                       invokeRestart <- base::invokeRestart
[11:01:55.000]                       is.null <- base::is.null
[11:01:55.000]                       muffled <- FALSE
[11:01:55.000]                       if (inherits(cond, "message")) {
[11:01:55.000]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.000]                         if (muffled) 
[11:01:55.000]                           invokeRestart("muffleMessage")
[11:01:55.000]                       }
[11:01:55.000]                       else if (inherits(cond, "warning")) {
[11:01:55.000]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.000]                         if (muffled) 
[11:01:55.000]                           invokeRestart("muffleWarning")
[11:01:55.000]                       }
[11:01:55.000]                       else if (inherits(cond, "condition")) {
[11:01:55.000]                         if (!is.null(pattern)) {
[11:01:55.000]                           computeRestarts <- base::computeRestarts
[11:01:55.000]                           grepl <- base::grepl
[11:01:55.000]                           restarts <- computeRestarts(cond)
[11:01:55.000]                           for (restart in restarts) {
[11:01:55.000]                             name <- restart$name
[11:01:55.000]                             if (is.null(name)) 
[11:01:55.000]                               next
[11:01:55.000]                             if (!grepl(pattern, name)) 
[11:01:55.000]                               next
[11:01:55.000]                             invokeRestart(restart)
[11:01:55.000]                             muffled <- TRUE
[11:01:55.000]                             break
[11:01:55.000]                           }
[11:01:55.000]                         }
[11:01:55.000]                       }
[11:01:55.000]                       invisible(muffled)
[11:01:55.000]                     }
[11:01:55.000]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.000]                   }
[11:01:55.000]                 }
[11:01:55.000]             }
[11:01:55.000]         }))
[11:01:55.000]     }, error = function(ex) {
[11:01:55.000]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.000]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.000]                 ...future.rng), started = ...future.startTime, 
[11:01:55.000]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.000]             version = "1.8"), class = "FutureResult")
[11:01:55.000]     }, finally = {
[11:01:55.000]         if (!identical(...future.workdir, getwd())) 
[11:01:55.000]             setwd(...future.workdir)
[11:01:55.000]         {
[11:01:55.000]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.000]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.000]             }
[11:01:55.000]             base::options(...future.oldOptions)
[11:01:55.000]             if (.Platform$OS.type == "windows") {
[11:01:55.000]                 old_names <- names(...future.oldEnvVars)
[11:01:55.000]                 envs <- base::Sys.getenv()
[11:01:55.000]                 names <- names(envs)
[11:01:55.000]                 common <- intersect(names, old_names)
[11:01:55.000]                 added <- setdiff(names, old_names)
[11:01:55.000]                 removed <- setdiff(old_names, names)
[11:01:55.000]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.000]                   envs[common]]
[11:01:55.000]                 NAMES <- toupper(changed)
[11:01:55.000]                 args <- list()
[11:01:55.000]                 for (kk in seq_along(NAMES)) {
[11:01:55.000]                   name <- changed[[kk]]
[11:01:55.000]                   NAME <- NAMES[[kk]]
[11:01:55.000]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.000]                     next
[11:01:55.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.000]                 }
[11:01:55.000]                 NAMES <- toupper(added)
[11:01:55.000]                 for (kk in seq_along(NAMES)) {
[11:01:55.000]                   name <- added[[kk]]
[11:01:55.000]                   NAME <- NAMES[[kk]]
[11:01:55.000]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.000]                     next
[11:01:55.000]                   args[[name]] <- ""
[11:01:55.000]                 }
[11:01:55.000]                 NAMES <- toupper(removed)
[11:01:55.000]                 for (kk in seq_along(NAMES)) {
[11:01:55.000]                   name <- removed[[kk]]
[11:01:55.000]                   NAME <- NAMES[[kk]]
[11:01:55.000]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.000]                     next
[11:01:55.000]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.000]                 }
[11:01:55.000]                 if (length(args) > 0) 
[11:01:55.000]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.000]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.000]             }
[11:01:55.000]             else {
[11:01:55.000]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.000]             }
[11:01:55.000]             {
[11:01:55.000]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.000]                   0L) {
[11:01:55.000]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.000]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.000]                   base::options(opts)
[11:01:55.000]                 }
[11:01:55.000]                 {
[11:01:55.000]                   {
[11:01:55.000]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.000]                     NULL
[11:01:55.000]                   }
[11:01:55.000]                   options(future.plan = NULL)
[11:01:55.000]                   if (is.na(NA_character_)) 
[11:01:55.000]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.000]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.000]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.000]                     .init = FALSE)
[11:01:55.000]                 }
[11:01:55.000]             }
[11:01:55.000]         }
[11:01:55.000]     })
[11:01:55.000]     if (TRUE) {
[11:01:55.000]         base::sink(type = "output", split = FALSE)
[11:01:55.000]         if (TRUE) {
[11:01:55.000]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.000]         }
[11:01:55.000]         else {
[11:01:55.000]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.000]         }
[11:01:55.000]         base::close(...future.stdout)
[11:01:55.000]         ...future.stdout <- NULL
[11:01:55.000]     }
[11:01:55.000]     ...future.result$conditions <- ...future.conditions
[11:01:55.000]     ...future.result$finished <- base::Sys.time()
[11:01:55.000]     ...future.result
[11:01:55.000] }
[11:01:55.003] MultisessionFuture started
[11:01:55.003] - Launch lazy future ... done
[11:01:55.003] run() for ‘MultisessionFuture’ ... done
[11:01:55.045] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.045] - Validating connection of MultisessionFuture
[11:01:55.045] - received message: FutureResult
[11:01:55.045] - Received FutureResult
[11:01:55.045] - Erased future from FutureRegistry
[11:01:55.046] result() for ClusterFuture ...
[11:01:55.046] - result already collected: FutureResult
[11:01:55.046] result() for ClusterFuture ... done
[11:01:55.046] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.046] Future #1
[11:01:55.046] result() for ClusterFuture ...
[11:01:55.046] - result already collected: FutureResult
[11:01:55.046] result() for ClusterFuture ... done
[11:01:55.046] result() for ClusterFuture ...
[11:01:55.046] - result already collected: FutureResult
[11:01:55.046] result() for ClusterFuture ... done
[11:01:55.047] A MultisessionFuture was resolved
[11:01:55.047]  length: 0 (resolved future 1)
[11:01:55.047] resolve() on list ... DONE
[11:01:55.047] - globals: [1] ‘a’
[11:01:55.047] Resolving futures part of globals (recursively) ... DONE
[11:01:55.059] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[11:01:55.059] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[11:01:55.060] - globals: [1] ‘a’
[11:01:55.060] - packages: [1] ‘future’
[11:01:55.060] getGlobalsAndPackages() ... DONE
[11:01:55.060] run() for ‘Future’ ...
[11:01:55.060] - state: ‘created’
[11:01:55.060] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.074] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.074] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.074]   - Field: ‘node’
[11:01:55.074]   - Field: ‘label’
[11:01:55.074]   - Field: ‘local’
[11:01:55.074]   - Field: ‘owner’
[11:01:55.074]   - Field: ‘envir’
[11:01:55.075]   - Field: ‘workers’
[11:01:55.075]   - Field: ‘packages’
[11:01:55.075]   - Field: ‘gc’
[11:01:55.075]   - Field: ‘conditions’
[11:01:55.075]   - Field: ‘persistent’
[11:01:55.075]   - Field: ‘expr’
[11:01:55.075]   - Field: ‘uuid’
[11:01:55.075]   - Field: ‘seed’
[11:01:55.075]   - Field: ‘version’
[11:01:55.075]   - Field: ‘result’
[11:01:55.075]   - Field: ‘asynchronous’
[11:01:55.075]   - Field: ‘calls’
[11:01:55.076]   - Field: ‘globals’
[11:01:55.076]   - Field: ‘stdout’
[11:01:55.076]   - Field: ‘earlySignal’
[11:01:55.076]   - Field: ‘lazy’
[11:01:55.076]   - Field: ‘state’
[11:01:55.076] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.076] - Launch lazy future ...
[11:01:55.076] Packages needed by the future expression (n = 1): ‘future’
[11:01:55.076] Packages needed by future strategies (n = 0): <none>
[11:01:55.077] {
[11:01:55.077]     {
[11:01:55.077]         {
[11:01:55.077]             ...future.startTime <- base::Sys.time()
[11:01:55.077]             {
[11:01:55.077]                 {
[11:01:55.077]                   {
[11:01:55.077]                     {
[11:01:55.077]                       {
[11:01:55.077]                         base::local({
[11:01:55.077]                           has_future <- base::requireNamespace("future", 
[11:01:55.077]                             quietly = TRUE)
[11:01:55.077]                           if (has_future) {
[11:01:55.077]                             ns <- base::getNamespace("future")
[11:01:55.077]                             version <- ns[[".package"]][["version"]]
[11:01:55.077]                             if (is.null(version)) 
[11:01:55.077]                               version <- utils::packageVersion("future")
[11:01:55.077]                           }
[11:01:55.077]                           else {
[11:01:55.077]                             version <- NULL
[11:01:55.077]                           }
[11:01:55.077]                           if (!has_future || version < "1.8.0") {
[11:01:55.077]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.077]                               "", base::R.version$version.string), 
[11:01:55.077]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:55.077]                                 base::R.version$platform, 8 * 
[11:01:55.077]                                   base::.Machine$sizeof.pointer), 
[11:01:55.077]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.077]                                 "release", "version")], collapse = " "), 
[11:01:55.077]                               hostname = base::Sys.info()[["nodename"]])
[11:01:55.077]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.077]                               info)
[11:01:55.077]                             info <- base::paste(info, collapse = "; ")
[11:01:55.077]                             if (!has_future) {
[11:01:55.077]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.077]                                 info)
[11:01:55.077]                             }
[11:01:55.077]                             else {
[11:01:55.077]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.077]                                 info, version)
[11:01:55.077]                             }
[11:01:55.077]                             base::stop(msg)
[11:01:55.077]                           }
[11:01:55.077]                         })
[11:01:55.077]                       }
[11:01:55.077]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.077]                       base::options(mc.cores = 1L)
[11:01:55.077]                     }
[11:01:55.077]                     base::local({
[11:01:55.077]                       for (pkg in "future") {
[11:01:55.077]                         base::loadNamespace(pkg)
[11:01:55.077]                         base::library(pkg, character.only = TRUE)
[11:01:55.077]                       }
[11:01:55.077]                     })
[11:01:55.077]                   }
[11:01:55.077]                   ...future.strategy.old <- future::plan("list")
[11:01:55.077]                   options(future.plan = NULL)
[11:01:55.077]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.077]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.077]                 }
[11:01:55.077]                 ...future.workdir <- getwd()
[11:01:55.077]             }
[11:01:55.077]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.077]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.077]         }
[11:01:55.077]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.077]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:55.077]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.077]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.077]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.077]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.077]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.077]             base::names(...future.oldOptions))
[11:01:55.077]     }
[11:01:55.077]     if (FALSE) {
[11:01:55.077]     }
[11:01:55.077]     else {
[11:01:55.077]         if (TRUE) {
[11:01:55.077]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.077]                 open = "w")
[11:01:55.077]         }
[11:01:55.077]         else {
[11:01:55.077]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.077]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.077]         }
[11:01:55.077]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.077]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.077]             base::sink(type = "output", split = FALSE)
[11:01:55.077]             base::close(...future.stdout)
[11:01:55.077]         }, add = TRUE)
[11:01:55.077]     }
[11:01:55.077]     ...future.frame <- base::sys.nframe()
[11:01:55.077]     ...future.conditions <- base::list()
[11:01:55.077]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.077]     if (FALSE) {
[11:01:55.077]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.077]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.077]     }
[11:01:55.077]     ...future.result <- base::tryCatch({
[11:01:55.077]         base::withCallingHandlers({
[11:01:55.077]             ...future.value <- base::withVisible(base::local({
[11:01:55.077]                 ...future.makeSendCondition <- base::local({
[11:01:55.077]                   sendCondition <- NULL
[11:01:55.077]                   function(frame = 1L) {
[11:01:55.077]                     if (is.function(sendCondition)) 
[11:01:55.077]                       return(sendCondition)
[11:01:55.077]                     ns <- getNamespace("parallel")
[11:01:55.077]                     if (exists("sendData", mode = "function", 
[11:01:55.077]                       envir = ns)) {
[11:01:55.077]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.077]                         envir = ns)
[11:01:55.077]                       envir <- sys.frame(frame)
[11:01:55.077]                       master <- NULL
[11:01:55.077]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.077]                         !identical(envir, emptyenv())) {
[11:01:55.077]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.077]                           inherits = FALSE)) {
[11:01:55.077]                           master <- get("master", mode = "list", 
[11:01:55.077]                             envir = envir, inherits = FALSE)
[11:01:55.077]                           if (inherits(master, c("SOCKnode", 
[11:01:55.077]                             "SOCK0node"))) {
[11:01:55.077]                             sendCondition <<- function(cond) {
[11:01:55.077]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.077]                                 success = TRUE)
[11:01:55.077]                               parallel_sendData(master, data)
[11:01:55.077]                             }
[11:01:55.077]                             return(sendCondition)
[11:01:55.077]                           }
[11:01:55.077]                         }
[11:01:55.077]                         frame <- frame + 1L
[11:01:55.077]                         envir <- sys.frame(frame)
[11:01:55.077]                       }
[11:01:55.077]                     }
[11:01:55.077]                     sendCondition <<- function(cond) NULL
[11:01:55.077]                   }
[11:01:55.077]                 })
[11:01:55.077]                 withCallingHandlers({
[11:01:55.077]                   value(a) + 1
[11:01:55.077]                 }, immediateCondition = function(cond) {
[11:01:55.077]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.077]                   sendCondition(cond)
[11:01:55.077]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.077]                   {
[11:01:55.077]                     inherits <- base::inherits
[11:01:55.077]                     invokeRestart <- base::invokeRestart
[11:01:55.077]                     is.null <- base::is.null
[11:01:55.077]                     muffled <- FALSE
[11:01:55.077]                     if (inherits(cond, "message")) {
[11:01:55.077]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.077]                       if (muffled) 
[11:01:55.077]                         invokeRestart("muffleMessage")
[11:01:55.077]                     }
[11:01:55.077]                     else if (inherits(cond, "warning")) {
[11:01:55.077]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.077]                       if (muffled) 
[11:01:55.077]                         invokeRestart("muffleWarning")
[11:01:55.077]                     }
[11:01:55.077]                     else if (inherits(cond, "condition")) {
[11:01:55.077]                       if (!is.null(pattern)) {
[11:01:55.077]                         computeRestarts <- base::computeRestarts
[11:01:55.077]                         grepl <- base::grepl
[11:01:55.077]                         restarts <- computeRestarts(cond)
[11:01:55.077]                         for (restart in restarts) {
[11:01:55.077]                           name <- restart$name
[11:01:55.077]                           if (is.null(name)) 
[11:01:55.077]                             next
[11:01:55.077]                           if (!grepl(pattern, name)) 
[11:01:55.077]                             next
[11:01:55.077]                           invokeRestart(restart)
[11:01:55.077]                           muffled <- TRUE
[11:01:55.077]                           break
[11:01:55.077]                         }
[11:01:55.077]                       }
[11:01:55.077]                     }
[11:01:55.077]                     invisible(muffled)
[11:01:55.077]                   }
[11:01:55.077]                   muffleCondition(cond)
[11:01:55.077]                 })
[11:01:55.077]             }))
[11:01:55.077]             future::FutureResult(value = ...future.value$value, 
[11:01:55.077]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.077]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.077]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.077]                     ...future.globalenv.names))
[11:01:55.077]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.077]         }, condition = base::local({
[11:01:55.077]             c <- base::c
[11:01:55.077]             inherits <- base::inherits
[11:01:55.077]             invokeRestart <- base::invokeRestart
[11:01:55.077]             length <- base::length
[11:01:55.077]             list <- base::list
[11:01:55.077]             seq.int <- base::seq.int
[11:01:55.077]             signalCondition <- base::signalCondition
[11:01:55.077]             sys.calls <- base::sys.calls
[11:01:55.077]             `[[` <- base::`[[`
[11:01:55.077]             `+` <- base::`+`
[11:01:55.077]             `<<-` <- base::`<<-`
[11:01:55.077]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.077]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.077]                   3L)]
[11:01:55.077]             }
[11:01:55.077]             function(cond) {
[11:01:55.077]                 is_error <- inherits(cond, "error")
[11:01:55.077]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.077]                   NULL)
[11:01:55.077]                 if (is_error) {
[11:01:55.077]                   sessionInformation <- function() {
[11:01:55.077]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.077]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.077]                       search = base::search(), system = base::Sys.info())
[11:01:55.077]                   }
[11:01:55.077]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.077]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.077]                     cond$call), session = sessionInformation(), 
[11:01:55.077]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.077]                   signalCondition(cond)
[11:01:55.077]                 }
[11:01:55.077]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.077]                 "immediateCondition"))) {
[11:01:55.077]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.077]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.077]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.077]                   if (TRUE && !signal) {
[11:01:55.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.077]                     {
[11:01:55.077]                       inherits <- base::inherits
[11:01:55.077]                       invokeRestart <- base::invokeRestart
[11:01:55.077]                       is.null <- base::is.null
[11:01:55.077]                       muffled <- FALSE
[11:01:55.077]                       if (inherits(cond, "message")) {
[11:01:55.077]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.077]                         if (muffled) 
[11:01:55.077]                           invokeRestart("muffleMessage")
[11:01:55.077]                       }
[11:01:55.077]                       else if (inherits(cond, "warning")) {
[11:01:55.077]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.077]                         if (muffled) 
[11:01:55.077]                           invokeRestart("muffleWarning")
[11:01:55.077]                       }
[11:01:55.077]                       else if (inherits(cond, "condition")) {
[11:01:55.077]                         if (!is.null(pattern)) {
[11:01:55.077]                           computeRestarts <- base::computeRestarts
[11:01:55.077]                           grepl <- base::grepl
[11:01:55.077]                           restarts <- computeRestarts(cond)
[11:01:55.077]                           for (restart in restarts) {
[11:01:55.077]                             name <- restart$name
[11:01:55.077]                             if (is.null(name)) 
[11:01:55.077]                               next
[11:01:55.077]                             if (!grepl(pattern, name)) 
[11:01:55.077]                               next
[11:01:55.077]                             invokeRestart(restart)
[11:01:55.077]                             muffled <- TRUE
[11:01:55.077]                             break
[11:01:55.077]                           }
[11:01:55.077]                         }
[11:01:55.077]                       }
[11:01:55.077]                       invisible(muffled)
[11:01:55.077]                     }
[11:01:55.077]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.077]                   }
[11:01:55.077]                 }
[11:01:55.077]                 else {
[11:01:55.077]                   if (TRUE) {
[11:01:55.077]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.077]                     {
[11:01:55.077]                       inherits <- base::inherits
[11:01:55.077]                       invokeRestart <- base::invokeRestart
[11:01:55.077]                       is.null <- base::is.null
[11:01:55.077]                       muffled <- FALSE
[11:01:55.077]                       if (inherits(cond, "message")) {
[11:01:55.077]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.077]                         if (muffled) 
[11:01:55.077]                           invokeRestart("muffleMessage")
[11:01:55.077]                       }
[11:01:55.077]                       else if (inherits(cond, "warning")) {
[11:01:55.077]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.077]                         if (muffled) 
[11:01:55.077]                           invokeRestart("muffleWarning")
[11:01:55.077]                       }
[11:01:55.077]                       else if (inherits(cond, "condition")) {
[11:01:55.077]                         if (!is.null(pattern)) {
[11:01:55.077]                           computeRestarts <- base::computeRestarts
[11:01:55.077]                           grepl <- base::grepl
[11:01:55.077]                           restarts <- computeRestarts(cond)
[11:01:55.077]                           for (restart in restarts) {
[11:01:55.077]                             name <- restart$name
[11:01:55.077]                             if (is.null(name)) 
[11:01:55.077]                               next
[11:01:55.077]                             if (!grepl(pattern, name)) 
[11:01:55.077]                               next
[11:01:55.077]                             invokeRestart(restart)
[11:01:55.077]                             muffled <- TRUE
[11:01:55.077]                             break
[11:01:55.077]                           }
[11:01:55.077]                         }
[11:01:55.077]                       }
[11:01:55.077]                       invisible(muffled)
[11:01:55.077]                     }
[11:01:55.077]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.077]                   }
[11:01:55.077]                 }
[11:01:55.077]             }
[11:01:55.077]         }))
[11:01:55.077]     }, error = function(ex) {
[11:01:55.077]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.077]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.077]                 ...future.rng), started = ...future.startTime, 
[11:01:55.077]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.077]             version = "1.8"), class = "FutureResult")
[11:01:55.077]     }, finally = {
[11:01:55.077]         if (!identical(...future.workdir, getwd())) 
[11:01:55.077]             setwd(...future.workdir)
[11:01:55.077]         {
[11:01:55.077]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.077]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.077]             }
[11:01:55.077]             base::options(...future.oldOptions)
[11:01:55.077]             if (.Platform$OS.type == "windows") {
[11:01:55.077]                 old_names <- names(...future.oldEnvVars)
[11:01:55.077]                 envs <- base::Sys.getenv()
[11:01:55.077]                 names <- names(envs)
[11:01:55.077]                 common <- intersect(names, old_names)
[11:01:55.077]                 added <- setdiff(names, old_names)
[11:01:55.077]                 removed <- setdiff(old_names, names)
[11:01:55.077]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.077]                   envs[common]]
[11:01:55.077]                 NAMES <- toupper(changed)
[11:01:55.077]                 args <- list()
[11:01:55.077]                 for (kk in seq_along(NAMES)) {
[11:01:55.077]                   name <- changed[[kk]]
[11:01:55.077]                   NAME <- NAMES[[kk]]
[11:01:55.077]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.077]                     next
[11:01:55.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.077]                 }
[11:01:55.077]                 NAMES <- toupper(added)
[11:01:55.077]                 for (kk in seq_along(NAMES)) {
[11:01:55.077]                   name <- added[[kk]]
[11:01:55.077]                   NAME <- NAMES[[kk]]
[11:01:55.077]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.077]                     next
[11:01:55.077]                   args[[name]] <- ""
[11:01:55.077]                 }
[11:01:55.077]                 NAMES <- toupper(removed)
[11:01:55.077]                 for (kk in seq_along(NAMES)) {
[11:01:55.077]                   name <- removed[[kk]]
[11:01:55.077]                   NAME <- NAMES[[kk]]
[11:01:55.077]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.077]                     next
[11:01:55.077]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.077]                 }
[11:01:55.077]                 if (length(args) > 0) 
[11:01:55.077]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.077]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.077]             }
[11:01:55.077]             else {
[11:01:55.077]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.077]             }
[11:01:55.077]             {
[11:01:55.077]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.077]                   0L) {
[11:01:55.077]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.077]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.077]                   base::options(opts)
[11:01:55.077]                 }
[11:01:55.077]                 {
[11:01:55.077]                   {
[11:01:55.077]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.077]                     NULL
[11:01:55.077]                   }
[11:01:55.077]                   options(future.plan = NULL)
[11:01:55.077]                   if (is.na(NA_character_)) 
[11:01:55.077]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.077]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.077]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.077]                     .init = FALSE)
[11:01:55.077]                 }
[11:01:55.077]             }
[11:01:55.077]         }
[11:01:55.077]     })
[11:01:55.077]     if (TRUE) {
[11:01:55.077]         base::sink(type = "output", split = FALSE)
[11:01:55.077]         if (TRUE) {
[11:01:55.077]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.077]         }
[11:01:55.077]         else {
[11:01:55.077]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.077]         }
[11:01:55.077]         base::close(...future.stdout)
[11:01:55.077]         ...future.stdout <- NULL
[11:01:55.077]     }
[11:01:55.077]     ...future.result$conditions <- ...future.conditions
[11:01:55.077]     ...future.result$finished <- base::Sys.time()
[11:01:55.077]     ...future.result
[11:01:55.077] }
[11:01:55.090] Exporting 1 global objects (313.46 KiB) to cluster node #2 ...
[11:01:55.101] Exporting ‘a’ (313.25 KiB) to cluster node #2 ...
[11:01:55.153] Exporting ‘a’ (313.25 KiB) to cluster node #2 ... DONE
[11:01:55.153] Exporting 1 global objects (313.46 KiB) to cluster node #2 ... DONE
[11:01:55.153] MultisessionFuture started
[11:01:55.154] - Launch lazy future ... done
[11:01:55.154] run() for ‘MultisessionFuture’ ... done
[11:01:55.154] result() for ClusterFuture ...
[11:01:55.154] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.154] - Validating connection of MultisessionFuture
[11:01:55.195] - received message: FutureResult
[11:01:55.195] - Received FutureResult
[11:01:55.195] - Erased future from FutureRegistry
[11:01:55.196] result() for ClusterFuture ...
[11:01:55.196] - result already collected: FutureResult
[11:01:55.196] result() for ClusterFuture ... done
[11:01:55.196] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.196] result() for ClusterFuture ... done
[11:01:55.196] result() for ClusterFuture ...
[11:01:55.196] - result already collected: FutureResult
[11:01:55.196] result() for ClusterFuture ... done
value(b) = 2
[11:01:55.196] result() for ClusterFuture ...
[11:01:55.196] - result already collected: FutureResult
[11:01:55.197] result() for ClusterFuture ... done
[11:01:55.197] result() for ClusterFuture ...
[11:01:55.197] - result already collected: FutureResult
[11:01:55.197] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.197] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.197] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:55.198] 
[11:01:55.198] Searching for globals ... DONE
[11:01:55.198] - globals: [0] <none>
[11:01:55.198] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.198] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.198] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:55.199] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:55.199] Searching for globals ... DONE
[11:01:55.199] Resolving globals: TRUE
[11:01:55.200] Resolving any globals that are futures ...
[11:01:55.200] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:55.200] Resolving any globals that are futures ... DONE
[11:01:55.200] Resolving futures part of globals (recursively) ...
[11:01:55.200] resolve() on list ...
[11:01:55.200]  recursive: 99
[11:01:55.200]  length: 1
[11:01:55.201]  elements: ‘a’
[11:01:55.201] run() for ‘Future’ ...
[11:01:55.201] - state: ‘created’
[11:01:55.201] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.214] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.215] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.215]   - Field: ‘node’
[11:01:55.215]   - Field: ‘label’
[11:01:55.215]   - Field: ‘local’
[11:01:55.215]   - Field: ‘owner’
[11:01:55.215]   - Field: ‘envir’
[11:01:55.215]   - Field: ‘workers’
[11:01:55.215]   - Field: ‘packages’
[11:01:55.215]   - Field: ‘gc’
[11:01:55.215]   - Field: ‘conditions’
[11:01:55.215]   - Field: ‘persistent’
[11:01:55.216]   - Field: ‘expr’
[11:01:55.216]   - Field: ‘uuid’
[11:01:55.216]   - Field: ‘seed’
[11:01:55.216]   - Field: ‘version’
[11:01:55.216]   - Field: ‘result’
[11:01:55.216]   - Field: ‘asynchronous’
[11:01:55.216]   - Field: ‘calls’
[11:01:55.216]   - Field: ‘globals’
[11:01:55.216]   - Field: ‘stdout’
[11:01:55.216]   - Field: ‘earlySignal’
[11:01:55.216]   - Field: ‘lazy’
[11:01:55.216]   - Field: ‘state’
[11:01:55.217] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.217] - Launch lazy future ...
[11:01:55.217] Packages needed by the future expression (n = 0): <none>
[11:01:55.217] Packages needed by future strategies (n = 0): <none>
[11:01:55.217] {
[11:01:55.217]     {
[11:01:55.217]         {
[11:01:55.217]             ...future.startTime <- base::Sys.time()
[11:01:55.217]             {
[11:01:55.217]                 {
[11:01:55.217]                   {
[11:01:55.217]                     {
[11:01:55.217]                       base::local({
[11:01:55.217]                         has_future <- base::requireNamespace("future", 
[11:01:55.217]                           quietly = TRUE)
[11:01:55.217]                         if (has_future) {
[11:01:55.217]                           ns <- base::getNamespace("future")
[11:01:55.217]                           version <- ns[[".package"]][["version"]]
[11:01:55.217]                           if (is.null(version)) 
[11:01:55.217]                             version <- utils::packageVersion("future")
[11:01:55.217]                         }
[11:01:55.217]                         else {
[11:01:55.217]                           version <- NULL
[11:01:55.217]                         }
[11:01:55.217]                         if (!has_future || version < "1.8.0") {
[11:01:55.217]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.217]                             "", base::R.version$version.string), 
[11:01:55.217]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.217]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.217]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.217]                               "release", "version")], collapse = " "), 
[11:01:55.217]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.217]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.217]                             info)
[11:01:55.217]                           info <- base::paste(info, collapse = "; ")
[11:01:55.217]                           if (!has_future) {
[11:01:55.217]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.217]                               info)
[11:01:55.217]                           }
[11:01:55.217]                           else {
[11:01:55.217]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.217]                               info, version)
[11:01:55.217]                           }
[11:01:55.217]                           base::stop(msg)
[11:01:55.217]                         }
[11:01:55.217]                       })
[11:01:55.217]                     }
[11:01:55.217]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.217]                     base::options(mc.cores = 1L)
[11:01:55.217]                   }
[11:01:55.217]                   ...future.strategy.old <- future::plan("list")
[11:01:55.217]                   options(future.plan = NULL)
[11:01:55.217]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.217]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.217]                 }
[11:01:55.217]                 ...future.workdir <- getwd()
[11:01:55.217]             }
[11:01:55.217]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.217]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.217]         }
[11:01:55.217]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.217]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:55.217]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.217]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.217]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.217]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.217]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.217]             base::names(...future.oldOptions))
[11:01:55.217]     }
[11:01:55.217]     if (FALSE) {
[11:01:55.217]     }
[11:01:55.217]     else {
[11:01:55.217]         if (TRUE) {
[11:01:55.217]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.217]                 open = "w")
[11:01:55.217]         }
[11:01:55.217]         else {
[11:01:55.217]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.217]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.217]         }
[11:01:55.217]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.217]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.217]             base::sink(type = "output", split = FALSE)
[11:01:55.217]             base::close(...future.stdout)
[11:01:55.217]         }, add = TRUE)
[11:01:55.217]     }
[11:01:55.217]     ...future.frame <- base::sys.nframe()
[11:01:55.217]     ...future.conditions <- base::list()
[11:01:55.217]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.217]     if (FALSE) {
[11:01:55.217]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.217]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.217]     }
[11:01:55.217]     ...future.result <- base::tryCatch({
[11:01:55.217]         base::withCallingHandlers({
[11:01:55.217]             ...future.value <- base::withVisible(base::local({
[11:01:55.217]                 ...future.makeSendCondition <- base::local({
[11:01:55.217]                   sendCondition <- NULL
[11:01:55.217]                   function(frame = 1L) {
[11:01:55.217]                     if (is.function(sendCondition)) 
[11:01:55.217]                       return(sendCondition)
[11:01:55.217]                     ns <- getNamespace("parallel")
[11:01:55.217]                     if (exists("sendData", mode = "function", 
[11:01:55.217]                       envir = ns)) {
[11:01:55.217]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.217]                         envir = ns)
[11:01:55.217]                       envir <- sys.frame(frame)
[11:01:55.217]                       master <- NULL
[11:01:55.217]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.217]                         !identical(envir, emptyenv())) {
[11:01:55.217]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.217]                           inherits = FALSE)) {
[11:01:55.217]                           master <- get("master", mode = "list", 
[11:01:55.217]                             envir = envir, inherits = FALSE)
[11:01:55.217]                           if (inherits(master, c("SOCKnode", 
[11:01:55.217]                             "SOCK0node"))) {
[11:01:55.217]                             sendCondition <<- function(cond) {
[11:01:55.217]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.217]                                 success = TRUE)
[11:01:55.217]                               parallel_sendData(master, data)
[11:01:55.217]                             }
[11:01:55.217]                             return(sendCondition)
[11:01:55.217]                           }
[11:01:55.217]                         }
[11:01:55.217]                         frame <- frame + 1L
[11:01:55.217]                         envir <- sys.frame(frame)
[11:01:55.217]                       }
[11:01:55.217]                     }
[11:01:55.217]                     sendCondition <<- function(cond) NULL
[11:01:55.217]                   }
[11:01:55.217]                 })
[11:01:55.217]                 withCallingHandlers({
[11:01:55.217]                   1
[11:01:55.217]                 }, immediateCondition = function(cond) {
[11:01:55.217]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.217]                   sendCondition(cond)
[11:01:55.217]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.217]                   {
[11:01:55.217]                     inherits <- base::inherits
[11:01:55.217]                     invokeRestart <- base::invokeRestart
[11:01:55.217]                     is.null <- base::is.null
[11:01:55.217]                     muffled <- FALSE
[11:01:55.217]                     if (inherits(cond, "message")) {
[11:01:55.217]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.217]                       if (muffled) 
[11:01:55.217]                         invokeRestart("muffleMessage")
[11:01:55.217]                     }
[11:01:55.217]                     else if (inherits(cond, "warning")) {
[11:01:55.217]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.217]                       if (muffled) 
[11:01:55.217]                         invokeRestart("muffleWarning")
[11:01:55.217]                     }
[11:01:55.217]                     else if (inherits(cond, "condition")) {
[11:01:55.217]                       if (!is.null(pattern)) {
[11:01:55.217]                         computeRestarts <- base::computeRestarts
[11:01:55.217]                         grepl <- base::grepl
[11:01:55.217]                         restarts <- computeRestarts(cond)
[11:01:55.217]                         for (restart in restarts) {
[11:01:55.217]                           name <- restart$name
[11:01:55.217]                           if (is.null(name)) 
[11:01:55.217]                             next
[11:01:55.217]                           if (!grepl(pattern, name)) 
[11:01:55.217]                             next
[11:01:55.217]                           invokeRestart(restart)
[11:01:55.217]                           muffled <- TRUE
[11:01:55.217]                           break
[11:01:55.217]                         }
[11:01:55.217]                       }
[11:01:55.217]                     }
[11:01:55.217]                     invisible(muffled)
[11:01:55.217]                   }
[11:01:55.217]                   muffleCondition(cond)
[11:01:55.217]                 })
[11:01:55.217]             }))
[11:01:55.217]             future::FutureResult(value = ...future.value$value, 
[11:01:55.217]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.217]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.217]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.217]                     ...future.globalenv.names))
[11:01:55.217]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.217]         }, condition = base::local({
[11:01:55.217]             c <- base::c
[11:01:55.217]             inherits <- base::inherits
[11:01:55.217]             invokeRestart <- base::invokeRestart
[11:01:55.217]             length <- base::length
[11:01:55.217]             list <- base::list
[11:01:55.217]             seq.int <- base::seq.int
[11:01:55.217]             signalCondition <- base::signalCondition
[11:01:55.217]             sys.calls <- base::sys.calls
[11:01:55.217]             `[[` <- base::`[[`
[11:01:55.217]             `+` <- base::`+`
[11:01:55.217]             `<<-` <- base::`<<-`
[11:01:55.217]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.217]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.217]                   3L)]
[11:01:55.217]             }
[11:01:55.217]             function(cond) {
[11:01:55.217]                 is_error <- inherits(cond, "error")
[11:01:55.217]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.217]                   NULL)
[11:01:55.217]                 if (is_error) {
[11:01:55.217]                   sessionInformation <- function() {
[11:01:55.217]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.217]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.217]                       search = base::search(), system = base::Sys.info())
[11:01:55.217]                   }
[11:01:55.217]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.217]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.217]                     cond$call), session = sessionInformation(), 
[11:01:55.217]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.217]                   signalCondition(cond)
[11:01:55.217]                 }
[11:01:55.217]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.217]                 "immediateCondition"))) {
[11:01:55.217]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.217]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.217]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.217]                   if (TRUE && !signal) {
[11:01:55.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.217]                     {
[11:01:55.217]                       inherits <- base::inherits
[11:01:55.217]                       invokeRestart <- base::invokeRestart
[11:01:55.217]                       is.null <- base::is.null
[11:01:55.217]                       muffled <- FALSE
[11:01:55.217]                       if (inherits(cond, "message")) {
[11:01:55.217]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.217]                         if (muffled) 
[11:01:55.217]                           invokeRestart("muffleMessage")
[11:01:55.217]                       }
[11:01:55.217]                       else if (inherits(cond, "warning")) {
[11:01:55.217]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.217]                         if (muffled) 
[11:01:55.217]                           invokeRestart("muffleWarning")
[11:01:55.217]                       }
[11:01:55.217]                       else if (inherits(cond, "condition")) {
[11:01:55.217]                         if (!is.null(pattern)) {
[11:01:55.217]                           computeRestarts <- base::computeRestarts
[11:01:55.217]                           grepl <- base::grepl
[11:01:55.217]                           restarts <- computeRestarts(cond)
[11:01:55.217]                           for (restart in restarts) {
[11:01:55.217]                             name <- restart$name
[11:01:55.217]                             if (is.null(name)) 
[11:01:55.217]                               next
[11:01:55.217]                             if (!grepl(pattern, name)) 
[11:01:55.217]                               next
[11:01:55.217]                             invokeRestart(restart)
[11:01:55.217]                             muffled <- TRUE
[11:01:55.217]                             break
[11:01:55.217]                           }
[11:01:55.217]                         }
[11:01:55.217]                       }
[11:01:55.217]                       invisible(muffled)
[11:01:55.217]                     }
[11:01:55.217]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.217]                   }
[11:01:55.217]                 }
[11:01:55.217]                 else {
[11:01:55.217]                   if (TRUE) {
[11:01:55.217]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.217]                     {
[11:01:55.217]                       inherits <- base::inherits
[11:01:55.217]                       invokeRestart <- base::invokeRestart
[11:01:55.217]                       is.null <- base::is.null
[11:01:55.217]                       muffled <- FALSE
[11:01:55.217]                       if (inherits(cond, "message")) {
[11:01:55.217]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.217]                         if (muffled) 
[11:01:55.217]                           invokeRestart("muffleMessage")
[11:01:55.217]                       }
[11:01:55.217]                       else if (inherits(cond, "warning")) {
[11:01:55.217]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.217]                         if (muffled) 
[11:01:55.217]                           invokeRestart("muffleWarning")
[11:01:55.217]                       }
[11:01:55.217]                       else if (inherits(cond, "condition")) {
[11:01:55.217]                         if (!is.null(pattern)) {
[11:01:55.217]                           computeRestarts <- base::computeRestarts
[11:01:55.217]                           grepl <- base::grepl
[11:01:55.217]                           restarts <- computeRestarts(cond)
[11:01:55.217]                           for (restart in restarts) {
[11:01:55.217]                             name <- restart$name
[11:01:55.217]                             if (is.null(name)) 
[11:01:55.217]                               next
[11:01:55.217]                             if (!grepl(pattern, name)) 
[11:01:55.217]                               next
[11:01:55.217]                             invokeRestart(restart)
[11:01:55.217]                             muffled <- TRUE
[11:01:55.217]                             break
[11:01:55.217]                           }
[11:01:55.217]                         }
[11:01:55.217]                       }
[11:01:55.217]                       invisible(muffled)
[11:01:55.217]                     }
[11:01:55.217]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.217]                   }
[11:01:55.217]                 }
[11:01:55.217]             }
[11:01:55.217]         }))
[11:01:55.217]     }, error = function(ex) {
[11:01:55.217]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.217]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.217]                 ...future.rng), started = ...future.startTime, 
[11:01:55.217]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.217]             version = "1.8"), class = "FutureResult")
[11:01:55.217]     }, finally = {
[11:01:55.217]         if (!identical(...future.workdir, getwd())) 
[11:01:55.217]             setwd(...future.workdir)
[11:01:55.217]         {
[11:01:55.217]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.217]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.217]             }
[11:01:55.217]             base::options(...future.oldOptions)
[11:01:55.217]             if (.Platform$OS.type == "windows") {
[11:01:55.217]                 old_names <- names(...future.oldEnvVars)
[11:01:55.217]                 envs <- base::Sys.getenv()
[11:01:55.217]                 names <- names(envs)
[11:01:55.217]                 common <- intersect(names, old_names)
[11:01:55.217]                 added <- setdiff(names, old_names)
[11:01:55.217]                 removed <- setdiff(old_names, names)
[11:01:55.217]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.217]                   envs[common]]
[11:01:55.217]                 NAMES <- toupper(changed)
[11:01:55.217]                 args <- list()
[11:01:55.217]                 for (kk in seq_along(NAMES)) {
[11:01:55.217]                   name <- changed[[kk]]
[11:01:55.217]                   NAME <- NAMES[[kk]]
[11:01:55.217]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.217]                     next
[11:01:55.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.217]                 }
[11:01:55.217]                 NAMES <- toupper(added)
[11:01:55.217]                 for (kk in seq_along(NAMES)) {
[11:01:55.217]                   name <- added[[kk]]
[11:01:55.217]                   NAME <- NAMES[[kk]]
[11:01:55.217]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.217]                     next
[11:01:55.217]                   args[[name]] <- ""
[11:01:55.217]                 }
[11:01:55.217]                 NAMES <- toupper(removed)
[11:01:55.217]                 for (kk in seq_along(NAMES)) {
[11:01:55.217]                   name <- removed[[kk]]
[11:01:55.217]                   NAME <- NAMES[[kk]]
[11:01:55.217]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.217]                     next
[11:01:55.217]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.217]                 }
[11:01:55.217]                 if (length(args) > 0) 
[11:01:55.217]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.217]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.217]             }
[11:01:55.217]             else {
[11:01:55.217]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.217]             }
[11:01:55.217]             {
[11:01:55.217]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.217]                   0L) {
[11:01:55.217]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.217]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.217]                   base::options(opts)
[11:01:55.217]                 }
[11:01:55.217]                 {
[11:01:55.217]                   {
[11:01:55.217]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.217]                     NULL
[11:01:55.217]                   }
[11:01:55.217]                   options(future.plan = NULL)
[11:01:55.217]                   if (is.na(NA_character_)) 
[11:01:55.217]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.217]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.217]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.217]                     .init = FALSE)
[11:01:55.217]                 }
[11:01:55.217]             }
[11:01:55.217]         }
[11:01:55.217]     })
[11:01:55.217]     if (TRUE) {
[11:01:55.217]         base::sink(type = "output", split = FALSE)
[11:01:55.217]         if (TRUE) {
[11:01:55.217]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.217]         }
[11:01:55.217]         else {
[11:01:55.217]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.217]         }
[11:01:55.217]         base::close(...future.stdout)
[11:01:55.217]         ...future.stdout <- NULL
[11:01:55.217]     }
[11:01:55.217]     ...future.result$conditions <- ...future.conditions
[11:01:55.217]     ...future.result$finished <- base::Sys.time()
[11:01:55.217]     ...future.result
[11:01:55.217] }
[11:01:55.220] MultisessionFuture started
[11:01:55.220] - Launch lazy future ... done
[11:01:55.220] run() for ‘MultisessionFuture’ ... done
[11:01:55.262] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.262] - Validating connection of MultisessionFuture
[11:01:55.262] - received message: FutureResult
[11:01:55.262] - Received FutureResult
[11:01:55.263] - Erased future from FutureRegistry
[11:01:55.263] result() for ClusterFuture ...
[11:01:55.263] - result already collected: FutureResult
[11:01:55.263] result() for ClusterFuture ... done
[11:01:55.263] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.263] Future #1
[11:01:55.263] result() for ClusterFuture ...
[11:01:55.263] - result already collected: FutureResult
[11:01:55.263] result() for ClusterFuture ... done
[11:01:55.263] result() for ClusterFuture ...
[11:01:55.263] - result already collected: FutureResult
[11:01:55.264] result() for ClusterFuture ... done
[11:01:55.264] A MultisessionFuture was resolved
[11:01:55.264]  length: 0 (resolved future 1)
[11:01:55.264] resolve() on list ... DONE
[11:01:55.264] - globals: [1] ‘a’
[11:01:55.264] Resolving futures part of globals (recursively) ... DONE
[11:01:55.275] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[11:01:55.275] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[11:01:55.275] - globals: [1] ‘a’
[11:01:55.276] - packages: [1] ‘future’
[11:01:55.276] getGlobalsAndPackages() ... DONE
[11:01:55.276] run() for ‘Future’ ...
[11:01:55.276] - state: ‘created’
[11:01:55.276] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.290] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.290] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.290]   - Field: ‘node’
[11:01:55.290]   - Field: ‘label’
[11:01:55.291]   - Field: ‘local’
[11:01:55.291]   - Field: ‘owner’
[11:01:55.291]   - Field: ‘envir’
[11:01:55.291]   - Field: ‘workers’
[11:01:55.291]   - Field: ‘packages’
[11:01:55.291]   - Field: ‘gc’
[11:01:55.291]   - Field: ‘conditions’
[11:01:55.291]   - Field: ‘persistent’
[11:01:55.291]   - Field: ‘expr’
[11:01:55.291]   - Field: ‘uuid’
[11:01:55.291]   - Field: ‘seed’
[11:01:55.291]   - Field: ‘version’
[11:01:55.292]   - Field: ‘result’
[11:01:55.292]   - Field: ‘asynchronous’
[11:01:55.292]   - Field: ‘calls’
[11:01:55.292]   - Field: ‘globals’
[11:01:55.292]   - Field: ‘stdout’
[11:01:55.292]   - Field: ‘earlySignal’
[11:01:55.292]   - Field: ‘lazy’
[11:01:55.292]   - Field: ‘state’
[11:01:55.292] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.292] - Launch lazy future ...
[11:01:55.293] Packages needed by the future expression (n = 1): ‘future’
[11:01:55.293] Packages needed by future strategies (n = 0): <none>
[11:01:55.293] {
[11:01:55.293]     {
[11:01:55.293]         {
[11:01:55.293]             ...future.startTime <- base::Sys.time()
[11:01:55.293]             {
[11:01:55.293]                 {
[11:01:55.293]                   {
[11:01:55.293]                     {
[11:01:55.293]                       {
[11:01:55.293]                         base::local({
[11:01:55.293]                           has_future <- base::requireNamespace("future", 
[11:01:55.293]                             quietly = TRUE)
[11:01:55.293]                           if (has_future) {
[11:01:55.293]                             ns <- base::getNamespace("future")
[11:01:55.293]                             version <- ns[[".package"]][["version"]]
[11:01:55.293]                             if (is.null(version)) 
[11:01:55.293]                               version <- utils::packageVersion("future")
[11:01:55.293]                           }
[11:01:55.293]                           else {
[11:01:55.293]                             version <- NULL
[11:01:55.293]                           }
[11:01:55.293]                           if (!has_future || version < "1.8.0") {
[11:01:55.293]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.293]                               "", base::R.version$version.string), 
[11:01:55.293]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:55.293]                                 base::R.version$platform, 8 * 
[11:01:55.293]                                   base::.Machine$sizeof.pointer), 
[11:01:55.293]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.293]                                 "release", "version")], collapse = " "), 
[11:01:55.293]                               hostname = base::Sys.info()[["nodename"]])
[11:01:55.293]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.293]                               info)
[11:01:55.293]                             info <- base::paste(info, collapse = "; ")
[11:01:55.293]                             if (!has_future) {
[11:01:55.293]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.293]                                 info)
[11:01:55.293]                             }
[11:01:55.293]                             else {
[11:01:55.293]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.293]                                 info, version)
[11:01:55.293]                             }
[11:01:55.293]                             base::stop(msg)
[11:01:55.293]                           }
[11:01:55.293]                         })
[11:01:55.293]                       }
[11:01:55.293]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.293]                       base::options(mc.cores = 1L)
[11:01:55.293]                     }
[11:01:55.293]                     base::local({
[11:01:55.293]                       for (pkg in "future") {
[11:01:55.293]                         base::loadNamespace(pkg)
[11:01:55.293]                         base::library(pkg, character.only = TRUE)
[11:01:55.293]                       }
[11:01:55.293]                     })
[11:01:55.293]                   }
[11:01:55.293]                   ...future.strategy.old <- future::plan("list")
[11:01:55.293]                   options(future.plan = NULL)
[11:01:55.293]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.293]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.293]                 }
[11:01:55.293]                 ...future.workdir <- getwd()
[11:01:55.293]             }
[11:01:55.293]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.293]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.293]         }
[11:01:55.293]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.293]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:55.293]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.293]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.293]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.293]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.293]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.293]             base::names(...future.oldOptions))
[11:01:55.293]     }
[11:01:55.293]     if (FALSE) {
[11:01:55.293]     }
[11:01:55.293]     else {
[11:01:55.293]         if (TRUE) {
[11:01:55.293]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.293]                 open = "w")
[11:01:55.293]         }
[11:01:55.293]         else {
[11:01:55.293]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.293]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.293]         }
[11:01:55.293]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.293]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.293]             base::sink(type = "output", split = FALSE)
[11:01:55.293]             base::close(...future.stdout)
[11:01:55.293]         }, add = TRUE)
[11:01:55.293]     }
[11:01:55.293]     ...future.frame <- base::sys.nframe()
[11:01:55.293]     ...future.conditions <- base::list()
[11:01:55.293]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.293]     if (FALSE) {
[11:01:55.293]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.293]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.293]     }
[11:01:55.293]     ...future.result <- base::tryCatch({
[11:01:55.293]         base::withCallingHandlers({
[11:01:55.293]             ...future.value <- base::withVisible(base::local({
[11:01:55.293]                 ...future.makeSendCondition <- base::local({
[11:01:55.293]                   sendCondition <- NULL
[11:01:55.293]                   function(frame = 1L) {
[11:01:55.293]                     if (is.function(sendCondition)) 
[11:01:55.293]                       return(sendCondition)
[11:01:55.293]                     ns <- getNamespace("parallel")
[11:01:55.293]                     if (exists("sendData", mode = "function", 
[11:01:55.293]                       envir = ns)) {
[11:01:55.293]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.293]                         envir = ns)
[11:01:55.293]                       envir <- sys.frame(frame)
[11:01:55.293]                       master <- NULL
[11:01:55.293]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.293]                         !identical(envir, emptyenv())) {
[11:01:55.293]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.293]                           inherits = FALSE)) {
[11:01:55.293]                           master <- get("master", mode = "list", 
[11:01:55.293]                             envir = envir, inherits = FALSE)
[11:01:55.293]                           if (inherits(master, c("SOCKnode", 
[11:01:55.293]                             "SOCK0node"))) {
[11:01:55.293]                             sendCondition <<- function(cond) {
[11:01:55.293]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.293]                                 success = TRUE)
[11:01:55.293]                               parallel_sendData(master, data)
[11:01:55.293]                             }
[11:01:55.293]                             return(sendCondition)
[11:01:55.293]                           }
[11:01:55.293]                         }
[11:01:55.293]                         frame <- frame + 1L
[11:01:55.293]                         envir <- sys.frame(frame)
[11:01:55.293]                       }
[11:01:55.293]                     }
[11:01:55.293]                     sendCondition <<- function(cond) NULL
[11:01:55.293]                   }
[11:01:55.293]                 })
[11:01:55.293]                 withCallingHandlers({
[11:01:55.293]                   value(a) + 1
[11:01:55.293]                 }, immediateCondition = function(cond) {
[11:01:55.293]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.293]                   sendCondition(cond)
[11:01:55.293]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.293]                   {
[11:01:55.293]                     inherits <- base::inherits
[11:01:55.293]                     invokeRestart <- base::invokeRestart
[11:01:55.293]                     is.null <- base::is.null
[11:01:55.293]                     muffled <- FALSE
[11:01:55.293]                     if (inherits(cond, "message")) {
[11:01:55.293]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.293]                       if (muffled) 
[11:01:55.293]                         invokeRestart("muffleMessage")
[11:01:55.293]                     }
[11:01:55.293]                     else if (inherits(cond, "warning")) {
[11:01:55.293]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.293]                       if (muffled) 
[11:01:55.293]                         invokeRestart("muffleWarning")
[11:01:55.293]                     }
[11:01:55.293]                     else if (inherits(cond, "condition")) {
[11:01:55.293]                       if (!is.null(pattern)) {
[11:01:55.293]                         computeRestarts <- base::computeRestarts
[11:01:55.293]                         grepl <- base::grepl
[11:01:55.293]                         restarts <- computeRestarts(cond)
[11:01:55.293]                         for (restart in restarts) {
[11:01:55.293]                           name <- restart$name
[11:01:55.293]                           if (is.null(name)) 
[11:01:55.293]                             next
[11:01:55.293]                           if (!grepl(pattern, name)) 
[11:01:55.293]                             next
[11:01:55.293]                           invokeRestart(restart)
[11:01:55.293]                           muffled <- TRUE
[11:01:55.293]                           break
[11:01:55.293]                         }
[11:01:55.293]                       }
[11:01:55.293]                     }
[11:01:55.293]                     invisible(muffled)
[11:01:55.293]                   }
[11:01:55.293]                   muffleCondition(cond)
[11:01:55.293]                 })
[11:01:55.293]             }))
[11:01:55.293]             future::FutureResult(value = ...future.value$value, 
[11:01:55.293]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.293]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.293]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.293]                     ...future.globalenv.names))
[11:01:55.293]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.293]         }, condition = base::local({
[11:01:55.293]             c <- base::c
[11:01:55.293]             inherits <- base::inherits
[11:01:55.293]             invokeRestart <- base::invokeRestart
[11:01:55.293]             length <- base::length
[11:01:55.293]             list <- base::list
[11:01:55.293]             seq.int <- base::seq.int
[11:01:55.293]             signalCondition <- base::signalCondition
[11:01:55.293]             sys.calls <- base::sys.calls
[11:01:55.293]             `[[` <- base::`[[`
[11:01:55.293]             `+` <- base::`+`
[11:01:55.293]             `<<-` <- base::`<<-`
[11:01:55.293]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.293]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.293]                   3L)]
[11:01:55.293]             }
[11:01:55.293]             function(cond) {
[11:01:55.293]                 is_error <- inherits(cond, "error")
[11:01:55.293]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.293]                   NULL)
[11:01:55.293]                 if (is_error) {
[11:01:55.293]                   sessionInformation <- function() {
[11:01:55.293]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.293]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.293]                       search = base::search(), system = base::Sys.info())
[11:01:55.293]                   }
[11:01:55.293]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.293]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.293]                     cond$call), session = sessionInformation(), 
[11:01:55.293]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.293]                   signalCondition(cond)
[11:01:55.293]                 }
[11:01:55.293]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.293]                 "immediateCondition"))) {
[11:01:55.293]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.293]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.293]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.293]                   if (TRUE && !signal) {
[11:01:55.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.293]                     {
[11:01:55.293]                       inherits <- base::inherits
[11:01:55.293]                       invokeRestart <- base::invokeRestart
[11:01:55.293]                       is.null <- base::is.null
[11:01:55.293]                       muffled <- FALSE
[11:01:55.293]                       if (inherits(cond, "message")) {
[11:01:55.293]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.293]                         if (muffled) 
[11:01:55.293]                           invokeRestart("muffleMessage")
[11:01:55.293]                       }
[11:01:55.293]                       else if (inherits(cond, "warning")) {
[11:01:55.293]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.293]                         if (muffled) 
[11:01:55.293]                           invokeRestart("muffleWarning")
[11:01:55.293]                       }
[11:01:55.293]                       else if (inherits(cond, "condition")) {
[11:01:55.293]                         if (!is.null(pattern)) {
[11:01:55.293]                           computeRestarts <- base::computeRestarts
[11:01:55.293]                           grepl <- base::grepl
[11:01:55.293]                           restarts <- computeRestarts(cond)
[11:01:55.293]                           for (restart in restarts) {
[11:01:55.293]                             name <- restart$name
[11:01:55.293]                             if (is.null(name)) 
[11:01:55.293]                               next
[11:01:55.293]                             if (!grepl(pattern, name)) 
[11:01:55.293]                               next
[11:01:55.293]                             invokeRestart(restart)
[11:01:55.293]                             muffled <- TRUE
[11:01:55.293]                             break
[11:01:55.293]                           }
[11:01:55.293]                         }
[11:01:55.293]                       }
[11:01:55.293]                       invisible(muffled)
[11:01:55.293]                     }
[11:01:55.293]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.293]                   }
[11:01:55.293]                 }
[11:01:55.293]                 else {
[11:01:55.293]                   if (TRUE) {
[11:01:55.293]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.293]                     {
[11:01:55.293]                       inherits <- base::inherits
[11:01:55.293]                       invokeRestart <- base::invokeRestart
[11:01:55.293]                       is.null <- base::is.null
[11:01:55.293]                       muffled <- FALSE
[11:01:55.293]                       if (inherits(cond, "message")) {
[11:01:55.293]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.293]                         if (muffled) 
[11:01:55.293]                           invokeRestart("muffleMessage")
[11:01:55.293]                       }
[11:01:55.293]                       else if (inherits(cond, "warning")) {
[11:01:55.293]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.293]                         if (muffled) 
[11:01:55.293]                           invokeRestart("muffleWarning")
[11:01:55.293]                       }
[11:01:55.293]                       else if (inherits(cond, "condition")) {
[11:01:55.293]                         if (!is.null(pattern)) {
[11:01:55.293]                           computeRestarts <- base::computeRestarts
[11:01:55.293]                           grepl <- base::grepl
[11:01:55.293]                           restarts <- computeRestarts(cond)
[11:01:55.293]                           for (restart in restarts) {
[11:01:55.293]                             name <- restart$name
[11:01:55.293]                             if (is.null(name)) 
[11:01:55.293]                               next
[11:01:55.293]                             if (!grepl(pattern, name)) 
[11:01:55.293]                               next
[11:01:55.293]                             invokeRestart(restart)
[11:01:55.293]                             muffled <- TRUE
[11:01:55.293]                             break
[11:01:55.293]                           }
[11:01:55.293]                         }
[11:01:55.293]                       }
[11:01:55.293]                       invisible(muffled)
[11:01:55.293]                     }
[11:01:55.293]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.293]                   }
[11:01:55.293]                 }
[11:01:55.293]             }
[11:01:55.293]         }))
[11:01:55.293]     }, error = function(ex) {
[11:01:55.293]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.293]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.293]                 ...future.rng), started = ...future.startTime, 
[11:01:55.293]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.293]             version = "1.8"), class = "FutureResult")
[11:01:55.293]     }, finally = {
[11:01:55.293]         if (!identical(...future.workdir, getwd())) 
[11:01:55.293]             setwd(...future.workdir)
[11:01:55.293]         {
[11:01:55.293]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.293]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.293]             }
[11:01:55.293]             base::options(...future.oldOptions)
[11:01:55.293]             if (.Platform$OS.type == "windows") {
[11:01:55.293]                 old_names <- names(...future.oldEnvVars)
[11:01:55.293]                 envs <- base::Sys.getenv()
[11:01:55.293]                 names <- names(envs)
[11:01:55.293]                 common <- intersect(names, old_names)
[11:01:55.293]                 added <- setdiff(names, old_names)
[11:01:55.293]                 removed <- setdiff(old_names, names)
[11:01:55.293]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.293]                   envs[common]]
[11:01:55.293]                 NAMES <- toupper(changed)
[11:01:55.293]                 args <- list()
[11:01:55.293]                 for (kk in seq_along(NAMES)) {
[11:01:55.293]                   name <- changed[[kk]]
[11:01:55.293]                   NAME <- NAMES[[kk]]
[11:01:55.293]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.293]                     next
[11:01:55.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.293]                 }
[11:01:55.293]                 NAMES <- toupper(added)
[11:01:55.293]                 for (kk in seq_along(NAMES)) {
[11:01:55.293]                   name <- added[[kk]]
[11:01:55.293]                   NAME <- NAMES[[kk]]
[11:01:55.293]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.293]                     next
[11:01:55.293]                   args[[name]] <- ""
[11:01:55.293]                 }
[11:01:55.293]                 NAMES <- toupper(removed)
[11:01:55.293]                 for (kk in seq_along(NAMES)) {
[11:01:55.293]                   name <- removed[[kk]]
[11:01:55.293]                   NAME <- NAMES[[kk]]
[11:01:55.293]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.293]                     next
[11:01:55.293]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.293]                 }
[11:01:55.293]                 if (length(args) > 0) 
[11:01:55.293]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.293]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.293]             }
[11:01:55.293]             else {
[11:01:55.293]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.293]             }
[11:01:55.293]             {
[11:01:55.293]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.293]                   0L) {
[11:01:55.293]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.293]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.293]                   base::options(opts)
[11:01:55.293]                 }
[11:01:55.293]                 {
[11:01:55.293]                   {
[11:01:55.293]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.293]                     NULL
[11:01:55.293]                   }
[11:01:55.293]                   options(future.plan = NULL)
[11:01:55.293]                   if (is.na(NA_character_)) 
[11:01:55.293]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.293]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.293]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.293]                     .init = FALSE)
[11:01:55.293]                 }
[11:01:55.293]             }
[11:01:55.293]         }
[11:01:55.293]     })
[11:01:55.293]     if (TRUE) {
[11:01:55.293]         base::sink(type = "output", split = FALSE)
[11:01:55.293]         if (TRUE) {
[11:01:55.293]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.293]         }
[11:01:55.293]         else {
[11:01:55.293]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.293]         }
[11:01:55.293]         base::close(...future.stdout)
[11:01:55.293]         ...future.stdout <- NULL
[11:01:55.293]     }
[11:01:55.293]     ...future.result$conditions <- ...future.conditions
[11:01:55.293]     ...future.result$finished <- base::Sys.time()
[11:01:55.293]     ...future.result
[11:01:55.293] }
[11:01:55.306] Exporting 1 global objects (313.46 KiB) to cluster node #2 ...
[11:01:55.317] Exporting ‘a’ (313.25 KiB) to cluster node #2 ...
[11:01:55.370] Exporting ‘a’ (313.25 KiB) to cluster node #2 ... DONE
[11:01:55.370] Exporting 1 global objects (313.46 KiB) to cluster node #2 ... DONE
[11:01:55.371] MultisessionFuture started
[11:01:55.371] - Launch lazy future ... done
[11:01:55.371] run() for ‘MultisessionFuture’ ... done
[11:01:55.371] result() for ClusterFuture ...
[11:01:55.371] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.371] - Validating connection of MultisessionFuture
[11:01:55.412] - received message: FutureResult
[11:01:55.412] - Received FutureResult
[11:01:55.412] - Erased future from FutureRegistry
[11:01:55.413] result() for ClusterFuture ...
[11:01:55.413] - result already collected: FutureResult
[11:01:55.413] result() for ClusterFuture ... done
[11:01:55.413] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.413] result() for ClusterFuture ... done
[11:01:55.413] result() for ClusterFuture ...
[11:01:55.413] - result already collected: FutureResult
[11:01:55.413] result() for ClusterFuture ... done
value(b) = 2
[11:01:55.413] result() for ClusterFuture ...
[11:01:55.414] - result already collected: FutureResult
[11:01:55.414] result() for ClusterFuture ... done
[11:01:55.414] result() for ClusterFuture ...
[11:01:55.414] - result already collected: FutureResult
[11:01:55.414] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.414] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.414] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘conservative’
[11:01:55.415] - globals found: [2] ‘{’, ‘pkg’
[11:01:55.415] Searching for globals ... DONE
[11:01:55.415] Resolving globals: TRUE
[11:01:55.415] Resolving any globals that are futures ...
[11:01:55.416] - globals: [2] ‘{’, ‘pkg’
[11:01:55.416] Resolving any globals that are futures ... DONE
[11:01:55.416] Resolving futures part of globals (recursively) ...
[11:01:55.416] resolve() on list ...
[11:01:55.416]  recursive: 99
[11:01:55.416]  length: 1
[11:01:55.416]  elements: ‘pkg’
[11:01:55.419]  length: 0 (resolved future 1)
[11:01:55.419] resolve() on list ... DONE
[11:01:55.419] - globals: [1] ‘pkg’
[11:01:55.419] Resolving futures part of globals (recursively) ... DONE
[11:01:55.419] The total size of the 1 globals is 42 bytes (42 bytes)
[11:01:55.419] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[11:01:55.419] - globals: [1] ‘pkg’
[11:01:55.420] 
[11:01:55.420] getGlobalsAndPackages() ... DONE
[11:01:55.420] Packages needed by the future expression (n = 0): <none>
[11:01:55.420] Packages needed by future strategies (n = 0): <none>
[11:01:55.420] {
[11:01:55.420]     {
[11:01:55.420]         {
[11:01:55.420]             ...future.startTime <- base::Sys.time()
[11:01:55.420]             {
[11:01:55.420]                 {
[11:01:55.420]                   {
[11:01:55.420]                     base::local({
[11:01:55.420]                       has_future <- base::requireNamespace("future", 
[11:01:55.420]                         quietly = TRUE)
[11:01:55.420]                       if (has_future) {
[11:01:55.420]                         ns <- base::getNamespace("future")
[11:01:55.420]                         version <- ns[[".package"]][["version"]]
[11:01:55.420]                         if (is.null(version)) 
[11:01:55.420]                           version <- utils::packageVersion("future")
[11:01:55.420]                       }
[11:01:55.420]                       else {
[11:01:55.420]                         version <- NULL
[11:01:55.420]                       }
[11:01:55.420]                       if (!has_future || version < "1.8.0") {
[11:01:55.420]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.420]                           "", base::R.version$version.string), 
[11:01:55.420]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:55.420]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.420]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.420]                             "release", "version")], collapse = " "), 
[11:01:55.420]                           hostname = base::Sys.info()[["nodename"]])
[11:01:55.420]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.420]                           info)
[11:01:55.420]                         info <- base::paste(info, collapse = "; ")
[11:01:55.420]                         if (!has_future) {
[11:01:55.420]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.420]                             info)
[11:01:55.420]                         }
[11:01:55.420]                         else {
[11:01:55.420]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.420]                             info, version)
[11:01:55.420]                         }
[11:01:55.420]                         base::stop(msg)
[11:01:55.420]                       }
[11:01:55.420]                     })
[11:01:55.420]                   }
[11:01:55.420]                   ...future.strategy.old <- future::plan("list")
[11:01:55.420]                   options(future.plan = NULL)
[11:01:55.420]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.420]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.420]                 }
[11:01:55.420]                 ...future.workdir <- getwd()
[11:01:55.420]             }
[11:01:55.420]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.420]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.420]         }
[11:01:55.420]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.420]             future.globals.maxSize = NULL, future.globals.method = "conservative", 
[11:01:55.420]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.420]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.420]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.420]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.420]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.420]             base::names(...future.oldOptions))
[11:01:55.420]     }
[11:01:55.420]     if (FALSE) {
[11:01:55.420]     }
[11:01:55.420]     else {
[11:01:55.420]         if (TRUE) {
[11:01:55.420]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.420]                 open = "w")
[11:01:55.420]         }
[11:01:55.420]         else {
[11:01:55.420]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.420]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.420]         }
[11:01:55.420]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.420]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.420]             base::sink(type = "output", split = FALSE)
[11:01:55.420]             base::close(...future.stdout)
[11:01:55.420]         }, add = TRUE)
[11:01:55.420]     }
[11:01:55.420]     ...future.frame <- base::sys.nframe()
[11:01:55.420]     ...future.conditions <- base::list()
[11:01:55.420]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.420]     if (FALSE) {
[11:01:55.420]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.420]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.420]     }
[11:01:55.420]     ...future.result <- base::tryCatch({
[11:01:55.420]         base::withCallingHandlers({
[11:01:55.420]             ...future.value <- base::withVisible(base::local({
[11:01:55.420]                 pkg
[11:01:55.420]             }))
[11:01:55.420]             future::FutureResult(value = ...future.value$value, 
[11:01:55.420]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.420]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.420]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.420]                     ...future.globalenv.names))
[11:01:55.420]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.420]         }, condition = base::local({
[11:01:55.420]             c <- base::c
[11:01:55.420]             inherits <- base::inherits
[11:01:55.420]             invokeRestart <- base::invokeRestart
[11:01:55.420]             length <- base::length
[11:01:55.420]             list <- base::list
[11:01:55.420]             seq.int <- base::seq.int
[11:01:55.420]             signalCondition <- base::signalCondition
[11:01:55.420]             sys.calls <- base::sys.calls
[11:01:55.420]             `[[` <- base::`[[`
[11:01:55.420]             `+` <- base::`+`
[11:01:55.420]             `<<-` <- base::`<<-`
[11:01:55.420]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.420]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.420]                   3L)]
[11:01:55.420]             }
[11:01:55.420]             function(cond) {
[11:01:55.420]                 is_error <- inherits(cond, "error")
[11:01:55.420]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.420]                   NULL)
[11:01:55.420]                 if (is_error) {
[11:01:55.420]                   sessionInformation <- function() {
[11:01:55.420]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.420]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.420]                       search = base::search(), system = base::Sys.info())
[11:01:55.420]                   }
[11:01:55.420]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.420]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.420]                     cond$call), session = sessionInformation(), 
[11:01:55.420]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.420]                   signalCondition(cond)
[11:01:55.420]                 }
[11:01:55.420]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.420]                 "immediateCondition"))) {
[11:01:55.420]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.420]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.420]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.420]                   if (TRUE && !signal) {
[11:01:55.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.420]                     {
[11:01:55.420]                       inherits <- base::inherits
[11:01:55.420]                       invokeRestart <- base::invokeRestart
[11:01:55.420]                       is.null <- base::is.null
[11:01:55.420]                       muffled <- FALSE
[11:01:55.420]                       if (inherits(cond, "message")) {
[11:01:55.420]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.420]                         if (muffled) 
[11:01:55.420]                           invokeRestart("muffleMessage")
[11:01:55.420]                       }
[11:01:55.420]                       else if (inherits(cond, "warning")) {
[11:01:55.420]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.420]                         if (muffled) 
[11:01:55.420]                           invokeRestart("muffleWarning")
[11:01:55.420]                       }
[11:01:55.420]                       else if (inherits(cond, "condition")) {
[11:01:55.420]                         if (!is.null(pattern)) {
[11:01:55.420]                           computeRestarts <- base::computeRestarts
[11:01:55.420]                           grepl <- base::grepl
[11:01:55.420]                           restarts <- computeRestarts(cond)
[11:01:55.420]                           for (restart in restarts) {
[11:01:55.420]                             name <- restart$name
[11:01:55.420]                             if (is.null(name)) 
[11:01:55.420]                               next
[11:01:55.420]                             if (!grepl(pattern, name)) 
[11:01:55.420]                               next
[11:01:55.420]                             invokeRestart(restart)
[11:01:55.420]                             muffled <- TRUE
[11:01:55.420]                             break
[11:01:55.420]                           }
[11:01:55.420]                         }
[11:01:55.420]                       }
[11:01:55.420]                       invisible(muffled)
[11:01:55.420]                     }
[11:01:55.420]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.420]                   }
[11:01:55.420]                 }
[11:01:55.420]                 else {
[11:01:55.420]                   if (TRUE) {
[11:01:55.420]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.420]                     {
[11:01:55.420]                       inherits <- base::inherits
[11:01:55.420]                       invokeRestart <- base::invokeRestart
[11:01:55.420]                       is.null <- base::is.null
[11:01:55.420]                       muffled <- FALSE
[11:01:55.420]                       if (inherits(cond, "message")) {
[11:01:55.420]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.420]                         if (muffled) 
[11:01:55.420]                           invokeRestart("muffleMessage")
[11:01:55.420]                       }
[11:01:55.420]                       else if (inherits(cond, "warning")) {
[11:01:55.420]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.420]                         if (muffled) 
[11:01:55.420]                           invokeRestart("muffleWarning")
[11:01:55.420]                       }
[11:01:55.420]                       else if (inherits(cond, "condition")) {
[11:01:55.420]                         if (!is.null(pattern)) {
[11:01:55.420]                           computeRestarts <- base::computeRestarts
[11:01:55.420]                           grepl <- base::grepl
[11:01:55.420]                           restarts <- computeRestarts(cond)
[11:01:55.420]                           for (restart in restarts) {
[11:01:55.420]                             name <- restart$name
[11:01:55.420]                             if (is.null(name)) 
[11:01:55.420]                               next
[11:01:55.420]                             if (!grepl(pattern, name)) 
[11:01:55.420]                               next
[11:01:55.420]                             invokeRestart(restart)
[11:01:55.420]                             muffled <- TRUE
[11:01:55.420]                             break
[11:01:55.420]                           }
[11:01:55.420]                         }
[11:01:55.420]                       }
[11:01:55.420]                       invisible(muffled)
[11:01:55.420]                     }
[11:01:55.420]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.420]                   }
[11:01:55.420]                 }
[11:01:55.420]             }
[11:01:55.420]         }))
[11:01:55.420]     }, error = function(ex) {
[11:01:55.420]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.420]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.420]                 ...future.rng), started = ...future.startTime, 
[11:01:55.420]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.420]             version = "1.8"), class = "FutureResult")
[11:01:55.420]     }, finally = {
[11:01:55.420]         if (!identical(...future.workdir, getwd())) 
[11:01:55.420]             setwd(...future.workdir)
[11:01:55.420]         {
[11:01:55.420]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.420]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.420]             }
[11:01:55.420]             base::options(...future.oldOptions)
[11:01:55.420]             if (.Platform$OS.type == "windows") {
[11:01:55.420]                 old_names <- names(...future.oldEnvVars)
[11:01:55.420]                 envs <- base::Sys.getenv()
[11:01:55.420]                 names <- names(envs)
[11:01:55.420]                 common <- intersect(names, old_names)
[11:01:55.420]                 added <- setdiff(names, old_names)
[11:01:55.420]                 removed <- setdiff(old_names, names)
[11:01:55.420]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.420]                   envs[common]]
[11:01:55.420]                 NAMES <- toupper(changed)
[11:01:55.420]                 args <- list()
[11:01:55.420]                 for (kk in seq_along(NAMES)) {
[11:01:55.420]                   name <- changed[[kk]]
[11:01:55.420]                   NAME <- NAMES[[kk]]
[11:01:55.420]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.420]                     next
[11:01:55.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.420]                 }
[11:01:55.420]                 NAMES <- toupper(added)
[11:01:55.420]                 for (kk in seq_along(NAMES)) {
[11:01:55.420]                   name <- added[[kk]]
[11:01:55.420]                   NAME <- NAMES[[kk]]
[11:01:55.420]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.420]                     next
[11:01:55.420]                   args[[name]] <- ""
[11:01:55.420]                 }
[11:01:55.420]                 NAMES <- toupper(removed)
[11:01:55.420]                 for (kk in seq_along(NAMES)) {
[11:01:55.420]                   name <- removed[[kk]]
[11:01:55.420]                   NAME <- NAMES[[kk]]
[11:01:55.420]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.420]                     next
[11:01:55.420]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.420]                 }
[11:01:55.420]                 if (length(args) > 0) 
[11:01:55.420]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.420]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.420]             }
[11:01:55.420]             else {
[11:01:55.420]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.420]             }
[11:01:55.420]             {
[11:01:55.420]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.420]                   0L) {
[11:01:55.420]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.420]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.420]                   base::options(opts)
[11:01:55.420]                 }
[11:01:55.420]                 {
[11:01:55.420]                   {
[11:01:55.420]                     NULL
[11:01:55.420]                     RNGkind("Mersenne-Twister")
[11:01:55.420]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:55.420]                       inherits = FALSE)
[11:01:55.420]                   }
[11:01:55.420]                   options(future.plan = NULL)
[11:01:55.420]                   if (is.na(NA_character_)) 
[11:01:55.420]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.420]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.420]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.420]                     .init = FALSE)
[11:01:55.420]                 }
[11:01:55.420]             }
[11:01:55.420]         }
[11:01:55.420]     })
[11:01:55.420]     if (TRUE) {
[11:01:55.420]         base::sink(type = "output", split = FALSE)
[11:01:55.420]         if (TRUE) {
[11:01:55.420]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.420]         }
[11:01:55.420]         else {
[11:01:55.420]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.420]         }
[11:01:55.420]         base::close(...future.stdout)
[11:01:55.420]         ...future.stdout <- NULL
[11:01:55.420]     }
[11:01:55.420]     ...future.result$conditions <- ...future.conditions
[11:01:55.420]     ...future.result$finished <- base::Sys.time()
[11:01:55.420]     ...future.result
[11:01:55.420] }
[11:01:55.422] assign_globals() ...
[11:01:55.422] List of 1
[11:01:55.422]  $ pkg: chr "foo"
[11:01:55.422]  - attr(*, "where")=List of 1
[11:01:55.422]   ..$ pkg:<environment: R_EmptyEnv> 
[11:01:55.422]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:55.422]  - attr(*, "resolved")= logi TRUE
[11:01:55.422]  - attr(*, "total_size")= num 42
[11:01:55.424] - copied ‘pkg’ to environment
[11:01:55.424] assign_globals() ... done
[11:01:55.424] plan(): Setting new future strategy stack:
[11:01:55.424] List of future strategies:
[11:01:55.424] 1. sequential:
[11:01:55.424]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:55.424]    - tweaked: FALSE
[11:01:55.424]    - call: NULL
[11:01:55.425] plan(): nbrOfWorkers() = 1
[11:01:55.426] plan(): Setting new future strategy stack:
[11:01:55.426] List of future strategies:
[11:01:55.426] 1. multisession:
[11:01:55.426]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:55.426]    - tweaked: FALSE
[11:01:55.426]    - call: plan(strategy)
[11:01:55.427] plan(): nbrOfWorkers() = 2
[11:01:55.427] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'conservative' ... DONE
Method for identifying globals: 'ordered' ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.428] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.428] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.430] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:55.430] Searching for globals ... DONE
[11:01:55.430] Resolving globals: TRUE
[11:01:55.430] Resolving any globals that are futures ...
[11:01:55.430] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:55.430] Resolving any globals that are futures ... DONE
[11:01:55.431] Resolving futures part of globals (recursively) ...
[11:01:55.431] resolve() on list ...
[11:01:55.431]  recursive: 99
[11:01:55.431]  length: 1
[11:01:55.431]  elements: ‘a’
[11:01:55.431]  length: 0 (resolved future 1)
[11:01:55.431] resolve() on list ... DONE
[11:01:55.431] - globals: [1] ‘a’
[11:01:55.431] Resolving futures part of globals (recursively) ... DONE
[11:01:55.432] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:55.432] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:55.432] - globals: [1] ‘a’
[11:01:55.432] 
[11:01:55.432] getGlobalsAndPackages() ... DONE
[11:01:55.432] run() for ‘Future’ ...
[11:01:55.432] - state: ‘created’
[11:01:55.433] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.446] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.446] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.446]   - Field: ‘node’
[11:01:55.446]   - Field: ‘label’
[11:01:55.447]   - Field: ‘local’
[11:01:55.447]   - Field: ‘owner’
[11:01:55.447]   - Field: ‘envir’
[11:01:55.447]   - Field: ‘workers’
[11:01:55.447]   - Field: ‘packages’
[11:01:55.447]   - Field: ‘gc’
[11:01:55.447]   - Field: ‘conditions’
[11:01:55.447]   - Field: ‘persistent’
[11:01:55.447]   - Field: ‘expr’
[11:01:55.447]   - Field: ‘uuid’
[11:01:55.447]   - Field: ‘seed’
[11:01:55.447]   - Field: ‘version’
[11:01:55.448]   - Field: ‘result’
[11:01:55.448]   - Field: ‘asynchronous’
[11:01:55.448]   - Field: ‘calls’
[11:01:55.448]   - Field: ‘globals’
[11:01:55.448]   - Field: ‘stdout’
[11:01:55.448]   - Field: ‘earlySignal’
[11:01:55.448]   - Field: ‘lazy’
[11:01:55.448]   - Field: ‘state’
[11:01:55.448] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.448] - Launch lazy future ...
[11:01:55.449] Packages needed by the future expression (n = 0): <none>
[11:01:55.449] Packages needed by future strategies (n = 0): <none>
[11:01:55.449] {
[11:01:55.449]     {
[11:01:55.449]         {
[11:01:55.449]             ...future.startTime <- base::Sys.time()
[11:01:55.449]             {
[11:01:55.449]                 {
[11:01:55.449]                   {
[11:01:55.449]                     {
[11:01:55.449]                       base::local({
[11:01:55.449]                         has_future <- base::requireNamespace("future", 
[11:01:55.449]                           quietly = TRUE)
[11:01:55.449]                         if (has_future) {
[11:01:55.449]                           ns <- base::getNamespace("future")
[11:01:55.449]                           version <- ns[[".package"]][["version"]]
[11:01:55.449]                           if (is.null(version)) 
[11:01:55.449]                             version <- utils::packageVersion("future")
[11:01:55.449]                         }
[11:01:55.449]                         else {
[11:01:55.449]                           version <- NULL
[11:01:55.449]                         }
[11:01:55.449]                         if (!has_future || version < "1.8.0") {
[11:01:55.449]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.449]                             "", base::R.version$version.string), 
[11:01:55.449]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.449]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.449]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.449]                               "release", "version")], collapse = " "), 
[11:01:55.449]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.449]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.449]                             info)
[11:01:55.449]                           info <- base::paste(info, collapse = "; ")
[11:01:55.449]                           if (!has_future) {
[11:01:55.449]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.449]                               info)
[11:01:55.449]                           }
[11:01:55.449]                           else {
[11:01:55.449]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.449]                               info, version)
[11:01:55.449]                           }
[11:01:55.449]                           base::stop(msg)
[11:01:55.449]                         }
[11:01:55.449]                       })
[11:01:55.449]                     }
[11:01:55.449]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.449]                     base::options(mc.cores = 1L)
[11:01:55.449]                   }
[11:01:55.449]                   ...future.strategy.old <- future::plan("list")
[11:01:55.449]                   options(future.plan = NULL)
[11:01:55.449]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.449]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.449]                 }
[11:01:55.449]                 ...future.workdir <- getwd()
[11:01:55.449]             }
[11:01:55.449]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.449]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.449]         }
[11:01:55.449]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.449]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.449]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.449]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.449]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.449]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.449]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.449]             base::names(...future.oldOptions))
[11:01:55.449]     }
[11:01:55.449]     if (FALSE) {
[11:01:55.449]     }
[11:01:55.449]     else {
[11:01:55.449]         if (TRUE) {
[11:01:55.449]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.449]                 open = "w")
[11:01:55.449]         }
[11:01:55.449]         else {
[11:01:55.449]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.449]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.449]         }
[11:01:55.449]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.449]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.449]             base::sink(type = "output", split = FALSE)
[11:01:55.449]             base::close(...future.stdout)
[11:01:55.449]         }, add = TRUE)
[11:01:55.449]     }
[11:01:55.449]     ...future.frame <- base::sys.nframe()
[11:01:55.449]     ...future.conditions <- base::list()
[11:01:55.449]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.449]     if (FALSE) {
[11:01:55.449]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.449]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.449]     }
[11:01:55.449]     ...future.result <- base::tryCatch({
[11:01:55.449]         base::withCallingHandlers({
[11:01:55.449]             ...future.value <- base::withVisible(base::local({
[11:01:55.449]                 ...future.makeSendCondition <- base::local({
[11:01:55.449]                   sendCondition <- NULL
[11:01:55.449]                   function(frame = 1L) {
[11:01:55.449]                     if (is.function(sendCondition)) 
[11:01:55.449]                       return(sendCondition)
[11:01:55.449]                     ns <- getNamespace("parallel")
[11:01:55.449]                     if (exists("sendData", mode = "function", 
[11:01:55.449]                       envir = ns)) {
[11:01:55.449]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.449]                         envir = ns)
[11:01:55.449]                       envir <- sys.frame(frame)
[11:01:55.449]                       master <- NULL
[11:01:55.449]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.449]                         !identical(envir, emptyenv())) {
[11:01:55.449]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.449]                           inherits = FALSE)) {
[11:01:55.449]                           master <- get("master", mode = "list", 
[11:01:55.449]                             envir = envir, inherits = FALSE)
[11:01:55.449]                           if (inherits(master, c("SOCKnode", 
[11:01:55.449]                             "SOCK0node"))) {
[11:01:55.449]                             sendCondition <<- function(cond) {
[11:01:55.449]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.449]                                 success = TRUE)
[11:01:55.449]                               parallel_sendData(master, data)
[11:01:55.449]                             }
[11:01:55.449]                             return(sendCondition)
[11:01:55.449]                           }
[11:01:55.449]                         }
[11:01:55.449]                         frame <- frame + 1L
[11:01:55.449]                         envir <- sys.frame(frame)
[11:01:55.449]                       }
[11:01:55.449]                     }
[11:01:55.449]                     sendCondition <<- function(cond) NULL
[11:01:55.449]                   }
[11:01:55.449]                 })
[11:01:55.449]                 withCallingHandlers({
[11:01:55.449]                   {
[11:01:55.449]                     b <- a
[11:01:55.449]                     a <- 2
[11:01:55.449]                     a * b
[11:01:55.449]                   }
[11:01:55.449]                 }, immediateCondition = function(cond) {
[11:01:55.449]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.449]                   sendCondition(cond)
[11:01:55.449]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.449]                   {
[11:01:55.449]                     inherits <- base::inherits
[11:01:55.449]                     invokeRestart <- base::invokeRestart
[11:01:55.449]                     is.null <- base::is.null
[11:01:55.449]                     muffled <- FALSE
[11:01:55.449]                     if (inherits(cond, "message")) {
[11:01:55.449]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.449]                       if (muffled) 
[11:01:55.449]                         invokeRestart("muffleMessage")
[11:01:55.449]                     }
[11:01:55.449]                     else if (inherits(cond, "warning")) {
[11:01:55.449]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.449]                       if (muffled) 
[11:01:55.449]                         invokeRestart("muffleWarning")
[11:01:55.449]                     }
[11:01:55.449]                     else if (inherits(cond, "condition")) {
[11:01:55.449]                       if (!is.null(pattern)) {
[11:01:55.449]                         computeRestarts <- base::computeRestarts
[11:01:55.449]                         grepl <- base::grepl
[11:01:55.449]                         restarts <- computeRestarts(cond)
[11:01:55.449]                         for (restart in restarts) {
[11:01:55.449]                           name <- restart$name
[11:01:55.449]                           if (is.null(name)) 
[11:01:55.449]                             next
[11:01:55.449]                           if (!grepl(pattern, name)) 
[11:01:55.449]                             next
[11:01:55.449]                           invokeRestart(restart)
[11:01:55.449]                           muffled <- TRUE
[11:01:55.449]                           break
[11:01:55.449]                         }
[11:01:55.449]                       }
[11:01:55.449]                     }
[11:01:55.449]                     invisible(muffled)
[11:01:55.449]                   }
[11:01:55.449]                   muffleCondition(cond)
[11:01:55.449]                 })
[11:01:55.449]             }))
[11:01:55.449]             future::FutureResult(value = ...future.value$value, 
[11:01:55.449]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.449]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.449]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.449]                     ...future.globalenv.names))
[11:01:55.449]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.449]         }, condition = base::local({
[11:01:55.449]             c <- base::c
[11:01:55.449]             inherits <- base::inherits
[11:01:55.449]             invokeRestart <- base::invokeRestart
[11:01:55.449]             length <- base::length
[11:01:55.449]             list <- base::list
[11:01:55.449]             seq.int <- base::seq.int
[11:01:55.449]             signalCondition <- base::signalCondition
[11:01:55.449]             sys.calls <- base::sys.calls
[11:01:55.449]             `[[` <- base::`[[`
[11:01:55.449]             `+` <- base::`+`
[11:01:55.449]             `<<-` <- base::`<<-`
[11:01:55.449]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.449]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.449]                   3L)]
[11:01:55.449]             }
[11:01:55.449]             function(cond) {
[11:01:55.449]                 is_error <- inherits(cond, "error")
[11:01:55.449]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.449]                   NULL)
[11:01:55.449]                 if (is_error) {
[11:01:55.449]                   sessionInformation <- function() {
[11:01:55.449]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.449]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.449]                       search = base::search(), system = base::Sys.info())
[11:01:55.449]                   }
[11:01:55.449]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.449]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.449]                     cond$call), session = sessionInformation(), 
[11:01:55.449]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.449]                   signalCondition(cond)
[11:01:55.449]                 }
[11:01:55.449]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.449]                 "immediateCondition"))) {
[11:01:55.449]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.449]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.449]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.449]                   if (TRUE && !signal) {
[11:01:55.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.449]                     {
[11:01:55.449]                       inherits <- base::inherits
[11:01:55.449]                       invokeRestart <- base::invokeRestart
[11:01:55.449]                       is.null <- base::is.null
[11:01:55.449]                       muffled <- FALSE
[11:01:55.449]                       if (inherits(cond, "message")) {
[11:01:55.449]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.449]                         if (muffled) 
[11:01:55.449]                           invokeRestart("muffleMessage")
[11:01:55.449]                       }
[11:01:55.449]                       else if (inherits(cond, "warning")) {
[11:01:55.449]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.449]                         if (muffled) 
[11:01:55.449]                           invokeRestart("muffleWarning")
[11:01:55.449]                       }
[11:01:55.449]                       else if (inherits(cond, "condition")) {
[11:01:55.449]                         if (!is.null(pattern)) {
[11:01:55.449]                           computeRestarts <- base::computeRestarts
[11:01:55.449]                           grepl <- base::grepl
[11:01:55.449]                           restarts <- computeRestarts(cond)
[11:01:55.449]                           for (restart in restarts) {
[11:01:55.449]                             name <- restart$name
[11:01:55.449]                             if (is.null(name)) 
[11:01:55.449]                               next
[11:01:55.449]                             if (!grepl(pattern, name)) 
[11:01:55.449]                               next
[11:01:55.449]                             invokeRestart(restart)
[11:01:55.449]                             muffled <- TRUE
[11:01:55.449]                             break
[11:01:55.449]                           }
[11:01:55.449]                         }
[11:01:55.449]                       }
[11:01:55.449]                       invisible(muffled)
[11:01:55.449]                     }
[11:01:55.449]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.449]                   }
[11:01:55.449]                 }
[11:01:55.449]                 else {
[11:01:55.449]                   if (TRUE) {
[11:01:55.449]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.449]                     {
[11:01:55.449]                       inherits <- base::inherits
[11:01:55.449]                       invokeRestart <- base::invokeRestart
[11:01:55.449]                       is.null <- base::is.null
[11:01:55.449]                       muffled <- FALSE
[11:01:55.449]                       if (inherits(cond, "message")) {
[11:01:55.449]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.449]                         if (muffled) 
[11:01:55.449]                           invokeRestart("muffleMessage")
[11:01:55.449]                       }
[11:01:55.449]                       else if (inherits(cond, "warning")) {
[11:01:55.449]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.449]                         if (muffled) 
[11:01:55.449]                           invokeRestart("muffleWarning")
[11:01:55.449]                       }
[11:01:55.449]                       else if (inherits(cond, "condition")) {
[11:01:55.449]                         if (!is.null(pattern)) {
[11:01:55.449]                           computeRestarts <- base::computeRestarts
[11:01:55.449]                           grepl <- base::grepl
[11:01:55.449]                           restarts <- computeRestarts(cond)
[11:01:55.449]                           for (restart in restarts) {
[11:01:55.449]                             name <- restart$name
[11:01:55.449]                             if (is.null(name)) 
[11:01:55.449]                               next
[11:01:55.449]                             if (!grepl(pattern, name)) 
[11:01:55.449]                               next
[11:01:55.449]                             invokeRestart(restart)
[11:01:55.449]                             muffled <- TRUE
[11:01:55.449]                             break
[11:01:55.449]                           }
[11:01:55.449]                         }
[11:01:55.449]                       }
[11:01:55.449]                       invisible(muffled)
[11:01:55.449]                     }
[11:01:55.449]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.449]                   }
[11:01:55.449]                 }
[11:01:55.449]             }
[11:01:55.449]         }))
[11:01:55.449]     }, error = function(ex) {
[11:01:55.449]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.449]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.449]                 ...future.rng), started = ...future.startTime, 
[11:01:55.449]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.449]             version = "1.8"), class = "FutureResult")
[11:01:55.449]     }, finally = {
[11:01:55.449]         if (!identical(...future.workdir, getwd())) 
[11:01:55.449]             setwd(...future.workdir)
[11:01:55.449]         {
[11:01:55.449]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.449]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.449]             }
[11:01:55.449]             base::options(...future.oldOptions)
[11:01:55.449]             if (.Platform$OS.type == "windows") {
[11:01:55.449]                 old_names <- names(...future.oldEnvVars)
[11:01:55.449]                 envs <- base::Sys.getenv()
[11:01:55.449]                 names <- names(envs)
[11:01:55.449]                 common <- intersect(names, old_names)
[11:01:55.449]                 added <- setdiff(names, old_names)
[11:01:55.449]                 removed <- setdiff(old_names, names)
[11:01:55.449]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.449]                   envs[common]]
[11:01:55.449]                 NAMES <- toupper(changed)
[11:01:55.449]                 args <- list()
[11:01:55.449]                 for (kk in seq_along(NAMES)) {
[11:01:55.449]                   name <- changed[[kk]]
[11:01:55.449]                   NAME <- NAMES[[kk]]
[11:01:55.449]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.449]                     next
[11:01:55.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.449]                 }
[11:01:55.449]                 NAMES <- toupper(added)
[11:01:55.449]                 for (kk in seq_along(NAMES)) {
[11:01:55.449]                   name <- added[[kk]]
[11:01:55.449]                   NAME <- NAMES[[kk]]
[11:01:55.449]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.449]                     next
[11:01:55.449]                   args[[name]] <- ""
[11:01:55.449]                 }
[11:01:55.449]                 NAMES <- toupper(removed)
[11:01:55.449]                 for (kk in seq_along(NAMES)) {
[11:01:55.449]                   name <- removed[[kk]]
[11:01:55.449]                   NAME <- NAMES[[kk]]
[11:01:55.449]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.449]                     next
[11:01:55.449]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.449]                 }
[11:01:55.449]                 if (length(args) > 0) 
[11:01:55.449]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.449]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.449]             }
[11:01:55.449]             else {
[11:01:55.449]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.449]             }
[11:01:55.449]             {
[11:01:55.449]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.449]                   0L) {
[11:01:55.449]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.449]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.449]                   base::options(opts)
[11:01:55.449]                 }
[11:01:55.449]                 {
[11:01:55.449]                   {
[11:01:55.449]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.449]                     NULL
[11:01:55.449]                   }
[11:01:55.449]                   options(future.plan = NULL)
[11:01:55.449]                   if (is.na(NA_character_)) 
[11:01:55.449]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.449]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.449]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.449]                     .init = FALSE)
[11:01:55.449]                 }
[11:01:55.449]             }
[11:01:55.449]         }
[11:01:55.449]     })
[11:01:55.449]     if (TRUE) {
[11:01:55.449]         base::sink(type = "output", split = FALSE)
[11:01:55.449]         if (TRUE) {
[11:01:55.449]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.449]         }
[11:01:55.449]         else {
[11:01:55.449]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.449]         }
[11:01:55.449]         base::close(...future.stdout)
[11:01:55.449]         ...future.stdout <- NULL
[11:01:55.449]     }
[11:01:55.449]     ...future.result$conditions <- ...future.conditions
[11:01:55.449]     ...future.result$finished <- base::Sys.time()
[11:01:55.449]     ...future.result
[11:01:55.449] }
[11:01:55.452] Exporting 1 global objects (346 bytes) to cluster node #2 ...
[11:01:55.452] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[11:01:55.452] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[11:01:55.452] Exporting 1 global objects (346 bytes) to cluster node #2 ... DONE
[11:01:55.453] MultisessionFuture started
[11:01:55.453] - Launch lazy future ... done
[11:01:55.453] run() for ‘MultisessionFuture’ ... done
[11:01:55.453] result() for ClusterFuture ...
[11:01:55.453] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.453] - Validating connection of MultisessionFuture
[11:01:55.495] - received message: FutureResult
[11:01:55.495] - Received FutureResult
[11:01:55.495] - Erased future from FutureRegistry
[11:01:55.495] result() for ClusterFuture ...
[11:01:55.495] - result already collected: FutureResult
[11:01:55.495] result() for ClusterFuture ... done
[11:01:55.495] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.495] result() for ClusterFuture ... done
[11:01:55.496] result() for ClusterFuture ...
[11:01:55.496] - result already collected: FutureResult
[11:01:55.496] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.496] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.496] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.498] - globals found: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:55.498] Searching for globals ... DONE
[11:01:55.498] Resolving globals: TRUE
[11:01:55.498] Resolving any globals that are futures ...
[11:01:55.498] - globals: [4] ‘{’, ‘<-’, ‘a’, ‘*’
[11:01:55.499] Resolving any globals that are futures ... DONE
[11:01:55.499] Resolving futures part of globals (recursively) ...
[11:01:55.499] resolve() on list ...
[11:01:55.499]  recursive: 99
[11:01:55.499]  length: 1
[11:01:55.499]  elements: ‘a’
[11:01:55.499]  length: 0 (resolved future 1)
[11:01:55.499] resolve() on list ... DONE
[11:01:55.500] - globals: [1] ‘a’
[11:01:55.500] Resolving futures part of globals (recursively) ... DONE
[11:01:55.500] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:55.500] The total size of the 1 globals exported for future expression (‘{; b <- a; a <- 2; a * b; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (39 bytes of class ‘numeric’)
[11:01:55.500] - globals: [1] ‘a’
[11:01:55.500] 
[11:01:55.500] getGlobalsAndPackages() ... DONE
[11:01:55.501] run() for ‘Future’ ...
[11:01:55.501] - state: ‘created’
[11:01:55.501] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.514] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.514] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.515]   - Field: ‘node’
[11:01:55.515]   - Field: ‘label’
[11:01:55.515]   - Field: ‘local’
[11:01:55.515]   - Field: ‘owner’
[11:01:55.515]   - Field: ‘envir’
[11:01:55.515]   - Field: ‘workers’
[11:01:55.515]   - Field: ‘packages’
[11:01:55.515]   - Field: ‘gc’
[11:01:55.515]   - Field: ‘conditions’
[11:01:55.515]   - Field: ‘persistent’
[11:01:55.515]   - Field: ‘expr’
[11:01:55.516]   - Field: ‘uuid’
[11:01:55.516]   - Field: ‘seed’
[11:01:55.516]   - Field: ‘version’
[11:01:55.516]   - Field: ‘result’
[11:01:55.516]   - Field: ‘asynchronous’
[11:01:55.516]   - Field: ‘calls’
[11:01:55.516]   - Field: ‘globals’
[11:01:55.516]   - Field: ‘stdout’
[11:01:55.516]   - Field: ‘earlySignal’
[11:01:55.516]   - Field: ‘lazy’
[11:01:55.516]   - Field: ‘state’
[11:01:55.516] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.517] - Launch lazy future ...
[11:01:55.517] Packages needed by the future expression (n = 0): <none>
[11:01:55.517] Packages needed by future strategies (n = 0): <none>
[11:01:55.517] {
[11:01:55.517]     {
[11:01:55.517]         {
[11:01:55.517]             ...future.startTime <- base::Sys.time()
[11:01:55.517]             {
[11:01:55.517]                 {
[11:01:55.517]                   {
[11:01:55.517]                     {
[11:01:55.517]                       base::local({
[11:01:55.517]                         has_future <- base::requireNamespace("future", 
[11:01:55.517]                           quietly = TRUE)
[11:01:55.517]                         if (has_future) {
[11:01:55.517]                           ns <- base::getNamespace("future")
[11:01:55.517]                           version <- ns[[".package"]][["version"]]
[11:01:55.517]                           if (is.null(version)) 
[11:01:55.517]                             version <- utils::packageVersion("future")
[11:01:55.517]                         }
[11:01:55.517]                         else {
[11:01:55.517]                           version <- NULL
[11:01:55.517]                         }
[11:01:55.517]                         if (!has_future || version < "1.8.0") {
[11:01:55.517]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.517]                             "", base::R.version$version.string), 
[11:01:55.517]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.517]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.517]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.517]                               "release", "version")], collapse = " "), 
[11:01:55.517]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.517]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.517]                             info)
[11:01:55.517]                           info <- base::paste(info, collapse = "; ")
[11:01:55.517]                           if (!has_future) {
[11:01:55.517]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.517]                               info)
[11:01:55.517]                           }
[11:01:55.517]                           else {
[11:01:55.517]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.517]                               info, version)
[11:01:55.517]                           }
[11:01:55.517]                           base::stop(msg)
[11:01:55.517]                         }
[11:01:55.517]                       })
[11:01:55.517]                     }
[11:01:55.517]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.517]                     base::options(mc.cores = 1L)
[11:01:55.517]                   }
[11:01:55.517]                   ...future.strategy.old <- future::plan("list")
[11:01:55.517]                   options(future.plan = NULL)
[11:01:55.517]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.517]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.517]                 }
[11:01:55.517]                 ...future.workdir <- getwd()
[11:01:55.517]             }
[11:01:55.517]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.517]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.517]         }
[11:01:55.517]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.517]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.517]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.517]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.517]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.517]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.517]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.517]             base::names(...future.oldOptions))
[11:01:55.517]     }
[11:01:55.517]     if (FALSE) {
[11:01:55.517]     }
[11:01:55.517]     else {
[11:01:55.517]         if (TRUE) {
[11:01:55.517]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.517]                 open = "w")
[11:01:55.517]         }
[11:01:55.517]         else {
[11:01:55.517]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.517]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.517]         }
[11:01:55.517]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.517]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.517]             base::sink(type = "output", split = FALSE)
[11:01:55.517]             base::close(...future.stdout)
[11:01:55.517]         }, add = TRUE)
[11:01:55.517]     }
[11:01:55.517]     ...future.frame <- base::sys.nframe()
[11:01:55.517]     ...future.conditions <- base::list()
[11:01:55.517]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.517]     if (FALSE) {
[11:01:55.517]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.517]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.517]     }
[11:01:55.517]     ...future.result <- base::tryCatch({
[11:01:55.517]         base::withCallingHandlers({
[11:01:55.517]             ...future.value <- base::withVisible(base::local({
[11:01:55.517]                 ...future.makeSendCondition <- base::local({
[11:01:55.517]                   sendCondition <- NULL
[11:01:55.517]                   function(frame = 1L) {
[11:01:55.517]                     if (is.function(sendCondition)) 
[11:01:55.517]                       return(sendCondition)
[11:01:55.517]                     ns <- getNamespace("parallel")
[11:01:55.517]                     if (exists("sendData", mode = "function", 
[11:01:55.517]                       envir = ns)) {
[11:01:55.517]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.517]                         envir = ns)
[11:01:55.517]                       envir <- sys.frame(frame)
[11:01:55.517]                       master <- NULL
[11:01:55.517]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.517]                         !identical(envir, emptyenv())) {
[11:01:55.517]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.517]                           inherits = FALSE)) {
[11:01:55.517]                           master <- get("master", mode = "list", 
[11:01:55.517]                             envir = envir, inherits = FALSE)
[11:01:55.517]                           if (inherits(master, c("SOCKnode", 
[11:01:55.517]                             "SOCK0node"))) {
[11:01:55.517]                             sendCondition <<- function(cond) {
[11:01:55.517]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.517]                                 success = TRUE)
[11:01:55.517]                               parallel_sendData(master, data)
[11:01:55.517]                             }
[11:01:55.517]                             return(sendCondition)
[11:01:55.517]                           }
[11:01:55.517]                         }
[11:01:55.517]                         frame <- frame + 1L
[11:01:55.517]                         envir <- sys.frame(frame)
[11:01:55.517]                       }
[11:01:55.517]                     }
[11:01:55.517]                     sendCondition <<- function(cond) NULL
[11:01:55.517]                   }
[11:01:55.517]                 })
[11:01:55.517]                 withCallingHandlers({
[11:01:55.517]                   {
[11:01:55.517]                     b <- a
[11:01:55.517]                     a <- 2
[11:01:55.517]                     a * b
[11:01:55.517]                   }
[11:01:55.517]                 }, immediateCondition = function(cond) {
[11:01:55.517]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.517]                   sendCondition(cond)
[11:01:55.517]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.517]                   {
[11:01:55.517]                     inherits <- base::inherits
[11:01:55.517]                     invokeRestart <- base::invokeRestart
[11:01:55.517]                     is.null <- base::is.null
[11:01:55.517]                     muffled <- FALSE
[11:01:55.517]                     if (inherits(cond, "message")) {
[11:01:55.517]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.517]                       if (muffled) 
[11:01:55.517]                         invokeRestart("muffleMessage")
[11:01:55.517]                     }
[11:01:55.517]                     else if (inherits(cond, "warning")) {
[11:01:55.517]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.517]                       if (muffled) 
[11:01:55.517]                         invokeRestart("muffleWarning")
[11:01:55.517]                     }
[11:01:55.517]                     else if (inherits(cond, "condition")) {
[11:01:55.517]                       if (!is.null(pattern)) {
[11:01:55.517]                         computeRestarts <- base::computeRestarts
[11:01:55.517]                         grepl <- base::grepl
[11:01:55.517]                         restarts <- computeRestarts(cond)
[11:01:55.517]                         for (restart in restarts) {
[11:01:55.517]                           name <- restart$name
[11:01:55.517]                           if (is.null(name)) 
[11:01:55.517]                             next
[11:01:55.517]                           if (!grepl(pattern, name)) 
[11:01:55.517]                             next
[11:01:55.517]                           invokeRestart(restart)
[11:01:55.517]                           muffled <- TRUE
[11:01:55.517]                           break
[11:01:55.517]                         }
[11:01:55.517]                       }
[11:01:55.517]                     }
[11:01:55.517]                     invisible(muffled)
[11:01:55.517]                   }
[11:01:55.517]                   muffleCondition(cond)
[11:01:55.517]                 })
[11:01:55.517]             }))
[11:01:55.517]             future::FutureResult(value = ...future.value$value, 
[11:01:55.517]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.517]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.517]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.517]                     ...future.globalenv.names))
[11:01:55.517]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.517]         }, condition = base::local({
[11:01:55.517]             c <- base::c
[11:01:55.517]             inherits <- base::inherits
[11:01:55.517]             invokeRestart <- base::invokeRestart
[11:01:55.517]             length <- base::length
[11:01:55.517]             list <- base::list
[11:01:55.517]             seq.int <- base::seq.int
[11:01:55.517]             signalCondition <- base::signalCondition
[11:01:55.517]             sys.calls <- base::sys.calls
[11:01:55.517]             `[[` <- base::`[[`
[11:01:55.517]             `+` <- base::`+`
[11:01:55.517]             `<<-` <- base::`<<-`
[11:01:55.517]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.517]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.517]                   3L)]
[11:01:55.517]             }
[11:01:55.517]             function(cond) {
[11:01:55.517]                 is_error <- inherits(cond, "error")
[11:01:55.517]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.517]                   NULL)
[11:01:55.517]                 if (is_error) {
[11:01:55.517]                   sessionInformation <- function() {
[11:01:55.517]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.517]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.517]                       search = base::search(), system = base::Sys.info())
[11:01:55.517]                   }
[11:01:55.517]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.517]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.517]                     cond$call), session = sessionInformation(), 
[11:01:55.517]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.517]                   signalCondition(cond)
[11:01:55.517]                 }
[11:01:55.517]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.517]                 "immediateCondition"))) {
[11:01:55.517]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.517]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.517]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.517]                   if (TRUE && !signal) {
[11:01:55.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.517]                     {
[11:01:55.517]                       inherits <- base::inherits
[11:01:55.517]                       invokeRestart <- base::invokeRestart
[11:01:55.517]                       is.null <- base::is.null
[11:01:55.517]                       muffled <- FALSE
[11:01:55.517]                       if (inherits(cond, "message")) {
[11:01:55.517]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.517]                         if (muffled) 
[11:01:55.517]                           invokeRestart("muffleMessage")
[11:01:55.517]                       }
[11:01:55.517]                       else if (inherits(cond, "warning")) {
[11:01:55.517]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.517]                         if (muffled) 
[11:01:55.517]                           invokeRestart("muffleWarning")
[11:01:55.517]                       }
[11:01:55.517]                       else if (inherits(cond, "condition")) {
[11:01:55.517]                         if (!is.null(pattern)) {
[11:01:55.517]                           computeRestarts <- base::computeRestarts
[11:01:55.517]                           grepl <- base::grepl
[11:01:55.517]                           restarts <- computeRestarts(cond)
[11:01:55.517]                           for (restart in restarts) {
[11:01:55.517]                             name <- restart$name
[11:01:55.517]                             if (is.null(name)) 
[11:01:55.517]                               next
[11:01:55.517]                             if (!grepl(pattern, name)) 
[11:01:55.517]                               next
[11:01:55.517]                             invokeRestart(restart)
[11:01:55.517]                             muffled <- TRUE
[11:01:55.517]                             break
[11:01:55.517]                           }
[11:01:55.517]                         }
[11:01:55.517]                       }
[11:01:55.517]                       invisible(muffled)
[11:01:55.517]                     }
[11:01:55.517]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.517]                   }
[11:01:55.517]                 }
[11:01:55.517]                 else {
[11:01:55.517]                   if (TRUE) {
[11:01:55.517]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.517]                     {
[11:01:55.517]                       inherits <- base::inherits
[11:01:55.517]                       invokeRestart <- base::invokeRestart
[11:01:55.517]                       is.null <- base::is.null
[11:01:55.517]                       muffled <- FALSE
[11:01:55.517]                       if (inherits(cond, "message")) {
[11:01:55.517]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.517]                         if (muffled) 
[11:01:55.517]                           invokeRestart("muffleMessage")
[11:01:55.517]                       }
[11:01:55.517]                       else if (inherits(cond, "warning")) {
[11:01:55.517]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.517]                         if (muffled) 
[11:01:55.517]                           invokeRestart("muffleWarning")
[11:01:55.517]                       }
[11:01:55.517]                       else if (inherits(cond, "condition")) {
[11:01:55.517]                         if (!is.null(pattern)) {
[11:01:55.517]                           computeRestarts <- base::computeRestarts
[11:01:55.517]                           grepl <- base::grepl
[11:01:55.517]                           restarts <- computeRestarts(cond)
[11:01:55.517]                           for (restart in restarts) {
[11:01:55.517]                             name <- restart$name
[11:01:55.517]                             if (is.null(name)) 
[11:01:55.517]                               next
[11:01:55.517]                             if (!grepl(pattern, name)) 
[11:01:55.517]                               next
[11:01:55.517]                             invokeRestart(restart)
[11:01:55.517]                             muffled <- TRUE
[11:01:55.517]                             break
[11:01:55.517]                           }
[11:01:55.517]                         }
[11:01:55.517]                       }
[11:01:55.517]                       invisible(muffled)
[11:01:55.517]                     }
[11:01:55.517]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.517]                   }
[11:01:55.517]                 }
[11:01:55.517]             }
[11:01:55.517]         }))
[11:01:55.517]     }, error = function(ex) {
[11:01:55.517]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.517]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.517]                 ...future.rng), started = ...future.startTime, 
[11:01:55.517]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.517]             version = "1.8"), class = "FutureResult")
[11:01:55.517]     }, finally = {
[11:01:55.517]         if (!identical(...future.workdir, getwd())) 
[11:01:55.517]             setwd(...future.workdir)
[11:01:55.517]         {
[11:01:55.517]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.517]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.517]             }
[11:01:55.517]             base::options(...future.oldOptions)
[11:01:55.517]             if (.Platform$OS.type == "windows") {
[11:01:55.517]                 old_names <- names(...future.oldEnvVars)
[11:01:55.517]                 envs <- base::Sys.getenv()
[11:01:55.517]                 names <- names(envs)
[11:01:55.517]                 common <- intersect(names, old_names)
[11:01:55.517]                 added <- setdiff(names, old_names)
[11:01:55.517]                 removed <- setdiff(old_names, names)
[11:01:55.517]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.517]                   envs[common]]
[11:01:55.517]                 NAMES <- toupper(changed)
[11:01:55.517]                 args <- list()
[11:01:55.517]                 for (kk in seq_along(NAMES)) {
[11:01:55.517]                   name <- changed[[kk]]
[11:01:55.517]                   NAME <- NAMES[[kk]]
[11:01:55.517]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.517]                     next
[11:01:55.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.517]                 }
[11:01:55.517]                 NAMES <- toupper(added)
[11:01:55.517]                 for (kk in seq_along(NAMES)) {
[11:01:55.517]                   name <- added[[kk]]
[11:01:55.517]                   NAME <- NAMES[[kk]]
[11:01:55.517]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.517]                     next
[11:01:55.517]                   args[[name]] <- ""
[11:01:55.517]                 }
[11:01:55.517]                 NAMES <- toupper(removed)
[11:01:55.517]                 for (kk in seq_along(NAMES)) {
[11:01:55.517]                   name <- removed[[kk]]
[11:01:55.517]                   NAME <- NAMES[[kk]]
[11:01:55.517]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.517]                     next
[11:01:55.517]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.517]                 }
[11:01:55.517]                 if (length(args) > 0) 
[11:01:55.517]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.517]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.517]             }
[11:01:55.517]             else {
[11:01:55.517]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.517]             }
[11:01:55.517]             {
[11:01:55.517]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.517]                   0L) {
[11:01:55.517]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.517]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.517]                   base::options(opts)
[11:01:55.517]                 }
[11:01:55.517]                 {
[11:01:55.517]                   {
[11:01:55.517]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.517]                     NULL
[11:01:55.517]                   }
[11:01:55.517]                   options(future.plan = NULL)
[11:01:55.517]                   if (is.na(NA_character_)) 
[11:01:55.517]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.517]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.517]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.517]                     .init = FALSE)
[11:01:55.517]                 }
[11:01:55.517]             }
[11:01:55.517]         }
[11:01:55.517]     })
[11:01:55.517]     if (TRUE) {
[11:01:55.517]         base::sink(type = "output", split = FALSE)
[11:01:55.517]         if (TRUE) {
[11:01:55.517]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.517]         }
[11:01:55.517]         else {
[11:01:55.517]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.517]         }
[11:01:55.517]         base::close(...future.stdout)
[11:01:55.517]         ...future.stdout <- NULL
[11:01:55.517]     }
[11:01:55.517]     ...future.result$conditions <- ...future.conditions
[11:01:55.517]     ...future.result$finished <- base::Sys.time()
[11:01:55.517]     ...future.result
[11:01:55.517] }
[11:01:55.520] Exporting 1 global objects (346 bytes) to cluster node #2 ...
[11:01:55.520] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[11:01:55.520] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[11:01:55.520] Exporting 1 global objects (346 bytes) to cluster node #2 ... DONE
[11:01:55.521] MultisessionFuture started
[11:01:55.521] - Launch lazy future ... done
[11:01:55.521] run() for ‘MultisessionFuture’ ... done
[11:01:55.521] result() for ClusterFuture ...
[11:01:55.521] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.521] - Validating connection of MultisessionFuture
[11:01:55.563] - received message: FutureResult
[11:01:55.563] - Received FutureResult
[11:01:55.563] - Erased future from FutureRegistry
[11:01:55.563] result() for ClusterFuture ...
[11:01:55.563] - result already collected: FutureResult
[11:01:55.563] result() for ClusterFuture ... done
[11:01:55.563] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.563] result() for ClusterFuture ... done
[11:01:55.564] result() for ClusterFuture ...
[11:01:55.564] - result already collected: FutureResult
[11:01:55.564] result() for ClusterFuture ... done
y = 6
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.565] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.565] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.567] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.568] Searching for globals ... DONE
[11:01:55.568] Resolving globals: TRUE
[11:01:55.568] Resolving any globals that are futures ...
[11:01:55.568] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.568] Resolving any globals that are futures ... DONE
[11:01:55.569] Resolving futures part of globals (recursively) ...
[11:01:55.569] resolve() on list ...
[11:01:55.569]  recursive: 99
[11:01:55.569]  length: 2
[11:01:55.569]  elements: ‘a’, ‘ii’
[11:01:55.569]  length: 1 (resolved future 1)
[11:01:55.570]  length: 0 (resolved future 2)
[11:01:55.570] resolve() on list ... DONE
[11:01:55.570] - globals: [2] ‘a’, ‘ii’
[11:01:55.570] Resolving futures part of globals (recursively) ... DONE
[11:01:55.570] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:55.571] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:55.571] - globals: [2] ‘a’, ‘ii’
[11:01:55.571] 
[11:01:55.571] getGlobalsAndPackages() ... DONE
[11:01:55.571] run() for ‘Future’ ...
[11:01:55.572] - state: ‘created’
[11:01:55.572] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.586] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.586] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.586]   - Field: ‘node’
[11:01:55.586]   - Field: ‘label’
[11:01:55.586]   - Field: ‘local’
[11:01:55.586]   - Field: ‘owner’
[11:01:55.586]   - Field: ‘envir’
[11:01:55.587]   - Field: ‘workers’
[11:01:55.587]   - Field: ‘packages’
[11:01:55.587]   - Field: ‘gc’
[11:01:55.587]   - Field: ‘conditions’
[11:01:55.587]   - Field: ‘persistent’
[11:01:55.587]   - Field: ‘expr’
[11:01:55.587]   - Field: ‘uuid’
[11:01:55.587]   - Field: ‘seed’
[11:01:55.587]   - Field: ‘version’
[11:01:55.587]   - Field: ‘result’
[11:01:55.587]   - Field: ‘asynchronous’
[11:01:55.588]   - Field: ‘calls’
[11:01:55.588]   - Field: ‘globals’
[11:01:55.588]   - Field: ‘stdout’
[11:01:55.588]   - Field: ‘earlySignal’
[11:01:55.588]   - Field: ‘lazy’
[11:01:55.588]   - Field: ‘state’
[11:01:55.588] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.588] - Launch lazy future ...
[11:01:55.588] Packages needed by the future expression (n = 0): <none>
[11:01:55.588] Packages needed by future strategies (n = 0): <none>
[11:01:55.589] {
[11:01:55.589]     {
[11:01:55.589]         {
[11:01:55.589]             ...future.startTime <- base::Sys.time()
[11:01:55.589]             {
[11:01:55.589]                 {
[11:01:55.589]                   {
[11:01:55.589]                     {
[11:01:55.589]                       base::local({
[11:01:55.589]                         has_future <- base::requireNamespace("future", 
[11:01:55.589]                           quietly = TRUE)
[11:01:55.589]                         if (has_future) {
[11:01:55.589]                           ns <- base::getNamespace("future")
[11:01:55.589]                           version <- ns[[".package"]][["version"]]
[11:01:55.589]                           if (is.null(version)) 
[11:01:55.589]                             version <- utils::packageVersion("future")
[11:01:55.589]                         }
[11:01:55.589]                         else {
[11:01:55.589]                           version <- NULL
[11:01:55.589]                         }
[11:01:55.589]                         if (!has_future || version < "1.8.0") {
[11:01:55.589]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.589]                             "", base::R.version$version.string), 
[11:01:55.589]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.589]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.589]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.589]                               "release", "version")], collapse = " "), 
[11:01:55.589]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.589]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.589]                             info)
[11:01:55.589]                           info <- base::paste(info, collapse = "; ")
[11:01:55.589]                           if (!has_future) {
[11:01:55.589]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.589]                               info)
[11:01:55.589]                           }
[11:01:55.589]                           else {
[11:01:55.589]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.589]                               info, version)
[11:01:55.589]                           }
[11:01:55.589]                           base::stop(msg)
[11:01:55.589]                         }
[11:01:55.589]                       })
[11:01:55.589]                     }
[11:01:55.589]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.589]                     base::options(mc.cores = 1L)
[11:01:55.589]                   }
[11:01:55.589]                   ...future.strategy.old <- future::plan("list")
[11:01:55.589]                   options(future.plan = NULL)
[11:01:55.589]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.589]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.589]                 }
[11:01:55.589]                 ...future.workdir <- getwd()
[11:01:55.589]             }
[11:01:55.589]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.589]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.589]         }
[11:01:55.589]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.589]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.589]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.589]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.589]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.589]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.589]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.589]             base::names(...future.oldOptions))
[11:01:55.589]     }
[11:01:55.589]     if (FALSE) {
[11:01:55.589]     }
[11:01:55.589]     else {
[11:01:55.589]         if (TRUE) {
[11:01:55.589]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.589]                 open = "w")
[11:01:55.589]         }
[11:01:55.589]         else {
[11:01:55.589]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.589]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.589]         }
[11:01:55.589]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.589]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.589]             base::sink(type = "output", split = FALSE)
[11:01:55.589]             base::close(...future.stdout)
[11:01:55.589]         }, add = TRUE)
[11:01:55.589]     }
[11:01:55.589]     ...future.frame <- base::sys.nframe()
[11:01:55.589]     ...future.conditions <- base::list()
[11:01:55.589]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.589]     if (FALSE) {
[11:01:55.589]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.589]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.589]     }
[11:01:55.589]     ...future.result <- base::tryCatch({
[11:01:55.589]         base::withCallingHandlers({
[11:01:55.589]             ...future.value <- base::withVisible(base::local({
[11:01:55.589]                 ...future.makeSendCondition <- base::local({
[11:01:55.589]                   sendCondition <- NULL
[11:01:55.589]                   function(frame = 1L) {
[11:01:55.589]                     if (is.function(sendCondition)) 
[11:01:55.589]                       return(sendCondition)
[11:01:55.589]                     ns <- getNamespace("parallel")
[11:01:55.589]                     if (exists("sendData", mode = "function", 
[11:01:55.589]                       envir = ns)) {
[11:01:55.589]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.589]                         envir = ns)
[11:01:55.589]                       envir <- sys.frame(frame)
[11:01:55.589]                       master <- NULL
[11:01:55.589]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.589]                         !identical(envir, emptyenv())) {
[11:01:55.589]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.589]                           inherits = FALSE)) {
[11:01:55.589]                           master <- get("master", mode = "list", 
[11:01:55.589]                             envir = envir, inherits = FALSE)
[11:01:55.589]                           if (inherits(master, c("SOCKnode", 
[11:01:55.589]                             "SOCK0node"))) {
[11:01:55.589]                             sendCondition <<- function(cond) {
[11:01:55.589]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.589]                                 success = TRUE)
[11:01:55.589]                               parallel_sendData(master, data)
[11:01:55.589]                             }
[11:01:55.589]                             return(sendCondition)
[11:01:55.589]                           }
[11:01:55.589]                         }
[11:01:55.589]                         frame <- frame + 1L
[11:01:55.589]                         envir <- sys.frame(frame)
[11:01:55.589]                       }
[11:01:55.589]                     }
[11:01:55.589]                     sendCondition <<- function(cond) NULL
[11:01:55.589]                   }
[11:01:55.589]                 })
[11:01:55.589]                 withCallingHandlers({
[11:01:55.589]                   {
[11:01:55.589]                     b <- a * ii
[11:01:55.589]                     a <- 0
[11:01:55.589]                     b
[11:01:55.589]                   }
[11:01:55.589]                 }, immediateCondition = function(cond) {
[11:01:55.589]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.589]                   sendCondition(cond)
[11:01:55.589]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.589]                   {
[11:01:55.589]                     inherits <- base::inherits
[11:01:55.589]                     invokeRestart <- base::invokeRestart
[11:01:55.589]                     is.null <- base::is.null
[11:01:55.589]                     muffled <- FALSE
[11:01:55.589]                     if (inherits(cond, "message")) {
[11:01:55.589]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.589]                       if (muffled) 
[11:01:55.589]                         invokeRestart("muffleMessage")
[11:01:55.589]                     }
[11:01:55.589]                     else if (inherits(cond, "warning")) {
[11:01:55.589]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.589]                       if (muffled) 
[11:01:55.589]                         invokeRestart("muffleWarning")
[11:01:55.589]                     }
[11:01:55.589]                     else if (inherits(cond, "condition")) {
[11:01:55.589]                       if (!is.null(pattern)) {
[11:01:55.589]                         computeRestarts <- base::computeRestarts
[11:01:55.589]                         grepl <- base::grepl
[11:01:55.589]                         restarts <- computeRestarts(cond)
[11:01:55.589]                         for (restart in restarts) {
[11:01:55.589]                           name <- restart$name
[11:01:55.589]                           if (is.null(name)) 
[11:01:55.589]                             next
[11:01:55.589]                           if (!grepl(pattern, name)) 
[11:01:55.589]                             next
[11:01:55.589]                           invokeRestart(restart)
[11:01:55.589]                           muffled <- TRUE
[11:01:55.589]                           break
[11:01:55.589]                         }
[11:01:55.589]                       }
[11:01:55.589]                     }
[11:01:55.589]                     invisible(muffled)
[11:01:55.589]                   }
[11:01:55.589]                   muffleCondition(cond)
[11:01:55.589]                 })
[11:01:55.589]             }))
[11:01:55.589]             future::FutureResult(value = ...future.value$value, 
[11:01:55.589]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.589]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.589]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.589]                     ...future.globalenv.names))
[11:01:55.589]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.589]         }, condition = base::local({
[11:01:55.589]             c <- base::c
[11:01:55.589]             inherits <- base::inherits
[11:01:55.589]             invokeRestart <- base::invokeRestart
[11:01:55.589]             length <- base::length
[11:01:55.589]             list <- base::list
[11:01:55.589]             seq.int <- base::seq.int
[11:01:55.589]             signalCondition <- base::signalCondition
[11:01:55.589]             sys.calls <- base::sys.calls
[11:01:55.589]             `[[` <- base::`[[`
[11:01:55.589]             `+` <- base::`+`
[11:01:55.589]             `<<-` <- base::`<<-`
[11:01:55.589]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.589]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.589]                   3L)]
[11:01:55.589]             }
[11:01:55.589]             function(cond) {
[11:01:55.589]                 is_error <- inherits(cond, "error")
[11:01:55.589]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.589]                   NULL)
[11:01:55.589]                 if (is_error) {
[11:01:55.589]                   sessionInformation <- function() {
[11:01:55.589]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.589]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.589]                       search = base::search(), system = base::Sys.info())
[11:01:55.589]                   }
[11:01:55.589]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.589]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.589]                     cond$call), session = sessionInformation(), 
[11:01:55.589]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.589]                   signalCondition(cond)
[11:01:55.589]                 }
[11:01:55.589]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.589]                 "immediateCondition"))) {
[11:01:55.589]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.589]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.589]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.589]                   if (TRUE && !signal) {
[11:01:55.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.589]                     {
[11:01:55.589]                       inherits <- base::inherits
[11:01:55.589]                       invokeRestart <- base::invokeRestart
[11:01:55.589]                       is.null <- base::is.null
[11:01:55.589]                       muffled <- FALSE
[11:01:55.589]                       if (inherits(cond, "message")) {
[11:01:55.589]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.589]                         if (muffled) 
[11:01:55.589]                           invokeRestart("muffleMessage")
[11:01:55.589]                       }
[11:01:55.589]                       else if (inherits(cond, "warning")) {
[11:01:55.589]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.589]                         if (muffled) 
[11:01:55.589]                           invokeRestart("muffleWarning")
[11:01:55.589]                       }
[11:01:55.589]                       else if (inherits(cond, "condition")) {
[11:01:55.589]                         if (!is.null(pattern)) {
[11:01:55.589]                           computeRestarts <- base::computeRestarts
[11:01:55.589]                           grepl <- base::grepl
[11:01:55.589]                           restarts <- computeRestarts(cond)
[11:01:55.589]                           for (restart in restarts) {
[11:01:55.589]                             name <- restart$name
[11:01:55.589]                             if (is.null(name)) 
[11:01:55.589]                               next
[11:01:55.589]                             if (!grepl(pattern, name)) 
[11:01:55.589]                               next
[11:01:55.589]                             invokeRestart(restart)
[11:01:55.589]                             muffled <- TRUE
[11:01:55.589]                             break
[11:01:55.589]                           }
[11:01:55.589]                         }
[11:01:55.589]                       }
[11:01:55.589]                       invisible(muffled)
[11:01:55.589]                     }
[11:01:55.589]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.589]                   }
[11:01:55.589]                 }
[11:01:55.589]                 else {
[11:01:55.589]                   if (TRUE) {
[11:01:55.589]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.589]                     {
[11:01:55.589]                       inherits <- base::inherits
[11:01:55.589]                       invokeRestart <- base::invokeRestart
[11:01:55.589]                       is.null <- base::is.null
[11:01:55.589]                       muffled <- FALSE
[11:01:55.589]                       if (inherits(cond, "message")) {
[11:01:55.589]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.589]                         if (muffled) 
[11:01:55.589]                           invokeRestart("muffleMessage")
[11:01:55.589]                       }
[11:01:55.589]                       else if (inherits(cond, "warning")) {
[11:01:55.589]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.589]                         if (muffled) 
[11:01:55.589]                           invokeRestart("muffleWarning")
[11:01:55.589]                       }
[11:01:55.589]                       else if (inherits(cond, "condition")) {
[11:01:55.589]                         if (!is.null(pattern)) {
[11:01:55.589]                           computeRestarts <- base::computeRestarts
[11:01:55.589]                           grepl <- base::grepl
[11:01:55.589]                           restarts <- computeRestarts(cond)
[11:01:55.589]                           for (restart in restarts) {
[11:01:55.589]                             name <- restart$name
[11:01:55.589]                             if (is.null(name)) 
[11:01:55.589]                               next
[11:01:55.589]                             if (!grepl(pattern, name)) 
[11:01:55.589]                               next
[11:01:55.589]                             invokeRestart(restart)
[11:01:55.589]                             muffled <- TRUE
[11:01:55.589]                             break
[11:01:55.589]                           }
[11:01:55.589]                         }
[11:01:55.589]                       }
[11:01:55.589]                       invisible(muffled)
[11:01:55.589]                     }
[11:01:55.589]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.589]                   }
[11:01:55.589]                 }
[11:01:55.589]             }
[11:01:55.589]         }))
[11:01:55.589]     }, error = function(ex) {
[11:01:55.589]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.589]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.589]                 ...future.rng), started = ...future.startTime, 
[11:01:55.589]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.589]             version = "1.8"), class = "FutureResult")
[11:01:55.589]     }, finally = {
[11:01:55.589]         if (!identical(...future.workdir, getwd())) 
[11:01:55.589]             setwd(...future.workdir)
[11:01:55.589]         {
[11:01:55.589]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.589]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.589]             }
[11:01:55.589]             base::options(...future.oldOptions)
[11:01:55.589]             if (.Platform$OS.type == "windows") {
[11:01:55.589]                 old_names <- names(...future.oldEnvVars)
[11:01:55.589]                 envs <- base::Sys.getenv()
[11:01:55.589]                 names <- names(envs)
[11:01:55.589]                 common <- intersect(names, old_names)
[11:01:55.589]                 added <- setdiff(names, old_names)
[11:01:55.589]                 removed <- setdiff(old_names, names)
[11:01:55.589]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.589]                   envs[common]]
[11:01:55.589]                 NAMES <- toupper(changed)
[11:01:55.589]                 args <- list()
[11:01:55.589]                 for (kk in seq_along(NAMES)) {
[11:01:55.589]                   name <- changed[[kk]]
[11:01:55.589]                   NAME <- NAMES[[kk]]
[11:01:55.589]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.589]                     next
[11:01:55.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.589]                 }
[11:01:55.589]                 NAMES <- toupper(added)
[11:01:55.589]                 for (kk in seq_along(NAMES)) {
[11:01:55.589]                   name <- added[[kk]]
[11:01:55.589]                   NAME <- NAMES[[kk]]
[11:01:55.589]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.589]                     next
[11:01:55.589]                   args[[name]] <- ""
[11:01:55.589]                 }
[11:01:55.589]                 NAMES <- toupper(removed)
[11:01:55.589]                 for (kk in seq_along(NAMES)) {
[11:01:55.589]                   name <- removed[[kk]]
[11:01:55.589]                   NAME <- NAMES[[kk]]
[11:01:55.589]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.589]                     next
[11:01:55.589]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.589]                 }
[11:01:55.589]                 if (length(args) > 0) 
[11:01:55.589]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.589]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.589]             }
[11:01:55.589]             else {
[11:01:55.589]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.589]             }
[11:01:55.589]             {
[11:01:55.589]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.589]                   0L) {
[11:01:55.589]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.589]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.589]                   base::options(opts)
[11:01:55.589]                 }
[11:01:55.589]                 {
[11:01:55.589]                   {
[11:01:55.589]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.589]                     NULL
[11:01:55.589]                   }
[11:01:55.589]                   options(future.plan = NULL)
[11:01:55.589]                   if (is.na(NA_character_)) 
[11:01:55.589]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.589]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.589]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.589]                     .init = FALSE)
[11:01:55.589]                 }
[11:01:55.589]             }
[11:01:55.589]         }
[11:01:55.589]     })
[11:01:55.589]     if (TRUE) {
[11:01:55.589]         base::sink(type = "output", split = FALSE)
[11:01:55.589]         if (TRUE) {
[11:01:55.589]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.589]         }
[11:01:55.589]         else {
[11:01:55.589]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.589]         }
[11:01:55.589]         base::close(...future.stdout)
[11:01:55.589]         ...future.stdout <- NULL
[11:01:55.589]     }
[11:01:55.589]     ...future.result$conditions <- ...future.conditions
[11:01:55.589]     ...future.result$finished <- base::Sys.time()
[11:01:55.589]     ...future.result
[11:01:55.589] }
[11:01:55.591] Exporting 2 global objects (382 bytes) to cluster node #2 ...
[11:01:55.591] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[11:01:55.592] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[11:01:55.592] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:01:55.592] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:01:55.592] Exporting 2 global objects (382 bytes) to cluster node #2 ... DONE
[11:01:55.593] MultisessionFuture started
[11:01:55.593] - Launch lazy future ... done
[11:01:55.593] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.593] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.594] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.595] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.595] Searching for globals ... DONE
[11:01:55.596] Resolving globals: TRUE
[11:01:55.596] Resolving any globals that are futures ...
[11:01:55.596] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.596] Resolving any globals that are futures ... DONE
[11:01:55.596] Resolving futures part of globals (recursively) ...
[11:01:55.596] resolve() on list ...
[11:01:55.596]  recursive: 99
[11:01:55.597]  length: 2
[11:01:55.597]  elements: ‘a’, ‘ii’
[11:01:55.597]  length: 1 (resolved future 1)
[11:01:55.597]  length: 0 (resolved future 2)
[11:01:55.597] resolve() on list ... DONE
[11:01:55.597] - globals: [2] ‘a’, ‘ii’
[11:01:55.597] Resolving futures part of globals (recursively) ... DONE
[11:01:55.597] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:55.598] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:55.598] - globals: [2] ‘a’, ‘ii’
[11:01:55.598] 
[11:01:55.598] getGlobalsAndPackages() ... DONE
[11:01:55.598] run() for ‘Future’ ...
[11:01:55.598] - state: ‘created’
[11:01:55.598] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.612] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.612] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.612]   - Field: ‘node’
[11:01:55.612]   - Field: ‘label’
[11:01:55.613]   - Field: ‘local’
[11:01:55.613]   - Field: ‘owner’
[11:01:55.613]   - Field: ‘envir’
[11:01:55.613]   - Field: ‘workers’
[11:01:55.613]   - Field: ‘packages’
[11:01:55.613]   - Field: ‘gc’
[11:01:55.613]   - Field: ‘conditions’
[11:01:55.613]   - Field: ‘persistent’
[11:01:55.613]   - Field: ‘expr’
[11:01:55.613]   - Field: ‘uuid’
[11:01:55.613]   - Field: ‘seed’
[11:01:55.613]   - Field: ‘version’
[11:01:55.614]   - Field: ‘result’
[11:01:55.614]   - Field: ‘asynchronous’
[11:01:55.614]   - Field: ‘calls’
[11:01:55.614]   - Field: ‘globals’
[11:01:55.614]   - Field: ‘stdout’
[11:01:55.614]   - Field: ‘earlySignal’
[11:01:55.614]   - Field: ‘lazy’
[11:01:55.614]   - Field: ‘state’
[11:01:55.614] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.614] - Launch lazy future ...
[11:01:55.615] Packages needed by the future expression (n = 0): <none>
[11:01:55.615] Packages needed by future strategies (n = 0): <none>
[11:01:55.615] {
[11:01:55.615]     {
[11:01:55.615]         {
[11:01:55.615]             ...future.startTime <- base::Sys.time()
[11:01:55.615]             {
[11:01:55.615]                 {
[11:01:55.615]                   {
[11:01:55.615]                     {
[11:01:55.615]                       base::local({
[11:01:55.615]                         has_future <- base::requireNamespace("future", 
[11:01:55.615]                           quietly = TRUE)
[11:01:55.615]                         if (has_future) {
[11:01:55.615]                           ns <- base::getNamespace("future")
[11:01:55.615]                           version <- ns[[".package"]][["version"]]
[11:01:55.615]                           if (is.null(version)) 
[11:01:55.615]                             version <- utils::packageVersion("future")
[11:01:55.615]                         }
[11:01:55.615]                         else {
[11:01:55.615]                           version <- NULL
[11:01:55.615]                         }
[11:01:55.615]                         if (!has_future || version < "1.8.0") {
[11:01:55.615]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.615]                             "", base::R.version$version.string), 
[11:01:55.615]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.615]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.615]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.615]                               "release", "version")], collapse = " "), 
[11:01:55.615]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.615]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.615]                             info)
[11:01:55.615]                           info <- base::paste(info, collapse = "; ")
[11:01:55.615]                           if (!has_future) {
[11:01:55.615]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.615]                               info)
[11:01:55.615]                           }
[11:01:55.615]                           else {
[11:01:55.615]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.615]                               info, version)
[11:01:55.615]                           }
[11:01:55.615]                           base::stop(msg)
[11:01:55.615]                         }
[11:01:55.615]                       })
[11:01:55.615]                     }
[11:01:55.615]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.615]                     base::options(mc.cores = 1L)
[11:01:55.615]                   }
[11:01:55.615]                   ...future.strategy.old <- future::plan("list")
[11:01:55.615]                   options(future.plan = NULL)
[11:01:55.615]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.615]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.615]                 }
[11:01:55.615]                 ...future.workdir <- getwd()
[11:01:55.615]             }
[11:01:55.615]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.615]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.615]         }
[11:01:55.615]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.615]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.615]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.615]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.615]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.615]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.615]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.615]             base::names(...future.oldOptions))
[11:01:55.615]     }
[11:01:55.615]     if (FALSE) {
[11:01:55.615]     }
[11:01:55.615]     else {
[11:01:55.615]         if (TRUE) {
[11:01:55.615]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.615]                 open = "w")
[11:01:55.615]         }
[11:01:55.615]         else {
[11:01:55.615]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.615]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.615]         }
[11:01:55.615]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.615]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.615]             base::sink(type = "output", split = FALSE)
[11:01:55.615]             base::close(...future.stdout)
[11:01:55.615]         }, add = TRUE)
[11:01:55.615]     }
[11:01:55.615]     ...future.frame <- base::sys.nframe()
[11:01:55.615]     ...future.conditions <- base::list()
[11:01:55.615]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.615]     if (FALSE) {
[11:01:55.615]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.615]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.615]     }
[11:01:55.615]     ...future.result <- base::tryCatch({
[11:01:55.615]         base::withCallingHandlers({
[11:01:55.615]             ...future.value <- base::withVisible(base::local({
[11:01:55.615]                 ...future.makeSendCondition <- base::local({
[11:01:55.615]                   sendCondition <- NULL
[11:01:55.615]                   function(frame = 1L) {
[11:01:55.615]                     if (is.function(sendCondition)) 
[11:01:55.615]                       return(sendCondition)
[11:01:55.615]                     ns <- getNamespace("parallel")
[11:01:55.615]                     if (exists("sendData", mode = "function", 
[11:01:55.615]                       envir = ns)) {
[11:01:55.615]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.615]                         envir = ns)
[11:01:55.615]                       envir <- sys.frame(frame)
[11:01:55.615]                       master <- NULL
[11:01:55.615]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.615]                         !identical(envir, emptyenv())) {
[11:01:55.615]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.615]                           inherits = FALSE)) {
[11:01:55.615]                           master <- get("master", mode = "list", 
[11:01:55.615]                             envir = envir, inherits = FALSE)
[11:01:55.615]                           if (inherits(master, c("SOCKnode", 
[11:01:55.615]                             "SOCK0node"))) {
[11:01:55.615]                             sendCondition <<- function(cond) {
[11:01:55.615]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.615]                                 success = TRUE)
[11:01:55.615]                               parallel_sendData(master, data)
[11:01:55.615]                             }
[11:01:55.615]                             return(sendCondition)
[11:01:55.615]                           }
[11:01:55.615]                         }
[11:01:55.615]                         frame <- frame + 1L
[11:01:55.615]                         envir <- sys.frame(frame)
[11:01:55.615]                       }
[11:01:55.615]                     }
[11:01:55.615]                     sendCondition <<- function(cond) NULL
[11:01:55.615]                   }
[11:01:55.615]                 })
[11:01:55.615]                 withCallingHandlers({
[11:01:55.615]                   {
[11:01:55.615]                     b <- a * ii
[11:01:55.615]                     a <- 0
[11:01:55.615]                     b
[11:01:55.615]                   }
[11:01:55.615]                 }, immediateCondition = function(cond) {
[11:01:55.615]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.615]                   sendCondition(cond)
[11:01:55.615]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.615]                   {
[11:01:55.615]                     inherits <- base::inherits
[11:01:55.615]                     invokeRestart <- base::invokeRestart
[11:01:55.615]                     is.null <- base::is.null
[11:01:55.615]                     muffled <- FALSE
[11:01:55.615]                     if (inherits(cond, "message")) {
[11:01:55.615]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.615]                       if (muffled) 
[11:01:55.615]                         invokeRestart("muffleMessage")
[11:01:55.615]                     }
[11:01:55.615]                     else if (inherits(cond, "warning")) {
[11:01:55.615]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.615]                       if (muffled) 
[11:01:55.615]                         invokeRestart("muffleWarning")
[11:01:55.615]                     }
[11:01:55.615]                     else if (inherits(cond, "condition")) {
[11:01:55.615]                       if (!is.null(pattern)) {
[11:01:55.615]                         computeRestarts <- base::computeRestarts
[11:01:55.615]                         grepl <- base::grepl
[11:01:55.615]                         restarts <- computeRestarts(cond)
[11:01:55.615]                         for (restart in restarts) {
[11:01:55.615]                           name <- restart$name
[11:01:55.615]                           if (is.null(name)) 
[11:01:55.615]                             next
[11:01:55.615]                           if (!grepl(pattern, name)) 
[11:01:55.615]                             next
[11:01:55.615]                           invokeRestart(restart)
[11:01:55.615]                           muffled <- TRUE
[11:01:55.615]                           break
[11:01:55.615]                         }
[11:01:55.615]                       }
[11:01:55.615]                     }
[11:01:55.615]                     invisible(muffled)
[11:01:55.615]                   }
[11:01:55.615]                   muffleCondition(cond)
[11:01:55.615]                 })
[11:01:55.615]             }))
[11:01:55.615]             future::FutureResult(value = ...future.value$value, 
[11:01:55.615]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.615]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.615]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.615]                     ...future.globalenv.names))
[11:01:55.615]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.615]         }, condition = base::local({
[11:01:55.615]             c <- base::c
[11:01:55.615]             inherits <- base::inherits
[11:01:55.615]             invokeRestart <- base::invokeRestart
[11:01:55.615]             length <- base::length
[11:01:55.615]             list <- base::list
[11:01:55.615]             seq.int <- base::seq.int
[11:01:55.615]             signalCondition <- base::signalCondition
[11:01:55.615]             sys.calls <- base::sys.calls
[11:01:55.615]             `[[` <- base::`[[`
[11:01:55.615]             `+` <- base::`+`
[11:01:55.615]             `<<-` <- base::`<<-`
[11:01:55.615]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.615]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.615]                   3L)]
[11:01:55.615]             }
[11:01:55.615]             function(cond) {
[11:01:55.615]                 is_error <- inherits(cond, "error")
[11:01:55.615]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.615]                   NULL)
[11:01:55.615]                 if (is_error) {
[11:01:55.615]                   sessionInformation <- function() {
[11:01:55.615]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.615]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.615]                       search = base::search(), system = base::Sys.info())
[11:01:55.615]                   }
[11:01:55.615]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.615]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.615]                     cond$call), session = sessionInformation(), 
[11:01:55.615]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.615]                   signalCondition(cond)
[11:01:55.615]                 }
[11:01:55.615]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.615]                 "immediateCondition"))) {
[11:01:55.615]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.615]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.615]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.615]                   if (TRUE && !signal) {
[11:01:55.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.615]                     {
[11:01:55.615]                       inherits <- base::inherits
[11:01:55.615]                       invokeRestart <- base::invokeRestart
[11:01:55.615]                       is.null <- base::is.null
[11:01:55.615]                       muffled <- FALSE
[11:01:55.615]                       if (inherits(cond, "message")) {
[11:01:55.615]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.615]                         if (muffled) 
[11:01:55.615]                           invokeRestart("muffleMessage")
[11:01:55.615]                       }
[11:01:55.615]                       else if (inherits(cond, "warning")) {
[11:01:55.615]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.615]                         if (muffled) 
[11:01:55.615]                           invokeRestart("muffleWarning")
[11:01:55.615]                       }
[11:01:55.615]                       else if (inherits(cond, "condition")) {
[11:01:55.615]                         if (!is.null(pattern)) {
[11:01:55.615]                           computeRestarts <- base::computeRestarts
[11:01:55.615]                           grepl <- base::grepl
[11:01:55.615]                           restarts <- computeRestarts(cond)
[11:01:55.615]                           for (restart in restarts) {
[11:01:55.615]                             name <- restart$name
[11:01:55.615]                             if (is.null(name)) 
[11:01:55.615]                               next
[11:01:55.615]                             if (!grepl(pattern, name)) 
[11:01:55.615]                               next
[11:01:55.615]                             invokeRestart(restart)
[11:01:55.615]                             muffled <- TRUE
[11:01:55.615]                             break
[11:01:55.615]                           }
[11:01:55.615]                         }
[11:01:55.615]                       }
[11:01:55.615]                       invisible(muffled)
[11:01:55.615]                     }
[11:01:55.615]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.615]                   }
[11:01:55.615]                 }
[11:01:55.615]                 else {
[11:01:55.615]                   if (TRUE) {
[11:01:55.615]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.615]                     {
[11:01:55.615]                       inherits <- base::inherits
[11:01:55.615]                       invokeRestart <- base::invokeRestart
[11:01:55.615]                       is.null <- base::is.null
[11:01:55.615]                       muffled <- FALSE
[11:01:55.615]                       if (inherits(cond, "message")) {
[11:01:55.615]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.615]                         if (muffled) 
[11:01:55.615]                           invokeRestart("muffleMessage")
[11:01:55.615]                       }
[11:01:55.615]                       else if (inherits(cond, "warning")) {
[11:01:55.615]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.615]                         if (muffled) 
[11:01:55.615]                           invokeRestart("muffleWarning")
[11:01:55.615]                       }
[11:01:55.615]                       else if (inherits(cond, "condition")) {
[11:01:55.615]                         if (!is.null(pattern)) {
[11:01:55.615]                           computeRestarts <- base::computeRestarts
[11:01:55.615]                           grepl <- base::grepl
[11:01:55.615]                           restarts <- computeRestarts(cond)
[11:01:55.615]                           for (restart in restarts) {
[11:01:55.615]                             name <- restart$name
[11:01:55.615]                             if (is.null(name)) 
[11:01:55.615]                               next
[11:01:55.615]                             if (!grepl(pattern, name)) 
[11:01:55.615]                               next
[11:01:55.615]                             invokeRestart(restart)
[11:01:55.615]                             muffled <- TRUE
[11:01:55.615]                             break
[11:01:55.615]                           }
[11:01:55.615]                         }
[11:01:55.615]                       }
[11:01:55.615]                       invisible(muffled)
[11:01:55.615]                     }
[11:01:55.615]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.615]                   }
[11:01:55.615]                 }
[11:01:55.615]             }
[11:01:55.615]         }))
[11:01:55.615]     }, error = function(ex) {
[11:01:55.615]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.615]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.615]                 ...future.rng), started = ...future.startTime, 
[11:01:55.615]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.615]             version = "1.8"), class = "FutureResult")
[11:01:55.615]     }, finally = {
[11:01:55.615]         if (!identical(...future.workdir, getwd())) 
[11:01:55.615]             setwd(...future.workdir)
[11:01:55.615]         {
[11:01:55.615]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.615]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.615]             }
[11:01:55.615]             base::options(...future.oldOptions)
[11:01:55.615]             if (.Platform$OS.type == "windows") {
[11:01:55.615]                 old_names <- names(...future.oldEnvVars)
[11:01:55.615]                 envs <- base::Sys.getenv()
[11:01:55.615]                 names <- names(envs)
[11:01:55.615]                 common <- intersect(names, old_names)
[11:01:55.615]                 added <- setdiff(names, old_names)
[11:01:55.615]                 removed <- setdiff(old_names, names)
[11:01:55.615]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.615]                   envs[common]]
[11:01:55.615]                 NAMES <- toupper(changed)
[11:01:55.615]                 args <- list()
[11:01:55.615]                 for (kk in seq_along(NAMES)) {
[11:01:55.615]                   name <- changed[[kk]]
[11:01:55.615]                   NAME <- NAMES[[kk]]
[11:01:55.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.615]                     next
[11:01:55.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.615]                 }
[11:01:55.615]                 NAMES <- toupper(added)
[11:01:55.615]                 for (kk in seq_along(NAMES)) {
[11:01:55.615]                   name <- added[[kk]]
[11:01:55.615]                   NAME <- NAMES[[kk]]
[11:01:55.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.615]                     next
[11:01:55.615]                   args[[name]] <- ""
[11:01:55.615]                 }
[11:01:55.615]                 NAMES <- toupper(removed)
[11:01:55.615]                 for (kk in seq_along(NAMES)) {
[11:01:55.615]                   name <- removed[[kk]]
[11:01:55.615]                   NAME <- NAMES[[kk]]
[11:01:55.615]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.615]                     next
[11:01:55.615]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.615]                 }
[11:01:55.615]                 if (length(args) > 0) 
[11:01:55.615]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.615]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.615]             }
[11:01:55.615]             else {
[11:01:55.615]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.615]             }
[11:01:55.615]             {
[11:01:55.615]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.615]                   0L) {
[11:01:55.615]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.615]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.615]                   base::options(opts)
[11:01:55.615]                 }
[11:01:55.615]                 {
[11:01:55.615]                   {
[11:01:55.615]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.615]                     NULL
[11:01:55.615]                   }
[11:01:55.615]                   options(future.plan = NULL)
[11:01:55.615]                   if (is.na(NA_character_)) 
[11:01:55.615]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.615]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.615]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.615]                     .init = FALSE)
[11:01:55.615]                 }
[11:01:55.615]             }
[11:01:55.615]         }
[11:01:55.615]     })
[11:01:55.615]     if (TRUE) {
[11:01:55.615]         base::sink(type = "output", split = FALSE)
[11:01:55.615]         if (TRUE) {
[11:01:55.615]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.615]         }
[11:01:55.615]         else {
[11:01:55.615]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.615]         }
[11:01:55.615]         base::close(...future.stdout)
[11:01:55.615]         ...future.stdout <- NULL
[11:01:55.615]     }
[11:01:55.615]     ...future.result$conditions <- ...future.conditions
[11:01:55.615]     ...future.result$finished <- base::Sys.time()
[11:01:55.615]     ...future.result
[11:01:55.615] }
[11:01:55.617] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:55.628] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.628] - Validating connection of MultisessionFuture
[11:01:55.629] - received message: FutureResult
[11:01:55.629] - Received FutureResult
[11:01:55.629] - Erased future from FutureRegistry
[11:01:55.629] result() for ClusterFuture ...
[11:01:55.629] - result already collected: FutureResult
[11:01:55.629] result() for ClusterFuture ... done
[11:01:55.629] signalConditions() ...
[11:01:55.629]  - include = ‘immediateCondition’
[11:01:55.629]  - exclude = 
[11:01:55.629]  - resignal = FALSE
[11:01:55.630]  - Number of conditions: 1
[11:01:55.630] signalConditions() ... done
[11:01:55.630] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.630] result() for ClusterFuture ...
[11:01:55.630] - result already collected: FutureResult
[11:01:55.630] result() for ClusterFuture ... done
[11:01:55.630] result() for ClusterFuture ...
[11:01:55.630] - result already collected: FutureResult
[11:01:55.630] result() for ClusterFuture ... done
[11:01:55.630] signalConditions() ...
[11:01:55.630]  - include = ‘immediateCondition’
[11:01:55.630]  - exclude = 
[11:01:55.631]  - resignal = FALSE
[11:01:55.631]  - Number of conditions: 1
[11:01:55.631] signalConditions() ... done
[11:01:55.631] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[11:01:55.632] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:55.632] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:55.632] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:55.633] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:55.633] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[11:01:55.633] MultisessionFuture started
[11:01:55.633] - Launch lazy future ... done
[11:01:55.634] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.634] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.635] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.637] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.637] Searching for globals ... DONE
[11:01:55.637] Resolving globals: TRUE
[11:01:55.637] Resolving any globals that are futures ...
[11:01:55.637] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.637] Resolving any globals that are futures ... DONE
[11:01:55.638] Resolving futures part of globals (recursively) ...
[11:01:55.638] resolve() on list ...
[11:01:55.638]  recursive: 99
[11:01:55.640]  length: 2
[11:01:55.640]  elements: ‘a’, ‘ii’
[11:01:55.640]  length: 1 (resolved future 1)
[11:01:55.640]  length: 0 (resolved future 2)
[11:01:55.640] resolve() on list ... DONE
[11:01:55.641] - globals: [2] ‘a’, ‘ii’
[11:01:55.641] Resolving futures part of globals (recursively) ... DONE
[11:01:55.641] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:55.641] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:55.641] - globals: [2] ‘a’, ‘ii’
[11:01:55.641] 
[11:01:55.641] getGlobalsAndPackages() ... DONE
[11:01:55.642] run() for ‘Future’ ...
[11:01:55.642] - state: ‘created’
[11:01:55.642] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.655] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.655] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.656]   - Field: ‘node’
[11:01:55.656]   - Field: ‘label’
[11:01:55.656]   - Field: ‘local’
[11:01:55.656]   - Field: ‘owner’
[11:01:55.656]   - Field: ‘envir’
[11:01:55.656]   - Field: ‘workers’
[11:01:55.656]   - Field: ‘packages’
[11:01:55.656]   - Field: ‘gc’
[11:01:55.656]   - Field: ‘conditions’
[11:01:55.656]   - Field: ‘persistent’
[11:01:55.656]   - Field: ‘expr’
[11:01:55.656]   - Field: ‘uuid’
[11:01:55.657]   - Field: ‘seed’
[11:01:55.657]   - Field: ‘version’
[11:01:55.657]   - Field: ‘result’
[11:01:55.657]   - Field: ‘asynchronous’
[11:01:55.657]   - Field: ‘calls’
[11:01:55.657]   - Field: ‘globals’
[11:01:55.657]   - Field: ‘stdout’
[11:01:55.657]   - Field: ‘earlySignal’
[11:01:55.657]   - Field: ‘lazy’
[11:01:55.657]   - Field: ‘state’
[11:01:55.657] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.657] - Launch lazy future ...
[11:01:55.658] Packages needed by the future expression (n = 0): <none>
[11:01:55.658] Packages needed by future strategies (n = 0): <none>
[11:01:55.658] {
[11:01:55.658]     {
[11:01:55.658]         {
[11:01:55.658]             ...future.startTime <- base::Sys.time()
[11:01:55.658]             {
[11:01:55.658]                 {
[11:01:55.658]                   {
[11:01:55.658]                     {
[11:01:55.658]                       base::local({
[11:01:55.658]                         has_future <- base::requireNamespace("future", 
[11:01:55.658]                           quietly = TRUE)
[11:01:55.658]                         if (has_future) {
[11:01:55.658]                           ns <- base::getNamespace("future")
[11:01:55.658]                           version <- ns[[".package"]][["version"]]
[11:01:55.658]                           if (is.null(version)) 
[11:01:55.658]                             version <- utils::packageVersion("future")
[11:01:55.658]                         }
[11:01:55.658]                         else {
[11:01:55.658]                           version <- NULL
[11:01:55.658]                         }
[11:01:55.658]                         if (!has_future || version < "1.8.0") {
[11:01:55.658]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.658]                             "", base::R.version$version.string), 
[11:01:55.658]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.658]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.658]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.658]                               "release", "version")], collapse = " "), 
[11:01:55.658]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.658]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.658]                             info)
[11:01:55.658]                           info <- base::paste(info, collapse = "; ")
[11:01:55.658]                           if (!has_future) {
[11:01:55.658]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.658]                               info)
[11:01:55.658]                           }
[11:01:55.658]                           else {
[11:01:55.658]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.658]                               info, version)
[11:01:55.658]                           }
[11:01:55.658]                           base::stop(msg)
[11:01:55.658]                         }
[11:01:55.658]                       })
[11:01:55.658]                     }
[11:01:55.658]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.658]                     base::options(mc.cores = 1L)
[11:01:55.658]                   }
[11:01:55.658]                   ...future.strategy.old <- future::plan("list")
[11:01:55.658]                   options(future.plan = NULL)
[11:01:55.658]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.658]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.658]                 }
[11:01:55.658]                 ...future.workdir <- getwd()
[11:01:55.658]             }
[11:01:55.658]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.658]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.658]         }
[11:01:55.658]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.658]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.658]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.658]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.658]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.658]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.658]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.658]             base::names(...future.oldOptions))
[11:01:55.658]     }
[11:01:55.658]     if (FALSE) {
[11:01:55.658]     }
[11:01:55.658]     else {
[11:01:55.658]         if (TRUE) {
[11:01:55.658]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.658]                 open = "w")
[11:01:55.658]         }
[11:01:55.658]         else {
[11:01:55.658]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.658]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.658]         }
[11:01:55.658]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.658]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.658]             base::sink(type = "output", split = FALSE)
[11:01:55.658]             base::close(...future.stdout)
[11:01:55.658]         }, add = TRUE)
[11:01:55.658]     }
[11:01:55.658]     ...future.frame <- base::sys.nframe()
[11:01:55.658]     ...future.conditions <- base::list()
[11:01:55.658]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.658]     if (FALSE) {
[11:01:55.658]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.658]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.658]     }
[11:01:55.658]     ...future.result <- base::tryCatch({
[11:01:55.658]         base::withCallingHandlers({
[11:01:55.658]             ...future.value <- base::withVisible(base::local({
[11:01:55.658]                 ...future.makeSendCondition <- base::local({
[11:01:55.658]                   sendCondition <- NULL
[11:01:55.658]                   function(frame = 1L) {
[11:01:55.658]                     if (is.function(sendCondition)) 
[11:01:55.658]                       return(sendCondition)
[11:01:55.658]                     ns <- getNamespace("parallel")
[11:01:55.658]                     if (exists("sendData", mode = "function", 
[11:01:55.658]                       envir = ns)) {
[11:01:55.658]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.658]                         envir = ns)
[11:01:55.658]                       envir <- sys.frame(frame)
[11:01:55.658]                       master <- NULL
[11:01:55.658]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.658]                         !identical(envir, emptyenv())) {
[11:01:55.658]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.658]                           inherits = FALSE)) {
[11:01:55.658]                           master <- get("master", mode = "list", 
[11:01:55.658]                             envir = envir, inherits = FALSE)
[11:01:55.658]                           if (inherits(master, c("SOCKnode", 
[11:01:55.658]                             "SOCK0node"))) {
[11:01:55.658]                             sendCondition <<- function(cond) {
[11:01:55.658]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.658]                                 success = TRUE)
[11:01:55.658]                               parallel_sendData(master, data)
[11:01:55.658]                             }
[11:01:55.658]                             return(sendCondition)
[11:01:55.658]                           }
[11:01:55.658]                         }
[11:01:55.658]                         frame <- frame + 1L
[11:01:55.658]                         envir <- sys.frame(frame)
[11:01:55.658]                       }
[11:01:55.658]                     }
[11:01:55.658]                     sendCondition <<- function(cond) NULL
[11:01:55.658]                   }
[11:01:55.658]                 })
[11:01:55.658]                 withCallingHandlers({
[11:01:55.658]                   {
[11:01:55.658]                     b <- a * ii
[11:01:55.658]                     a <- 0
[11:01:55.658]                     b
[11:01:55.658]                   }
[11:01:55.658]                 }, immediateCondition = function(cond) {
[11:01:55.658]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.658]                   sendCondition(cond)
[11:01:55.658]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.658]                   {
[11:01:55.658]                     inherits <- base::inherits
[11:01:55.658]                     invokeRestart <- base::invokeRestart
[11:01:55.658]                     is.null <- base::is.null
[11:01:55.658]                     muffled <- FALSE
[11:01:55.658]                     if (inherits(cond, "message")) {
[11:01:55.658]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.658]                       if (muffled) 
[11:01:55.658]                         invokeRestart("muffleMessage")
[11:01:55.658]                     }
[11:01:55.658]                     else if (inherits(cond, "warning")) {
[11:01:55.658]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.658]                       if (muffled) 
[11:01:55.658]                         invokeRestart("muffleWarning")
[11:01:55.658]                     }
[11:01:55.658]                     else if (inherits(cond, "condition")) {
[11:01:55.658]                       if (!is.null(pattern)) {
[11:01:55.658]                         computeRestarts <- base::computeRestarts
[11:01:55.658]                         grepl <- base::grepl
[11:01:55.658]                         restarts <- computeRestarts(cond)
[11:01:55.658]                         for (restart in restarts) {
[11:01:55.658]                           name <- restart$name
[11:01:55.658]                           if (is.null(name)) 
[11:01:55.658]                             next
[11:01:55.658]                           if (!grepl(pattern, name)) 
[11:01:55.658]                             next
[11:01:55.658]                           invokeRestart(restart)
[11:01:55.658]                           muffled <- TRUE
[11:01:55.658]                           break
[11:01:55.658]                         }
[11:01:55.658]                       }
[11:01:55.658]                     }
[11:01:55.658]                     invisible(muffled)
[11:01:55.658]                   }
[11:01:55.658]                   muffleCondition(cond)
[11:01:55.658]                 })
[11:01:55.658]             }))
[11:01:55.658]             future::FutureResult(value = ...future.value$value, 
[11:01:55.658]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.658]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.658]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.658]                     ...future.globalenv.names))
[11:01:55.658]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.658]         }, condition = base::local({
[11:01:55.658]             c <- base::c
[11:01:55.658]             inherits <- base::inherits
[11:01:55.658]             invokeRestart <- base::invokeRestart
[11:01:55.658]             length <- base::length
[11:01:55.658]             list <- base::list
[11:01:55.658]             seq.int <- base::seq.int
[11:01:55.658]             signalCondition <- base::signalCondition
[11:01:55.658]             sys.calls <- base::sys.calls
[11:01:55.658]             `[[` <- base::`[[`
[11:01:55.658]             `+` <- base::`+`
[11:01:55.658]             `<<-` <- base::`<<-`
[11:01:55.658]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.658]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.658]                   3L)]
[11:01:55.658]             }
[11:01:55.658]             function(cond) {
[11:01:55.658]                 is_error <- inherits(cond, "error")
[11:01:55.658]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.658]                   NULL)
[11:01:55.658]                 if (is_error) {
[11:01:55.658]                   sessionInformation <- function() {
[11:01:55.658]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.658]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.658]                       search = base::search(), system = base::Sys.info())
[11:01:55.658]                   }
[11:01:55.658]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.658]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.658]                     cond$call), session = sessionInformation(), 
[11:01:55.658]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.658]                   signalCondition(cond)
[11:01:55.658]                 }
[11:01:55.658]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.658]                 "immediateCondition"))) {
[11:01:55.658]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.658]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.658]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.658]                   if (TRUE && !signal) {
[11:01:55.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.658]                     {
[11:01:55.658]                       inherits <- base::inherits
[11:01:55.658]                       invokeRestart <- base::invokeRestart
[11:01:55.658]                       is.null <- base::is.null
[11:01:55.658]                       muffled <- FALSE
[11:01:55.658]                       if (inherits(cond, "message")) {
[11:01:55.658]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.658]                         if (muffled) 
[11:01:55.658]                           invokeRestart("muffleMessage")
[11:01:55.658]                       }
[11:01:55.658]                       else if (inherits(cond, "warning")) {
[11:01:55.658]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.658]                         if (muffled) 
[11:01:55.658]                           invokeRestart("muffleWarning")
[11:01:55.658]                       }
[11:01:55.658]                       else if (inherits(cond, "condition")) {
[11:01:55.658]                         if (!is.null(pattern)) {
[11:01:55.658]                           computeRestarts <- base::computeRestarts
[11:01:55.658]                           grepl <- base::grepl
[11:01:55.658]                           restarts <- computeRestarts(cond)
[11:01:55.658]                           for (restart in restarts) {
[11:01:55.658]                             name <- restart$name
[11:01:55.658]                             if (is.null(name)) 
[11:01:55.658]                               next
[11:01:55.658]                             if (!grepl(pattern, name)) 
[11:01:55.658]                               next
[11:01:55.658]                             invokeRestart(restart)
[11:01:55.658]                             muffled <- TRUE
[11:01:55.658]                             break
[11:01:55.658]                           }
[11:01:55.658]                         }
[11:01:55.658]                       }
[11:01:55.658]                       invisible(muffled)
[11:01:55.658]                     }
[11:01:55.658]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.658]                   }
[11:01:55.658]                 }
[11:01:55.658]                 else {
[11:01:55.658]                   if (TRUE) {
[11:01:55.658]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.658]                     {
[11:01:55.658]                       inherits <- base::inherits
[11:01:55.658]                       invokeRestart <- base::invokeRestart
[11:01:55.658]                       is.null <- base::is.null
[11:01:55.658]                       muffled <- FALSE
[11:01:55.658]                       if (inherits(cond, "message")) {
[11:01:55.658]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.658]                         if (muffled) 
[11:01:55.658]                           invokeRestart("muffleMessage")
[11:01:55.658]                       }
[11:01:55.658]                       else if (inherits(cond, "warning")) {
[11:01:55.658]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.658]                         if (muffled) 
[11:01:55.658]                           invokeRestart("muffleWarning")
[11:01:55.658]                       }
[11:01:55.658]                       else if (inherits(cond, "condition")) {
[11:01:55.658]                         if (!is.null(pattern)) {
[11:01:55.658]                           computeRestarts <- base::computeRestarts
[11:01:55.658]                           grepl <- base::grepl
[11:01:55.658]                           restarts <- computeRestarts(cond)
[11:01:55.658]                           for (restart in restarts) {
[11:01:55.658]                             name <- restart$name
[11:01:55.658]                             if (is.null(name)) 
[11:01:55.658]                               next
[11:01:55.658]                             if (!grepl(pattern, name)) 
[11:01:55.658]                               next
[11:01:55.658]                             invokeRestart(restart)
[11:01:55.658]                             muffled <- TRUE
[11:01:55.658]                             break
[11:01:55.658]                           }
[11:01:55.658]                         }
[11:01:55.658]                       }
[11:01:55.658]                       invisible(muffled)
[11:01:55.658]                     }
[11:01:55.658]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.658]                   }
[11:01:55.658]                 }
[11:01:55.658]             }
[11:01:55.658]         }))
[11:01:55.658]     }, error = function(ex) {
[11:01:55.658]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.658]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.658]                 ...future.rng), started = ...future.startTime, 
[11:01:55.658]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.658]             version = "1.8"), class = "FutureResult")
[11:01:55.658]     }, finally = {
[11:01:55.658]         if (!identical(...future.workdir, getwd())) 
[11:01:55.658]             setwd(...future.workdir)
[11:01:55.658]         {
[11:01:55.658]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.658]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.658]             }
[11:01:55.658]             base::options(...future.oldOptions)
[11:01:55.658]             if (.Platform$OS.type == "windows") {
[11:01:55.658]                 old_names <- names(...future.oldEnvVars)
[11:01:55.658]                 envs <- base::Sys.getenv()
[11:01:55.658]                 names <- names(envs)
[11:01:55.658]                 common <- intersect(names, old_names)
[11:01:55.658]                 added <- setdiff(names, old_names)
[11:01:55.658]                 removed <- setdiff(old_names, names)
[11:01:55.658]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.658]                   envs[common]]
[11:01:55.658]                 NAMES <- toupper(changed)
[11:01:55.658]                 args <- list()
[11:01:55.658]                 for (kk in seq_along(NAMES)) {
[11:01:55.658]                   name <- changed[[kk]]
[11:01:55.658]                   NAME <- NAMES[[kk]]
[11:01:55.658]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.658]                     next
[11:01:55.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.658]                 }
[11:01:55.658]                 NAMES <- toupper(added)
[11:01:55.658]                 for (kk in seq_along(NAMES)) {
[11:01:55.658]                   name <- added[[kk]]
[11:01:55.658]                   NAME <- NAMES[[kk]]
[11:01:55.658]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.658]                     next
[11:01:55.658]                   args[[name]] <- ""
[11:01:55.658]                 }
[11:01:55.658]                 NAMES <- toupper(removed)
[11:01:55.658]                 for (kk in seq_along(NAMES)) {
[11:01:55.658]                   name <- removed[[kk]]
[11:01:55.658]                   NAME <- NAMES[[kk]]
[11:01:55.658]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.658]                     next
[11:01:55.658]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.658]                 }
[11:01:55.658]                 if (length(args) > 0) 
[11:01:55.658]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.658]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.658]             }
[11:01:55.658]             else {
[11:01:55.658]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.658]             }
[11:01:55.658]             {
[11:01:55.658]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.658]                   0L) {
[11:01:55.658]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.658]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.658]                   base::options(opts)
[11:01:55.658]                 }
[11:01:55.658]                 {
[11:01:55.658]                   {
[11:01:55.658]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.658]                     NULL
[11:01:55.658]                   }
[11:01:55.658]                   options(future.plan = NULL)
[11:01:55.658]                   if (is.na(NA_character_)) 
[11:01:55.658]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.658]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.658]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.658]                     .init = FALSE)
[11:01:55.658]                 }
[11:01:55.658]             }
[11:01:55.658]         }
[11:01:55.658]     })
[11:01:55.658]     if (TRUE) {
[11:01:55.658]         base::sink(type = "output", split = FALSE)
[11:01:55.658]         if (TRUE) {
[11:01:55.658]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.658]         }
[11:01:55.658]         else {
[11:01:55.658]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.658]         }
[11:01:55.658]         base::close(...future.stdout)
[11:01:55.658]         ...future.stdout <- NULL
[11:01:55.658]     }
[11:01:55.658]     ...future.result$conditions <- ...future.conditions
[11:01:55.658]     ...future.result$finished <- base::Sys.time()
[11:01:55.658]     ...future.result
[11:01:55.658] }
[11:01:55.660] Poll #1 (0): usedNodes() = 2, workers = 2
[11:01:55.671] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.671] - Validating connection of MultisessionFuture
[11:01:55.671] - received message: FutureResult
[11:01:55.671] - Received FutureResult
[11:01:55.672] - Erased future from FutureRegistry
[11:01:55.672] result() for ClusterFuture ...
[11:01:55.672] - result already collected: FutureResult
[11:01:55.672] result() for ClusterFuture ... done
[11:01:55.672] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.672] result() for ClusterFuture ...
[11:01:55.672] - result already collected: FutureResult
[11:01:55.672] result() for ClusterFuture ... done
[11:01:55.672] result() for ClusterFuture ...
[11:01:55.672] - result already collected: FutureResult
[11:01:55.672] result() for ClusterFuture ... done
[11:01:55.673] Exporting 2 global objects (382 bytes) to cluster node #2 ...
[11:01:55.673] Exporting ‘a’ (39 bytes) to cluster node #2 ...
[11:01:55.673] Exporting ‘a’ (39 bytes) to cluster node #2 ... DONE
[11:01:55.674] Exporting ‘ii’ (35 bytes) to cluster node #2 ...
[11:01:55.674] Exporting ‘ii’ (35 bytes) to cluster node #2 ... DONE
[11:01:55.674] Exporting 2 global objects (382 bytes) to cluster node #2 ... DONE
[11:01:55.675] MultisessionFuture started
[11:01:55.675] - Launch lazy future ... done
[11:01:55.675] run() for ‘MultisessionFuture’ ... done
[11:01:55.675] result() for ClusterFuture ...
[11:01:55.675] - result already collected: FutureResult
[11:01:55.675] result() for ClusterFuture ... done
[11:01:55.675] result() for ClusterFuture ...
[11:01:55.675] - result already collected: FutureResult
[11:01:55.675] result() for ClusterFuture ... done
[11:01:55.676] result() for ClusterFuture ...
[11:01:55.676] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.676] - Validating connection of MultisessionFuture
[11:01:55.676] - received message: FutureResult
[11:01:55.676] - Received FutureResult
[11:01:55.676] - Erased future from FutureRegistry
[11:01:55.676] result() for ClusterFuture ...
[11:01:55.676] - result already collected: FutureResult
[11:01:55.676] result() for ClusterFuture ... done
[11:01:55.676] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.677] result() for ClusterFuture ... done
[11:01:55.677] result() for ClusterFuture ...
[11:01:55.677] - result already collected: FutureResult
[11:01:55.677] result() for ClusterFuture ... done
[11:01:55.677] result() for ClusterFuture ...
[11:01:55.677] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.677] - Validating connection of MultisessionFuture
[11:01:55.716] - received message: FutureResult
[11:01:55.716] - Received FutureResult
[11:01:55.716] - Erased future from FutureRegistry
[11:01:55.716] result() for ClusterFuture ...
[11:01:55.716] - result already collected: FutureResult
[11:01:55.717] result() for ClusterFuture ... done
[11:01:55.717] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.717] result() for ClusterFuture ... done
[11:01:55.717] result() for ClusterFuture ...
[11:01:55.717] - result already collected: FutureResult
[11:01:55.717] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.717] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.718] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.719] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.720] Searching for globals ... DONE
[11:01:55.720] Resolving globals: TRUE
[11:01:55.720] Resolving any globals that are futures ...
[11:01:55.720] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.720] Resolving any globals that are futures ... DONE
[11:01:55.720] Resolving futures part of globals (recursively) ...
[11:01:55.720] resolve() on list ...
[11:01:55.721]  recursive: 99
[11:01:55.721]  length: 2
[11:01:55.721]  elements: ‘a’, ‘ii’
[11:01:55.721]  length: 1 (resolved future 1)
[11:01:55.721]  length: 0 (resolved future 2)
[11:01:55.721] resolve() on list ... DONE
[11:01:55.721] - globals: [2] ‘a’, ‘ii’
[11:01:55.721] Resolving futures part of globals (recursively) ... DONE
[11:01:55.721] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:55.722] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:55.722] - globals: [2] ‘a’, ‘ii’
[11:01:55.722] 
[11:01:55.722] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.722] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.723] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.724] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.725] Searching for globals ... DONE
[11:01:55.725] Resolving globals: TRUE
[11:01:55.725] Resolving any globals that are futures ...
[11:01:55.725] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.725] Resolving any globals that are futures ... DONE
[11:01:55.725] Resolving futures part of globals (recursively) ...
[11:01:55.725] resolve() on list ...
[11:01:55.726]  recursive: 99
[11:01:55.726]  length: 2
[11:01:55.726]  elements: ‘a’, ‘ii’
[11:01:55.726]  length: 1 (resolved future 1)
[11:01:55.726]  length: 0 (resolved future 2)
[11:01:55.726] resolve() on list ... DONE
[11:01:55.726] - globals: [2] ‘a’, ‘ii’
[11:01:55.726] Resolving futures part of globals (recursively) ... DONE
[11:01:55.726] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:55.727] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:55.727] - globals: [2] ‘a’, ‘ii’
[11:01:55.727] 
[11:01:55.727] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.727] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.728] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.729] - globals found: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.729] Searching for globals ... DONE
[11:01:55.730] Resolving globals: TRUE
[11:01:55.730] Resolving any globals that are futures ...
[11:01:55.730] - globals: [5] ‘{’, ‘<-’, ‘*’, ‘a’, ‘ii’
[11:01:55.730] Resolving any globals that are futures ... DONE
[11:01:55.730] Resolving futures part of globals (recursively) ...
[11:01:55.730] resolve() on list ...
[11:01:55.730]  recursive: 99
[11:01:55.730]  length: 2
[11:01:55.731]  elements: ‘a’, ‘ii’
[11:01:55.731]  length: 1 (resolved future 1)
[11:01:55.731]  length: 0 (resolved future 2)
[11:01:55.731] resolve() on list ... DONE
[11:01:55.731] - globals: [2] ‘a’, ‘ii’
[11:01:55.731] Resolving futures part of globals (recursively) ... DONE
[11:01:55.731] The total size of the 2 globals is 74 bytes (74 bytes)
[11:01:55.731] The total size of the 2 globals exported for future expression (‘{; b <- a * ii; a <- 0; b; }’) is 74 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (39 bytes of class ‘numeric’) and ‘ii’ (35 bytes of class ‘numeric’)
[11:01:55.732] - globals: [2] ‘a’, ‘ii’
[11:01:55.732] 
[11:01:55.732] getGlobalsAndPackages() ... DONE
[11:01:55.732] run() for ‘Future’ ...
[11:01:55.732] - state: ‘created’
[11:01:55.732] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.746] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.746] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.746]   - Field: ‘node’
[11:01:55.746]   - Field: ‘label’
[11:01:55.746]   - Field: ‘local’
[11:01:55.746]   - Field: ‘owner’
[11:01:55.746]   - Field: ‘envir’
[11:01:55.746]   - Field: ‘workers’
[11:01:55.747]   - Field: ‘packages’
[11:01:55.747]   - Field: ‘gc’
[11:01:55.747]   - Field: ‘conditions’
[11:01:55.747]   - Field: ‘persistent’
[11:01:55.747]   - Field: ‘expr’
[11:01:55.747]   - Field: ‘uuid’
[11:01:55.747]   - Field: ‘seed’
[11:01:55.747]   - Field: ‘version’
[11:01:55.747]   - Field: ‘result’
[11:01:55.747]   - Field: ‘asynchronous’
[11:01:55.747]   - Field: ‘calls’
[11:01:55.747]   - Field: ‘globals’
[11:01:55.748]   - Field: ‘stdout’
[11:01:55.748]   - Field: ‘earlySignal’
[11:01:55.748]   - Field: ‘lazy’
[11:01:55.748]   - Field: ‘state’
[11:01:55.748] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.748] - Launch lazy future ...
[11:01:55.748] Packages needed by the future expression (n = 0): <none>
[11:01:55.748] Packages needed by future strategies (n = 0): <none>
[11:01:55.749] {
[11:01:55.749]     {
[11:01:55.749]         {
[11:01:55.749]             ...future.startTime <- base::Sys.time()
[11:01:55.749]             {
[11:01:55.749]                 {
[11:01:55.749]                   {
[11:01:55.749]                     {
[11:01:55.749]                       base::local({
[11:01:55.749]                         has_future <- base::requireNamespace("future", 
[11:01:55.749]                           quietly = TRUE)
[11:01:55.749]                         if (has_future) {
[11:01:55.749]                           ns <- base::getNamespace("future")
[11:01:55.749]                           version <- ns[[".package"]][["version"]]
[11:01:55.749]                           if (is.null(version)) 
[11:01:55.749]                             version <- utils::packageVersion("future")
[11:01:55.749]                         }
[11:01:55.749]                         else {
[11:01:55.749]                           version <- NULL
[11:01:55.749]                         }
[11:01:55.749]                         if (!has_future || version < "1.8.0") {
[11:01:55.749]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.749]                             "", base::R.version$version.string), 
[11:01:55.749]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.749]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.749]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.749]                               "release", "version")], collapse = " "), 
[11:01:55.749]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.749]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.749]                             info)
[11:01:55.749]                           info <- base::paste(info, collapse = "; ")
[11:01:55.749]                           if (!has_future) {
[11:01:55.749]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.749]                               info)
[11:01:55.749]                           }
[11:01:55.749]                           else {
[11:01:55.749]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.749]                               info, version)
[11:01:55.749]                           }
[11:01:55.749]                           base::stop(msg)
[11:01:55.749]                         }
[11:01:55.749]                       })
[11:01:55.749]                     }
[11:01:55.749]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.749]                     base::options(mc.cores = 1L)
[11:01:55.749]                   }
[11:01:55.749]                   ...future.strategy.old <- future::plan("list")
[11:01:55.749]                   options(future.plan = NULL)
[11:01:55.749]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.749]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.749]                 }
[11:01:55.749]                 ...future.workdir <- getwd()
[11:01:55.749]             }
[11:01:55.749]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.749]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.749]         }
[11:01:55.749]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.749]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.749]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.749]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.749]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.749]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.749]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.749]             base::names(...future.oldOptions))
[11:01:55.749]     }
[11:01:55.749]     if (FALSE) {
[11:01:55.749]     }
[11:01:55.749]     else {
[11:01:55.749]         if (TRUE) {
[11:01:55.749]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.749]                 open = "w")
[11:01:55.749]         }
[11:01:55.749]         else {
[11:01:55.749]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.749]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.749]         }
[11:01:55.749]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.749]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.749]             base::sink(type = "output", split = FALSE)
[11:01:55.749]             base::close(...future.stdout)
[11:01:55.749]         }, add = TRUE)
[11:01:55.749]     }
[11:01:55.749]     ...future.frame <- base::sys.nframe()
[11:01:55.749]     ...future.conditions <- base::list()
[11:01:55.749]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.749]     if (FALSE) {
[11:01:55.749]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.749]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.749]     }
[11:01:55.749]     ...future.result <- base::tryCatch({
[11:01:55.749]         base::withCallingHandlers({
[11:01:55.749]             ...future.value <- base::withVisible(base::local({
[11:01:55.749]                 ...future.makeSendCondition <- base::local({
[11:01:55.749]                   sendCondition <- NULL
[11:01:55.749]                   function(frame = 1L) {
[11:01:55.749]                     if (is.function(sendCondition)) 
[11:01:55.749]                       return(sendCondition)
[11:01:55.749]                     ns <- getNamespace("parallel")
[11:01:55.749]                     if (exists("sendData", mode = "function", 
[11:01:55.749]                       envir = ns)) {
[11:01:55.749]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.749]                         envir = ns)
[11:01:55.749]                       envir <- sys.frame(frame)
[11:01:55.749]                       master <- NULL
[11:01:55.749]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.749]                         !identical(envir, emptyenv())) {
[11:01:55.749]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.749]                           inherits = FALSE)) {
[11:01:55.749]                           master <- get("master", mode = "list", 
[11:01:55.749]                             envir = envir, inherits = FALSE)
[11:01:55.749]                           if (inherits(master, c("SOCKnode", 
[11:01:55.749]                             "SOCK0node"))) {
[11:01:55.749]                             sendCondition <<- function(cond) {
[11:01:55.749]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.749]                                 success = TRUE)
[11:01:55.749]                               parallel_sendData(master, data)
[11:01:55.749]                             }
[11:01:55.749]                             return(sendCondition)
[11:01:55.749]                           }
[11:01:55.749]                         }
[11:01:55.749]                         frame <- frame + 1L
[11:01:55.749]                         envir <- sys.frame(frame)
[11:01:55.749]                       }
[11:01:55.749]                     }
[11:01:55.749]                     sendCondition <<- function(cond) NULL
[11:01:55.749]                   }
[11:01:55.749]                 })
[11:01:55.749]                 withCallingHandlers({
[11:01:55.749]                   {
[11:01:55.749]                     b <- a * ii
[11:01:55.749]                     a <- 0
[11:01:55.749]                     b
[11:01:55.749]                   }
[11:01:55.749]                 }, immediateCondition = function(cond) {
[11:01:55.749]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.749]                   sendCondition(cond)
[11:01:55.749]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.749]                   {
[11:01:55.749]                     inherits <- base::inherits
[11:01:55.749]                     invokeRestart <- base::invokeRestart
[11:01:55.749]                     is.null <- base::is.null
[11:01:55.749]                     muffled <- FALSE
[11:01:55.749]                     if (inherits(cond, "message")) {
[11:01:55.749]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.749]                       if (muffled) 
[11:01:55.749]                         invokeRestart("muffleMessage")
[11:01:55.749]                     }
[11:01:55.749]                     else if (inherits(cond, "warning")) {
[11:01:55.749]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.749]                       if (muffled) 
[11:01:55.749]                         invokeRestart("muffleWarning")
[11:01:55.749]                     }
[11:01:55.749]                     else if (inherits(cond, "condition")) {
[11:01:55.749]                       if (!is.null(pattern)) {
[11:01:55.749]                         computeRestarts <- base::computeRestarts
[11:01:55.749]                         grepl <- base::grepl
[11:01:55.749]                         restarts <- computeRestarts(cond)
[11:01:55.749]                         for (restart in restarts) {
[11:01:55.749]                           name <- restart$name
[11:01:55.749]                           if (is.null(name)) 
[11:01:55.749]                             next
[11:01:55.749]                           if (!grepl(pattern, name)) 
[11:01:55.749]                             next
[11:01:55.749]                           invokeRestart(restart)
[11:01:55.749]                           muffled <- TRUE
[11:01:55.749]                           break
[11:01:55.749]                         }
[11:01:55.749]                       }
[11:01:55.749]                     }
[11:01:55.749]                     invisible(muffled)
[11:01:55.749]                   }
[11:01:55.749]                   muffleCondition(cond)
[11:01:55.749]                 })
[11:01:55.749]             }))
[11:01:55.749]             future::FutureResult(value = ...future.value$value, 
[11:01:55.749]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.749]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.749]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.749]                     ...future.globalenv.names))
[11:01:55.749]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.749]         }, condition = base::local({
[11:01:55.749]             c <- base::c
[11:01:55.749]             inherits <- base::inherits
[11:01:55.749]             invokeRestart <- base::invokeRestart
[11:01:55.749]             length <- base::length
[11:01:55.749]             list <- base::list
[11:01:55.749]             seq.int <- base::seq.int
[11:01:55.749]             signalCondition <- base::signalCondition
[11:01:55.749]             sys.calls <- base::sys.calls
[11:01:55.749]             `[[` <- base::`[[`
[11:01:55.749]             `+` <- base::`+`
[11:01:55.749]             `<<-` <- base::`<<-`
[11:01:55.749]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.749]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.749]                   3L)]
[11:01:55.749]             }
[11:01:55.749]             function(cond) {
[11:01:55.749]                 is_error <- inherits(cond, "error")
[11:01:55.749]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.749]                   NULL)
[11:01:55.749]                 if (is_error) {
[11:01:55.749]                   sessionInformation <- function() {
[11:01:55.749]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.749]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.749]                       search = base::search(), system = base::Sys.info())
[11:01:55.749]                   }
[11:01:55.749]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.749]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.749]                     cond$call), session = sessionInformation(), 
[11:01:55.749]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.749]                   signalCondition(cond)
[11:01:55.749]                 }
[11:01:55.749]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.749]                 "immediateCondition"))) {
[11:01:55.749]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.749]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.749]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.749]                   if (TRUE && !signal) {
[11:01:55.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.749]                     {
[11:01:55.749]                       inherits <- base::inherits
[11:01:55.749]                       invokeRestart <- base::invokeRestart
[11:01:55.749]                       is.null <- base::is.null
[11:01:55.749]                       muffled <- FALSE
[11:01:55.749]                       if (inherits(cond, "message")) {
[11:01:55.749]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.749]                         if (muffled) 
[11:01:55.749]                           invokeRestart("muffleMessage")
[11:01:55.749]                       }
[11:01:55.749]                       else if (inherits(cond, "warning")) {
[11:01:55.749]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.749]                         if (muffled) 
[11:01:55.749]                           invokeRestart("muffleWarning")
[11:01:55.749]                       }
[11:01:55.749]                       else if (inherits(cond, "condition")) {
[11:01:55.749]                         if (!is.null(pattern)) {
[11:01:55.749]                           computeRestarts <- base::computeRestarts
[11:01:55.749]                           grepl <- base::grepl
[11:01:55.749]                           restarts <- computeRestarts(cond)
[11:01:55.749]                           for (restart in restarts) {
[11:01:55.749]                             name <- restart$name
[11:01:55.749]                             if (is.null(name)) 
[11:01:55.749]                               next
[11:01:55.749]                             if (!grepl(pattern, name)) 
[11:01:55.749]                               next
[11:01:55.749]                             invokeRestart(restart)
[11:01:55.749]                             muffled <- TRUE
[11:01:55.749]                             break
[11:01:55.749]                           }
[11:01:55.749]                         }
[11:01:55.749]                       }
[11:01:55.749]                       invisible(muffled)
[11:01:55.749]                     }
[11:01:55.749]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.749]                   }
[11:01:55.749]                 }
[11:01:55.749]                 else {
[11:01:55.749]                   if (TRUE) {
[11:01:55.749]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.749]                     {
[11:01:55.749]                       inherits <- base::inherits
[11:01:55.749]                       invokeRestart <- base::invokeRestart
[11:01:55.749]                       is.null <- base::is.null
[11:01:55.749]                       muffled <- FALSE
[11:01:55.749]                       if (inherits(cond, "message")) {
[11:01:55.749]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.749]                         if (muffled) 
[11:01:55.749]                           invokeRestart("muffleMessage")
[11:01:55.749]                       }
[11:01:55.749]                       else if (inherits(cond, "warning")) {
[11:01:55.749]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.749]                         if (muffled) 
[11:01:55.749]                           invokeRestart("muffleWarning")
[11:01:55.749]                       }
[11:01:55.749]                       else if (inherits(cond, "condition")) {
[11:01:55.749]                         if (!is.null(pattern)) {
[11:01:55.749]                           computeRestarts <- base::computeRestarts
[11:01:55.749]                           grepl <- base::grepl
[11:01:55.749]                           restarts <- computeRestarts(cond)
[11:01:55.749]                           for (restart in restarts) {
[11:01:55.749]                             name <- restart$name
[11:01:55.749]                             if (is.null(name)) 
[11:01:55.749]                               next
[11:01:55.749]                             if (!grepl(pattern, name)) 
[11:01:55.749]                               next
[11:01:55.749]                             invokeRestart(restart)
[11:01:55.749]                             muffled <- TRUE
[11:01:55.749]                             break
[11:01:55.749]                           }
[11:01:55.749]                         }
[11:01:55.749]                       }
[11:01:55.749]                       invisible(muffled)
[11:01:55.749]                     }
[11:01:55.749]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.749]                   }
[11:01:55.749]                 }
[11:01:55.749]             }
[11:01:55.749]         }))
[11:01:55.749]     }, error = function(ex) {
[11:01:55.749]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.749]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.749]                 ...future.rng), started = ...future.startTime, 
[11:01:55.749]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.749]             version = "1.8"), class = "FutureResult")
[11:01:55.749]     }, finally = {
[11:01:55.749]         if (!identical(...future.workdir, getwd())) 
[11:01:55.749]             setwd(...future.workdir)
[11:01:55.749]         {
[11:01:55.749]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.749]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.749]             }
[11:01:55.749]             base::options(...future.oldOptions)
[11:01:55.749]             if (.Platform$OS.type == "windows") {
[11:01:55.749]                 old_names <- names(...future.oldEnvVars)
[11:01:55.749]                 envs <- base::Sys.getenv()
[11:01:55.749]                 names <- names(envs)
[11:01:55.749]                 common <- intersect(names, old_names)
[11:01:55.749]                 added <- setdiff(names, old_names)
[11:01:55.749]                 removed <- setdiff(old_names, names)
[11:01:55.749]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.749]                   envs[common]]
[11:01:55.749]                 NAMES <- toupper(changed)
[11:01:55.749]                 args <- list()
[11:01:55.749]                 for (kk in seq_along(NAMES)) {
[11:01:55.749]                   name <- changed[[kk]]
[11:01:55.749]                   NAME <- NAMES[[kk]]
[11:01:55.749]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.749]                     next
[11:01:55.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.749]                 }
[11:01:55.749]                 NAMES <- toupper(added)
[11:01:55.749]                 for (kk in seq_along(NAMES)) {
[11:01:55.749]                   name <- added[[kk]]
[11:01:55.749]                   NAME <- NAMES[[kk]]
[11:01:55.749]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.749]                     next
[11:01:55.749]                   args[[name]] <- ""
[11:01:55.749]                 }
[11:01:55.749]                 NAMES <- toupper(removed)
[11:01:55.749]                 for (kk in seq_along(NAMES)) {
[11:01:55.749]                   name <- removed[[kk]]
[11:01:55.749]                   NAME <- NAMES[[kk]]
[11:01:55.749]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.749]                     next
[11:01:55.749]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.749]                 }
[11:01:55.749]                 if (length(args) > 0) 
[11:01:55.749]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.749]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.749]             }
[11:01:55.749]             else {
[11:01:55.749]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.749]             }
[11:01:55.749]             {
[11:01:55.749]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.749]                   0L) {
[11:01:55.749]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.749]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.749]                   base::options(opts)
[11:01:55.749]                 }
[11:01:55.749]                 {
[11:01:55.749]                   {
[11:01:55.749]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.749]                     NULL
[11:01:55.749]                   }
[11:01:55.749]                   options(future.plan = NULL)
[11:01:55.749]                   if (is.na(NA_character_)) 
[11:01:55.749]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.749]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.749]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.749]                     .init = FALSE)
[11:01:55.749]                 }
[11:01:55.749]             }
[11:01:55.749]         }
[11:01:55.749]     })
[11:01:55.749]     if (TRUE) {
[11:01:55.749]         base::sink(type = "output", split = FALSE)
[11:01:55.749]         if (TRUE) {
[11:01:55.749]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.749]         }
[11:01:55.749]         else {
[11:01:55.749]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.749]         }
[11:01:55.749]         base::close(...future.stdout)
[11:01:55.749]         ...future.stdout <- NULL
[11:01:55.749]     }
[11:01:55.749]     ...future.result$conditions <- ...future.conditions
[11:01:55.749]     ...future.result$finished <- base::Sys.time()
[11:01:55.749]     ...future.result
[11:01:55.749] }
[11:01:55.751] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[11:01:55.751] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:55.752] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:55.752] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:55.752] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:55.752] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[11:01:55.753] MultisessionFuture started
[11:01:55.753] - Launch lazy future ... done
[11:01:55.753] run() for ‘MultisessionFuture’ ... done
[11:01:55.753] result() for ClusterFuture ...
[11:01:55.753] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.753] - Validating connection of MultisessionFuture
[11:01:55.795] - received message: FutureResult
[11:01:55.795] - Received FutureResult
[11:01:55.795] - Erased future from FutureRegistry
[11:01:55.795] result() for ClusterFuture ...
[11:01:55.795] - result already collected: FutureResult
[11:01:55.795] result() for ClusterFuture ... done
[11:01:55.796] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.796] result() for ClusterFuture ... done
[11:01:55.796] result() for ClusterFuture ...
[11:01:55.796] - result already collected: FutureResult
[11:01:55.796] result() for ClusterFuture ... done
[11:01:55.796] run() for ‘Future’ ...
[11:01:55.796] - state: ‘created’
[11:01:55.796] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.810] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.810] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.810]   - Field: ‘node’
[11:01:55.810]   - Field: ‘label’
[11:01:55.810]   - Field: ‘local’
[11:01:55.810]   - Field: ‘owner’
[11:01:55.810]   - Field: ‘envir’
[11:01:55.811]   - Field: ‘workers’
[11:01:55.811]   - Field: ‘packages’
[11:01:55.811]   - Field: ‘gc’
[11:01:55.811]   - Field: ‘conditions’
[11:01:55.811]   - Field: ‘persistent’
[11:01:55.811]   - Field: ‘expr’
[11:01:55.811]   - Field: ‘uuid’
[11:01:55.811]   - Field: ‘seed’
[11:01:55.811]   - Field: ‘version’
[11:01:55.811]   - Field: ‘result’
[11:01:55.811]   - Field: ‘asynchronous’
[11:01:55.811]   - Field: ‘calls’
[11:01:55.812]   - Field: ‘globals’
[11:01:55.812]   - Field: ‘stdout’
[11:01:55.812]   - Field: ‘earlySignal’
[11:01:55.812]   - Field: ‘lazy’
[11:01:55.812]   - Field: ‘state’
[11:01:55.812] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.812] - Launch lazy future ...
[11:01:55.812] Packages needed by the future expression (n = 0): <none>
[11:01:55.812] Packages needed by future strategies (n = 0): <none>
[11:01:55.813] {
[11:01:55.813]     {
[11:01:55.813]         {
[11:01:55.813]             ...future.startTime <- base::Sys.time()
[11:01:55.813]             {
[11:01:55.813]                 {
[11:01:55.813]                   {
[11:01:55.813]                     {
[11:01:55.813]                       base::local({
[11:01:55.813]                         has_future <- base::requireNamespace("future", 
[11:01:55.813]                           quietly = TRUE)
[11:01:55.813]                         if (has_future) {
[11:01:55.813]                           ns <- base::getNamespace("future")
[11:01:55.813]                           version <- ns[[".package"]][["version"]]
[11:01:55.813]                           if (is.null(version)) 
[11:01:55.813]                             version <- utils::packageVersion("future")
[11:01:55.813]                         }
[11:01:55.813]                         else {
[11:01:55.813]                           version <- NULL
[11:01:55.813]                         }
[11:01:55.813]                         if (!has_future || version < "1.8.0") {
[11:01:55.813]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.813]                             "", base::R.version$version.string), 
[11:01:55.813]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.813]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.813]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.813]                               "release", "version")], collapse = " "), 
[11:01:55.813]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.813]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.813]                             info)
[11:01:55.813]                           info <- base::paste(info, collapse = "; ")
[11:01:55.813]                           if (!has_future) {
[11:01:55.813]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.813]                               info)
[11:01:55.813]                           }
[11:01:55.813]                           else {
[11:01:55.813]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.813]                               info, version)
[11:01:55.813]                           }
[11:01:55.813]                           base::stop(msg)
[11:01:55.813]                         }
[11:01:55.813]                       })
[11:01:55.813]                     }
[11:01:55.813]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.813]                     base::options(mc.cores = 1L)
[11:01:55.813]                   }
[11:01:55.813]                   ...future.strategy.old <- future::plan("list")
[11:01:55.813]                   options(future.plan = NULL)
[11:01:55.813]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.813]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.813]                 }
[11:01:55.813]                 ...future.workdir <- getwd()
[11:01:55.813]             }
[11:01:55.813]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.813]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.813]         }
[11:01:55.813]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.813]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.813]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.813]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.813]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.813]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.813]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.813]             base::names(...future.oldOptions))
[11:01:55.813]     }
[11:01:55.813]     if (FALSE) {
[11:01:55.813]     }
[11:01:55.813]     else {
[11:01:55.813]         if (TRUE) {
[11:01:55.813]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.813]                 open = "w")
[11:01:55.813]         }
[11:01:55.813]         else {
[11:01:55.813]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.813]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.813]         }
[11:01:55.813]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.813]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.813]             base::sink(type = "output", split = FALSE)
[11:01:55.813]             base::close(...future.stdout)
[11:01:55.813]         }, add = TRUE)
[11:01:55.813]     }
[11:01:55.813]     ...future.frame <- base::sys.nframe()
[11:01:55.813]     ...future.conditions <- base::list()
[11:01:55.813]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.813]     if (FALSE) {
[11:01:55.813]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.813]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.813]     }
[11:01:55.813]     ...future.result <- base::tryCatch({
[11:01:55.813]         base::withCallingHandlers({
[11:01:55.813]             ...future.value <- base::withVisible(base::local({
[11:01:55.813]                 ...future.makeSendCondition <- base::local({
[11:01:55.813]                   sendCondition <- NULL
[11:01:55.813]                   function(frame = 1L) {
[11:01:55.813]                     if (is.function(sendCondition)) 
[11:01:55.813]                       return(sendCondition)
[11:01:55.813]                     ns <- getNamespace("parallel")
[11:01:55.813]                     if (exists("sendData", mode = "function", 
[11:01:55.813]                       envir = ns)) {
[11:01:55.813]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.813]                         envir = ns)
[11:01:55.813]                       envir <- sys.frame(frame)
[11:01:55.813]                       master <- NULL
[11:01:55.813]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.813]                         !identical(envir, emptyenv())) {
[11:01:55.813]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.813]                           inherits = FALSE)) {
[11:01:55.813]                           master <- get("master", mode = "list", 
[11:01:55.813]                             envir = envir, inherits = FALSE)
[11:01:55.813]                           if (inherits(master, c("SOCKnode", 
[11:01:55.813]                             "SOCK0node"))) {
[11:01:55.813]                             sendCondition <<- function(cond) {
[11:01:55.813]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.813]                                 success = TRUE)
[11:01:55.813]                               parallel_sendData(master, data)
[11:01:55.813]                             }
[11:01:55.813]                             return(sendCondition)
[11:01:55.813]                           }
[11:01:55.813]                         }
[11:01:55.813]                         frame <- frame + 1L
[11:01:55.813]                         envir <- sys.frame(frame)
[11:01:55.813]                       }
[11:01:55.813]                     }
[11:01:55.813]                     sendCondition <<- function(cond) NULL
[11:01:55.813]                   }
[11:01:55.813]                 })
[11:01:55.813]                 withCallingHandlers({
[11:01:55.813]                   {
[11:01:55.813]                     b <- a * ii
[11:01:55.813]                     a <- 0
[11:01:55.813]                     b
[11:01:55.813]                   }
[11:01:55.813]                 }, immediateCondition = function(cond) {
[11:01:55.813]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.813]                   sendCondition(cond)
[11:01:55.813]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.813]                   {
[11:01:55.813]                     inherits <- base::inherits
[11:01:55.813]                     invokeRestart <- base::invokeRestart
[11:01:55.813]                     is.null <- base::is.null
[11:01:55.813]                     muffled <- FALSE
[11:01:55.813]                     if (inherits(cond, "message")) {
[11:01:55.813]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.813]                       if (muffled) 
[11:01:55.813]                         invokeRestart("muffleMessage")
[11:01:55.813]                     }
[11:01:55.813]                     else if (inherits(cond, "warning")) {
[11:01:55.813]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.813]                       if (muffled) 
[11:01:55.813]                         invokeRestart("muffleWarning")
[11:01:55.813]                     }
[11:01:55.813]                     else if (inherits(cond, "condition")) {
[11:01:55.813]                       if (!is.null(pattern)) {
[11:01:55.813]                         computeRestarts <- base::computeRestarts
[11:01:55.813]                         grepl <- base::grepl
[11:01:55.813]                         restarts <- computeRestarts(cond)
[11:01:55.813]                         for (restart in restarts) {
[11:01:55.813]                           name <- restart$name
[11:01:55.813]                           if (is.null(name)) 
[11:01:55.813]                             next
[11:01:55.813]                           if (!grepl(pattern, name)) 
[11:01:55.813]                             next
[11:01:55.813]                           invokeRestart(restart)
[11:01:55.813]                           muffled <- TRUE
[11:01:55.813]                           break
[11:01:55.813]                         }
[11:01:55.813]                       }
[11:01:55.813]                     }
[11:01:55.813]                     invisible(muffled)
[11:01:55.813]                   }
[11:01:55.813]                   muffleCondition(cond)
[11:01:55.813]                 })
[11:01:55.813]             }))
[11:01:55.813]             future::FutureResult(value = ...future.value$value, 
[11:01:55.813]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.813]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.813]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.813]                     ...future.globalenv.names))
[11:01:55.813]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.813]         }, condition = base::local({
[11:01:55.813]             c <- base::c
[11:01:55.813]             inherits <- base::inherits
[11:01:55.813]             invokeRestart <- base::invokeRestart
[11:01:55.813]             length <- base::length
[11:01:55.813]             list <- base::list
[11:01:55.813]             seq.int <- base::seq.int
[11:01:55.813]             signalCondition <- base::signalCondition
[11:01:55.813]             sys.calls <- base::sys.calls
[11:01:55.813]             `[[` <- base::`[[`
[11:01:55.813]             `+` <- base::`+`
[11:01:55.813]             `<<-` <- base::`<<-`
[11:01:55.813]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.813]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.813]                   3L)]
[11:01:55.813]             }
[11:01:55.813]             function(cond) {
[11:01:55.813]                 is_error <- inherits(cond, "error")
[11:01:55.813]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.813]                   NULL)
[11:01:55.813]                 if (is_error) {
[11:01:55.813]                   sessionInformation <- function() {
[11:01:55.813]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.813]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.813]                       search = base::search(), system = base::Sys.info())
[11:01:55.813]                   }
[11:01:55.813]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.813]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.813]                     cond$call), session = sessionInformation(), 
[11:01:55.813]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.813]                   signalCondition(cond)
[11:01:55.813]                 }
[11:01:55.813]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.813]                 "immediateCondition"))) {
[11:01:55.813]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.813]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.813]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.813]                   if (TRUE && !signal) {
[11:01:55.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.813]                     {
[11:01:55.813]                       inherits <- base::inherits
[11:01:55.813]                       invokeRestart <- base::invokeRestart
[11:01:55.813]                       is.null <- base::is.null
[11:01:55.813]                       muffled <- FALSE
[11:01:55.813]                       if (inherits(cond, "message")) {
[11:01:55.813]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.813]                         if (muffled) 
[11:01:55.813]                           invokeRestart("muffleMessage")
[11:01:55.813]                       }
[11:01:55.813]                       else if (inherits(cond, "warning")) {
[11:01:55.813]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.813]                         if (muffled) 
[11:01:55.813]                           invokeRestart("muffleWarning")
[11:01:55.813]                       }
[11:01:55.813]                       else if (inherits(cond, "condition")) {
[11:01:55.813]                         if (!is.null(pattern)) {
[11:01:55.813]                           computeRestarts <- base::computeRestarts
[11:01:55.813]                           grepl <- base::grepl
[11:01:55.813]                           restarts <- computeRestarts(cond)
[11:01:55.813]                           for (restart in restarts) {
[11:01:55.813]                             name <- restart$name
[11:01:55.813]                             if (is.null(name)) 
[11:01:55.813]                               next
[11:01:55.813]                             if (!grepl(pattern, name)) 
[11:01:55.813]                               next
[11:01:55.813]                             invokeRestart(restart)
[11:01:55.813]                             muffled <- TRUE
[11:01:55.813]                             break
[11:01:55.813]                           }
[11:01:55.813]                         }
[11:01:55.813]                       }
[11:01:55.813]                       invisible(muffled)
[11:01:55.813]                     }
[11:01:55.813]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.813]                   }
[11:01:55.813]                 }
[11:01:55.813]                 else {
[11:01:55.813]                   if (TRUE) {
[11:01:55.813]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.813]                     {
[11:01:55.813]                       inherits <- base::inherits
[11:01:55.813]                       invokeRestart <- base::invokeRestart
[11:01:55.813]                       is.null <- base::is.null
[11:01:55.813]                       muffled <- FALSE
[11:01:55.813]                       if (inherits(cond, "message")) {
[11:01:55.813]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.813]                         if (muffled) 
[11:01:55.813]                           invokeRestart("muffleMessage")
[11:01:55.813]                       }
[11:01:55.813]                       else if (inherits(cond, "warning")) {
[11:01:55.813]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.813]                         if (muffled) 
[11:01:55.813]                           invokeRestart("muffleWarning")
[11:01:55.813]                       }
[11:01:55.813]                       else if (inherits(cond, "condition")) {
[11:01:55.813]                         if (!is.null(pattern)) {
[11:01:55.813]                           computeRestarts <- base::computeRestarts
[11:01:55.813]                           grepl <- base::grepl
[11:01:55.813]                           restarts <- computeRestarts(cond)
[11:01:55.813]                           for (restart in restarts) {
[11:01:55.813]                             name <- restart$name
[11:01:55.813]                             if (is.null(name)) 
[11:01:55.813]                               next
[11:01:55.813]                             if (!grepl(pattern, name)) 
[11:01:55.813]                               next
[11:01:55.813]                             invokeRestart(restart)
[11:01:55.813]                             muffled <- TRUE
[11:01:55.813]                             break
[11:01:55.813]                           }
[11:01:55.813]                         }
[11:01:55.813]                       }
[11:01:55.813]                       invisible(muffled)
[11:01:55.813]                     }
[11:01:55.813]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.813]                   }
[11:01:55.813]                 }
[11:01:55.813]             }
[11:01:55.813]         }))
[11:01:55.813]     }, error = function(ex) {
[11:01:55.813]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.813]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.813]                 ...future.rng), started = ...future.startTime, 
[11:01:55.813]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.813]             version = "1.8"), class = "FutureResult")
[11:01:55.813]     }, finally = {
[11:01:55.813]         if (!identical(...future.workdir, getwd())) 
[11:01:55.813]             setwd(...future.workdir)
[11:01:55.813]         {
[11:01:55.813]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.813]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.813]             }
[11:01:55.813]             base::options(...future.oldOptions)
[11:01:55.813]             if (.Platform$OS.type == "windows") {
[11:01:55.813]                 old_names <- names(...future.oldEnvVars)
[11:01:55.813]                 envs <- base::Sys.getenv()
[11:01:55.813]                 names <- names(envs)
[11:01:55.813]                 common <- intersect(names, old_names)
[11:01:55.813]                 added <- setdiff(names, old_names)
[11:01:55.813]                 removed <- setdiff(old_names, names)
[11:01:55.813]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.813]                   envs[common]]
[11:01:55.813]                 NAMES <- toupper(changed)
[11:01:55.813]                 args <- list()
[11:01:55.813]                 for (kk in seq_along(NAMES)) {
[11:01:55.813]                   name <- changed[[kk]]
[11:01:55.813]                   NAME <- NAMES[[kk]]
[11:01:55.813]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.813]                     next
[11:01:55.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.813]                 }
[11:01:55.813]                 NAMES <- toupper(added)
[11:01:55.813]                 for (kk in seq_along(NAMES)) {
[11:01:55.813]                   name <- added[[kk]]
[11:01:55.813]                   NAME <- NAMES[[kk]]
[11:01:55.813]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.813]                     next
[11:01:55.813]                   args[[name]] <- ""
[11:01:55.813]                 }
[11:01:55.813]                 NAMES <- toupper(removed)
[11:01:55.813]                 for (kk in seq_along(NAMES)) {
[11:01:55.813]                   name <- removed[[kk]]
[11:01:55.813]                   NAME <- NAMES[[kk]]
[11:01:55.813]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.813]                     next
[11:01:55.813]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.813]                 }
[11:01:55.813]                 if (length(args) > 0) 
[11:01:55.813]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.813]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.813]             }
[11:01:55.813]             else {
[11:01:55.813]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.813]             }
[11:01:55.813]             {
[11:01:55.813]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.813]                   0L) {
[11:01:55.813]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.813]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.813]                   base::options(opts)
[11:01:55.813]                 }
[11:01:55.813]                 {
[11:01:55.813]                   {
[11:01:55.813]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.813]                     NULL
[11:01:55.813]                   }
[11:01:55.813]                   options(future.plan = NULL)
[11:01:55.813]                   if (is.na(NA_character_)) 
[11:01:55.813]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.813]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.813]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.813]                     .init = FALSE)
[11:01:55.813]                 }
[11:01:55.813]             }
[11:01:55.813]         }
[11:01:55.813]     })
[11:01:55.813]     if (TRUE) {
[11:01:55.813]         base::sink(type = "output", split = FALSE)
[11:01:55.813]         if (TRUE) {
[11:01:55.813]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.813]         }
[11:01:55.813]         else {
[11:01:55.813]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.813]         }
[11:01:55.813]         base::close(...future.stdout)
[11:01:55.813]         ...future.stdout <- NULL
[11:01:55.813]     }
[11:01:55.813]     ...future.result$conditions <- ...future.conditions
[11:01:55.813]     ...future.result$finished <- base::Sys.time()
[11:01:55.813]     ...future.result
[11:01:55.813] }
[11:01:55.815] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[11:01:55.815] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:55.816] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:55.816] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:55.816] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:55.816] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[11:01:55.817] MultisessionFuture started
[11:01:55.817] - Launch lazy future ... done
[11:01:55.817] run() for ‘MultisessionFuture’ ... done
[11:01:55.817] result() for ClusterFuture ...
[11:01:55.817] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.817] - Validating connection of MultisessionFuture
[11:01:55.859] - received message: FutureResult
[11:01:55.859] - Received FutureResult
[11:01:55.859] - Erased future from FutureRegistry
[11:01:55.859] result() for ClusterFuture ...
[11:01:55.859] - result already collected: FutureResult
[11:01:55.859] result() for ClusterFuture ... done
[11:01:55.859] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.859] result() for ClusterFuture ... done
[11:01:55.860] result() for ClusterFuture ...
[11:01:55.860] - result already collected: FutureResult
[11:01:55.860] result() for ClusterFuture ... done
[11:01:55.860] run() for ‘Future’ ...
[11:01:55.860] - state: ‘created’
[11:01:55.860] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.874] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.874] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.874]   - Field: ‘node’
[11:01:55.874]   - Field: ‘label’
[11:01:55.874]   - Field: ‘local’
[11:01:55.874]   - Field: ‘owner’
[11:01:55.874]   - Field: ‘envir’
[11:01:55.874]   - Field: ‘workers’
[11:01:55.874]   - Field: ‘packages’
[11:01:55.875]   - Field: ‘gc’
[11:01:55.875]   - Field: ‘conditions’
[11:01:55.875]   - Field: ‘persistent’
[11:01:55.875]   - Field: ‘expr’
[11:01:55.875]   - Field: ‘uuid’
[11:01:55.875]   - Field: ‘seed’
[11:01:55.875]   - Field: ‘version’
[11:01:55.875]   - Field: ‘result’
[11:01:55.875]   - Field: ‘asynchronous’
[11:01:55.875]   - Field: ‘calls’
[11:01:55.875]   - Field: ‘globals’
[11:01:55.875]   - Field: ‘stdout’
[11:01:55.876]   - Field: ‘earlySignal’
[11:01:55.876]   - Field: ‘lazy’
[11:01:55.876]   - Field: ‘state’
[11:01:55.876] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.876] - Launch lazy future ...
[11:01:55.876] Packages needed by the future expression (n = 0): <none>
[11:01:55.876] Packages needed by future strategies (n = 0): <none>
[11:01:55.877] {
[11:01:55.877]     {
[11:01:55.877]         {
[11:01:55.877]             ...future.startTime <- base::Sys.time()
[11:01:55.877]             {
[11:01:55.877]                 {
[11:01:55.877]                   {
[11:01:55.877]                     {
[11:01:55.877]                       base::local({
[11:01:55.877]                         has_future <- base::requireNamespace("future", 
[11:01:55.877]                           quietly = TRUE)
[11:01:55.877]                         if (has_future) {
[11:01:55.877]                           ns <- base::getNamespace("future")
[11:01:55.877]                           version <- ns[[".package"]][["version"]]
[11:01:55.877]                           if (is.null(version)) 
[11:01:55.877]                             version <- utils::packageVersion("future")
[11:01:55.877]                         }
[11:01:55.877]                         else {
[11:01:55.877]                           version <- NULL
[11:01:55.877]                         }
[11:01:55.877]                         if (!has_future || version < "1.8.0") {
[11:01:55.877]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.877]                             "", base::R.version$version.string), 
[11:01:55.877]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.877]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.877]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.877]                               "release", "version")], collapse = " "), 
[11:01:55.877]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.877]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.877]                             info)
[11:01:55.877]                           info <- base::paste(info, collapse = "; ")
[11:01:55.877]                           if (!has_future) {
[11:01:55.877]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.877]                               info)
[11:01:55.877]                           }
[11:01:55.877]                           else {
[11:01:55.877]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.877]                               info, version)
[11:01:55.877]                           }
[11:01:55.877]                           base::stop(msg)
[11:01:55.877]                         }
[11:01:55.877]                       })
[11:01:55.877]                     }
[11:01:55.877]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.877]                     base::options(mc.cores = 1L)
[11:01:55.877]                   }
[11:01:55.877]                   ...future.strategy.old <- future::plan("list")
[11:01:55.877]                   options(future.plan = NULL)
[11:01:55.877]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.877]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.877]                 }
[11:01:55.877]                 ...future.workdir <- getwd()
[11:01:55.877]             }
[11:01:55.877]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.877]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.877]         }
[11:01:55.877]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.877]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.877]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.877]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.877]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.877]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.877]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.877]             base::names(...future.oldOptions))
[11:01:55.877]     }
[11:01:55.877]     if (FALSE) {
[11:01:55.877]     }
[11:01:55.877]     else {
[11:01:55.877]         if (TRUE) {
[11:01:55.877]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.877]                 open = "w")
[11:01:55.877]         }
[11:01:55.877]         else {
[11:01:55.877]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.877]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.877]         }
[11:01:55.877]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.877]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.877]             base::sink(type = "output", split = FALSE)
[11:01:55.877]             base::close(...future.stdout)
[11:01:55.877]         }, add = TRUE)
[11:01:55.877]     }
[11:01:55.877]     ...future.frame <- base::sys.nframe()
[11:01:55.877]     ...future.conditions <- base::list()
[11:01:55.877]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.877]     if (FALSE) {
[11:01:55.877]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.877]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.877]     }
[11:01:55.877]     ...future.result <- base::tryCatch({
[11:01:55.877]         base::withCallingHandlers({
[11:01:55.877]             ...future.value <- base::withVisible(base::local({
[11:01:55.877]                 ...future.makeSendCondition <- base::local({
[11:01:55.877]                   sendCondition <- NULL
[11:01:55.877]                   function(frame = 1L) {
[11:01:55.877]                     if (is.function(sendCondition)) 
[11:01:55.877]                       return(sendCondition)
[11:01:55.877]                     ns <- getNamespace("parallel")
[11:01:55.877]                     if (exists("sendData", mode = "function", 
[11:01:55.877]                       envir = ns)) {
[11:01:55.877]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.877]                         envir = ns)
[11:01:55.877]                       envir <- sys.frame(frame)
[11:01:55.877]                       master <- NULL
[11:01:55.877]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.877]                         !identical(envir, emptyenv())) {
[11:01:55.877]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.877]                           inherits = FALSE)) {
[11:01:55.877]                           master <- get("master", mode = "list", 
[11:01:55.877]                             envir = envir, inherits = FALSE)
[11:01:55.877]                           if (inherits(master, c("SOCKnode", 
[11:01:55.877]                             "SOCK0node"))) {
[11:01:55.877]                             sendCondition <<- function(cond) {
[11:01:55.877]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.877]                                 success = TRUE)
[11:01:55.877]                               parallel_sendData(master, data)
[11:01:55.877]                             }
[11:01:55.877]                             return(sendCondition)
[11:01:55.877]                           }
[11:01:55.877]                         }
[11:01:55.877]                         frame <- frame + 1L
[11:01:55.877]                         envir <- sys.frame(frame)
[11:01:55.877]                       }
[11:01:55.877]                     }
[11:01:55.877]                     sendCondition <<- function(cond) NULL
[11:01:55.877]                   }
[11:01:55.877]                 })
[11:01:55.877]                 withCallingHandlers({
[11:01:55.877]                   {
[11:01:55.877]                     b <- a * ii
[11:01:55.877]                     a <- 0
[11:01:55.877]                     b
[11:01:55.877]                   }
[11:01:55.877]                 }, immediateCondition = function(cond) {
[11:01:55.877]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.877]                   sendCondition(cond)
[11:01:55.877]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.877]                   {
[11:01:55.877]                     inherits <- base::inherits
[11:01:55.877]                     invokeRestart <- base::invokeRestart
[11:01:55.877]                     is.null <- base::is.null
[11:01:55.877]                     muffled <- FALSE
[11:01:55.877]                     if (inherits(cond, "message")) {
[11:01:55.877]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.877]                       if (muffled) 
[11:01:55.877]                         invokeRestart("muffleMessage")
[11:01:55.877]                     }
[11:01:55.877]                     else if (inherits(cond, "warning")) {
[11:01:55.877]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.877]                       if (muffled) 
[11:01:55.877]                         invokeRestart("muffleWarning")
[11:01:55.877]                     }
[11:01:55.877]                     else if (inherits(cond, "condition")) {
[11:01:55.877]                       if (!is.null(pattern)) {
[11:01:55.877]                         computeRestarts <- base::computeRestarts
[11:01:55.877]                         grepl <- base::grepl
[11:01:55.877]                         restarts <- computeRestarts(cond)
[11:01:55.877]                         for (restart in restarts) {
[11:01:55.877]                           name <- restart$name
[11:01:55.877]                           if (is.null(name)) 
[11:01:55.877]                             next
[11:01:55.877]                           if (!grepl(pattern, name)) 
[11:01:55.877]                             next
[11:01:55.877]                           invokeRestart(restart)
[11:01:55.877]                           muffled <- TRUE
[11:01:55.877]                           break
[11:01:55.877]                         }
[11:01:55.877]                       }
[11:01:55.877]                     }
[11:01:55.877]                     invisible(muffled)
[11:01:55.877]                   }
[11:01:55.877]                   muffleCondition(cond)
[11:01:55.877]                 })
[11:01:55.877]             }))
[11:01:55.877]             future::FutureResult(value = ...future.value$value, 
[11:01:55.877]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.877]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.877]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.877]                     ...future.globalenv.names))
[11:01:55.877]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.877]         }, condition = base::local({
[11:01:55.877]             c <- base::c
[11:01:55.877]             inherits <- base::inherits
[11:01:55.877]             invokeRestart <- base::invokeRestart
[11:01:55.877]             length <- base::length
[11:01:55.877]             list <- base::list
[11:01:55.877]             seq.int <- base::seq.int
[11:01:55.877]             signalCondition <- base::signalCondition
[11:01:55.877]             sys.calls <- base::sys.calls
[11:01:55.877]             `[[` <- base::`[[`
[11:01:55.877]             `+` <- base::`+`
[11:01:55.877]             `<<-` <- base::`<<-`
[11:01:55.877]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.877]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.877]                   3L)]
[11:01:55.877]             }
[11:01:55.877]             function(cond) {
[11:01:55.877]                 is_error <- inherits(cond, "error")
[11:01:55.877]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.877]                   NULL)
[11:01:55.877]                 if (is_error) {
[11:01:55.877]                   sessionInformation <- function() {
[11:01:55.877]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.877]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.877]                       search = base::search(), system = base::Sys.info())
[11:01:55.877]                   }
[11:01:55.877]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.877]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.877]                     cond$call), session = sessionInformation(), 
[11:01:55.877]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.877]                   signalCondition(cond)
[11:01:55.877]                 }
[11:01:55.877]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.877]                 "immediateCondition"))) {
[11:01:55.877]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.877]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.877]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.877]                   if (TRUE && !signal) {
[11:01:55.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.877]                     {
[11:01:55.877]                       inherits <- base::inherits
[11:01:55.877]                       invokeRestart <- base::invokeRestart
[11:01:55.877]                       is.null <- base::is.null
[11:01:55.877]                       muffled <- FALSE
[11:01:55.877]                       if (inherits(cond, "message")) {
[11:01:55.877]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.877]                         if (muffled) 
[11:01:55.877]                           invokeRestart("muffleMessage")
[11:01:55.877]                       }
[11:01:55.877]                       else if (inherits(cond, "warning")) {
[11:01:55.877]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.877]                         if (muffled) 
[11:01:55.877]                           invokeRestart("muffleWarning")
[11:01:55.877]                       }
[11:01:55.877]                       else if (inherits(cond, "condition")) {
[11:01:55.877]                         if (!is.null(pattern)) {
[11:01:55.877]                           computeRestarts <- base::computeRestarts
[11:01:55.877]                           grepl <- base::grepl
[11:01:55.877]                           restarts <- computeRestarts(cond)
[11:01:55.877]                           for (restart in restarts) {
[11:01:55.877]                             name <- restart$name
[11:01:55.877]                             if (is.null(name)) 
[11:01:55.877]                               next
[11:01:55.877]                             if (!grepl(pattern, name)) 
[11:01:55.877]                               next
[11:01:55.877]                             invokeRestart(restart)
[11:01:55.877]                             muffled <- TRUE
[11:01:55.877]                             break
[11:01:55.877]                           }
[11:01:55.877]                         }
[11:01:55.877]                       }
[11:01:55.877]                       invisible(muffled)
[11:01:55.877]                     }
[11:01:55.877]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.877]                   }
[11:01:55.877]                 }
[11:01:55.877]                 else {
[11:01:55.877]                   if (TRUE) {
[11:01:55.877]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.877]                     {
[11:01:55.877]                       inherits <- base::inherits
[11:01:55.877]                       invokeRestart <- base::invokeRestart
[11:01:55.877]                       is.null <- base::is.null
[11:01:55.877]                       muffled <- FALSE
[11:01:55.877]                       if (inherits(cond, "message")) {
[11:01:55.877]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.877]                         if (muffled) 
[11:01:55.877]                           invokeRestart("muffleMessage")
[11:01:55.877]                       }
[11:01:55.877]                       else if (inherits(cond, "warning")) {
[11:01:55.877]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.877]                         if (muffled) 
[11:01:55.877]                           invokeRestart("muffleWarning")
[11:01:55.877]                       }
[11:01:55.877]                       else if (inherits(cond, "condition")) {
[11:01:55.877]                         if (!is.null(pattern)) {
[11:01:55.877]                           computeRestarts <- base::computeRestarts
[11:01:55.877]                           grepl <- base::grepl
[11:01:55.877]                           restarts <- computeRestarts(cond)
[11:01:55.877]                           for (restart in restarts) {
[11:01:55.877]                             name <- restart$name
[11:01:55.877]                             if (is.null(name)) 
[11:01:55.877]                               next
[11:01:55.877]                             if (!grepl(pattern, name)) 
[11:01:55.877]                               next
[11:01:55.877]                             invokeRestart(restart)
[11:01:55.877]                             muffled <- TRUE
[11:01:55.877]                             break
[11:01:55.877]                           }
[11:01:55.877]                         }
[11:01:55.877]                       }
[11:01:55.877]                       invisible(muffled)
[11:01:55.877]                     }
[11:01:55.877]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.877]                   }
[11:01:55.877]                 }
[11:01:55.877]             }
[11:01:55.877]         }))
[11:01:55.877]     }, error = function(ex) {
[11:01:55.877]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.877]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.877]                 ...future.rng), started = ...future.startTime, 
[11:01:55.877]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.877]             version = "1.8"), class = "FutureResult")
[11:01:55.877]     }, finally = {
[11:01:55.877]         if (!identical(...future.workdir, getwd())) 
[11:01:55.877]             setwd(...future.workdir)
[11:01:55.877]         {
[11:01:55.877]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.877]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.877]             }
[11:01:55.877]             base::options(...future.oldOptions)
[11:01:55.877]             if (.Platform$OS.type == "windows") {
[11:01:55.877]                 old_names <- names(...future.oldEnvVars)
[11:01:55.877]                 envs <- base::Sys.getenv()
[11:01:55.877]                 names <- names(envs)
[11:01:55.877]                 common <- intersect(names, old_names)
[11:01:55.877]                 added <- setdiff(names, old_names)
[11:01:55.877]                 removed <- setdiff(old_names, names)
[11:01:55.877]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.877]                   envs[common]]
[11:01:55.877]                 NAMES <- toupper(changed)
[11:01:55.877]                 args <- list()
[11:01:55.877]                 for (kk in seq_along(NAMES)) {
[11:01:55.877]                   name <- changed[[kk]]
[11:01:55.877]                   NAME <- NAMES[[kk]]
[11:01:55.877]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.877]                     next
[11:01:55.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.877]                 }
[11:01:55.877]                 NAMES <- toupper(added)
[11:01:55.877]                 for (kk in seq_along(NAMES)) {
[11:01:55.877]                   name <- added[[kk]]
[11:01:55.877]                   NAME <- NAMES[[kk]]
[11:01:55.877]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.877]                     next
[11:01:55.877]                   args[[name]] <- ""
[11:01:55.877]                 }
[11:01:55.877]                 NAMES <- toupper(removed)
[11:01:55.877]                 for (kk in seq_along(NAMES)) {
[11:01:55.877]                   name <- removed[[kk]]
[11:01:55.877]                   NAME <- NAMES[[kk]]
[11:01:55.877]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.877]                     next
[11:01:55.877]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.877]                 }
[11:01:55.877]                 if (length(args) > 0) 
[11:01:55.877]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.877]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.877]             }
[11:01:55.877]             else {
[11:01:55.877]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.877]             }
[11:01:55.877]             {
[11:01:55.877]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.877]                   0L) {
[11:01:55.877]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.877]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.877]                   base::options(opts)
[11:01:55.877]                 }
[11:01:55.877]                 {
[11:01:55.877]                   {
[11:01:55.877]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.877]                     NULL
[11:01:55.877]                   }
[11:01:55.877]                   options(future.plan = NULL)
[11:01:55.877]                   if (is.na(NA_character_)) 
[11:01:55.877]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.877]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.877]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.877]                     .init = FALSE)
[11:01:55.877]                 }
[11:01:55.877]             }
[11:01:55.877]         }
[11:01:55.877]     })
[11:01:55.877]     if (TRUE) {
[11:01:55.877]         base::sink(type = "output", split = FALSE)
[11:01:55.877]         if (TRUE) {
[11:01:55.877]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.877]         }
[11:01:55.877]         else {
[11:01:55.877]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.877]         }
[11:01:55.877]         base::close(...future.stdout)
[11:01:55.877]         ...future.stdout <- NULL
[11:01:55.877]     }
[11:01:55.877]     ...future.result$conditions <- ...future.conditions
[11:01:55.877]     ...future.result$finished <- base::Sys.time()
[11:01:55.877]     ...future.result
[11:01:55.877] }
[11:01:55.879] Exporting 2 global objects (382 bytes) to cluster node #1 ...
[11:01:55.879] Exporting ‘a’ (39 bytes) to cluster node #1 ...
[11:01:55.880] Exporting ‘a’ (39 bytes) to cluster node #1 ... DONE
[11:01:55.880] Exporting ‘ii’ (35 bytes) to cluster node #1 ...
[11:01:55.880] Exporting ‘ii’ (35 bytes) to cluster node #1 ... DONE
[11:01:55.880] Exporting 2 global objects (382 bytes) to cluster node #1 ... DONE
[11:01:55.881] MultisessionFuture started
[11:01:55.881] - Launch lazy future ... done
[11:01:55.881] run() for ‘MultisessionFuture’ ... done
[11:01:55.881] result() for ClusterFuture ...
[11:01:55.881] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.881] - Validating connection of MultisessionFuture
[11:01:55.922] - received message: FutureResult
[11:01:55.922] - Received FutureResult
[11:01:55.922] - Erased future from FutureRegistry
[11:01:55.922] result() for ClusterFuture ...
[11:01:55.922] - result already collected: FutureResult
[11:01:55.922] result() for ClusterFuture ... done
[11:01:55.923] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.923] result() for ClusterFuture ... done
[11:01:55.923] result() for ClusterFuture ...
[11:01:55.923] - result already collected: FutureResult
[11:01:55.923] result() for ClusterFuture ... done
[1] 1 2 3
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.923] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.923] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.924] 
[11:01:55.924] Searching for globals ... DONE
[11:01:55.924] - globals: [0] <none>
[11:01:55.924] getGlobalsAndPackages() ... DONE
[11:01:55.924] run() for ‘Future’ ...
[11:01:55.924] - state: ‘created’
[11:01:55.924] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:55.938] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:55.938] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:55.938]   - Field: ‘node’
[11:01:55.938]   - Field: ‘label’
[11:01:55.938]   - Field: ‘local’
[11:01:55.938]   - Field: ‘owner’
[11:01:55.938]   - Field: ‘envir’
[11:01:55.939]   - Field: ‘workers’
[11:01:55.939]   - Field: ‘packages’
[11:01:55.939]   - Field: ‘gc’
[11:01:55.939]   - Field: ‘conditions’
[11:01:55.939]   - Field: ‘persistent’
[11:01:55.939]   - Field: ‘expr’
[11:01:55.939]   - Field: ‘uuid’
[11:01:55.939]   - Field: ‘seed’
[11:01:55.939]   - Field: ‘version’
[11:01:55.939]   - Field: ‘result’
[11:01:55.939]   - Field: ‘asynchronous’
[11:01:55.940]   - Field: ‘calls’
[11:01:55.940]   - Field: ‘globals’
[11:01:55.940]   - Field: ‘stdout’
[11:01:55.940]   - Field: ‘earlySignal’
[11:01:55.940]   - Field: ‘lazy’
[11:01:55.940]   - Field: ‘state’
[11:01:55.940] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:55.940] - Launch lazy future ...
[11:01:55.940] Packages needed by the future expression (n = 0): <none>
[11:01:55.940] Packages needed by future strategies (n = 0): <none>
[11:01:55.941] {
[11:01:55.941]     {
[11:01:55.941]         {
[11:01:55.941]             ...future.startTime <- base::Sys.time()
[11:01:55.941]             {
[11:01:55.941]                 {
[11:01:55.941]                   {
[11:01:55.941]                     {
[11:01:55.941]                       base::local({
[11:01:55.941]                         has_future <- base::requireNamespace("future", 
[11:01:55.941]                           quietly = TRUE)
[11:01:55.941]                         if (has_future) {
[11:01:55.941]                           ns <- base::getNamespace("future")
[11:01:55.941]                           version <- ns[[".package"]][["version"]]
[11:01:55.941]                           if (is.null(version)) 
[11:01:55.941]                             version <- utils::packageVersion("future")
[11:01:55.941]                         }
[11:01:55.941]                         else {
[11:01:55.941]                           version <- NULL
[11:01:55.941]                         }
[11:01:55.941]                         if (!has_future || version < "1.8.0") {
[11:01:55.941]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:55.941]                             "", base::R.version$version.string), 
[11:01:55.941]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:55.941]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:55.941]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:55.941]                               "release", "version")], collapse = " "), 
[11:01:55.941]                             hostname = base::Sys.info()[["nodename"]])
[11:01:55.941]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:55.941]                             info)
[11:01:55.941]                           info <- base::paste(info, collapse = "; ")
[11:01:55.941]                           if (!has_future) {
[11:01:55.941]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:55.941]                               info)
[11:01:55.941]                           }
[11:01:55.941]                           else {
[11:01:55.941]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:55.941]                               info, version)
[11:01:55.941]                           }
[11:01:55.941]                           base::stop(msg)
[11:01:55.941]                         }
[11:01:55.941]                       })
[11:01:55.941]                     }
[11:01:55.941]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:55.941]                     base::options(mc.cores = 1L)
[11:01:55.941]                   }
[11:01:55.941]                   ...future.strategy.old <- future::plan("list")
[11:01:55.941]                   options(future.plan = NULL)
[11:01:55.941]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.941]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:55.941]                 }
[11:01:55.941]                 ...future.workdir <- getwd()
[11:01:55.941]             }
[11:01:55.941]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:55.941]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:55.941]         }
[11:01:55.941]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:55.941]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:55.941]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:55.941]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:55.941]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:55.941]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:55.941]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:55.941]             base::names(...future.oldOptions))
[11:01:55.941]     }
[11:01:55.941]     if (FALSE) {
[11:01:55.941]     }
[11:01:55.941]     else {
[11:01:55.941]         if (TRUE) {
[11:01:55.941]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:55.941]                 open = "w")
[11:01:55.941]         }
[11:01:55.941]         else {
[11:01:55.941]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:55.941]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:55.941]         }
[11:01:55.941]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:55.941]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:55.941]             base::sink(type = "output", split = FALSE)
[11:01:55.941]             base::close(...future.stdout)
[11:01:55.941]         }, add = TRUE)
[11:01:55.941]     }
[11:01:55.941]     ...future.frame <- base::sys.nframe()
[11:01:55.941]     ...future.conditions <- base::list()
[11:01:55.941]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:55.941]     if (FALSE) {
[11:01:55.941]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:55.941]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:55.941]     }
[11:01:55.941]     ...future.result <- base::tryCatch({
[11:01:55.941]         base::withCallingHandlers({
[11:01:55.941]             ...future.value <- base::withVisible(base::local({
[11:01:55.941]                 ...future.makeSendCondition <- base::local({
[11:01:55.941]                   sendCondition <- NULL
[11:01:55.941]                   function(frame = 1L) {
[11:01:55.941]                     if (is.function(sendCondition)) 
[11:01:55.941]                       return(sendCondition)
[11:01:55.941]                     ns <- getNamespace("parallel")
[11:01:55.941]                     if (exists("sendData", mode = "function", 
[11:01:55.941]                       envir = ns)) {
[11:01:55.941]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:55.941]                         envir = ns)
[11:01:55.941]                       envir <- sys.frame(frame)
[11:01:55.941]                       master <- NULL
[11:01:55.941]                       while (!identical(envir, .GlobalEnv) && 
[11:01:55.941]                         !identical(envir, emptyenv())) {
[11:01:55.941]                         if (exists("master", mode = "list", envir = envir, 
[11:01:55.941]                           inherits = FALSE)) {
[11:01:55.941]                           master <- get("master", mode = "list", 
[11:01:55.941]                             envir = envir, inherits = FALSE)
[11:01:55.941]                           if (inherits(master, c("SOCKnode", 
[11:01:55.941]                             "SOCK0node"))) {
[11:01:55.941]                             sendCondition <<- function(cond) {
[11:01:55.941]                               data <- list(type = "VALUE", value = cond, 
[11:01:55.941]                                 success = TRUE)
[11:01:55.941]                               parallel_sendData(master, data)
[11:01:55.941]                             }
[11:01:55.941]                             return(sendCondition)
[11:01:55.941]                           }
[11:01:55.941]                         }
[11:01:55.941]                         frame <- frame + 1L
[11:01:55.941]                         envir <- sys.frame(frame)
[11:01:55.941]                       }
[11:01:55.941]                     }
[11:01:55.941]                     sendCondition <<- function(cond) NULL
[11:01:55.941]                   }
[11:01:55.941]                 })
[11:01:55.941]                 withCallingHandlers({
[11:01:55.941]                   1
[11:01:55.941]                 }, immediateCondition = function(cond) {
[11:01:55.941]                   sendCondition <- ...future.makeSendCondition()
[11:01:55.941]                   sendCondition(cond)
[11:01:55.941]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.941]                   {
[11:01:55.941]                     inherits <- base::inherits
[11:01:55.941]                     invokeRestart <- base::invokeRestart
[11:01:55.941]                     is.null <- base::is.null
[11:01:55.941]                     muffled <- FALSE
[11:01:55.941]                     if (inherits(cond, "message")) {
[11:01:55.941]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:55.941]                       if (muffled) 
[11:01:55.941]                         invokeRestart("muffleMessage")
[11:01:55.941]                     }
[11:01:55.941]                     else if (inherits(cond, "warning")) {
[11:01:55.941]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:55.941]                       if (muffled) 
[11:01:55.941]                         invokeRestart("muffleWarning")
[11:01:55.941]                     }
[11:01:55.941]                     else if (inherits(cond, "condition")) {
[11:01:55.941]                       if (!is.null(pattern)) {
[11:01:55.941]                         computeRestarts <- base::computeRestarts
[11:01:55.941]                         grepl <- base::grepl
[11:01:55.941]                         restarts <- computeRestarts(cond)
[11:01:55.941]                         for (restart in restarts) {
[11:01:55.941]                           name <- restart$name
[11:01:55.941]                           if (is.null(name)) 
[11:01:55.941]                             next
[11:01:55.941]                           if (!grepl(pattern, name)) 
[11:01:55.941]                             next
[11:01:55.941]                           invokeRestart(restart)
[11:01:55.941]                           muffled <- TRUE
[11:01:55.941]                           break
[11:01:55.941]                         }
[11:01:55.941]                       }
[11:01:55.941]                     }
[11:01:55.941]                     invisible(muffled)
[11:01:55.941]                   }
[11:01:55.941]                   muffleCondition(cond)
[11:01:55.941]                 })
[11:01:55.941]             }))
[11:01:55.941]             future::FutureResult(value = ...future.value$value, 
[11:01:55.941]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.941]                   ...future.rng), globalenv = if (FALSE) 
[11:01:55.941]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:55.941]                     ...future.globalenv.names))
[11:01:55.941]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:55.941]         }, condition = base::local({
[11:01:55.941]             c <- base::c
[11:01:55.941]             inherits <- base::inherits
[11:01:55.941]             invokeRestart <- base::invokeRestart
[11:01:55.941]             length <- base::length
[11:01:55.941]             list <- base::list
[11:01:55.941]             seq.int <- base::seq.int
[11:01:55.941]             signalCondition <- base::signalCondition
[11:01:55.941]             sys.calls <- base::sys.calls
[11:01:55.941]             `[[` <- base::`[[`
[11:01:55.941]             `+` <- base::`+`
[11:01:55.941]             `<<-` <- base::`<<-`
[11:01:55.941]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:55.941]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:55.941]                   3L)]
[11:01:55.941]             }
[11:01:55.941]             function(cond) {
[11:01:55.941]                 is_error <- inherits(cond, "error")
[11:01:55.941]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:55.941]                   NULL)
[11:01:55.941]                 if (is_error) {
[11:01:55.941]                   sessionInformation <- function() {
[11:01:55.941]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:55.941]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:55.941]                       search = base::search(), system = base::Sys.info())
[11:01:55.941]                   }
[11:01:55.941]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.941]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:55.941]                     cond$call), session = sessionInformation(), 
[11:01:55.941]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:55.941]                   signalCondition(cond)
[11:01:55.941]                 }
[11:01:55.941]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:55.941]                 "immediateCondition"))) {
[11:01:55.941]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:55.941]                   ...future.conditions[[length(...future.conditions) + 
[11:01:55.941]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:55.941]                   if (TRUE && !signal) {
[11:01:55.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.941]                     {
[11:01:55.941]                       inherits <- base::inherits
[11:01:55.941]                       invokeRestart <- base::invokeRestart
[11:01:55.941]                       is.null <- base::is.null
[11:01:55.941]                       muffled <- FALSE
[11:01:55.941]                       if (inherits(cond, "message")) {
[11:01:55.941]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.941]                         if (muffled) 
[11:01:55.941]                           invokeRestart("muffleMessage")
[11:01:55.941]                       }
[11:01:55.941]                       else if (inherits(cond, "warning")) {
[11:01:55.941]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.941]                         if (muffled) 
[11:01:55.941]                           invokeRestart("muffleWarning")
[11:01:55.941]                       }
[11:01:55.941]                       else if (inherits(cond, "condition")) {
[11:01:55.941]                         if (!is.null(pattern)) {
[11:01:55.941]                           computeRestarts <- base::computeRestarts
[11:01:55.941]                           grepl <- base::grepl
[11:01:55.941]                           restarts <- computeRestarts(cond)
[11:01:55.941]                           for (restart in restarts) {
[11:01:55.941]                             name <- restart$name
[11:01:55.941]                             if (is.null(name)) 
[11:01:55.941]                               next
[11:01:55.941]                             if (!grepl(pattern, name)) 
[11:01:55.941]                               next
[11:01:55.941]                             invokeRestart(restart)
[11:01:55.941]                             muffled <- TRUE
[11:01:55.941]                             break
[11:01:55.941]                           }
[11:01:55.941]                         }
[11:01:55.941]                       }
[11:01:55.941]                       invisible(muffled)
[11:01:55.941]                     }
[11:01:55.941]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.941]                   }
[11:01:55.941]                 }
[11:01:55.941]                 else {
[11:01:55.941]                   if (TRUE) {
[11:01:55.941]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:55.941]                     {
[11:01:55.941]                       inherits <- base::inherits
[11:01:55.941]                       invokeRestart <- base::invokeRestart
[11:01:55.941]                       is.null <- base::is.null
[11:01:55.941]                       muffled <- FALSE
[11:01:55.941]                       if (inherits(cond, "message")) {
[11:01:55.941]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:55.941]                         if (muffled) 
[11:01:55.941]                           invokeRestart("muffleMessage")
[11:01:55.941]                       }
[11:01:55.941]                       else if (inherits(cond, "warning")) {
[11:01:55.941]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:55.941]                         if (muffled) 
[11:01:55.941]                           invokeRestart("muffleWarning")
[11:01:55.941]                       }
[11:01:55.941]                       else if (inherits(cond, "condition")) {
[11:01:55.941]                         if (!is.null(pattern)) {
[11:01:55.941]                           computeRestarts <- base::computeRestarts
[11:01:55.941]                           grepl <- base::grepl
[11:01:55.941]                           restarts <- computeRestarts(cond)
[11:01:55.941]                           for (restart in restarts) {
[11:01:55.941]                             name <- restart$name
[11:01:55.941]                             if (is.null(name)) 
[11:01:55.941]                               next
[11:01:55.941]                             if (!grepl(pattern, name)) 
[11:01:55.941]                               next
[11:01:55.941]                             invokeRestart(restart)
[11:01:55.941]                             muffled <- TRUE
[11:01:55.941]                             break
[11:01:55.941]                           }
[11:01:55.941]                         }
[11:01:55.941]                       }
[11:01:55.941]                       invisible(muffled)
[11:01:55.941]                     }
[11:01:55.941]                     muffleCondition(cond, pattern = "^muffle")
[11:01:55.941]                   }
[11:01:55.941]                 }
[11:01:55.941]             }
[11:01:55.941]         }))
[11:01:55.941]     }, error = function(ex) {
[11:01:55.941]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:55.941]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:55.941]                 ...future.rng), started = ...future.startTime, 
[11:01:55.941]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:55.941]             version = "1.8"), class = "FutureResult")
[11:01:55.941]     }, finally = {
[11:01:55.941]         if (!identical(...future.workdir, getwd())) 
[11:01:55.941]             setwd(...future.workdir)
[11:01:55.941]         {
[11:01:55.941]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:55.941]                 ...future.oldOptions$nwarnings <- NULL
[11:01:55.941]             }
[11:01:55.941]             base::options(...future.oldOptions)
[11:01:55.941]             if (.Platform$OS.type == "windows") {
[11:01:55.941]                 old_names <- names(...future.oldEnvVars)
[11:01:55.941]                 envs <- base::Sys.getenv()
[11:01:55.941]                 names <- names(envs)
[11:01:55.941]                 common <- intersect(names, old_names)
[11:01:55.941]                 added <- setdiff(names, old_names)
[11:01:55.941]                 removed <- setdiff(old_names, names)
[11:01:55.941]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:55.941]                   envs[common]]
[11:01:55.941]                 NAMES <- toupper(changed)
[11:01:55.941]                 args <- list()
[11:01:55.941]                 for (kk in seq_along(NAMES)) {
[11:01:55.941]                   name <- changed[[kk]]
[11:01:55.941]                   NAME <- NAMES[[kk]]
[11:01:55.941]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.941]                     next
[11:01:55.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.941]                 }
[11:01:55.941]                 NAMES <- toupper(added)
[11:01:55.941]                 for (kk in seq_along(NAMES)) {
[11:01:55.941]                   name <- added[[kk]]
[11:01:55.941]                   NAME <- NAMES[[kk]]
[11:01:55.941]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.941]                     next
[11:01:55.941]                   args[[name]] <- ""
[11:01:55.941]                 }
[11:01:55.941]                 NAMES <- toupper(removed)
[11:01:55.941]                 for (kk in seq_along(NAMES)) {
[11:01:55.941]                   name <- removed[[kk]]
[11:01:55.941]                   NAME <- NAMES[[kk]]
[11:01:55.941]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:55.941]                     next
[11:01:55.941]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:55.941]                 }
[11:01:55.941]                 if (length(args) > 0) 
[11:01:55.941]                   base::do.call(base::Sys.setenv, args = args)
[11:01:55.941]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:55.941]             }
[11:01:55.941]             else {
[11:01:55.941]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:55.941]             }
[11:01:55.941]             {
[11:01:55.941]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:55.941]                   0L) {
[11:01:55.941]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:55.941]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:55.941]                   base::options(opts)
[11:01:55.941]                 }
[11:01:55.941]                 {
[11:01:55.941]                   {
[11:01:55.941]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:55.941]                     NULL
[11:01:55.941]                   }
[11:01:55.941]                   options(future.plan = NULL)
[11:01:55.941]                   if (is.na(NA_character_)) 
[11:01:55.941]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:55.941]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:55.941]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:55.941]                     .init = FALSE)
[11:01:55.941]                 }
[11:01:55.941]             }
[11:01:55.941]         }
[11:01:55.941]     })
[11:01:55.941]     if (TRUE) {
[11:01:55.941]         base::sink(type = "output", split = FALSE)
[11:01:55.941]         if (TRUE) {
[11:01:55.941]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:55.941]         }
[11:01:55.941]         else {
[11:01:55.941]             ...future.result["stdout"] <- base::list(NULL)
[11:01:55.941]         }
[11:01:55.941]         base::close(...future.stdout)
[11:01:55.941]         ...future.stdout <- NULL
[11:01:55.941]     }
[11:01:55.941]     ...future.result$conditions <- ...future.conditions
[11:01:55.941]     ...future.result$finished <- base::Sys.time()
[11:01:55.941]     ...future.result
[11:01:55.941] }
[11:01:55.944] MultisessionFuture started
[11:01:55.944] - Launch lazy future ... done
[11:01:55.944] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:55.944] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:55.944] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:55.945] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:55.945] Searching for globals ... DONE
[11:01:55.945] Resolving globals: TRUE
[11:01:55.945] Resolving any globals that are futures ...
[11:01:55.945] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:55.945] Resolving any globals that are futures ... DONE
[11:01:55.948] Resolving futures part of globals (recursively) ...
[11:01:55.948] resolve() on list ...
[11:01:55.948]  recursive: 99
[11:01:55.948]  length: 1
[11:01:55.948]  elements: ‘a’
[11:01:55.990] receiveMessageFromWorker() for ClusterFuture ...
[11:01:55.990] - Validating connection of MultisessionFuture
[11:01:55.990] - received message: FutureResult
[11:01:55.990] - Received FutureResult
[11:01:55.990] - Erased future from FutureRegistry
[11:01:55.990] result() for ClusterFuture ...
[11:01:55.991] - result already collected: FutureResult
[11:01:55.991] result() for ClusterFuture ... done
[11:01:55.991] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:55.991] Future #1
[11:01:55.991] result() for ClusterFuture ...
[11:01:55.991] - result already collected: FutureResult
[11:01:55.991] result() for ClusterFuture ... done
[11:01:55.991] result() for ClusterFuture ...
[11:01:55.991] - result already collected: FutureResult
[11:01:55.991] result() for ClusterFuture ... done
[11:01:55.991] A MultisessionFuture was resolved
[11:01:55.991]  length: 0 (resolved future 1)
[11:01:55.992] resolve() on list ... DONE
[11:01:55.992] - globals: [1] ‘a’
[11:01:55.992] Resolving futures part of globals (recursively) ... DONE
[11:01:56.003] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[11:01:56.003] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[11:01:56.003] - globals: [1] ‘a’
[11:01:56.003] - packages: [1] ‘future’
[11:01:56.003] getGlobalsAndPackages() ... DONE
[11:01:56.004] run() for ‘Future’ ...
[11:01:56.004] - state: ‘created’
[11:01:56.004] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.017] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.018] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.018]   - Field: ‘node’
[11:01:56.018]   - Field: ‘label’
[11:01:56.018]   - Field: ‘local’
[11:01:56.018]   - Field: ‘owner’
[11:01:56.018]   - Field: ‘envir’
[11:01:56.018]   - Field: ‘workers’
[11:01:56.018]   - Field: ‘packages’
[11:01:56.018]   - Field: ‘gc’
[11:01:56.018]   - Field: ‘conditions’
[11:01:56.018]   - Field: ‘persistent’
[11:01:56.018]   - Field: ‘expr’
[11:01:56.019]   - Field: ‘uuid’
[11:01:56.019]   - Field: ‘seed’
[11:01:56.019]   - Field: ‘version’
[11:01:56.019]   - Field: ‘result’
[11:01:56.019]   - Field: ‘asynchronous’
[11:01:56.019]   - Field: ‘calls’
[11:01:56.019]   - Field: ‘globals’
[11:01:56.019]   - Field: ‘stdout’
[11:01:56.019]   - Field: ‘earlySignal’
[11:01:56.019]   - Field: ‘lazy’
[11:01:56.019]   - Field: ‘state’
[11:01:56.019] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.020] - Launch lazy future ...
[11:01:56.020] Packages needed by the future expression (n = 1): ‘future’
[11:01:56.020] Packages needed by future strategies (n = 0): <none>
[11:01:56.020] {
[11:01:56.020]     {
[11:01:56.020]         {
[11:01:56.020]             ...future.startTime <- base::Sys.time()
[11:01:56.020]             {
[11:01:56.020]                 {
[11:01:56.020]                   {
[11:01:56.020]                     {
[11:01:56.020]                       {
[11:01:56.020]                         base::local({
[11:01:56.020]                           has_future <- base::requireNamespace("future", 
[11:01:56.020]                             quietly = TRUE)
[11:01:56.020]                           if (has_future) {
[11:01:56.020]                             ns <- base::getNamespace("future")
[11:01:56.020]                             version <- ns[[".package"]][["version"]]
[11:01:56.020]                             if (is.null(version)) 
[11:01:56.020]                               version <- utils::packageVersion("future")
[11:01:56.020]                           }
[11:01:56.020]                           else {
[11:01:56.020]                             version <- NULL
[11:01:56.020]                           }
[11:01:56.020]                           if (!has_future || version < "1.8.0") {
[11:01:56.020]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.020]                               "", base::R.version$version.string), 
[11:01:56.020]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:56.020]                                 base::R.version$platform, 8 * 
[11:01:56.020]                                   base::.Machine$sizeof.pointer), 
[11:01:56.020]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.020]                                 "release", "version")], collapse = " "), 
[11:01:56.020]                               hostname = base::Sys.info()[["nodename"]])
[11:01:56.020]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.020]                               info)
[11:01:56.020]                             info <- base::paste(info, collapse = "; ")
[11:01:56.020]                             if (!has_future) {
[11:01:56.020]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.020]                                 info)
[11:01:56.020]                             }
[11:01:56.020]                             else {
[11:01:56.020]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.020]                                 info, version)
[11:01:56.020]                             }
[11:01:56.020]                             base::stop(msg)
[11:01:56.020]                           }
[11:01:56.020]                         })
[11:01:56.020]                       }
[11:01:56.020]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.020]                       base::options(mc.cores = 1L)
[11:01:56.020]                     }
[11:01:56.020]                     base::local({
[11:01:56.020]                       for (pkg in "future") {
[11:01:56.020]                         base::loadNamespace(pkg)
[11:01:56.020]                         base::library(pkg, character.only = TRUE)
[11:01:56.020]                       }
[11:01:56.020]                     })
[11:01:56.020]                   }
[11:01:56.020]                   ...future.strategy.old <- future::plan("list")
[11:01:56.020]                   options(future.plan = NULL)
[11:01:56.020]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.020]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.020]                 }
[11:01:56.020]                 ...future.workdir <- getwd()
[11:01:56.020]             }
[11:01:56.020]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.020]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.020]         }
[11:01:56.020]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.020]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.020]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.020]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.020]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.020]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.020]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.020]             base::names(...future.oldOptions))
[11:01:56.020]     }
[11:01:56.020]     if (FALSE) {
[11:01:56.020]     }
[11:01:56.020]     else {
[11:01:56.020]         if (TRUE) {
[11:01:56.020]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.020]                 open = "w")
[11:01:56.020]         }
[11:01:56.020]         else {
[11:01:56.020]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.020]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.020]         }
[11:01:56.020]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.020]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.020]             base::sink(type = "output", split = FALSE)
[11:01:56.020]             base::close(...future.stdout)
[11:01:56.020]         }, add = TRUE)
[11:01:56.020]     }
[11:01:56.020]     ...future.frame <- base::sys.nframe()
[11:01:56.020]     ...future.conditions <- base::list()
[11:01:56.020]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.020]     if (FALSE) {
[11:01:56.020]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.020]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.020]     }
[11:01:56.020]     ...future.result <- base::tryCatch({
[11:01:56.020]         base::withCallingHandlers({
[11:01:56.020]             ...future.value <- base::withVisible(base::local({
[11:01:56.020]                 ...future.makeSendCondition <- base::local({
[11:01:56.020]                   sendCondition <- NULL
[11:01:56.020]                   function(frame = 1L) {
[11:01:56.020]                     if (is.function(sendCondition)) 
[11:01:56.020]                       return(sendCondition)
[11:01:56.020]                     ns <- getNamespace("parallel")
[11:01:56.020]                     if (exists("sendData", mode = "function", 
[11:01:56.020]                       envir = ns)) {
[11:01:56.020]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.020]                         envir = ns)
[11:01:56.020]                       envir <- sys.frame(frame)
[11:01:56.020]                       master <- NULL
[11:01:56.020]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.020]                         !identical(envir, emptyenv())) {
[11:01:56.020]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.020]                           inherits = FALSE)) {
[11:01:56.020]                           master <- get("master", mode = "list", 
[11:01:56.020]                             envir = envir, inherits = FALSE)
[11:01:56.020]                           if (inherits(master, c("SOCKnode", 
[11:01:56.020]                             "SOCK0node"))) {
[11:01:56.020]                             sendCondition <<- function(cond) {
[11:01:56.020]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.020]                                 success = TRUE)
[11:01:56.020]                               parallel_sendData(master, data)
[11:01:56.020]                             }
[11:01:56.020]                             return(sendCondition)
[11:01:56.020]                           }
[11:01:56.020]                         }
[11:01:56.020]                         frame <- frame + 1L
[11:01:56.020]                         envir <- sys.frame(frame)
[11:01:56.020]                       }
[11:01:56.020]                     }
[11:01:56.020]                     sendCondition <<- function(cond) NULL
[11:01:56.020]                   }
[11:01:56.020]                 })
[11:01:56.020]                 withCallingHandlers({
[11:01:56.020]                   value(a) + 1
[11:01:56.020]                 }, immediateCondition = function(cond) {
[11:01:56.020]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.020]                   sendCondition(cond)
[11:01:56.020]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.020]                   {
[11:01:56.020]                     inherits <- base::inherits
[11:01:56.020]                     invokeRestart <- base::invokeRestart
[11:01:56.020]                     is.null <- base::is.null
[11:01:56.020]                     muffled <- FALSE
[11:01:56.020]                     if (inherits(cond, "message")) {
[11:01:56.020]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.020]                       if (muffled) 
[11:01:56.020]                         invokeRestart("muffleMessage")
[11:01:56.020]                     }
[11:01:56.020]                     else if (inherits(cond, "warning")) {
[11:01:56.020]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.020]                       if (muffled) 
[11:01:56.020]                         invokeRestart("muffleWarning")
[11:01:56.020]                     }
[11:01:56.020]                     else if (inherits(cond, "condition")) {
[11:01:56.020]                       if (!is.null(pattern)) {
[11:01:56.020]                         computeRestarts <- base::computeRestarts
[11:01:56.020]                         grepl <- base::grepl
[11:01:56.020]                         restarts <- computeRestarts(cond)
[11:01:56.020]                         for (restart in restarts) {
[11:01:56.020]                           name <- restart$name
[11:01:56.020]                           if (is.null(name)) 
[11:01:56.020]                             next
[11:01:56.020]                           if (!grepl(pattern, name)) 
[11:01:56.020]                             next
[11:01:56.020]                           invokeRestart(restart)
[11:01:56.020]                           muffled <- TRUE
[11:01:56.020]                           break
[11:01:56.020]                         }
[11:01:56.020]                       }
[11:01:56.020]                     }
[11:01:56.020]                     invisible(muffled)
[11:01:56.020]                   }
[11:01:56.020]                   muffleCondition(cond)
[11:01:56.020]                 })
[11:01:56.020]             }))
[11:01:56.020]             future::FutureResult(value = ...future.value$value, 
[11:01:56.020]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.020]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.020]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.020]                     ...future.globalenv.names))
[11:01:56.020]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.020]         }, condition = base::local({
[11:01:56.020]             c <- base::c
[11:01:56.020]             inherits <- base::inherits
[11:01:56.020]             invokeRestart <- base::invokeRestart
[11:01:56.020]             length <- base::length
[11:01:56.020]             list <- base::list
[11:01:56.020]             seq.int <- base::seq.int
[11:01:56.020]             signalCondition <- base::signalCondition
[11:01:56.020]             sys.calls <- base::sys.calls
[11:01:56.020]             `[[` <- base::`[[`
[11:01:56.020]             `+` <- base::`+`
[11:01:56.020]             `<<-` <- base::`<<-`
[11:01:56.020]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.020]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.020]                   3L)]
[11:01:56.020]             }
[11:01:56.020]             function(cond) {
[11:01:56.020]                 is_error <- inherits(cond, "error")
[11:01:56.020]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.020]                   NULL)
[11:01:56.020]                 if (is_error) {
[11:01:56.020]                   sessionInformation <- function() {
[11:01:56.020]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.020]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.020]                       search = base::search(), system = base::Sys.info())
[11:01:56.020]                   }
[11:01:56.020]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.020]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.020]                     cond$call), session = sessionInformation(), 
[11:01:56.020]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.020]                   signalCondition(cond)
[11:01:56.020]                 }
[11:01:56.020]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.020]                 "immediateCondition"))) {
[11:01:56.020]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.020]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.020]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.020]                   if (TRUE && !signal) {
[11:01:56.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.020]                     {
[11:01:56.020]                       inherits <- base::inherits
[11:01:56.020]                       invokeRestart <- base::invokeRestart
[11:01:56.020]                       is.null <- base::is.null
[11:01:56.020]                       muffled <- FALSE
[11:01:56.020]                       if (inherits(cond, "message")) {
[11:01:56.020]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.020]                         if (muffled) 
[11:01:56.020]                           invokeRestart("muffleMessage")
[11:01:56.020]                       }
[11:01:56.020]                       else if (inherits(cond, "warning")) {
[11:01:56.020]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.020]                         if (muffled) 
[11:01:56.020]                           invokeRestart("muffleWarning")
[11:01:56.020]                       }
[11:01:56.020]                       else if (inherits(cond, "condition")) {
[11:01:56.020]                         if (!is.null(pattern)) {
[11:01:56.020]                           computeRestarts <- base::computeRestarts
[11:01:56.020]                           grepl <- base::grepl
[11:01:56.020]                           restarts <- computeRestarts(cond)
[11:01:56.020]                           for (restart in restarts) {
[11:01:56.020]                             name <- restart$name
[11:01:56.020]                             if (is.null(name)) 
[11:01:56.020]                               next
[11:01:56.020]                             if (!grepl(pattern, name)) 
[11:01:56.020]                               next
[11:01:56.020]                             invokeRestart(restart)
[11:01:56.020]                             muffled <- TRUE
[11:01:56.020]                             break
[11:01:56.020]                           }
[11:01:56.020]                         }
[11:01:56.020]                       }
[11:01:56.020]                       invisible(muffled)
[11:01:56.020]                     }
[11:01:56.020]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.020]                   }
[11:01:56.020]                 }
[11:01:56.020]                 else {
[11:01:56.020]                   if (TRUE) {
[11:01:56.020]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.020]                     {
[11:01:56.020]                       inherits <- base::inherits
[11:01:56.020]                       invokeRestart <- base::invokeRestart
[11:01:56.020]                       is.null <- base::is.null
[11:01:56.020]                       muffled <- FALSE
[11:01:56.020]                       if (inherits(cond, "message")) {
[11:01:56.020]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.020]                         if (muffled) 
[11:01:56.020]                           invokeRestart("muffleMessage")
[11:01:56.020]                       }
[11:01:56.020]                       else if (inherits(cond, "warning")) {
[11:01:56.020]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.020]                         if (muffled) 
[11:01:56.020]                           invokeRestart("muffleWarning")
[11:01:56.020]                       }
[11:01:56.020]                       else if (inherits(cond, "condition")) {
[11:01:56.020]                         if (!is.null(pattern)) {
[11:01:56.020]                           computeRestarts <- base::computeRestarts
[11:01:56.020]                           grepl <- base::grepl
[11:01:56.020]                           restarts <- computeRestarts(cond)
[11:01:56.020]                           for (restart in restarts) {
[11:01:56.020]                             name <- restart$name
[11:01:56.020]                             if (is.null(name)) 
[11:01:56.020]                               next
[11:01:56.020]                             if (!grepl(pattern, name)) 
[11:01:56.020]                               next
[11:01:56.020]                             invokeRestart(restart)
[11:01:56.020]                             muffled <- TRUE
[11:01:56.020]                             break
[11:01:56.020]                           }
[11:01:56.020]                         }
[11:01:56.020]                       }
[11:01:56.020]                       invisible(muffled)
[11:01:56.020]                     }
[11:01:56.020]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.020]                   }
[11:01:56.020]                 }
[11:01:56.020]             }
[11:01:56.020]         }))
[11:01:56.020]     }, error = function(ex) {
[11:01:56.020]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.020]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.020]                 ...future.rng), started = ...future.startTime, 
[11:01:56.020]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.020]             version = "1.8"), class = "FutureResult")
[11:01:56.020]     }, finally = {
[11:01:56.020]         if (!identical(...future.workdir, getwd())) 
[11:01:56.020]             setwd(...future.workdir)
[11:01:56.020]         {
[11:01:56.020]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.020]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.020]             }
[11:01:56.020]             base::options(...future.oldOptions)
[11:01:56.020]             if (.Platform$OS.type == "windows") {
[11:01:56.020]                 old_names <- names(...future.oldEnvVars)
[11:01:56.020]                 envs <- base::Sys.getenv()
[11:01:56.020]                 names <- names(envs)
[11:01:56.020]                 common <- intersect(names, old_names)
[11:01:56.020]                 added <- setdiff(names, old_names)
[11:01:56.020]                 removed <- setdiff(old_names, names)
[11:01:56.020]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.020]                   envs[common]]
[11:01:56.020]                 NAMES <- toupper(changed)
[11:01:56.020]                 args <- list()
[11:01:56.020]                 for (kk in seq_along(NAMES)) {
[11:01:56.020]                   name <- changed[[kk]]
[11:01:56.020]                   NAME <- NAMES[[kk]]
[11:01:56.020]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.020]                     next
[11:01:56.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.020]                 }
[11:01:56.020]                 NAMES <- toupper(added)
[11:01:56.020]                 for (kk in seq_along(NAMES)) {
[11:01:56.020]                   name <- added[[kk]]
[11:01:56.020]                   NAME <- NAMES[[kk]]
[11:01:56.020]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.020]                     next
[11:01:56.020]                   args[[name]] <- ""
[11:01:56.020]                 }
[11:01:56.020]                 NAMES <- toupper(removed)
[11:01:56.020]                 for (kk in seq_along(NAMES)) {
[11:01:56.020]                   name <- removed[[kk]]
[11:01:56.020]                   NAME <- NAMES[[kk]]
[11:01:56.020]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.020]                     next
[11:01:56.020]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.020]                 }
[11:01:56.020]                 if (length(args) > 0) 
[11:01:56.020]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.020]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.020]             }
[11:01:56.020]             else {
[11:01:56.020]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.020]             }
[11:01:56.020]             {
[11:01:56.020]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.020]                   0L) {
[11:01:56.020]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.020]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.020]                   base::options(opts)
[11:01:56.020]                 }
[11:01:56.020]                 {
[11:01:56.020]                   {
[11:01:56.020]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.020]                     NULL
[11:01:56.020]                   }
[11:01:56.020]                   options(future.plan = NULL)
[11:01:56.020]                   if (is.na(NA_character_)) 
[11:01:56.020]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.020]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.020]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.020]                     .init = FALSE)
[11:01:56.020]                 }
[11:01:56.020]             }
[11:01:56.020]         }
[11:01:56.020]     })
[11:01:56.020]     if (TRUE) {
[11:01:56.020]         base::sink(type = "output", split = FALSE)
[11:01:56.020]         if (TRUE) {
[11:01:56.020]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.020]         }
[11:01:56.020]         else {
[11:01:56.020]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.020]         }
[11:01:56.020]         base::close(...future.stdout)
[11:01:56.020]         ...future.stdout <- NULL
[11:01:56.020]     }
[11:01:56.020]     ...future.result$conditions <- ...future.conditions
[11:01:56.020]     ...future.result$finished <- base::Sys.time()
[11:01:56.020]     ...future.result
[11:01:56.020] }
[11:01:56.034] Exporting 1 global objects (313.44 KiB) to cluster node #1 ...
[11:01:56.044] Exporting ‘a’ (313.23 KiB) to cluster node #1 ...
[11:01:56.097] Exporting ‘a’ (313.23 KiB) to cluster node #1 ... DONE
[11:01:56.097] Exporting 1 global objects (313.44 KiB) to cluster node #1 ... DONE
[11:01:56.098] MultisessionFuture started
[11:01:56.098] - Launch lazy future ... done
[11:01:56.098] run() for ‘MultisessionFuture’ ... done
[11:01:56.098] result() for ClusterFuture ...
[11:01:56.098] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.098] - Validating connection of MultisessionFuture
[11:01:56.144] - received message: FutureResult
[11:01:56.144] - Received FutureResult
[11:01:56.144] - Erased future from FutureRegistry
[11:01:56.144] result() for ClusterFuture ...
[11:01:56.144] - result already collected: FutureResult
[11:01:56.144] result() for ClusterFuture ... done
[11:01:56.144] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.144] result() for ClusterFuture ... done
[11:01:56.144] result() for ClusterFuture ...
[11:01:56.145] - result already collected: FutureResult
[11:01:56.145] result() for ClusterFuture ... done
value(b) = 2
[11:01:56.145] result() for ClusterFuture ...
[11:01:56.145] - result already collected: FutureResult
[11:01:56.145] result() for ClusterFuture ... done
[11:01:56.145] result() for ClusterFuture ...
[11:01:56.145] - result already collected: FutureResult
[11:01:56.145] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.145] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.146] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.146] 
[11:01:56.146] Searching for globals ... DONE
[11:01:56.146] - globals: [0] <none>
[11:01:56.146] getGlobalsAndPackages() ... DONE
[11:01:56.147] run() for ‘Future’ ...
[11:01:56.147] - state: ‘created’
[11:01:56.147] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.162] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.162] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.162]   - Field: ‘node’
[11:01:56.163]   - Field: ‘label’
[11:01:56.163]   - Field: ‘local’
[11:01:56.163]   - Field: ‘owner’
[11:01:56.163]   - Field: ‘envir’
[11:01:56.163]   - Field: ‘workers’
[11:01:56.163]   - Field: ‘packages’
[11:01:56.163]   - Field: ‘gc’
[11:01:56.163]   - Field: ‘conditions’
[11:01:56.163]   - Field: ‘persistent’
[11:01:56.163]   - Field: ‘expr’
[11:01:56.163]   - Field: ‘uuid’
[11:01:56.163]   - Field: ‘seed’
[11:01:56.164]   - Field: ‘version’
[11:01:56.164]   - Field: ‘result’
[11:01:56.164]   - Field: ‘asynchronous’
[11:01:56.164]   - Field: ‘calls’
[11:01:56.164]   - Field: ‘globals’
[11:01:56.164]   - Field: ‘stdout’
[11:01:56.164]   - Field: ‘earlySignal’
[11:01:56.164]   - Field: ‘lazy’
[11:01:56.164]   - Field: ‘state’
[11:01:56.164] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.164] - Launch lazy future ...
[11:01:56.165] Packages needed by the future expression (n = 0): <none>
[11:01:56.165] Packages needed by future strategies (n = 0): <none>
[11:01:56.165] {
[11:01:56.165]     {
[11:01:56.165]         {
[11:01:56.165]             ...future.startTime <- base::Sys.time()
[11:01:56.165]             {
[11:01:56.165]                 {
[11:01:56.165]                   {
[11:01:56.165]                     {
[11:01:56.165]                       base::local({
[11:01:56.165]                         has_future <- base::requireNamespace("future", 
[11:01:56.165]                           quietly = TRUE)
[11:01:56.165]                         if (has_future) {
[11:01:56.165]                           ns <- base::getNamespace("future")
[11:01:56.165]                           version <- ns[[".package"]][["version"]]
[11:01:56.165]                           if (is.null(version)) 
[11:01:56.165]                             version <- utils::packageVersion("future")
[11:01:56.165]                         }
[11:01:56.165]                         else {
[11:01:56.165]                           version <- NULL
[11:01:56.165]                         }
[11:01:56.165]                         if (!has_future || version < "1.8.0") {
[11:01:56.165]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.165]                             "", base::R.version$version.string), 
[11:01:56.165]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:56.165]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:56.165]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.165]                               "release", "version")], collapse = " "), 
[11:01:56.165]                             hostname = base::Sys.info()[["nodename"]])
[11:01:56.165]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.165]                             info)
[11:01:56.165]                           info <- base::paste(info, collapse = "; ")
[11:01:56.165]                           if (!has_future) {
[11:01:56.165]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.165]                               info)
[11:01:56.165]                           }
[11:01:56.165]                           else {
[11:01:56.165]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.165]                               info, version)
[11:01:56.165]                           }
[11:01:56.165]                           base::stop(msg)
[11:01:56.165]                         }
[11:01:56.165]                       })
[11:01:56.165]                     }
[11:01:56.165]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.165]                     base::options(mc.cores = 1L)
[11:01:56.165]                   }
[11:01:56.165]                   ...future.strategy.old <- future::plan("list")
[11:01:56.165]                   options(future.plan = NULL)
[11:01:56.165]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.165]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.165]                 }
[11:01:56.165]                 ...future.workdir <- getwd()
[11:01:56.165]             }
[11:01:56.165]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.165]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.165]         }
[11:01:56.165]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.165]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.165]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.165]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.165]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.165]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.165]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.165]             base::names(...future.oldOptions))
[11:01:56.165]     }
[11:01:56.165]     if (FALSE) {
[11:01:56.165]     }
[11:01:56.165]     else {
[11:01:56.165]         if (TRUE) {
[11:01:56.165]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.165]                 open = "w")
[11:01:56.165]         }
[11:01:56.165]         else {
[11:01:56.165]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.165]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.165]         }
[11:01:56.165]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.165]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.165]             base::sink(type = "output", split = FALSE)
[11:01:56.165]             base::close(...future.stdout)
[11:01:56.165]         }, add = TRUE)
[11:01:56.165]     }
[11:01:56.165]     ...future.frame <- base::sys.nframe()
[11:01:56.165]     ...future.conditions <- base::list()
[11:01:56.165]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.165]     if (FALSE) {
[11:01:56.165]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.165]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.165]     }
[11:01:56.165]     ...future.result <- base::tryCatch({
[11:01:56.165]         base::withCallingHandlers({
[11:01:56.165]             ...future.value <- base::withVisible(base::local({
[11:01:56.165]                 ...future.makeSendCondition <- base::local({
[11:01:56.165]                   sendCondition <- NULL
[11:01:56.165]                   function(frame = 1L) {
[11:01:56.165]                     if (is.function(sendCondition)) 
[11:01:56.165]                       return(sendCondition)
[11:01:56.165]                     ns <- getNamespace("parallel")
[11:01:56.165]                     if (exists("sendData", mode = "function", 
[11:01:56.165]                       envir = ns)) {
[11:01:56.165]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.165]                         envir = ns)
[11:01:56.165]                       envir <- sys.frame(frame)
[11:01:56.165]                       master <- NULL
[11:01:56.165]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.165]                         !identical(envir, emptyenv())) {
[11:01:56.165]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.165]                           inherits = FALSE)) {
[11:01:56.165]                           master <- get("master", mode = "list", 
[11:01:56.165]                             envir = envir, inherits = FALSE)
[11:01:56.165]                           if (inherits(master, c("SOCKnode", 
[11:01:56.165]                             "SOCK0node"))) {
[11:01:56.165]                             sendCondition <<- function(cond) {
[11:01:56.165]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.165]                                 success = TRUE)
[11:01:56.165]                               parallel_sendData(master, data)
[11:01:56.165]                             }
[11:01:56.165]                             return(sendCondition)
[11:01:56.165]                           }
[11:01:56.165]                         }
[11:01:56.165]                         frame <- frame + 1L
[11:01:56.165]                         envir <- sys.frame(frame)
[11:01:56.165]                       }
[11:01:56.165]                     }
[11:01:56.165]                     sendCondition <<- function(cond) NULL
[11:01:56.165]                   }
[11:01:56.165]                 })
[11:01:56.165]                 withCallingHandlers({
[11:01:56.165]                   1
[11:01:56.165]                 }, immediateCondition = function(cond) {
[11:01:56.165]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.165]                   sendCondition(cond)
[11:01:56.165]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.165]                   {
[11:01:56.165]                     inherits <- base::inherits
[11:01:56.165]                     invokeRestart <- base::invokeRestart
[11:01:56.165]                     is.null <- base::is.null
[11:01:56.165]                     muffled <- FALSE
[11:01:56.165]                     if (inherits(cond, "message")) {
[11:01:56.165]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.165]                       if (muffled) 
[11:01:56.165]                         invokeRestart("muffleMessage")
[11:01:56.165]                     }
[11:01:56.165]                     else if (inherits(cond, "warning")) {
[11:01:56.165]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.165]                       if (muffled) 
[11:01:56.165]                         invokeRestart("muffleWarning")
[11:01:56.165]                     }
[11:01:56.165]                     else if (inherits(cond, "condition")) {
[11:01:56.165]                       if (!is.null(pattern)) {
[11:01:56.165]                         computeRestarts <- base::computeRestarts
[11:01:56.165]                         grepl <- base::grepl
[11:01:56.165]                         restarts <- computeRestarts(cond)
[11:01:56.165]                         for (restart in restarts) {
[11:01:56.165]                           name <- restart$name
[11:01:56.165]                           if (is.null(name)) 
[11:01:56.165]                             next
[11:01:56.165]                           if (!grepl(pattern, name)) 
[11:01:56.165]                             next
[11:01:56.165]                           invokeRestart(restart)
[11:01:56.165]                           muffled <- TRUE
[11:01:56.165]                           break
[11:01:56.165]                         }
[11:01:56.165]                       }
[11:01:56.165]                     }
[11:01:56.165]                     invisible(muffled)
[11:01:56.165]                   }
[11:01:56.165]                   muffleCondition(cond)
[11:01:56.165]                 })
[11:01:56.165]             }))
[11:01:56.165]             future::FutureResult(value = ...future.value$value, 
[11:01:56.165]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.165]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.165]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.165]                     ...future.globalenv.names))
[11:01:56.165]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.165]         }, condition = base::local({
[11:01:56.165]             c <- base::c
[11:01:56.165]             inherits <- base::inherits
[11:01:56.165]             invokeRestart <- base::invokeRestart
[11:01:56.165]             length <- base::length
[11:01:56.165]             list <- base::list
[11:01:56.165]             seq.int <- base::seq.int
[11:01:56.165]             signalCondition <- base::signalCondition
[11:01:56.165]             sys.calls <- base::sys.calls
[11:01:56.165]             `[[` <- base::`[[`
[11:01:56.165]             `+` <- base::`+`
[11:01:56.165]             `<<-` <- base::`<<-`
[11:01:56.165]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.165]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.165]                   3L)]
[11:01:56.165]             }
[11:01:56.165]             function(cond) {
[11:01:56.165]                 is_error <- inherits(cond, "error")
[11:01:56.165]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.165]                   NULL)
[11:01:56.165]                 if (is_error) {
[11:01:56.165]                   sessionInformation <- function() {
[11:01:56.165]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.165]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.165]                       search = base::search(), system = base::Sys.info())
[11:01:56.165]                   }
[11:01:56.165]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.165]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.165]                     cond$call), session = sessionInformation(), 
[11:01:56.165]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.165]                   signalCondition(cond)
[11:01:56.165]                 }
[11:01:56.165]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.165]                 "immediateCondition"))) {
[11:01:56.165]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.165]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.165]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.165]                   if (TRUE && !signal) {
[11:01:56.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.165]                     {
[11:01:56.165]                       inherits <- base::inherits
[11:01:56.165]                       invokeRestart <- base::invokeRestart
[11:01:56.165]                       is.null <- base::is.null
[11:01:56.165]                       muffled <- FALSE
[11:01:56.165]                       if (inherits(cond, "message")) {
[11:01:56.165]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.165]                         if (muffled) 
[11:01:56.165]                           invokeRestart("muffleMessage")
[11:01:56.165]                       }
[11:01:56.165]                       else if (inherits(cond, "warning")) {
[11:01:56.165]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.165]                         if (muffled) 
[11:01:56.165]                           invokeRestart("muffleWarning")
[11:01:56.165]                       }
[11:01:56.165]                       else if (inherits(cond, "condition")) {
[11:01:56.165]                         if (!is.null(pattern)) {
[11:01:56.165]                           computeRestarts <- base::computeRestarts
[11:01:56.165]                           grepl <- base::grepl
[11:01:56.165]                           restarts <- computeRestarts(cond)
[11:01:56.165]                           for (restart in restarts) {
[11:01:56.165]                             name <- restart$name
[11:01:56.165]                             if (is.null(name)) 
[11:01:56.165]                               next
[11:01:56.165]                             if (!grepl(pattern, name)) 
[11:01:56.165]                               next
[11:01:56.165]                             invokeRestart(restart)
[11:01:56.165]                             muffled <- TRUE
[11:01:56.165]                             break
[11:01:56.165]                           }
[11:01:56.165]                         }
[11:01:56.165]                       }
[11:01:56.165]                       invisible(muffled)
[11:01:56.165]                     }
[11:01:56.165]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.165]                   }
[11:01:56.165]                 }
[11:01:56.165]                 else {
[11:01:56.165]                   if (TRUE) {
[11:01:56.165]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.165]                     {
[11:01:56.165]                       inherits <- base::inherits
[11:01:56.165]                       invokeRestart <- base::invokeRestart
[11:01:56.165]                       is.null <- base::is.null
[11:01:56.165]                       muffled <- FALSE
[11:01:56.165]                       if (inherits(cond, "message")) {
[11:01:56.165]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.165]                         if (muffled) 
[11:01:56.165]                           invokeRestart("muffleMessage")
[11:01:56.165]                       }
[11:01:56.165]                       else if (inherits(cond, "warning")) {
[11:01:56.165]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.165]                         if (muffled) 
[11:01:56.165]                           invokeRestart("muffleWarning")
[11:01:56.165]                       }
[11:01:56.165]                       else if (inherits(cond, "condition")) {
[11:01:56.165]                         if (!is.null(pattern)) {
[11:01:56.165]                           computeRestarts <- base::computeRestarts
[11:01:56.165]                           grepl <- base::grepl
[11:01:56.165]                           restarts <- computeRestarts(cond)
[11:01:56.165]                           for (restart in restarts) {
[11:01:56.165]                             name <- restart$name
[11:01:56.165]                             if (is.null(name)) 
[11:01:56.165]                               next
[11:01:56.165]                             if (!grepl(pattern, name)) 
[11:01:56.165]                               next
[11:01:56.165]                             invokeRestart(restart)
[11:01:56.165]                             muffled <- TRUE
[11:01:56.165]                             break
[11:01:56.165]                           }
[11:01:56.165]                         }
[11:01:56.165]                       }
[11:01:56.165]                       invisible(muffled)
[11:01:56.165]                     }
[11:01:56.165]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.165]                   }
[11:01:56.165]                 }
[11:01:56.165]             }
[11:01:56.165]         }))
[11:01:56.165]     }, error = function(ex) {
[11:01:56.165]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.165]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.165]                 ...future.rng), started = ...future.startTime, 
[11:01:56.165]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.165]             version = "1.8"), class = "FutureResult")
[11:01:56.165]     }, finally = {
[11:01:56.165]         if (!identical(...future.workdir, getwd())) 
[11:01:56.165]             setwd(...future.workdir)
[11:01:56.165]         {
[11:01:56.165]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.165]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.165]             }
[11:01:56.165]             base::options(...future.oldOptions)
[11:01:56.165]             if (.Platform$OS.type == "windows") {
[11:01:56.165]                 old_names <- names(...future.oldEnvVars)
[11:01:56.165]                 envs <- base::Sys.getenv()
[11:01:56.165]                 names <- names(envs)
[11:01:56.165]                 common <- intersect(names, old_names)
[11:01:56.165]                 added <- setdiff(names, old_names)
[11:01:56.165]                 removed <- setdiff(old_names, names)
[11:01:56.165]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.165]                   envs[common]]
[11:01:56.165]                 NAMES <- toupper(changed)
[11:01:56.165]                 args <- list()
[11:01:56.165]                 for (kk in seq_along(NAMES)) {
[11:01:56.165]                   name <- changed[[kk]]
[11:01:56.165]                   NAME <- NAMES[[kk]]
[11:01:56.165]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.165]                     next
[11:01:56.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.165]                 }
[11:01:56.165]                 NAMES <- toupper(added)
[11:01:56.165]                 for (kk in seq_along(NAMES)) {
[11:01:56.165]                   name <- added[[kk]]
[11:01:56.165]                   NAME <- NAMES[[kk]]
[11:01:56.165]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.165]                     next
[11:01:56.165]                   args[[name]] <- ""
[11:01:56.165]                 }
[11:01:56.165]                 NAMES <- toupper(removed)
[11:01:56.165]                 for (kk in seq_along(NAMES)) {
[11:01:56.165]                   name <- removed[[kk]]
[11:01:56.165]                   NAME <- NAMES[[kk]]
[11:01:56.165]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.165]                     next
[11:01:56.165]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.165]                 }
[11:01:56.165]                 if (length(args) > 0) 
[11:01:56.165]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.165]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.165]             }
[11:01:56.165]             else {
[11:01:56.165]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.165]             }
[11:01:56.165]             {
[11:01:56.165]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.165]                   0L) {
[11:01:56.165]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.165]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.165]                   base::options(opts)
[11:01:56.165]                 }
[11:01:56.165]                 {
[11:01:56.165]                   {
[11:01:56.165]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.165]                     NULL
[11:01:56.165]                   }
[11:01:56.165]                   options(future.plan = NULL)
[11:01:56.165]                   if (is.na(NA_character_)) 
[11:01:56.165]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.165]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.165]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.165]                     .init = FALSE)
[11:01:56.165]                 }
[11:01:56.165]             }
[11:01:56.165]         }
[11:01:56.165]     })
[11:01:56.165]     if (TRUE) {
[11:01:56.165]         base::sink(type = "output", split = FALSE)
[11:01:56.165]         if (TRUE) {
[11:01:56.165]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.165]         }
[11:01:56.165]         else {
[11:01:56.165]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.165]         }
[11:01:56.165]         base::close(...future.stdout)
[11:01:56.165]         ...future.stdout <- NULL
[11:01:56.165]     }
[11:01:56.165]     ...future.result$conditions <- ...future.conditions
[11:01:56.165]     ...future.result$finished <- base::Sys.time()
[11:01:56.165]     ...future.result
[11:01:56.165] }
[11:01:56.168] MultisessionFuture started
[11:01:56.168] - Launch lazy future ... done
[11:01:56.168] run() for ‘MultisessionFuture’ ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.169] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.169] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.169] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:56.170] Searching for globals ... DONE
[11:01:56.170] Resolving globals: TRUE
[11:01:56.170] Resolving any globals that are futures ...
[11:01:56.170] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:56.170] Resolving any globals that are futures ... DONE
[11:01:56.170] Resolving futures part of globals (recursively) ...
[11:01:56.171] resolve() on list ...
[11:01:56.171]  recursive: 99
[11:01:56.171]  length: 1
[11:01:56.171]  elements: ‘a’
[11:01:56.212] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.213] - Validating connection of MultisessionFuture
[11:01:56.213] - received message: FutureResult
[11:01:56.213] - Received FutureResult
[11:01:56.213] - Erased future from FutureRegistry
[11:01:56.213] result() for ClusterFuture ...
[11:01:56.213] - result already collected: FutureResult
[11:01:56.213] result() for ClusterFuture ... done
[11:01:56.213] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.213] Future #1
[11:01:56.214] result() for ClusterFuture ...
[11:01:56.214] - result already collected: FutureResult
[11:01:56.214] result() for ClusterFuture ... done
[11:01:56.214] result() for ClusterFuture ...
[11:01:56.214] - result already collected: FutureResult
[11:01:56.214] result() for ClusterFuture ... done
[11:01:56.214] A MultisessionFuture was resolved
[11:01:56.214]  length: 0 (resolved future 1)
[11:01:56.214] resolve() on list ... DONE
[11:01:56.214] - globals: [1] ‘a’
[11:01:56.214] Resolving futures part of globals (recursively) ... DONE
[11:01:56.225] The total size of the 1 globals is 313.23 KiB (320750 bytes)
[11:01:56.226] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.23 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.23 KiB of class ‘environment’)
[11:01:56.226] - globals: [1] ‘a’
[11:01:56.226] - packages: [1] ‘future’
[11:01:56.226] getGlobalsAndPackages() ... DONE
[11:01:56.226] run() for ‘Future’ ...
[11:01:56.226] - state: ‘created’
[11:01:56.226] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.240] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.240] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.240]   - Field: ‘node’
[11:01:56.240]   - Field: ‘label’
[11:01:56.240]   - Field: ‘local’
[11:01:56.241]   - Field: ‘owner’
[11:01:56.241]   - Field: ‘envir’
[11:01:56.241]   - Field: ‘workers’
[11:01:56.241]   - Field: ‘packages’
[11:01:56.241]   - Field: ‘gc’
[11:01:56.241]   - Field: ‘conditions’
[11:01:56.241]   - Field: ‘persistent’
[11:01:56.241]   - Field: ‘expr’
[11:01:56.241]   - Field: ‘uuid’
[11:01:56.241]   - Field: ‘seed’
[11:01:56.241]   - Field: ‘version’
[11:01:56.241]   - Field: ‘result’
[11:01:56.242]   - Field: ‘asynchronous’
[11:01:56.242]   - Field: ‘calls’
[11:01:56.242]   - Field: ‘globals’
[11:01:56.242]   - Field: ‘stdout’
[11:01:56.242]   - Field: ‘earlySignal’
[11:01:56.242]   - Field: ‘lazy’
[11:01:56.242]   - Field: ‘state’
[11:01:56.242] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.242] - Launch lazy future ...
[11:01:56.242] Packages needed by the future expression (n = 1): ‘future’
[11:01:56.243] Packages needed by future strategies (n = 0): <none>
[11:01:56.243] {
[11:01:56.243]     {
[11:01:56.243]         {
[11:01:56.243]             ...future.startTime <- base::Sys.time()
[11:01:56.243]             {
[11:01:56.243]                 {
[11:01:56.243]                   {
[11:01:56.243]                     {
[11:01:56.243]                       {
[11:01:56.243]                         base::local({
[11:01:56.243]                           has_future <- base::requireNamespace("future", 
[11:01:56.243]                             quietly = TRUE)
[11:01:56.243]                           if (has_future) {
[11:01:56.243]                             ns <- base::getNamespace("future")
[11:01:56.243]                             version <- ns[[".package"]][["version"]]
[11:01:56.243]                             if (is.null(version)) 
[11:01:56.243]                               version <- utils::packageVersion("future")
[11:01:56.243]                           }
[11:01:56.243]                           else {
[11:01:56.243]                             version <- NULL
[11:01:56.243]                           }
[11:01:56.243]                           if (!has_future || version < "1.8.0") {
[11:01:56.243]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.243]                               "", base::R.version$version.string), 
[11:01:56.243]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:56.243]                                 base::R.version$platform, 8 * 
[11:01:56.243]                                   base::.Machine$sizeof.pointer), 
[11:01:56.243]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.243]                                 "release", "version")], collapse = " "), 
[11:01:56.243]                               hostname = base::Sys.info()[["nodename"]])
[11:01:56.243]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.243]                               info)
[11:01:56.243]                             info <- base::paste(info, collapse = "; ")
[11:01:56.243]                             if (!has_future) {
[11:01:56.243]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.243]                                 info)
[11:01:56.243]                             }
[11:01:56.243]                             else {
[11:01:56.243]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.243]                                 info, version)
[11:01:56.243]                             }
[11:01:56.243]                             base::stop(msg)
[11:01:56.243]                           }
[11:01:56.243]                         })
[11:01:56.243]                       }
[11:01:56.243]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.243]                       base::options(mc.cores = 1L)
[11:01:56.243]                     }
[11:01:56.243]                     base::local({
[11:01:56.243]                       for (pkg in "future") {
[11:01:56.243]                         base::loadNamespace(pkg)
[11:01:56.243]                         base::library(pkg, character.only = TRUE)
[11:01:56.243]                       }
[11:01:56.243]                     })
[11:01:56.243]                   }
[11:01:56.243]                   ...future.strategy.old <- future::plan("list")
[11:01:56.243]                   options(future.plan = NULL)
[11:01:56.243]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.243]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.243]                 }
[11:01:56.243]                 ...future.workdir <- getwd()
[11:01:56.243]             }
[11:01:56.243]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.243]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.243]         }
[11:01:56.243]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.243]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.243]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.243]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.243]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.243]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.243]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.243]             base::names(...future.oldOptions))
[11:01:56.243]     }
[11:01:56.243]     if (FALSE) {
[11:01:56.243]     }
[11:01:56.243]     else {
[11:01:56.243]         if (TRUE) {
[11:01:56.243]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.243]                 open = "w")
[11:01:56.243]         }
[11:01:56.243]         else {
[11:01:56.243]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.243]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.243]         }
[11:01:56.243]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.243]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.243]             base::sink(type = "output", split = FALSE)
[11:01:56.243]             base::close(...future.stdout)
[11:01:56.243]         }, add = TRUE)
[11:01:56.243]     }
[11:01:56.243]     ...future.frame <- base::sys.nframe()
[11:01:56.243]     ...future.conditions <- base::list()
[11:01:56.243]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.243]     if (FALSE) {
[11:01:56.243]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.243]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.243]     }
[11:01:56.243]     ...future.result <- base::tryCatch({
[11:01:56.243]         base::withCallingHandlers({
[11:01:56.243]             ...future.value <- base::withVisible(base::local({
[11:01:56.243]                 ...future.makeSendCondition <- base::local({
[11:01:56.243]                   sendCondition <- NULL
[11:01:56.243]                   function(frame = 1L) {
[11:01:56.243]                     if (is.function(sendCondition)) 
[11:01:56.243]                       return(sendCondition)
[11:01:56.243]                     ns <- getNamespace("parallel")
[11:01:56.243]                     if (exists("sendData", mode = "function", 
[11:01:56.243]                       envir = ns)) {
[11:01:56.243]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.243]                         envir = ns)
[11:01:56.243]                       envir <- sys.frame(frame)
[11:01:56.243]                       master <- NULL
[11:01:56.243]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.243]                         !identical(envir, emptyenv())) {
[11:01:56.243]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.243]                           inherits = FALSE)) {
[11:01:56.243]                           master <- get("master", mode = "list", 
[11:01:56.243]                             envir = envir, inherits = FALSE)
[11:01:56.243]                           if (inherits(master, c("SOCKnode", 
[11:01:56.243]                             "SOCK0node"))) {
[11:01:56.243]                             sendCondition <<- function(cond) {
[11:01:56.243]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.243]                                 success = TRUE)
[11:01:56.243]                               parallel_sendData(master, data)
[11:01:56.243]                             }
[11:01:56.243]                             return(sendCondition)
[11:01:56.243]                           }
[11:01:56.243]                         }
[11:01:56.243]                         frame <- frame + 1L
[11:01:56.243]                         envir <- sys.frame(frame)
[11:01:56.243]                       }
[11:01:56.243]                     }
[11:01:56.243]                     sendCondition <<- function(cond) NULL
[11:01:56.243]                   }
[11:01:56.243]                 })
[11:01:56.243]                 withCallingHandlers({
[11:01:56.243]                   value(a) + 1
[11:01:56.243]                 }, immediateCondition = function(cond) {
[11:01:56.243]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.243]                   sendCondition(cond)
[11:01:56.243]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.243]                   {
[11:01:56.243]                     inherits <- base::inherits
[11:01:56.243]                     invokeRestart <- base::invokeRestart
[11:01:56.243]                     is.null <- base::is.null
[11:01:56.243]                     muffled <- FALSE
[11:01:56.243]                     if (inherits(cond, "message")) {
[11:01:56.243]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.243]                       if (muffled) 
[11:01:56.243]                         invokeRestart("muffleMessage")
[11:01:56.243]                     }
[11:01:56.243]                     else if (inherits(cond, "warning")) {
[11:01:56.243]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.243]                       if (muffled) 
[11:01:56.243]                         invokeRestart("muffleWarning")
[11:01:56.243]                     }
[11:01:56.243]                     else if (inherits(cond, "condition")) {
[11:01:56.243]                       if (!is.null(pattern)) {
[11:01:56.243]                         computeRestarts <- base::computeRestarts
[11:01:56.243]                         grepl <- base::grepl
[11:01:56.243]                         restarts <- computeRestarts(cond)
[11:01:56.243]                         for (restart in restarts) {
[11:01:56.243]                           name <- restart$name
[11:01:56.243]                           if (is.null(name)) 
[11:01:56.243]                             next
[11:01:56.243]                           if (!grepl(pattern, name)) 
[11:01:56.243]                             next
[11:01:56.243]                           invokeRestart(restart)
[11:01:56.243]                           muffled <- TRUE
[11:01:56.243]                           break
[11:01:56.243]                         }
[11:01:56.243]                       }
[11:01:56.243]                     }
[11:01:56.243]                     invisible(muffled)
[11:01:56.243]                   }
[11:01:56.243]                   muffleCondition(cond)
[11:01:56.243]                 })
[11:01:56.243]             }))
[11:01:56.243]             future::FutureResult(value = ...future.value$value, 
[11:01:56.243]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.243]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.243]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.243]                     ...future.globalenv.names))
[11:01:56.243]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.243]         }, condition = base::local({
[11:01:56.243]             c <- base::c
[11:01:56.243]             inherits <- base::inherits
[11:01:56.243]             invokeRestart <- base::invokeRestart
[11:01:56.243]             length <- base::length
[11:01:56.243]             list <- base::list
[11:01:56.243]             seq.int <- base::seq.int
[11:01:56.243]             signalCondition <- base::signalCondition
[11:01:56.243]             sys.calls <- base::sys.calls
[11:01:56.243]             `[[` <- base::`[[`
[11:01:56.243]             `+` <- base::`+`
[11:01:56.243]             `<<-` <- base::`<<-`
[11:01:56.243]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.243]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.243]                   3L)]
[11:01:56.243]             }
[11:01:56.243]             function(cond) {
[11:01:56.243]                 is_error <- inherits(cond, "error")
[11:01:56.243]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.243]                   NULL)
[11:01:56.243]                 if (is_error) {
[11:01:56.243]                   sessionInformation <- function() {
[11:01:56.243]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.243]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.243]                       search = base::search(), system = base::Sys.info())
[11:01:56.243]                   }
[11:01:56.243]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.243]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.243]                     cond$call), session = sessionInformation(), 
[11:01:56.243]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.243]                   signalCondition(cond)
[11:01:56.243]                 }
[11:01:56.243]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.243]                 "immediateCondition"))) {
[11:01:56.243]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.243]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.243]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.243]                   if (TRUE && !signal) {
[11:01:56.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.243]                     {
[11:01:56.243]                       inherits <- base::inherits
[11:01:56.243]                       invokeRestart <- base::invokeRestart
[11:01:56.243]                       is.null <- base::is.null
[11:01:56.243]                       muffled <- FALSE
[11:01:56.243]                       if (inherits(cond, "message")) {
[11:01:56.243]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.243]                         if (muffled) 
[11:01:56.243]                           invokeRestart("muffleMessage")
[11:01:56.243]                       }
[11:01:56.243]                       else if (inherits(cond, "warning")) {
[11:01:56.243]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.243]                         if (muffled) 
[11:01:56.243]                           invokeRestart("muffleWarning")
[11:01:56.243]                       }
[11:01:56.243]                       else if (inherits(cond, "condition")) {
[11:01:56.243]                         if (!is.null(pattern)) {
[11:01:56.243]                           computeRestarts <- base::computeRestarts
[11:01:56.243]                           grepl <- base::grepl
[11:01:56.243]                           restarts <- computeRestarts(cond)
[11:01:56.243]                           for (restart in restarts) {
[11:01:56.243]                             name <- restart$name
[11:01:56.243]                             if (is.null(name)) 
[11:01:56.243]                               next
[11:01:56.243]                             if (!grepl(pattern, name)) 
[11:01:56.243]                               next
[11:01:56.243]                             invokeRestart(restart)
[11:01:56.243]                             muffled <- TRUE
[11:01:56.243]                             break
[11:01:56.243]                           }
[11:01:56.243]                         }
[11:01:56.243]                       }
[11:01:56.243]                       invisible(muffled)
[11:01:56.243]                     }
[11:01:56.243]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.243]                   }
[11:01:56.243]                 }
[11:01:56.243]                 else {
[11:01:56.243]                   if (TRUE) {
[11:01:56.243]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.243]                     {
[11:01:56.243]                       inherits <- base::inherits
[11:01:56.243]                       invokeRestart <- base::invokeRestart
[11:01:56.243]                       is.null <- base::is.null
[11:01:56.243]                       muffled <- FALSE
[11:01:56.243]                       if (inherits(cond, "message")) {
[11:01:56.243]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.243]                         if (muffled) 
[11:01:56.243]                           invokeRestart("muffleMessage")
[11:01:56.243]                       }
[11:01:56.243]                       else if (inherits(cond, "warning")) {
[11:01:56.243]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.243]                         if (muffled) 
[11:01:56.243]                           invokeRestart("muffleWarning")
[11:01:56.243]                       }
[11:01:56.243]                       else if (inherits(cond, "condition")) {
[11:01:56.243]                         if (!is.null(pattern)) {
[11:01:56.243]                           computeRestarts <- base::computeRestarts
[11:01:56.243]                           grepl <- base::grepl
[11:01:56.243]                           restarts <- computeRestarts(cond)
[11:01:56.243]                           for (restart in restarts) {
[11:01:56.243]                             name <- restart$name
[11:01:56.243]                             if (is.null(name)) 
[11:01:56.243]                               next
[11:01:56.243]                             if (!grepl(pattern, name)) 
[11:01:56.243]                               next
[11:01:56.243]                             invokeRestart(restart)
[11:01:56.243]                             muffled <- TRUE
[11:01:56.243]                             break
[11:01:56.243]                           }
[11:01:56.243]                         }
[11:01:56.243]                       }
[11:01:56.243]                       invisible(muffled)
[11:01:56.243]                     }
[11:01:56.243]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.243]                   }
[11:01:56.243]                 }
[11:01:56.243]             }
[11:01:56.243]         }))
[11:01:56.243]     }, error = function(ex) {
[11:01:56.243]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.243]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.243]                 ...future.rng), started = ...future.startTime, 
[11:01:56.243]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.243]             version = "1.8"), class = "FutureResult")
[11:01:56.243]     }, finally = {
[11:01:56.243]         if (!identical(...future.workdir, getwd())) 
[11:01:56.243]             setwd(...future.workdir)
[11:01:56.243]         {
[11:01:56.243]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.243]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.243]             }
[11:01:56.243]             base::options(...future.oldOptions)
[11:01:56.243]             if (.Platform$OS.type == "windows") {
[11:01:56.243]                 old_names <- names(...future.oldEnvVars)
[11:01:56.243]                 envs <- base::Sys.getenv()
[11:01:56.243]                 names <- names(envs)
[11:01:56.243]                 common <- intersect(names, old_names)
[11:01:56.243]                 added <- setdiff(names, old_names)
[11:01:56.243]                 removed <- setdiff(old_names, names)
[11:01:56.243]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.243]                   envs[common]]
[11:01:56.243]                 NAMES <- toupper(changed)
[11:01:56.243]                 args <- list()
[11:01:56.243]                 for (kk in seq_along(NAMES)) {
[11:01:56.243]                   name <- changed[[kk]]
[11:01:56.243]                   NAME <- NAMES[[kk]]
[11:01:56.243]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.243]                     next
[11:01:56.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.243]                 }
[11:01:56.243]                 NAMES <- toupper(added)
[11:01:56.243]                 for (kk in seq_along(NAMES)) {
[11:01:56.243]                   name <- added[[kk]]
[11:01:56.243]                   NAME <- NAMES[[kk]]
[11:01:56.243]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.243]                     next
[11:01:56.243]                   args[[name]] <- ""
[11:01:56.243]                 }
[11:01:56.243]                 NAMES <- toupper(removed)
[11:01:56.243]                 for (kk in seq_along(NAMES)) {
[11:01:56.243]                   name <- removed[[kk]]
[11:01:56.243]                   NAME <- NAMES[[kk]]
[11:01:56.243]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.243]                     next
[11:01:56.243]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.243]                 }
[11:01:56.243]                 if (length(args) > 0) 
[11:01:56.243]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.243]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.243]             }
[11:01:56.243]             else {
[11:01:56.243]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.243]             }
[11:01:56.243]             {
[11:01:56.243]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.243]                   0L) {
[11:01:56.243]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.243]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.243]                   base::options(opts)
[11:01:56.243]                 }
[11:01:56.243]                 {
[11:01:56.243]                   {
[11:01:56.243]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.243]                     NULL
[11:01:56.243]                   }
[11:01:56.243]                   options(future.plan = NULL)
[11:01:56.243]                   if (is.na(NA_character_)) 
[11:01:56.243]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.243]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.243]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.243]                     .init = FALSE)
[11:01:56.243]                 }
[11:01:56.243]             }
[11:01:56.243]         }
[11:01:56.243]     })
[11:01:56.243]     if (TRUE) {
[11:01:56.243]         base::sink(type = "output", split = FALSE)
[11:01:56.243]         if (TRUE) {
[11:01:56.243]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.243]         }
[11:01:56.243]         else {
[11:01:56.243]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.243]         }
[11:01:56.243]         base::close(...future.stdout)
[11:01:56.243]         ...future.stdout <- NULL
[11:01:56.243]     }
[11:01:56.243]     ...future.result$conditions <- ...future.conditions
[11:01:56.243]     ...future.result$finished <- base::Sys.time()
[11:01:56.243]     ...future.result
[11:01:56.243] }
[11:01:56.256] Exporting 1 global objects (313.44 KiB) to cluster node #1 ...
[11:01:56.267] Exporting ‘a’ (313.23 KiB) to cluster node #1 ...
[11:01:56.319] Exporting ‘a’ (313.23 KiB) to cluster node #1 ... DONE
[11:01:56.319] Exporting 1 global objects (313.44 KiB) to cluster node #1 ... DONE
[11:01:56.319] MultisessionFuture started
[11:01:56.319] - Launch lazy future ... done
[11:01:56.320] run() for ‘MultisessionFuture’ ... done
[11:01:56.320] result() for ClusterFuture ...
[11:01:56.320] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.320] - Validating connection of MultisessionFuture
[11:01:56.361] - received message: FutureResult
[11:01:56.361] - Received FutureResult
[11:01:56.361] - Erased future from FutureRegistry
[11:01:56.361] result() for ClusterFuture ...
[11:01:56.362] - result already collected: FutureResult
[11:01:56.362] result() for ClusterFuture ... done
[11:01:56.362] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.362] result() for ClusterFuture ... done
[11:01:56.362] result() for ClusterFuture ...
[11:01:56.362] - result already collected: FutureResult
[11:01:56.362] result() for ClusterFuture ... done
value(b) = 2
[11:01:56.362] result() for ClusterFuture ...
[11:01:56.362] - result already collected: FutureResult
[11:01:56.362] result() for ClusterFuture ... done
[11:01:56.362] result() for ClusterFuture ...
[11:01:56.363] - result already collected: FutureResult
[11:01:56.363] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.363] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.363] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.363] 
[11:01:56.364] Searching for globals ... DONE
[11:01:56.364] - globals: [0] <none>
[11:01:56.364] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.364] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.364] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.365] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:56.365] Searching for globals ... DONE
[11:01:56.365] Resolving globals: TRUE
[11:01:56.365] Resolving any globals that are futures ...
[11:01:56.365] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:56.365] Resolving any globals that are futures ... DONE
[11:01:56.366] Resolving futures part of globals (recursively) ...
[11:01:56.366] resolve() on list ...
[11:01:56.366]  recursive: 99
[11:01:56.366]  length: 1
[11:01:56.366]  elements: ‘a’
[11:01:56.366] run() for ‘Future’ ...
[11:01:56.366] - state: ‘created’
[11:01:56.366] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.380] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.380] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.380]   - Field: ‘node’
[11:01:56.380]   - Field: ‘label’
[11:01:56.380]   - Field: ‘local’
[11:01:56.380]   - Field: ‘owner’
[11:01:56.380]   - Field: ‘envir’
[11:01:56.381]   - Field: ‘workers’
[11:01:56.381]   - Field: ‘packages’
[11:01:56.381]   - Field: ‘gc’
[11:01:56.381]   - Field: ‘conditions’
[11:01:56.381]   - Field: ‘persistent’
[11:01:56.381]   - Field: ‘expr’
[11:01:56.381]   - Field: ‘uuid’
[11:01:56.381]   - Field: ‘seed’
[11:01:56.381]   - Field: ‘version’
[11:01:56.381]   - Field: ‘result’
[11:01:56.381]   - Field: ‘asynchronous’
[11:01:56.381]   - Field: ‘calls’
[11:01:56.382]   - Field: ‘globals’
[11:01:56.382]   - Field: ‘stdout’
[11:01:56.382]   - Field: ‘earlySignal’
[11:01:56.382]   - Field: ‘lazy’
[11:01:56.382]   - Field: ‘state’
[11:01:56.382] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.382] - Launch lazy future ...
[11:01:56.382] Packages needed by the future expression (n = 0): <none>
[11:01:56.382] Packages needed by future strategies (n = 0): <none>
[11:01:56.383] {
[11:01:56.383]     {
[11:01:56.383]         {
[11:01:56.383]             ...future.startTime <- base::Sys.time()
[11:01:56.383]             {
[11:01:56.383]                 {
[11:01:56.383]                   {
[11:01:56.383]                     {
[11:01:56.383]                       base::local({
[11:01:56.383]                         has_future <- base::requireNamespace("future", 
[11:01:56.383]                           quietly = TRUE)
[11:01:56.383]                         if (has_future) {
[11:01:56.383]                           ns <- base::getNamespace("future")
[11:01:56.383]                           version <- ns[[".package"]][["version"]]
[11:01:56.383]                           if (is.null(version)) 
[11:01:56.383]                             version <- utils::packageVersion("future")
[11:01:56.383]                         }
[11:01:56.383]                         else {
[11:01:56.383]                           version <- NULL
[11:01:56.383]                         }
[11:01:56.383]                         if (!has_future || version < "1.8.0") {
[11:01:56.383]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.383]                             "", base::R.version$version.string), 
[11:01:56.383]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:56.383]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:56.383]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.383]                               "release", "version")], collapse = " "), 
[11:01:56.383]                             hostname = base::Sys.info()[["nodename"]])
[11:01:56.383]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.383]                             info)
[11:01:56.383]                           info <- base::paste(info, collapse = "; ")
[11:01:56.383]                           if (!has_future) {
[11:01:56.383]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.383]                               info)
[11:01:56.383]                           }
[11:01:56.383]                           else {
[11:01:56.383]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.383]                               info, version)
[11:01:56.383]                           }
[11:01:56.383]                           base::stop(msg)
[11:01:56.383]                         }
[11:01:56.383]                       })
[11:01:56.383]                     }
[11:01:56.383]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.383]                     base::options(mc.cores = 1L)
[11:01:56.383]                   }
[11:01:56.383]                   ...future.strategy.old <- future::plan("list")
[11:01:56.383]                   options(future.plan = NULL)
[11:01:56.383]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.383]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.383]                 }
[11:01:56.383]                 ...future.workdir <- getwd()
[11:01:56.383]             }
[11:01:56.383]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.383]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.383]         }
[11:01:56.383]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.383]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.383]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.383]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.383]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.383]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.383]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.383]             base::names(...future.oldOptions))
[11:01:56.383]     }
[11:01:56.383]     if (FALSE) {
[11:01:56.383]     }
[11:01:56.383]     else {
[11:01:56.383]         if (TRUE) {
[11:01:56.383]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.383]                 open = "w")
[11:01:56.383]         }
[11:01:56.383]         else {
[11:01:56.383]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.383]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.383]         }
[11:01:56.383]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.383]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.383]             base::sink(type = "output", split = FALSE)
[11:01:56.383]             base::close(...future.stdout)
[11:01:56.383]         }, add = TRUE)
[11:01:56.383]     }
[11:01:56.383]     ...future.frame <- base::sys.nframe()
[11:01:56.383]     ...future.conditions <- base::list()
[11:01:56.383]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.383]     if (FALSE) {
[11:01:56.383]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.383]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.383]     }
[11:01:56.383]     ...future.result <- base::tryCatch({
[11:01:56.383]         base::withCallingHandlers({
[11:01:56.383]             ...future.value <- base::withVisible(base::local({
[11:01:56.383]                 ...future.makeSendCondition <- base::local({
[11:01:56.383]                   sendCondition <- NULL
[11:01:56.383]                   function(frame = 1L) {
[11:01:56.383]                     if (is.function(sendCondition)) 
[11:01:56.383]                       return(sendCondition)
[11:01:56.383]                     ns <- getNamespace("parallel")
[11:01:56.383]                     if (exists("sendData", mode = "function", 
[11:01:56.383]                       envir = ns)) {
[11:01:56.383]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.383]                         envir = ns)
[11:01:56.383]                       envir <- sys.frame(frame)
[11:01:56.383]                       master <- NULL
[11:01:56.383]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.383]                         !identical(envir, emptyenv())) {
[11:01:56.383]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.383]                           inherits = FALSE)) {
[11:01:56.383]                           master <- get("master", mode = "list", 
[11:01:56.383]                             envir = envir, inherits = FALSE)
[11:01:56.383]                           if (inherits(master, c("SOCKnode", 
[11:01:56.383]                             "SOCK0node"))) {
[11:01:56.383]                             sendCondition <<- function(cond) {
[11:01:56.383]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.383]                                 success = TRUE)
[11:01:56.383]                               parallel_sendData(master, data)
[11:01:56.383]                             }
[11:01:56.383]                             return(sendCondition)
[11:01:56.383]                           }
[11:01:56.383]                         }
[11:01:56.383]                         frame <- frame + 1L
[11:01:56.383]                         envir <- sys.frame(frame)
[11:01:56.383]                       }
[11:01:56.383]                     }
[11:01:56.383]                     sendCondition <<- function(cond) NULL
[11:01:56.383]                   }
[11:01:56.383]                 })
[11:01:56.383]                 withCallingHandlers({
[11:01:56.383]                   1
[11:01:56.383]                 }, immediateCondition = function(cond) {
[11:01:56.383]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.383]                   sendCondition(cond)
[11:01:56.383]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.383]                   {
[11:01:56.383]                     inherits <- base::inherits
[11:01:56.383]                     invokeRestart <- base::invokeRestart
[11:01:56.383]                     is.null <- base::is.null
[11:01:56.383]                     muffled <- FALSE
[11:01:56.383]                     if (inherits(cond, "message")) {
[11:01:56.383]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.383]                       if (muffled) 
[11:01:56.383]                         invokeRestart("muffleMessage")
[11:01:56.383]                     }
[11:01:56.383]                     else if (inherits(cond, "warning")) {
[11:01:56.383]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.383]                       if (muffled) 
[11:01:56.383]                         invokeRestart("muffleWarning")
[11:01:56.383]                     }
[11:01:56.383]                     else if (inherits(cond, "condition")) {
[11:01:56.383]                       if (!is.null(pattern)) {
[11:01:56.383]                         computeRestarts <- base::computeRestarts
[11:01:56.383]                         grepl <- base::grepl
[11:01:56.383]                         restarts <- computeRestarts(cond)
[11:01:56.383]                         for (restart in restarts) {
[11:01:56.383]                           name <- restart$name
[11:01:56.383]                           if (is.null(name)) 
[11:01:56.383]                             next
[11:01:56.383]                           if (!grepl(pattern, name)) 
[11:01:56.383]                             next
[11:01:56.383]                           invokeRestart(restart)
[11:01:56.383]                           muffled <- TRUE
[11:01:56.383]                           break
[11:01:56.383]                         }
[11:01:56.383]                       }
[11:01:56.383]                     }
[11:01:56.383]                     invisible(muffled)
[11:01:56.383]                   }
[11:01:56.383]                   muffleCondition(cond)
[11:01:56.383]                 })
[11:01:56.383]             }))
[11:01:56.383]             future::FutureResult(value = ...future.value$value, 
[11:01:56.383]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.383]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.383]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.383]                     ...future.globalenv.names))
[11:01:56.383]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.383]         }, condition = base::local({
[11:01:56.383]             c <- base::c
[11:01:56.383]             inherits <- base::inherits
[11:01:56.383]             invokeRestart <- base::invokeRestart
[11:01:56.383]             length <- base::length
[11:01:56.383]             list <- base::list
[11:01:56.383]             seq.int <- base::seq.int
[11:01:56.383]             signalCondition <- base::signalCondition
[11:01:56.383]             sys.calls <- base::sys.calls
[11:01:56.383]             `[[` <- base::`[[`
[11:01:56.383]             `+` <- base::`+`
[11:01:56.383]             `<<-` <- base::`<<-`
[11:01:56.383]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.383]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.383]                   3L)]
[11:01:56.383]             }
[11:01:56.383]             function(cond) {
[11:01:56.383]                 is_error <- inherits(cond, "error")
[11:01:56.383]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.383]                   NULL)
[11:01:56.383]                 if (is_error) {
[11:01:56.383]                   sessionInformation <- function() {
[11:01:56.383]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.383]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.383]                       search = base::search(), system = base::Sys.info())
[11:01:56.383]                   }
[11:01:56.383]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.383]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.383]                     cond$call), session = sessionInformation(), 
[11:01:56.383]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.383]                   signalCondition(cond)
[11:01:56.383]                 }
[11:01:56.383]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.383]                 "immediateCondition"))) {
[11:01:56.383]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.383]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.383]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.383]                   if (TRUE && !signal) {
[11:01:56.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.383]                     {
[11:01:56.383]                       inherits <- base::inherits
[11:01:56.383]                       invokeRestart <- base::invokeRestart
[11:01:56.383]                       is.null <- base::is.null
[11:01:56.383]                       muffled <- FALSE
[11:01:56.383]                       if (inherits(cond, "message")) {
[11:01:56.383]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.383]                         if (muffled) 
[11:01:56.383]                           invokeRestart("muffleMessage")
[11:01:56.383]                       }
[11:01:56.383]                       else if (inherits(cond, "warning")) {
[11:01:56.383]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.383]                         if (muffled) 
[11:01:56.383]                           invokeRestart("muffleWarning")
[11:01:56.383]                       }
[11:01:56.383]                       else if (inherits(cond, "condition")) {
[11:01:56.383]                         if (!is.null(pattern)) {
[11:01:56.383]                           computeRestarts <- base::computeRestarts
[11:01:56.383]                           grepl <- base::grepl
[11:01:56.383]                           restarts <- computeRestarts(cond)
[11:01:56.383]                           for (restart in restarts) {
[11:01:56.383]                             name <- restart$name
[11:01:56.383]                             if (is.null(name)) 
[11:01:56.383]                               next
[11:01:56.383]                             if (!grepl(pattern, name)) 
[11:01:56.383]                               next
[11:01:56.383]                             invokeRestart(restart)
[11:01:56.383]                             muffled <- TRUE
[11:01:56.383]                             break
[11:01:56.383]                           }
[11:01:56.383]                         }
[11:01:56.383]                       }
[11:01:56.383]                       invisible(muffled)
[11:01:56.383]                     }
[11:01:56.383]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.383]                   }
[11:01:56.383]                 }
[11:01:56.383]                 else {
[11:01:56.383]                   if (TRUE) {
[11:01:56.383]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.383]                     {
[11:01:56.383]                       inherits <- base::inherits
[11:01:56.383]                       invokeRestart <- base::invokeRestart
[11:01:56.383]                       is.null <- base::is.null
[11:01:56.383]                       muffled <- FALSE
[11:01:56.383]                       if (inherits(cond, "message")) {
[11:01:56.383]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.383]                         if (muffled) 
[11:01:56.383]                           invokeRestart("muffleMessage")
[11:01:56.383]                       }
[11:01:56.383]                       else if (inherits(cond, "warning")) {
[11:01:56.383]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.383]                         if (muffled) 
[11:01:56.383]                           invokeRestart("muffleWarning")
[11:01:56.383]                       }
[11:01:56.383]                       else if (inherits(cond, "condition")) {
[11:01:56.383]                         if (!is.null(pattern)) {
[11:01:56.383]                           computeRestarts <- base::computeRestarts
[11:01:56.383]                           grepl <- base::grepl
[11:01:56.383]                           restarts <- computeRestarts(cond)
[11:01:56.383]                           for (restart in restarts) {
[11:01:56.383]                             name <- restart$name
[11:01:56.383]                             if (is.null(name)) 
[11:01:56.383]                               next
[11:01:56.383]                             if (!grepl(pattern, name)) 
[11:01:56.383]                               next
[11:01:56.383]                             invokeRestart(restart)
[11:01:56.383]                             muffled <- TRUE
[11:01:56.383]                             break
[11:01:56.383]                           }
[11:01:56.383]                         }
[11:01:56.383]                       }
[11:01:56.383]                       invisible(muffled)
[11:01:56.383]                     }
[11:01:56.383]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.383]                   }
[11:01:56.383]                 }
[11:01:56.383]             }
[11:01:56.383]         }))
[11:01:56.383]     }, error = function(ex) {
[11:01:56.383]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.383]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.383]                 ...future.rng), started = ...future.startTime, 
[11:01:56.383]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.383]             version = "1.8"), class = "FutureResult")
[11:01:56.383]     }, finally = {
[11:01:56.383]         if (!identical(...future.workdir, getwd())) 
[11:01:56.383]             setwd(...future.workdir)
[11:01:56.383]         {
[11:01:56.383]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.383]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.383]             }
[11:01:56.383]             base::options(...future.oldOptions)
[11:01:56.383]             if (.Platform$OS.type == "windows") {
[11:01:56.383]                 old_names <- names(...future.oldEnvVars)
[11:01:56.383]                 envs <- base::Sys.getenv()
[11:01:56.383]                 names <- names(envs)
[11:01:56.383]                 common <- intersect(names, old_names)
[11:01:56.383]                 added <- setdiff(names, old_names)
[11:01:56.383]                 removed <- setdiff(old_names, names)
[11:01:56.383]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.383]                   envs[common]]
[11:01:56.383]                 NAMES <- toupper(changed)
[11:01:56.383]                 args <- list()
[11:01:56.383]                 for (kk in seq_along(NAMES)) {
[11:01:56.383]                   name <- changed[[kk]]
[11:01:56.383]                   NAME <- NAMES[[kk]]
[11:01:56.383]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.383]                     next
[11:01:56.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.383]                 }
[11:01:56.383]                 NAMES <- toupper(added)
[11:01:56.383]                 for (kk in seq_along(NAMES)) {
[11:01:56.383]                   name <- added[[kk]]
[11:01:56.383]                   NAME <- NAMES[[kk]]
[11:01:56.383]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.383]                     next
[11:01:56.383]                   args[[name]] <- ""
[11:01:56.383]                 }
[11:01:56.383]                 NAMES <- toupper(removed)
[11:01:56.383]                 for (kk in seq_along(NAMES)) {
[11:01:56.383]                   name <- removed[[kk]]
[11:01:56.383]                   NAME <- NAMES[[kk]]
[11:01:56.383]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.383]                     next
[11:01:56.383]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.383]                 }
[11:01:56.383]                 if (length(args) > 0) 
[11:01:56.383]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.383]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.383]             }
[11:01:56.383]             else {
[11:01:56.383]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.383]             }
[11:01:56.383]             {
[11:01:56.383]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.383]                   0L) {
[11:01:56.383]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.383]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.383]                   base::options(opts)
[11:01:56.383]                 }
[11:01:56.383]                 {
[11:01:56.383]                   {
[11:01:56.383]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.383]                     NULL
[11:01:56.383]                   }
[11:01:56.383]                   options(future.plan = NULL)
[11:01:56.383]                   if (is.na(NA_character_)) 
[11:01:56.383]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.383]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.383]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.383]                     .init = FALSE)
[11:01:56.383]                 }
[11:01:56.383]             }
[11:01:56.383]         }
[11:01:56.383]     })
[11:01:56.383]     if (TRUE) {
[11:01:56.383]         base::sink(type = "output", split = FALSE)
[11:01:56.383]         if (TRUE) {
[11:01:56.383]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.383]         }
[11:01:56.383]         else {
[11:01:56.383]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.383]         }
[11:01:56.383]         base::close(...future.stdout)
[11:01:56.383]         ...future.stdout <- NULL
[11:01:56.383]     }
[11:01:56.383]     ...future.result$conditions <- ...future.conditions
[11:01:56.383]     ...future.result$finished <- base::Sys.time()
[11:01:56.383]     ...future.result
[11:01:56.383] }
[11:01:56.386] MultisessionFuture started
[11:01:56.386] - Launch lazy future ... done
[11:01:56.386] run() for ‘MultisessionFuture’ ... done
[11:01:56.428] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.428] - Validating connection of MultisessionFuture
[11:01:56.428] - received message: FutureResult
[11:01:56.428] - Received FutureResult
[11:01:56.428] - Erased future from FutureRegistry
[11:01:56.428] result() for ClusterFuture ...
[11:01:56.428] - result already collected: FutureResult
[11:01:56.429] result() for ClusterFuture ... done
[11:01:56.429] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.429] Future #1
[11:01:56.429] result() for ClusterFuture ...
[11:01:56.429] - result already collected: FutureResult
[11:01:56.429] result() for ClusterFuture ... done
[11:01:56.429] result() for ClusterFuture ...
[11:01:56.429] - result already collected: FutureResult
[11:01:56.429] result() for ClusterFuture ... done
[11:01:56.429] A MultisessionFuture was resolved
[11:01:56.429]  length: 0 (resolved future 1)
[11:01:56.430] resolve() on list ... DONE
[11:01:56.430] - globals: [1] ‘a’
[11:01:56.430] Resolving futures part of globals (recursively) ... DONE
[11:01:56.441] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[11:01:56.441] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[11:01:56.441] - globals: [1] ‘a’
[11:01:56.441] - packages: [1] ‘future’
[11:01:56.441] getGlobalsAndPackages() ... DONE
[11:01:56.442] run() for ‘Future’ ...
[11:01:56.442] - state: ‘created’
[11:01:56.442] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.456] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.456] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.456]   - Field: ‘node’
[11:01:56.456]   - Field: ‘label’
[11:01:56.456]   - Field: ‘local’
[11:01:56.456]   - Field: ‘owner’
[11:01:56.457]   - Field: ‘envir’
[11:01:56.457]   - Field: ‘workers’
[11:01:56.457]   - Field: ‘packages’
[11:01:56.457]   - Field: ‘gc’
[11:01:56.457]   - Field: ‘conditions’
[11:01:56.457]   - Field: ‘persistent’
[11:01:56.457]   - Field: ‘expr’
[11:01:56.457]   - Field: ‘uuid’
[11:01:56.457]   - Field: ‘seed’
[11:01:56.457]   - Field: ‘version’
[11:01:56.457]   - Field: ‘result’
[11:01:56.457]   - Field: ‘asynchronous’
[11:01:56.458]   - Field: ‘calls’
[11:01:56.458]   - Field: ‘globals’
[11:01:56.458]   - Field: ‘stdout’
[11:01:56.458]   - Field: ‘earlySignal’
[11:01:56.458]   - Field: ‘lazy’
[11:01:56.458]   - Field: ‘state’
[11:01:56.460] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.460] - Launch lazy future ...
[11:01:56.461] Packages needed by the future expression (n = 1): ‘future’
[11:01:56.461] Packages needed by future strategies (n = 0): <none>
[11:01:56.461] {
[11:01:56.461]     {
[11:01:56.461]         {
[11:01:56.461]             ...future.startTime <- base::Sys.time()
[11:01:56.461]             {
[11:01:56.461]                 {
[11:01:56.461]                   {
[11:01:56.461]                     {
[11:01:56.461]                       {
[11:01:56.461]                         base::local({
[11:01:56.461]                           has_future <- base::requireNamespace("future", 
[11:01:56.461]                             quietly = TRUE)
[11:01:56.461]                           if (has_future) {
[11:01:56.461]                             ns <- base::getNamespace("future")
[11:01:56.461]                             version <- ns[[".package"]][["version"]]
[11:01:56.461]                             if (is.null(version)) 
[11:01:56.461]                               version <- utils::packageVersion("future")
[11:01:56.461]                           }
[11:01:56.461]                           else {
[11:01:56.461]                             version <- NULL
[11:01:56.461]                           }
[11:01:56.461]                           if (!has_future || version < "1.8.0") {
[11:01:56.461]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.461]                               "", base::R.version$version.string), 
[11:01:56.461]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:56.461]                                 base::R.version$platform, 8 * 
[11:01:56.461]                                   base::.Machine$sizeof.pointer), 
[11:01:56.461]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.461]                                 "release", "version")], collapse = " "), 
[11:01:56.461]                               hostname = base::Sys.info()[["nodename"]])
[11:01:56.461]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.461]                               info)
[11:01:56.461]                             info <- base::paste(info, collapse = "; ")
[11:01:56.461]                             if (!has_future) {
[11:01:56.461]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.461]                                 info)
[11:01:56.461]                             }
[11:01:56.461]                             else {
[11:01:56.461]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.461]                                 info, version)
[11:01:56.461]                             }
[11:01:56.461]                             base::stop(msg)
[11:01:56.461]                           }
[11:01:56.461]                         })
[11:01:56.461]                       }
[11:01:56.461]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.461]                       base::options(mc.cores = 1L)
[11:01:56.461]                     }
[11:01:56.461]                     base::local({
[11:01:56.461]                       for (pkg in "future") {
[11:01:56.461]                         base::loadNamespace(pkg)
[11:01:56.461]                         base::library(pkg, character.only = TRUE)
[11:01:56.461]                       }
[11:01:56.461]                     })
[11:01:56.461]                   }
[11:01:56.461]                   ...future.strategy.old <- future::plan("list")
[11:01:56.461]                   options(future.plan = NULL)
[11:01:56.461]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.461]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.461]                 }
[11:01:56.461]                 ...future.workdir <- getwd()
[11:01:56.461]             }
[11:01:56.461]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.461]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.461]         }
[11:01:56.461]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.461]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.461]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.461]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.461]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.461]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.461]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.461]             base::names(...future.oldOptions))
[11:01:56.461]     }
[11:01:56.461]     if (FALSE) {
[11:01:56.461]     }
[11:01:56.461]     else {
[11:01:56.461]         if (TRUE) {
[11:01:56.461]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.461]                 open = "w")
[11:01:56.461]         }
[11:01:56.461]         else {
[11:01:56.461]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.461]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.461]         }
[11:01:56.461]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.461]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.461]             base::sink(type = "output", split = FALSE)
[11:01:56.461]             base::close(...future.stdout)
[11:01:56.461]         }, add = TRUE)
[11:01:56.461]     }
[11:01:56.461]     ...future.frame <- base::sys.nframe()
[11:01:56.461]     ...future.conditions <- base::list()
[11:01:56.461]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.461]     if (FALSE) {
[11:01:56.461]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.461]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.461]     }
[11:01:56.461]     ...future.result <- base::tryCatch({
[11:01:56.461]         base::withCallingHandlers({
[11:01:56.461]             ...future.value <- base::withVisible(base::local({
[11:01:56.461]                 ...future.makeSendCondition <- base::local({
[11:01:56.461]                   sendCondition <- NULL
[11:01:56.461]                   function(frame = 1L) {
[11:01:56.461]                     if (is.function(sendCondition)) 
[11:01:56.461]                       return(sendCondition)
[11:01:56.461]                     ns <- getNamespace("parallel")
[11:01:56.461]                     if (exists("sendData", mode = "function", 
[11:01:56.461]                       envir = ns)) {
[11:01:56.461]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.461]                         envir = ns)
[11:01:56.461]                       envir <- sys.frame(frame)
[11:01:56.461]                       master <- NULL
[11:01:56.461]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.461]                         !identical(envir, emptyenv())) {
[11:01:56.461]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.461]                           inherits = FALSE)) {
[11:01:56.461]                           master <- get("master", mode = "list", 
[11:01:56.461]                             envir = envir, inherits = FALSE)
[11:01:56.461]                           if (inherits(master, c("SOCKnode", 
[11:01:56.461]                             "SOCK0node"))) {
[11:01:56.461]                             sendCondition <<- function(cond) {
[11:01:56.461]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.461]                                 success = TRUE)
[11:01:56.461]                               parallel_sendData(master, data)
[11:01:56.461]                             }
[11:01:56.461]                             return(sendCondition)
[11:01:56.461]                           }
[11:01:56.461]                         }
[11:01:56.461]                         frame <- frame + 1L
[11:01:56.461]                         envir <- sys.frame(frame)
[11:01:56.461]                       }
[11:01:56.461]                     }
[11:01:56.461]                     sendCondition <<- function(cond) NULL
[11:01:56.461]                   }
[11:01:56.461]                 })
[11:01:56.461]                 withCallingHandlers({
[11:01:56.461]                   value(a) + 1
[11:01:56.461]                 }, immediateCondition = function(cond) {
[11:01:56.461]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.461]                   sendCondition(cond)
[11:01:56.461]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.461]                   {
[11:01:56.461]                     inherits <- base::inherits
[11:01:56.461]                     invokeRestart <- base::invokeRestart
[11:01:56.461]                     is.null <- base::is.null
[11:01:56.461]                     muffled <- FALSE
[11:01:56.461]                     if (inherits(cond, "message")) {
[11:01:56.461]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.461]                       if (muffled) 
[11:01:56.461]                         invokeRestart("muffleMessage")
[11:01:56.461]                     }
[11:01:56.461]                     else if (inherits(cond, "warning")) {
[11:01:56.461]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.461]                       if (muffled) 
[11:01:56.461]                         invokeRestart("muffleWarning")
[11:01:56.461]                     }
[11:01:56.461]                     else if (inherits(cond, "condition")) {
[11:01:56.461]                       if (!is.null(pattern)) {
[11:01:56.461]                         computeRestarts <- base::computeRestarts
[11:01:56.461]                         grepl <- base::grepl
[11:01:56.461]                         restarts <- computeRestarts(cond)
[11:01:56.461]                         for (restart in restarts) {
[11:01:56.461]                           name <- restart$name
[11:01:56.461]                           if (is.null(name)) 
[11:01:56.461]                             next
[11:01:56.461]                           if (!grepl(pattern, name)) 
[11:01:56.461]                             next
[11:01:56.461]                           invokeRestart(restart)
[11:01:56.461]                           muffled <- TRUE
[11:01:56.461]                           break
[11:01:56.461]                         }
[11:01:56.461]                       }
[11:01:56.461]                     }
[11:01:56.461]                     invisible(muffled)
[11:01:56.461]                   }
[11:01:56.461]                   muffleCondition(cond)
[11:01:56.461]                 })
[11:01:56.461]             }))
[11:01:56.461]             future::FutureResult(value = ...future.value$value, 
[11:01:56.461]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.461]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.461]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.461]                     ...future.globalenv.names))
[11:01:56.461]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.461]         }, condition = base::local({
[11:01:56.461]             c <- base::c
[11:01:56.461]             inherits <- base::inherits
[11:01:56.461]             invokeRestart <- base::invokeRestart
[11:01:56.461]             length <- base::length
[11:01:56.461]             list <- base::list
[11:01:56.461]             seq.int <- base::seq.int
[11:01:56.461]             signalCondition <- base::signalCondition
[11:01:56.461]             sys.calls <- base::sys.calls
[11:01:56.461]             `[[` <- base::`[[`
[11:01:56.461]             `+` <- base::`+`
[11:01:56.461]             `<<-` <- base::`<<-`
[11:01:56.461]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.461]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.461]                   3L)]
[11:01:56.461]             }
[11:01:56.461]             function(cond) {
[11:01:56.461]                 is_error <- inherits(cond, "error")
[11:01:56.461]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.461]                   NULL)
[11:01:56.461]                 if (is_error) {
[11:01:56.461]                   sessionInformation <- function() {
[11:01:56.461]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.461]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.461]                       search = base::search(), system = base::Sys.info())
[11:01:56.461]                   }
[11:01:56.461]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.461]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.461]                     cond$call), session = sessionInformation(), 
[11:01:56.461]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.461]                   signalCondition(cond)
[11:01:56.461]                 }
[11:01:56.461]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.461]                 "immediateCondition"))) {
[11:01:56.461]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.461]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.461]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.461]                   if (TRUE && !signal) {
[11:01:56.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.461]                     {
[11:01:56.461]                       inherits <- base::inherits
[11:01:56.461]                       invokeRestart <- base::invokeRestart
[11:01:56.461]                       is.null <- base::is.null
[11:01:56.461]                       muffled <- FALSE
[11:01:56.461]                       if (inherits(cond, "message")) {
[11:01:56.461]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.461]                         if (muffled) 
[11:01:56.461]                           invokeRestart("muffleMessage")
[11:01:56.461]                       }
[11:01:56.461]                       else if (inherits(cond, "warning")) {
[11:01:56.461]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.461]                         if (muffled) 
[11:01:56.461]                           invokeRestart("muffleWarning")
[11:01:56.461]                       }
[11:01:56.461]                       else if (inherits(cond, "condition")) {
[11:01:56.461]                         if (!is.null(pattern)) {
[11:01:56.461]                           computeRestarts <- base::computeRestarts
[11:01:56.461]                           grepl <- base::grepl
[11:01:56.461]                           restarts <- computeRestarts(cond)
[11:01:56.461]                           for (restart in restarts) {
[11:01:56.461]                             name <- restart$name
[11:01:56.461]                             if (is.null(name)) 
[11:01:56.461]                               next
[11:01:56.461]                             if (!grepl(pattern, name)) 
[11:01:56.461]                               next
[11:01:56.461]                             invokeRestart(restart)
[11:01:56.461]                             muffled <- TRUE
[11:01:56.461]                             break
[11:01:56.461]                           }
[11:01:56.461]                         }
[11:01:56.461]                       }
[11:01:56.461]                       invisible(muffled)
[11:01:56.461]                     }
[11:01:56.461]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.461]                   }
[11:01:56.461]                 }
[11:01:56.461]                 else {
[11:01:56.461]                   if (TRUE) {
[11:01:56.461]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.461]                     {
[11:01:56.461]                       inherits <- base::inherits
[11:01:56.461]                       invokeRestart <- base::invokeRestart
[11:01:56.461]                       is.null <- base::is.null
[11:01:56.461]                       muffled <- FALSE
[11:01:56.461]                       if (inherits(cond, "message")) {
[11:01:56.461]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.461]                         if (muffled) 
[11:01:56.461]                           invokeRestart("muffleMessage")
[11:01:56.461]                       }
[11:01:56.461]                       else if (inherits(cond, "warning")) {
[11:01:56.461]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.461]                         if (muffled) 
[11:01:56.461]                           invokeRestart("muffleWarning")
[11:01:56.461]                       }
[11:01:56.461]                       else if (inherits(cond, "condition")) {
[11:01:56.461]                         if (!is.null(pattern)) {
[11:01:56.461]                           computeRestarts <- base::computeRestarts
[11:01:56.461]                           grepl <- base::grepl
[11:01:56.461]                           restarts <- computeRestarts(cond)
[11:01:56.461]                           for (restart in restarts) {
[11:01:56.461]                             name <- restart$name
[11:01:56.461]                             if (is.null(name)) 
[11:01:56.461]                               next
[11:01:56.461]                             if (!grepl(pattern, name)) 
[11:01:56.461]                               next
[11:01:56.461]                             invokeRestart(restart)
[11:01:56.461]                             muffled <- TRUE
[11:01:56.461]                             break
[11:01:56.461]                           }
[11:01:56.461]                         }
[11:01:56.461]                       }
[11:01:56.461]                       invisible(muffled)
[11:01:56.461]                     }
[11:01:56.461]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.461]                   }
[11:01:56.461]                 }
[11:01:56.461]             }
[11:01:56.461]         }))
[11:01:56.461]     }, error = function(ex) {
[11:01:56.461]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.461]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.461]                 ...future.rng), started = ...future.startTime, 
[11:01:56.461]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.461]             version = "1.8"), class = "FutureResult")
[11:01:56.461]     }, finally = {
[11:01:56.461]         if (!identical(...future.workdir, getwd())) 
[11:01:56.461]             setwd(...future.workdir)
[11:01:56.461]         {
[11:01:56.461]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.461]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.461]             }
[11:01:56.461]             base::options(...future.oldOptions)
[11:01:56.461]             if (.Platform$OS.type == "windows") {
[11:01:56.461]                 old_names <- names(...future.oldEnvVars)
[11:01:56.461]                 envs <- base::Sys.getenv()
[11:01:56.461]                 names <- names(envs)
[11:01:56.461]                 common <- intersect(names, old_names)
[11:01:56.461]                 added <- setdiff(names, old_names)
[11:01:56.461]                 removed <- setdiff(old_names, names)
[11:01:56.461]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.461]                   envs[common]]
[11:01:56.461]                 NAMES <- toupper(changed)
[11:01:56.461]                 args <- list()
[11:01:56.461]                 for (kk in seq_along(NAMES)) {
[11:01:56.461]                   name <- changed[[kk]]
[11:01:56.461]                   NAME <- NAMES[[kk]]
[11:01:56.461]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.461]                     next
[11:01:56.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.461]                 }
[11:01:56.461]                 NAMES <- toupper(added)
[11:01:56.461]                 for (kk in seq_along(NAMES)) {
[11:01:56.461]                   name <- added[[kk]]
[11:01:56.461]                   NAME <- NAMES[[kk]]
[11:01:56.461]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.461]                     next
[11:01:56.461]                   args[[name]] <- ""
[11:01:56.461]                 }
[11:01:56.461]                 NAMES <- toupper(removed)
[11:01:56.461]                 for (kk in seq_along(NAMES)) {
[11:01:56.461]                   name <- removed[[kk]]
[11:01:56.461]                   NAME <- NAMES[[kk]]
[11:01:56.461]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.461]                     next
[11:01:56.461]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.461]                 }
[11:01:56.461]                 if (length(args) > 0) 
[11:01:56.461]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.461]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.461]             }
[11:01:56.461]             else {
[11:01:56.461]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.461]             }
[11:01:56.461]             {
[11:01:56.461]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.461]                   0L) {
[11:01:56.461]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.461]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.461]                   base::options(opts)
[11:01:56.461]                 }
[11:01:56.461]                 {
[11:01:56.461]                   {
[11:01:56.461]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.461]                     NULL
[11:01:56.461]                   }
[11:01:56.461]                   options(future.plan = NULL)
[11:01:56.461]                   if (is.na(NA_character_)) 
[11:01:56.461]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.461]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.461]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.461]                     .init = FALSE)
[11:01:56.461]                 }
[11:01:56.461]             }
[11:01:56.461]         }
[11:01:56.461]     })
[11:01:56.461]     if (TRUE) {
[11:01:56.461]         base::sink(type = "output", split = FALSE)
[11:01:56.461]         if (TRUE) {
[11:01:56.461]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.461]         }
[11:01:56.461]         else {
[11:01:56.461]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.461]         }
[11:01:56.461]         base::close(...future.stdout)
[11:01:56.461]         ...future.stdout <- NULL
[11:01:56.461]     }
[11:01:56.461]     ...future.result$conditions <- ...future.conditions
[11:01:56.461]     ...future.result$finished <- base::Sys.time()
[11:01:56.461]     ...future.result
[11:01:56.461] }
[11:01:56.474] Exporting 1 global objects (313.46 KiB) to cluster node #1 ...
[11:01:56.485] Exporting ‘a’ (313.25 KiB) to cluster node #1 ...
[11:01:56.538] Exporting ‘a’ (313.25 KiB) to cluster node #1 ... DONE
[11:01:56.538] Exporting 1 global objects (313.46 KiB) to cluster node #1 ... DONE
[11:01:56.539] MultisessionFuture started
[11:01:56.539] - Launch lazy future ... done
[11:01:56.539] run() for ‘MultisessionFuture’ ... done
[11:01:56.539] result() for ClusterFuture ...
[11:01:56.539] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.539] - Validating connection of MultisessionFuture
[11:01:56.581] - received message: FutureResult
[11:01:56.581] - Received FutureResult
[11:01:56.581] - Erased future from FutureRegistry
[11:01:56.581] result() for ClusterFuture ...
[11:01:56.581] - result already collected: FutureResult
[11:01:56.582] result() for ClusterFuture ... done
[11:01:56.582] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.582] result() for ClusterFuture ... done
[11:01:56.582] result() for ClusterFuture ...
[11:01:56.582] - result already collected: FutureResult
[11:01:56.582] result() for ClusterFuture ... done
value(b) = 2
[11:01:56.582] result() for ClusterFuture ...
[11:01:56.582] - result already collected: FutureResult
[11:01:56.582] result() for ClusterFuture ... done
[11:01:56.582] result() for ClusterFuture ...
[11:01:56.582] - result already collected: FutureResult
[11:01:56.583] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.583] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.583] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.583] 
[11:01:56.583] Searching for globals ... DONE
[11:01:56.584] - globals: [0] <none>
[11:01:56.584] getGlobalsAndPackages() ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.584] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.584] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.585] - globals found: [3] ‘+’, ‘value’, ‘a’
[11:01:56.585] Searching for globals ... DONE
[11:01:56.585] Resolving globals: TRUE
[11:01:56.585] Resolving any globals that are futures ...
[11:01:56.585] - globals: [3] ‘+’, ‘value’, ‘a’
[11:01:56.585] Resolving any globals that are futures ... DONE
[11:01:56.585] Resolving futures part of globals (recursively) ...
[11:01:56.586] resolve() on list ...
[11:01:56.586]  recursive: 99
[11:01:56.586]  length: 1
[11:01:56.586]  elements: ‘a’
[11:01:56.586] run() for ‘Future’ ...
[11:01:56.586] - state: ‘created’
[11:01:56.586] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.600] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.600] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.600]   - Field: ‘node’
[11:01:56.600]   - Field: ‘label’
[11:01:56.600]   - Field: ‘local’
[11:01:56.600]   - Field: ‘owner’
[11:01:56.601]   - Field: ‘envir’
[11:01:56.601]   - Field: ‘workers’
[11:01:56.601]   - Field: ‘packages’
[11:01:56.601]   - Field: ‘gc’
[11:01:56.601]   - Field: ‘conditions’
[11:01:56.601]   - Field: ‘persistent’
[11:01:56.601]   - Field: ‘expr’
[11:01:56.601]   - Field: ‘uuid’
[11:01:56.601]   - Field: ‘seed’
[11:01:56.601]   - Field: ‘version’
[11:01:56.601]   - Field: ‘result’
[11:01:56.601]   - Field: ‘asynchronous’
[11:01:56.601]   - Field: ‘calls’
[11:01:56.602]   - Field: ‘globals’
[11:01:56.602]   - Field: ‘stdout’
[11:01:56.602]   - Field: ‘earlySignal’
[11:01:56.602]   - Field: ‘lazy’
[11:01:56.602]   - Field: ‘state’
[11:01:56.602] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.602] - Launch lazy future ...
[11:01:56.602] Packages needed by the future expression (n = 0): <none>
[11:01:56.602] Packages needed by future strategies (n = 0): <none>
[11:01:56.603] {
[11:01:56.603]     {
[11:01:56.603]         {
[11:01:56.603]             ...future.startTime <- base::Sys.time()
[11:01:56.603]             {
[11:01:56.603]                 {
[11:01:56.603]                   {
[11:01:56.603]                     {
[11:01:56.603]                       base::local({
[11:01:56.603]                         has_future <- base::requireNamespace("future", 
[11:01:56.603]                           quietly = TRUE)
[11:01:56.603]                         if (has_future) {
[11:01:56.603]                           ns <- base::getNamespace("future")
[11:01:56.603]                           version <- ns[[".package"]][["version"]]
[11:01:56.603]                           if (is.null(version)) 
[11:01:56.603]                             version <- utils::packageVersion("future")
[11:01:56.603]                         }
[11:01:56.603]                         else {
[11:01:56.603]                           version <- NULL
[11:01:56.603]                         }
[11:01:56.603]                         if (!has_future || version < "1.8.0") {
[11:01:56.603]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.603]                             "", base::R.version$version.string), 
[11:01:56.603]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:56.603]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:56.603]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.603]                               "release", "version")], collapse = " "), 
[11:01:56.603]                             hostname = base::Sys.info()[["nodename"]])
[11:01:56.603]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.603]                             info)
[11:01:56.603]                           info <- base::paste(info, collapse = "; ")
[11:01:56.603]                           if (!has_future) {
[11:01:56.603]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.603]                               info)
[11:01:56.603]                           }
[11:01:56.603]                           else {
[11:01:56.603]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.603]                               info, version)
[11:01:56.603]                           }
[11:01:56.603]                           base::stop(msg)
[11:01:56.603]                         }
[11:01:56.603]                       })
[11:01:56.603]                     }
[11:01:56.603]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.603]                     base::options(mc.cores = 1L)
[11:01:56.603]                   }
[11:01:56.603]                   ...future.strategy.old <- future::plan("list")
[11:01:56.603]                   options(future.plan = NULL)
[11:01:56.603]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.603]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.603]                 }
[11:01:56.603]                 ...future.workdir <- getwd()
[11:01:56.603]             }
[11:01:56.603]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.603]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.603]         }
[11:01:56.603]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.603]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.603]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.603]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.603]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.603]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.603]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.603]             base::names(...future.oldOptions))
[11:01:56.603]     }
[11:01:56.603]     if (FALSE) {
[11:01:56.603]     }
[11:01:56.603]     else {
[11:01:56.603]         if (TRUE) {
[11:01:56.603]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.603]                 open = "w")
[11:01:56.603]         }
[11:01:56.603]         else {
[11:01:56.603]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.603]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.603]         }
[11:01:56.603]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.603]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.603]             base::sink(type = "output", split = FALSE)
[11:01:56.603]             base::close(...future.stdout)
[11:01:56.603]         }, add = TRUE)
[11:01:56.603]     }
[11:01:56.603]     ...future.frame <- base::sys.nframe()
[11:01:56.603]     ...future.conditions <- base::list()
[11:01:56.603]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.603]     if (FALSE) {
[11:01:56.603]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.603]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.603]     }
[11:01:56.603]     ...future.result <- base::tryCatch({
[11:01:56.603]         base::withCallingHandlers({
[11:01:56.603]             ...future.value <- base::withVisible(base::local({
[11:01:56.603]                 ...future.makeSendCondition <- base::local({
[11:01:56.603]                   sendCondition <- NULL
[11:01:56.603]                   function(frame = 1L) {
[11:01:56.603]                     if (is.function(sendCondition)) 
[11:01:56.603]                       return(sendCondition)
[11:01:56.603]                     ns <- getNamespace("parallel")
[11:01:56.603]                     if (exists("sendData", mode = "function", 
[11:01:56.603]                       envir = ns)) {
[11:01:56.603]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.603]                         envir = ns)
[11:01:56.603]                       envir <- sys.frame(frame)
[11:01:56.603]                       master <- NULL
[11:01:56.603]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.603]                         !identical(envir, emptyenv())) {
[11:01:56.603]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.603]                           inherits = FALSE)) {
[11:01:56.603]                           master <- get("master", mode = "list", 
[11:01:56.603]                             envir = envir, inherits = FALSE)
[11:01:56.603]                           if (inherits(master, c("SOCKnode", 
[11:01:56.603]                             "SOCK0node"))) {
[11:01:56.603]                             sendCondition <<- function(cond) {
[11:01:56.603]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.603]                                 success = TRUE)
[11:01:56.603]                               parallel_sendData(master, data)
[11:01:56.603]                             }
[11:01:56.603]                             return(sendCondition)
[11:01:56.603]                           }
[11:01:56.603]                         }
[11:01:56.603]                         frame <- frame + 1L
[11:01:56.603]                         envir <- sys.frame(frame)
[11:01:56.603]                       }
[11:01:56.603]                     }
[11:01:56.603]                     sendCondition <<- function(cond) NULL
[11:01:56.603]                   }
[11:01:56.603]                 })
[11:01:56.603]                 withCallingHandlers({
[11:01:56.603]                   1
[11:01:56.603]                 }, immediateCondition = function(cond) {
[11:01:56.603]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.603]                   sendCondition(cond)
[11:01:56.603]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.603]                   {
[11:01:56.603]                     inherits <- base::inherits
[11:01:56.603]                     invokeRestart <- base::invokeRestart
[11:01:56.603]                     is.null <- base::is.null
[11:01:56.603]                     muffled <- FALSE
[11:01:56.603]                     if (inherits(cond, "message")) {
[11:01:56.603]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.603]                       if (muffled) 
[11:01:56.603]                         invokeRestart("muffleMessage")
[11:01:56.603]                     }
[11:01:56.603]                     else if (inherits(cond, "warning")) {
[11:01:56.603]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.603]                       if (muffled) 
[11:01:56.603]                         invokeRestart("muffleWarning")
[11:01:56.603]                     }
[11:01:56.603]                     else if (inherits(cond, "condition")) {
[11:01:56.603]                       if (!is.null(pattern)) {
[11:01:56.603]                         computeRestarts <- base::computeRestarts
[11:01:56.603]                         grepl <- base::grepl
[11:01:56.603]                         restarts <- computeRestarts(cond)
[11:01:56.603]                         for (restart in restarts) {
[11:01:56.603]                           name <- restart$name
[11:01:56.603]                           if (is.null(name)) 
[11:01:56.603]                             next
[11:01:56.603]                           if (!grepl(pattern, name)) 
[11:01:56.603]                             next
[11:01:56.603]                           invokeRestart(restart)
[11:01:56.603]                           muffled <- TRUE
[11:01:56.603]                           break
[11:01:56.603]                         }
[11:01:56.603]                       }
[11:01:56.603]                     }
[11:01:56.603]                     invisible(muffled)
[11:01:56.603]                   }
[11:01:56.603]                   muffleCondition(cond)
[11:01:56.603]                 })
[11:01:56.603]             }))
[11:01:56.603]             future::FutureResult(value = ...future.value$value, 
[11:01:56.603]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.603]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.603]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.603]                     ...future.globalenv.names))
[11:01:56.603]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.603]         }, condition = base::local({
[11:01:56.603]             c <- base::c
[11:01:56.603]             inherits <- base::inherits
[11:01:56.603]             invokeRestart <- base::invokeRestart
[11:01:56.603]             length <- base::length
[11:01:56.603]             list <- base::list
[11:01:56.603]             seq.int <- base::seq.int
[11:01:56.603]             signalCondition <- base::signalCondition
[11:01:56.603]             sys.calls <- base::sys.calls
[11:01:56.603]             `[[` <- base::`[[`
[11:01:56.603]             `+` <- base::`+`
[11:01:56.603]             `<<-` <- base::`<<-`
[11:01:56.603]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.603]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.603]                   3L)]
[11:01:56.603]             }
[11:01:56.603]             function(cond) {
[11:01:56.603]                 is_error <- inherits(cond, "error")
[11:01:56.603]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.603]                   NULL)
[11:01:56.603]                 if (is_error) {
[11:01:56.603]                   sessionInformation <- function() {
[11:01:56.603]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.603]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.603]                       search = base::search(), system = base::Sys.info())
[11:01:56.603]                   }
[11:01:56.603]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.603]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.603]                     cond$call), session = sessionInformation(), 
[11:01:56.603]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.603]                   signalCondition(cond)
[11:01:56.603]                 }
[11:01:56.603]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.603]                 "immediateCondition"))) {
[11:01:56.603]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.603]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.603]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.603]                   if (TRUE && !signal) {
[11:01:56.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.603]                     {
[11:01:56.603]                       inherits <- base::inherits
[11:01:56.603]                       invokeRestart <- base::invokeRestart
[11:01:56.603]                       is.null <- base::is.null
[11:01:56.603]                       muffled <- FALSE
[11:01:56.603]                       if (inherits(cond, "message")) {
[11:01:56.603]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.603]                         if (muffled) 
[11:01:56.603]                           invokeRestart("muffleMessage")
[11:01:56.603]                       }
[11:01:56.603]                       else if (inherits(cond, "warning")) {
[11:01:56.603]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.603]                         if (muffled) 
[11:01:56.603]                           invokeRestart("muffleWarning")
[11:01:56.603]                       }
[11:01:56.603]                       else if (inherits(cond, "condition")) {
[11:01:56.603]                         if (!is.null(pattern)) {
[11:01:56.603]                           computeRestarts <- base::computeRestarts
[11:01:56.603]                           grepl <- base::grepl
[11:01:56.603]                           restarts <- computeRestarts(cond)
[11:01:56.603]                           for (restart in restarts) {
[11:01:56.603]                             name <- restart$name
[11:01:56.603]                             if (is.null(name)) 
[11:01:56.603]                               next
[11:01:56.603]                             if (!grepl(pattern, name)) 
[11:01:56.603]                               next
[11:01:56.603]                             invokeRestart(restart)
[11:01:56.603]                             muffled <- TRUE
[11:01:56.603]                             break
[11:01:56.603]                           }
[11:01:56.603]                         }
[11:01:56.603]                       }
[11:01:56.603]                       invisible(muffled)
[11:01:56.603]                     }
[11:01:56.603]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.603]                   }
[11:01:56.603]                 }
[11:01:56.603]                 else {
[11:01:56.603]                   if (TRUE) {
[11:01:56.603]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.603]                     {
[11:01:56.603]                       inherits <- base::inherits
[11:01:56.603]                       invokeRestart <- base::invokeRestart
[11:01:56.603]                       is.null <- base::is.null
[11:01:56.603]                       muffled <- FALSE
[11:01:56.603]                       if (inherits(cond, "message")) {
[11:01:56.603]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.603]                         if (muffled) 
[11:01:56.603]                           invokeRestart("muffleMessage")
[11:01:56.603]                       }
[11:01:56.603]                       else if (inherits(cond, "warning")) {
[11:01:56.603]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.603]                         if (muffled) 
[11:01:56.603]                           invokeRestart("muffleWarning")
[11:01:56.603]                       }
[11:01:56.603]                       else if (inherits(cond, "condition")) {
[11:01:56.603]                         if (!is.null(pattern)) {
[11:01:56.603]                           computeRestarts <- base::computeRestarts
[11:01:56.603]                           grepl <- base::grepl
[11:01:56.603]                           restarts <- computeRestarts(cond)
[11:01:56.603]                           for (restart in restarts) {
[11:01:56.603]                             name <- restart$name
[11:01:56.603]                             if (is.null(name)) 
[11:01:56.603]                               next
[11:01:56.603]                             if (!grepl(pattern, name)) 
[11:01:56.603]                               next
[11:01:56.603]                             invokeRestart(restart)
[11:01:56.603]                             muffled <- TRUE
[11:01:56.603]                             break
[11:01:56.603]                           }
[11:01:56.603]                         }
[11:01:56.603]                       }
[11:01:56.603]                       invisible(muffled)
[11:01:56.603]                     }
[11:01:56.603]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.603]                   }
[11:01:56.603]                 }
[11:01:56.603]             }
[11:01:56.603]         }))
[11:01:56.603]     }, error = function(ex) {
[11:01:56.603]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.603]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.603]                 ...future.rng), started = ...future.startTime, 
[11:01:56.603]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.603]             version = "1.8"), class = "FutureResult")
[11:01:56.603]     }, finally = {
[11:01:56.603]         if (!identical(...future.workdir, getwd())) 
[11:01:56.603]             setwd(...future.workdir)
[11:01:56.603]         {
[11:01:56.603]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.603]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.603]             }
[11:01:56.603]             base::options(...future.oldOptions)
[11:01:56.603]             if (.Platform$OS.type == "windows") {
[11:01:56.603]                 old_names <- names(...future.oldEnvVars)
[11:01:56.603]                 envs <- base::Sys.getenv()
[11:01:56.603]                 names <- names(envs)
[11:01:56.603]                 common <- intersect(names, old_names)
[11:01:56.603]                 added <- setdiff(names, old_names)
[11:01:56.603]                 removed <- setdiff(old_names, names)
[11:01:56.603]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.603]                   envs[common]]
[11:01:56.603]                 NAMES <- toupper(changed)
[11:01:56.603]                 args <- list()
[11:01:56.603]                 for (kk in seq_along(NAMES)) {
[11:01:56.603]                   name <- changed[[kk]]
[11:01:56.603]                   NAME <- NAMES[[kk]]
[11:01:56.603]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.603]                     next
[11:01:56.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.603]                 }
[11:01:56.603]                 NAMES <- toupper(added)
[11:01:56.603]                 for (kk in seq_along(NAMES)) {
[11:01:56.603]                   name <- added[[kk]]
[11:01:56.603]                   NAME <- NAMES[[kk]]
[11:01:56.603]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.603]                     next
[11:01:56.603]                   args[[name]] <- ""
[11:01:56.603]                 }
[11:01:56.603]                 NAMES <- toupper(removed)
[11:01:56.603]                 for (kk in seq_along(NAMES)) {
[11:01:56.603]                   name <- removed[[kk]]
[11:01:56.603]                   NAME <- NAMES[[kk]]
[11:01:56.603]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.603]                     next
[11:01:56.603]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.603]                 }
[11:01:56.603]                 if (length(args) > 0) 
[11:01:56.603]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.603]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.603]             }
[11:01:56.603]             else {
[11:01:56.603]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.603]             }
[11:01:56.603]             {
[11:01:56.603]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.603]                   0L) {
[11:01:56.603]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.603]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.603]                   base::options(opts)
[11:01:56.603]                 }
[11:01:56.603]                 {
[11:01:56.603]                   {
[11:01:56.603]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.603]                     NULL
[11:01:56.603]                   }
[11:01:56.603]                   options(future.plan = NULL)
[11:01:56.603]                   if (is.na(NA_character_)) 
[11:01:56.603]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.603]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.603]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.603]                     .init = FALSE)
[11:01:56.603]                 }
[11:01:56.603]             }
[11:01:56.603]         }
[11:01:56.603]     })
[11:01:56.603]     if (TRUE) {
[11:01:56.603]         base::sink(type = "output", split = FALSE)
[11:01:56.603]         if (TRUE) {
[11:01:56.603]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.603]         }
[11:01:56.603]         else {
[11:01:56.603]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.603]         }
[11:01:56.603]         base::close(...future.stdout)
[11:01:56.603]         ...future.stdout <- NULL
[11:01:56.603]     }
[11:01:56.603]     ...future.result$conditions <- ...future.conditions
[11:01:56.603]     ...future.result$finished <- base::Sys.time()
[11:01:56.603]     ...future.result
[11:01:56.603] }
[11:01:56.606] MultisessionFuture started
[11:01:56.606] - Launch lazy future ... done
[11:01:56.606] run() for ‘MultisessionFuture’ ... done
[11:01:56.648] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.648] - Validating connection of MultisessionFuture
[11:01:56.649] - received message: FutureResult
[11:01:56.649] - Received FutureResult
[11:01:56.649] - Erased future from FutureRegistry
[11:01:56.649] result() for ClusterFuture ...
[11:01:56.649] - result already collected: FutureResult
[11:01:56.649] result() for ClusterFuture ... done
[11:01:56.649] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.649] Future #1
[11:01:56.649] result() for ClusterFuture ...
[11:01:56.649] - result already collected: FutureResult
[11:01:56.649] result() for ClusterFuture ... done
[11:01:56.650] result() for ClusterFuture ...
[11:01:56.650] - result already collected: FutureResult
[11:01:56.650] result() for ClusterFuture ... done
[11:01:56.650] A MultisessionFuture was resolved
[11:01:56.650]  length: 0 (resolved future 1)
[11:01:56.650] resolve() on list ... DONE
[11:01:56.650] - globals: [1] ‘a’
[11:01:56.650] Resolving futures part of globals (recursively) ... DONE
[11:01:56.662] The total size of the 1 globals is 313.25 KiB (320770 bytes)
[11:01:56.663] The total size of the 1 globals exported for future expression (‘value(a) + 1’) is 313.25 KiB.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘a’ (313.25 KiB of class ‘environment’)
[11:01:56.663] - globals: [1] ‘a’
[11:01:56.663] - packages: [1] ‘future’
[11:01:56.663] getGlobalsAndPackages() ... DONE
[11:01:56.663] run() for ‘Future’ ...
[11:01:56.663] - state: ‘created’
[11:01:56.663] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.677] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.677] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.677]   - Field: ‘node’
[11:01:56.677]   - Field: ‘label’
[11:01:56.678]   - Field: ‘local’
[11:01:56.678]   - Field: ‘owner’
[11:01:56.678]   - Field: ‘envir’
[11:01:56.678]   - Field: ‘workers’
[11:01:56.678]   - Field: ‘packages’
[11:01:56.678]   - Field: ‘gc’
[11:01:56.678]   - Field: ‘conditions’
[11:01:56.678]   - Field: ‘persistent’
[11:01:56.678]   - Field: ‘expr’
[11:01:56.678]   - Field: ‘uuid’
[11:01:56.678]   - Field: ‘seed’
[11:01:56.678]   - Field: ‘version’
[11:01:56.679]   - Field: ‘result’
[11:01:56.679]   - Field: ‘asynchronous’
[11:01:56.679]   - Field: ‘calls’
[11:01:56.679]   - Field: ‘globals’
[11:01:56.679]   - Field: ‘stdout’
[11:01:56.679]   - Field: ‘earlySignal’
[11:01:56.679]   - Field: ‘lazy’
[11:01:56.679]   - Field: ‘state’
[11:01:56.679] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.679] - Launch lazy future ...
[11:01:56.680] Packages needed by the future expression (n = 1): ‘future’
[11:01:56.680] Packages needed by future strategies (n = 0): <none>
[11:01:56.680] {
[11:01:56.680]     {
[11:01:56.680]         {
[11:01:56.680]             ...future.startTime <- base::Sys.time()
[11:01:56.680]             {
[11:01:56.680]                 {
[11:01:56.680]                   {
[11:01:56.680]                     {
[11:01:56.680]                       {
[11:01:56.680]                         base::local({
[11:01:56.680]                           has_future <- base::requireNamespace("future", 
[11:01:56.680]                             quietly = TRUE)
[11:01:56.680]                           if (has_future) {
[11:01:56.680]                             ns <- base::getNamespace("future")
[11:01:56.680]                             version <- ns[[".package"]][["version"]]
[11:01:56.680]                             if (is.null(version)) 
[11:01:56.680]                               version <- utils::packageVersion("future")
[11:01:56.680]                           }
[11:01:56.680]                           else {
[11:01:56.680]                             version <- NULL
[11:01:56.680]                           }
[11:01:56.680]                           if (!has_future || version < "1.8.0") {
[11:01:56.680]                             info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.680]                               "", base::R.version$version.string), 
[11:01:56.680]                               platform = base::sprintf("%s (%s-bit)", 
[11:01:56.680]                                 base::R.version$platform, 8 * 
[11:01:56.680]                                   base::.Machine$sizeof.pointer), 
[11:01:56.680]                               os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.680]                                 "release", "version")], collapse = " "), 
[11:01:56.680]                               hostname = base::Sys.info()[["nodename"]])
[11:01:56.680]                             info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.680]                               info)
[11:01:56.680]                             info <- base::paste(info, collapse = "; ")
[11:01:56.680]                             if (!has_future) {
[11:01:56.680]                               msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.680]                                 info)
[11:01:56.680]                             }
[11:01:56.680]                             else {
[11:01:56.680]                               msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.680]                                 info, version)
[11:01:56.680]                             }
[11:01:56.680]                             base::stop(msg)
[11:01:56.680]                           }
[11:01:56.680]                         })
[11:01:56.680]                       }
[11:01:56.680]                       ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.680]                       base::options(mc.cores = 1L)
[11:01:56.680]                     }
[11:01:56.680]                     base::local({
[11:01:56.680]                       for (pkg in "future") {
[11:01:56.680]                         base::loadNamespace(pkg)
[11:01:56.680]                         base::library(pkg, character.only = TRUE)
[11:01:56.680]                       }
[11:01:56.680]                     })
[11:01:56.680]                   }
[11:01:56.680]                   ...future.strategy.old <- future::plan("list")
[11:01:56.680]                   options(future.plan = NULL)
[11:01:56.680]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.680]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.680]                 }
[11:01:56.680]                 ...future.workdir <- getwd()
[11:01:56.680]             }
[11:01:56.680]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.680]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.680]         }
[11:01:56.680]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.680]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.680]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.680]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.680]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.680]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.680]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.680]             base::names(...future.oldOptions))
[11:01:56.680]     }
[11:01:56.680]     if (FALSE) {
[11:01:56.680]     }
[11:01:56.680]     else {
[11:01:56.680]         if (TRUE) {
[11:01:56.680]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.680]                 open = "w")
[11:01:56.680]         }
[11:01:56.680]         else {
[11:01:56.680]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.680]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.680]         }
[11:01:56.680]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.680]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.680]             base::sink(type = "output", split = FALSE)
[11:01:56.680]             base::close(...future.stdout)
[11:01:56.680]         }, add = TRUE)
[11:01:56.680]     }
[11:01:56.680]     ...future.frame <- base::sys.nframe()
[11:01:56.680]     ...future.conditions <- base::list()
[11:01:56.680]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.680]     if (FALSE) {
[11:01:56.680]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.680]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.680]     }
[11:01:56.680]     ...future.result <- base::tryCatch({
[11:01:56.680]         base::withCallingHandlers({
[11:01:56.680]             ...future.value <- base::withVisible(base::local({
[11:01:56.680]                 ...future.makeSendCondition <- base::local({
[11:01:56.680]                   sendCondition <- NULL
[11:01:56.680]                   function(frame = 1L) {
[11:01:56.680]                     if (is.function(sendCondition)) 
[11:01:56.680]                       return(sendCondition)
[11:01:56.680]                     ns <- getNamespace("parallel")
[11:01:56.680]                     if (exists("sendData", mode = "function", 
[11:01:56.680]                       envir = ns)) {
[11:01:56.680]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.680]                         envir = ns)
[11:01:56.680]                       envir <- sys.frame(frame)
[11:01:56.680]                       master <- NULL
[11:01:56.680]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.680]                         !identical(envir, emptyenv())) {
[11:01:56.680]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.680]                           inherits = FALSE)) {
[11:01:56.680]                           master <- get("master", mode = "list", 
[11:01:56.680]                             envir = envir, inherits = FALSE)
[11:01:56.680]                           if (inherits(master, c("SOCKnode", 
[11:01:56.680]                             "SOCK0node"))) {
[11:01:56.680]                             sendCondition <<- function(cond) {
[11:01:56.680]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.680]                                 success = TRUE)
[11:01:56.680]                               parallel_sendData(master, data)
[11:01:56.680]                             }
[11:01:56.680]                             return(sendCondition)
[11:01:56.680]                           }
[11:01:56.680]                         }
[11:01:56.680]                         frame <- frame + 1L
[11:01:56.680]                         envir <- sys.frame(frame)
[11:01:56.680]                       }
[11:01:56.680]                     }
[11:01:56.680]                     sendCondition <<- function(cond) NULL
[11:01:56.680]                   }
[11:01:56.680]                 })
[11:01:56.680]                 withCallingHandlers({
[11:01:56.680]                   value(a) + 1
[11:01:56.680]                 }, immediateCondition = function(cond) {
[11:01:56.680]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.680]                   sendCondition(cond)
[11:01:56.680]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.680]                   {
[11:01:56.680]                     inherits <- base::inherits
[11:01:56.680]                     invokeRestart <- base::invokeRestart
[11:01:56.680]                     is.null <- base::is.null
[11:01:56.680]                     muffled <- FALSE
[11:01:56.680]                     if (inherits(cond, "message")) {
[11:01:56.680]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.680]                       if (muffled) 
[11:01:56.680]                         invokeRestart("muffleMessage")
[11:01:56.680]                     }
[11:01:56.680]                     else if (inherits(cond, "warning")) {
[11:01:56.680]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.680]                       if (muffled) 
[11:01:56.680]                         invokeRestart("muffleWarning")
[11:01:56.680]                     }
[11:01:56.680]                     else if (inherits(cond, "condition")) {
[11:01:56.680]                       if (!is.null(pattern)) {
[11:01:56.680]                         computeRestarts <- base::computeRestarts
[11:01:56.680]                         grepl <- base::grepl
[11:01:56.680]                         restarts <- computeRestarts(cond)
[11:01:56.680]                         for (restart in restarts) {
[11:01:56.680]                           name <- restart$name
[11:01:56.680]                           if (is.null(name)) 
[11:01:56.680]                             next
[11:01:56.680]                           if (!grepl(pattern, name)) 
[11:01:56.680]                             next
[11:01:56.680]                           invokeRestart(restart)
[11:01:56.680]                           muffled <- TRUE
[11:01:56.680]                           break
[11:01:56.680]                         }
[11:01:56.680]                       }
[11:01:56.680]                     }
[11:01:56.680]                     invisible(muffled)
[11:01:56.680]                   }
[11:01:56.680]                   muffleCondition(cond)
[11:01:56.680]                 })
[11:01:56.680]             }))
[11:01:56.680]             future::FutureResult(value = ...future.value$value, 
[11:01:56.680]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.680]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.680]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.680]                     ...future.globalenv.names))
[11:01:56.680]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.680]         }, condition = base::local({
[11:01:56.680]             c <- base::c
[11:01:56.680]             inherits <- base::inherits
[11:01:56.680]             invokeRestart <- base::invokeRestart
[11:01:56.680]             length <- base::length
[11:01:56.680]             list <- base::list
[11:01:56.680]             seq.int <- base::seq.int
[11:01:56.680]             signalCondition <- base::signalCondition
[11:01:56.680]             sys.calls <- base::sys.calls
[11:01:56.680]             `[[` <- base::`[[`
[11:01:56.680]             `+` <- base::`+`
[11:01:56.680]             `<<-` <- base::`<<-`
[11:01:56.680]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.680]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.680]                   3L)]
[11:01:56.680]             }
[11:01:56.680]             function(cond) {
[11:01:56.680]                 is_error <- inherits(cond, "error")
[11:01:56.680]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.680]                   NULL)
[11:01:56.680]                 if (is_error) {
[11:01:56.680]                   sessionInformation <- function() {
[11:01:56.680]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.680]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.680]                       search = base::search(), system = base::Sys.info())
[11:01:56.680]                   }
[11:01:56.680]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.680]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.680]                     cond$call), session = sessionInformation(), 
[11:01:56.680]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.680]                   signalCondition(cond)
[11:01:56.680]                 }
[11:01:56.680]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.680]                 "immediateCondition"))) {
[11:01:56.680]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.680]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.680]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.680]                   if (TRUE && !signal) {
[11:01:56.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.680]                     {
[11:01:56.680]                       inherits <- base::inherits
[11:01:56.680]                       invokeRestart <- base::invokeRestart
[11:01:56.680]                       is.null <- base::is.null
[11:01:56.680]                       muffled <- FALSE
[11:01:56.680]                       if (inherits(cond, "message")) {
[11:01:56.680]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.680]                         if (muffled) 
[11:01:56.680]                           invokeRestart("muffleMessage")
[11:01:56.680]                       }
[11:01:56.680]                       else if (inherits(cond, "warning")) {
[11:01:56.680]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.680]                         if (muffled) 
[11:01:56.680]                           invokeRestart("muffleWarning")
[11:01:56.680]                       }
[11:01:56.680]                       else if (inherits(cond, "condition")) {
[11:01:56.680]                         if (!is.null(pattern)) {
[11:01:56.680]                           computeRestarts <- base::computeRestarts
[11:01:56.680]                           grepl <- base::grepl
[11:01:56.680]                           restarts <- computeRestarts(cond)
[11:01:56.680]                           for (restart in restarts) {
[11:01:56.680]                             name <- restart$name
[11:01:56.680]                             if (is.null(name)) 
[11:01:56.680]                               next
[11:01:56.680]                             if (!grepl(pattern, name)) 
[11:01:56.680]                               next
[11:01:56.680]                             invokeRestart(restart)
[11:01:56.680]                             muffled <- TRUE
[11:01:56.680]                             break
[11:01:56.680]                           }
[11:01:56.680]                         }
[11:01:56.680]                       }
[11:01:56.680]                       invisible(muffled)
[11:01:56.680]                     }
[11:01:56.680]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.680]                   }
[11:01:56.680]                 }
[11:01:56.680]                 else {
[11:01:56.680]                   if (TRUE) {
[11:01:56.680]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.680]                     {
[11:01:56.680]                       inherits <- base::inherits
[11:01:56.680]                       invokeRestart <- base::invokeRestart
[11:01:56.680]                       is.null <- base::is.null
[11:01:56.680]                       muffled <- FALSE
[11:01:56.680]                       if (inherits(cond, "message")) {
[11:01:56.680]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.680]                         if (muffled) 
[11:01:56.680]                           invokeRestart("muffleMessage")
[11:01:56.680]                       }
[11:01:56.680]                       else if (inherits(cond, "warning")) {
[11:01:56.680]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.680]                         if (muffled) 
[11:01:56.680]                           invokeRestart("muffleWarning")
[11:01:56.680]                       }
[11:01:56.680]                       else if (inherits(cond, "condition")) {
[11:01:56.680]                         if (!is.null(pattern)) {
[11:01:56.680]                           computeRestarts <- base::computeRestarts
[11:01:56.680]                           grepl <- base::grepl
[11:01:56.680]                           restarts <- computeRestarts(cond)
[11:01:56.680]                           for (restart in restarts) {
[11:01:56.680]                             name <- restart$name
[11:01:56.680]                             if (is.null(name)) 
[11:01:56.680]                               next
[11:01:56.680]                             if (!grepl(pattern, name)) 
[11:01:56.680]                               next
[11:01:56.680]                             invokeRestart(restart)
[11:01:56.680]                             muffled <- TRUE
[11:01:56.680]                             break
[11:01:56.680]                           }
[11:01:56.680]                         }
[11:01:56.680]                       }
[11:01:56.680]                       invisible(muffled)
[11:01:56.680]                     }
[11:01:56.680]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.680]                   }
[11:01:56.680]                 }
[11:01:56.680]             }
[11:01:56.680]         }))
[11:01:56.680]     }, error = function(ex) {
[11:01:56.680]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.680]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.680]                 ...future.rng), started = ...future.startTime, 
[11:01:56.680]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.680]             version = "1.8"), class = "FutureResult")
[11:01:56.680]     }, finally = {
[11:01:56.680]         if (!identical(...future.workdir, getwd())) 
[11:01:56.680]             setwd(...future.workdir)
[11:01:56.680]         {
[11:01:56.680]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.680]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.680]             }
[11:01:56.680]             base::options(...future.oldOptions)
[11:01:56.680]             if (.Platform$OS.type == "windows") {
[11:01:56.680]                 old_names <- names(...future.oldEnvVars)
[11:01:56.680]                 envs <- base::Sys.getenv()
[11:01:56.680]                 names <- names(envs)
[11:01:56.680]                 common <- intersect(names, old_names)
[11:01:56.680]                 added <- setdiff(names, old_names)
[11:01:56.680]                 removed <- setdiff(old_names, names)
[11:01:56.680]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.680]                   envs[common]]
[11:01:56.680]                 NAMES <- toupper(changed)
[11:01:56.680]                 args <- list()
[11:01:56.680]                 for (kk in seq_along(NAMES)) {
[11:01:56.680]                   name <- changed[[kk]]
[11:01:56.680]                   NAME <- NAMES[[kk]]
[11:01:56.680]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.680]                     next
[11:01:56.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.680]                 }
[11:01:56.680]                 NAMES <- toupper(added)
[11:01:56.680]                 for (kk in seq_along(NAMES)) {
[11:01:56.680]                   name <- added[[kk]]
[11:01:56.680]                   NAME <- NAMES[[kk]]
[11:01:56.680]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.680]                     next
[11:01:56.680]                   args[[name]] <- ""
[11:01:56.680]                 }
[11:01:56.680]                 NAMES <- toupper(removed)
[11:01:56.680]                 for (kk in seq_along(NAMES)) {
[11:01:56.680]                   name <- removed[[kk]]
[11:01:56.680]                   NAME <- NAMES[[kk]]
[11:01:56.680]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.680]                     next
[11:01:56.680]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.680]                 }
[11:01:56.680]                 if (length(args) > 0) 
[11:01:56.680]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.680]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.680]             }
[11:01:56.680]             else {
[11:01:56.680]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.680]             }
[11:01:56.680]             {
[11:01:56.680]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.680]                   0L) {
[11:01:56.680]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.680]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.680]                   base::options(opts)
[11:01:56.680]                 }
[11:01:56.680]                 {
[11:01:56.680]                   {
[11:01:56.680]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.680]                     NULL
[11:01:56.680]                   }
[11:01:56.680]                   options(future.plan = NULL)
[11:01:56.680]                   if (is.na(NA_character_)) 
[11:01:56.680]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.680]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.680]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.680]                     .init = FALSE)
[11:01:56.680]                 }
[11:01:56.680]             }
[11:01:56.680]         }
[11:01:56.680]     })
[11:01:56.680]     if (TRUE) {
[11:01:56.680]         base::sink(type = "output", split = FALSE)
[11:01:56.680]         if (TRUE) {
[11:01:56.680]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.680]         }
[11:01:56.680]         else {
[11:01:56.680]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.680]         }
[11:01:56.680]         base::close(...future.stdout)
[11:01:56.680]         ...future.stdout <- NULL
[11:01:56.680]     }
[11:01:56.680]     ...future.result$conditions <- ...future.conditions
[11:01:56.680]     ...future.result$finished <- base::Sys.time()
[11:01:56.680]     ...future.result
[11:01:56.680] }
[11:01:56.694] Exporting 1 global objects (313.46 KiB) to cluster node #1 ...
[11:01:56.704] Exporting ‘a’ (313.25 KiB) to cluster node #1 ...
[11:01:56.757] Exporting ‘a’ (313.25 KiB) to cluster node #1 ... DONE
[11:01:56.757] Exporting 1 global objects (313.46 KiB) to cluster node #1 ... DONE
[11:01:56.757] MultisessionFuture started
[11:01:56.758] - Launch lazy future ... done
[11:01:56.758] run() for ‘MultisessionFuture’ ... done
[11:01:56.758] result() for ClusterFuture ...
[11:01:56.758] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.758] - Validating connection of MultisessionFuture
[11:01:56.799] - received message: FutureResult
[11:01:56.799] - Received FutureResult
[11:01:56.799] - Erased future from FutureRegistry
[11:01:56.799] result() for ClusterFuture ...
[11:01:56.800] - result already collected: FutureResult
[11:01:56.800] result() for ClusterFuture ... done
[11:01:56.800] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.800] result() for ClusterFuture ... done
[11:01:56.800] result() for ClusterFuture ...
[11:01:56.800] - result already collected: FutureResult
[11:01:56.800] result() for ClusterFuture ... done
value(b) = 2
[11:01:56.800] result() for ClusterFuture ...
[11:01:56.800] - result already collected: FutureResult
[11:01:56.800] result() for ClusterFuture ... done
[11:01:56.801] result() for ClusterFuture ...
[11:01:56.801] - result already collected: FutureResult
[11:01:56.801] result() for ClusterFuture ... done
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.801] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.801] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.802] - globals found: [2] ‘{’, ‘pkg’
[11:01:56.802] Searching for globals ... DONE
[11:01:56.802] Resolving globals: TRUE
[11:01:56.802] Resolving any globals that are futures ...
[11:01:56.802] - globals: [2] ‘{’, ‘pkg’
[11:01:56.802] Resolving any globals that are futures ... DONE
[11:01:56.803] Resolving futures part of globals (recursively) ...
[11:01:56.803] resolve() on list ...
[11:01:56.803]  recursive: 99
[11:01:56.803]  length: 1
[11:01:56.803]  elements: ‘pkg’
[11:01:56.803]  length: 0 (resolved future 1)
[11:01:56.803] resolve() on list ... DONE
[11:01:56.803] - globals: [1] ‘pkg’
[11:01:56.803] Resolving futures part of globals (recursively) ... DONE
[11:01:56.804] The total size of the 1 globals is 42 bytes (42 bytes)
[11:01:56.804] The total size of the 1 globals exported for future expression (‘{; pkg; }’) is 42 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘pkg’ (42 bytes of class ‘character’)
[11:01:56.804] - globals: [1] ‘pkg’
[11:01:56.804] 
[11:01:56.804] getGlobalsAndPackages() ... DONE
[11:01:56.804] Packages needed by the future expression (n = 0): <none>
[11:01:56.805] Packages needed by future strategies (n = 0): <none>
[11:01:56.805] {
[11:01:56.805]     {
[11:01:56.805]         {
[11:01:56.805]             ...future.startTime <- base::Sys.time()
[11:01:56.805]             {
[11:01:56.805]                 {
[11:01:56.805]                   {
[11:01:56.805]                     base::local({
[11:01:56.805]                       has_future <- base::requireNamespace("future", 
[11:01:56.805]                         quietly = TRUE)
[11:01:56.805]                       if (has_future) {
[11:01:56.805]                         ns <- base::getNamespace("future")
[11:01:56.805]                         version <- ns[[".package"]][["version"]]
[11:01:56.805]                         if (is.null(version)) 
[11:01:56.805]                           version <- utils::packageVersion("future")
[11:01:56.805]                       }
[11:01:56.805]                       else {
[11:01:56.805]                         version <- NULL
[11:01:56.805]                       }
[11:01:56.805]                       if (!has_future || version < "1.8.0") {
[11:01:56.805]                         info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.805]                           "", base::R.version$version.string), 
[11:01:56.805]                           platform = base::sprintf("%s (%s-bit)", 
[11:01:56.805]                             base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:56.805]                           os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.805]                             "release", "version")], collapse = " "), 
[11:01:56.805]                           hostname = base::Sys.info()[["nodename"]])
[11:01:56.805]                         info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.805]                           info)
[11:01:56.805]                         info <- base::paste(info, collapse = "; ")
[11:01:56.805]                         if (!has_future) {
[11:01:56.805]                           msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.805]                             info)
[11:01:56.805]                         }
[11:01:56.805]                         else {
[11:01:56.805]                           msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.805]                             info, version)
[11:01:56.805]                         }
[11:01:56.805]                         base::stop(msg)
[11:01:56.805]                       }
[11:01:56.805]                     })
[11:01:56.805]                   }
[11:01:56.805]                   ...future.strategy.old <- future::plan("list")
[11:01:56.805]                   options(future.plan = NULL)
[11:01:56.805]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.805]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.805]                 }
[11:01:56.805]                 ...future.workdir <- getwd()
[11:01:56.805]             }
[11:01:56.805]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.805]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.805]         }
[11:01:56.805]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.805]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.805]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.805]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.805]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.805]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.805]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.805]             base::names(...future.oldOptions))
[11:01:56.805]     }
[11:01:56.805]     if (FALSE) {
[11:01:56.805]     }
[11:01:56.805]     else {
[11:01:56.805]         if (TRUE) {
[11:01:56.805]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.805]                 open = "w")
[11:01:56.805]         }
[11:01:56.805]         else {
[11:01:56.805]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.805]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.805]         }
[11:01:56.805]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.805]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.805]             base::sink(type = "output", split = FALSE)
[11:01:56.805]             base::close(...future.stdout)
[11:01:56.805]         }, add = TRUE)
[11:01:56.805]     }
[11:01:56.805]     ...future.frame <- base::sys.nframe()
[11:01:56.805]     ...future.conditions <- base::list()
[11:01:56.805]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.805]     if (FALSE) {
[11:01:56.805]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.805]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.805]     }
[11:01:56.805]     ...future.result <- base::tryCatch({
[11:01:56.805]         base::withCallingHandlers({
[11:01:56.805]             ...future.value <- base::withVisible(base::local({
[11:01:56.805]                 pkg
[11:01:56.805]             }))
[11:01:56.805]             future::FutureResult(value = ...future.value$value, 
[11:01:56.805]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.805]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.805]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.805]                     ...future.globalenv.names))
[11:01:56.805]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.805]         }, condition = base::local({
[11:01:56.805]             c <- base::c
[11:01:56.805]             inherits <- base::inherits
[11:01:56.805]             invokeRestart <- base::invokeRestart
[11:01:56.805]             length <- base::length
[11:01:56.805]             list <- base::list
[11:01:56.805]             seq.int <- base::seq.int
[11:01:56.805]             signalCondition <- base::signalCondition
[11:01:56.805]             sys.calls <- base::sys.calls
[11:01:56.805]             `[[` <- base::`[[`
[11:01:56.805]             `+` <- base::`+`
[11:01:56.805]             `<<-` <- base::`<<-`
[11:01:56.805]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.805]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.805]                   3L)]
[11:01:56.805]             }
[11:01:56.805]             function(cond) {
[11:01:56.805]                 is_error <- inherits(cond, "error")
[11:01:56.805]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.805]                   NULL)
[11:01:56.805]                 if (is_error) {
[11:01:56.805]                   sessionInformation <- function() {
[11:01:56.805]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.805]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.805]                       search = base::search(), system = base::Sys.info())
[11:01:56.805]                   }
[11:01:56.805]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.805]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.805]                     cond$call), session = sessionInformation(), 
[11:01:56.805]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.805]                   signalCondition(cond)
[11:01:56.805]                 }
[11:01:56.805]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.805]                 "immediateCondition"))) {
[11:01:56.805]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.805]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.805]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.805]                   if (TRUE && !signal) {
[11:01:56.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.805]                     {
[11:01:56.805]                       inherits <- base::inherits
[11:01:56.805]                       invokeRestart <- base::invokeRestart
[11:01:56.805]                       is.null <- base::is.null
[11:01:56.805]                       muffled <- FALSE
[11:01:56.805]                       if (inherits(cond, "message")) {
[11:01:56.805]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.805]                         if (muffled) 
[11:01:56.805]                           invokeRestart("muffleMessage")
[11:01:56.805]                       }
[11:01:56.805]                       else if (inherits(cond, "warning")) {
[11:01:56.805]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.805]                         if (muffled) 
[11:01:56.805]                           invokeRestart("muffleWarning")
[11:01:56.805]                       }
[11:01:56.805]                       else if (inherits(cond, "condition")) {
[11:01:56.805]                         if (!is.null(pattern)) {
[11:01:56.805]                           computeRestarts <- base::computeRestarts
[11:01:56.805]                           grepl <- base::grepl
[11:01:56.805]                           restarts <- computeRestarts(cond)
[11:01:56.805]                           for (restart in restarts) {
[11:01:56.805]                             name <- restart$name
[11:01:56.805]                             if (is.null(name)) 
[11:01:56.805]                               next
[11:01:56.805]                             if (!grepl(pattern, name)) 
[11:01:56.805]                               next
[11:01:56.805]                             invokeRestart(restart)
[11:01:56.805]                             muffled <- TRUE
[11:01:56.805]                             break
[11:01:56.805]                           }
[11:01:56.805]                         }
[11:01:56.805]                       }
[11:01:56.805]                       invisible(muffled)
[11:01:56.805]                     }
[11:01:56.805]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.805]                   }
[11:01:56.805]                 }
[11:01:56.805]                 else {
[11:01:56.805]                   if (TRUE) {
[11:01:56.805]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.805]                     {
[11:01:56.805]                       inherits <- base::inherits
[11:01:56.805]                       invokeRestart <- base::invokeRestart
[11:01:56.805]                       is.null <- base::is.null
[11:01:56.805]                       muffled <- FALSE
[11:01:56.805]                       if (inherits(cond, "message")) {
[11:01:56.805]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.805]                         if (muffled) 
[11:01:56.805]                           invokeRestart("muffleMessage")
[11:01:56.805]                       }
[11:01:56.805]                       else if (inherits(cond, "warning")) {
[11:01:56.805]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.805]                         if (muffled) 
[11:01:56.805]                           invokeRestart("muffleWarning")
[11:01:56.805]                       }
[11:01:56.805]                       else if (inherits(cond, "condition")) {
[11:01:56.805]                         if (!is.null(pattern)) {
[11:01:56.805]                           computeRestarts <- base::computeRestarts
[11:01:56.805]                           grepl <- base::grepl
[11:01:56.805]                           restarts <- computeRestarts(cond)
[11:01:56.805]                           for (restart in restarts) {
[11:01:56.805]                             name <- restart$name
[11:01:56.805]                             if (is.null(name)) 
[11:01:56.805]                               next
[11:01:56.805]                             if (!grepl(pattern, name)) 
[11:01:56.805]                               next
[11:01:56.805]                             invokeRestart(restart)
[11:01:56.805]                             muffled <- TRUE
[11:01:56.805]                             break
[11:01:56.805]                           }
[11:01:56.805]                         }
[11:01:56.805]                       }
[11:01:56.805]                       invisible(muffled)
[11:01:56.805]                     }
[11:01:56.805]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.805]                   }
[11:01:56.805]                 }
[11:01:56.805]             }
[11:01:56.805]         }))
[11:01:56.805]     }, error = function(ex) {
[11:01:56.805]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.805]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.805]                 ...future.rng), started = ...future.startTime, 
[11:01:56.805]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.805]             version = "1.8"), class = "FutureResult")
[11:01:56.805]     }, finally = {
[11:01:56.805]         if (!identical(...future.workdir, getwd())) 
[11:01:56.805]             setwd(...future.workdir)
[11:01:56.805]         {
[11:01:56.805]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.805]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.805]             }
[11:01:56.805]             base::options(...future.oldOptions)
[11:01:56.805]             if (.Platform$OS.type == "windows") {
[11:01:56.805]                 old_names <- names(...future.oldEnvVars)
[11:01:56.805]                 envs <- base::Sys.getenv()
[11:01:56.805]                 names <- names(envs)
[11:01:56.805]                 common <- intersect(names, old_names)
[11:01:56.805]                 added <- setdiff(names, old_names)
[11:01:56.805]                 removed <- setdiff(old_names, names)
[11:01:56.805]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.805]                   envs[common]]
[11:01:56.805]                 NAMES <- toupper(changed)
[11:01:56.805]                 args <- list()
[11:01:56.805]                 for (kk in seq_along(NAMES)) {
[11:01:56.805]                   name <- changed[[kk]]
[11:01:56.805]                   NAME <- NAMES[[kk]]
[11:01:56.805]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.805]                     next
[11:01:56.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.805]                 }
[11:01:56.805]                 NAMES <- toupper(added)
[11:01:56.805]                 for (kk in seq_along(NAMES)) {
[11:01:56.805]                   name <- added[[kk]]
[11:01:56.805]                   NAME <- NAMES[[kk]]
[11:01:56.805]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.805]                     next
[11:01:56.805]                   args[[name]] <- ""
[11:01:56.805]                 }
[11:01:56.805]                 NAMES <- toupper(removed)
[11:01:56.805]                 for (kk in seq_along(NAMES)) {
[11:01:56.805]                   name <- removed[[kk]]
[11:01:56.805]                   NAME <- NAMES[[kk]]
[11:01:56.805]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.805]                     next
[11:01:56.805]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.805]                 }
[11:01:56.805]                 if (length(args) > 0) 
[11:01:56.805]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.805]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.805]             }
[11:01:56.805]             else {
[11:01:56.805]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.805]             }
[11:01:56.805]             {
[11:01:56.805]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.805]                   0L) {
[11:01:56.805]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.805]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.805]                   base::options(opts)
[11:01:56.805]                 }
[11:01:56.805]                 {
[11:01:56.805]                   {
[11:01:56.805]                     NULL
[11:01:56.805]                     RNGkind("Mersenne-Twister")
[11:01:56.805]                     base::rm(list = ".Random.seed", envir = base::globalenv(), 
[11:01:56.805]                       inherits = FALSE)
[11:01:56.805]                   }
[11:01:56.805]                   options(future.plan = NULL)
[11:01:56.805]                   if (is.na(NA_character_)) 
[11:01:56.805]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.805]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.805]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.805]                     .init = FALSE)
[11:01:56.805]                 }
[11:01:56.805]             }
[11:01:56.805]         }
[11:01:56.805]     })
[11:01:56.805]     if (TRUE) {
[11:01:56.805]         base::sink(type = "output", split = FALSE)
[11:01:56.805]         if (TRUE) {
[11:01:56.805]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.805]         }
[11:01:56.805]         else {
[11:01:56.805]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.805]         }
[11:01:56.805]         base::close(...future.stdout)
[11:01:56.805]         ...future.stdout <- NULL
[11:01:56.805]     }
[11:01:56.805]     ...future.result$conditions <- ...future.conditions
[11:01:56.805]     ...future.result$finished <- base::Sys.time()
[11:01:56.805]     ...future.result
[11:01:56.805] }
[11:01:56.807] assign_globals() ...
[11:01:56.807] List of 1
[11:01:56.807]  $ pkg: chr "foo"
[11:01:56.807]  - attr(*, "where")=List of 1
[11:01:56.807]   ..$ pkg:<environment: R_EmptyEnv> 
[11:01:56.807]  - attr(*, "class")= chr [1:3] "FutureGlobals" "Globals" "list"
[11:01:56.807]  - attr(*, "resolved")= logi TRUE
[11:01:56.807]  - attr(*, "total_size")= num 42
[11:01:56.809] - copied ‘pkg’ to environment
[11:01:56.809] assign_globals() ... done
[11:01:56.809] plan(): Setting new future strategy stack:
[11:01:56.809] List of future strategies:
[11:01:56.809] 1. sequential:
[11:01:56.809]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:56.809]    - tweaked: FALSE
[11:01:56.809]    - call: NULL
[11:01:56.810] plan(): nbrOfWorkers() = 1
[11:01:56.810] plan(): Setting new future strategy stack:
[11:01:56.811] List of future strategies:
[11:01:56.811] 1. multisession:
[11:01:56.811]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[11:01:56.811]    - tweaked: FALSE
[11:01:56.811]    - call: plan(strategy)
[11:01:56.812] plan(): nbrOfWorkers() = 2
[11:01:56.812] SequentialFuture started (and completed)
value(f) = ‘foo’
Method for identifying globals: 'ordered' ... DONE
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.813] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.813] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.814] - globals found: [3] ‘{’, ‘<-’, ‘+’
[11:01:56.815] Searching for globals ... DONE
[11:01:56.815] Resolving globals: TRUE
[11:01:56.815] Resolving any globals that are futures ...
[11:01:56.815] - globals: [3] ‘{’, ‘<-’, ‘+’
[11:01:56.815] Resolving any globals that are futures ... DONE
[11:01:56.815] 
[11:01:56.815] 
[11:01:56.815] getGlobalsAndPackages() ... DONE
[11:01:56.816] run() for ‘Future’ ...
[11:01:56.816] - state: ‘created’
[11:01:56.816] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.829] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.829] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.830]   - Field: ‘node’
[11:01:56.830]   - Field: ‘label’
[11:01:56.830]   - Field: ‘local’
[11:01:56.830]   - Field: ‘owner’
[11:01:56.830]   - Field: ‘envir’
[11:01:56.830]   - Field: ‘workers’
[11:01:56.830]   - Field: ‘packages’
[11:01:56.830]   - Field: ‘gc’
[11:01:56.830]   - Field: ‘conditions’
[11:01:56.830]   - Field: ‘persistent’
[11:01:56.830]   - Field: ‘expr’
[11:01:56.831]   - Field: ‘uuid’
[11:01:56.831]   - Field: ‘seed’
[11:01:56.831]   - Field: ‘version’
[11:01:56.831]   - Field: ‘result’
[11:01:56.831]   - Field: ‘asynchronous’
[11:01:56.831]   - Field: ‘calls’
[11:01:56.831]   - Field: ‘globals’
[11:01:56.831]   - Field: ‘stdout’
[11:01:56.831]   - Field: ‘earlySignal’
[11:01:56.831]   - Field: ‘lazy’
[11:01:56.831]   - Field: ‘state’
[11:01:56.831] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.832] - Launch lazy future ...
[11:01:56.832] Packages needed by the future expression (n = 0): <none>
[11:01:56.832] Packages needed by future strategies (n = 0): <none>
[11:01:56.832] {
[11:01:56.832]     {
[11:01:56.832]         {
[11:01:56.832]             ...future.startTime <- base::Sys.time()
[11:01:56.832]             {
[11:01:56.832]                 {
[11:01:56.832]                   {
[11:01:56.832]                     {
[11:01:56.832]                       base::local({
[11:01:56.832]                         has_future <- base::requireNamespace("future", 
[11:01:56.832]                           quietly = TRUE)
[11:01:56.832]                         if (has_future) {
[11:01:56.832]                           ns <- base::getNamespace("future")
[11:01:56.832]                           version <- ns[[".package"]][["version"]]
[11:01:56.832]                           if (is.null(version)) 
[11:01:56.832]                             version <- utils::packageVersion("future")
[11:01:56.832]                         }
[11:01:56.832]                         else {
[11:01:56.832]                           version <- NULL
[11:01:56.832]                         }
[11:01:56.832]                         if (!has_future || version < "1.8.0") {
[11:01:56.832]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.832]                             "", base::R.version$version.string), 
[11:01:56.832]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:56.832]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:56.832]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.832]                               "release", "version")], collapse = " "), 
[11:01:56.832]                             hostname = base::Sys.info()[["nodename"]])
[11:01:56.832]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.832]                             info)
[11:01:56.832]                           info <- base::paste(info, collapse = "; ")
[11:01:56.832]                           if (!has_future) {
[11:01:56.832]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.832]                               info)
[11:01:56.832]                           }
[11:01:56.832]                           else {
[11:01:56.832]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.832]                               info, version)
[11:01:56.832]                           }
[11:01:56.832]                           base::stop(msg)
[11:01:56.832]                         }
[11:01:56.832]                       })
[11:01:56.832]                     }
[11:01:56.832]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.832]                     base::options(mc.cores = 1L)
[11:01:56.832]                   }
[11:01:56.832]                   ...future.strategy.old <- future::plan("list")
[11:01:56.832]                   options(future.plan = NULL)
[11:01:56.832]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.832]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.832]                 }
[11:01:56.832]                 ...future.workdir <- getwd()
[11:01:56.832]             }
[11:01:56.832]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.832]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.832]         }
[11:01:56.832]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.832]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.832]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.832]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.832]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.832]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.832]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.832]             base::names(...future.oldOptions))
[11:01:56.832]     }
[11:01:56.832]     if (FALSE) {
[11:01:56.832]     }
[11:01:56.832]     else {
[11:01:56.832]         if (TRUE) {
[11:01:56.832]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.832]                 open = "w")
[11:01:56.832]         }
[11:01:56.832]         else {
[11:01:56.832]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.832]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.832]         }
[11:01:56.832]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.832]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.832]             base::sink(type = "output", split = FALSE)
[11:01:56.832]             base::close(...future.stdout)
[11:01:56.832]         }, add = TRUE)
[11:01:56.832]     }
[11:01:56.832]     ...future.frame <- base::sys.nframe()
[11:01:56.832]     ...future.conditions <- base::list()
[11:01:56.832]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.832]     if (FALSE) {
[11:01:56.832]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.832]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.832]     }
[11:01:56.832]     ...future.result <- base::tryCatch({
[11:01:56.832]         base::withCallingHandlers({
[11:01:56.832]             ...future.value <- base::withVisible(base::local({
[11:01:56.832]                 ...future.makeSendCondition <- base::local({
[11:01:56.832]                   sendCondition <- NULL
[11:01:56.832]                   function(frame = 1L) {
[11:01:56.832]                     if (is.function(sendCondition)) 
[11:01:56.832]                       return(sendCondition)
[11:01:56.832]                     ns <- getNamespace("parallel")
[11:01:56.832]                     if (exists("sendData", mode = "function", 
[11:01:56.832]                       envir = ns)) {
[11:01:56.832]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.832]                         envir = ns)
[11:01:56.832]                       envir <- sys.frame(frame)
[11:01:56.832]                       master <- NULL
[11:01:56.832]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.832]                         !identical(envir, emptyenv())) {
[11:01:56.832]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.832]                           inherits = FALSE)) {
[11:01:56.832]                           master <- get("master", mode = "list", 
[11:01:56.832]                             envir = envir, inherits = FALSE)
[11:01:56.832]                           if (inherits(master, c("SOCKnode", 
[11:01:56.832]                             "SOCK0node"))) {
[11:01:56.832]                             sendCondition <<- function(cond) {
[11:01:56.832]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.832]                                 success = TRUE)
[11:01:56.832]                               parallel_sendData(master, data)
[11:01:56.832]                             }
[11:01:56.832]                             return(sendCondition)
[11:01:56.832]                           }
[11:01:56.832]                         }
[11:01:56.832]                         frame <- frame + 1L
[11:01:56.832]                         envir <- sys.frame(frame)
[11:01:56.832]                       }
[11:01:56.832]                     }
[11:01:56.832]                     sendCondition <<- function(cond) NULL
[11:01:56.832]                   }
[11:01:56.832]                 })
[11:01:56.832]                 withCallingHandlers({
[11:01:56.832]                   {
[11:01:56.832]                     x <- 0
[11:01:56.832]                     x <- x + 1
[11:01:56.832]                     x
[11:01:56.832]                   }
[11:01:56.832]                 }, immediateCondition = function(cond) {
[11:01:56.832]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.832]                   sendCondition(cond)
[11:01:56.832]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.832]                   {
[11:01:56.832]                     inherits <- base::inherits
[11:01:56.832]                     invokeRestart <- base::invokeRestart
[11:01:56.832]                     is.null <- base::is.null
[11:01:56.832]                     muffled <- FALSE
[11:01:56.832]                     if (inherits(cond, "message")) {
[11:01:56.832]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.832]                       if (muffled) 
[11:01:56.832]                         invokeRestart("muffleMessage")
[11:01:56.832]                     }
[11:01:56.832]                     else if (inherits(cond, "warning")) {
[11:01:56.832]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.832]                       if (muffled) 
[11:01:56.832]                         invokeRestart("muffleWarning")
[11:01:56.832]                     }
[11:01:56.832]                     else if (inherits(cond, "condition")) {
[11:01:56.832]                       if (!is.null(pattern)) {
[11:01:56.832]                         computeRestarts <- base::computeRestarts
[11:01:56.832]                         grepl <- base::grepl
[11:01:56.832]                         restarts <- computeRestarts(cond)
[11:01:56.832]                         for (restart in restarts) {
[11:01:56.832]                           name <- restart$name
[11:01:56.832]                           if (is.null(name)) 
[11:01:56.832]                             next
[11:01:56.832]                           if (!grepl(pattern, name)) 
[11:01:56.832]                             next
[11:01:56.832]                           invokeRestart(restart)
[11:01:56.832]                           muffled <- TRUE
[11:01:56.832]                           break
[11:01:56.832]                         }
[11:01:56.832]                       }
[11:01:56.832]                     }
[11:01:56.832]                     invisible(muffled)
[11:01:56.832]                   }
[11:01:56.832]                   muffleCondition(cond)
[11:01:56.832]                 })
[11:01:56.832]             }))
[11:01:56.832]             future::FutureResult(value = ...future.value$value, 
[11:01:56.832]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.832]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.832]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.832]                     ...future.globalenv.names))
[11:01:56.832]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.832]         }, condition = base::local({
[11:01:56.832]             c <- base::c
[11:01:56.832]             inherits <- base::inherits
[11:01:56.832]             invokeRestart <- base::invokeRestart
[11:01:56.832]             length <- base::length
[11:01:56.832]             list <- base::list
[11:01:56.832]             seq.int <- base::seq.int
[11:01:56.832]             signalCondition <- base::signalCondition
[11:01:56.832]             sys.calls <- base::sys.calls
[11:01:56.832]             `[[` <- base::`[[`
[11:01:56.832]             `+` <- base::`+`
[11:01:56.832]             `<<-` <- base::`<<-`
[11:01:56.832]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.832]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.832]                   3L)]
[11:01:56.832]             }
[11:01:56.832]             function(cond) {
[11:01:56.832]                 is_error <- inherits(cond, "error")
[11:01:56.832]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.832]                   NULL)
[11:01:56.832]                 if (is_error) {
[11:01:56.832]                   sessionInformation <- function() {
[11:01:56.832]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.832]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.832]                       search = base::search(), system = base::Sys.info())
[11:01:56.832]                   }
[11:01:56.832]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.832]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.832]                     cond$call), session = sessionInformation(), 
[11:01:56.832]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.832]                   signalCondition(cond)
[11:01:56.832]                 }
[11:01:56.832]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.832]                 "immediateCondition"))) {
[11:01:56.832]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.832]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.832]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.832]                   if (TRUE && !signal) {
[11:01:56.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.832]                     {
[11:01:56.832]                       inherits <- base::inherits
[11:01:56.832]                       invokeRestart <- base::invokeRestart
[11:01:56.832]                       is.null <- base::is.null
[11:01:56.832]                       muffled <- FALSE
[11:01:56.832]                       if (inherits(cond, "message")) {
[11:01:56.832]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.832]                         if (muffled) 
[11:01:56.832]                           invokeRestart("muffleMessage")
[11:01:56.832]                       }
[11:01:56.832]                       else if (inherits(cond, "warning")) {
[11:01:56.832]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.832]                         if (muffled) 
[11:01:56.832]                           invokeRestart("muffleWarning")
[11:01:56.832]                       }
[11:01:56.832]                       else if (inherits(cond, "condition")) {
[11:01:56.832]                         if (!is.null(pattern)) {
[11:01:56.832]                           computeRestarts <- base::computeRestarts
[11:01:56.832]                           grepl <- base::grepl
[11:01:56.832]                           restarts <- computeRestarts(cond)
[11:01:56.832]                           for (restart in restarts) {
[11:01:56.832]                             name <- restart$name
[11:01:56.832]                             if (is.null(name)) 
[11:01:56.832]                               next
[11:01:56.832]                             if (!grepl(pattern, name)) 
[11:01:56.832]                               next
[11:01:56.832]                             invokeRestart(restart)
[11:01:56.832]                             muffled <- TRUE
[11:01:56.832]                             break
[11:01:56.832]                           }
[11:01:56.832]                         }
[11:01:56.832]                       }
[11:01:56.832]                       invisible(muffled)
[11:01:56.832]                     }
[11:01:56.832]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.832]                   }
[11:01:56.832]                 }
[11:01:56.832]                 else {
[11:01:56.832]                   if (TRUE) {
[11:01:56.832]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.832]                     {
[11:01:56.832]                       inherits <- base::inherits
[11:01:56.832]                       invokeRestart <- base::invokeRestart
[11:01:56.832]                       is.null <- base::is.null
[11:01:56.832]                       muffled <- FALSE
[11:01:56.832]                       if (inherits(cond, "message")) {
[11:01:56.832]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.832]                         if (muffled) 
[11:01:56.832]                           invokeRestart("muffleMessage")
[11:01:56.832]                       }
[11:01:56.832]                       else if (inherits(cond, "warning")) {
[11:01:56.832]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.832]                         if (muffled) 
[11:01:56.832]                           invokeRestart("muffleWarning")
[11:01:56.832]                       }
[11:01:56.832]                       else if (inherits(cond, "condition")) {
[11:01:56.832]                         if (!is.null(pattern)) {
[11:01:56.832]                           computeRestarts <- base::computeRestarts
[11:01:56.832]                           grepl <- base::grepl
[11:01:56.832]                           restarts <- computeRestarts(cond)
[11:01:56.832]                           for (restart in restarts) {
[11:01:56.832]                             name <- restart$name
[11:01:56.832]                             if (is.null(name)) 
[11:01:56.832]                               next
[11:01:56.832]                             if (!grepl(pattern, name)) 
[11:01:56.832]                               next
[11:01:56.832]                             invokeRestart(restart)
[11:01:56.832]                             muffled <- TRUE
[11:01:56.832]                             break
[11:01:56.832]                           }
[11:01:56.832]                         }
[11:01:56.832]                       }
[11:01:56.832]                       invisible(muffled)
[11:01:56.832]                     }
[11:01:56.832]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.832]                   }
[11:01:56.832]                 }
[11:01:56.832]             }
[11:01:56.832]         }))
[11:01:56.832]     }, error = function(ex) {
[11:01:56.832]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.832]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.832]                 ...future.rng), started = ...future.startTime, 
[11:01:56.832]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.832]             version = "1.8"), class = "FutureResult")
[11:01:56.832]     }, finally = {
[11:01:56.832]         if (!identical(...future.workdir, getwd())) 
[11:01:56.832]             setwd(...future.workdir)
[11:01:56.832]         {
[11:01:56.832]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.832]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.832]             }
[11:01:56.832]             base::options(...future.oldOptions)
[11:01:56.832]             if (.Platform$OS.type == "windows") {
[11:01:56.832]                 old_names <- names(...future.oldEnvVars)
[11:01:56.832]                 envs <- base::Sys.getenv()
[11:01:56.832]                 names <- names(envs)
[11:01:56.832]                 common <- intersect(names, old_names)
[11:01:56.832]                 added <- setdiff(names, old_names)
[11:01:56.832]                 removed <- setdiff(old_names, names)
[11:01:56.832]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.832]                   envs[common]]
[11:01:56.832]                 NAMES <- toupper(changed)
[11:01:56.832]                 args <- list()
[11:01:56.832]                 for (kk in seq_along(NAMES)) {
[11:01:56.832]                   name <- changed[[kk]]
[11:01:56.832]                   NAME <- NAMES[[kk]]
[11:01:56.832]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.832]                     next
[11:01:56.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.832]                 }
[11:01:56.832]                 NAMES <- toupper(added)
[11:01:56.832]                 for (kk in seq_along(NAMES)) {
[11:01:56.832]                   name <- added[[kk]]
[11:01:56.832]                   NAME <- NAMES[[kk]]
[11:01:56.832]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.832]                     next
[11:01:56.832]                   args[[name]] <- ""
[11:01:56.832]                 }
[11:01:56.832]                 NAMES <- toupper(removed)
[11:01:56.832]                 for (kk in seq_along(NAMES)) {
[11:01:56.832]                   name <- removed[[kk]]
[11:01:56.832]                   NAME <- NAMES[[kk]]
[11:01:56.832]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.832]                     next
[11:01:56.832]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.832]                 }
[11:01:56.832]                 if (length(args) > 0) 
[11:01:56.832]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.832]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.832]             }
[11:01:56.832]             else {
[11:01:56.832]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.832]             }
[11:01:56.832]             {
[11:01:56.832]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.832]                   0L) {
[11:01:56.832]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.832]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.832]                   base::options(opts)
[11:01:56.832]                 }
[11:01:56.832]                 {
[11:01:56.832]                   {
[11:01:56.832]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.832]                     NULL
[11:01:56.832]                   }
[11:01:56.832]                   options(future.plan = NULL)
[11:01:56.832]                   if (is.na(NA_character_)) 
[11:01:56.832]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.832]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.832]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.832]                     .init = FALSE)
[11:01:56.832]                 }
[11:01:56.832]             }
[11:01:56.832]         }
[11:01:56.832]     })
[11:01:56.832]     if (TRUE) {
[11:01:56.832]         base::sink(type = "output", split = FALSE)
[11:01:56.832]         if (TRUE) {
[11:01:56.832]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.832]         }
[11:01:56.832]         else {
[11:01:56.832]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.832]         }
[11:01:56.832]         base::close(...future.stdout)
[11:01:56.832]         ...future.stdout <- NULL
[11:01:56.832]     }
[11:01:56.832]     ...future.result$conditions <- ...future.conditions
[11:01:56.832]     ...future.result$finished <- base::Sys.time()
[11:01:56.832]     ...future.result
[11:01:56.832] }
[11:01:56.835] MultisessionFuture started
[11:01:56.835] - Launch lazy future ... done
[11:01:56.835] run() for ‘MultisessionFuture’ ... done
[11:01:56.835] result() for ClusterFuture ...
[11:01:56.836] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.836] - Validating connection of MultisessionFuture
[11:01:56.877] - received message: FutureResult
[11:01:56.877] - Received FutureResult
[11:01:56.877] - Erased future from FutureRegistry
[11:01:56.877] result() for ClusterFuture ...
[11:01:56.877] - result already collected: FutureResult
[11:01:56.877] result() for ClusterFuture ... done
[11:01:56.877] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.877] result() for ClusterFuture ... done
[11:01:56.878] result() for ClusterFuture ...
[11:01:56.878] - result already collected: FutureResult
[11:01:56.878] result() for ClusterFuture ... done
value(f) = ‘1’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.878] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.878] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.880] - globals found: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[11:01:56.880] Searching for globals ... DONE
[11:01:56.880] Resolving globals: TRUE
[11:01:56.880] Resolving any globals that are futures ...
[11:01:56.880] - globals: [4] ‘{’, ‘<-’, ‘x’, ‘+’
[11:01:56.880] Resolving any globals that are futures ... DONE
[11:01:56.880] Resolving futures part of globals (recursively) ...
[11:01:56.881] resolve() on list ...
[11:01:56.881]  recursive: 99
[11:01:56.881]  length: 1
[11:01:56.881]  elements: ‘x’
[11:01:56.881]  length: 0 (resolved future 1)
[11:01:56.881] resolve() on list ... DONE
[11:01:56.881] - globals: [1] ‘x’
[11:01:56.881] Resolving futures part of globals (recursively) ... DONE
[11:01:56.881] The total size of the 1 globals is 39 bytes (39 bytes)
[11:01:56.882] The total size of the 1 globals exported for future expression (‘{; x <- x + 1; x; }’) is 39 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (39 bytes of class ‘numeric’)
[11:01:56.882] - globals: [1] ‘x’
[11:01:56.882] 
[11:01:56.882] getGlobalsAndPackages() ... DONE
[11:01:56.882] run() for ‘Future’ ...
[11:01:56.882] - state: ‘created’
[11:01:56.882] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.896] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.896] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.896]   - Field: ‘node’
[11:01:56.896]   - Field: ‘label’
[11:01:56.896]   - Field: ‘local’
[11:01:56.896]   - Field: ‘owner’
[11:01:56.896]   - Field: ‘envir’
[11:01:56.897]   - Field: ‘workers’
[11:01:56.897]   - Field: ‘packages’
[11:01:56.897]   - Field: ‘gc’
[11:01:56.897]   - Field: ‘conditions’
[11:01:56.897]   - Field: ‘persistent’
[11:01:56.897]   - Field: ‘expr’
[11:01:56.897]   - Field: ‘uuid’
[11:01:56.897]   - Field: ‘seed’
[11:01:56.897]   - Field: ‘version’
[11:01:56.897]   - Field: ‘result’
[11:01:56.897]   - Field: ‘asynchronous’
[11:01:56.897]   - Field: ‘calls’
[11:01:56.898]   - Field: ‘globals’
[11:01:56.900]   - Field: ‘stdout’
[11:01:56.900]   - Field: ‘earlySignal’
[11:01:56.900]   - Field: ‘lazy’
[11:01:56.900]   - Field: ‘state’
[11:01:56.900] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.900] - Launch lazy future ...
[11:01:56.900] Packages needed by the future expression (n = 0): <none>
[11:01:56.901] Packages needed by future strategies (n = 0): <none>
[11:01:56.901] {
[11:01:56.901]     {
[11:01:56.901]         {
[11:01:56.901]             ...future.startTime <- base::Sys.time()
[11:01:56.901]             {
[11:01:56.901]                 {
[11:01:56.901]                   {
[11:01:56.901]                     {
[11:01:56.901]                       base::local({
[11:01:56.901]                         has_future <- base::requireNamespace("future", 
[11:01:56.901]                           quietly = TRUE)
[11:01:56.901]                         if (has_future) {
[11:01:56.901]                           ns <- base::getNamespace("future")
[11:01:56.901]                           version <- ns[[".package"]][["version"]]
[11:01:56.901]                           if (is.null(version)) 
[11:01:56.901]                             version <- utils::packageVersion("future")
[11:01:56.901]                         }
[11:01:56.901]                         else {
[11:01:56.901]                           version <- NULL
[11:01:56.901]                         }
[11:01:56.901]                         if (!has_future || version < "1.8.0") {
[11:01:56.901]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.901]                             "", base::R.version$version.string), 
[11:01:56.901]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:56.901]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:56.901]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.901]                               "release", "version")], collapse = " "), 
[11:01:56.901]                             hostname = base::Sys.info()[["nodename"]])
[11:01:56.901]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.901]                             info)
[11:01:56.901]                           info <- base::paste(info, collapse = "; ")
[11:01:56.901]                           if (!has_future) {
[11:01:56.901]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.901]                               info)
[11:01:56.901]                           }
[11:01:56.901]                           else {
[11:01:56.901]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.901]                               info, version)
[11:01:56.901]                           }
[11:01:56.901]                           base::stop(msg)
[11:01:56.901]                         }
[11:01:56.901]                       })
[11:01:56.901]                     }
[11:01:56.901]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.901]                     base::options(mc.cores = 1L)
[11:01:56.901]                   }
[11:01:56.901]                   ...future.strategy.old <- future::plan("list")
[11:01:56.901]                   options(future.plan = NULL)
[11:01:56.901]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.901]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.901]                 }
[11:01:56.901]                 ...future.workdir <- getwd()
[11:01:56.901]             }
[11:01:56.901]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.901]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.901]         }
[11:01:56.901]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.901]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.901]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.901]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.901]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.901]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.901]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.901]             base::names(...future.oldOptions))
[11:01:56.901]     }
[11:01:56.901]     if (FALSE) {
[11:01:56.901]     }
[11:01:56.901]     else {
[11:01:56.901]         if (TRUE) {
[11:01:56.901]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.901]                 open = "w")
[11:01:56.901]         }
[11:01:56.901]         else {
[11:01:56.901]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.901]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.901]         }
[11:01:56.901]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.901]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.901]             base::sink(type = "output", split = FALSE)
[11:01:56.901]             base::close(...future.stdout)
[11:01:56.901]         }, add = TRUE)
[11:01:56.901]     }
[11:01:56.901]     ...future.frame <- base::sys.nframe()
[11:01:56.901]     ...future.conditions <- base::list()
[11:01:56.901]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.901]     if (FALSE) {
[11:01:56.901]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.901]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.901]     }
[11:01:56.901]     ...future.result <- base::tryCatch({
[11:01:56.901]         base::withCallingHandlers({
[11:01:56.901]             ...future.value <- base::withVisible(base::local({
[11:01:56.901]                 ...future.makeSendCondition <- base::local({
[11:01:56.901]                   sendCondition <- NULL
[11:01:56.901]                   function(frame = 1L) {
[11:01:56.901]                     if (is.function(sendCondition)) 
[11:01:56.901]                       return(sendCondition)
[11:01:56.901]                     ns <- getNamespace("parallel")
[11:01:56.901]                     if (exists("sendData", mode = "function", 
[11:01:56.901]                       envir = ns)) {
[11:01:56.901]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.901]                         envir = ns)
[11:01:56.901]                       envir <- sys.frame(frame)
[11:01:56.901]                       master <- NULL
[11:01:56.901]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.901]                         !identical(envir, emptyenv())) {
[11:01:56.901]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.901]                           inherits = FALSE)) {
[11:01:56.901]                           master <- get("master", mode = "list", 
[11:01:56.901]                             envir = envir, inherits = FALSE)
[11:01:56.901]                           if (inherits(master, c("SOCKnode", 
[11:01:56.901]                             "SOCK0node"))) {
[11:01:56.901]                             sendCondition <<- function(cond) {
[11:01:56.901]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.901]                                 success = TRUE)
[11:01:56.901]                               parallel_sendData(master, data)
[11:01:56.901]                             }
[11:01:56.901]                             return(sendCondition)
[11:01:56.901]                           }
[11:01:56.901]                         }
[11:01:56.901]                         frame <- frame + 1L
[11:01:56.901]                         envir <- sys.frame(frame)
[11:01:56.901]                       }
[11:01:56.901]                     }
[11:01:56.901]                     sendCondition <<- function(cond) NULL
[11:01:56.901]                   }
[11:01:56.901]                 })
[11:01:56.901]                 withCallingHandlers({
[11:01:56.901]                   {
[11:01:56.901]                     x <- x + 1
[11:01:56.901]                     x
[11:01:56.901]                   }
[11:01:56.901]                 }, immediateCondition = function(cond) {
[11:01:56.901]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.901]                   sendCondition(cond)
[11:01:56.901]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.901]                   {
[11:01:56.901]                     inherits <- base::inherits
[11:01:56.901]                     invokeRestart <- base::invokeRestart
[11:01:56.901]                     is.null <- base::is.null
[11:01:56.901]                     muffled <- FALSE
[11:01:56.901]                     if (inherits(cond, "message")) {
[11:01:56.901]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.901]                       if (muffled) 
[11:01:56.901]                         invokeRestart("muffleMessage")
[11:01:56.901]                     }
[11:01:56.901]                     else if (inherits(cond, "warning")) {
[11:01:56.901]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.901]                       if (muffled) 
[11:01:56.901]                         invokeRestart("muffleWarning")
[11:01:56.901]                     }
[11:01:56.901]                     else if (inherits(cond, "condition")) {
[11:01:56.901]                       if (!is.null(pattern)) {
[11:01:56.901]                         computeRestarts <- base::computeRestarts
[11:01:56.901]                         grepl <- base::grepl
[11:01:56.901]                         restarts <- computeRestarts(cond)
[11:01:56.901]                         for (restart in restarts) {
[11:01:56.901]                           name <- restart$name
[11:01:56.901]                           if (is.null(name)) 
[11:01:56.901]                             next
[11:01:56.901]                           if (!grepl(pattern, name)) 
[11:01:56.901]                             next
[11:01:56.901]                           invokeRestart(restart)
[11:01:56.901]                           muffled <- TRUE
[11:01:56.901]                           break
[11:01:56.901]                         }
[11:01:56.901]                       }
[11:01:56.901]                     }
[11:01:56.901]                     invisible(muffled)
[11:01:56.901]                   }
[11:01:56.901]                   muffleCondition(cond)
[11:01:56.901]                 })
[11:01:56.901]             }))
[11:01:56.901]             future::FutureResult(value = ...future.value$value, 
[11:01:56.901]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.901]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.901]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.901]                     ...future.globalenv.names))
[11:01:56.901]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.901]         }, condition = base::local({
[11:01:56.901]             c <- base::c
[11:01:56.901]             inherits <- base::inherits
[11:01:56.901]             invokeRestart <- base::invokeRestart
[11:01:56.901]             length <- base::length
[11:01:56.901]             list <- base::list
[11:01:56.901]             seq.int <- base::seq.int
[11:01:56.901]             signalCondition <- base::signalCondition
[11:01:56.901]             sys.calls <- base::sys.calls
[11:01:56.901]             `[[` <- base::`[[`
[11:01:56.901]             `+` <- base::`+`
[11:01:56.901]             `<<-` <- base::`<<-`
[11:01:56.901]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.901]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.901]                   3L)]
[11:01:56.901]             }
[11:01:56.901]             function(cond) {
[11:01:56.901]                 is_error <- inherits(cond, "error")
[11:01:56.901]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.901]                   NULL)
[11:01:56.901]                 if (is_error) {
[11:01:56.901]                   sessionInformation <- function() {
[11:01:56.901]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.901]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.901]                       search = base::search(), system = base::Sys.info())
[11:01:56.901]                   }
[11:01:56.901]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.901]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.901]                     cond$call), session = sessionInformation(), 
[11:01:56.901]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.901]                   signalCondition(cond)
[11:01:56.901]                 }
[11:01:56.901]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.901]                 "immediateCondition"))) {
[11:01:56.901]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.901]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.901]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.901]                   if (TRUE && !signal) {
[11:01:56.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.901]                     {
[11:01:56.901]                       inherits <- base::inherits
[11:01:56.901]                       invokeRestart <- base::invokeRestart
[11:01:56.901]                       is.null <- base::is.null
[11:01:56.901]                       muffled <- FALSE
[11:01:56.901]                       if (inherits(cond, "message")) {
[11:01:56.901]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.901]                         if (muffled) 
[11:01:56.901]                           invokeRestart("muffleMessage")
[11:01:56.901]                       }
[11:01:56.901]                       else if (inherits(cond, "warning")) {
[11:01:56.901]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.901]                         if (muffled) 
[11:01:56.901]                           invokeRestart("muffleWarning")
[11:01:56.901]                       }
[11:01:56.901]                       else if (inherits(cond, "condition")) {
[11:01:56.901]                         if (!is.null(pattern)) {
[11:01:56.901]                           computeRestarts <- base::computeRestarts
[11:01:56.901]                           grepl <- base::grepl
[11:01:56.901]                           restarts <- computeRestarts(cond)
[11:01:56.901]                           for (restart in restarts) {
[11:01:56.901]                             name <- restart$name
[11:01:56.901]                             if (is.null(name)) 
[11:01:56.901]                               next
[11:01:56.901]                             if (!grepl(pattern, name)) 
[11:01:56.901]                               next
[11:01:56.901]                             invokeRestart(restart)
[11:01:56.901]                             muffled <- TRUE
[11:01:56.901]                             break
[11:01:56.901]                           }
[11:01:56.901]                         }
[11:01:56.901]                       }
[11:01:56.901]                       invisible(muffled)
[11:01:56.901]                     }
[11:01:56.901]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.901]                   }
[11:01:56.901]                 }
[11:01:56.901]                 else {
[11:01:56.901]                   if (TRUE) {
[11:01:56.901]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.901]                     {
[11:01:56.901]                       inherits <- base::inherits
[11:01:56.901]                       invokeRestart <- base::invokeRestart
[11:01:56.901]                       is.null <- base::is.null
[11:01:56.901]                       muffled <- FALSE
[11:01:56.901]                       if (inherits(cond, "message")) {
[11:01:56.901]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.901]                         if (muffled) 
[11:01:56.901]                           invokeRestart("muffleMessage")
[11:01:56.901]                       }
[11:01:56.901]                       else if (inherits(cond, "warning")) {
[11:01:56.901]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.901]                         if (muffled) 
[11:01:56.901]                           invokeRestart("muffleWarning")
[11:01:56.901]                       }
[11:01:56.901]                       else if (inherits(cond, "condition")) {
[11:01:56.901]                         if (!is.null(pattern)) {
[11:01:56.901]                           computeRestarts <- base::computeRestarts
[11:01:56.901]                           grepl <- base::grepl
[11:01:56.901]                           restarts <- computeRestarts(cond)
[11:01:56.901]                           for (restart in restarts) {
[11:01:56.901]                             name <- restart$name
[11:01:56.901]                             if (is.null(name)) 
[11:01:56.901]                               next
[11:01:56.901]                             if (!grepl(pattern, name)) 
[11:01:56.901]                               next
[11:01:56.901]                             invokeRestart(restart)
[11:01:56.901]                             muffled <- TRUE
[11:01:56.901]                             break
[11:01:56.901]                           }
[11:01:56.901]                         }
[11:01:56.901]                       }
[11:01:56.901]                       invisible(muffled)
[11:01:56.901]                     }
[11:01:56.901]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.901]                   }
[11:01:56.901]                 }
[11:01:56.901]             }
[11:01:56.901]         }))
[11:01:56.901]     }, error = function(ex) {
[11:01:56.901]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.901]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.901]                 ...future.rng), started = ...future.startTime, 
[11:01:56.901]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.901]             version = "1.8"), class = "FutureResult")
[11:01:56.901]     }, finally = {
[11:01:56.901]         if (!identical(...future.workdir, getwd())) 
[11:01:56.901]             setwd(...future.workdir)
[11:01:56.901]         {
[11:01:56.901]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.901]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.901]             }
[11:01:56.901]             base::options(...future.oldOptions)
[11:01:56.901]             if (.Platform$OS.type == "windows") {
[11:01:56.901]                 old_names <- names(...future.oldEnvVars)
[11:01:56.901]                 envs <- base::Sys.getenv()
[11:01:56.901]                 names <- names(envs)
[11:01:56.901]                 common <- intersect(names, old_names)
[11:01:56.901]                 added <- setdiff(names, old_names)
[11:01:56.901]                 removed <- setdiff(old_names, names)
[11:01:56.901]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.901]                   envs[common]]
[11:01:56.901]                 NAMES <- toupper(changed)
[11:01:56.901]                 args <- list()
[11:01:56.901]                 for (kk in seq_along(NAMES)) {
[11:01:56.901]                   name <- changed[[kk]]
[11:01:56.901]                   NAME <- NAMES[[kk]]
[11:01:56.901]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.901]                     next
[11:01:56.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.901]                 }
[11:01:56.901]                 NAMES <- toupper(added)
[11:01:56.901]                 for (kk in seq_along(NAMES)) {
[11:01:56.901]                   name <- added[[kk]]
[11:01:56.901]                   NAME <- NAMES[[kk]]
[11:01:56.901]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.901]                     next
[11:01:56.901]                   args[[name]] <- ""
[11:01:56.901]                 }
[11:01:56.901]                 NAMES <- toupper(removed)
[11:01:56.901]                 for (kk in seq_along(NAMES)) {
[11:01:56.901]                   name <- removed[[kk]]
[11:01:56.901]                   NAME <- NAMES[[kk]]
[11:01:56.901]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.901]                     next
[11:01:56.901]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.901]                 }
[11:01:56.901]                 if (length(args) > 0) 
[11:01:56.901]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.901]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.901]             }
[11:01:56.901]             else {
[11:01:56.901]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.901]             }
[11:01:56.901]             {
[11:01:56.901]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.901]                   0L) {
[11:01:56.901]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.901]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.901]                   base::options(opts)
[11:01:56.901]                 }
[11:01:56.901]                 {
[11:01:56.901]                   {
[11:01:56.901]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.901]                     NULL
[11:01:56.901]                   }
[11:01:56.901]                   options(future.plan = NULL)
[11:01:56.901]                   if (is.na(NA_character_)) 
[11:01:56.901]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.901]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.901]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.901]                     .init = FALSE)
[11:01:56.901]                 }
[11:01:56.901]             }
[11:01:56.901]         }
[11:01:56.901]     })
[11:01:56.901]     if (TRUE) {
[11:01:56.901]         base::sink(type = "output", split = FALSE)
[11:01:56.901]         if (TRUE) {
[11:01:56.901]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.901]         }
[11:01:56.901]         else {
[11:01:56.901]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.901]         }
[11:01:56.901]         base::close(...future.stdout)
[11:01:56.901]         ...future.stdout <- NULL
[11:01:56.901]     }
[11:01:56.901]     ...future.result$conditions <- ...future.conditions
[11:01:56.901]     ...future.result$finished <- base::Sys.time()
[11:01:56.901]     ...future.result
[11:01:56.901] }
[11:01:56.903] Exporting 1 global objects (346 bytes) to cluster node #1 ...
[11:01:56.904] Exporting ‘x’ (39 bytes) to cluster node #1 ...
[11:01:56.904] Exporting ‘x’ (39 bytes) to cluster node #1 ... DONE
[11:01:56.904] Exporting 1 global objects (346 bytes) to cluster node #1 ... DONE
[11:01:56.904] MultisessionFuture started
[11:01:56.905] - Launch lazy future ... done
[11:01:56.905] run() for ‘MultisessionFuture’ ... done
[11:01:56.905] result() for ClusterFuture ...
[11:01:56.905] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.905] - Validating connection of MultisessionFuture
[11:01:56.946] - received message: FutureResult
[11:01:56.946] - Received FutureResult
[11:01:56.946] - Erased future from FutureRegistry
[11:01:56.946] result() for ClusterFuture ...
[11:01:56.946] - result already collected: FutureResult
[11:01:56.946] result() for ClusterFuture ... done
[11:01:56.947] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:56.947] result() for ClusterFuture ... done
[11:01:56.947] result() for ClusterFuture ...
[11:01:56.947] - result already collected: FutureResult
[11:01:56.947] result() for ClusterFuture ... done
value(f) = ‘2’
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.resolve’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘TRUE’
[11:01:56.947] getGlobalsAndPackages() ...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.onMissing’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘error’
[11:01:56.947] Searching for globals...
Warning in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,  :
  R option ‘future.globals.method’ may only be used for troubleshooting. It must not be used in production since it changes how futures are evaluated and there is a great risk that the results cannot be reproduced elsewhere: ‘ordered’
[11:01:56.949] - globals found: [3] ‘{’, ‘<-’, ‘x’
[11:01:56.949] Searching for globals ... DONE
[11:01:56.949] Resolving globals: TRUE
[11:01:56.949] Resolving any globals that are futures ...
[11:01:56.949] - globals: [3] ‘{’, ‘<-’, ‘x’
[11:01:56.949] Resolving any globals that are futures ... DONE
[11:01:56.950] Resolving futures part of globals (recursively) ...
[11:01:56.950] resolve() on list ...
[11:01:56.950]  recursive: 99
[11:01:56.950]  length: 1
[11:01:56.950]  elements: ‘x’
[11:01:56.950]  length: 0 (resolved future 1)
[11:01:56.950] resolve() on list ... DONE
[11:01:56.950] - globals: [1] ‘x’
[11:01:56.950] Resolving futures part of globals (recursively) ... DONE
[11:01:56.951] The total size of the 1 globals is 260 bytes (260 bytes)
[11:01:56.951] The total size of the 1 globals exported for future expression (‘{; x <- x(); x; }’) is 260 bytes.. This exceeds the maximum allowed size of 500.00 MiB (option 'future.globals.maxSize'). There is one global: ‘x’ (260 bytes of class ‘function’)
[11:01:56.951] - globals: [1] ‘x’
[11:01:56.951] 
[11:01:56.951] getGlobalsAndPackages() ... DONE
[11:01:56.951] run() for ‘Future’ ...
[11:01:56.951] - state: ‘created’
[11:01:56.952] - Future backend: ‘FutureStrategy’, ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’
[11:01:56.965] - Future class: ‘MultisessionFuture’, ‘ClusterFuture’, ‘MultiprocessFuture’, ‘Future’, ‘environment’
[11:01:56.965] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ...
[11:01:56.965]   - Field: ‘node’
[11:01:56.965]   - Field: ‘label’
[11:01:56.966]   - Field: ‘local’
[11:01:56.966]   - Field: ‘owner’
[11:01:56.966]   - Field: ‘envir’
[11:01:56.966]   - Field: ‘workers’
[11:01:56.966]   - Field: ‘packages’
[11:01:56.966]   - Field: ‘gc’
[11:01:56.966]   - Field: ‘conditions’
[11:01:56.966]   - Field: ‘persistent’
[11:01:56.966]   - Field: ‘expr’
[11:01:56.966]   - Field: ‘uuid’
[11:01:56.966]   - Field: ‘seed’
[11:01:56.966]   - Field: ‘version’
[11:01:56.967]   - Field: ‘result’
[11:01:56.967]   - Field: ‘asynchronous’
[11:01:56.967]   - Field: ‘calls’
[11:01:56.967]   - Field: ‘globals’
[11:01:56.967]   - Field: ‘stdout’
[11:01:56.967]   - Field: ‘earlySignal’
[11:01:56.967]   - Field: ‘lazy’
[11:01:56.967]   - Field: ‘state’
[11:01:56.967] - Copy elements of temporary ‘MultisessionFuture’ to final ‘Future’ object ... done
[11:01:56.967] - Launch lazy future ...
[11:01:56.967] Packages needed by the future expression (n = 0): <none>
[11:01:56.968] Packages needed by future strategies (n = 0): <none>
[11:01:56.968] {
[11:01:56.968]     {
[11:01:56.968]         {
[11:01:56.968]             ...future.startTime <- base::Sys.time()
[11:01:56.968]             {
[11:01:56.968]                 {
[11:01:56.968]                   {
[11:01:56.968]                     {
[11:01:56.968]                       base::local({
[11:01:56.968]                         has_future <- base::requireNamespace("future", 
[11:01:56.968]                           quietly = TRUE)
[11:01:56.968]                         if (has_future) {
[11:01:56.968]                           ns <- base::getNamespace("future")
[11:01:56.968]                           version <- ns[[".package"]][["version"]]
[11:01:56.968]                           if (is.null(version)) 
[11:01:56.968]                             version <- utils::packageVersion("future")
[11:01:56.968]                         }
[11:01:56.968]                         else {
[11:01:56.968]                           version <- NULL
[11:01:56.968]                         }
[11:01:56.968]                         if (!has_future || version < "1.8.0") {
[11:01:56.968]                           info <- base::c(r_version = base::gsub("R version ", 
[11:01:56.968]                             "", base::R.version$version.string), 
[11:01:56.968]                             platform = base::sprintf("%s (%s-bit)", 
[11:01:56.968]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[11:01:56.968]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[11:01:56.968]                               "release", "version")], collapse = " "), 
[11:01:56.968]                             hostname = base::Sys.info()[["nodename"]])
[11:01:56.968]                           info <- base::sprintf("%s: %s", base::names(info), 
[11:01:56.968]                             info)
[11:01:56.968]                           info <- base::paste(info, collapse = "; ")
[11:01:56.968]                           if (!has_future) {
[11:01:56.968]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[11:01:56.968]                               info)
[11:01:56.968]                           }
[11:01:56.968]                           else {
[11:01:56.968]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[11:01:56.968]                               info, version)
[11:01:56.968]                           }
[11:01:56.968]                           base::stop(msg)
[11:01:56.968]                         }
[11:01:56.968]                       })
[11:01:56.968]                     }
[11:01:56.968]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[11:01:56.968]                     base::options(mc.cores = 1L)
[11:01:56.968]                   }
[11:01:56.968]                   ...future.strategy.old <- future::plan("list")
[11:01:56.968]                   options(future.plan = NULL)
[11:01:56.968]                   Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.968]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[11:01:56.968]                 }
[11:01:56.968]                 ...future.workdir <- getwd()
[11:01:56.968]             }
[11:01:56.968]             ...future.oldOptions <- base::as.list(base::.Options)
[11:01:56.968]             ...future.oldEnvVars <- base::Sys.getenv()
[11:01:56.968]         }
[11:01:56.968]         base::options(future.startup.script = FALSE, future.globals.onMissing = "error", 
[11:01:56.968]             future.globals.maxSize = NULL, future.globals.method = "ordered", 
[11:01:56.968]             future.globals.onMissing = "error", future.globals.onReference = NULL, 
[11:01:56.968]             future.globals.resolve = TRUE, future.resolve.recursive = NULL, 
[11:01:56.968]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[11:01:56.968]             future.stdout.windows.reencode = NULL, width = 80L)
[11:01:56.968]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[11:01:56.968]             base::names(...future.oldOptions))
[11:01:56.968]     }
[11:01:56.968]     if (FALSE) {
[11:01:56.968]     }
[11:01:56.968]     else {
[11:01:56.968]         if (TRUE) {
[11:01:56.968]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[11:01:56.968]                 open = "w")
[11:01:56.968]         }
[11:01:56.968]         else {
[11:01:56.968]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[11:01:56.968]                 windows = "NUL", "/dev/null"), open = "w")
[11:01:56.968]         }
[11:01:56.968]         base::sink(...future.stdout, type = "output", split = FALSE)
[11:01:56.968]         base::on.exit(if (!base::is.null(...future.stdout)) {
[11:01:56.968]             base::sink(type = "output", split = FALSE)
[11:01:56.968]             base::close(...future.stdout)
[11:01:56.968]         }, add = TRUE)
[11:01:56.968]     }
[11:01:56.968]     ...future.frame <- base::sys.nframe()
[11:01:56.968]     ...future.conditions <- base::list()
[11:01:56.968]     ...future.rng <- base::globalenv()$.Random.seed
[11:01:56.968]     if (FALSE) {
[11:01:56.968]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[11:01:56.968]             "...future.value", "...future.globalenv.names", ".Random.seed")
[11:01:56.968]     }
[11:01:56.968]     ...future.result <- base::tryCatch({
[11:01:56.968]         base::withCallingHandlers({
[11:01:56.968]             ...future.value <- base::withVisible(base::local({
[11:01:56.968]                 ...future.makeSendCondition <- base::local({
[11:01:56.968]                   sendCondition <- NULL
[11:01:56.968]                   function(frame = 1L) {
[11:01:56.968]                     if (is.function(sendCondition)) 
[11:01:56.968]                       return(sendCondition)
[11:01:56.968]                     ns <- getNamespace("parallel")
[11:01:56.968]                     if (exists("sendData", mode = "function", 
[11:01:56.968]                       envir = ns)) {
[11:01:56.968]                       parallel_sendData <- get("sendData", mode = "function", 
[11:01:56.968]                         envir = ns)
[11:01:56.968]                       envir <- sys.frame(frame)
[11:01:56.968]                       master <- NULL
[11:01:56.968]                       while (!identical(envir, .GlobalEnv) && 
[11:01:56.968]                         !identical(envir, emptyenv())) {
[11:01:56.968]                         if (exists("master", mode = "list", envir = envir, 
[11:01:56.968]                           inherits = FALSE)) {
[11:01:56.968]                           master <- get("master", mode = "list", 
[11:01:56.968]                             envir = envir, inherits = FALSE)
[11:01:56.968]                           if (inherits(master, c("SOCKnode", 
[11:01:56.968]                             "SOCK0node"))) {
[11:01:56.968]                             sendCondition <<- function(cond) {
[11:01:56.968]                               data <- list(type = "VALUE", value = cond, 
[11:01:56.968]                                 success = TRUE)
[11:01:56.968]                               parallel_sendData(master, data)
[11:01:56.968]                             }
[11:01:56.968]                             return(sendCondition)
[11:01:56.968]                           }
[11:01:56.968]                         }
[11:01:56.968]                         frame <- frame + 1L
[11:01:56.968]                         envir <- sys.frame(frame)
[11:01:56.968]                       }
[11:01:56.968]                     }
[11:01:56.968]                     sendCondition <<- function(cond) NULL
[11:01:56.968]                   }
[11:01:56.968]                 })
[11:01:56.968]                 withCallingHandlers({
[11:01:56.968]                   {
[11:01:56.968]                     x <- x()
[11:01:56.968]                     x
[11:01:56.968]                   }
[11:01:56.968]                 }, immediateCondition = function(cond) {
[11:01:56.968]                   sendCondition <- ...future.makeSendCondition()
[11:01:56.968]                   sendCondition(cond)
[11:01:56.968]                   muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.968]                   {
[11:01:56.968]                     inherits <- base::inherits
[11:01:56.968]                     invokeRestart <- base::invokeRestart
[11:01:56.968]                     is.null <- base::is.null
[11:01:56.968]                     muffled <- FALSE
[11:01:56.968]                     if (inherits(cond, "message")) {
[11:01:56.968]                       muffled <- grepl(pattern, "muffleMessage")
[11:01:56.968]                       if (muffled) 
[11:01:56.968]                         invokeRestart("muffleMessage")
[11:01:56.968]                     }
[11:01:56.968]                     else if (inherits(cond, "warning")) {
[11:01:56.968]                       muffled <- grepl(pattern, "muffleWarning")
[11:01:56.968]                       if (muffled) 
[11:01:56.968]                         invokeRestart("muffleWarning")
[11:01:56.968]                     }
[11:01:56.968]                     else if (inherits(cond, "condition")) {
[11:01:56.968]                       if (!is.null(pattern)) {
[11:01:56.968]                         computeRestarts <- base::computeRestarts
[11:01:56.968]                         grepl <- base::grepl
[11:01:56.968]                         restarts <- computeRestarts(cond)
[11:01:56.968]                         for (restart in restarts) {
[11:01:56.968]                           name <- restart$name
[11:01:56.968]                           if (is.null(name)) 
[11:01:56.968]                             next
[11:01:56.968]                           if (!grepl(pattern, name)) 
[11:01:56.968]                             next
[11:01:56.968]                           invokeRestart(restart)
[11:01:56.968]                           muffled <- TRUE
[11:01:56.968]                           break
[11:01:56.968]                         }
[11:01:56.968]                       }
[11:01:56.968]                     }
[11:01:56.968]                     invisible(muffled)
[11:01:56.968]                   }
[11:01:56.968]                   muffleCondition(cond)
[11:01:56.968]                 })
[11:01:56.968]             }))
[11:01:56.968]             future::FutureResult(value = ...future.value$value, 
[11:01:56.968]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.968]                   ...future.rng), globalenv = if (FALSE) 
[11:01:56.968]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[11:01:56.968]                     ...future.globalenv.names))
[11:01:56.968]                 else NULL, started = ...future.startTime, version = "1.8")
[11:01:56.968]         }, condition = base::local({
[11:01:56.968]             c <- base::c
[11:01:56.968]             inherits <- base::inherits
[11:01:56.968]             invokeRestart <- base::invokeRestart
[11:01:56.968]             length <- base::length
[11:01:56.968]             list <- base::list
[11:01:56.968]             seq.int <- base::seq.int
[11:01:56.968]             signalCondition <- base::signalCondition
[11:01:56.968]             sys.calls <- base::sys.calls
[11:01:56.968]             `[[` <- base::`[[`
[11:01:56.968]             `+` <- base::`+`
[11:01:56.968]             `<<-` <- base::`<<-`
[11:01:56.968]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[11:01:56.968]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[11:01:56.968]                   3L)]
[11:01:56.968]             }
[11:01:56.968]             function(cond) {
[11:01:56.968]                 is_error <- inherits(cond, "error")
[11:01:56.968]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[11:01:56.968]                   NULL)
[11:01:56.968]                 if (is_error) {
[11:01:56.968]                   sessionInformation <- function() {
[11:01:56.968]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[11:01:56.968]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[11:01:56.968]                       search = base::search(), system = base::Sys.info())
[11:01:56.968]                   }
[11:01:56.968]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.968]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[11:01:56.968]                     cond$call), session = sessionInformation(), 
[11:01:56.968]                     timestamp = base::Sys.time(), signaled = 0L)
[11:01:56.968]                   signalCondition(cond)
[11:01:56.968]                 }
[11:01:56.968]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[11:01:56.968]                 "immediateCondition"))) {
[11:01:56.968]                   signal <- TRUE && inherits(cond, "immediateCondition")
[11:01:56.968]                   ...future.conditions[[length(...future.conditions) + 
[11:01:56.968]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[11:01:56.968]                   if (TRUE && !signal) {
[11:01:56.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.968]                     {
[11:01:56.968]                       inherits <- base::inherits
[11:01:56.968]                       invokeRestart <- base::invokeRestart
[11:01:56.968]                       is.null <- base::is.null
[11:01:56.968]                       muffled <- FALSE
[11:01:56.968]                       if (inherits(cond, "message")) {
[11:01:56.968]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.968]                         if (muffled) 
[11:01:56.968]                           invokeRestart("muffleMessage")
[11:01:56.968]                       }
[11:01:56.968]                       else if (inherits(cond, "warning")) {
[11:01:56.968]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.968]                         if (muffled) 
[11:01:56.968]                           invokeRestart("muffleWarning")
[11:01:56.968]                       }
[11:01:56.968]                       else if (inherits(cond, "condition")) {
[11:01:56.968]                         if (!is.null(pattern)) {
[11:01:56.968]                           computeRestarts <- base::computeRestarts
[11:01:56.968]                           grepl <- base::grepl
[11:01:56.968]                           restarts <- computeRestarts(cond)
[11:01:56.968]                           for (restart in restarts) {
[11:01:56.968]                             name <- restart$name
[11:01:56.968]                             if (is.null(name)) 
[11:01:56.968]                               next
[11:01:56.968]                             if (!grepl(pattern, name)) 
[11:01:56.968]                               next
[11:01:56.968]                             invokeRestart(restart)
[11:01:56.968]                             muffled <- TRUE
[11:01:56.968]                             break
[11:01:56.968]                           }
[11:01:56.968]                         }
[11:01:56.968]                       }
[11:01:56.968]                       invisible(muffled)
[11:01:56.968]                     }
[11:01:56.968]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.968]                   }
[11:01:56.968]                 }
[11:01:56.968]                 else {
[11:01:56.968]                   if (TRUE) {
[11:01:56.968]                     muffleCondition <- function (cond, pattern = "^muffle") 
[11:01:56.968]                     {
[11:01:56.968]                       inherits <- base::inherits
[11:01:56.968]                       invokeRestart <- base::invokeRestart
[11:01:56.968]                       is.null <- base::is.null
[11:01:56.968]                       muffled <- FALSE
[11:01:56.968]                       if (inherits(cond, "message")) {
[11:01:56.968]                         muffled <- grepl(pattern, "muffleMessage")
[11:01:56.968]                         if (muffled) 
[11:01:56.968]                           invokeRestart("muffleMessage")
[11:01:56.968]                       }
[11:01:56.968]                       else if (inherits(cond, "warning")) {
[11:01:56.968]                         muffled <- grepl(pattern, "muffleWarning")
[11:01:56.968]                         if (muffled) 
[11:01:56.968]                           invokeRestart("muffleWarning")
[11:01:56.968]                       }
[11:01:56.968]                       else if (inherits(cond, "condition")) {
[11:01:56.968]                         if (!is.null(pattern)) {
[11:01:56.968]                           computeRestarts <- base::computeRestarts
[11:01:56.968]                           grepl <- base::grepl
[11:01:56.968]                           restarts <- computeRestarts(cond)
[11:01:56.968]                           for (restart in restarts) {
[11:01:56.968]                             name <- restart$name
[11:01:56.968]                             if (is.null(name)) 
[11:01:56.968]                               next
[11:01:56.968]                             if (!grepl(pattern, name)) 
[11:01:56.968]                               next
[11:01:56.968]                             invokeRestart(restart)
[11:01:56.968]                             muffled <- TRUE
[11:01:56.968]                             break
[11:01:56.968]                           }
[11:01:56.968]                         }
[11:01:56.968]                       }
[11:01:56.968]                       invisible(muffled)
[11:01:56.968]                     }
[11:01:56.968]                     muffleCondition(cond, pattern = "^muffle")
[11:01:56.968]                   }
[11:01:56.968]                 }
[11:01:56.968]             }
[11:01:56.968]         }))
[11:01:56.968]     }, error = function(ex) {
[11:01:56.968]         base::structure(base::list(value = NULL, visible = NULL, 
[11:01:56.968]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[11:01:56.968]                 ...future.rng), started = ...future.startTime, 
[11:01:56.968]             finished = Sys.time(), session_uuid = NA_character_, 
[11:01:56.968]             version = "1.8"), class = "FutureResult")
[11:01:56.968]     }, finally = {
[11:01:56.968]         if (!identical(...future.workdir, getwd())) 
[11:01:56.968]             setwd(...future.workdir)
[11:01:56.968]         {
[11:01:56.968]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[11:01:56.968]                 ...future.oldOptions$nwarnings <- NULL
[11:01:56.968]             }
[11:01:56.968]             base::options(...future.oldOptions)
[11:01:56.968]             if (.Platform$OS.type == "windows") {
[11:01:56.968]                 old_names <- names(...future.oldEnvVars)
[11:01:56.968]                 envs <- base::Sys.getenv()
[11:01:56.968]                 names <- names(envs)
[11:01:56.968]                 common <- intersect(names, old_names)
[11:01:56.968]                 added <- setdiff(names, old_names)
[11:01:56.968]                 removed <- setdiff(old_names, names)
[11:01:56.968]                 changed <- common[...future.oldEnvVars[common] != 
[11:01:56.968]                   envs[common]]
[11:01:56.968]                 NAMES <- toupper(changed)
[11:01:56.968]                 args <- list()
[11:01:56.968]                 for (kk in seq_along(NAMES)) {
[11:01:56.968]                   name <- changed[[kk]]
[11:01:56.968]                   NAME <- NAMES[[kk]]
[11:01:56.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.968]                     next
[11:01:56.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.968]                 }
[11:01:56.968]                 NAMES <- toupper(added)
[11:01:56.968]                 for (kk in seq_along(NAMES)) {
[11:01:56.968]                   name <- added[[kk]]
[11:01:56.968]                   NAME <- NAMES[[kk]]
[11:01:56.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.968]                     next
[11:01:56.968]                   args[[name]] <- ""
[11:01:56.968]                 }
[11:01:56.968]                 NAMES <- toupper(removed)
[11:01:56.968]                 for (kk in seq_along(NAMES)) {
[11:01:56.968]                   name <- removed[[kk]]
[11:01:56.968]                   NAME <- NAMES[[kk]]
[11:01:56.968]                   if (name != NAME && is.element(NAME, old_names)) 
[11:01:56.968]                     next
[11:01:56.968]                   args[[name]] <- ...future.oldEnvVars[[name]]
[11:01:56.968]                 }
[11:01:56.968]                 if (length(args) > 0) 
[11:01:56.968]                   base::do.call(base::Sys.setenv, args = args)
[11:01:56.968]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[11:01:56.968]             }
[11:01:56.968]             else {
[11:01:56.968]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[11:01:56.968]             }
[11:01:56.968]             {
[11:01:56.968]                 if (base::length(...future.futureOptionsAdded) > 
[11:01:56.968]                   0L) {
[11:01:56.968]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[11:01:56.968]                   base::names(opts) <- ...future.futureOptionsAdded
[11:01:56.968]                   base::options(opts)
[11:01:56.968]                 }
[11:01:56.968]                 {
[11:01:56.968]                   {
[11:01:56.968]                     base::options(mc.cores = ...future.mc.cores.old)
[11:01:56.968]                     NULL
[11:01:56.968]                   }
[11:01:56.968]                   options(future.plan = NULL)
[11:01:56.968]                   if (is.na(NA_character_)) 
[11:01:56.968]                     Sys.unsetenv("R_FUTURE_PLAN")
[11:01:56.968]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[11:01:56.968]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[11:01:56.968]                     .init = FALSE)
[11:01:56.968]                 }
[11:01:56.968]             }
[11:01:56.968]         }
[11:01:56.968]     })
[11:01:56.968]     if (TRUE) {
[11:01:56.968]         base::sink(type = "output", split = FALSE)
[11:01:56.968]         if (TRUE) {
[11:01:56.968]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[11:01:56.968]         }
[11:01:56.968]         else {
[11:01:56.968]             ...future.result["stdout"] <- base::list(NULL)
[11:01:56.968]         }
[11:01:56.968]         base::close(...future.stdout)
[11:01:56.968]         ...future.stdout <- NULL
[11:01:56.968]     }
[11:01:56.968]     ...future.result$conditions <- ...future.conditions
[11:01:56.968]     ...future.result$finished <- base::Sys.time()
[11:01:56.968]     ...future.result
[11:01:56.968] }
[11:01:56.970] Exporting 1 global objects (554 bytes) to cluster node #1 ...
[11:01:56.971] Exporting ‘x’ (260 bytes) to cluster node #1 ...
[11:01:56.971] Exporting ‘x’ (260 bytes) to cluster node #1 ... DONE
[11:01:56.971] Exporting 1 global objects (554 bytes) to cluster node #1 ... DONE
[11:01:56.971] MultisessionFuture started
[11:01:56.972] - Launch lazy future ... done
[11:01:56.972] run() for ‘MultisessionFuture’ ... done
[11:01:56.972] result() for ClusterFuture ...
[11:01:56.972] receiveMessageFromWorker() for ClusterFuture ...
[11:01:56.972] - Validating connection of MultisessionFuture
[11:01:57.013] - received message: FutureResult
[11:01:57.013] - Received FutureResult
[11:01:57.013] - Erased future from FutureRegistry
[11:01:57.013] result() for ClusterFuture ...
[11:01:57.013] - result already collected: FutureResult
[11:01:57.013] result() for ClusterFuture ... done
[11:01:57.013] receiveMessageFromWorker() for ClusterFuture ... done
[11:01:57.013] result() for ClusterFuture ... done
[11:01:57.013] result() for ClusterFuture ...
[11:01:57.013] - result already collected: FutureResult
[11:01:57.014] result() for ClusterFuture ... done
value(f) = ‘TRUE’
Testing with 2 cores ... DONE
> 
> message("*** Tricky use cases related to globals ... DONE")
*** Tricky use cases related to globals ... DONE
> 
> source("incl/end.R")
[11:01:57.014] plan(): Setting new future strategy stack:
[11:01:57.014] List of future strategies:
[11:01:57.014] 1. FutureStrategy:
[11:01:57.014]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[11:01:57.014]    - tweaked: FALSE
[11:01:57.014]    - call: future::plan(oplan)
[11:01:57.015] plan(): nbrOfWorkers() = 1
> 
