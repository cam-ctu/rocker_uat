
R version 4.4.3 (2025-02-28) -- "Trophy Case"
Copyright (C) 2025 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> source("incl/start.R")
[10:21:40.688] plan(): Setting new future strategy stack:
[10:21:40.689] List of future strategies:
[10:21:40.689] 1. sequential:
[10:21:40.689]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:40.689]    - tweaked: FALSE
[10:21:40.689]    - call: future::plan("sequential")
[10:21:40.703] plan(): nbrOfWorkers() = 1
> library("listenv")
> 
> message("*** Globals - too large ...")
*** Globals - too large ...
> 
> a <- integer(length = 1000)
> ooptsT <- options(future.globals.maxSize = object.size(a) - 100L)
> limit <- getOption("future.globals.maxSize")
> cat(sprintf("Max total size of globals: %g bytes\n", limit))
Max total size of globals: 3948 bytes
> 
> plan(multisession)
[10:21:40.721] plan(): Setting new future strategy stack:
[10:21:40.721] List of future strategies:
[10:21:40.721] 1. multisession:
[10:21:40.721]    - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:40.721]    - tweaked: FALSE
[10:21:40.721]    - call: plan(multisession)
[10:21:40.732] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ...
[10:21:40.732] multisession:
[10:21:40.732] - args: function (..., workers = availableCores(), lazy = FALSE, rscript_libs = .libPaths(), envir = parent.frame())
[10:21:40.732] - tweaked: FALSE
[10:21:40.732] - call: plan(multisession)
[10:21:40.736] getGlobalsAndPackages() ...
[10:21:40.736] Not searching for globals
[10:21:40.737] - globals: [0] <none>
[10:21:40.737] getGlobalsAndPackages() ... DONE
[10:21:41.208] Packages needed by the future expression (n = 0): <none>
[10:21:41.208] Packages needed by future strategies (n = 0): <none>
[10:21:41.208] {
[10:21:41.208]     {
[10:21:41.208]         {
[10:21:41.208]             ...future.startTime <- base::Sys.time()
[10:21:41.208]             {
[10:21:41.208]                 {
[10:21:41.208]                   {
[10:21:41.208]                     {
[10:21:41.208]                       base::local({
[10:21:41.208]                         has_future <- base::requireNamespace("future", 
[10:21:41.208]                           quietly = TRUE)
[10:21:41.208]                         if (has_future) {
[10:21:41.208]                           ns <- base::getNamespace("future")
[10:21:41.208]                           version <- ns[[".package"]][["version"]]
[10:21:41.208]                           if (is.null(version)) 
[10:21:41.208]                             version <- utils::packageVersion("future")
[10:21:41.208]                         }
[10:21:41.208]                         else {
[10:21:41.208]                           version <- NULL
[10:21:41.208]                         }
[10:21:41.208]                         if (!has_future || version < "1.8.0") {
[10:21:41.208]                           info <- base::c(r_version = base::gsub("R version ", 
[10:21:41.208]                             "", base::R.version$version.string), 
[10:21:41.208]                             platform = base::sprintf("%s (%s-bit)", 
[10:21:41.208]                               base::R.version$platform, 8 * base::.Machine$sizeof.pointer), 
[10:21:41.208]                             os = base::paste(base::Sys.info()[base::c("sysname", 
[10:21:41.208]                               "release", "version")], collapse = " "), 
[10:21:41.208]                             hostname = base::Sys.info()[["nodename"]])
[10:21:41.208]                           info <- base::sprintf("%s: %s", base::names(info), 
[10:21:41.208]                             info)
[10:21:41.208]                           info <- base::paste(info, collapse = "; ")
[10:21:41.208]                           if (!has_future) {
[10:21:41.208]                             msg <- base::sprintf("Package 'future' is not installed on worker (%s)", 
[10:21:41.208]                               info)
[10:21:41.208]                           }
[10:21:41.208]                           else {
[10:21:41.208]                             msg <- base::sprintf("Package 'future' on worker (%s) must be of version >= 1.8.0: %s", 
[10:21:41.208]                               info, version)
[10:21:41.208]                           }
[10:21:41.208]                           base::stop(msg)
[10:21:41.208]                         }
[10:21:41.208]                       })
[10:21:41.208]                     }
[10:21:41.208]                     ...future.mc.cores.old <- base::getOption("mc.cores")
[10:21:41.208]                     base::options(mc.cores = 1L)
[10:21:41.208]                   }
[10:21:41.208]                   ...future.strategy.old <- future::plan("list")
[10:21:41.208]                   options(future.plan = NULL)
[10:21:41.208]                   Sys.unsetenv("R_FUTURE_PLAN")
[10:21:41.208]                   future::plan("default", .cleanup = FALSE, .init = FALSE)
[10:21:41.208]                 }
[10:21:41.208]                 ...future.workdir <- getwd()
[10:21:41.208]             }
[10:21:41.208]             ...future.oldOptions <- base::as.list(base::.Options)
[10:21:41.208]             ...future.oldEnvVars <- base::Sys.getenv()
[10:21:41.208]         }
[10:21:41.208]         base::options(future.startup.script = FALSE, future.globals.onMissing = NULL, 
[10:21:41.208]             future.globals.maxSize = 3948, future.globals.method = NULL, 
[10:21:41.208]             future.globals.onMissing = NULL, future.globals.onReference = NULL, 
[10:21:41.208]             future.globals.resolve = NULL, future.resolve.recursive = NULL, 
[10:21:41.208]             future.rng.onMisuse = NULL, future.rng.onMisuse.keepFuture = NULL, 
[10:21:41.208]             future.stdout.windows.reencode = NULL, width = 80L)
[10:21:41.208]         ...future.futureOptionsAdded <- base::setdiff(base::names(base::.Options), 
[10:21:41.208]             base::names(...future.oldOptions))
[10:21:41.208]     }
[10:21:41.208]     if (FALSE) {
[10:21:41.208]     }
[10:21:41.208]     else {
[10:21:41.208]         if (TRUE) {
[10:21:41.208]             ...future.stdout <- base::rawConnection(base::raw(0L), 
[10:21:41.208]                 open = "w")
[10:21:41.208]         }
[10:21:41.208]         else {
[10:21:41.208]             ...future.stdout <- base::file(base::switch(.Platform$OS.type, 
[10:21:41.208]                 windows = "NUL", "/dev/null"), open = "w")
[10:21:41.208]         }
[10:21:41.208]         base::sink(...future.stdout, type = "output", split = FALSE)
[10:21:41.208]         base::on.exit(if (!base::is.null(...future.stdout)) {
[10:21:41.208]             base::sink(type = "output", split = FALSE)
[10:21:41.208]             base::close(...future.stdout)
[10:21:41.208]         }, add = TRUE)
[10:21:41.208]     }
[10:21:41.208]     ...future.frame <- base::sys.nframe()
[10:21:41.208]     ...future.conditions <- base::list()
[10:21:41.208]     ...future.rng <- base::globalenv()$.Random.seed
[10:21:41.208]     if (FALSE) {
[10:21:41.208]         ...future.globalenv.names <- c(base::names(base::.GlobalEnv), 
[10:21:41.208]             "...future.value", "...future.globalenv.names", ".Random.seed")
[10:21:41.208]     }
[10:21:41.208]     ...future.result <- base::tryCatch({
[10:21:41.208]         base::withCallingHandlers({
[10:21:41.208]             ...future.value <- base::withVisible(base::local({
[10:21:41.208]                 ...future.makeSendCondition <- base::local({
[10:21:41.208]                   sendCondition <- NULL
[10:21:41.208]                   function(frame = 1L) {
[10:21:41.208]                     if (is.function(sendCondition)) 
[10:21:41.208]                       return(sendCondition)
[10:21:41.208]                     ns <- getNamespace("parallel")
[10:21:41.208]                     if (exists("sendData", mode = "function", 
[10:21:41.208]                       envir = ns)) {
[10:21:41.208]                       parallel_sendData <- get("sendData", mode = "function", 
[10:21:41.208]                         envir = ns)
[10:21:41.208]                       envir <- sys.frame(frame)
[10:21:41.208]                       master <- NULL
[10:21:41.208]                       while (!identical(envir, .GlobalEnv) && 
[10:21:41.208]                         !identical(envir, emptyenv())) {
[10:21:41.208]                         if (exists("master", mode = "list", envir = envir, 
[10:21:41.208]                           inherits = FALSE)) {
[10:21:41.208]                           master <- get("master", mode = "list", 
[10:21:41.208]                             envir = envir, inherits = FALSE)
[10:21:41.208]                           if (inherits(master, c("SOCKnode", 
[10:21:41.208]                             "SOCK0node"))) {
[10:21:41.208]                             sendCondition <<- function(cond) {
[10:21:41.208]                               data <- list(type = "VALUE", value = cond, 
[10:21:41.208]                                 success = TRUE)
[10:21:41.208]                               parallel_sendData(master, data)
[10:21:41.208]                             }
[10:21:41.208]                             return(sendCondition)
[10:21:41.208]                           }
[10:21:41.208]                         }
[10:21:41.208]                         frame <- frame + 1L
[10:21:41.208]                         envir <- sys.frame(frame)
[10:21:41.208]                       }
[10:21:41.208]                     }
[10:21:41.208]                     sendCondition <<- function(cond) NULL
[10:21:41.208]                   }
[10:21:41.208]                 })
[10:21:41.208]                 withCallingHandlers({
[10:21:41.208]                   NA
[10:21:41.208]                 }, immediateCondition = function(cond) {
[10:21:41.208]                   sendCondition <- ...future.makeSendCondition()
[10:21:41.208]                   sendCondition(cond)
[10:21:41.208]                   muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:41.208]                   {
[10:21:41.208]                     inherits <- base::inherits
[10:21:41.208]                     invokeRestart <- base::invokeRestart
[10:21:41.208]                     is.null <- base::is.null
[10:21:41.208]                     muffled <- FALSE
[10:21:41.208]                     if (inherits(cond, "message")) {
[10:21:41.208]                       muffled <- grepl(pattern, "muffleMessage")
[10:21:41.208]                       if (muffled) 
[10:21:41.208]                         invokeRestart("muffleMessage")
[10:21:41.208]                     }
[10:21:41.208]                     else if (inherits(cond, "warning")) {
[10:21:41.208]                       muffled <- grepl(pattern, "muffleWarning")
[10:21:41.208]                       if (muffled) 
[10:21:41.208]                         invokeRestart("muffleWarning")
[10:21:41.208]                     }
[10:21:41.208]                     else if (inherits(cond, "condition")) {
[10:21:41.208]                       if (!is.null(pattern)) {
[10:21:41.208]                         computeRestarts <- base::computeRestarts
[10:21:41.208]                         grepl <- base::grepl
[10:21:41.208]                         restarts <- computeRestarts(cond)
[10:21:41.208]                         for (restart in restarts) {
[10:21:41.208]                           name <- restart$name
[10:21:41.208]                           if (is.null(name)) 
[10:21:41.208]                             next
[10:21:41.208]                           if (!grepl(pattern, name)) 
[10:21:41.208]                             next
[10:21:41.208]                           invokeRestart(restart)
[10:21:41.208]                           muffled <- TRUE
[10:21:41.208]                           break
[10:21:41.208]                         }
[10:21:41.208]                       }
[10:21:41.208]                     }
[10:21:41.208]                     invisible(muffled)
[10:21:41.208]                   }
[10:21:41.208]                   muffleCondition(cond)
[10:21:41.208]                 })
[10:21:41.208]             }))
[10:21:41.208]             future::FutureResult(value = ...future.value$value, 
[10:21:41.208]                 visible = ...future.value$visible, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:41.208]                   ...future.rng), globalenv = if (FALSE) 
[10:21:41.208]                   list(added = base::setdiff(base::names(base::.GlobalEnv), 
[10:21:41.208]                     ...future.globalenv.names))
[10:21:41.208]                 else NULL, started = ...future.startTime, version = "1.8")
[10:21:41.208]         }, condition = base::local({
[10:21:41.208]             c <- base::c
[10:21:41.208]             inherits <- base::inherits
[10:21:41.208]             invokeRestart <- base::invokeRestart
[10:21:41.208]             length <- base::length
[10:21:41.208]             list <- base::list
[10:21:41.208]             seq.int <- base::seq.int
[10:21:41.208]             signalCondition <- base::signalCondition
[10:21:41.208]             sys.calls <- base::sys.calls
[10:21:41.208]             `[[` <- base::`[[`
[10:21:41.208]             `+` <- base::`+`
[10:21:41.208]             `<<-` <- base::`<<-`
[10:21:41.208]             sysCalls <- function(calls = sys.calls(), from = 1L) {
[10:21:41.208]                 calls[seq.int(from = from + 12L, to = length(calls) - 
[10:21:41.208]                   3L)]
[10:21:41.208]             }
[10:21:41.208]             function(cond) {
[10:21:41.208]                 is_error <- inherits(cond, "error")
[10:21:41.208]                 ignore <- !is_error && !is.null(NULL) && inherits(cond, 
[10:21:41.208]                   NULL)
[10:21:41.208]                 if (is_error) {
[10:21:41.208]                   sessionInformation <- function() {
[10:21:41.208]                     list(r = base::R.Version(), locale = base::Sys.getlocale(), 
[10:21:41.208]                       rngkind = base::RNGkind(), namespaces = base::loadedNamespaces(), 
[10:21:41.208]                       search = base::search(), system = base::Sys.info())
[10:21:41.208]                   }
[10:21:41.208]                   ...future.conditions[[length(...future.conditions) + 
[10:21:41.208]                     1L]] <<- list(condition = cond, calls = c(sysCalls(from = ...future.frame), 
[10:21:41.208]                     cond$call), session = sessionInformation(), 
[10:21:41.208]                     timestamp = base::Sys.time(), signaled = 0L)
[10:21:41.208]                   signalCondition(cond)
[10:21:41.208]                 }
[10:21:41.208]                 else if (!ignore && TRUE && inherits(cond, c("condition", 
[10:21:41.208]                 "immediateCondition"))) {
[10:21:41.208]                   signal <- TRUE && inherits(cond, "immediateCondition")
[10:21:41.208]                   ...future.conditions[[length(...future.conditions) + 
[10:21:41.208]                     1L]] <<- list(condition = cond, signaled = base::as.integer(signal))
[10:21:41.208]                   if (TRUE && !signal) {
[10:21:41.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:41.208]                     {
[10:21:41.208]                       inherits <- base::inherits
[10:21:41.208]                       invokeRestart <- base::invokeRestart
[10:21:41.208]                       is.null <- base::is.null
[10:21:41.208]                       muffled <- FALSE
[10:21:41.208]                       if (inherits(cond, "message")) {
[10:21:41.208]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:41.208]                         if (muffled) 
[10:21:41.208]                           invokeRestart("muffleMessage")
[10:21:41.208]                       }
[10:21:41.208]                       else if (inherits(cond, "warning")) {
[10:21:41.208]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:41.208]                         if (muffled) 
[10:21:41.208]                           invokeRestart("muffleWarning")
[10:21:41.208]                       }
[10:21:41.208]                       else if (inherits(cond, "condition")) {
[10:21:41.208]                         if (!is.null(pattern)) {
[10:21:41.208]                           computeRestarts <- base::computeRestarts
[10:21:41.208]                           grepl <- base::grepl
[10:21:41.208]                           restarts <- computeRestarts(cond)
[10:21:41.208]                           for (restart in restarts) {
[10:21:41.208]                             name <- restart$name
[10:21:41.208]                             if (is.null(name)) 
[10:21:41.208]                               next
[10:21:41.208]                             if (!grepl(pattern, name)) 
[10:21:41.208]                               next
[10:21:41.208]                             invokeRestart(restart)
[10:21:41.208]                             muffled <- TRUE
[10:21:41.208]                             break
[10:21:41.208]                           }
[10:21:41.208]                         }
[10:21:41.208]                       }
[10:21:41.208]                       invisible(muffled)
[10:21:41.208]                     }
[10:21:41.208]                     muffleCondition(cond, pattern = "^muffle")
[10:21:41.208]                   }
[10:21:41.208]                 }
[10:21:41.208]                 else {
[10:21:41.208]                   if (TRUE) {
[10:21:41.208]                     muffleCondition <- function (cond, pattern = "^muffle") 
[10:21:41.208]                     {
[10:21:41.208]                       inherits <- base::inherits
[10:21:41.208]                       invokeRestart <- base::invokeRestart
[10:21:41.208]                       is.null <- base::is.null
[10:21:41.208]                       muffled <- FALSE
[10:21:41.208]                       if (inherits(cond, "message")) {
[10:21:41.208]                         muffled <- grepl(pattern, "muffleMessage")
[10:21:41.208]                         if (muffled) 
[10:21:41.208]                           invokeRestart("muffleMessage")
[10:21:41.208]                       }
[10:21:41.208]                       else if (inherits(cond, "warning")) {
[10:21:41.208]                         muffled <- grepl(pattern, "muffleWarning")
[10:21:41.208]                         if (muffled) 
[10:21:41.208]                           invokeRestart("muffleWarning")
[10:21:41.208]                       }
[10:21:41.208]                       else if (inherits(cond, "condition")) {
[10:21:41.208]                         if (!is.null(pattern)) {
[10:21:41.208]                           computeRestarts <- base::computeRestarts
[10:21:41.208]                           grepl <- base::grepl
[10:21:41.208]                           restarts <- computeRestarts(cond)
[10:21:41.208]                           for (restart in restarts) {
[10:21:41.208]                             name <- restart$name
[10:21:41.208]                             if (is.null(name)) 
[10:21:41.208]                               next
[10:21:41.208]                             if (!grepl(pattern, name)) 
[10:21:41.208]                               next
[10:21:41.208]                             invokeRestart(restart)
[10:21:41.208]                             muffled <- TRUE
[10:21:41.208]                             break
[10:21:41.208]                           }
[10:21:41.208]                         }
[10:21:41.208]                       }
[10:21:41.208]                       invisible(muffled)
[10:21:41.208]                     }
[10:21:41.208]                     muffleCondition(cond, pattern = "^muffle")
[10:21:41.208]                   }
[10:21:41.208]                 }
[10:21:41.208]             }
[10:21:41.208]         }))
[10:21:41.208]     }, error = function(ex) {
[10:21:41.208]         base::structure(base::list(value = NULL, visible = NULL, 
[10:21:41.208]             conditions = ...future.conditions, rng = !identical(base::globalenv()$.Random.seed, 
[10:21:41.208]                 ...future.rng), started = ...future.startTime, 
[10:21:41.208]             finished = Sys.time(), session_uuid = NA_character_, 
[10:21:41.208]             version = "1.8"), class = "FutureResult")
[10:21:41.208]     }, finally = {
[10:21:41.208]         if (!identical(...future.workdir, getwd())) 
[10:21:41.208]             setwd(...future.workdir)
[10:21:41.208]         {
[10:21:41.208]             if (identical(getOption("nwarnings"), ...future.oldOptions$nwarnings)) {
[10:21:41.208]                 ...future.oldOptions$nwarnings <- NULL
[10:21:41.208]             }
[10:21:41.208]             base::options(...future.oldOptions)
[10:21:41.208]             if (.Platform$OS.type == "windows") {
[10:21:41.208]                 old_names <- names(...future.oldEnvVars)
[10:21:41.208]                 envs <- base::Sys.getenv()
[10:21:41.208]                 names <- names(envs)
[10:21:41.208]                 common <- intersect(names, old_names)
[10:21:41.208]                 added <- setdiff(names, old_names)
[10:21:41.208]                 removed <- setdiff(old_names, names)
[10:21:41.208]                 changed <- common[...future.oldEnvVars[common] != 
[10:21:41.208]                   envs[common]]
[10:21:41.208]                 NAMES <- toupper(changed)
[10:21:41.208]                 args <- list()
[10:21:41.208]                 for (kk in seq_along(NAMES)) {
[10:21:41.208]                   name <- changed[[kk]]
[10:21:41.208]                   NAME <- NAMES[[kk]]
[10:21:41.208]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:41.208]                     next
[10:21:41.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:41.208]                 }
[10:21:41.208]                 NAMES <- toupper(added)
[10:21:41.208]                 for (kk in seq_along(NAMES)) {
[10:21:41.208]                   name <- added[[kk]]
[10:21:41.208]                   NAME <- NAMES[[kk]]
[10:21:41.208]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:41.208]                     next
[10:21:41.208]                   args[[name]] <- ""
[10:21:41.208]                 }
[10:21:41.208]                 NAMES <- toupper(removed)
[10:21:41.208]                 for (kk in seq_along(NAMES)) {
[10:21:41.208]                   name <- removed[[kk]]
[10:21:41.208]                   NAME <- NAMES[[kk]]
[10:21:41.208]                   if (name != NAME && is.element(NAME, old_names)) 
[10:21:41.208]                     next
[10:21:41.208]                   args[[name]] <- ...future.oldEnvVars[[name]]
[10:21:41.208]                 }
[10:21:41.208]                 if (length(args) > 0) 
[10:21:41.208]                   base::do.call(base::Sys.setenv, args = args)
[10:21:41.208]                 args <- names <- old_names <- NAMES <- envs <- common <- added <- removed <- NULL
[10:21:41.208]             }
[10:21:41.208]             else {
[10:21:41.208]                 base::do.call(base::Sys.setenv, args = base::as.list(...future.oldEnvVars))
[10:21:41.208]             }
[10:21:41.208]             {
[10:21:41.208]                 if (base::length(...future.futureOptionsAdded) > 
[10:21:41.208]                   0L) {
[10:21:41.208]                   opts <- base::vector("list", length = base::length(...future.futureOptionsAdded))
[10:21:41.208]                   base::names(opts) <- ...future.futureOptionsAdded
[10:21:41.208]                   base::options(opts)
[10:21:41.208]                 }
[10:21:41.208]                 {
[10:21:41.208]                   {
[10:21:41.208]                     base::options(mc.cores = ...future.mc.cores.old)
[10:21:41.208]                     NULL
[10:21:41.208]                   }
[10:21:41.208]                   options(future.plan = NULL)
[10:21:41.208]                   if (is.na(NA_character_)) 
[10:21:41.208]                     Sys.unsetenv("R_FUTURE_PLAN")
[10:21:41.208]                   else Sys.setenv(R_FUTURE_PLAN = NA_character_)
[10:21:41.208]                   future::plan(...future.strategy.old, .cleanup = FALSE, 
[10:21:41.208]                     .init = FALSE)
[10:21:41.208]                 }
[10:21:41.208]             }
[10:21:41.208]         }
[10:21:41.208]     })
[10:21:41.208]     if (TRUE) {
[10:21:41.208]         base::sink(type = "output", split = FALSE)
[10:21:41.208]         if (TRUE) {
[10:21:41.208]             ...future.result$stdout <- base::rawToChar(base::rawConnectionValue(...future.stdout))
[10:21:41.208]         }
[10:21:41.208]         else {
[10:21:41.208]             ...future.result["stdout"] <- base::list(NULL)
[10:21:41.208]         }
[10:21:41.208]         base::close(...future.stdout)
[10:21:41.208]         ...future.stdout <- NULL
[10:21:41.208]     }
[10:21:41.208]     ...future.result$conditions <- ...future.conditions
[10:21:41.208]     ...future.result$finished <- base::Sys.time()
[10:21:41.208]     ...future.result
[10:21:41.208] }
[10:21:41.262] MultisessionFuture started
[10:21:41.262] result() for ClusterFuture ...
[10:21:41.263] receiveMessageFromWorker() for ClusterFuture ...
[10:21:41.263] - Validating connection of MultisessionFuture
[10:21:41.294] - received message: FutureResult
[10:21:41.294] - Received FutureResult
[10:21:41.296] - Erased future from FutureRegistry
[10:21:41.297] result() for ClusterFuture ...
[10:21:41.297] - result already collected: FutureResult
[10:21:41.297] result() for ClusterFuture ... done
[10:21:41.297] receiveMessageFromWorker() for ClusterFuture ... done
[10:21:41.297] result() for ClusterFuture ... done
[10:21:41.297] result() for ClusterFuture ...
[10:21:41.297] - result already collected: FutureResult
[10:21:41.297] result() for ClusterFuture ... done
[10:21:41.298] plan(): plan_init() of ‘multisession’, ‘cluster’, ‘multiprocess’, ‘future’, ‘function’ ... DONE
[10:21:41.299] plan(): nbrOfWorkers() = 2
> 
> exprs <- list(
+   A = substitute({ a                 }, env = list()),
+   B = substitute({ a * b             }, env = list()),
+   C = substitute({ a * b * c         }, env = list()),
+   D = substitute({ a * b * c * d     }, env = list()),
+   E = substitute({ a * b * c * d * e }, env = list())
+ )
> 
> a <- integer(length = 1000)
> b <- integer(length =  900)
> c <- integer(length =  800)
> d <- integer(length =  700)
> e <- integer(length =    1)
> 
> for (name in names(exprs)) {
+   message(sprintf("Expression %s:", name))
+   expr <- exprs[[name]]
+   print(expr)
+   res <- tryCatch({
+     f <- future(expr, substitute = FALSE)
+   }, error = function(ex) ex)
+   print(res)
+   stopifnot(inherits(res, "error"))
+   msg <- conditionMessage(res)
+   stopifnot(grepl("exceeds the maximum allowed size", msg))
+ }
Expression A:
{
    a
}
[10:21:41.305] getGlobalsAndPackages() ...
[10:21:41.306] Searching for globals...
[10:21:41.308] - globals found: [2] ‘{’, ‘a’
[10:21:41.309] Searching for globals ... DONE
[10:21:41.309] Resolving globals: FALSE
[10:21:41.310] The total size of the 1 globals is 3.94 KiB (4031 bytes)
[10:21:41.310] The total size of the 1 globals exported for future expression (‘{; a; }’) is 3.94 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.94 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 1 globals exported for future expression (‘{; a; }’) is 3.94 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). There is one global: ‘a’ (3.94 KiB of class ‘numeric’)>
Expression B:
{
    a * b
}
[10:21:41.310] getGlobalsAndPackages() ...
[10:21:41.310] Searching for globals...
[10:21:41.314] - globals found: [4] ‘{’, ‘*’, ‘a’, ‘b’
[10:21:41.314] Searching for globals ... DONE
[10:21:41.314] Resolving globals: FALSE
[10:21:41.315] The total size of the 2 globals is 7.48 KiB (7662 bytes)
[10:21:41.315] The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 7.48 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (3.94 KiB of class ‘numeric’) and ‘b’ (3.55 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 2 globals exported for future expression (‘{; a * b; }’) is 7.48 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). There are two globals: ‘a’ (3.94 KiB of class ‘numeric’) and ‘b’ (3.55 KiB of class ‘numeric’)>
Expression C:
{
    a * b * c
}
[10:21:41.316] getGlobalsAndPackages() ...
[10:21:41.316] Searching for globals...
[10:21:41.317] - globals found: [5] ‘{’, ‘*’, ‘a’, ‘b’, ‘c’
[10:21:41.317] Searching for globals ... DONE
[10:21:41.317] Resolving globals: FALSE
[10:21:41.317] The total size of the 3 globals is 10.64 KiB (10893 bytes)
[10:21:41.318] The total size of the 3 globals exported for future expression (‘{; a * b * c; }’) is 10.64 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). There are three globals: ‘a’ (3.94 KiB of class ‘numeric’), ‘b’ (3.55 KiB of class ‘numeric’) and ‘c’ (3.16 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 3 globals exported for future expression (‘{; a * b * c; }’) is 10.64 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). There are three globals: ‘a’ (3.94 KiB of class ‘numeric’), ‘b’ (3.55 KiB of class ‘numeric’) and ‘c’ (3.16 KiB of class ‘numeric’)>
Expression D:
{
    a * b * c * d
}
[10:21:41.318] getGlobalsAndPackages() ...
[10:21:41.318] Searching for globals...
[10:21:41.320] - globals found: [6] ‘{’, ‘*’, ‘a’, ‘b’, ‘c’, ‘d’
[10:21:41.320] Searching for globals ... DONE
[10:21:41.320] Resolving globals: FALSE
[10:21:41.320] The total size of the 4 globals is 13.40 KiB (13724 bytes)
[10:21:41.321] The total size of the 4 globals exported for future expression (‘{; a * b * c * d; }’) is 13.40 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.94 KiB of class ‘numeric’), ‘b’ (3.55 KiB of class ‘numeric’) and ‘c’ (3.16 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 4 globals exported for future expression (‘{; a * b * c * d; }’) is 13.40 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.94 KiB of class ‘numeric’), ‘b’ (3.55 KiB of class ‘numeric’) and ‘c’ (3.16 KiB of class ‘numeric’)>
Expression E:
{
    a * b * c * d * e
}
[10:21:41.321] getGlobalsAndPackages() ...
[10:21:41.321] Searching for globals...
[10:21:41.323] - globals found: [7] ‘{’, ‘*’, ‘a’, ‘b’, ‘c’, ‘d’, ‘e’
[10:21:41.323] Searching for globals ... DONE
[10:21:41.323] Resolving globals: FALSE
[10:21:41.324] The total size of the 5 globals is 13.44 KiB (13759 bytes)
[10:21:41.324] The total size of the 5 globals exported for future expression (‘{; a * b * c * d * e; }’) is 13.44 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.94 KiB of class ‘numeric’), ‘b’ (3.55 KiB of class ‘numeric’) and ‘c’ (3.16 KiB of class ‘numeric’)
<simpleError in getGlobalsAndPackages(expr, envir = envir, tweak = tweakExpression,     globals = globals): The total size of the 5 globals exported for future expression (‘{; a * b * c * d * e; }’) is 13.44 KiB.. This exceeds the maximum allowed size of 3.86 KiB (option 'future.globals.maxSize'). The three largest globals are ‘a’ (3.94 KiB of class ‘numeric’), ‘b’ (3.55 KiB of class ‘numeric’) and ‘c’ (3.16 KiB of class ‘numeric’)>
> 
> message("*** Globals - too large ... DONE")
*** Globals - too large ... DONE
> 
> source("incl/end.R")
[10:21:41.325] plan(): Setting new future strategy stack:
[10:21:41.325] List of future strategies:
[10:21:41.325] 1. FutureStrategy:
[10:21:41.325]    - args: function (..., envir = parent.frame(), workers = "<NULL>")
[10:21:41.325]    - tweaked: FALSE
[10:21:41.325]    - call: future::plan(oplan)
[10:21:41.326] plan(): nbrOfWorkers() = 1
> 
